// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension PersonalizeClientTypes.Algorithm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn
        case algorithmImage
        case creationDateTime
        case defaultHyperParameterRanges
        case defaultHyperParameters
        case defaultResourceConfig
        case lastUpdatedDateTime
        case name
        case roleArn
        case trainingInputMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = self.algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let algorithmImage = self.algorithmImage {
            try encodeContainer.encode(algorithmImage, forKey: .algorithmImage)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let defaultHyperParameterRanges = self.defaultHyperParameterRanges {
            try encodeContainer.encode(defaultHyperParameterRanges, forKey: .defaultHyperParameterRanges)
        }
        if let defaultHyperParameters = defaultHyperParameters {
            var defaultHyperParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .defaultHyperParameters)
            for (dictKey0, hyperParameters0) in defaultHyperParameters {
                try defaultHyperParametersContainer.encode(hyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let defaultResourceConfig = defaultResourceConfig {
            var defaultResourceConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .defaultResourceConfig)
            for (dictKey0, resourceConfig0) in defaultResourceConfig {
                try defaultResourceConfigContainer.encode(resourceConfig0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let trainingInputMode = self.trainingInputMode {
            try encodeContainer.encode(trainingInputMode, forKey: .trainingInputMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let algorithmImageDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.AlgorithmImage.self, forKey: .algorithmImage)
        algorithmImage = algorithmImageDecoded
        let defaultHyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .defaultHyperParameters)
        var defaultHyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let defaultHyperParametersContainer = defaultHyperParametersContainer {
            defaultHyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in defaultHyperParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    defaultHyperParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        defaultHyperParameters = defaultHyperParametersDecoded0
        let defaultHyperParameterRangesDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DefaultHyperParameterRanges.self, forKey: .defaultHyperParameterRanges)
        defaultHyperParameterRanges = defaultHyperParameterRangesDecoded
        let defaultResourceConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .defaultResourceConfig)
        var defaultResourceConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let defaultResourceConfigContainer = defaultResourceConfigContainer {
            defaultResourceConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in defaultResourceConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    defaultResourceConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        defaultResourceConfig = defaultResourceConfigDecoded0
        let trainingInputModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trainingInputMode)
        trainingInputMode = trainingInputModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes a custom algorithm.
    public struct Algorithm: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the algorithm.
        public var algorithmArn: Swift.String?
        /// The URI of the Docker container for the algorithm image.
        public var algorithmImage: PersonalizeClientTypes.AlgorithmImage?
        /// The date and time (in Unix time) that the algorithm was created.
        public var creationDateTime: ClientRuntime.Date?
        /// Specifies the default hyperparameters, their ranges, and whether they are tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
        public var defaultHyperParameterRanges: PersonalizeClientTypes.DefaultHyperParameterRanges?
        /// Specifies the default hyperparameters.
        public var defaultHyperParameters: [Swift.String:Swift.String]?
        /// Specifies the default maximum number of training jobs and parallel training jobs.
        public var defaultResourceConfig: [Swift.String:Swift.String]?
        /// The date and time (in Unix time) that the algorithm was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the algorithm.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the role.
        public var roleArn: Swift.String?
        /// The training input mode.
        public var trainingInputMode: Swift.String?

        public init(
            algorithmArn: Swift.String? = nil,
            algorithmImage: PersonalizeClientTypes.AlgorithmImage? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            defaultHyperParameterRanges: PersonalizeClientTypes.DefaultHyperParameterRanges? = nil,
            defaultHyperParameters: [Swift.String:Swift.String]? = nil,
            defaultResourceConfig: [Swift.String:Swift.String]? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            trainingInputMode: Swift.String? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.algorithmImage = algorithmImage
            self.creationDateTime = creationDateTime
            self.defaultHyperParameterRanges = defaultHyperParameterRanges
            self.defaultHyperParameters = defaultHyperParameters
            self.defaultResourceConfig = defaultResourceConfig
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.trainingInputMode = trainingInputMode
        }
    }

}

extension PersonalizeClientTypes.AlgorithmImage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dockerURI
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dockerURI = self.dockerURI {
            try encodeContainer.encode(dockerURI, forKey: .dockerURI)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dockerURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dockerURI)
        dockerURI = dockerURIDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes an algorithm image.
    public struct AlgorithmImage: Swift.Equatable {
        /// The URI of the Docker container for the algorithm image.
        /// This member is required.
        public var dockerURI: Swift.String?
        /// The name of the algorithm image.
        public var name: Swift.String?

        public init(
            dockerURI: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.dockerURI = dockerURI
            self.name = name
        }
    }

}

extension PersonalizeClientTypes.AutoMLConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName
        case recipeList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let recipeList = recipeList {
            var recipeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recipeList)
            for arn0 in recipeList {
                try recipeListContainer.encode(arn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let recipeListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recipeList)
        var recipeListDecoded0:[Swift.String]? = nil
        if let recipeListContainer = recipeListContainer {
            recipeListDecoded0 = [Swift.String]()
            for string0 in recipeListContainer {
                if let string0 = string0 {
                    recipeListDecoded0?.append(string0)
                }
            }
        }
        recipeList = recipeListDecoded0
    }
}

extension PersonalizeClientTypes {
    /// When the solution performs AutoML (performAutoML is true in [CreateSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSolution.html)), Amazon Personalize determines which recipe, from the specified list, optimizes the given metric. Amazon Personalize then uses that recipe for the solution.
    public struct AutoMLConfig: Swift.Equatable {
        /// The metric to optimize.
        public var metricName: Swift.String?
        /// The list of candidate recipes.
        public var recipeList: [Swift.String]?

        public init(
            metricName: Swift.String? = nil,
            recipeList: [Swift.String]? = nil
        )
        {
            self.metricName = metricName
            self.recipeList = recipeList
        }
    }

}

extension PersonalizeClientTypes.AutoMLResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bestRecipeArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bestRecipeArn = self.bestRecipeArn {
            try encodeContainer.encode(bestRecipeArn, forKey: .bestRecipeArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bestRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bestRecipeArn)
        bestRecipeArn = bestRecipeArnDecoded
    }
}

extension PersonalizeClientTypes {
    /// When the solution performs AutoML (performAutoML is true in [CreateSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSolution.html)), specifies the recipe that best optimized the specified metric.
    public struct AutoMLResult: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the best recipe.
        public var bestRecipeArn: Swift.String?

        public init(
            bestRecipeArn: Swift.String? = nil
        )
        {
            self.bestRecipeArn = bestRecipeArn
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
        case batchInferenceJobConfig
        case creationDateTime
        case failureReason
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case lastUpdatedDateTime
        case numResults
        case roleArn
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobArn = self.batchInferenceJobArn {
            try encodeContainer.encode(batchInferenceJobArn, forKey: .batchInferenceJobArn)
        }
        if let batchInferenceJobConfig = self.batchInferenceJobConfig {
            try encodeContainer.encode(batchInferenceJobConfig, forKey: .batchInferenceJobConfig)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let jobInput = self.jobInput {
            try encodeContainer.encode(jobInput, forKey: .jobInput)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = self.jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let numResults = self.numResults {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let jobInputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobInput.self, forKey: .jobInput)
        jobInput = jobInputDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let batchInferenceJobConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobConfig.self, forKey: .batchInferenceJobConfig)
        batchInferenceJobConfig = batchInferenceJobConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Contains information on a batch inference job.
    public struct BatchInferenceJob: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public var batchInferenceJobArn: Swift.String?
        /// A string to string map of the configuration details of a batch inference job.
        public var batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig?
        /// The time at which the batch inference job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If the batch inference job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter used on the batch inference job.
        public var filterArn: Swift.String?
        /// The Amazon S3 path that leads to the input data used to generate the batch inference job.
        public var jobInput: PersonalizeClientTypes.BatchInferenceJobInput?
        /// The name of the batch inference job.
        public var jobName: Swift.String?
        /// The Amazon S3 bucket that contains the output data generated by the batch inference job.
        public var jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput?
        /// The time at which the batch inference job was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The number of recommendations generated by the batch inference job. This number includes the error messages generated for failed input records.
        public var numResults: Swift.Int?
        /// The ARN of the Amazon Identity and Access Management (IAM) role that requested the batch inference job.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the solution version from which the batch inference job was created.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch inference job. The status is one of the following values:
        ///
        /// * PENDING
        ///
        /// * IN PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        public var status: Swift.String?

        public init(
            batchInferenceJobArn: Swift.String? = nil,
            batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            jobInput: PersonalizeClientTypes.BatchInferenceJobInput? = nil,
            jobName: Swift.String? = nil,
            jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            numResults: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.batchInferenceJobConfig = batchInferenceJobConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJobConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemExplorationConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemExplorationConfig = itemExplorationConfig {
            var itemExplorationConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .itemExplorationConfig)
            for (dictKey0, hyperParameters0) in itemExplorationConfig {
                try itemExplorationConfigContainer.encode(hyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemExplorationConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .itemExplorationConfig)
        var itemExplorationConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let itemExplorationConfigContainer = itemExplorationConfigContainer {
            itemExplorationConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in itemExplorationConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    itemExplorationConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        itemExplorationConfig = itemExplorationConfigDecoded0
    }
}

extension PersonalizeClientTypes {
    /// The configuration details of a batch inference job.
    public struct BatchInferenceJobConfig: Swift.Equatable {
        /// A string to string map specifying the exploration configuration hyperparameters, including explorationWeight and explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items. See [User-Personalization](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html).
        public var itemExplorationConfig: [Swift.String:Swift.String]?

        public init(
            itemExplorationConfig: [Swift.String:Swift.String]? = nil
        )
        {
            self.itemExplorationConfig = itemExplorationConfig
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJobInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataSource = self.s3DataSource {
            try encodeContainer.encode(s3DataSource, forKey: .s3DataSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataSourceDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataSource)
        s3DataSource = s3DataSourceDecoded
    }
}

extension PersonalizeClientTypes {
    /// The input configuration of a batch inference job.
    public struct BatchInferenceJobInput: Swift.Equatable {
        /// The URI of the Amazon S3 location that contains your input data. The Amazon S3 bucket must be in the same region as the API endpoint you are calling.
        /// This member is required.
        public var s3DataSource: PersonalizeClientTypes.S3DataConfig?

        public init(
            s3DataSource: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataSource = s3DataSource
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJobOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataDestination = self.s3DataDestination {
            try encodeContainer.encode(s3DataDestination, forKey: .s3DataDestination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDestinationDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataDestination)
        s3DataDestination = s3DataDestinationDecoded
    }
}

extension PersonalizeClientTypes {
    /// The output configuration parameters of a batch inference job.
    public struct BatchInferenceJobOutput: Swift.Equatable {
        /// Information on the Amazon S3 bucket in which the batch inference job's output is stored.
        /// This member is required.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init(
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataDestination = s3DataDestination
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
        case creationDateTime
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobArn = self.batchInferenceJobArn {
            try encodeContainer.encode(batchInferenceJobArn, forKey: .batchInferenceJobArn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension PersonalizeClientTypes {
    /// A truncated version of the [BatchInferenceJob](https://docs.aws.amazon.com/personalize/latest/dg/API_BatchInferenceJob.html). The [ListBatchInferenceJobs](https://docs.aws.amazon.com/personalize/latest/dg/API_ListBatchInferenceJobs.html) operation returns a list of batch inference job summaries.
    public struct BatchInferenceJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public var batchInferenceJobArn: Swift.String?
        /// The time at which the batch inference job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If the batch inference job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The name of the batch inference job.
        public var jobName: Swift.String?
        /// The time at which the batch inference job was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The ARN of the solution version used by the batch inference job.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch inference job. The status is one of the following values:
        ///
        /// * PENDING
        ///
        /// * IN PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        public var status: Swift.String?

        public init(
            batchInferenceJobArn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.BatchSegmentJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJobArn
        case creationDateTime
        case failureReason
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case lastUpdatedDateTime
        case numResults
        case roleArn
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSegmentJobArn = self.batchSegmentJobArn {
            try encodeContainer.encode(batchSegmentJobArn, forKey: .batchSegmentJobArn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let jobInput = self.jobInput {
            try encodeContainer.encode(jobInput, forKey: .jobInput)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = self.jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let numResults = self.numResults {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let batchSegmentJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchSegmentJobArn)
        batchSegmentJobArn = batchSegmentJobArnDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let jobInputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchSegmentJobInput.self, forKey: .jobInput)
        jobInput = jobInputDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchSegmentJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Contains information on a batch segment job.
    public struct BatchSegmentJob: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the batch segment job.
        public var batchSegmentJobArn: Swift.String?
        /// The time at which the batch segment job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If the batch segment job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter used on the batch segment job.
        public var filterArn: Swift.String?
        /// The Amazon S3 path that leads to the input data used to generate the batch segment job.
        public var jobInput: PersonalizeClientTypes.BatchSegmentJobInput?
        /// The name of the batch segment job.
        public var jobName: Swift.String?
        /// The Amazon S3 bucket that contains the output data generated by the batch segment job.
        public var jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput?
        /// The time at which the batch segment job last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The number of predicted users generated by the batch segment job for each line of input data. The maximum number of users per segment is 5 million.
        public var numResults: Swift.Int?
        /// The ARN of the Amazon Identity and Access Management (IAM) role that requested the batch segment job.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the solution version used by the batch segment job to generate batch segments.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch segment job. The status is one of the following values:
        ///
        /// * PENDING
        ///
        /// * IN PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        public var status: Swift.String?

        public init(
            batchSegmentJobArn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            jobInput: PersonalizeClientTypes.BatchSegmentJobInput? = nil,
            jobName: Swift.String? = nil,
            jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            numResults: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.batchSegmentJobArn = batchSegmentJobArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.BatchSegmentJobInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataSource = self.s3DataSource {
            try encodeContainer.encode(s3DataSource, forKey: .s3DataSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataSourceDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataSource)
        s3DataSource = s3DataSourceDecoded
    }
}

extension PersonalizeClientTypes {
    /// The input configuration of a batch segment job.
    public struct BatchSegmentJobInput: Swift.Equatable {
        /// The configuration details of an Amazon S3 input or output bucket.
        /// This member is required.
        public var s3DataSource: PersonalizeClientTypes.S3DataConfig?

        public init(
            s3DataSource: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataSource = s3DataSource
        }
    }

}

extension PersonalizeClientTypes.BatchSegmentJobOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataDestination = self.s3DataDestination {
            try encodeContainer.encode(s3DataDestination, forKey: .s3DataDestination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDestinationDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataDestination)
        s3DataDestination = s3DataDestinationDecoded
    }
}

extension PersonalizeClientTypes {
    /// The output configuration parameters of a batch segment job.
    public struct BatchSegmentJobOutput: Swift.Equatable {
        /// The configuration details of an Amazon S3 input or output bucket.
        /// This member is required.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init(
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataDestination = s3DataDestination
        }
    }

}

extension PersonalizeClientTypes.BatchSegmentJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJobArn
        case creationDateTime
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSegmentJobArn = self.batchSegmentJobArn {
            try encodeContainer.encode(batchSegmentJobArn, forKey: .batchSegmentJobArn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchSegmentJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchSegmentJobArn)
        batchSegmentJobArn = batchSegmentJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension PersonalizeClientTypes {
    /// A truncated version of the [BatchSegmentJob](https://docs.aws.amazon.com/personalize/latest/dg/API_BatchSegmentJob.html) datatype. [ListBatchSegmentJobs](https://docs.aws.amazon.com/personalize/latest/dg/API_ListBatchSegmentJobs.html) operation returns a list of batch segment job summaries.
    public struct BatchSegmentJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the batch segment job.
        public var batchSegmentJobArn: Swift.String?
        /// The time at which the batch segment job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If the batch segment job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The name of the batch segment job.
        public var jobName: Swift.String?
        /// The time at which the batch segment job was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the solution version used by the batch segment job to generate batch segments.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch segment job. The status is one of the following values:
        ///
        /// * PENDING
        ///
        /// * IN PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        public var status: Swift.String?

        public init(
            batchSegmentJobArn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.batchSegmentJobArn = batchSegmentJobArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.Campaign: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case campaignConfig
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case latestCampaignUpdate
        case minProvisionedTPS
        case name
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let campaignConfig = self.campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let latestCampaignUpdate = self.latestCampaignUpdate {
            try encodeContainer.encode(latestCampaignUpdate, forKey: .latestCampaignUpdate)
        }
        if let minProvisionedTPS = self.minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let latestCampaignUpdateDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignUpdateSummary.self, forKey: .latestCampaignUpdate)
        latestCampaignUpdate = latestCampaignUpdateDecoded
    }
}

extension PersonalizeClientTypes {
    /// An object that describes the deployment of a solution version. For more information on campaigns, see [CreateCampaign](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateCampaign.html).
    public struct Campaign: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the campaign.
        public var campaignArn: Swift.String?
        /// The configuration details of a campaign.
        public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
        /// The date and time (in Unix format) that the campaign was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a campaign fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix format) that the campaign was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Provides a summary of the properties of a campaign update. For a complete listing, call the [DescribeCampaign](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeCampaign.html) API.
        public var latestCampaignUpdate: PersonalizeClientTypes.CampaignUpdateSummary?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second. A high minProvisionedTPS will increase your bill. We recommend starting with 1 for minProvisionedTPS (the default). Track your usage using Amazon CloudWatch metrics, and increase the minProvisionedTPS as necessary.
        public var minProvisionedTPS: Swift.Int?
        /// The name of the campaign.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of a specific version of the solution.
        public var solutionVersionArn: Swift.String?
        /// The status of the campaign. A campaign can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            campaignArn: Swift.String? = nil,
            campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            latestCampaignUpdate: PersonalizeClientTypes.CampaignUpdateSummary? = nil,
            minProvisionedTPS: Swift.Int? = nil,
            name: Swift.String? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.campaignArn = campaignArn
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestCampaignUpdate = latestCampaignUpdate
            self.minProvisionedTPS = minProvisionedTPS
            self.name = name
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.CampaignConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemExplorationConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemExplorationConfig = itemExplorationConfig {
            var itemExplorationConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .itemExplorationConfig)
            for (dictKey0, hyperParameters0) in itemExplorationConfig {
                try itemExplorationConfigContainer.encode(hyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemExplorationConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .itemExplorationConfig)
        var itemExplorationConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let itemExplorationConfigContainer = itemExplorationConfigContainer {
            itemExplorationConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in itemExplorationConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    itemExplorationConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        itemExplorationConfig = itemExplorationConfigDecoded0
    }
}

extension PersonalizeClientTypes {
    /// The configuration details of a campaign.
    public struct CampaignConfig: Swift.Equatable {
        /// Specifies the exploration configuration hyperparameters, including explorationWeight and explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items. Provide itemExplorationConfig data only if your solution uses the [User-Personalization](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html) recipe.
        public var itemExplorationConfig: [Swift.String:Swift.String]?

        public init(
            itemExplorationConfig: [Swift.String:Swift.String]? = nil
        )
        {
            self.itemExplorationConfig = itemExplorationConfig
        }
    }

}

extension PersonalizeClientTypes.CampaignSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a campaign. For a complete listing, call the [DescribeCampaign](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeCampaign.html) API.
    public struct CampaignSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the campaign.
        public var campaignArn: Swift.String?
        /// The date and time (in Unix time) that the campaign was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a campaign fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the campaign was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the campaign.
        public var name: Swift.String?
        /// The status of the campaign. A campaign can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            campaignArn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.campaignArn = campaignArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.CampaignUpdateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignConfig
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case minProvisionedTPS
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignConfig = self.campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let minProvisionedTPS = self.minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a campaign update. For a complete listing, call the [DescribeCampaign](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeCampaign.html) API.
    public struct CampaignUpdateSummary: Swift.Equatable {
        /// The configuration details of a campaign.
        public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
        /// The date and time (in Unix time) that the campaign update was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a campaign update fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the campaign update was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
        public var minProvisionedTPS: Swift.Int?
        /// The Amazon Resource Name (ARN) of the deployed solution version.
        public var solutionVersionArn: Swift.String?
        /// The status of the campaign update. A campaign update can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            minProvisionedTPS: Swift.Int? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.minProvisionedTPS = minProvisionedTPS
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.CategoricalHyperParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for categoricalvalue0 in values {
                try valuesContainer.encode(categoricalvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PersonalizeClientTypes {
    /// Provides the name and range of a categorical hyperparameter.
    public struct CategoricalHyperParameterRange: Swift.Equatable {
        /// The name of the hyperparameter.
        public var name: Swift.String?
        /// A list of the categories for the hyperparameter.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PersonalizeClientTypes.ContinuousHyperParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxValue != 0.0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0.0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minValue) ?? 0.0
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxValue) ?? 0.0
        maxValue = maxValueDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides the name and range of a continuous hyperparameter.
    public struct ContinuousHyperParameterRange: Swift.Equatable {
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Double
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Double
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init(
            maxValue: Swift.Double = 0.0,
            minValue: Swift.Double = 0.0,
            name: Swift.String? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }

}

extension CreateBatchInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobConfig
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case numResults
        case roleArn
        case solutionVersionArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobConfig = self.batchInferenceJobConfig {
            try encodeContainer.encode(batchInferenceJobConfig, forKey: .batchInferenceJobConfig)
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let jobInput = self.jobInput {
            try encodeContainer.encode(jobInput, forKey: .jobInput)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = self.jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let numResults = self.numResults {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateBatchInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateBatchInferenceJobInput: Swift.Equatable {
    /// The configuration details of a batch inference job.
    public var batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig?
    /// The ARN of the filter to apply to the batch inference job. For more information on using filters, see [Filtering batch recommendations](https://docs.aws.amazon.com/personalize/latest/dg/filter-batch.html).
    public var filterArn: Swift.String?
    /// The Amazon S3 path that leads to the input file to base your recommendations on. The input material must be in JSON format.
    /// This member is required.
    public var jobInput: PersonalizeClientTypes.BatchInferenceJobInput?
    /// The name of the batch inference job to create.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the Amazon S3 bucket where the job's output will be stored.
    /// This member is required.
    public var jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput?
    /// The number of recommendations to retrieve.
    public var numResults: Swift.Int?
    /// The ARN of the Amazon Identity and Access Management role that has permissions to read and write to your input and output Amazon S3 buckets respectively.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version that will be used to generate the batch inference recommendations.
    /// This member is required.
    public var solutionVersionArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the batch inference job.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig? = nil,
        filterArn: Swift.String? = nil,
        jobInput: PersonalizeClientTypes.BatchInferenceJobInput? = nil,
        jobName: Swift.String? = nil,
        jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput? = nil,
        numResults: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.batchInferenceJobConfig = batchInferenceJobConfig
        self.filterArn = filterArn
        self.jobInput = jobInput
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.numResults = numResults
        self.roleArn = roleArn
        self.solutionVersionArn = solutionVersionArn
        self.tags = tags
    }
}

struct CreateBatchInferenceJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let solutionVersionArn: Swift.String?
    let filterArn: Swift.String?
    let numResults: Swift.Int?
    let jobInput: PersonalizeClientTypes.BatchInferenceJobInput?
    let jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput?
    let roleArn: Swift.String?
    let batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateBatchInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobConfig
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case numResults
        case roleArn
        case solutionVersionArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let jobInputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobInput.self, forKey: .jobInput)
        jobInput = jobInputDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let batchInferenceJobConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobConfig.self, forKey: .batchInferenceJobConfig)
        batchInferenceJobConfig = batchInferenceJobConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBatchInferenceJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBatchInferenceJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchInferenceJobArn = output.batchInferenceJobArn
        } else {
            self.batchInferenceJobArn = nil
        }
    }
}

public struct CreateBatchInferenceJobOutput: Swift.Equatable {
    /// The ARN of the batch inference job.
    public var batchInferenceJobArn: Swift.String?

    public init(
        batchInferenceJobArn: Swift.String? = nil
    )
    {
        self.batchInferenceJobArn = batchInferenceJobArn
    }
}

struct CreateBatchInferenceJobOutputBody: Swift.Equatable {
    let batchInferenceJobArn: Swift.String?
}

extension CreateBatchInferenceJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
    }
}

enum CreateBatchInferenceJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBatchSegmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case numResults
        case roleArn
        case solutionVersionArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let jobInput = self.jobInput {
            try encodeContainer.encode(jobInput, forKey: .jobInput)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = self.jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let numResults = self.numResults {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateBatchSegmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateBatchSegmentJobInput: Swift.Equatable {
    /// The ARN of the filter to apply to the batch segment job. For more information on using filters, see [Filtering batch recommendations](https://docs.aws.amazon.com/personalize/latest/dg/filter-batch.html).
    public var filterArn: Swift.String?
    /// The Amazon S3 path for the input data used to generate the batch segment job.
    /// This member is required.
    public var jobInput: PersonalizeClientTypes.BatchSegmentJobInput?
    /// The name of the batch segment job to create.
    /// This member is required.
    public var jobName: Swift.String?
    /// The Amazon S3 path for the bucket where the job's output will be stored.
    /// This member is required.
    public var jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput?
    /// The number of predicted users generated by the batch segment job for each line of input data. The maximum number of users per segment is 5 million.
    public var numResults: Swift.Int?
    /// The ARN of the Amazon Identity and Access Management role that has permissions to read and write to your input and output Amazon S3 buckets respectively.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version you want the batch segment job to use to generate batch segments.
    /// This member is required.
    public var solutionVersionArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the batch segment job.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        filterArn: Swift.String? = nil,
        jobInput: PersonalizeClientTypes.BatchSegmentJobInput? = nil,
        jobName: Swift.String? = nil,
        jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput? = nil,
        numResults: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.filterArn = filterArn
        self.jobInput = jobInput
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.numResults = numResults
        self.roleArn = roleArn
        self.solutionVersionArn = solutionVersionArn
        self.tags = tags
    }
}

struct CreateBatchSegmentJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let solutionVersionArn: Swift.String?
    let filterArn: Swift.String?
    let numResults: Swift.Int?
    let jobInput: PersonalizeClientTypes.BatchSegmentJobInput?
    let jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput?
    let roleArn: Swift.String?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateBatchSegmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case numResults
        case roleArn
        case solutionVersionArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let jobInputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchSegmentJobInput.self, forKey: .jobInput)
        jobInput = jobInputDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchSegmentJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBatchSegmentJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBatchSegmentJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchSegmentJobArn = output.batchSegmentJobArn
        } else {
            self.batchSegmentJobArn = nil
        }
    }
}

public struct CreateBatchSegmentJobOutput: Swift.Equatable {
    /// The ARN of the batch segment job.
    public var batchSegmentJobArn: Swift.String?

    public init(
        batchSegmentJobArn: Swift.String? = nil
    )
    {
        self.batchSegmentJobArn = batchSegmentJobArn
    }
}

struct CreateBatchSegmentJobOutputBody: Swift.Equatable {
    let batchSegmentJobArn: Swift.String?
}

extension CreateBatchSegmentJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJobArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchSegmentJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchSegmentJobArn)
        batchSegmentJobArn = batchSegmentJobArnDecoded
    }
}

enum CreateBatchSegmentJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCampaignInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignConfig
        case minProvisionedTPS
        case name
        case solutionVersionArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignConfig = self.campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let minProvisionedTPS = self.minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCampaignInput: Swift.Equatable {
    /// The configuration details of a campaign.
    public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
    /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support. A high minProvisionedTPS will increase your bill. We recommend starting with 1 for minProvisionedTPS (the default). Track your usage using Amazon CloudWatch metrics, and increase the minProvisionedTPS as necessary.
    public var minProvisionedTPS: Swift.Int?
    /// A name for the new campaign. The campaign name must be unique within your account.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version to deploy.
    /// This member is required.
    public var solutionVersionArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the campaign.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
        minProvisionedTPS: Swift.Int? = nil,
        name: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.campaignConfig = campaignConfig
        self.minProvisionedTPS = minProvisionedTPS
        self.name = name
        self.solutionVersionArn = solutionVersionArn
        self.tags = tags
    }
}

struct CreateCampaignInputBody: Swift.Equatable {
    let name: Swift.String?
    let solutionVersionArn: Swift.String?
    let minProvisionedTPS: Swift.Int?
    let campaignConfig: PersonalizeClientTypes.CampaignConfig?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignConfig
        case minProvisionedTPS
        case name
        case solutionVersionArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCampaignOutputBody = try responseDecoder.decode(responseBody: data)
            self.campaignArn = output.campaignArn
        } else {
            self.campaignArn = nil
        }
    }
}

public struct CreateCampaignOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign.
    public var campaignArn: Swift.String?

    public init(
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct CreateCampaignOutputBody: Swift.Equatable {
    let campaignArn: Swift.String?
}

extension CreateCampaignOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

enum CreateCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDatasetExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case ingestionMode
        case jobName
        case jobOutput
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let ingestionMode = self.ingestionMode {
            try encodeContainer.encode(ingestionMode.rawValue, forKey: .ingestionMode)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = self.jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDatasetExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset that contains the data to export.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// The data to export, based on how you imported the data. You can choose to export only BULK data that you imported using a dataset import job, only PUT data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or ALL for both types. The default value is PUT.
    public var ingestionMode: PersonalizeClientTypes.IngestionMode?
    /// The name for the dataset export job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the Amazon S3 bucket where the job's output is stored.
    /// This member is required.
    public var jobOutput: PersonalizeClientTypes.DatasetExportJobOutput?
    /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your output Amazon S3 bucket.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the dataset export job.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        datasetArn: Swift.String? = nil,
        ingestionMode: PersonalizeClientTypes.IngestionMode? = nil,
        jobName: Swift.String? = nil,
        jobOutput: PersonalizeClientTypes.DatasetExportJobOutput? = nil,
        roleArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetArn = datasetArn
        self.ingestionMode = ingestionMode
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDatasetExportJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let datasetArn: Swift.String?
    let ingestionMode: PersonalizeClientTypes.IngestionMode?
    let roleArn: Swift.String?
    let jobOutput: PersonalizeClientTypes.DatasetExportJobOutput?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateDatasetExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case ingestionMode
        case jobName
        case jobOutput
        case roleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let ingestionModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.IngestionMode.self, forKey: .ingestionMode)
        ingestionMode = ingestionModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetExportJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDatasetExportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetExportJobArn = output.datasetExportJobArn
        } else {
            self.datasetExportJobArn = nil
        }
    }
}

public struct CreateDatasetExportJobOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset export job.
    public var datasetExportJobArn: Swift.String?

    public init(
        datasetExportJobArn: Swift.String? = nil
    )
    {
        self.datasetExportJobArn = datasetExportJobArn
    }
}

struct CreateDatasetExportJobOutputBody: Swift.Equatable {
    let datasetExportJobArn: Swift.String?
}

extension CreateDatasetExportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJobArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
    }
}

enum CreateDatasetExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case kmsKeyArn
        case name
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetGroupInput: Swift.Equatable {
    /// The domain of the dataset group. Specify a domain to create a Domain dataset group. The domain you specify determines the default schemas for datasets and the use cases available for recommenders. If you don't specify a domain, you create a Custom dataset group with solution versions that you deploy with a campaign.
    public var domain: PersonalizeClientTypes.Domain?
    /// The Amazon Resource Name (ARN) of a Key Management Service (KMS) key used to encrypt the datasets.
    public var kmsKeyArn: Swift.String?
    /// The name for the new dataset group.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the Identity and Access Management (IAM) role that has permissions to access the Key Management Service (KMS) key. Supplying an IAM role is only valid when also specifying a KMS key.
    public var roleArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the dataset group.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        domain: PersonalizeClientTypes.Domain? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.domain = domain
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDatasetGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let roleArn: Swift.String?
    let kmsKeyArn: Swift.String?
    let domain: PersonalizeClientTypes.Domain?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case kmsKeyArn
        case name
        case roleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDatasetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroupArn = output.datasetGroupArn
            self.domain = output.domain
        } else {
            self.datasetGroupArn = nil
            self.domain = nil
        }
    }
}

public struct CreateDatasetGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new dataset group.
    public var datasetGroupArn: Swift.String?
    /// The domain for the new Domain dataset group.
    public var domain: PersonalizeClientTypes.Domain?

    public init(
        datasetGroupArn: Swift.String? = nil,
        domain: PersonalizeClientTypes.Domain? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.domain = domain
    }
}

struct CreateDatasetGroupOutputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let domain: PersonalizeClientTypes.Domain?
}

extension CreateDatasetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case domain
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

enum CreateDatasetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDatasetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case datasetArn
        case importMode
        case jobName
        case publishAttributionMetricsToS3
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let importMode = self.importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let publishAttributionMetricsToS3 = self.publishAttributionMetricsToS3 {
            try encodeContainer.encode(publishAttributionMetricsToS3, forKey: .publishAttributionMetricsToS3)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDatasetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetImportJobInput: Swift.Equatable {
    /// The Amazon S3 bucket that contains the training data to import.
    /// This member is required.
    public var dataSource: PersonalizeClientTypes.DataSource?
    /// The ARN of the dataset that receives the imported data.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// Specify how to add the new records to an existing dataset. The default import mode is FULL. If you haven't imported bulk records into the dataset previously, you can only specify FULL.
    ///
    /// * Specify FULL to overwrite all existing bulk data in your dataset. Data you imported individually is not replaced.
    ///
    /// * Specify INCREMENTAL to append the new records to the existing data in your dataset. Amazon Personalize replaces any record with the same ID with the new one.
    public var importMode: PersonalizeClientTypes.ImportMode?
    /// The name for the dataset import job.
    /// This member is required.
    public var jobName: Swift.String?
    /// If you created a metric attribution, specify whether to publish metrics for this import job to Amazon S3
    public var publishAttributionMetricsToS3: Swift.Bool?
    /// The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the dataset import job.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        dataSource: PersonalizeClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        importMode: PersonalizeClientTypes.ImportMode? = nil,
        jobName: Swift.String? = nil,
        publishAttributionMetricsToS3: Swift.Bool? = nil,
        roleArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.importMode = importMode
        self.jobName = jobName
        self.publishAttributionMetricsToS3 = publishAttributionMetricsToS3
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDatasetImportJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let datasetArn: Swift.String?
    let dataSource: PersonalizeClientTypes.DataSource?
    let roleArn: Swift.String?
    let tags: [PersonalizeClientTypes.Tag]?
    let importMode: PersonalizeClientTypes.ImportMode?
    let publishAttributionMetricsToS3: Swift.Bool?
}

extension CreateDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case datasetArn
        case importMode
        case jobName
        case publishAttributionMetricsToS3
        case roleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let importModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.ImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let publishAttributionMetricsToS3Decoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishAttributionMetricsToS3)
        publishAttributionMetricsToS3 = publishAttributionMetricsToS3Decoded
    }
}

extension CreateDatasetImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDatasetImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobArn = output.datasetImportJobArn
        } else {
            self.datasetImportJobArn = nil
        }
    }
}

public struct CreateDatasetImportJobOutput: Swift.Equatable {
    /// The ARN of the dataset import job.
    public var datasetImportJobArn: Swift.String?

    public init(
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct CreateDatasetImportJobOutputBody: Swift.Equatable {
    let datasetImportJobArn: Swift.String?
}

extension CreateDatasetImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

enum CreateDatasetImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case datasetType
        case name
        case schemaArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let datasetType = self.datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group to add the dataset to.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The type of dataset. One of the following (case insensitive) values:
    ///
    /// * Interactions
    ///
    /// * Items
    ///
    /// * Users
    /// This member is required.
    public var datasetType: Swift.String?
    /// The name for the dataset.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the schema to associate with the dataset. The schema defines the dataset fields.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the dataset.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        datasetGroupArn: Swift.String? = nil,
        datasetType: Swift.String? = nil,
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.datasetType = datasetType
        self.name = name
        self.schemaArn = schemaArn
        self.tags = tags
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    let name: Swift.String?
    let schemaArn: Swift.String?
    let datasetGroupArn: Swift.String?
    let datasetType: Swift.String?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case datasetType
        case name
        case schemaArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetArn = output.datasetArn
        } else {
            self.datasetArn = nil
        }
    }
}

public struct CreateDatasetOutput: Swift.Equatable {
    /// The ARN of the dataset.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct CreateDatasetOutputBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension CreateDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

enum CreateDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEventTrackerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateEventTrackerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEventTrackerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The name for the event tracker.
    /// This member is required.
    public var name: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the event tracker.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        datasetGroupArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.name = name
        self.tags = tags
    }
}

struct CreateEventTrackerInputBody: Swift.Equatable {
    let name: Swift.String?
    let datasetGroupArn: Swift.String?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateEventTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEventTrackerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEventTrackerOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventTrackerArn = output.eventTrackerArn
            self.trackingId = output.trackingId
        } else {
            self.eventTrackerArn = nil
            self.trackingId = nil
        }
    }
}

public struct CreateEventTrackerOutput: Swift.Equatable {
    /// The ARN of the event tracker.
    public var eventTrackerArn: Swift.String?
    /// The ID of the event tracker. Include this ID in requests to the [PutEvents](https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html) API.
    public var trackingId: Swift.String?

    public init(
        eventTrackerArn: Swift.String? = nil,
        trackingId: Swift.String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
        self.trackingId = trackingId
    }
}

struct CreateEventTrackerOutputBody: Swift.Equatable {
    let eventTrackerArn: Swift.String?
    let trackingId: Swift.String?
}

extension CreateEventTrackerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
        case trackingId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
        let trackingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingId)
        trackingId = trackingIdDecoded
    }
}

enum CreateEventTrackerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFilterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFilterInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), filterExpression: \"CONTENT_REDACTED\")"}
}

extension CreateFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case filterExpression
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let filterExpression = self.filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFilterInput: Swift.Equatable {
    /// The ARN of the dataset group that the filter will belong to.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The filter expression defines which items are included or excluded from recommendations. Filter expression must follow specific format rules. For information about filter expression structure and syntax, see [Filter expressions](https://docs.aws.amazon.com/personalize/latest/dg/filter-expressions.html).
    /// This member is required.
    public var filterExpression: Swift.String?
    /// The name of the filter to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the filter.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        datasetGroupArn: Swift.String? = nil,
        filterExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.filterExpression = filterExpression
        self.name = name
        self.tags = tags
    }
}

struct CreateFilterInputBody: Swift.Equatable {
    let name: Swift.String?
    let datasetGroupArn: Swift.String?
    let filterExpression: Swift.String?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case filterExpression
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.filterArn = output.filterArn
        } else {
            self.filterArn = nil
        }
    }
}

public struct CreateFilterOutput: Swift.Equatable {
    /// The ARN of the new filter.
    public var filterArn: Swift.String?

    public init(
        filterArn: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

struct CreateFilterOutputBody: Swift.Equatable {
    let filterArn: Swift.String?
}

extension CreateFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
    }
}

enum CreateFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMetricAttributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case metrics
        case metricsOutputConfig
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricattribute0 in metrics {
                try metricsContainer.encode(metricattribute0)
            }
        }
        if let metricsOutputConfig = self.metricsOutputConfig {
            try encodeContainer.encode(metricsOutputConfig, forKey: .metricsOutputConfig)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateMetricAttributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateMetricAttributionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the destination dataset group for the metric attribution.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// A list of metric attributes for the metric attribution. Each metric attribute specifies an event type to track and a function. Available functions are SUM() or SAMPLECOUNT(). For SUM() functions, provide the dataset type (either Interactions or Items) and column to sum as a parameter. For example SUM(Items.PRICE).
    /// This member is required.
    public var metrics: [PersonalizeClientTypes.MetricAttribute]?
    /// The output configuration details for the metric attribution.
    /// This member is required.
    public var metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput?
    /// A name for the metric attribution.
    /// This member is required.
    public var name: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        metrics: [PersonalizeClientTypes.MetricAttribute]? = nil,
        metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput? = nil,
        name: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.metrics = metrics
        self.metricsOutputConfig = metricsOutputConfig
        self.name = name
    }
}

struct CreateMetricAttributionInputBody: Swift.Equatable {
    let name: Swift.String?
    let datasetGroupArn: Swift.String?
    let metrics: [PersonalizeClientTypes.MetricAttribute]?
    let metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput?
}

extension CreateMetricAttributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case metrics
        case metricsOutputConfig
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let metricsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.MetricAttribute?].self, forKey: .metrics)
        var metricsDecoded0:[PersonalizeClientTypes.MetricAttribute]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [PersonalizeClientTypes.MetricAttribute]()
            for structure0 in metricsContainer {
                if let structure0 = structure0 {
                    metricsDecoded0?.append(structure0)
                }
            }
        }
        metrics = metricsDecoded0
        let metricsOutputConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.MetricAttributionOutput.self, forKey: .metricsOutputConfig)
        metricsOutputConfig = metricsOutputConfigDecoded
    }
}

extension CreateMetricAttributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMetricAttributionOutputBody = try responseDecoder.decode(responseBody: data)
            self.metricAttributionArn = output.metricAttributionArn
        } else {
            self.metricAttributionArn = nil
        }
    }
}

public struct CreateMetricAttributionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the new metric attribution.
    public var metricAttributionArn: Swift.String?

    public init(
        metricAttributionArn: Swift.String? = nil
    )
    {
        self.metricAttributionArn = metricAttributionArn
    }
}

struct CreateMetricAttributionOutputBody: Swift.Equatable {
    let metricAttributionArn: Swift.String?
}

extension CreateMetricAttributionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
    }
}

enum CreateMetricAttributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRecommenderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case name
        case recipeArn
        case recommenderConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let recommenderConfig = self.recommenderConfig {
            try encodeContainer.encode(recommenderConfig, forKey: .recommenderConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateRecommenderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRecommenderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the destination domain dataset group for the recommender.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The name of the recommender.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the recipe that the recommender will use. For a recommender, a recipe is a Domain dataset group use case. Only Domain dataset group use cases can be used to create a recommender. For information about use cases see [Choosing recommender use cases](https://docs.aws.amazon.com/personalize/latest/dg/domain-use-cases.html).
    /// This member is required.
    public var recipeArn: Swift.String?
    /// The configuration details of the recommender.
    public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the recommender.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        datasetGroupArn: Swift.String? = nil,
        name: Swift.String? = nil,
        recipeArn: Swift.String? = nil,
        recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.name = name
        self.recipeArn = recipeArn
        self.recommenderConfig = recommenderConfig
        self.tags = tags
    }
}

struct CreateRecommenderInputBody: Swift.Equatable {
    let name: Swift.String?
    let datasetGroupArn: Swift.String?
    let recipeArn: Swift.String?
    let recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateRecommenderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case name
        case recipeArn
        case recommenderConfig
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let recommenderConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecommenderConfig.self, forKey: .recommenderConfig)
        recommenderConfig = recommenderConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRecommenderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRecommenderOutputBody = try responseDecoder.decode(responseBody: data)
            self.recommenderArn = output.recommenderArn
        } else {
            self.recommenderArn = nil
        }
    }
}

public struct CreateRecommenderOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct CreateRecommenderOutputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension CreateRecommenderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

enum CreateRecommenderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case name
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }
}

extension CreateSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSchemaInput: Swift.Equatable {
    /// The domain for the schema. If you are creating a schema for a dataset in a Domain dataset group, specify the domain you chose when you created the Domain dataset group.
    public var domain: PersonalizeClientTypes.Domain?
    /// The name for the schema.
    /// This member is required.
    public var name: Swift.String?
    /// A schema in Avro JSON format.
    /// This member is required.
    public var schema: Swift.String?

    public init(
        domain: PersonalizeClientTypes.Domain? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.domain = domain
        self.name = name
        self.schema = schema
    }
}

struct CreateSchemaInputBody: Swift.Equatable {
    let name: Swift.String?
    let schema: Swift.String?
    let domain: PersonalizeClientTypes.Domain?
}

extension CreateSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case name
        case schema
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension CreateSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.schemaArn = output.schemaArn
        } else {
            self.schemaArn = nil
        }
    }
}

public struct CreateSchemaOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created schema.
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct CreateSchemaOutputBody: Swift.Equatable {
    let schemaArn: Swift.String?
}

extension CreateSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

enum CreateSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSolutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case eventType
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let performAutoML = self.performAutoML {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if let performHPO = self.performHPO {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionConfig = self.solutionConfig {
            try encodeContainer.encode(solutionConfig, forKey: .solutionConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSolutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSolutionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// When your have multiple event types (using an EVENT_TYPE schema field), this parameter specifies which event type (for example, 'click' or 'like') is used for training the model. If you do not provide an eventType, Amazon Personalize will use all interactions for training with equal weight regardless of type.
    public var eventType: Swift.String?
    /// The name for the solution.
    /// This member is required.
    public var name: Swift.String?
    /// We don't recommend enabling automated machine learning. Instead, match your use case to the available Amazon Personalize recipes. For more information, see [Determining your use case.](https://docs.aws.amazon.com/personalize/latest/dg/determining-use-case.html) Whether to perform automated machine learning (AutoML). The default is false. For this case, you must specify recipeArn. When set to true, Amazon Personalize analyzes your training data and selects the optimal USER_PERSONALIZATION recipe and hyperparameters. In this case, you must omit recipeArn. Amazon Personalize determines the optimal recipe by running tests with different values for the hyperparameters. AutoML lengthens the training process as compared to selecting a specific recipe.
    public var performAutoML: Swift.Bool?
    /// Whether to perform hyperparameter optimization (HPO) on the specified or selected recipe. The default is false. When performing AutoML, this parameter is always true and you should not set it to false.
    public var performHPO: Swift.Bool?
    /// The ARN of the recipe to use for model training. This is required when performAutoML is false.
    public var recipeArn: Swift.String?
    /// The configuration to use with the solution. When performAutoML is set to true, Amazon Personalize only evaluates the autoMLConfig section of the solution configuration. Amazon Personalize doesn't support configuring the hpoObjective at this time.
    public var solutionConfig: PersonalizeClientTypes.SolutionConfig?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the solution.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        datasetGroupArn: Swift.String? = nil,
        eventType: Swift.String? = nil,
        name: Swift.String? = nil,
        performAutoML: Swift.Bool? = nil,
        performHPO: Swift.Bool? = nil,
        recipeArn: Swift.String? = nil,
        solutionConfig: PersonalizeClientTypes.SolutionConfig? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.eventType = eventType
        self.name = name
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.recipeArn = recipeArn
        self.solutionConfig = solutionConfig
        self.tags = tags
    }
}

struct CreateSolutionInputBody: Swift.Equatable {
    let name: Swift.String?
    let performHPO: Swift.Bool?
    let performAutoML: Swift.Bool?
    let recipeArn: Swift.String?
    let datasetGroupArn: Swift.String?
    let eventType: Swift.String?
    let solutionConfig: PersonalizeClientTypes.SolutionConfig?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateSolutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case eventType
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionConfig
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let solutionConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionConfig.self, forKey: .solutionConfig)
        solutionConfig = solutionConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSolutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSolutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.solutionArn = output.solutionArn
        } else {
            self.solutionArn = nil
        }
    }
}

public struct CreateSolutionOutput: Swift.Equatable {
    /// The ARN of the solution.
    public var solutionArn: Swift.String?

    public init(
        solutionArn: Swift.String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

struct CreateSolutionOutputBody: Swift.Equatable {
    let solutionArn: Swift.String?
}

extension CreateSolutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
    }
}

enum CreateSolutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSolutionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case solutionArn
        case tags
        case trainingMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let trainingMode = self.trainingMode {
            try encodeContainer.encode(trainingMode.rawValue, forKey: .trainingMode)
        }
    }
}

extension CreateSolutionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSolutionVersionInput: Swift.Equatable {
    /// The name of the solution version.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution containing the training configuration information.
    /// This member is required.
    public var solutionArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the solution version.
    public var tags: [PersonalizeClientTypes.Tag]?
    /// The scope of training to be performed when creating the solution version. The FULL option trains the solution version based on the entirety of the input solution's training data, while the UPDATE option processes only the data that has changed in comparison to the input solution. Choose UPDATE when you want to incrementally update your solution version instead of creating an entirely new one. The UPDATE option can only be used when you already have an active solution version created from the input solution using the FULL option and the input solution was trained with the [User-Personalization](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html) recipe or the [HRNN-Coldstart](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-hrnn-coldstart.html) recipe.
    public var trainingMode: PersonalizeClientTypes.TrainingMode?

    public init(
        name: Swift.String? = nil,
        solutionArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil,
        trainingMode: PersonalizeClientTypes.TrainingMode? = nil
    )
    {
        self.name = name
        self.solutionArn = solutionArn
        self.tags = tags
        self.trainingMode = trainingMode
    }
}

struct CreateSolutionVersionInputBody: Swift.Equatable {
    let name: Swift.String?
    let solutionArn: Swift.String?
    let trainingMode: PersonalizeClientTypes.TrainingMode?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension CreateSolutionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case solutionArn
        case tags
        case trainingMode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let trainingModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.TrainingMode.self, forKey: .trainingMode)
        trainingMode = trainingModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSolutionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSolutionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.solutionVersionArn = output.solutionVersionArn
        } else {
            self.solutionVersionArn = nil
        }
    }
}

public struct CreateSolutionVersionOutput: Swift.Equatable {
    /// The ARN of the new solution version.
    public var solutionVersionArn: Swift.String?

    public init(
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct CreateSolutionVersionOutputBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
}

extension CreateSolutionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

enum CreateSolutionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PersonalizeClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataLocation = self.dataLocation {
            try encodeContainer.encode(dataLocation, forKey: .dataLocation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataLocation)
        dataLocation = dataLocationDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes the data source that contains the data to upload to a dataset.
    public struct DataSource: Swift.Equatable {
        /// The path to the Amazon S3 bucket where the data that you want to upload to your dataset is stored. For example: s3://bucket-name/folder-name/
        public var dataLocation: Swift.String?

        public init(
            dataLocation: Swift.String? = nil
        )
        {
            self.dataLocation = dataLocation
        }
    }

}

extension PersonalizeClientTypes.Dataset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetArn
        case datasetGroupArn
        case datasetType
        case lastUpdatedDateTime
        case latestDatasetUpdate
        case name
        case schemaArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let datasetType = self.datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let latestDatasetUpdate = self.latestDatasetUpdate {
            try encodeContainer.encode(latestDatasetUpdate, forKey: .latestDatasetUpdate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let latestDatasetUpdateDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetUpdateSummary.self, forKey: .latestDatasetUpdate)
        latestDatasetUpdate = latestDatasetUpdateDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides metadata for a dataset.
    public struct Dataset: Swift.Equatable {
        /// The creation date and time (in Unix time) of the dataset.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset that you want metadata for.
        public var datasetArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// One of the following values:
        ///
        /// * Interactions
        ///
        /// * Items
        ///
        /// * Users
        public var datasetType: Swift.String?
        /// A time stamp that shows when the dataset was updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Describes the latest update to the dataset.
        public var latestDatasetUpdate: PersonalizeClientTypes.DatasetUpdateSummary?
        /// The name of the dataset.
        public var name: Swift.String?
        /// The ARN of the associated schema.
        public var schemaArn: Swift.String?
        /// The status of the dataset. A dataset can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetGroupArn: Swift.String? = nil,
            datasetType: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            latestDatasetUpdate: PersonalizeClientTypes.DatasetUpdateSummary? = nil,
            name: Swift.String? = nil,
            schemaArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetGroupArn = datasetGroupArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestDatasetUpdate = latestDatasetUpdate
            self.name = name
            self.schemaArn = schemaArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetExportJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetArn
        case datasetExportJobArn
        case failureReason
        case ingestionMode
        case jobName
        case jobOutput
        case lastUpdatedDateTime
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetExportJobArn = self.datasetExportJobArn {
            try encodeContainer.encode(datasetExportJobArn, forKey: .datasetExportJobArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let ingestionMode = self.ingestionMode {
            try encodeContainer.encode(ingestionMode.rawValue, forKey: .ingestionMode)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = self.jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let ingestionModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.IngestionMode.self, forKey: .ingestionMode)
        ingestionMode = ingestionModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetExportJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes a job that exports a dataset to an Amazon S3 bucket. For more information, see [CreateDatasetExportJob](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateDatasetExportJob.html). A dataset export job can be in one of the following states:
    ///
    /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    public struct DatasetExportJob: Swift.Equatable {
        /// The creation date and time (in Unix time) of the dataset export job.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset to export.
        public var datasetArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public var datasetExportJobArn: Swift.String?
        /// If a dataset export job fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The data to export, based on how you imported the data. You can choose to export BULK data that you imported using a dataset import job, PUT data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or ALL for both types. The default value is PUT.
        public var ingestionMode: PersonalizeClientTypes.IngestionMode?
        /// The name of the export job.
        public var jobName: Swift.String?
        /// The path to the Amazon S3 bucket where the job's output is stored. For example: s3://bucket-name/folder-name/
        public var jobOutput: PersonalizeClientTypes.DatasetExportJobOutput?
        /// The date and time (in Unix time) the status of the dataset export job was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your output Amazon S3 bucket.
        public var roleArn: Swift.String?
        /// The status of the dataset export job. A dataset export job can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetExportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            ingestionMode: PersonalizeClientTypes.IngestionMode? = nil,
            jobName: Swift.String? = nil,
            jobOutput: PersonalizeClientTypes.DatasetExportJobOutput? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetExportJobArn = datasetExportJobArn
            self.failureReason = failureReason
            self.ingestionMode = ingestionMode
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetExportJobOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataDestination = self.s3DataDestination {
            try encodeContainer.encode(s3DataDestination, forKey: .s3DataDestination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDestinationDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataDestination)
        s3DataDestination = s3DataDestinationDecoded
    }
}

extension PersonalizeClientTypes {
    /// The output configuration parameters of a dataset export job.
    public struct DatasetExportJobOutput: Swift.Equatable {
        /// The configuration details of an Amazon S3 input or output bucket.
        /// This member is required.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init(
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataDestination = s3DataDestination
        }
    }

}

extension PersonalizeClientTypes.DatasetExportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetExportJobArn
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetExportJobArn = self.datasetExportJobArn {
            try encodeContainer.encode(datasetExportJobArn, forKey: .datasetExportJobArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset export job. For a complete listing, call the [DescribeDatasetExportJob](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeDatasetExportJob.html) API.
    public struct DatasetExportJobSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the dataset export job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public var datasetExportJobArn: Swift.String?
        /// If a dataset export job fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The name of the dataset export job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) that the dataset export job status was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The status of the dataset export job. A dataset export job can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            datasetExportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetExportJobArn = datasetExportJobArn
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case domain
        case failureReason
        case kmsKeyArn
        case lastUpdatedDateTime
        case name
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension PersonalizeClientTypes {
    /// A dataset group is a collection of related datasets (Interactions, User, and Item). You create a dataset group by calling [CreateDatasetGroup](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateDatasetGroup.html). You then create a dataset and add it to a dataset group by calling [CreateDataset](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateDataset.html). The dataset group is used to create and train a solution by calling [CreateSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSolution.html). A dataset group can contain only one of each type of dataset. You can specify an Key Management Service (KMS) key to encrypt the datasets in the group.
    public struct DatasetGroup: Swift.Equatable {
        /// The creation date and time (in Unix time) of the dataset group.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// The domain of a Domain dataset group.
        public var domain: PersonalizeClientTypes.Domain?
        /// If creating a dataset group fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key used to encrypt the datasets.
        public var kmsKeyArn: Swift.String?
        /// The last update date and time (in Unix time) of the dataset group.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the dataset group.
        public var name: Swift.String?
        /// The ARN of the IAM role that has permissions to create the dataset group.
        public var roleArn: Swift.String?
        /// The current status of the dataset group. A dataset group can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            failureReason: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.domain = domain
            self.failureReason = failureReason
            self.kmsKeyArn = kmsKeyArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case domain
        case failureReason
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset group. For a complete listing, call the [DescribeDatasetGroup](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeDatasetGroup.html) API.
    public struct DatasetGroupSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the dataset group was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// The domain of a Domain dataset group.
        public var domain: PersonalizeClientTypes.Domain?
        /// If creating a dataset group fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the dataset group was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the dataset group.
        public var name: Swift.String?
        /// The status of the dataset group. A dataset group can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.domain = domain
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetImportJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case dataSource
        case datasetArn
        case datasetImportJobArn
        case failureReason
        case importMode
        case jobName
        case lastUpdatedDateTime
        case publishAttributionMetricsToS3
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let importMode = self.importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let publishAttributionMetricsToS3 = self.publishAttributionMetricsToS3 {
            try encodeContainer.encode(publishAttributionMetricsToS3, forKey: .publishAttributionMetricsToS3)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let importModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.ImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
        let publishAttributionMetricsToS3Decoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishAttributionMetricsToS3)
        publishAttributionMetricsToS3 = publishAttributionMetricsToS3Decoded
    }
}

extension PersonalizeClientTypes {
    /// Describes a job that imports training data from a data source (Amazon S3 bucket) to an Amazon Personalize dataset. For more information, see [CreateDatasetImportJob](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateDatasetImportJob.html). A dataset import job can be in one of the following states:
    ///
    /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    public struct DatasetImportJob: Swift.Equatable {
        /// The creation date and time (in Unix time) of the dataset import job.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon S3 bucket that contains the training data to import.
        public var dataSource: PersonalizeClientTypes.DataSource?
        /// The Amazon Resource Name (ARN) of the dataset that receives the imported data.
        public var datasetArn: Swift.String?
        /// The ARN of the dataset import job.
        public var datasetImportJobArn: Swift.String?
        /// If a dataset import job fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The import mode used by the dataset import job to import new records.
        public var importMode: PersonalizeClientTypes.ImportMode?
        /// The name of the import job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) the dataset was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Whether the job publishes metrics to Amazon S3 for a metric attribution.
        public var publishAttributionMetricsToS3: Swift.Bool?
        /// The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
        public var roleArn: Swift.String?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            dataSource: PersonalizeClientTypes.DataSource? = nil,
            datasetArn: Swift.String? = nil,
            datasetImportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            importMode: PersonalizeClientTypes.ImportMode? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            publishAttributionMetricsToS3: Swift.Bool? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.dataSource = dataSource
            self.datasetArn = datasetArn
            self.datasetImportJobArn = datasetImportJobArn
            self.failureReason = failureReason
            self.importMode = importMode
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.publishAttributionMetricsToS3 = publishAttributionMetricsToS3
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetImportJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetImportJobArn
        case failureReason
        case importMode
        case jobName
        case lastUpdatedDateTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let importMode = self.importMode {
            try encodeContainer.encode(importMode.rawValue, forKey: .importMode)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let importModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.ImportMode.self, forKey: .importMode)
        importMode = importModeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset import job. For a complete listing, call the [DescribeDatasetImportJob](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeDatasetImportJob.html) API.
    public struct DatasetImportJobSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the dataset import job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public var datasetImportJobArn: Swift.String?
        /// If a dataset import job fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The import mode the dataset import job used to update the data in the dataset. For more information see [Updating existing bulk data](https://docs.aws.amazon.com/personalize/latest/dg/updating-existing-bulk-data.html).
        public var importMode: PersonalizeClientTypes.ImportMode?
        /// The name of the dataset import job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) that the dataset import job status was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            datasetImportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            importMode: PersonalizeClientTypes.ImportMode? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetImportJobArn = datasetImportJobArn
            self.failureReason = failureReason
            self.importMode = importMode
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case domain
        case lastUpdatedDateTime
        case name
        case schema
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes the schema for a dataset. For more information on schemas, see [CreateSchema](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSchema.html).
    public struct DatasetSchema: Swift.Equatable {
        /// The date and time (in Unix time) that the schema was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The domain of a schema that you created for a dataset in a Domain dataset group.
        public var domain: PersonalizeClientTypes.Domain?
        /// The date and time (in Unix time) that the schema was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the schema.
        public var name: Swift.String?
        /// The schema.
        public var schema: Swift.String?
        /// The Amazon Resource Name (ARN) of the schema.
        public var schemaArn: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.domain = domain
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schema = schema
            self.schemaArn = schemaArn
        }
    }

}

extension PersonalizeClientTypes.DatasetSchemaSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case domain
        case lastUpdatedDateTime
        case name
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset schema. For a complete listing, call the [DescribeSchema](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeSchema.html) API.
    public struct DatasetSchemaSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the schema was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The domain of a schema that you created for a dataset in a Domain dataset group.
        public var domain: PersonalizeClientTypes.Domain?
        /// The date and time (in Unix time) that the schema was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the schema.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the schema.
        public var schemaArn: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.domain = domain
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schemaArn = schemaArn
        }
    }

}

extension PersonalizeClientTypes.DatasetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetArn
        case datasetType
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetType = self.datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset. For a complete listing, call the [DescribeDataset](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeDataset.html) API.
    public struct DatasetSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the dataset was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset.
        public var datasetArn: Swift.String?
        /// The dataset type. One of the following values:
        ///
        /// * Interactions
        ///
        /// * Items
        ///
        /// * Users
        ///
        /// * Event-Interactions
        public var datasetType: Swift.String?
        /// The date and time (in Unix time) that the dataset was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the dataset.
        public var name: Swift.String?
        /// The status of the dataset. A dataset can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetType: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetUpdateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case schemaArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes an update to a dataset.
    public struct DatasetUpdateSummary: Swift.Equatable {
        /// The creation date and time (in Unix time) of the dataset update.
        public var creationDateTime: ClientRuntime.Date?
        /// If updating a dataset fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The last update date and time (in Unix time) of the dataset.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the schema that replaced the previous schema of the dataset.
        public var schemaArn: Swift.String?
        /// The status of the dataset update.
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            schemaArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.schemaArn = schemaArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DefaultCategoricalHyperParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTunable
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isTunable != false {
            try encodeContainer.encode(isTunable, forKey: .isTunable)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for categoricalvalue0 in values {
                try valuesContainer.encode(categoricalvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let isTunableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTunable) ?? false
        isTunable = isTunableDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides the name and default range of a categorical hyperparameter and whether the hyperparameter is tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
    public struct DefaultCategoricalHyperParameterRange: Swift.Equatable {
        /// Whether the hyperparameter is tunable.
        public var isTunable: Swift.Bool
        /// The name of the hyperparameter.
        public var name: Swift.String?
        /// A list of the categories for the hyperparameter.
        public var values: [Swift.String]?

        public init(
            isTunable: Swift.Bool = false,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.isTunable = isTunable
            self.name = name
            self.values = values
        }
    }

}

extension PersonalizeClientTypes.DefaultContinuousHyperParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTunable
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isTunable != false {
            try encodeContainer.encode(isTunable, forKey: .isTunable)
        }
        if maxValue != 0.0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0.0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minValue) ?? 0.0
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxValue) ?? 0.0
        maxValue = maxValueDecoded
        let isTunableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTunable) ?? false
        isTunable = isTunableDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides the name and default range of a continuous hyperparameter and whether the hyperparameter is tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
    public struct DefaultContinuousHyperParameterRange: Swift.Equatable {
        /// Whether the hyperparameter is tunable.
        public var isTunable: Swift.Bool
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Double
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Double
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init(
            isTunable: Swift.Bool = false,
            maxValue: Swift.Double = 0.0,
            minValue: Swift.Double = 0.0,
            name: Swift.String? = nil
        )
        {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }

}

extension PersonalizeClientTypes.DefaultHyperParameterRanges: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoricalHyperParameterRanges
        case continuousHyperParameterRanges
        case integerHyperParameterRanges
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalHyperParameterRanges = categoricalHyperParameterRanges {
            var categoricalHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoricalHyperParameterRanges)
            for defaultcategoricalhyperparameterrange0 in categoricalHyperParameterRanges {
                try categoricalHyperParameterRangesContainer.encode(defaultcategoricalhyperparameterrange0)
            }
        }
        if let continuousHyperParameterRanges = continuousHyperParameterRanges {
            var continuousHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .continuousHyperParameterRanges)
            for defaultcontinuoushyperparameterrange0 in continuousHyperParameterRanges {
                try continuousHyperParameterRangesContainer.encode(defaultcontinuoushyperparameterrange0)
            }
        }
        if let integerHyperParameterRanges = integerHyperParameterRanges {
            var integerHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerHyperParameterRanges)
            for defaultintegerhyperparameterrange0 in integerHyperParameterRanges {
                try integerHyperParameterRangesContainer.encode(defaultintegerhyperparameterrange0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integerHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DefaultIntegerHyperParameterRange?].self, forKey: .integerHyperParameterRanges)
        var integerHyperParameterRangesDecoded0:[PersonalizeClientTypes.DefaultIntegerHyperParameterRange]? = nil
        if let integerHyperParameterRangesContainer = integerHyperParameterRangesContainer {
            integerHyperParameterRangesDecoded0 = [PersonalizeClientTypes.DefaultIntegerHyperParameterRange]()
            for structure0 in integerHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    integerHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        integerHyperParameterRanges = integerHyperParameterRangesDecoded0
        let continuousHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DefaultContinuousHyperParameterRange?].self, forKey: .continuousHyperParameterRanges)
        var continuousHyperParameterRangesDecoded0:[PersonalizeClientTypes.DefaultContinuousHyperParameterRange]? = nil
        if let continuousHyperParameterRangesContainer = continuousHyperParameterRangesContainer {
            continuousHyperParameterRangesDecoded0 = [PersonalizeClientTypes.DefaultContinuousHyperParameterRange]()
            for structure0 in continuousHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    continuousHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        continuousHyperParameterRanges = continuousHyperParameterRangesDecoded0
        let categoricalHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DefaultCategoricalHyperParameterRange?].self, forKey: .categoricalHyperParameterRanges)
        var categoricalHyperParameterRangesDecoded0:[PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]? = nil
        if let categoricalHyperParameterRangesContainer = categoricalHyperParameterRangesContainer {
            categoricalHyperParameterRangesDecoded0 = [PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]()
            for structure0 in categoricalHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    categoricalHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        categoricalHyperParameterRanges = categoricalHyperParameterRangesDecoded0
    }
}

extension PersonalizeClientTypes {
    /// Specifies the hyperparameters and their default ranges. Hyperparameters can be categorical, continuous, or integer-valued.
    public struct DefaultHyperParameterRanges: Swift.Equatable {
        /// The categorical hyperparameters and their default ranges.
        public var categoricalHyperParameterRanges: [PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their default ranges.
        public var continuousHyperParameterRanges: [PersonalizeClientTypes.DefaultContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their default ranges.
        public var integerHyperParameterRanges: [PersonalizeClientTypes.DefaultIntegerHyperParameterRange]?

        public init(
            categoricalHyperParameterRanges: [PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]? = nil,
            continuousHyperParameterRanges: [PersonalizeClientTypes.DefaultContinuousHyperParameterRange]? = nil,
            integerHyperParameterRanges: [PersonalizeClientTypes.DefaultIntegerHyperParameterRange]? = nil
        )
        {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }
    }

}

extension PersonalizeClientTypes.DefaultIntegerHyperParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTunable
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isTunable != false {
            try encodeContainer.encode(isTunable, forKey: .isTunable)
        }
        if maxValue != 0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minValue) ?? 0
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxValue) ?? 0
        maxValue = maxValueDecoded
        let isTunableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTunable) ?? false
        isTunable = isTunableDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides the name and default range of a integer-valued hyperparameter and whether the hyperparameter is tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
    public struct DefaultIntegerHyperParameterRange: Swift.Equatable {
        /// Indicates whether the hyperparameter is tunable.
        public var isTunable: Swift.Bool
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Int
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Int
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init(
            isTunable: Swift.Bool = false,
            maxValue: Swift.Int = 0,
            minValue: Swift.Int = 0,
            name: Swift.String? = nil
        )
        {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }

}

extension DeleteCampaignInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
    }
}

extension DeleteCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCampaignInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign to delete.
    /// This member is required.
    public var campaignArn: Swift.String?

    public init(
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct DeleteCampaignInputBody: Swift.Equatable {
    let campaignArn: Swift.String?
}

extension DeleteCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

extension DeleteCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCampaignOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

extension DeleteDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatasetGroupInput: Swift.Equatable {
    /// The ARN of the dataset group to delete.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DeleteDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
}

extension DeleteDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DeleteDatasetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDatasetGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDatasetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

extension DeleteDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to delete.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension DeleteDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DeleteDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDatasetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEventTrackerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTrackerArn = self.eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
    }
}

extension DeleteEventTrackerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEventTrackerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the event tracker to delete.
    /// This member is required.
    public var eventTrackerArn: Swift.String?

    public init(
        eventTrackerArn: Swift.String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
    }
}

struct DeleteEventTrackerInputBody: Swift.Equatable {
    let eventTrackerArn: Swift.String?
}

extension DeleteEventTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
    }
}

extension DeleteEventTrackerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEventTrackerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEventTrackerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
    }
}

extension DeleteFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFilterInput: Swift.Equatable {
    /// The ARN of the filter to delete.
    /// This member is required.
    public var filterArn: Swift.String?

    public init(
        filterArn: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

struct DeleteFilterInputBody: Swift.Equatable {
    let filterArn: Swift.String?
}

extension DeleteFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
    }
}

extension DeleteFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFilterOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMetricAttributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricAttributionArn = self.metricAttributionArn {
            try encodeContainer.encode(metricAttributionArn, forKey: .metricAttributionArn)
        }
    }
}

extension DeleteMetricAttributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMetricAttributionInput: Swift.Equatable {
    /// The metric attribution's Amazon Resource Name (ARN).
    /// This member is required.
    public var metricAttributionArn: Swift.String?

    public init(
        metricAttributionArn: Swift.String? = nil
    )
    {
        self.metricAttributionArn = metricAttributionArn
    }
}

struct DeleteMetricAttributionInputBody: Swift.Equatable {
    let metricAttributionArn: Swift.String?
}

extension DeleteMetricAttributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
    }
}

extension DeleteMetricAttributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMetricAttributionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMetricAttributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRecommenderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
    }
}

extension DeleteRecommenderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRecommenderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender to delete.
    /// This member is required.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct DeleteRecommenderInputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension DeleteRecommenderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

extension DeleteRecommenderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRecommenderOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRecommenderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

extension DeleteSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSchemaInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the schema to delete.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DeleteSchemaInputBody: Swift.Equatable {
    let schemaArn: Swift.String?
}

extension DeleteSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

extension DeleteSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSchemaOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSolutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

extension DeleteSolutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSolutionInput: Swift.Equatable {
    /// The ARN of the solution to delete.
    /// This member is required.
    public var solutionArn: Swift.String?

    public init(
        solutionArn: Swift.String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

struct DeleteSolutionInputBody: Swift.Equatable {
    let solutionArn: Swift.String?
}

extension DeleteSolutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
    }
}

extension DeleteSolutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSolutionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSolutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAlgorithmInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = self.algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
    }
}

extension DescribeAlgorithmInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAlgorithmInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the algorithm to describe.
    /// This member is required.
    public var algorithmArn: Swift.String?

    public init(
        algorithmArn: Swift.String? = nil
    )
    {
        self.algorithmArn = algorithmArn
    }
}

struct DescribeAlgorithmInputBody: Swift.Equatable {
    let algorithmArn: Swift.String?
}

extension DescribeAlgorithmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
    }
}

extension DescribeAlgorithmOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAlgorithmOutputBody = try responseDecoder.decode(responseBody: data)
            self.algorithm = output.algorithm
        } else {
            self.algorithm = nil
        }
    }
}

public struct DescribeAlgorithmOutput: Swift.Equatable {
    /// A listing of the properties of the algorithm.
    public var algorithm: PersonalizeClientTypes.Algorithm?

    public init(
        algorithm: PersonalizeClientTypes.Algorithm? = nil
    )
    {
        self.algorithm = algorithm
    }
}

struct DescribeAlgorithmOutputBody: Swift.Equatable {
    let algorithm: PersonalizeClientTypes.Algorithm?
}

extension DescribeAlgorithmOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithm
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Algorithm.self, forKey: .algorithm)
        algorithm = algorithmDecoded
    }
}

enum DescribeAlgorithmOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBatchInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobArn = self.batchInferenceJobArn {
            try encodeContainer.encode(batchInferenceJobArn, forKey: .batchInferenceJobArn)
        }
    }
}

extension DescribeBatchInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBatchInferenceJobInput: Swift.Equatable {
    /// The ARN of the batch inference job to describe.
    /// This member is required.
    public var batchInferenceJobArn: Swift.String?

    public init(
        batchInferenceJobArn: Swift.String? = nil
    )
    {
        self.batchInferenceJobArn = batchInferenceJobArn
    }
}

struct DescribeBatchInferenceJobInputBody: Swift.Equatable {
    let batchInferenceJobArn: Swift.String?
}

extension DescribeBatchInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
    }
}

extension DescribeBatchInferenceJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBatchInferenceJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchInferenceJob = output.batchInferenceJob
        } else {
            self.batchInferenceJob = nil
        }
    }
}

public struct DescribeBatchInferenceJobOutput: Swift.Equatable {
    /// Information on the specified batch inference job.
    public var batchInferenceJob: PersonalizeClientTypes.BatchInferenceJob?

    public init(
        batchInferenceJob: PersonalizeClientTypes.BatchInferenceJob? = nil
    )
    {
        self.batchInferenceJob = batchInferenceJob
    }
}

struct DescribeBatchInferenceJobOutputBody: Swift.Equatable {
    let batchInferenceJob: PersonalizeClientTypes.BatchInferenceJob?
}

extension DescribeBatchInferenceJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJob
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJob.self, forKey: .batchInferenceJob)
        batchInferenceJob = batchInferenceJobDecoded
    }
}

enum DescribeBatchInferenceJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBatchSegmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJobArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSegmentJobArn = self.batchSegmentJobArn {
            try encodeContainer.encode(batchSegmentJobArn, forKey: .batchSegmentJobArn)
        }
    }
}

extension DescribeBatchSegmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBatchSegmentJobInput: Swift.Equatable {
    /// The ARN of the batch segment job to describe.
    /// This member is required.
    public var batchSegmentJobArn: Swift.String?

    public init(
        batchSegmentJobArn: Swift.String? = nil
    )
    {
        self.batchSegmentJobArn = batchSegmentJobArn
    }
}

struct DescribeBatchSegmentJobInputBody: Swift.Equatable {
    let batchSegmentJobArn: Swift.String?
}

extension DescribeBatchSegmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJobArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchSegmentJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchSegmentJobArn)
        batchSegmentJobArn = batchSegmentJobArnDecoded
    }
}

extension DescribeBatchSegmentJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBatchSegmentJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchSegmentJob = output.batchSegmentJob
        } else {
            self.batchSegmentJob = nil
        }
    }
}

public struct DescribeBatchSegmentJobOutput: Swift.Equatable {
    /// Information on the specified batch segment job.
    public var batchSegmentJob: PersonalizeClientTypes.BatchSegmentJob?

    public init(
        batchSegmentJob: PersonalizeClientTypes.BatchSegmentJob? = nil
    )
    {
        self.batchSegmentJob = batchSegmentJob
    }
}

struct DescribeBatchSegmentJobOutputBody: Swift.Equatable {
    let batchSegmentJob: PersonalizeClientTypes.BatchSegmentJob?
}

extension DescribeBatchSegmentJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJob
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchSegmentJobDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchSegmentJob.self, forKey: .batchSegmentJob)
        batchSegmentJob = batchSegmentJobDecoded
    }
}

enum DescribeBatchSegmentJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCampaignInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
    }
}

extension DescribeCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCampaignInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign.
    /// This member is required.
    public var campaignArn: Swift.String?

    public init(
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct DescribeCampaignInputBody: Swift.Equatable {
    let campaignArn: Swift.String?
}

extension DescribeCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

extension DescribeCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCampaignOutputBody = try responseDecoder.decode(responseBody: data)
            self.campaign = output.campaign
        } else {
            self.campaign = nil
        }
    }
}

public struct DescribeCampaignOutput: Swift.Equatable {
    /// The properties of the campaign.
    public var campaign: PersonalizeClientTypes.Campaign?

    public init(
        campaign: PersonalizeClientTypes.Campaign? = nil
    )
    {
        self.campaign = campaign
    }
}

struct DescribeCampaignOutputBody: Swift.Equatable {
    let campaign: PersonalizeClientTypes.Campaign?
}

extension DescribeCampaignOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaign
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Campaign.self, forKey: .campaign)
        campaign = campaignDecoded
    }
}

enum DescribeCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDatasetExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJobArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetExportJobArn = self.datasetExportJobArn {
            try encodeContainer.encode(datasetExportJobArn, forKey: .datasetExportJobArn)
        }
    }
}

extension DescribeDatasetExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset export job to describe.
    /// This member is required.
    public var datasetExportJobArn: Swift.String?

    public init(
        datasetExportJobArn: Swift.String? = nil
    )
    {
        self.datasetExportJobArn = datasetExportJobArn
    }
}

struct DescribeDatasetExportJobInputBody: Swift.Equatable {
    let datasetExportJobArn: Swift.String?
}

extension DescribeDatasetExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJobArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
    }
}

extension DescribeDatasetExportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDatasetExportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetExportJob = output.datasetExportJob
        } else {
            self.datasetExportJob = nil
        }
    }
}

public struct DescribeDatasetExportJobOutput: Swift.Equatable {
    /// Information about the dataset export job, including the status. The status is one of the following values:
    ///
    /// * CREATE PENDING
    ///
    /// * CREATE IN_PROGRESS
    ///
    /// * ACTIVE
    ///
    /// * CREATE FAILED
    public var datasetExportJob: PersonalizeClientTypes.DatasetExportJob?

    public init(
        datasetExportJob: PersonalizeClientTypes.DatasetExportJob? = nil
    )
    {
        self.datasetExportJob = datasetExportJob
    }
}

struct DescribeDatasetExportJobOutputBody: Swift.Equatable {
    let datasetExportJob: PersonalizeClientTypes.DatasetExportJob?
}

extension DescribeDatasetExportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJob
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetExportJob.self, forKey: .datasetExportJob)
        datasetExportJob = datasetExportJobDecoded
    }
}

enum DescribeDatasetExportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDatasetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

extension DescribeDatasetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group to describe.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DescribeDatasetGroupInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
}

extension DescribeDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DescribeDatasetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDatasetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroup = output.datasetGroup
        } else {
            self.datasetGroup = nil
        }
    }
}

public struct DescribeDatasetGroupOutput: Swift.Equatable {
    /// A listing of the dataset group's properties.
    public var datasetGroup: PersonalizeClientTypes.DatasetGroup?

    public init(
        datasetGroup: PersonalizeClientTypes.DatasetGroup? = nil
    )
    {
        self.datasetGroup = datasetGroup
    }
}

struct DescribeDatasetGroupOutputBody: Swift.Equatable {
    let datasetGroup: PersonalizeClientTypes.DatasetGroup?
}

extension DescribeDatasetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetGroup.self, forKey: .datasetGroup)
        datasetGroup = datasetGroupDecoded
    }
}

enum DescribeDatasetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDatasetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = self.datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

extension DescribeDatasetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetImportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job to describe.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init(
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DescribeDatasetImportJobInputBody: Swift.Equatable {
    let datasetImportJobArn: Swift.String?
}

extension DescribeDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DescribeDatasetImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDatasetImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJob = output.datasetImportJob
        } else {
            self.datasetImportJob = nil
        }
    }
}

public struct DescribeDatasetImportJobOutput: Swift.Equatable {
    /// Information about the dataset import job, including the status. The status is one of the following values:
    ///
    /// * CREATE PENDING
    ///
    /// * CREATE IN_PROGRESS
    ///
    /// * ACTIVE
    ///
    /// * CREATE FAILED
    public var datasetImportJob: PersonalizeClientTypes.DatasetImportJob?

    public init(
        datasetImportJob: PersonalizeClientTypes.DatasetImportJob? = nil
    )
    {
        self.datasetImportJob = datasetImportJob
    }
}

struct DescribeDatasetImportJobOutputBody: Swift.Equatable {
    let datasetImportJob: PersonalizeClientTypes.DatasetImportJob?
}

extension DescribeDatasetImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJob
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetImportJob.self, forKey: .datasetImportJob)
        datasetImportJob = datasetImportJobDecoded
    }
}

enum DescribeDatasetImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

extension DescribeDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to describe.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DescribeDatasetInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension DescribeDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DescribeDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataset = output.dataset
        } else {
            self.dataset = nil
        }
    }
}

public struct DescribeDatasetOutput: Swift.Equatable {
    /// A listing of the dataset's properties.
    public var dataset: PersonalizeClientTypes.Dataset?

    public init(
        dataset: PersonalizeClientTypes.Dataset? = nil
    )
    {
        self.dataset = dataset
    }
}

struct DescribeDatasetOutputBody: Swift.Equatable {
    let dataset: PersonalizeClientTypes.Dataset?
}

extension DescribeDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataset
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Dataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

enum DescribeDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventTrackerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTrackerArn = self.eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
    }
}

extension DescribeEventTrackerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventTrackerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the event tracker to describe.
    /// This member is required.
    public var eventTrackerArn: Swift.String?

    public init(
        eventTrackerArn: Swift.String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
    }
}

struct DescribeEventTrackerInputBody: Swift.Equatable {
    let eventTrackerArn: Swift.String?
}

extension DescribeEventTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
    }
}

extension DescribeEventTrackerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventTrackerOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventTracker = output.eventTracker
        } else {
            self.eventTracker = nil
        }
    }
}

public struct DescribeEventTrackerOutput: Swift.Equatable {
    /// An object that describes the event tracker.
    public var eventTracker: PersonalizeClientTypes.EventTracker?

    public init(
        eventTracker: PersonalizeClientTypes.EventTracker? = nil
    )
    {
        self.eventTracker = eventTracker
    }
}

struct DescribeEventTrackerOutputBody: Swift.Equatable {
    let eventTracker: PersonalizeClientTypes.EventTracker?
}

extension DescribeEventTrackerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTracker
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.EventTracker.self, forKey: .eventTracker)
        eventTracker = eventTrackerDecoded
    }
}

enum DescribeEventTrackerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFeatureTransformationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureTransformationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureTransformationArn = self.featureTransformationArn {
            try encodeContainer.encode(featureTransformationArn, forKey: .featureTransformationArn)
        }
    }
}

extension DescribeFeatureTransformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFeatureTransformationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the feature transformation to describe.
    /// This member is required.
    public var featureTransformationArn: Swift.String?

    public init(
        featureTransformationArn: Swift.String? = nil
    )
    {
        self.featureTransformationArn = featureTransformationArn
    }
}

struct DescribeFeatureTransformationInputBody: Swift.Equatable {
    let featureTransformationArn: Swift.String?
}

extension DescribeFeatureTransformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureTransformationArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureTransformationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureTransformationArn)
        featureTransformationArn = featureTransformationArnDecoded
    }
}

extension DescribeFeatureTransformationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFeatureTransformationOutputBody = try responseDecoder.decode(responseBody: data)
            self.featureTransformation = output.featureTransformation
        } else {
            self.featureTransformation = nil
        }
    }
}

public struct DescribeFeatureTransformationOutput: Swift.Equatable {
    /// A listing of the FeatureTransformation properties.
    public var featureTransformation: PersonalizeClientTypes.FeatureTransformation?

    public init(
        featureTransformation: PersonalizeClientTypes.FeatureTransformation? = nil
    )
    {
        self.featureTransformation = featureTransformation
    }
}

struct DescribeFeatureTransformationOutputBody: Swift.Equatable {
    let featureTransformation: PersonalizeClientTypes.FeatureTransformation?
}

extension DescribeFeatureTransformationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureTransformation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureTransformationDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.FeatureTransformation.self, forKey: .featureTransformation)
        featureTransformation = featureTransformationDecoded
    }
}

enum DescribeFeatureTransformationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
    }
}

extension DescribeFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFilterInput: Swift.Equatable {
    /// The ARN of the filter to describe.
    /// This member is required.
    public var filterArn: Swift.String?

    public init(
        filterArn: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

struct DescribeFilterInputBody: Swift.Equatable {
    let filterArn: Swift.String?
}

extension DescribeFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
    }
}

extension DescribeFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.filter = output.filter
        } else {
            self.filter = nil
        }
    }
}

public struct DescribeFilterOutput: Swift.Equatable {
    /// The filter's details.
    public var filter: PersonalizeClientTypes.Filter?

    public init(
        filter: PersonalizeClientTypes.Filter? = nil
    )
    {
        self.filter = filter
    }
}

struct DescribeFilterOutputBody: Swift.Equatable {
    let filter: PersonalizeClientTypes.Filter?
}

extension DescribeFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Filter.self, forKey: .filter)
        filter = filterDecoded
    }
}

enum DescribeFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMetricAttributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricAttributionArn = self.metricAttributionArn {
            try encodeContainer.encode(metricAttributionArn, forKey: .metricAttributionArn)
        }
    }
}

extension DescribeMetricAttributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMetricAttributionInput: Swift.Equatable {
    /// The metric attribution's Amazon Resource Name (ARN).
    /// This member is required.
    public var metricAttributionArn: Swift.String?

    public init(
        metricAttributionArn: Swift.String? = nil
    )
    {
        self.metricAttributionArn = metricAttributionArn
    }
}

struct DescribeMetricAttributionInputBody: Swift.Equatable {
    let metricAttributionArn: Swift.String?
}

extension DescribeMetricAttributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
    }
}

extension DescribeMetricAttributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMetricAttributionOutputBody = try responseDecoder.decode(responseBody: data)
            self.metricAttribution = output.metricAttribution
        } else {
            self.metricAttribution = nil
        }
    }
}

public struct DescribeMetricAttributionOutput: Swift.Equatable {
    /// The details of the metric attribution.
    public var metricAttribution: PersonalizeClientTypes.MetricAttribution?

    public init(
        metricAttribution: PersonalizeClientTypes.MetricAttribution? = nil
    )
    {
        self.metricAttribution = metricAttribution
    }
}

struct DescribeMetricAttributionOutputBody: Swift.Equatable {
    let metricAttribution: PersonalizeClientTypes.MetricAttribution?
}

extension DescribeMetricAttributionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttribution
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.MetricAttribution.self, forKey: .metricAttribution)
        metricAttribution = metricAttributionDecoded
    }
}

enum DescribeMetricAttributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRecipeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipeArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
    }
}

extension DescribeRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recipe to describe.
    /// This member is required.
    public var recipeArn: Swift.String?

    public init(
        recipeArn: Swift.String? = nil
    )
    {
        self.recipeArn = recipeArn
    }
}

struct DescribeRecipeInputBody: Swift.Equatable {
    let recipeArn: Swift.String?
}

extension DescribeRecipeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipeArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
    }
}

extension DescribeRecipeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRecipeOutputBody = try responseDecoder.decode(responseBody: data)
            self.recipe = output.recipe
        } else {
            self.recipe = nil
        }
    }
}

public struct DescribeRecipeOutput: Swift.Equatable {
    /// An object that describes the recipe.
    public var recipe: PersonalizeClientTypes.Recipe?

    public init(
        recipe: PersonalizeClientTypes.Recipe? = nil
    )
    {
        self.recipe = recipe
    }
}

struct DescribeRecipeOutputBody: Swift.Equatable {
    let recipe: PersonalizeClientTypes.Recipe?
}

extension DescribeRecipeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipe
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Recipe.self, forKey: .recipe)
        recipe = recipeDecoded
    }
}

enum DescribeRecipeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRecommenderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
    }
}

extension DescribeRecommenderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRecommenderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender to describe.
    /// This member is required.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct DescribeRecommenderInputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension DescribeRecommenderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

extension DescribeRecommenderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRecommenderOutputBody = try responseDecoder.decode(responseBody: data)
            self.recommender = output.recommender
        } else {
            self.recommender = nil
        }
    }
}

public struct DescribeRecommenderOutput: Swift.Equatable {
    /// The properties of the recommender.
    public var recommender: PersonalizeClientTypes.Recommender?

    public init(
        recommender: PersonalizeClientTypes.Recommender? = nil
    )
    {
        self.recommender = recommender
    }
}

struct DescribeRecommenderOutputBody: Swift.Equatable {
    let recommender: PersonalizeClientTypes.Recommender?
}

extension DescribeRecommenderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommender
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Recommender.self, forKey: .recommender)
        recommender = recommenderDecoded
    }
}

enum DescribeRecommenderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

extension DescribeSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSchemaInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the schema to retrieve.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DescribeSchemaInputBody: Swift.Equatable {
    let schemaArn: Swift.String?
}

extension DescribeSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

extension DescribeSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.schema = output.schema
        } else {
            self.schema = nil
        }
    }
}

public struct DescribeSchemaOutput: Swift.Equatable {
    /// The requested schema.
    public var schema: PersonalizeClientTypes.DatasetSchema?

    public init(
        schema: PersonalizeClientTypes.DatasetSchema? = nil
    )
    {
        self.schema = schema
    }
}

struct DescribeSchemaOutputBody: Swift.Equatable {
    let schema: PersonalizeClientTypes.DatasetSchema?
}

extension DescribeSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schema
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetSchema.self, forKey: .schema)
        schema = schemaDecoded
    }
}

enum DescribeSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSolutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

extension DescribeSolutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSolutionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the solution to describe.
    /// This member is required.
    public var solutionArn: Swift.String?

    public init(
        solutionArn: Swift.String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

struct DescribeSolutionInputBody: Swift.Equatable {
    let solutionArn: Swift.String?
}

extension DescribeSolutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
    }
}

extension DescribeSolutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSolutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.solution = output.solution
        } else {
            self.solution = nil
        }
    }
}

public struct DescribeSolutionOutput: Swift.Equatable {
    /// An object that describes the solution.
    public var solution: PersonalizeClientTypes.Solution?

    public init(
        solution: PersonalizeClientTypes.Solution? = nil
    )
    {
        self.solution = solution
    }
}

struct DescribeSolutionOutputBody: Swift.Equatable {
    let solution: PersonalizeClientTypes.Solution?
}

extension DescribeSolutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solution
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Solution.self, forKey: .solution)
        solution = solutionDecoded
    }
}

enum DescribeSolutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSolutionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

extension DescribeSolutionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSolutionVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the solution version.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init(
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct DescribeSolutionVersionInputBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
}

extension DescribeSolutionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension DescribeSolutionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSolutionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.solutionVersion = output.solutionVersion
        } else {
            self.solutionVersion = nil
        }
    }
}

public struct DescribeSolutionVersionOutput: Swift.Equatable {
    /// The solution version.
    public var solutionVersion: PersonalizeClientTypes.SolutionVersion?

    public init(
        solutionVersion: PersonalizeClientTypes.SolutionVersion? = nil
    )
    {
        self.solutionVersion = solutionVersion
    }
}

struct DescribeSolutionVersionOutputBody: Swift.Equatable {
    let solutionVersion: PersonalizeClientTypes.SolutionVersion?
}

extension DescribeSolutionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionVersion.self, forKey: .solutionVersion)
        solutionVersion = solutionVersionDecoded
    }
}

enum DescribeSolutionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PersonalizeClientTypes {
    public enum Domain: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ecommerce
        case videoOnDemand
        case sdkUnknown(Swift.String)

        public static var allCases: [Domain] {
            return [
                .ecommerce,
                .videoOnDemand,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ecommerce: return "ECOMMERCE"
            case .videoOnDemand: return "VIDEO_ON_DEMAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Domain(rawValue: rawValue) ?? Domain.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.EventTracker: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case creationDateTime
        case datasetGroupArn
        case eventTrackerArn
        case lastUpdatedDateTime
        case name
        case status
        case trackingId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventTrackerArn = self.eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trackingId = self.trackingId {
            try encodeContainer.encode(trackingId, forKey: .trackingId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let trackingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingId)
        trackingId = trackingIdDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides information about an event tracker.
    public struct EventTracker: Swift.Equatable {
        /// The Amazon Web Services account that owns the event tracker.
        public var accountId: Swift.String?
        /// The date and time (in Unix format) that the event tracker was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
        public var datasetGroupArn: Swift.String?
        /// The ARN of the event tracker.
        public var eventTrackerArn: Swift.String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the event tracker.
        public var name: Swift.String?
        /// The status of the event tracker. An event tracker can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?
        /// The ID of the event tracker. Include this ID in requests to the [PutEvents](https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html) API.
        public var trackingId: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            eventTrackerArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil,
            trackingId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
            self.trackingId = trackingId
        }
    }

}

extension PersonalizeClientTypes.EventTrackerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case eventTrackerArn
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let eventTrackerArn = self.eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of an event tracker. For a complete listing, call the [DescribeEventTracker](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeEventTracker.html) API.
    public struct EventTrackerSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the event tracker was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the event tracker.
        public var eventTrackerArn: Swift.String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the event tracker.
        public var name: Swift.String?
        /// The status of the event tracker. An event tracker can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            eventTrackerArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.FeatureTransformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case defaultParameters
        case featureTransformationArn
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let defaultParameters = defaultParameters {
            var defaultParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .defaultParameters)
            for (dictKey0, featurizationParameters0) in defaultParameters {
                try defaultParametersContainer.encode(featurizationParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let featureTransformationArn = self.featureTransformationArn {
            try encodeContainer.encode(featureTransformationArn, forKey: .featureTransformationArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let featureTransformationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureTransformationArn)
        featureTransformationArn = featureTransformationArnDecoded
        let defaultParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .defaultParameters)
        var defaultParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let defaultParametersContainer = defaultParametersContainer {
            defaultParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in defaultParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    defaultParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        defaultParameters = defaultParametersDecoded0
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides feature transformation information. Feature transformation is the process of modifying raw input data into a form more suitable for model training.
    public struct FeatureTransformation: Swift.Equatable {
        /// The creation date and time (in Unix time) of the feature transformation.
        public var creationDateTime: ClientRuntime.Date?
        /// Provides the default parameters for feature transformation.
        public var defaultParameters: [Swift.String:Swift.String]?
        /// The Amazon Resource Name (ARN) of the FeatureTransformation object.
        public var featureTransformationArn: Swift.String?
        /// The last update date and time (in Unix time) of the feature transformation.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the feature transformation.
        public var name: Swift.String?
        /// The status of the feature transformation. A feature transformation can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            defaultParameters: [Swift.String:Swift.String]? = nil,
            featureTransformationArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.defaultParameters = defaultParameters
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case filterArn
        case filterExpression
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterExpression = self.filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension PersonalizeClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(creationDateTime: \(Swift.String(describing: creationDateTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), failureReason: \(Swift.String(describing: failureReason)), filterArn: \(Swift.String(describing: filterArn)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), filterExpression: \"CONTENT_REDACTED\")"}
}

extension PersonalizeClientTypes {
    /// Contains information on a recommendation filter, including its ARN, status, and filter expression.
    public struct Filter: Swift.Equatable {
        /// The time at which the filter was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The ARN of the dataset group to which the filter belongs.
        public var datasetGroupArn: Swift.String?
        /// If the filter failed, the reason for its failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter.
        public var filterArn: Swift.String?
        /// Specifies the type of item interactions to filter out of recommendation results. The filter expression must follow specific format rules. For information about filter expression structure and syntax, see [Filter expressions](https://docs.aws.amazon.com/personalize/latest/dg/filter-expressions.html).
        public var filterExpression: Swift.String?
        /// The time at which the filter was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the filter.
        public var name: Swift.String?
        /// The status of the filter.
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            filterExpression: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.filterExpression = filterExpression
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.FilterSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case filterArn
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension PersonalizeClientTypes {
    /// A short summary of a filter's attributes.
    public struct FilterSummary: Swift.Equatable {
        /// The time at which the filter was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The ARN of the dataset group to which the filter belongs.
        public var datasetGroupArn: Swift.String?
        /// If the filter failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter.
        public var filterArn: Swift.String?
        /// The time at which the filter was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the filter.
        public var name: Swift.String?
        /// The status of the filter.
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension GetSolutionMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

extension GetSolutionMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSolutionMetricsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the solution version for which to get metrics.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init(
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct GetSolutionMetricsInputBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
}

extension GetSolutionMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension GetSolutionMetricsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSolutionMetricsOutputBody = try responseDecoder.decode(responseBody: data)
            self.metrics = output.metrics
            self.solutionVersionArn = output.solutionVersionArn
        } else {
            self.metrics = nil
            self.solutionVersionArn = nil
        }
    }
}

public struct GetSolutionMetricsOutput: Swift.Equatable {
    /// The metrics for the solution version. For more information, see [ Evaluating a solution version with metrics ](https://docs.aws.amazon.com/personalize/latest/dg/working-with-training-metrics.html).
    public var metrics: [Swift.String:Swift.Double]?
    /// The same solution version ARN as specified in the request.
    public var solutionVersionArn: Swift.String?

    public init(
        metrics: [Swift.String:Swift.Double]? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.metrics = metrics
        self.solutionVersionArn = solutionVersionArn
    }
}

struct GetSolutionMetricsOutputBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
    let metrics: [Swift.String:Swift.Double]?
}

extension GetSolutionMetricsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metrics
        case solutionVersionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Double?].self, forKey: .metrics)
        var metricsDecoded0: [Swift.String:Swift.Double]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String:Swift.Double]()
            for (key0, metricvalue0) in metricsContainer {
                if let metricvalue0 = metricvalue0 {
                    metricsDecoded0?[key0] = metricvalue0
                }
            }
        }
        metrics = metricsDecoded0
    }
}

enum GetSolutionMetricsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PersonalizeClientTypes.HPOConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmHyperParameterRanges
        case hpoObjective
        case hpoResourceConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmHyperParameterRanges = self.algorithmHyperParameterRanges {
            try encodeContainer.encode(algorithmHyperParameterRanges, forKey: .algorithmHyperParameterRanges)
        }
        if let hpoObjective = self.hpoObjective {
            try encodeContainer.encode(hpoObjective, forKey: .hpoObjective)
        }
        if let hpoResourceConfig = self.hpoResourceConfig {
            try encodeContainer.encode(hpoResourceConfig, forKey: .hpoResourceConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hpoObjectiveDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.HPOObjective.self, forKey: .hpoObjective)
        hpoObjective = hpoObjectiveDecoded
        let hpoResourceConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.HPOResourceConfig.self, forKey: .hpoResourceConfig)
        hpoResourceConfig = hpoResourceConfigDecoded
        let algorithmHyperParameterRangesDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.HyperParameterRanges.self, forKey: .algorithmHyperParameterRanges)
        algorithmHyperParameterRanges = algorithmHyperParameterRangesDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes the properties for hyperparameter optimization (HPO).
    public struct HPOConfig: Swift.Equatable {
        /// The hyperparameters and their allowable ranges.
        public var algorithmHyperParameterRanges: PersonalizeClientTypes.HyperParameterRanges?
        /// The metric to optimize during HPO. Amazon Personalize doesn't support configuring the hpoObjective at this time.
        public var hpoObjective: PersonalizeClientTypes.HPOObjective?
        /// Describes the resource configuration for HPO.
        public var hpoResourceConfig: PersonalizeClientTypes.HPOResourceConfig?

        public init(
            algorithmHyperParameterRanges: PersonalizeClientTypes.HyperParameterRanges? = nil,
            hpoObjective: PersonalizeClientTypes.HPOObjective? = nil,
            hpoResourceConfig: PersonalizeClientTypes.HPOResourceConfig? = nil
        )
        {
            self.algorithmHyperParameterRanges = algorithmHyperParameterRanges
            self.hpoObjective = hpoObjective
            self.hpoResourceConfig = hpoResourceConfig
        }
    }

}

extension PersonalizeClientTypes.HPOObjective: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName
        case metricRegex
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricRegex = self.metricRegex {
            try encodeContainer.encode(metricRegex, forKey: .metricRegex)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricRegexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricRegex)
        metricRegex = metricRegexDecoded
    }
}

extension PersonalizeClientTypes {
    /// The metric to optimize during hyperparameter optimization (HPO). Amazon Personalize doesn't support configuring the hpoObjective at this time.
    public struct HPOObjective: Swift.Equatable {
        /// The name of the metric.
        public var metricName: Swift.String?
        /// A regular expression for finding the metric in the training job logs.
        public var metricRegex: Swift.String?
        /// The type of the metric. Valid values are Maximize and Minimize.
        public var type: Swift.String?

        public init(
            metricName: Swift.String? = nil,
            metricRegex: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.metricRegex = metricRegex
            self.type = type
        }
    }

}

extension PersonalizeClientTypes.HPOResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxNumberOfTrainingJobs
        case maxParallelTrainingJobs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxNumberOfTrainingJobs = self.maxNumberOfTrainingJobs {
            try encodeContainer.encode(maxNumberOfTrainingJobs, forKey: .maxNumberOfTrainingJobs)
        }
        if let maxParallelTrainingJobs = self.maxParallelTrainingJobs {
            try encodeContainer.encode(maxParallelTrainingJobs, forKey: .maxParallelTrainingJobs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxNumberOfTrainingJobsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxNumberOfTrainingJobs)
        maxNumberOfTrainingJobs = maxNumberOfTrainingJobsDecoded
        let maxParallelTrainingJobsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxParallelTrainingJobs)
        maxParallelTrainingJobs = maxParallelTrainingJobsDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes the resource configuration for hyperparameter optimization (HPO).
    public struct HPOResourceConfig: Swift.Equatable {
        /// The maximum number of training jobs when you create a solution version. The maximum value for maxNumberOfTrainingJobs is 40.
        public var maxNumberOfTrainingJobs: Swift.String?
        /// The maximum number of parallel training jobs when you create a solution version. The maximum value for maxParallelTrainingJobs is 10.
        public var maxParallelTrainingJobs: Swift.String?

        public init(
            maxNumberOfTrainingJobs: Swift.String? = nil,
            maxParallelTrainingJobs: Swift.String? = nil
        )
        {
            self.maxNumberOfTrainingJobs = maxNumberOfTrainingJobs
            self.maxParallelTrainingJobs = maxParallelTrainingJobs
        }
    }

}

extension PersonalizeClientTypes.HyperParameterRanges: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoricalHyperParameterRanges
        case continuousHyperParameterRanges
        case integerHyperParameterRanges
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalHyperParameterRanges = categoricalHyperParameterRanges {
            var categoricalHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoricalHyperParameterRanges)
            for categoricalhyperparameterrange0 in categoricalHyperParameterRanges {
                try categoricalHyperParameterRangesContainer.encode(categoricalhyperparameterrange0)
            }
        }
        if let continuousHyperParameterRanges = continuousHyperParameterRanges {
            var continuousHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .continuousHyperParameterRanges)
            for continuoushyperparameterrange0 in continuousHyperParameterRanges {
                try continuousHyperParameterRangesContainer.encode(continuoushyperparameterrange0)
            }
        }
        if let integerHyperParameterRanges = integerHyperParameterRanges {
            var integerHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerHyperParameterRanges)
            for integerhyperparameterrange0 in integerHyperParameterRanges {
                try integerHyperParameterRangesContainer.encode(integerhyperparameterrange0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integerHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.IntegerHyperParameterRange?].self, forKey: .integerHyperParameterRanges)
        var integerHyperParameterRangesDecoded0:[PersonalizeClientTypes.IntegerHyperParameterRange]? = nil
        if let integerHyperParameterRangesContainer = integerHyperParameterRangesContainer {
            integerHyperParameterRangesDecoded0 = [PersonalizeClientTypes.IntegerHyperParameterRange]()
            for structure0 in integerHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    integerHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        integerHyperParameterRanges = integerHyperParameterRangesDecoded0
        let continuousHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.ContinuousHyperParameterRange?].self, forKey: .continuousHyperParameterRanges)
        var continuousHyperParameterRangesDecoded0:[PersonalizeClientTypes.ContinuousHyperParameterRange]? = nil
        if let continuousHyperParameterRangesContainer = continuousHyperParameterRangesContainer {
            continuousHyperParameterRangesDecoded0 = [PersonalizeClientTypes.ContinuousHyperParameterRange]()
            for structure0 in continuousHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    continuousHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        continuousHyperParameterRanges = continuousHyperParameterRangesDecoded0
        let categoricalHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.CategoricalHyperParameterRange?].self, forKey: .categoricalHyperParameterRanges)
        var categoricalHyperParameterRangesDecoded0:[PersonalizeClientTypes.CategoricalHyperParameterRange]? = nil
        if let categoricalHyperParameterRangesContainer = categoricalHyperParameterRangesContainer {
            categoricalHyperParameterRangesDecoded0 = [PersonalizeClientTypes.CategoricalHyperParameterRange]()
            for structure0 in categoricalHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    categoricalHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        categoricalHyperParameterRanges = categoricalHyperParameterRangesDecoded0
    }
}

extension PersonalizeClientTypes {
    /// Specifies the hyperparameters and their ranges. Hyperparameters can be categorical, continuous, or integer-valued.
    public struct HyperParameterRanges: Swift.Equatable {
        /// The categorical hyperparameters and their ranges.
        public var categoricalHyperParameterRanges: [PersonalizeClientTypes.CategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their ranges.
        public var continuousHyperParameterRanges: [PersonalizeClientTypes.ContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their ranges.
        public var integerHyperParameterRanges: [PersonalizeClientTypes.IntegerHyperParameterRange]?

        public init(
            categoricalHyperParameterRanges: [PersonalizeClientTypes.CategoricalHyperParameterRange]? = nil,
            continuousHyperParameterRanges: [PersonalizeClientTypes.ContinuousHyperParameterRange]? = nil,
            integerHyperParameterRanges: [PersonalizeClientTypes.IntegerHyperParameterRange]? = nil
        )
        {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }
    }

}

extension PersonalizeClientTypes {
    public enum ImportMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case incremental
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportMode] {
            return [
                .full,
                .incremental,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .incremental: return "INCREMENTAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportMode(rawValue: rawValue) ?? ImportMode.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes {
    public enum IngestionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case bulk
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionMode] {
            return [
                .all,
                .bulk,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .bulk: return "BULK"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionMode(rawValue: rawValue) ?? IngestionMode.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.IntegerHyperParameterRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxValue != 0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minValue) ?? 0
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxValue) ?? 0
        maxValue = maxValueDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides the name and range of an integer-valued hyperparameter.
    public struct IntegerHyperParameterRange: Swift.Equatable {
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Int
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Int
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init(
            maxValue: Swift.Int = 0,
            minValue: Swift.Int = 0,
            name: Swift.String? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }

}

extension InvalidInputException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Provide a valid value for the field or parameter.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The token is not valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The limit on the number of requests per second has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBatchInferenceJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

extension ListBatchInferenceJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListBatchInferenceJobsInput: Swift.Equatable {
    /// The maximum number of batch inference job results to return in each page. The default value is 100.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version from which the batch inference jobs were created.
    public var solutionVersionArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionVersionArn = solutionVersionArn
    }
}

struct ListBatchInferenceJobsInputBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListBatchInferenceJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionVersionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListBatchInferenceJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBatchInferenceJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchInferenceJobs = output.batchInferenceJobs
            self.nextToken = output.nextToken
        } else {
            self.batchInferenceJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBatchInferenceJobsOutput: Swift.Equatable {
    /// A list containing information on each job that is returned.
    public var batchInferenceJobs: [PersonalizeClientTypes.BatchInferenceJobSummary]?
    /// The token to use to retrieve the next page of results. The value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        batchInferenceJobs: [PersonalizeClientTypes.BatchInferenceJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchInferenceJobs = batchInferenceJobs
        self.nextToken = nextToken
    }
}

struct ListBatchInferenceJobsOutputBody: Swift.Equatable {
    let batchInferenceJobs: [PersonalizeClientTypes.BatchInferenceJobSummary]?
    let nextToken: Swift.String?
}

extension ListBatchInferenceJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.BatchInferenceJobSummary?].self, forKey: .batchInferenceJobs)
        var batchInferenceJobsDecoded0:[PersonalizeClientTypes.BatchInferenceJobSummary]? = nil
        if let batchInferenceJobsContainer = batchInferenceJobsContainer {
            batchInferenceJobsDecoded0 = [PersonalizeClientTypes.BatchInferenceJobSummary]()
            for structure0 in batchInferenceJobsContainer {
                if let structure0 = structure0 {
                    batchInferenceJobsDecoded0?.append(structure0)
                }
            }
        }
        batchInferenceJobs = batchInferenceJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBatchInferenceJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBatchSegmentJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

extension ListBatchSegmentJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListBatchSegmentJobsInput: Swift.Equatable {
    /// The maximum number of batch segment job results to return in each page. The default value is 100.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version that the batch segment jobs used to generate batch segments.
    public var solutionVersionArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionVersionArn = solutionVersionArn
    }
}

struct ListBatchSegmentJobsInputBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListBatchSegmentJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionVersionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListBatchSegmentJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBatchSegmentJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchSegmentJobs = output.batchSegmentJobs
            self.nextToken = output.nextToken
        } else {
            self.batchSegmentJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBatchSegmentJobsOutput: Swift.Equatable {
    /// A list containing information on each job that is returned.
    public var batchSegmentJobs: [PersonalizeClientTypes.BatchSegmentJobSummary]?
    /// The token to use to retrieve the next page of results. The value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        batchSegmentJobs: [PersonalizeClientTypes.BatchSegmentJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchSegmentJobs = batchSegmentJobs
        self.nextToken = nextToken
    }
}

struct ListBatchSegmentJobsOutputBody: Swift.Equatable {
    let batchSegmentJobs: [PersonalizeClientTypes.BatchSegmentJobSummary]?
    let nextToken: Swift.String?
}

extension ListBatchSegmentJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchSegmentJobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchSegmentJobsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.BatchSegmentJobSummary?].self, forKey: .batchSegmentJobs)
        var batchSegmentJobsDecoded0:[PersonalizeClientTypes.BatchSegmentJobSummary]? = nil
        if let batchSegmentJobsContainer = batchSegmentJobsContainer {
            batchSegmentJobsDecoded0 = [PersonalizeClientTypes.BatchSegmentJobSummary]()
            for structure0 in batchSegmentJobsContainer {
                if let structure0 = structure0 {
                    batchSegmentJobsDecoded0?.append(structure0)
                }
            }
        }
        batchSegmentJobs = batchSegmentJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBatchSegmentJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCampaignsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

extension ListCampaignsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCampaignsInput: Swift.Equatable {
    /// The maximum number of campaigns to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to [ListCampaigns](https://docs.aws.amazon.com/personalize/latest/dg/API_ListCampaigns.html) for getting the next set of campaigns (if they exist).
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution to list the campaigns for. When a solution is not specified, all the campaigns associated with the account are listed.
    public var solutionArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionArn = solutionArn
    }
}

struct ListCampaignsInputBody: Swift.Equatable {
    let solutionArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListCampaignsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCampaignsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCampaignsOutputBody = try responseDecoder.decode(responseBody: data)
            self.campaigns = output.campaigns
            self.nextToken = output.nextToken
        } else {
            self.campaigns = nil
            self.nextToken = nil
        }
    }
}

public struct ListCampaignsOutput: Swift.Equatable {
    /// A list of the campaigns.
    public var campaigns: [PersonalizeClientTypes.CampaignSummary]?
    /// A token for getting the next set of campaigns (if they exist).
    public var nextToken: Swift.String?

    public init(
        campaigns: [PersonalizeClientTypes.CampaignSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.campaigns = campaigns
        self.nextToken = nextToken
    }
}

struct ListCampaignsOutputBody: Swift.Equatable {
    let campaigns: [PersonalizeClientTypes.CampaignSummary]?
    let nextToken: Swift.String?
}

extension ListCampaignsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaigns
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.CampaignSummary?].self, forKey: .campaigns)
        var campaignsDecoded0:[PersonalizeClientTypes.CampaignSummary]? = nil
        if let campaignsContainer = campaignsContainer {
            campaignsDecoded0 = [PersonalizeClientTypes.CampaignSummary]()
            for structure0 in campaignsContainer {
                if let structure0 = structure0 {
                    campaignsDecoded0?.append(structure0)
                }
            }
        }
        campaigns = campaignsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCampaignsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDatasetExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetExportJobsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to list the dataset export jobs for.
    public var datasetArn: Swift.String?
    /// The maximum number of dataset export jobs to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetExportJobs for getting the next set of dataset export jobs (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetExportJobsInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetExportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatasetExportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetExportJobs = output.datasetExportJobs
            self.nextToken = output.nextToken
        } else {
            self.datasetExportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetExportJobsOutput: Swift.Equatable {
    /// The list of dataset export jobs.
    public var datasetExportJobs: [PersonalizeClientTypes.DatasetExportJobSummary]?
    /// A token for getting the next set of dataset export jobs (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetExportJobs: [PersonalizeClientTypes.DatasetExportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetExportJobs = datasetExportJobs
        self.nextToken = nextToken
    }
}

struct ListDatasetExportJobsOutputBody: Swift.Equatable {
    let datasetExportJobs: [PersonalizeClientTypes.DatasetExportJobSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetExportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetExportJobSummary?].self, forKey: .datasetExportJobs)
        var datasetExportJobsDecoded0:[PersonalizeClientTypes.DatasetExportJobSummary]? = nil
        if let datasetExportJobsContainer = datasetExportJobsContainer {
            datasetExportJobsDecoded0 = [PersonalizeClientTypes.DatasetExportJobSummary]()
            for structure0 in datasetExportJobsContainer {
                if let structure0 = structure0 {
                    datasetExportJobsDecoded0?.append(structure0)
                }
            }
        }
        datasetExportJobs = datasetExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatasetExportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDatasetGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetGroupsInput: Swift.Equatable {
    /// The maximum number of dataset groups to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetGroups for getting the next set of dataset groups (if they exist).
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatasetGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroups = output.datasetGroups
            self.nextToken = output.nextToken
        } else {
            self.datasetGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetGroupsOutput: Swift.Equatable {
    /// The list of your dataset groups.
    public var datasetGroups: [PersonalizeClientTypes.DatasetGroupSummary]?
    /// A token for getting the next set of dataset groups (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetGroups: [PersonalizeClientTypes.DatasetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroups = datasetGroups
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsOutputBody: Swift.Equatable {
    let datasetGroups: [PersonalizeClientTypes.DatasetGroupSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroups
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetGroupSummary?].self, forKey: .datasetGroups)
        var datasetGroupsDecoded0:[PersonalizeClientTypes.DatasetGroupSummary]? = nil
        if let datasetGroupsContainer = datasetGroupsContainer {
            datasetGroupsDecoded0 = [PersonalizeClientTypes.DatasetGroupSummary]()
            for structure0 in datasetGroupsContainer {
                if let structure0 = structure0 {
                    datasetGroupsDecoded0?.append(structure0)
                }
            }
        }
        datasetGroups = datasetGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatasetGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDatasetImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetImportJobsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to list the dataset import jobs for.
    public var datasetArn: Swift.String?
    /// The maximum number of dataset import jobs to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetImportJobs for getting the next set of dataset import jobs (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetImportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatasetImportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobs = output.datasetImportJobs
            self.nextToken = output.nextToken
        } else {
            self.datasetImportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetImportJobsOutput: Swift.Equatable {
    /// The list of dataset import jobs.
    public var datasetImportJobs: [PersonalizeClientTypes.DatasetImportJobSummary]?
    /// A token for getting the next set of dataset import jobs (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetImportJobs: [PersonalizeClientTypes.DatasetImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetImportJobs = datasetImportJobs
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsOutputBody: Swift.Equatable {
    let datasetImportJobs: [PersonalizeClientTypes.DatasetImportJobSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetImportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetImportJobSummary?].self, forKey: .datasetImportJobs)
        var datasetImportJobsDecoded0:[PersonalizeClientTypes.DatasetImportJobSummary]? = nil
        if let datasetImportJobsContainer = datasetImportJobsContainer {
            datasetImportJobsDecoded0 = [PersonalizeClientTypes.DatasetImportJobSummary]()
            for structure0 in datasetImportJobsContainer {
                if let structure0 = structure0 {
                    datasetImportJobsDecoded0?.append(structure0)
                }
            }
        }
        datasetImportJobs = datasetImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatasetImportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDatasetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatasetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatasetsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group that contains the datasets to list.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of datasets to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetImportJobs for getting the next set of dataset import jobs (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatasetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatasetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutput: Swift.Equatable {
    /// An array of Dataset objects. Each object provides metadata information.
    public var datasets: [PersonalizeClientTypes.DatasetSummary]?
    /// A token for getting the next set of datasets (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasets: [PersonalizeClientTypes.DatasetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputBody: Swift.Equatable {
    let datasets: [PersonalizeClientTypes.DatasetSummary]?
    let nextToken: Swift.String?
}

extension ListDatasetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasets
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetSummary?].self, forKey: .datasets)
        var datasetsDecoded0:[PersonalizeClientTypes.DatasetSummary]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [PersonalizeClientTypes.DatasetSummary]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatasetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEventTrackersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEventTrackersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEventTrackersInput: Swift.Equatable {
    /// The ARN of a dataset group used to filter the response.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of event trackers to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListEventTrackers for getting the next set of event trackers (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventTrackersInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEventTrackersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventTrackersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEventTrackersOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventTrackers = output.eventTrackers
            self.nextToken = output.nextToken
        } else {
            self.eventTrackers = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventTrackersOutput: Swift.Equatable {
    /// A list of event trackers.
    public var eventTrackers: [PersonalizeClientTypes.EventTrackerSummary]?
    /// A token for getting the next set of event trackers (if they exist).
    public var nextToken: Swift.String?

    public init(
        eventTrackers: [PersonalizeClientTypes.EventTrackerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventTrackers = eventTrackers
        self.nextToken = nextToken
    }
}

struct ListEventTrackersOutputBody: Swift.Equatable {
    let eventTrackers: [PersonalizeClientTypes.EventTrackerSummary]?
    let nextToken: Swift.String?
}

extension ListEventTrackersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackers
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackersContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.EventTrackerSummary?].self, forKey: .eventTrackers)
        var eventTrackersDecoded0:[PersonalizeClientTypes.EventTrackerSummary]? = nil
        if let eventTrackersContainer = eventTrackersContainer {
            eventTrackersDecoded0 = [PersonalizeClientTypes.EventTrackerSummary]()
            for structure0 in eventTrackersContainer {
                if let structure0 = structure0 {
                    eventTrackersDecoded0?.append(structure0)
                }
            }
        }
        eventTrackers = eventTrackersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEventTrackersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFiltersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFiltersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFiltersInput: Swift.Equatable {
    /// The ARN of the dataset group that contains the filters.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of filters to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListFilters for getting the next set of filters (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFiltersInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFiltersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFiltersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFiltersOutputBody = try responseDecoder.decode(responseBody: data)
            self.filters = output.filters
            self.nextToken = output.nextToken
        } else {
            self.filters = nil
            self.nextToken = nil
        }
    }
}

public struct ListFiltersOutput: Swift.Equatable {
    /// A list of returned filters.
    public var filters: [PersonalizeClientTypes.FilterSummary]?
    /// A token for getting the next set of filters (if they exist).
    public var nextToken: Swift.String?

    public init(
        filters: [PersonalizeClientTypes.FilterSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.nextToken = nextToken
    }
}

struct ListFiltersOutputBody: Swift.Equatable {
    let filters: [PersonalizeClientTypes.FilterSummary]?
    let nextToken: Swift.String?
}

extension ListFiltersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.FilterSummary?].self, forKey: .filters)
        var filtersDecoded0:[PersonalizeClientTypes.FilterSummary]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PersonalizeClientTypes.FilterSummary]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFiltersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMetricAttributionMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case metricAttributionArn
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metricAttributionArn = self.metricAttributionArn {
            try encodeContainer.encode(metricAttributionArn, forKey: .metricAttributionArn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMetricAttributionMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMetricAttributionMetricsInput: Swift.Equatable {
    /// The maximum number of metrics to return in one page of results.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the metric attribution to retrieve attributes for.
    public var metricAttributionArn: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        metricAttributionArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.metricAttributionArn = metricAttributionArn
        self.nextToken = nextToken
    }
}

struct ListMetricAttributionMetricsInputBody: Swift.Equatable {
    let metricAttributionArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMetricAttributionMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case metricAttributionArn
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMetricAttributionMetricsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMetricAttributionMetricsOutputBody = try responseDecoder.decode(responseBody: data)
            self.metrics = output.metrics
            self.nextToken = output.nextToken
        } else {
            self.metrics = nil
            self.nextToken = nil
        }
    }
}

public struct ListMetricAttributionMetricsOutput: Swift.Equatable {
    /// The metrics for the specified metric attribution.
    public var metrics: [PersonalizeClientTypes.MetricAttribute]?
    /// Specify the pagination token from a previous ListMetricAttributionMetricsResponse request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        metrics: [PersonalizeClientTypes.MetricAttribute]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metrics = metrics
        self.nextToken = nextToken
    }
}

struct ListMetricAttributionMetricsOutputBody: Swift.Equatable {
    let metrics: [PersonalizeClientTypes.MetricAttribute]?
    let nextToken: Swift.String?
}

extension ListMetricAttributionMetricsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metrics
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.MetricAttribute?].self, forKey: .metrics)
        var metricsDecoded0:[PersonalizeClientTypes.MetricAttribute]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [PersonalizeClientTypes.MetricAttribute]()
            for structure0 in metricsContainer {
                if let structure0 = structure0 {
                    metricsDecoded0?.append(structure0)
                }
            }
        }
        metrics = metricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMetricAttributionMetricsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMetricAttributionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMetricAttributionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMetricAttributionsInput: Swift.Equatable {
    /// The metric attributions' dataset group Amazon Resource Name (ARN).
    public var datasetGroupArn: Swift.String?
    /// The maximum number of metric attributions to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMetricAttributionsInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMetricAttributionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMetricAttributionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMetricAttributionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.metricAttributions = output.metricAttributions
            self.nextToken = output.nextToken
        } else {
            self.metricAttributions = nil
            self.nextToken = nil
        }
    }
}

public struct ListMetricAttributionsOutput: Swift.Equatable {
    /// The list of metric attributions.
    public var metricAttributions: [PersonalizeClientTypes.MetricAttributionSummary]?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        metricAttributions: [PersonalizeClientTypes.MetricAttributionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricAttributions = metricAttributions
        self.nextToken = nextToken
    }
}

struct ListMetricAttributionsOutputBody: Swift.Equatable {
    let metricAttributions: [PersonalizeClientTypes.MetricAttributionSummary]?
    let nextToken: Swift.String?
}

extension ListMetricAttributionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.MetricAttributionSummary?].self, forKey: .metricAttributions)
        var metricAttributionsDecoded0:[PersonalizeClientTypes.MetricAttributionSummary]? = nil
        if let metricAttributionsContainer = metricAttributionsContainer {
            metricAttributionsDecoded0 = [PersonalizeClientTypes.MetricAttributionSummary]()
            for structure0 in metricAttributionsContainer {
                if let structure0 = structure0 {
                    metricAttributionsDecoded0?.append(structure0)
                }
            }
        }
        metricAttributions = metricAttributionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMetricAttributionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecipesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case maxResults
        case nextToken
        case recipeProvider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let recipeProvider = self.recipeProvider {
            try encodeContainer.encode(recipeProvider.rawValue, forKey: .recipeProvider)
        }
    }
}

extension ListRecipesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRecipesInput: Swift.Equatable {
    /// Filters returned recipes by domain for a Domain dataset group. Only recipes (Domain dataset group use cases) for this domain are included in the response. If you don't specify a domain, all recipes are returned.
    public var domain: PersonalizeClientTypes.Domain?
    /// The maximum number of recipes to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListRecipes for getting the next set of recipes (if they exist).
    public var nextToken: Swift.String?
    /// The default is SERVICE.
    public var recipeProvider: PersonalizeClientTypes.RecipeProvider?

    public init(
        domain: PersonalizeClientTypes.Domain? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recipeProvider: PersonalizeClientTypes.RecipeProvider? = nil
    )
    {
        self.domain = domain
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recipeProvider = recipeProvider
    }
}

struct ListRecipesInputBody: Swift.Equatable {
    let recipeProvider: PersonalizeClientTypes.RecipeProvider?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let domain: PersonalizeClientTypes.Domain?
}

extension ListRecipesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case maxResults
        case nextToken
        case recipeProvider
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeProviderDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecipeProvider.self, forKey: .recipeProvider)
        recipeProvider = recipeProviderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension ListRecipesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecipesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recipes = output.recipes
        } else {
            self.nextToken = nil
            self.recipes = nil
        }
    }
}

public struct ListRecipesOutput: Swift.Equatable {
    /// A token for getting the next set of recipes.
    public var nextToken: Swift.String?
    /// The list of available recipes.
    public var recipes: [PersonalizeClientTypes.RecipeSummary]?

    public init(
        nextToken: Swift.String? = nil,
        recipes: [PersonalizeClientTypes.RecipeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recipes = recipes
    }
}

struct ListRecipesOutputBody: Swift.Equatable {
    let recipes: [PersonalizeClientTypes.RecipeSummary]?
    let nextToken: Swift.String?
}

extension ListRecipesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recipes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.RecipeSummary?].self, forKey: .recipes)
        var recipesDecoded0:[PersonalizeClientTypes.RecipeSummary]? = nil
        if let recipesContainer = recipesContainer {
            recipesDecoded0 = [PersonalizeClientTypes.RecipeSummary]()
            for structure0 in recipesContainer {
                if let structure0 = structure0 {
                    recipesDecoded0?.append(structure0)
                }
            }
        }
        recipes = recipesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRecipesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecommendersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRecommendersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRecommendersInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Domain dataset group to list the recommenders for. When a Domain dataset group is not specified, all the recommenders associated with the account are listed.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of recommenders to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListRecommenders for getting the next set of recommenders (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecommendersInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRecommendersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRecommendersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecommendersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommenders = output.recommenders
        } else {
            self.nextToken = nil
            self.recommenders = nil
        }
    }
}

public struct ListRecommendersOutput: Swift.Equatable {
    /// A token for getting the next set of recommenders (if they exist).
    public var nextToken: Swift.String?
    /// A list of the recommenders.
    public var recommenders: [PersonalizeClientTypes.RecommenderSummary]?

    public init(
        nextToken: Swift.String? = nil,
        recommenders: [PersonalizeClientTypes.RecommenderSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommenders = recommenders
    }
}

struct ListRecommendersOutputBody: Swift.Equatable {
    let recommenders: [PersonalizeClientTypes.RecommenderSummary]?
    let nextToken: Swift.String?
}

extension ListRecommendersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recommenders
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendersContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.RecommenderSummary?].self, forKey: .recommenders)
        var recommendersDecoded0:[PersonalizeClientTypes.RecommenderSummary]? = nil
        if let recommendersContainer = recommendersContainer {
            recommendersDecoded0 = [PersonalizeClientTypes.RecommenderSummary]()
            for structure0 in recommendersContainer {
                if let structure0 = structure0 {
                    recommendersDecoded0?.append(structure0)
                }
            }
        }
        recommenders = recommendersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRecommendersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSchemasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSchemasInput: Swift.Equatable {
    /// The maximum number of schemas to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListSchemas for getting the next set of schemas (if they exist).
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSchemasInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSchemasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSchemasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSchemasOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct ListSchemasOutput: Swift.Equatable {
    /// A token used to get the next set of schemas (if they exist).
    public var nextToken: Swift.String?
    /// A list of schemas.
    public var schemas: [PersonalizeClientTypes.DatasetSchemaSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemas: [PersonalizeClientTypes.DatasetSchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct ListSchemasOutputBody: Swift.Equatable {
    let schemas: [PersonalizeClientTypes.DatasetSchemaSummary]?
    let nextToken: Swift.String?
}

extension ListSchemasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case schemas
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemasContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetSchemaSummary?].self, forKey: .schemas)
        var schemasDecoded0:[PersonalizeClientTypes.DatasetSchemaSummary]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [PersonalizeClientTypes.DatasetSchemaSummary]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSchemasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSolutionVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

extension ListSolutionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSolutionVersionsInput: Swift.Equatable {
    /// The maximum number of solution versions to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListSolutionVersions for getting the next set of solution versions (if they exist).
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution.
    public var solutionArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionArn = solutionArn
    }
}

struct ListSolutionVersionsInputBody: Swift.Equatable {
    let solutionArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSolutionVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSolutionVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSolutionVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.solutionVersions = output.solutionVersions
        } else {
            self.nextToken = nil
            self.solutionVersions = nil
        }
    }
}

public struct ListSolutionVersionsOutput: Swift.Equatable {
    /// A token for getting the next set of solution versions (if they exist).
    public var nextToken: Swift.String?
    /// A list of solution versions describing the version properties.
    public var solutionVersions: [PersonalizeClientTypes.SolutionVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        solutionVersions: [PersonalizeClientTypes.SolutionVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.solutionVersions = solutionVersions
    }
}

struct ListSolutionVersionsOutputBody: Swift.Equatable {
    let solutionVersions: [PersonalizeClientTypes.SolutionVersionSummary]?
    let nextToken: Swift.String?
}

extension ListSolutionVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case solutionVersions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.SolutionVersionSummary?].self, forKey: .solutionVersions)
        var solutionVersionsDecoded0:[PersonalizeClientTypes.SolutionVersionSummary]? = nil
        if let solutionVersionsContainer = solutionVersionsContainer {
            solutionVersionsDecoded0 = [PersonalizeClientTypes.SolutionVersionSummary]()
            for structure0 in solutionVersionsContainer {
                if let structure0 = structure0 {
                    solutionVersionsDecoded0?.append(structure0)
                }
            }
        }
        solutionVersions = solutionVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSolutionVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSolutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSolutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSolutionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of solutions to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListSolutions for getting the next set of solutions (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolutionsInputBody: Swift.Equatable {
    let datasetGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSolutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSolutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSolutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.solutions = output.solutions
        } else {
            self.nextToken = nil
            self.solutions = nil
        }
    }
}

public struct ListSolutionsOutput: Swift.Equatable {
    /// A token for getting the next set of solutions (if they exist).
    public var nextToken: Swift.String?
    /// A list of the current solutions.
    public var solutions: [PersonalizeClientTypes.SolutionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        solutions: [PersonalizeClientTypes.SolutionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.solutions = solutions
    }
}

struct ListSolutionsOutputBody: Swift.Equatable {
    let solutions: [PersonalizeClientTypes.SolutionSummary]?
    let nextToken: Swift.String?
}

extension ListSolutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case solutions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.SolutionSummary?].self, forKey: .solutions)
        var solutionsDecoded0:[PersonalizeClientTypes.SolutionSummary]? = nil
        if let solutionsContainer = solutionsContainer {
            solutionsDecoded0 = [PersonalizeClientTypes.SolutionSummary]()
            for structure0 in solutionsContainer {
                if let structure0 = structure0 {
                    solutionsDecoded0?.append(structure0)
                }
            }
        }
        solutions = solutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSolutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The resource's tags.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [PersonalizeClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PersonalizeClientTypes.MetricAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType
        case expression
        case metricName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension PersonalizeClientTypes {
    /// Contains information on a metric that a metric attribution reports on. For more information, see [Measuring impact of recommendations](https://docs.aws.amazon.com/personalize/latest/dg/measuring-recommendation-impact.html).
    public struct MetricAttribute: Swift.Equatable {
        /// The metric's event type.
        /// This member is required.
        public var eventType: Swift.String?
        /// The attribute's expression. Available functions are SUM() or SAMPLECOUNT(). For SUM() functions, provide the dataset type (either Interactions or Items) and column to sum as a parameter. For example SUM(Items.PRICE).
        /// This member is required.
        public var expression: Swift.String?
        /// The metric's name. The name helps you identify the metric in Amazon CloudWatch or Amazon S3.
        /// This member is required.
        public var metricName: Swift.String?

        public init(
            eventType: Swift.String? = nil,
            expression: Swift.String? = nil,
            metricName: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.expression = expression
            self.metricName = metricName
        }
    }

}

extension PersonalizeClientTypes.MetricAttribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case lastUpdatedDateTime
        case metricAttributionArn
        case metricsOutputConfig
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let metricAttributionArn = self.metricAttributionArn {
            try encodeContainer.encode(metricAttributionArn, forKey: .metricAttributionArn)
        }
        if let metricsOutputConfig = self.metricsOutputConfig {
            try encodeContainer.encode(metricsOutputConfig, forKey: .metricsOutputConfig)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let metricsOutputConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.MetricAttributionOutput.self, forKey: .metricsOutputConfig)
        metricsOutputConfig = metricsOutputConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Contains information on a metric attribution. A metric attribution creates reports on the data that you import into Amazon Personalize. Depending on how you import the data, you can view reports in Amazon CloudWatch or Amazon S3. For more information, see [Measuring impact of recommendations](https://docs.aws.amazon.com/personalize/latest/dg/measuring-recommendation-impact.html).
    public struct MetricAttribution: Swift.Equatable {
        /// The metric attribution's creation date time.
        public var creationDateTime: ClientRuntime.Date?
        /// The metric attribution's dataset group Amazon Resource Name (ARN).
        public var datasetGroupArn: Swift.String?
        /// The metric attribution's failure reason.
        public var failureReason: Swift.String?
        /// The metric attribution's last updated date time.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The metric attribution's Amazon Resource Name (ARN).
        public var metricAttributionArn: Swift.String?
        /// The metric attribution's output configuration.
        public var metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput?
        /// The metric attribution's name.
        public var name: Swift.String?
        /// The metric attribution's status.
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            metricAttributionArn: Swift.String? = nil,
            metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.metricAttributionArn = metricAttributionArn
            self.metricsOutputConfig = metricsOutputConfig
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.MetricAttributionOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case s3DataDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3DataDestination = self.s3DataDestination {
            try encodeContainer.encode(s3DataDestination, forKey: .s3DataDestination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDestinationDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataDestination)
        s3DataDestination = s3DataDestinationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension PersonalizeClientTypes {
    /// The output configuration details for a metric attribution.
    public struct MetricAttributionOutput: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your output Amazon S3 bucket and add metrics to Amazon CloudWatch. For more information, see [Measuring impact of recommendations](https://docs.aws.amazon.com/personalize/latest/dg/measuring-recommendation-impact.html).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The configuration details of an Amazon S3 input or output bucket.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init(
            roleArn: Swift.String? = nil,
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.roleArn = roleArn
            self.s3DataDestination = s3DataDestination
        }
    }

}

extension PersonalizeClientTypes.MetricAttributionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case metricAttributionArn
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let metricAttributionArn = self.metricAttributionArn {
            try encodeContainer.encode(metricAttributionArn, forKey: .metricAttributionArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a metric attribution. For a complete listing, call the [DescribeMetricAttribution](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeMetricAttribution.html).
    public struct MetricAttributionSummary: Swift.Equatable {
        /// The metric attribution's creation date time.
        public var creationDateTime: ClientRuntime.Date?
        /// The metric attribution's failure reason.
        public var failureReason: Swift.String?
        /// The metric attribution's last updated date time.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The metric attribution's Amazon Resource Name (ARN).
        public var metricAttributionArn: Swift.String?
        /// The name of the metric attribution.
        public var name: Swift.String?
        /// The metric attribution's status.
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            metricAttributionArn: Swift.String? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.metricAttributionArn = metricAttributionArn
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes {
    public enum ObjectiveSensitivity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectiveSensitivity] {
            return [
                .high,
                .low,
                .medium,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectiveSensitivity(rawValue: rawValue) ?? ObjectiveSensitivity.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.OptimizationObjective: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemAttribute
        case objectiveSensitivity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemAttribute = self.itemAttribute {
            try encodeContainer.encode(itemAttribute, forKey: .itemAttribute)
        }
        if let objectiveSensitivity = self.objectiveSensitivity {
            try encodeContainer.encode(objectiveSensitivity.rawValue, forKey: .objectiveSensitivity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .itemAttribute)
        itemAttribute = itemAttributeDecoded
        let objectiveSensitivityDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.ObjectiveSensitivity.self, forKey: .objectiveSensitivity)
        objectiveSensitivity = objectiveSensitivityDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes the additional objective for the solution, such as maximizing streaming minutes or increasing revenue. For more information see [Optimizing a solution](https://docs.aws.amazon.com/personalize/latest/dg/optimizing-solution-for-objective.html).
    public struct OptimizationObjective: Swift.Equatable {
        /// The numerical metadata column in an Items dataset related to the optimization objective. For example, VIDEO_LENGTH (to maximize streaming minutes), or PRICE (to maximize revenue).
        public var itemAttribute: Swift.String?
        /// Specifies how Amazon Personalize balances the importance of your optimization objective versus relevance.
        public var objectiveSensitivity: PersonalizeClientTypes.ObjectiveSensitivity?

        public init(
            itemAttribute: Swift.String? = nil,
            objectiveSensitivity: PersonalizeClientTypes.ObjectiveSensitivity? = nil
        )
        {
            self.itemAttribute = itemAttribute
            self.objectiveSensitivity = objectiveSensitivity
        }
    }

}

extension PersonalizeClientTypes.Recipe: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn
        case creationDateTime
        case description
        case featureTransformationArn
        case lastUpdatedDateTime
        case name
        case recipeArn
        case recipeType
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = self.algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let featureTransformationArn = self.featureTransformationArn {
            try encodeContainer.encode(featureTransformationArn, forKey: .featureTransformationArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let recipeType = self.recipeType {
            try encodeContainer.encode(recipeType, forKey: .recipeType)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let featureTransformationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureTransformationArn)
        featureTransformationArn = featureTransformationArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let recipeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeType)
        recipeType = recipeTypeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides information about a recipe. Each recipe provides an algorithm that Amazon Personalize uses in model training when you use the [CreateSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSolution.html) operation.
    public struct Recipe: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the algorithm that Amazon Personalize uses to train the model.
        public var algorithmArn: Swift.String?
        /// The date and time (in Unix format) that the recipe was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the recipe.
        public var description: Swift.String?
        /// The ARN of the FeatureTransformation object.
        public var featureTransformationArn: Swift.String?
        /// The date and time (in Unix format) that the recipe was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the recipe.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public var recipeArn: Swift.String?
        /// One of the following values:
        ///
        /// * PERSONALIZED_RANKING
        ///
        /// * RELATED_ITEMS
        ///
        /// * USER_PERSONALIZATION
        public var recipeType: Swift.String?
        /// The status of the recipe.
        public var status: Swift.String?

        public init(
            algorithmArn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            featureTransformationArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            recipeType: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.creationDateTime = creationDateTime
            self.description = description
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.recipeType = recipeType
            self.status = status
        }
    }

}

extension PersonalizeClientTypes {
    public enum RecipeProvider: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [RecipeProvider] {
            return [
                .service,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecipeProvider(rawValue: rawValue) ?? RecipeProvider.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.RecipeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case domain
        case lastUpdatedDateTime
        case name
        case recipeArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let domainDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a recipe. For a complete listing, call the [DescribeRecipe](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeRecipe.html) API.
    public struct RecipeSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the recipe was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The domain of the recipe (if the recipe is a Domain dataset group use case).
        public var domain: PersonalizeClientTypes.Domain?
        /// The date and time (in Unix time) that the recipe was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the recipe.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public var recipeArn: Swift.String?
        /// The status of the recipe.
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.domain = domain
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.Recommender: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case lastUpdatedDateTime
        case latestRecommenderUpdate
        case modelMetrics
        case name
        case recipeArn
        case recommenderArn
        case recommenderConfig
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let latestRecommenderUpdate = self.latestRecommenderUpdate {
            try encodeContainer.encode(latestRecommenderUpdate, forKey: .latestRecommenderUpdate)
        }
        if let modelMetrics = modelMetrics {
            var modelMetricsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .modelMetrics)
            for (dictKey0, metrics0) in modelMetrics {
                try modelMetricsContainer.encode(metrics0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
        if let recommenderConfig = self.recommenderConfig {
            try encodeContainer.encode(recommenderConfig, forKey: .recommenderConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let recommenderConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecommenderConfig.self, forKey: .recommenderConfig)
        recommenderConfig = recommenderConfigDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let latestRecommenderUpdateDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecommenderUpdateSummary.self, forKey: .latestRecommenderUpdate)
        latestRecommenderUpdate = latestRecommenderUpdateDecoded
        let modelMetricsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Double?].self, forKey: .modelMetrics)
        var modelMetricsDecoded0: [Swift.String:Swift.Double]? = nil
        if let modelMetricsContainer = modelMetricsContainer {
            modelMetricsDecoded0 = [Swift.String:Swift.Double]()
            for (key0, metricvalue0) in modelMetricsContainer {
                if let metricvalue0 = metricvalue0 {
                    modelMetricsDecoded0?[key0] = metricvalue0
                }
            }
        }
        modelMetrics = modelMetricsDecoded0
    }
}

extension PersonalizeClientTypes {
    /// Describes a recommendation generator for a Domain dataset group. You create a recommender in a Domain dataset group for a specific domain use case (domain recipe), and specify the recommender in a [GetRecommendations](https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html) request.
    public struct Recommender: Swift.Equatable {
        /// The date and time (in Unix format) that the recommender was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the Domain dataset group that contains the recommender.
        public var datasetGroupArn: Swift.String?
        /// If a recommender fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix format) that the recommender was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Provides a summary of the latest updates to the recommender.
        public var latestRecommenderUpdate: PersonalizeClientTypes.RecommenderUpdateSummary?
        /// Provides evaluation metrics that help you determine the performance of a recommender. For more information, see [ Evaluating a recommender](https://docs.aws.amazon.com/personalize/latest/dg/evaluating-recommenders.html).
        public var modelMetrics: [Swift.String:Swift.Double]?
        /// The name of the recommender.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe (Domain dataset group use case) that the recommender was created for.
        public var recipeArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the recommender.
        public var recommenderArn: Swift.String?
        /// The configuration details of the recommender.
        public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
        /// The status of the recommender. A recommender can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * STOP PENDING > STOP IN_PROGRESS > INACTIVE > START PENDING > START IN_PROGRESS > ACTIVE
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            latestRecommenderUpdate: PersonalizeClientTypes.RecommenderUpdateSummary? = nil,
            modelMetrics: [Swift.String:Swift.Double]? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            recommenderArn: Swift.String? = nil,
            recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestRecommenderUpdate = latestRecommenderUpdate
            self.modelMetrics = modelMetrics
            self.name = name
            self.recipeArn = recipeArn
            self.recommenderArn = recommenderArn
            self.recommenderConfig = recommenderConfig
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.RecommenderConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemExplorationConfig
        case minRecommendationRequestsPerSecond
        case trainingDataConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemExplorationConfig = itemExplorationConfig {
            var itemExplorationConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .itemExplorationConfig)
            for (dictKey0, hyperParameters0) in itemExplorationConfig {
                try itemExplorationConfigContainer.encode(hyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let minRecommendationRequestsPerSecond = self.minRecommendationRequestsPerSecond {
            try encodeContainer.encode(minRecommendationRequestsPerSecond, forKey: .minRecommendationRequestsPerSecond)
        }
        if let trainingDataConfig = self.trainingDataConfig {
            try encodeContainer.encode(trainingDataConfig, forKey: .trainingDataConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemExplorationConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .itemExplorationConfig)
        var itemExplorationConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let itemExplorationConfigContainer = itemExplorationConfigContainer {
            itemExplorationConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in itemExplorationConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    itemExplorationConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        itemExplorationConfig = itemExplorationConfigDecoded0
        let minRecommendationRequestsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minRecommendationRequestsPerSecond)
        minRecommendationRequestsPerSecond = minRecommendationRequestsPerSecondDecoded
        let trainingDataConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.TrainingDataConfig.self, forKey: .trainingDataConfig)
        trainingDataConfig = trainingDataConfigDecoded
    }
}

extension PersonalizeClientTypes {
    /// The configuration details of the recommender.
    public struct RecommenderConfig: Swift.Equatable {
        /// Specifies the exploration configuration hyperparameters, including explorationWeight and explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items. Provide itemExplorationConfig data only if your recommenders generate personalized recommendations for a user (not popular items or similar items).
        public var itemExplorationConfig: [Swift.String:Swift.String]?
        /// Specifies the requested minimum provisioned recommendation requests per second that Amazon Personalize will support. A high minRecommendationRequestsPerSecond will increase your bill. We recommend starting with 1 for minRecommendationRequestsPerSecond (the default). Track your usage using Amazon CloudWatch metrics, and increase the minRecommendationRequestsPerSecond as necessary.
        public var minRecommendationRequestsPerSecond: Swift.Int?
        /// Specifies the training data configuration to use when creating a domain recommender.
        public var trainingDataConfig: PersonalizeClientTypes.TrainingDataConfig?

        public init(
            itemExplorationConfig: [Swift.String:Swift.String]? = nil,
            minRecommendationRequestsPerSecond: Swift.Int? = nil,
            trainingDataConfig: PersonalizeClientTypes.TrainingDataConfig? = nil
        )
        {
            self.itemExplorationConfig = itemExplorationConfig
            self.minRecommendationRequestsPerSecond = minRecommendationRequestsPerSecond
            self.trainingDataConfig = trainingDataConfig
        }
    }

}

extension PersonalizeClientTypes.RecommenderSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case lastUpdatedDateTime
        case name
        case recipeArn
        case recommenderArn
        case recommenderConfig
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
        if let recommenderConfig = self.recommenderConfig {
            try encodeContainer.encode(recommenderConfig, forKey: .recommenderConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let recommenderConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecommenderConfig.self, forKey: .recommenderConfig)
        recommenderConfig = recommenderConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of the recommender.
    public struct RecommenderSummary: Swift.Equatable {
        /// The date and time (in Unix format) that the recommender was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the Domain dataset group that contains the recommender.
        public var datasetGroupArn: Swift.String?
        /// The date and time (in Unix format) that the recommender was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the recommender.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe (Domain dataset group use case) that the recommender was created for.
        public var recipeArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the recommender.
        public var recommenderArn: Swift.String?
        /// The configuration details of the recommender.
        public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
        /// The status of the recommender. A recommender can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * STOP PENDING > STOP IN_PROGRESS > INACTIVE > START PENDING > START IN_PROGRESS > ACTIVE
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            recommenderArn: Swift.String? = nil,
            recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.recommenderArn = recommenderArn
            self.recommenderConfig = recommenderConfig
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.RecommenderUpdateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case recommenderConfig
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let recommenderConfig = self.recommenderConfig {
            try encodeContainer.encode(recommenderConfig, forKey: .recommenderConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecommenderConfig.self, forKey: .recommenderConfig)
        recommenderConfig = recommenderConfigDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a recommender update. For a complete listing, call the [DescribeRecommender](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeRecommender.html) API.
    public struct RecommenderUpdateSummary: Swift.Equatable {
        /// The date and time (in Unix format) that the recommender update was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a recommender update fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the recommender update was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The configuration details of the recommender update.
        public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
        /// The status of the recommender update. A recommender can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * STOP PENDING > STOP IN_PROGRESS > INACTIVE > START PENDING > START IN_PROGRESS > ACTIVE
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.recommenderConfig = recommenderConfig
            self.status = status
        }
    }

}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource is in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Could not find the specified resource.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PersonalizeClientTypes.S3DataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension PersonalizeClientTypes {
    /// The configuration details of an Amazon S3 input or output bucket.
    public struct S3DataConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key that Amazon Personalize uses to encrypt or decrypt the input and output files.
        public var kmsKeyArn: Swift.String?
        /// The file path of the Amazon S3 bucket.
        /// This member is required.
        public var path: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.path = path
        }
    }

}

extension PersonalizeClientTypes.Solution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoMLResult
        case creationDateTime
        case datasetGroupArn
        case eventType
        case lastUpdatedDateTime
        case latestSolutionVersion
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionArn
        case solutionConfig
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoMLResult = self.autoMLResult {
            try encodeContainer.encode(autoMLResult, forKey: .autoMLResult)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let latestSolutionVersion = self.latestSolutionVersion {
            try encodeContainer.encode(latestSolutionVersion, forKey: .latestSolutionVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if performAutoML != false {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if performHPO != false {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let solutionConfig = self.solutionConfig {
            try encodeContainer.encode(solutionConfig, forKey: .solutionConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO) ?? false
        performHPO = performHPODecoded
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML) ?? false
        performAutoML = performAutoMLDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let solutionConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionConfig.self, forKey: .solutionConfig)
        solutionConfig = solutionConfigDecoded
        let autoMLResultDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.AutoMLResult.self, forKey: .autoMLResult)
        autoMLResult = autoMLResultDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let latestSolutionVersionDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionVersionSummary.self, forKey: .latestSolutionVersion)
        latestSolutionVersion = latestSolutionVersionDecoded
    }
}

extension PersonalizeClientTypes {
    /// An object that provides information about a solution. A solution is a trained model that can be deployed as a campaign.
    public struct Solution: Swift.Equatable {
        /// When performAutoML is true, specifies the best recipe found.
        public var autoMLResult: PersonalizeClientTypes.AutoMLResult?
        /// The creation date and time (in Unix time) of the solution.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
        public var datasetGroupArn: Swift.String?
        /// The event type (for example, 'click' or 'like') that is used for training the model. If no eventType is provided, Amazon Personalize uses all interactions for training with equal weight regardless of type.
        public var eventType: Swift.String?
        /// The date and time (in Unix time) that the solution was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Describes the latest version of the solution, including the status and the ARN.
        public var latestSolutionVersion: PersonalizeClientTypes.SolutionVersionSummary?
        /// The name of the solution.
        public var name: Swift.String?
        /// We don't recommend enabling automated machine learning. Instead, match your use case to the available Amazon Personalize recipes. For more information, see [Determining your use case.](https://docs.aws.amazon.com/personalize/latest/dg/determining-use-case.html) When true, Amazon Personalize performs a search for the best USER_PERSONALIZATION recipe from the list specified in the solution configuration (recipeArn must not be specified). When false (the default), Amazon Personalize uses recipeArn for training.
        public var performAutoML: Swift.Bool
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public var performHPO: Swift.Bool
        /// The ARN of the recipe used to create the solution. This is required when performAutoML is false.
        public var recipeArn: Swift.String?
        /// The ARN of the solution.
        public var solutionArn: Swift.String?
        /// Describes the configuration properties for the solution.
        public var solutionConfig: PersonalizeClientTypes.SolutionConfig?
        /// The status of the solution. A solution can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            autoMLResult: PersonalizeClientTypes.AutoMLResult? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            eventType: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            latestSolutionVersion: PersonalizeClientTypes.SolutionVersionSummary? = nil,
            name: Swift.String? = nil,
            performAutoML: Swift.Bool = false,
            performHPO: Swift.Bool = false,
            recipeArn: Swift.String? = nil,
            solutionArn: Swift.String? = nil,
            solutionConfig: PersonalizeClientTypes.SolutionConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.autoMLResult = autoMLResult
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestSolutionVersion = latestSolutionVersion
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.SolutionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmHyperParameters
        case autoMLConfig
        case eventValueThreshold
        case featureTransformationParameters
        case hpoConfig
        case optimizationObjective
        case trainingDataConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmHyperParameters = algorithmHyperParameters {
            var algorithmHyperParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .algorithmHyperParameters)
            for (dictKey0, hyperParameters0) in algorithmHyperParameters {
                try algorithmHyperParametersContainer.encode(hyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let autoMLConfig = self.autoMLConfig {
            try encodeContainer.encode(autoMLConfig, forKey: .autoMLConfig)
        }
        if let eventValueThreshold = self.eventValueThreshold {
            try encodeContainer.encode(eventValueThreshold, forKey: .eventValueThreshold)
        }
        if let featureTransformationParameters = featureTransformationParameters {
            var featureTransformationParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .featureTransformationParameters)
            for (dictKey0, featureTransformationParameters0) in featureTransformationParameters {
                try featureTransformationParametersContainer.encode(featureTransformationParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let hpoConfig = self.hpoConfig {
            try encodeContainer.encode(hpoConfig, forKey: .hpoConfig)
        }
        if let optimizationObjective = self.optimizationObjective {
            try encodeContainer.encode(optimizationObjective, forKey: .optimizationObjective)
        }
        if let trainingDataConfig = self.trainingDataConfig {
            try encodeContainer.encode(trainingDataConfig, forKey: .trainingDataConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventValueThresholdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventValueThreshold)
        eventValueThreshold = eventValueThresholdDecoded
        let hpoConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.HPOConfig.self, forKey: .hpoConfig)
        hpoConfig = hpoConfigDecoded
        let algorithmHyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .algorithmHyperParameters)
        var algorithmHyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let algorithmHyperParametersContainer = algorithmHyperParametersContainer {
            algorithmHyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in algorithmHyperParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    algorithmHyperParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        algorithmHyperParameters = algorithmHyperParametersDecoded0
        let featureTransformationParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .featureTransformationParameters)
        var featureTransformationParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let featureTransformationParametersContainer = featureTransformationParametersContainer {
            featureTransformationParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in featureTransformationParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    featureTransformationParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        featureTransformationParameters = featureTransformationParametersDecoded0
        let autoMLConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.AutoMLConfig.self, forKey: .autoMLConfig)
        autoMLConfig = autoMLConfigDecoded
        let optimizationObjectiveDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.OptimizationObjective.self, forKey: .optimizationObjective)
        optimizationObjective = optimizationObjectiveDecoded
        let trainingDataConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.TrainingDataConfig.self, forKey: .trainingDataConfig)
        trainingDataConfig = trainingDataConfigDecoded
    }
}

extension PersonalizeClientTypes {
    /// Describes the configuration properties for the solution.
    public struct SolutionConfig: Swift.Equatable {
        /// Lists the hyperparameter names and ranges.
        public var algorithmHyperParameters: [Swift.String:Swift.String]?
        /// The [AutoMLConfig](https://docs.aws.amazon.com/personalize/latest/dg/API_AutoMLConfig.html) object containing a list of recipes to search when AutoML is performed.
        public var autoMLConfig: PersonalizeClientTypes.AutoMLConfig?
        /// Only events with a value greater than or equal to this threshold are used for training a model.
        public var eventValueThreshold: Swift.String?
        /// Lists the feature transformation parameters.
        public var featureTransformationParameters: [Swift.String:Swift.String]?
        /// Describes the properties for hyperparameter optimization (HPO).
        public var hpoConfig: PersonalizeClientTypes.HPOConfig?
        /// Describes the additional objective for the solution, such as maximizing streaming minutes or increasing revenue. For more information see [Optimizing a solution](https://docs.aws.amazon.com/personalize/latest/dg/optimizing-solution-for-objective.html).
        public var optimizationObjective: PersonalizeClientTypes.OptimizationObjective?
        /// Specifies the training data configuration to use when creating a custom solution version (trained model).
        public var trainingDataConfig: PersonalizeClientTypes.TrainingDataConfig?

        public init(
            algorithmHyperParameters: [Swift.String:Swift.String]? = nil,
            autoMLConfig: PersonalizeClientTypes.AutoMLConfig? = nil,
            eventValueThreshold: Swift.String? = nil,
            featureTransformationParameters: [Swift.String:Swift.String]? = nil,
            hpoConfig: PersonalizeClientTypes.HPOConfig? = nil,
            optimizationObjective: PersonalizeClientTypes.OptimizationObjective? = nil,
            trainingDataConfig: PersonalizeClientTypes.TrainingDataConfig? = nil
        )
        {
            self.algorithmHyperParameters = algorithmHyperParameters
            self.autoMLConfig = autoMLConfig
            self.eventValueThreshold = eventValueThreshold
            self.featureTransformationParameters = featureTransformationParameters
            self.hpoConfig = hpoConfig
            self.optimizationObjective = optimizationObjective
            self.trainingDataConfig = trainingDataConfig
        }
    }

}

extension PersonalizeClientTypes.SolutionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case lastUpdatedDateTime
        case name
        case recipeArn
        case solutionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a solution. For a complete listing, call the [DescribeSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeSolution.html) API.
    public struct SolutionSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the solution was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The date and time (in Unix time) that the solution was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the solution.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe used by the solution.
        public var recipeArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the solution.
        public var solutionArn: Swift.String?
        /// The status of the solution. A solution can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            solutionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.SolutionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case eventType
        case failureReason
        case lastUpdatedDateTime
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionArn
        case solutionConfig
        case solutionVersionArn
        case status
        case trainingHours
        case trainingMode
        case tunedHPOParams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let datasetGroupArn = self.datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if performAutoML != false {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if performHPO != false {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let recipeArn = self.recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionArn = self.solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let solutionConfig = self.solutionConfig {
            try encodeContainer.encode(solutionConfig, forKey: .solutionConfig)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trainingHours = self.trainingHours {
            try encodeContainer.encode(trainingHours, forKey: .trainingHours)
        }
        if let trainingMode = self.trainingMode {
            try encodeContainer.encode(trainingMode.rawValue, forKey: .trainingMode)
        }
        if let tunedHPOParams = self.tunedHPOParams {
            try encodeContainer.encode(tunedHPOParams, forKey: .tunedHPOParams)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO) ?? false
        performHPO = performHPODecoded
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performAutoML) ?? false
        performAutoML = performAutoMLDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let solutionConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionConfig.self, forKey: .solutionConfig)
        solutionConfig = solutionConfigDecoded
        let trainingHoursDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .trainingHours)
        trainingHours = trainingHoursDecoded
        let trainingModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.TrainingMode.self, forKey: .trainingMode)
        trainingMode = trainingModeDecoded
        let tunedHPOParamsDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.TunedHPOParams.self, forKey: .tunedHPOParams)
        tunedHPOParams = tunedHPOParamsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes {
    /// An object that provides information about a specific version of a [Solution](https://docs.aws.amazon.com/personalize/latest/dg/API_Solution.html) in a Custom dataset group.
    public struct SolutionVersion: Swift.Equatable {
        /// The date and time (in Unix time) that this version of the solution was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group providing the training data.
        public var datasetGroupArn: Swift.String?
        /// The event type (for example, 'click' or 'like') that is used for training the model.
        public var eventType: Swift.String?
        /// If training a solution version fails, the reason for the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the solution was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the solution version.
        public var name: Swift.String?
        /// When true, Amazon Personalize searches for the most optimal recipe according to the solution configuration. When false (the default), Amazon Personalize uses recipeArn.
        public var performAutoML: Swift.Bool
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public var performHPO: Swift.Bool
        /// The ARN of the recipe used in the solution.
        public var recipeArn: Swift.String?
        /// The ARN of the solution.
        public var solutionArn: Swift.String?
        /// Describes the configuration properties for the solution.
        public var solutionConfig: PersonalizeClientTypes.SolutionConfig?
        /// The ARN of the solution version.
        public var solutionVersionArn: Swift.String?
        /// The status of the solution version. A solution version can be in one of the following states:
        ///
        /// * CREATE PENDING
        ///
        /// * CREATE IN_PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        ///
        /// * CREATE STOPPING
        ///
        /// * CREATE STOPPED
        public var status: Swift.String?
        /// The time used to train the model. You are billed for the time it takes to train a model. This field is visible only after Amazon Personalize successfully trains a model.
        public var trainingHours: Swift.Double?
        /// The scope of training to be performed when creating the solution version. The FULL option trains the solution version based on the entirety of the input solution's training data, while the UPDATE option processes only the data that has changed in comparison to the input solution. Choose UPDATE when you want to incrementally update your solution version instead of creating an entirely new one. The UPDATE option can only be used when you already have an active solution version created from the input solution using the FULL option and the input solution was trained with the [User-Personalization](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html) recipe or the [HRNN-Coldstart](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-hrnn-coldstart.html) recipe.
        public var trainingMode: PersonalizeClientTypes.TrainingMode?
        /// If hyperparameter optimization was performed, contains the hyperparameter values of the best performing model.
        public var tunedHPOParams: PersonalizeClientTypes.TunedHPOParams?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            eventType: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            performAutoML: Swift.Bool = false,
            performHPO: Swift.Bool = false,
            recipeArn: Swift.String? = nil,
            solutionArn: Swift.String? = nil,
            solutionConfig: PersonalizeClientTypes.SolutionConfig? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil,
            trainingHours: Swift.Double? = nil,
            trainingMode: PersonalizeClientTypes.TrainingMode? = nil,
            tunedHPOParams: PersonalizeClientTypes.TunedHPOParams? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.solutionVersionArn = solutionVersionArn
            self.status = status
            self.trainingHours = trainingHours
            self.trainingMode = trainingMode
            self.tunedHPOParams = tunedHPOParams
        }
    }

}

extension PersonalizeClientTypes.SolutionVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encodeTimestamp(lastUpdatedDateTime, format: .epochSeconds, forKey: .lastUpdatedDateTime)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a solution version. For a complete listing, call the [DescribeSolutionVersion](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeSolutionVersion.html) API.
    public struct SolutionVersionSummary: Swift.Equatable {
        /// The date and time (in Unix time) that this version of a solution was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a solution version fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the solution version was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the solution version.
        public var solutionVersionArn: Swift.String?
        /// The status of the solution version. A solution version can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension StartRecommenderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
    }
}

extension StartRecommenderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartRecommenderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender to start.
    /// This member is required.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct StartRecommenderInputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension StartRecommenderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

extension StartRecommenderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartRecommenderOutputBody = try responseDecoder.decode(responseBody: data)
            self.recommenderArn = output.recommenderArn
        } else {
            self.recommenderArn = nil
        }
    }
}

public struct StartRecommenderOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender you started.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct StartRecommenderOutputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension StartRecommenderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

enum StartRecommenderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopRecommenderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
    }
}

extension StopRecommenderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopRecommenderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender to stop.
    /// This member is required.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct StopRecommenderInputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension StopRecommenderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

extension StopRecommenderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopRecommenderOutputBody = try responseDecoder.decode(responseBody: data)
            self.recommenderArn = output.recommenderArn
        } else {
            self.recommenderArn = nil
        }
    }
}

public struct StopRecommenderOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender you stopped.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct StopRecommenderOutputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension StopRecommenderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

enum StopRecommenderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopSolutionVersionCreationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

extension StopSolutionVersionCreationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopSolutionVersionCreationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the solution version you want to stop creating.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init(
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct StopSolutionVersionCreationInputBody: Swift.Equatable {
    let solutionVersionArn: Swift.String?
}

extension StopSolutionVersionCreationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension StopSolutionVersionCreationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopSolutionVersionCreationOutput: Swift.Equatable {

    public init() { }
}

enum StopSolutionVersionCreationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PersonalizeClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKey
        case tagValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValue = self.tagValue {
            try encodeContainer.encode(tagValue, forKey: .tagValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagValue)
        tagValue = tagValueDecoded
    }
}

extension PersonalizeClientTypes {
    /// The optional metadata that you apply to resources to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. For more information see [Tagging Amazon Personalize recources](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html).
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        /// This member is required.
        public var tagKey: Swift.String?
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key).
        /// This member is required.
        public var tagValue: Swift.String?

        public init(
            tagKey: Swift.String? = nil,
            tagValue: Swift.String? = nil
        )
        {
            self.tagKey = tagKey
            self.tagValue = tagValue
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags to apply to the resource. For more information see [Tagging Amazon Personalize recources](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html).
    /// This member is required.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [PersonalizeClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[PersonalizeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [PersonalizeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TooManyTagKeysException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagKeysExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request contains more tag keys than can be associated with a resource (50 tag keys per resource).
public struct TooManyTagKeysException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagKeysException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTagKeysExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagKeysExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded the maximum number of tags you can apply to this resource.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PersonalizeClientTypes.TrainingDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excludedDatasetColumns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludedDatasetColumns = excludedDatasetColumns {
            var excludedDatasetColumnsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .excludedDatasetColumns)
            for (dictKey0, excludedDatasetColumns0) in excludedDatasetColumns {
                var excludedDatasetColumns0Container = excludedDatasetColumnsContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for columnname1 in excludedDatasetColumns0 {
                    try excludedDatasetColumns0Container.encode(columnname1)
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludedDatasetColumnsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .excludedDatasetColumns)
        var excludedDatasetColumnsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let excludedDatasetColumnsContainer = excludedDatasetColumnsContainer {
            excludedDatasetColumnsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, columnnameslist0) in excludedDatasetColumnsContainer {
                var columnnameslist0Decoded0: [Swift.String]? = nil
                if let columnnameslist0 = columnnameslist0 {
                    columnnameslist0Decoded0 = [Swift.String]()
                    for string1 in columnnameslist0 {
                        if let string1 = string1 {
                            columnnameslist0Decoded0?.append(string1)
                        }
                    }
                }
                excludedDatasetColumnsDecoded0?[key0] = columnnameslist0Decoded0
            }
        }
        excludedDatasetColumns = excludedDatasetColumnsDecoded0
    }
}

extension PersonalizeClientTypes {
    /// The training data configuration to use when creating a domain recommender or custom solution version (trained model).
    public struct TrainingDataConfig: Swift.Equatable {
        /// Specifies the columns to exclude from training. Each key is a dataset type, and each value is a list of columns. Exclude columns to control what data Amazon Personalize uses to generate recommendations. For example, you might have a column that you want to use only to filter recommendations. You can exclude this column from training and Amazon Personalize considers it only when filtering.
        public var excludedDatasetColumns: [Swift.String:[Swift.String]]?

        public init(
            excludedDatasetColumns: [Swift.String:[Swift.String]]? = nil
        )
        {
            self.excludedDatasetColumns = excludedDatasetColumns
        }
    }

}

extension PersonalizeClientTypes {
    public enum TrainingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [TrainingMode] {
            return [
                .full,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrainingMode(rawValue: rawValue) ?? TrainingMode.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.TunedHPOParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmHyperParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmHyperParameters = algorithmHyperParameters {
            var algorithmHyperParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .algorithmHyperParameters)
            for (dictKey0, hyperParameters0) in algorithmHyperParameters {
                try algorithmHyperParametersContainer.encode(hyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmHyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .algorithmHyperParameters)
        var algorithmHyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let algorithmHyperParametersContainer = algorithmHyperParametersContainer {
            algorithmHyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in algorithmHyperParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    algorithmHyperParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        algorithmHyperParameters = algorithmHyperParametersDecoded0
    }
}

extension PersonalizeClientTypes {
    /// If hyperparameter optimization (HPO) was performed, contains the hyperparameter values of the best performing model.
    public struct TunedHPOParams: Swift.Equatable {
        /// A list of the hyperparameter values of the best performing model.
        public var algorithmHyperParameters: [Swift.String:Swift.String]?

        public init(
            algorithmHyperParameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.algorithmHyperParameters = algorithmHyperParameters
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys to remove from the resource's tags.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagKeysException": return try await TooManyTagKeysException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCampaignInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case campaignConfig
        case minProvisionedTPS
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let campaignConfig = self.campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let minProvisionedTPS = self.minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let solutionVersionArn = self.solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

extension UpdateCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCampaignInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign.
    /// This member is required.
    public var campaignArn: Swift.String?
    /// The configuration details of a campaign.
    public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
    /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support. A high minProvisionedTPS will increase your bill. We recommend starting with 1 for minProvisionedTPS (the default). Track your usage using Amazon CloudWatch metrics, and increase the minProvisionedTPS as necessary.
    public var minProvisionedTPS: Swift.Int?
    /// The ARN of a new solution version to deploy.
    public var solutionVersionArn: Swift.String?

    public init(
        campaignArn: Swift.String? = nil,
        campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
        minProvisionedTPS: Swift.Int? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
        self.campaignConfig = campaignConfig
        self.minProvisionedTPS = minProvisionedTPS
        self.solutionVersionArn = solutionVersionArn
    }
}

struct UpdateCampaignInputBody: Swift.Equatable {
    let campaignArn: Swift.String?
    let solutionVersionArn: Swift.String?
    let minProvisionedTPS: Swift.Int?
    let campaignConfig: PersonalizeClientTypes.CampaignConfig?
}

extension UpdateCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case campaignConfig
        case minProvisionedTPS
        case solutionVersionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
    }
}

extension UpdateCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCampaignOutputBody = try responseDecoder.decode(responseBody: data)
            self.campaignArn = output.campaignArn
        } else {
            self.campaignArn = nil
        }
    }
}

public struct UpdateCampaignOutput: Swift.Equatable {
    /// The same campaign ARN as given in the request.
    public var campaignArn: Swift.String?

    public init(
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct UpdateCampaignOutputBody: Swift.Equatable {
    let campaignArn: Swift.String?
}

extension UpdateCampaignOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

enum UpdateCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

extension UpdateDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset that you want to update.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the new schema you want use.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.schemaArn = schemaArn
    }
}

struct UpdateDatasetInputBody: Swift.Equatable {
    let datasetArn: Swift.String?
    let schemaArn: Swift.String?
}

extension UpdateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case schemaArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

extension UpdateDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetArn = output.datasetArn
        } else {
            self.datasetArn = nil
        }
    }
}

public struct UpdateDatasetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset you updated.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct UpdateDatasetOutputBody: Swift.Equatable {
    let datasetArn: Swift.String?
}

extension UpdateDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

enum UpdateDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMetricAttributionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addMetrics
        case metricAttributionArn
        case metricsOutputConfig
        case removeMetrics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addMetrics = addMetrics {
            var addMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addMetrics)
            for metricattribute0 in addMetrics {
                try addMetricsContainer.encode(metricattribute0)
            }
        }
        if let metricAttributionArn = self.metricAttributionArn {
            try encodeContainer.encode(metricAttributionArn, forKey: .metricAttributionArn)
        }
        if let metricsOutputConfig = self.metricsOutputConfig {
            try encodeContainer.encode(metricsOutputConfig, forKey: .metricsOutputConfig)
        }
        if let removeMetrics = removeMetrics {
            var removeMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeMetrics)
            for metricname0 in removeMetrics {
                try removeMetricsContainer.encode(metricname0)
            }
        }
    }
}

extension UpdateMetricAttributionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateMetricAttributionInput: Swift.Equatable {
    /// Add new metric attributes to the metric attribution.
    public var addMetrics: [PersonalizeClientTypes.MetricAttribute]?
    /// The Amazon Resource Name (ARN) for the metric attribution to update.
    public var metricAttributionArn: Swift.String?
    /// An output config for the metric attribution.
    public var metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput?
    /// Remove metric attributes from the metric attribution.
    public var removeMetrics: [Swift.String]?

    public init(
        addMetrics: [PersonalizeClientTypes.MetricAttribute]? = nil,
        metricAttributionArn: Swift.String? = nil,
        metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput? = nil,
        removeMetrics: [Swift.String]? = nil
    )
    {
        self.addMetrics = addMetrics
        self.metricAttributionArn = metricAttributionArn
        self.metricsOutputConfig = metricsOutputConfig
        self.removeMetrics = removeMetrics
    }
}

struct UpdateMetricAttributionInputBody: Swift.Equatable {
    let addMetrics: [PersonalizeClientTypes.MetricAttribute]?
    let removeMetrics: [Swift.String]?
    let metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput?
    let metricAttributionArn: Swift.String?
}

extension UpdateMetricAttributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addMetrics
        case metricAttributionArn
        case metricsOutputConfig
        case removeMetrics
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addMetricsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.MetricAttribute?].self, forKey: .addMetrics)
        var addMetricsDecoded0:[PersonalizeClientTypes.MetricAttribute]? = nil
        if let addMetricsContainer = addMetricsContainer {
            addMetricsDecoded0 = [PersonalizeClientTypes.MetricAttribute]()
            for structure0 in addMetricsContainer {
                if let structure0 = structure0 {
                    addMetricsDecoded0?.append(structure0)
                }
            }
        }
        addMetrics = addMetricsDecoded0
        let removeMetricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeMetrics)
        var removeMetricsDecoded0:[Swift.String]? = nil
        if let removeMetricsContainer = removeMetricsContainer {
            removeMetricsDecoded0 = [Swift.String]()
            for string0 in removeMetricsContainer {
                if let string0 = string0 {
                    removeMetricsDecoded0?.append(string0)
                }
            }
        }
        removeMetrics = removeMetricsDecoded0
        let metricsOutputConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.MetricAttributionOutput.self, forKey: .metricsOutputConfig)
        metricsOutputConfig = metricsOutputConfigDecoded
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
    }
}

extension UpdateMetricAttributionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMetricAttributionOutputBody = try responseDecoder.decode(responseBody: data)
            self.metricAttributionArn = output.metricAttributionArn
        } else {
            self.metricAttributionArn = nil
        }
    }
}

public struct UpdateMetricAttributionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the metric attribution that you updated.
    public var metricAttributionArn: Swift.String?

    public init(
        metricAttributionArn: Swift.String? = nil
    )
    {
        self.metricAttributionArn = metricAttributionArn
    }
}

struct UpdateMetricAttributionOutputBody: Swift.Equatable {
    let metricAttributionArn: Swift.String?
}

extension UpdateMetricAttributionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricAttributionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricAttributionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricAttributionArn)
        metricAttributionArn = metricAttributionArnDecoded
    }
}

enum UpdateMetricAttributionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRecommenderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
        case recommenderConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
        if let recommenderConfig = self.recommenderConfig {
            try encodeContainer.encode(recommenderConfig, forKey: .recommenderConfig)
        }
    }
}

extension UpdateRecommenderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRecommenderInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recommender to modify.
    /// This member is required.
    public var recommenderArn: Swift.String?
    /// The configuration details of the recommender.
    /// This member is required.
    public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?

    public init(
        recommenderArn: Swift.String? = nil,
        recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil
    )
    {
        self.recommenderArn = recommenderArn
        self.recommenderConfig = recommenderConfig
    }
}

struct UpdateRecommenderInputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
    let recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
}

extension UpdateRecommenderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
        case recommenderConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
        let recommenderConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecommenderConfig.self, forKey: .recommenderConfig)
        recommenderConfig = recommenderConfigDecoded
    }
}

extension UpdateRecommenderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRecommenderOutputBody = try responseDecoder.decode(responseBody: data)
            self.recommenderArn = output.recommenderArn
        } else {
            self.recommenderArn = nil
        }
    }
}

public struct UpdateRecommenderOutput: Swift.Equatable {
    /// The same recommender Amazon Resource Name (ARN) as given in the request.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

struct UpdateRecommenderOutputBody: Swift.Equatable {
    let recommenderArn: Swift.String?
}

extension UpdateRecommenderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommenderArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
    }
}

enum UpdateRecommenderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
