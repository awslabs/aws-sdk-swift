//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError


public struct DeleteCampaignOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDatasetGroupOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDatasetOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteEventTrackerOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFilterOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteMetricAttributionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRecommenderOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSchemaOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSolutionOutput: Swift.Sendable {

    public init() { }
}

public struct StopSolutionVersionCreationOutput: Swift.Sendable {

    public init() { }
}

extension PersonalizeClientTypes {

    /// Describes an algorithm image.
    public struct AlgorithmImage: Swift.Sendable {
        /// The URI of the Docker container for the algorithm image.
        /// This member is required.
        public var dockerURI: Swift.String?
        /// The name of the algorithm image.
        public var name: Swift.String?

        public init(
            dockerURI: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.dockerURI = dockerURI
            self.name = name
        }
    }
}

extension PersonalizeClientTypes {

    /// Provides the name and default range of a categorical hyperparameter and whether the hyperparameter is tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
    public struct DefaultCategoricalHyperParameterRange: Swift.Sendable {
        /// Whether the hyperparameter is tunable.
        public var isTunable: Swift.Bool
        /// The name of the hyperparameter.
        public var name: Swift.String?
        /// A list of the categories for the hyperparameter.
        public var values: [Swift.String]?

        public init(
            isTunable: Swift.Bool = false,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.isTunable = isTunable
            self.name = name
            self.values = values
        }
    }
}

extension PersonalizeClientTypes {

    /// Provides the name and default range of a continuous hyperparameter and whether the hyperparameter is tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
    public struct DefaultContinuousHyperParameterRange: Swift.Sendable {
        /// Whether the hyperparameter is tunable.
        public var isTunable: Swift.Bool
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Double
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Double
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init(
            isTunable: Swift.Bool = false,
            maxValue: Swift.Double = 0.0,
            minValue: Swift.Double = 0.0,
            name: Swift.String? = nil
        )
        {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }
}

extension PersonalizeClientTypes {

    /// Provides the name and default range of a integer-valued hyperparameter and whether the hyperparameter is tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
    public struct DefaultIntegerHyperParameterRange: Swift.Sendable {
        /// Indicates whether the hyperparameter is tunable.
        public var isTunable: Swift.Bool
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Int
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Int
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init(
            isTunable: Swift.Bool = false,
            maxValue: Swift.Int = 0,
            minValue: Swift.Int = 0,
            name: Swift.String? = nil
        )
        {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }
}

extension PersonalizeClientTypes {

    /// Specifies the hyperparameters and their default ranges. Hyperparameters can be categorical, continuous, or integer-valued.
    public struct DefaultHyperParameterRanges: Swift.Sendable {
        /// The categorical hyperparameters and their default ranges.
        public var categoricalHyperParameterRanges: [PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their default ranges.
        public var continuousHyperParameterRanges: [PersonalizeClientTypes.DefaultContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their default ranges.
        public var integerHyperParameterRanges: [PersonalizeClientTypes.DefaultIntegerHyperParameterRange]?

        public init(
            categoricalHyperParameterRanges: [PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]? = nil,
            continuousHyperParameterRanges: [PersonalizeClientTypes.DefaultContinuousHyperParameterRange]? = nil,
            integerHyperParameterRanges: [PersonalizeClientTypes.DefaultIntegerHyperParameterRange]? = nil
        )
        {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }
    }
}

extension PersonalizeClientTypes {

    /// Describes a custom algorithm.
    public struct Algorithm: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the algorithm.
        public var algorithmArn: Swift.String?
        /// The URI of the Docker container for the algorithm image.
        public var algorithmImage: PersonalizeClientTypes.AlgorithmImage?
        /// The date and time (in Unix time) that the algorithm was created.
        public var creationDateTime: Foundation.Date?
        /// Specifies the default hyperparameters, their ranges, and whether they are tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
        public var defaultHyperParameterRanges: PersonalizeClientTypes.DefaultHyperParameterRanges?
        /// Specifies the default hyperparameters.
        public var defaultHyperParameters: [Swift.String: Swift.String]?
        /// Specifies the default maximum number of training jobs and parallel training jobs.
        public var defaultResourceConfig: [Swift.String: Swift.String]?
        /// The date and time (in Unix time) that the algorithm was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the algorithm.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the role.
        public var roleArn: Swift.String?
        /// The training input mode.
        public var trainingInputMode: Swift.String?

        public init(
            algorithmArn: Swift.String? = nil,
            algorithmImage: PersonalizeClientTypes.AlgorithmImage? = nil,
            creationDateTime: Foundation.Date? = nil,
            defaultHyperParameterRanges: PersonalizeClientTypes.DefaultHyperParameterRanges? = nil,
            defaultHyperParameters: [Swift.String: Swift.String]? = nil,
            defaultResourceConfig: [Swift.String: Swift.String]? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            trainingInputMode: Swift.String? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.algorithmImage = algorithmImage
            self.creationDateTime = creationDateTime
            self.defaultHyperParameterRanges = defaultHyperParameterRanges
            self.defaultHyperParameters = defaultHyperParameters
            self.defaultResourceConfig = defaultResourceConfig
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.trainingInputMode = trainingInputMode
        }
    }
}

/// Provide a valid value for the field or parameter.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The limit on the number of requests per second has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource is in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Could not find the specified resource.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have exceeded the maximum number of tags you can apply to this resource.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PersonalizeClientTypes {

    /// The configuration details of a batch inference job.
    public struct BatchInferenceJobConfig: Swift.Sendable {
        /// A string to string map specifying the exploration configuration hyperparameters, including explorationWeight and explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items. See [User-Personalization](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html).
        public var itemExplorationConfig: [Swift.String: Swift.String]?

        public init(
            itemExplorationConfig: [Swift.String: Swift.String]? = nil
        )
        {
            self.itemExplorationConfig = itemExplorationConfig
        }
    }
}

extension PersonalizeClientTypes {

    public enum BatchInferenceJobMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case batchInference
        case themeGeneration
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchInferenceJobMode] {
            return [
                .batchInference,
                .themeGeneration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .batchInference: return "BATCH_INFERENCE"
            case .themeGeneration: return "THEME_GENERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PersonalizeClientTypes {

    /// The configuration details of an Amazon S3 input or output bucket.
    public struct S3DataConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key that Amazon Personalize uses to encrypt or decrypt the input and output files.
        public var kmsKeyArn: Swift.String?
        /// The file path of the Amazon S3 bucket.
        /// This member is required.
        public var path: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.path = path
        }
    }
}

extension PersonalizeClientTypes {

    /// The input configuration of a batch inference job.
    public struct BatchInferenceJobInput: Swift.Sendable {
        /// The URI of the Amazon S3 location that contains your input data. The Amazon S3 bucket must be in the same region as the API endpoint you are calling.
        /// This member is required.
        public var s3DataSource: PersonalizeClientTypes.S3DataConfig?

        public init(
            s3DataSource: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataSource = s3DataSource
        }
    }
}

extension PersonalizeClientTypes {

    /// The output configuration parameters of a batch inference job.
    public struct BatchInferenceJobOutput: Swift.Sendable {
        /// Information on the Amazon S3 bucket in which the batch inference job's output is stored.
        /// This member is required.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init(
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataDestination = s3DataDestination
        }
    }
}

extension PersonalizeClientTypes {

    /// The optional metadata that you apply to resources to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. For more information see [Tagging Amazon Personalize resources](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html).
    public struct Tag: Swift.Sendable {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        /// This member is required.
        public var tagKey: Swift.String?
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key).
        /// This member is required.
        public var tagValue: Swift.String?

        public init(
            tagKey: Swift.String? = nil,
            tagValue: Swift.String? = nil
        )
        {
            self.tagKey = tagKey
            self.tagValue = tagValue
        }
    }
}

extension PersonalizeClientTypes {

    /// A string to string map of the configuration details for theme generation.
    public struct FieldsForThemeGeneration: Swift.Sendable {
        /// The name of the Items dataset column that stores the name of each item in the dataset.
        /// This member is required.
        public var itemName: Swift.String?

        public init(
            itemName: Swift.String? = nil
        )
        {
            self.itemName = itemName
        }
    }
}

extension PersonalizeClientTypes {

    /// The configuration details for generating themes with a batch inference job.
    public struct ThemeGenerationConfig: Swift.Sendable {
        /// Fields used to generate descriptive themes for a batch inference job.
        /// This member is required.
        public var fieldsForThemeGeneration: PersonalizeClientTypes.FieldsForThemeGeneration?

        public init(
            fieldsForThemeGeneration: PersonalizeClientTypes.FieldsForThemeGeneration? = nil
        )
        {
            self.fieldsForThemeGeneration = fieldsForThemeGeneration
        }
    }
}

public struct CreateBatchInferenceJobInput: Swift.Sendable {
    /// The configuration details of a batch inference job.
    public var batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig?
    /// The mode of the batch inference job. To generate descriptive themes for groups of similar items, set the job mode to THEME_GENERATION. If you don't want to generate themes, use the default BATCH_INFERENCE. When you get batch recommendations with themes, you will incur additional costs. For more information, see [Amazon Personalize pricing](https://aws.amazon.com/personalize/pricing/).
    public var batchInferenceJobMode: PersonalizeClientTypes.BatchInferenceJobMode?
    /// The ARN of the filter to apply to the batch inference job. For more information on using filters, see [Filtering batch recommendations](https://docs.aws.amazon.com/personalize/latest/dg/filter-batch.html).
    public var filterArn: Swift.String?
    /// The Amazon S3 path that leads to the input file to base your recommendations on. The input material must be in JSON format.
    /// This member is required.
    public var jobInput: PersonalizeClientTypes.BatchInferenceJobInput?
    /// The name of the batch inference job to create.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the Amazon S3 bucket where the job's output will be stored.
    /// This member is required.
    public var jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput?
    /// The number of recommendations to retrieve.
    public var numResults: Swift.Int?
    /// The ARN of the Amazon Identity and Access Management role that has permissions to read and write to your input and output Amazon S3 buckets respectively.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version that will be used to generate the batch inference recommendations.
    /// This member is required.
    public var solutionVersionArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the batch inference job.
    public var tags: [PersonalizeClientTypes.Tag]?
    /// For theme generation jobs, specify the name of the column in your Items dataset that contains each item's name.
    public var themeGenerationConfig: PersonalizeClientTypes.ThemeGenerationConfig?

    public init(
        batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig? = nil,
        batchInferenceJobMode: PersonalizeClientTypes.BatchInferenceJobMode? = nil,
        filterArn: Swift.String? = nil,
        jobInput: PersonalizeClientTypes.BatchInferenceJobInput? = nil,
        jobName: Swift.String? = nil,
        jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput? = nil,
        numResults: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil,
        themeGenerationConfig: PersonalizeClientTypes.ThemeGenerationConfig? = nil
    )
    {
        self.batchInferenceJobConfig = batchInferenceJobConfig
        self.batchInferenceJobMode = batchInferenceJobMode
        self.filterArn = filterArn
        self.jobInput = jobInput
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.numResults = numResults
        self.roleArn = roleArn
        self.solutionVersionArn = solutionVersionArn
        self.tags = tags
        self.themeGenerationConfig = themeGenerationConfig
    }
}

public struct CreateBatchInferenceJobOutput: Swift.Sendable {
    /// The ARN of the batch inference job.
    public var batchInferenceJobArn: Swift.String?

    public init(
        batchInferenceJobArn: Swift.String? = nil
    )
    {
        self.batchInferenceJobArn = batchInferenceJobArn
    }
}

extension PersonalizeClientTypes {

    /// The input configuration of a batch segment job.
    public struct BatchSegmentJobInput: Swift.Sendable {
        /// The configuration details of an Amazon S3 input or output bucket.
        /// This member is required.
        public var s3DataSource: PersonalizeClientTypes.S3DataConfig?

        public init(
            s3DataSource: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataSource = s3DataSource
        }
    }
}

extension PersonalizeClientTypes {

    /// The output configuration parameters of a batch segment job.
    public struct BatchSegmentJobOutput: Swift.Sendable {
        /// The configuration details of an Amazon S3 input or output bucket.
        /// This member is required.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init(
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataDestination = s3DataDestination
        }
    }
}

public struct CreateBatchSegmentJobInput: Swift.Sendable {
    /// The ARN of the filter to apply to the batch segment job. For more information on using filters, see [Filtering batch recommendations](https://docs.aws.amazon.com/personalize/latest/dg/filter-batch.html).
    public var filterArn: Swift.String?
    /// The Amazon S3 path for the input data used to generate the batch segment job.
    /// This member is required.
    public var jobInput: PersonalizeClientTypes.BatchSegmentJobInput?
    /// The name of the batch segment job to create.
    /// This member is required.
    public var jobName: Swift.String?
    /// The Amazon S3 path for the bucket where the job's output will be stored.
    /// This member is required.
    public var jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput?
    /// The number of predicted users generated by the batch segment job for each line of input data. The maximum number of users per segment is 5 million.
    public var numResults: Swift.Int?
    /// The ARN of the Amazon Identity and Access Management role that has permissions to read and write to your input and output Amazon S3 buckets respectively.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version you want the batch segment job to use to generate batch segments.
    /// This member is required.
    public var solutionVersionArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the batch segment job.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        filterArn: Swift.String? = nil,
        jobInput: PersonalizeClientTypes.BatchSegmentJobInput? = nil,
        jobName: Swift.String? = nil,
        jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput? = nil,
        numResults: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.filterArn = filterArn
        self.jobInput = jobInput
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.numResults = numResults
        self.roleArn = roleArn
        self.solutionVersionArn = solutionVersionArn
        self.tags = tags
    }
}

public struct CreateBatchSegmentJobOutput: Swift.Sendable {
    /// The ARN of the batch segment job.
    public var batchSegmentJobArn: Swift.String?

    public init(
        batchSegmentJobArn: Swift.String? = nil
    )
    {
        self.batchSegmentJobArn = batchSegmentJobArn
    }
}

extension PersonalizeClientTypes {

    /// The configuration details of a campaign.
    public struct CampaignConfig: Swift.Sendable {
        /// Whether metadata with recommendations is enabled for the campaign. If enabled, you can specify the columns from your Items dataset in your request for recommendations. Amazon Personalize returns this data for each item in the recommendation response. For information about enabling metadata for a campaign, see [Enabling metadata in recommendations for a campaign](https://docs.aws.amazon.com/personalize/latest/dg/campaigns.html#create-campaign-return-metadata). If you enable metadata in recommendations, you will incur additional costs. For more information, see [Amazon Personalize pricing](https://aws.amazon.com/personalize/pricing/).
        public var enableMetadataWithRecommendations: Swift.Bool?
        /// Specifies the exploration configuration hyperparameters, including explorationWeight and explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items. Provide itemExplorationConfig data only if your solution uses the [User-Personalization](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html) recipe.
        public var itemExplorationConfig: [Swift.String: Swift.String]?
        /// Whether the campaign automatically updates to use the latest solution version (trained model) of a solution. If you specify True, you must specify the ARN of your solution for the SolutionVersionArn parameter. It must be in SolutionArn/$LATEST format. The default is False and you must manually update the campaign to deploy the latest solution version. For more information about automatic campaign updates, see [Enabling automatic campaign updates](https://docs.aws.amazon.com/personalize/latest/dg/campaigns.html#create-campaign-automatic-latest-sv-update).
        public var syncWithLatestSolutionVersion: Swift.Bool?

        public init(
            enableMetadataWithRecommendations: Swift.Bool? = nil,
            itemExplorationConfig: [Swift.String: Swift.String]? = nil,
            syncWithLatestSolutionVersion: Swift.Bool? = nil
        )
        {
            self.enableMetadataWithRecommendations = enableMetadataWithRecommendations
            self.itemExplorationConfig = itemExplorationConfig
            self.syncWithLatestSolutionVersion = syncWithLatestSolutionVersion
        }
    }
}

public struct CreateCampaignInput: Swift.Sendable {
    /// The configuration details of a campaign.
    public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
    /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support. A high minProvisionedTPS will increase your bill. We recommend starting with 1 for minProvisionedTPS (the default). Track your usage using Amazon CloudWatch metrics, and increase the minProvisionedTPS as necessary.
    public var minProvisionedTPS: Swift.Int?
    /// A name for the new campaign. The campaign name must be unique within your account.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the trained model to deploy with the campaign. To specify the latest solution version of your solution, specify the ARN of your solution in SolutionArn/$LATEST format. You must use this format if you set syncWithLatestSolutionVersion to True in the [CampaignConfig](https://docs.aws.amazon.com/personalize/latest/dg/API_CampaignConfig.html). To deploy a model that isn't the latest solution version of your solution, specify the ARN of the solution version. For more information about automatic campaign updates, see [Enabling automatic campaign updates](https://docs.aws.amazon.com/personalize/latest/dg/campaigns.html#create-campaign-automatic-latest-sv-update).
    /// This member is required.
    public var solutionVersionArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the campaign.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
        minProvisionedTPS: Swift.Int? = nil,
        name: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.campaignConfig = campaignConfig
        self.minProvisionedTPS = minProvisionedTPS
        self.name = name
        self.solutionVersionArn = solutionVersionArn
        self.tags = tags
    }
}

public struct CreateCampaignOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the campaign.
    public var campaignArn: Swift.String?

    public init(
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

extension PersonalizeClientTypes {

    /// Describes the data source that contains the data to upload to a dataset, or the list of records to delete from Amazon Personalize.
    public struct DataSource: Swift.Sendable {
        /// For dataset import jobs, the path to the Amazon S3 bucket where the data that you want to upload to your dataset is stored. For data deletion jobs, the path to the Amazon S3 bucket that stores the list of records to delete. For example: s3://bucket-name/folder-name/fileName.csv If your CSV files are in a folder in your Amazon S3 bucket and you want your import job or data deletion job to consider multiple files, you can specify the path to the folder. With a data deletion job, Amazon Personalize uses all files in the folder and any sub folder. Use the following syntax with a / after the folder name: s3://bucket-name/folder-name/
        public var dataLocation: Swift.String?

        public init(
            dataLocation: Swift.String? = nil
        )
        {
            self.dataLocation = dataLocation
        }
    }
}

public struct CreateDataDeletionJobInput: Swift.Sendable {
    /// The Amazon S3 bucket that contains the list of userIds of the users to delete.
    /// This member is required.
    public var dataSource: PersonalizeClientTypes.DataSource?
    /// The Amazon Resource Name (ARN) of the dataset group that has the datasets you want to delete records from.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The name for the data deletion job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that has permissions to read from the Amazon S3 data source.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the data deletion job.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        dataSource: PersonalizeClientTypes.DataSource? = nil,
        datasetGroupArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.dataSource = dataSource
        self.datasetGroupArn = datasetGroupArn
        self.jobName = jobName
        self.roleArn = roleArn
        self.tags = tags
    }
}

public struct CreateDataDeletionJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the data deletion job.
    public var dataDeletionJobArn: Swift.String?

    public init(
        dataDeletionJobArn: Swift.String? = nil
    )
    {
        self.dataDeletionJobArn = dataDeletionJobArn
    }
}

public struct CreateDatasetInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset group to add the dataset to.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The type of dataset. One of the following (case insensitive) values:
    ///
    /// * Interactions
    ///
    /// * Items
    ///
    /// * Users
    ///
    /// * Actions
    ///
    /// * Action_Interactions
    /// This member is required.
    public var datasetType: Swift.String?
    /// The name for the dataset.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the schema to associate with the dataset. The schema defines the dataset fields.
    /// This member is required.
    public var schemaArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the dataset.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        datasetGroupArn: Swift.String? = nil,
        datasetType: Swift.String? = nil,
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.datasetType = datasetType
        self.name = name
        self.schemaArn = schemaArn
        self.tags = tags
    }
}

public struct CreateDatasetOutput: Swift.Sendable {
    /// The ARN of the dataset.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

extension PersonalizeClientTypes {

    public enum IngestionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case bulk
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionMode] {
            return [
                .all,
                .bulk,
                .put
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .bulk: return "BULK"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PersonalizeClientTypes {

    /// The output configuration parameters of a dataset export job.
    public struct DatasetExportJobOutput: Swift.Sendable {
        /// The configuration details of an Amazon S3 input or output bucket.
        /// This member is required.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init(
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataDestination = s3DataDestination
        }
    }
}

public struct CreateDatasetExportJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset that contains the data to export.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// The data to export, based on how you imported the data. You can choose to export only BULK data that you imported using a dataset import job, only PUT data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or ALL for both types. The default value is PUT.
    public var ingestionMode: PersonalizeClientTypes.IngestionMode?
    /// The name for the dataset export job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the Amazon S3 bucket where the job's output is stored.
    /// This member is required.
    public var jobOutput: PersonalizeClientTypes.DatasetExportJobOutput?
    /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your output Amazon S3 bucket.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the dataset export job.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        datasetArn: Swift.String? = nil,
        ingestionMode: PersonalizeClientTypes.IngestionMode? = nil,
        jobName: Swift.String? = nil,
        jobOutput: PersonalizeClientTypes.DatasetExportJobOutput? = nil,
        roleArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetArn = datasetArn
        self.ingestionMode = ingestionMode
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.roleArn = roleArn
        self.tags = tags
    }
}

public struct CreateDatasetExportJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset export job.
    public var datasetExportJobArn: Swift.String?

    public init(
        datasetExportJobArn: Swift.String? = nil
    )
    {
        self.datasetExportJobArn = datasetExportJobArn
    }
}

extension PersonalizeClientTypes {

    public enum Domain: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ecommerce
        case videoOnDemand
        case sdkUnknown(Swift.String)

        public static var allCases: [Domain] {
            return [
                .ecommerce,
                .videoOnDemand
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ecommerce: return "ECOMMERCE"
            case .videoOnDemand: return "VIDEO_ON_DEMAND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDatasetGroupInput: Swift.Sendable {
    /// The domain of the dataset group. Specify a domain to create a Domain dataset group. The domain you specify determines the default schemas for datasets and the use cases available for recommenders. If you don't specify a domain, you create a Custom dataset group with solution versions that you deploy with a campaign.
    public var domain: PersonalizeClientTypes.Domain?
    /// The Amazon Resource Name (ARN) of a Key Management Service (KMS) key used to encrypt the datasets.
    public var kmsKeyArn: Swift.String?
    /// The name for the new dataset group.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the Identity and Access Management (IAM) role that has permissions to access the Key Management Service (KMS) key. Supplying an IAM role is only valid when also specifying a KMS key.
    public var roleArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the dataset group.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        domain: PersonalizeClientTypes.Domain? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.domain = domain
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

public struct CreateDatasetGroupOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the new dataset group.
    public var datasetGroupArn: Swift.String?
    /// The domain for the new Domain dataset group.
    public var domain: PersonalizeClientTypes.Domain?

    public init(
        datasetGroupArn: Swift.String? = nil,
        domain: PersonalizeClientTypes.Domain? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.domain = domain
    }
}

extension PersonalizeClientTypes {

    public enum ImportMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case full
        case incremental
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportMode] {
            return [
                .full,
                .incremental
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .incremental: return "INCREMENTAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDatasetImportJobInput: Swift.Sendable {
    /// The Amazon S3 bucket that contains the training data to import.
    /// This member is required.
    public var dataSource: PersonalizeClientTypes.DataSource?
    /// The ARN of the dataset that receives the imported data.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// Specify how to add the new records to an existing dataset. The default import mode is FULL. If you haven't imported bulk records into the dataset previously, you can only specify FULL.
    ///
    /// * Specify FULL to overwrite all existing bulk data in your dataset. Data you imported individually is not replaced.
    ///
    /// * Specify INCREMENTAL to append the new records to the existing data in your dataset. Amazon Personalize replaces any record with the same ID with the new one.
    public var importMode: PersonalizeClientTypes.ImportMode?
    /// The name for the dataset import job.
    /// This member is required.
    public var jobName: Swift.String?
    /// If you created a metric attribution, specify whether to publish metrics for this import job to Amazon S3
    public var publishAttributionMetricsToS3: Swift.Bool?
    /// The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the dataset import job.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        dataSource: PersonalizeClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        importMode: PersonalizeClientTypes.ImportMode? = nil,
        jobName: Swift.String? = nil,
        publishAttributionMetricsToS3: Swift.Bool? = nil,
        roleArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.importMode = importMode
        self.jobName = jobName
        self.publishAttributionMetricsToS3 = publishAttributionMetricsToS3
        self.roleArn = roleArn
        self.tags = tags
    }
}

public struct CreateDatasetImportJobOutput: Swift.Sendable {
    /// The ARN of the dataset import job.
    public var datasetImportJobArn: Swift.String?

    public init(
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

public struct CreateEventTrackerInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The name for the event tracker.
    /// This member is required.
    public var name: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the event tracker.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        datasetGroupArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.name = name
        self.tags = tags
    }
}

public struct CreateEventTrackerOutput: Swift.Sendable {
    /// The ARN of the event tracker.
    public var eventTrackerArn: Swift.String?
    /// The ID of the event tracker. Include this ID in requests to the [PutEvents](https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html) API.
    public var trackingId: Swift.String?

    public init(
        eventTrackerArn: Swift.String? = nil,
        trackingId: Swift.String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
        self.trackingId = trackingId
    }
}

public struct CreateFilterInput: Swift.Sendable {
    /// The ARN of the dataset group that the filter will belong to.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The filter expression defines which items are included or excluded from recommendations. Filter expression must follow specific format rules. For information about filter expression structure and syntax, see [Filter expressions](https://docs.aws.amazon.com/personalize/latest/dg/filter-expressions.html).
    /// This member is required.
    public var filterExpression: Swift.String?
    /// The name of the filter to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the filter.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        datasetGroupArn: Swift.String? = nil,
        filterExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.filterExpression = filterExpression
        self.name = name
        self.tags = tags
    }
}

extension CreateFilterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFilterInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), filterExpression: \"CONTENT_REDACTED\")"}
}

public struct CreateFilterOutput: Swift.Sendable {
    /// The ARN of the new filter.
    public var filterArn: Swift.String?

    public init(
        filterArn: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

extension PersonalizeClientTypes {

    /// Contains information on a metric that a metric attribution reports on. For more information, see [Measuring impact of recommendations](https://docs.aws.amazon.com/personalize/latest/dg/measuring-recommendation-impact.html).
    public struct MetricAttribute: Swift.Sendable {
        /// The metric's event type.
        /// This member is required.
        public var eventType: Swift.String?
        /// The attribute's expression. Available functions are SUM() or SAMPLECOUNT(). For SUM() functions, provide the dataset type (either Interactions or Items) and column to sum as a parameter. For example SUM(Items.PRICE).
        /// This member is required.
        public var expression: Swift.String?
        /// The metric's name. The name helps you identify the metric in Amazon CloudWatch or Amazon S3.
        /// This member is required.
        public var metricName: Swift.String?

        public init(
            eventType: Swift.String? = nil,
            expression: Swift.String? = nil,
            metricName: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.expression = expression
            self.metricName = metricName
        }
    }
}

extension PersonalizeClientTypes {

    /// The output configuration details for a metric attribution.
    public struct MetricAttributionOutput: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your output Amazon S3 bucket and add metrics to Amazon CloudWatch. For more information, see [Measuring impact of recommendations](https://docs.aws.amazon.com/personalize/latest/dg/measuring-recommendation-impact.html).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The configuration details of an Amazon S3 input or output bucket.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init(
            roleArn: Swift.String? = nil,
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.roleArn = roleArn
            self.s3DataDestination = s3DataDestination
        }
    }
}

public struct CreateMetricAttributionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the destination dataset group for the metric attribution.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// A list of metric attributes for the metric attribution. Each metric attribute specifies an event type to track and a function. Available functions are SUM() or SAMPLECOUNT(). For SUM() functions, provide the dataset type (either Interactions or Items) and column to sum as a parameter. For example SUM(Items.PRICE).
    /// This member is required.
    public var metrics: [PersonalizeClientTypes.MetricAttribute]?
    /// The output configuration details for the metric attribution.
    /// This member is required.
    public var metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput?
    /// A name for the metric attribution.
    /// This member is required.
    public var name: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        metrics: [PersonalizeClientTypes.MetricAttribute]? = nil,
        metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput? = nil,
        name: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.metrics = metrics
        self.metricsOutputConfig = metricsOutputConfig
        self.name = name
    }
}

public struct CreateMetricAttributionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the new metric attribution.
    public var metricAttributionArn: Swift.String?

    public init(
        metricAttributionArn: Swift.String? = nil
    )
    {
        self.metricAttributionArn = metricAttributionArn
    }
}

extension PersonalizeClientTypes {

    /// The training data configuration to use when creating a domain recommender or custom solution version (trained model).
    public struct TrainingDataConfig: Swift.Sendable {
        /// Specifies the columns to exclude from training. Each key is a dataset type, and each value is a list of columns. Exclude columns to control what data Amazon Personalize uses to generate recommendations. For example, you might have a column that you want to use only to filter recommendations. You can exclude this column from training and Amazon Personalize considers it only when filtering.
        public var excludedDatasetColumns: [Swift.String: [Swift.String]]?

        public init(
            excludedDatasetColumns: [Swift.String: [Swift.String]]? = nil
        )
        {
            self.excludedDatasetColumns = excludedDatasetColumns
        }
    }
}

extension PersonalizeClientTypes {

    /// The configuration details of the recommender.
    public struct RecommenderConfig: Swift.Sendable {
        /// Whether metadata with recommendations is enabled for the recommender. If enabled, you can specify the columns from your Items dataset in your request for recommendations. Amazon Personalize returns this data for each item in the recommendation response. For information about enabling metadata for a recommender, see [Enabling metadata in recommendations for a recommender](https://docs.aws.amazon.com/personalize/latest/dg/creating-recommenders.html#create-recommender-return-metadata). If you enable metadata in recommendations, you will incur additional costs. For more information, see [Amazon Personalize pricing](https://aws.amazon.com/personalize/pricing/).
        public var enableMetadataWithRecommendations: Swift.Bool?
        /// Specifies the exploration configuration hyperparameters, including explorationWeight and explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when recommending items. Provide itemExplorationConfig data only if your recommenders generate personalized recommendations for a user (not popular items or similar items).
        public var itemExplorationConfig: [Swift.String: Swift.String]?
        /// Specifies the requested minimum provisioned recommendation requests per second that Amazon Personalize will support. A high minRecommendationRequestsPerSecond will increase your bill. We recommend starting with 1 for minRecommendationRequestsPerSecond (the default). Track your usage using Amazon CloudWatch metrics, and increase the minRecommendationRequestsPerSecond as necessary.
        public var minRecommendationRequestsPerSecond: Swift.Int?
        /// Specifies the training data configuration to use when creating a domain recommender.
        public var trainingDataConfig: PersonalizeClientTypes.TrainingDataConfig?

        public init(
            enableMetadataWithRecommendations: Swift.Bool? = nil,
            itemExplorationConfig: [Swift.String: Swift.String]? = nil,
            minRecommendationRequestsPerSecond: Swift.Int? = nil,
            trainingDataConfig: PersonalizeClientTypes.TrainingDataConfig? = nil
        )
        {
            self.enableMetadataWithRecommendations = enableMetadataWithRecommendations
            self.itemExplorationConfig = itemExplorationConfig
            self.minRecommendationRequestsPerSecond = minRecommendationRequestsPerSecond
            self.trainingDataConfig = trainingDataConfig
        }
    }
}

public struct CreateRecommenderInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the destination domain dataset group for the recommender.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The name of the recommender.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the recipe that the recommender will use. For a recommender, a recipe is a Domain dataset group use case. Only Domain dataset group use cases can be used to create a recommender. For information about use cases see [Choosing recommender use cases](https://docs.aws.amazon.com/personalize/latest/dg/domain-use-cases.html).
    /// This member is required.
    public var recipeArn: Swift.String?
    /// The configuration details of the recommender.
    public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the recommender.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        datasetGroupArn: Swift.String? = nil,
        name: Swift.String? = nil,
        recipeArn: Swift.String? = nil,
        recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.name = name
        self.recipeArn = recipeArn
        self.recommenderConfig = recommenderConfig
        self.tags = tags
    }
}

public struct CreateRecommenderOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the recommender.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

public struct CreateSchemaInput: Swift.Sendable {
    /// The domain for the schema. If you are creating a schema for a dataset in a Domain dataset group, specify the domain you chose when you created the Domain dataset group.
    public var domain: PersonalizeClientTypes.Domain?
    /// The name for the schema.
    /// This member is required.
    public var name: Swift.String?
    /// A schema in Avro JSON format.
    /// This member is required.
    public var schema: Swift.String?

    public init(
        domain: PersonalizeClientTypes.Domain? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.domain = domain
        self.name = name
        self.schema = schema
    }
}

public struct CreateSchemaOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the created schema.
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

extension PersonalizeClientTypes {

    /// When the solution performs AutoML (performAutoML is true in [CreateSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSolution.html)), Amazon Personalize determines which recipe, from the specified list, optimizes the given metric. Amazon Personalize then uses that recipe for the solution.
    public struct AutoMLConfig: Swift.Sendable {
        /// The metric to optimize.
        public var metricName: Swift.String?
        /// The list of candidate recipes.
        public var recipeList: [Swift.String]?

        public init(
            metricName: Swift.String? = nil,
            recipeList: [Swift.String]? = nil
        )
        {
            self.metricName = metricName
            self.recipeList = recipeList
        }
    }
}

extension PersonalizeClientTypes {

    /// The automatic training configuration to use when performAutoTraining is true.
    public struct AutoTrainingConfig: Swift.Sendable {
        /// Specifies how often to automatically train new solution versions. Specify a rate expression in rate(value unit) format. For value, specify a number between 1 and 30. For unit, specify day or days. For example, to automatically create a new solution version every 5 days, specify rate(5 days). The default is every 7 days. For more information about auto training, see [Creating and configuring a solution](https://docs.aws.amazon.com/personalize/latest/dg/customizing-solution-config.html).
        public var schedulingExpression: Swift.String?

        public init(
            schedulingExpression: Swift.String? = nil
        )
        {
            self.schedulingExpression = schedulingExpression
        }
    }
}

extension PersonalizeClientTypes {

    /// Provides the name and range of a categorical hyperparameter.
    public struct CategoricalHyperParameterRange: Swift.Sendable {
        /// The name of the hyperparameter.
        public var name: Swift.String?
        /// A list of the categories for the hyperparameter.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

extension PersonalizeClientTypes {

    /// Provides the name and range of a continuous hyperparameter.
    public struct ContinuousHyperParameterRange: Swift.Sendable {
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Double
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Double
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init(
            maxValue: Swift.Double = 0.0,
            minValue: Swift.Double = 0.0,
            name: Swift.String? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }
}

extension PersonalizeClientTypes {

    /// Provides the name and range of an integer-valued hyperparameter.
    public struct IntegerHyperParameterRange: Swift.Sendable {
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Int
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Int
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init(
            maxValue: Swift.Int = 0,
            minValue: Swift.Int = 0,
            name: Swift.String? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }
}

extension PersonalizeClientTypes {

    /// Specifies the hyperparameters and their ranges. Hyperparameters can be categorical, continuous, or integer-valued.
    public struct HyperParameterRanges: Swift.Sendable {
        /// The categorical hyperparameters and their ranges.
        public var categoricalHyperParameterRanges: [PersonalizeClientTypes.CategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their ranges.
        public var continuousHyperParameterRanges: [PersonalizeClientTypes.ContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their ranges.
        public var integerHyperParameterRanges: [PersonalizeClientTypes.IntegerHyperParameterRange]?

        public init(
            categoricalHyperParameterRanges: [PersonalizeClientTypes.CategoricalHyperParameterRange]? = nil,
            continuousHyperParameterRanges: [PersonalizeClientTypes.ContinuousHyperParameterRange]? = nil,
            integerHyperParameterRanges: [PersonalizeClientTypes.IntegerHyperParameterRange]? = nil
        )
        {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }
    }
}

extension PersonalizeClientTypes {

    /// The metric to optimize during hyperparameter optimization (HPO). Amazon Personalize doesn't support configuring the hpoObjective at this time.
    public struct HPOObjective: Swift.Sendable {
        /// The name of the metric.
        public var metricName: Swift.String?
        /// A regular expression for finding the metric in the training job logs.
        public var metricRegex: Swift.String?
        /// The type of the metric. Valid values are Maximize and Minimize.
        public var type: Swift.String?

        public init(
            metricName: Swift.String? = nil,
            metricRegex: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.metricRegex = metricRegex
            self.type = type
        }
    }
}

extension PersonalizeClientTypes {

    /// Describes the resource configuration for hyperparameter optimization (HPO).
    public struct HPOResourceConfig: Swift.Sendable {
        /// The maximum number of training jobs when you create a solution version. The maximum value for maxNumberOfTrainingJobs is 40.
        public var maxNumberOfTrainingJobs: Swift.String?
        /// The maximum number of parallel training jobs when you create a solution version. The maximum value for maxParallelTrainingJobs is 10.
        public var maxParallelTrainingJobs: Swift.String?

        public init(
            maxNumberOfTrainingJobs: Swift.String? = nil,
            maxParallelTrainingJobs: Swift.String? = nil
        )
        {
            self.maxNumberOfTrainingJobs = maxNumberOfTrainingJobs
            self.maxParallelTrainingJobs = maxParallelTrainingJobs
        }
    }
}

extension PersonalizeClientTypes {

    /// Describes the properties for hyperparameter optimization (HPO).
    public struct HPOConfig: Swift.Sendable {
        /// The hyperparameters and their allowable ranges.
        public var algorithmHyperParameterRanges: PersonalizeClientTypes.HyperParameterRanges?
        /// The metric to optimize during HPO. Amazon Personalize doesn't support configuring the hpoObjective at this time.
        public var hpoObjective: PersonalizeClientTypes.HPOObjective?
        /// Describes the resource configuration for HPO.
        public var hpoResourceConfig: PersonalizeClientTypes.HPOResourceConfig?

        public init(
            algorithmHyperParameterRanges: PersonalizeClientTypes.HyperParameterRanges? = nil,
            hpoObjective: PersonalizeClientTypes.HPOObjective? = nil,
            hpoResourceConfig: PersonalizeClientTypes.HPOResourceConfig? = nil
        )
        {
            self.algorithmHyperParameterRanges = algorithmHyperParameterRanges
            self.hpoObjective = hpoObjective
            self.hpoResourceConfig = hpoResourceConfig
        }
    }
}

extension PersonalizeClientTypes {

    public enum ObjectiveSensitivity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectiveSensitivity] {
            return [
                .high,
                .low,
                .medium,
                .off
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PersonalizeClientTypes {

    /// Describes the additional objective for the solution, such as maximizing streaming minutes or increasing revenue. For more information see [Optimizing a solution](https://docs.aws.amazon.com/personalize/latest/dg/optimizing-solution-for-objective.html).
    public struct OptimizationObjective: Swift.Sendable {
        /// The numerical metadata column in an Items dataset related to the optimization objective. For example, VIDEO_LENGTH (to maximize streaming minutes), or PRICE (to maximize revenue).
        public var itemAttribute: Swift.String?
        /// Specifies how Amazon Personalize balances the importance of your optimization objective versus relevance.
        public var objectiveSensitivity: PersonalizeClientTypes.ObjectiveSensitivity?

        public init(
            itemAttribute: Swift.String? = nil,
            objectiveSensitivity: PersonalizeClientTypes.ObjectiveSensitivity? = nil
        )
        {
            self.itemAttribute = itemAttribute
            self.objectiveSensitivity = objectiveSensitivity
        }
    }
}

extension PersonalizeClientTypes {

    /// Describes the configuration properties for the solution.
    public struct SolutionConfig: Swift.Sendable {
        /// Lists the algorithm hyperparameters and their values.
        public var algorithmHyperParameters: [Swift.String: Swift.String]?
        /// The [AutoMLConfig](https://docs.aws.amazon.com/personalize/latest/dg/API_AutoMLConfig.html) object containing a list of recipes to search when AutoML is performed.
        public var autoMLConfig: PersonalizeClientTypes.AutoMLConfig?
        /// Specifies the automatic training configuration to use.
        public var autoTrainingConfig: PersonalizeClientTypes.AutoTrainingConfig?
        /// Only events with a value greater than or equal to this threshold are used for training a model.
        public var eventValueThreshold: Swift.String?
        /// Lists the feature transformation parameters.
        public var featureTransformationParameters: [Swift.String: Swift.String]?
        /// Describes the properties for hyperparameter optimization (HPO).
        public var hpoConfig: PersonalizeClientTypes.HPOConfig?
        /// Describes the additional objective for the solution, such as maximizing streaming minutes or increasing revenue. For more information see [Optimizing a solution](https://docs.aws.amazon.com/personalize/latest/dg/optimizing-solution-for-objective.html).
        public var optimizationObjective: PersonalizeClientTypes.OptimizationObjective?
        /// Specifies the training data configuration to use when creating a custom solution version (trained model).
        public var trainingDataConfig: PersonalizeClientTypes.TrainingDataConfig?

        public init(
            algorithmHyperParameters: [Swift.String: Swift.String]? = nil,
            autoMLConfig: PersonalizeClientTypes.AutoMLConfig? = nil,
            autoTrainingConfig: PersonalizeClientTypes.AutoTrainingConfig? = nil,
            eventValueThreshold: Swift.String? = nil,
            featureTransformationParameters: [Swift.String: Swift.String]? = nil,
            hpoConfig: PersonalizeClientTypes.HPOConfig? = nil,
            optimizationObjective: PersonalizeClientTypes.OptimizationObjective? = nil,
            trainingDataConfig: PersonalizeClientTypes.TrainingDataConfig? = nil
        )
        {
            self.algorithmHyperParameters = algorithmHyperParameters
            self.autoMLConfig = autoMLConfig
            self.autoTrainingConfig = autoTrainingConfig
            self.eventValueThreshold = eventValueThreshold
            self.featureTransformationParameters = featureTransformationParameters
            self.hpoConfig = hpoConfig
            self.optimizationObjective = optimizationObjective
            self.trainingDataConfig = trainingDataConfig
        }
    }
}

public struct CreateSolutionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// When your have multiple event types (using an EVENT_TYPE schema field), this parameter specifies which event type (for example, 'click' or 'like') is used for training the model. If you do not provide an eventType, Amazon Personalize will use all interactions for training with equal weight regardless of type.
    public var eventType: Swift.String?
    /// The name for the solution.
    /// This member is required.
    public var name: Swift.String?
    /// We don't recommend enabling automated machine learning. Instead, match your use case to the available Amazon Personalize recipes. For more information, see [Choosing a recipe](https://docs.aws.amazon.com/personalize/latest/dg/working-with-predefined-recipes.html). Whether to perform automated machine learning (AutoML). The default is false. For this case, you must specify recipeArn. When set to true, Amazon Personalize analyzes your training data and selects the optimal USER_PERSONALIZATION recipe and hyperparameters. In this case, you must omit recipeArn. Amazon Personalize determines the optimal recipe by running tests with different values for the hyperparameters. AutoML lengthens the training process as compared to selecting a specific recipe.
    public var performAutoML: Swift.Bool?
    /// Whether the solution uses automatic training to create new solution versions (trained models). The default is True and the solution automatically creates new solution versions every 7 days. You can change the training frequency by specifying a schedulingExpression in the AutoTrainingConfig as part of solution configuration. For more information about automatic training, see [Configuring automatic training](https://docs.aws.amazon.com/personalize/latest/dg/solution-config-auto-training.html). Automatic solution version creation starts within one hour after the solution is ACTIVE. If you manually create a solution version within the hour, the solution skips the first automatic training. After training starts, you can get the solution version's Amazon Resource Name (ARN) with the [ListSolutionVersions](https://docs.aws.amazon.com/personalize/latest/dg/API_ListSolutionVersions.html) API operation. To get its status, use the [DescribeSolutionVersion](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeSolutionVersion.html).
    public var performAutoTraining: Swift.Bool?
    /// Whether to perform hyperparameter optimization (HPO) on the specified or selected recipe. The default is false. When performing AutoML, this parameter is always true and you should not set it to false.
    public var performHPO: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the recipe to use for model training. This is required when performAutoML is false. For information about different Amazon Personalize recipes and their ARNs, see [Choosing a recipe](https://docs.aws.amazon.com/personalize/latest/dg/working-with-predefined-recipes.html).
    public var recipeArn: Swift.String?
    /// The configuration properties for the solution. When performAutoML is set to true, Amazon Personalize only evaluates the autoMLConfig section of the solution configuration. Amazon Personalize doesn't support configuring the hpoObjective at this time.
    public var solutionConfig: PersonalizeClientTypes.SolutionConfig?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the solution.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        datasetGroupArn: Swift.String? = nil,
        eventType: Swift.String? = nil,
        name: Swift.String? = nil,
        performAutoML: Swift.Bool? = false,
        performAutoTraining: Swift.Bool? = nil,
        performHPO: Swift.Bool? = nil,
        recipeArn: Swift.String? = nil,
        solutionConfig: PersonalizeClientTypes.SolutionConfig? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.eventType = eventType
        self.name = name
        self.performAutoML = performAutoML
        self.performAutoTraining = performAutoTraining
        self.performHPO = performHPO
        self.recipeArn = recipeArn
        self.solutionConfig = solutionConfig
        self.tags = tags
    }
}

public struct CreateSolutionOutput: Swift.Sendable {
    /// The ARN of the solution.
    public var solutionArn: Swift.String?

    public init(
        solutionArn: Swift.String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

extension PersonalizeClientTypes {

    public enum TrainingMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case autotrain
        case full
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [TrainingMode] {
            return [
                .autotrain,
                .full,
                .update
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .autotrain: return "AUTOTRAIN"
            case .full: return "FULL"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSolutionVersionInput: Swift.Sendable {
    /// The name of the solution version.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution containing the training configuration information.
    /// This member is required.
    public var solutionArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html) to apply to the solution version.
    public var tags: [PersonalizeClientTypes.Tag]?
    /// The scope of training to be performed when creating the solution version. The default is FULL. This creates a completely new model based on the entirety of the training data from the datasets in your dataset group. If you use [User-Personalization](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html), you can specify a training mode of UPDATE. This updates the model to consider new items for recommendations. It is not a full retraining. You should still complete a full retraining weekly. If you specify UPDATE, Amazon Personalize will stop automatic updates for the solution version. To resume updates, create a new solution with training mode set to FULL and deploy it in a campaign. For more information about automatic updates, see [Automatic updates](https://docs.aws.amazon.com/personalize/latest/dg/use-case-recipe-features.html#maintaining-with-automatic-updates). The UPDATE option can only be used when you already have an active solution version created from the input solution using the FULL option and the input solution was trained with the [User-Personalization](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html) recipe or the legacy [HRNN-Coldstart](https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-hrnn-coldstart.html) recipe.
    public var trainingMode: PersonalizeClientTypes.TrainingMode?

    public init(
        name: Swift.String? = nil,
        solutionArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil,
        trainingMode: PersonalizeClientTypes.TrainingMode? = nil
    )
    {
        self.name = name
        self.solutionArn = solutionArn
        self.tags = tags
        self.trainingMode = trainingMode
    }
}

public struct CreateSolutionVersionOutput: Swift.Sendable {
    /// The ARN of the new solution version.
    public var solutionVersionArn: Swift.String?

    public init(
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

public struct DeleteCampaignInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the campaign to delete.
    /// This member is required.
    public var campaignArn: Swift.String?

    public init(
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

public struct DeleteDatasetInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset to delete.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

public struct DeleteDatasetGroupInput: Swift.Sendable {
    /// The ARN of the dataset group to delete.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

public struct DeleteEventTrackerInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the event tracker to delete.
    /// This member is required.
    public var eventTrackerArn: Swift.String?

    public init(
        eventTrackerArn: Swift.String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
    }
}

public struct DeleteFilterInput: Swift.Sendable {
    /// The ARN of the filter to delete.
    /// This member is required.
    public var filterArn: Swift.String?

    public init(
        filterArn: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

public struct DeleteMetricAttributionInput: Swift.Sendable {
    /// The metric attribution's Amazon Resource Name (ARN).
    /// This member is required.
    public var metricAttributionArn: Swift.String?

    public init(
        metricAttributionArn: Swift.String? = nil
    )
    {
        self.metricAttributionArn = metricAttributionArn
    }
}

public struct DeleteRecommenderInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the recommender to delete.
    /// This member is required.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

public struct DeleteSchemaInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the schema to delete.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

public struct DeleteSolutionInput: Swift.Sendable {
    /// The ARN of the solution to delete.
    /// This member is required.
    public var solutionArn: Swift.String?

    public init(
        solutionArn: Swift.String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

public struct DescribeAlgorithmInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the algorithm to describe.
    /// This member is required.
    public var algorithmArn: Swift.String?

    public init(
        algorithmArn: Swift.String? = nil
    )
    {
        self.algorithmArn = algorithmArn
    }
}

public struct DescribeAlgorithmOutput: Swift.Sendable {
    /// A listing of the properties of the algorithm.
    public var algorithm: PersonalizeClientTypes.Algorithm?

    public init(
        algorithm: PersonalizeClientTypes.Algorithm? = nil
    )
    {
        self.algorithm = algorithm
    }
}

public struct DescribeBatchInferenceJobInput: Swift.Sendable {
    /// The ARN of the batch inference job to describe.
    /// This member is required.
    public var batchInferenceJobArn: Swift.String?

    public init(
        batchInferenceJobArn: Swift.String? = nil
    )
    {
        self.batchInferenceJobArn = batchInferenceJobArn
    }
}

extension PersonalizeClientTypes {

    /// Contains information on a batch inference job.
    public struct BatchInferenceJob: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public var batchInferenceJobArn: Swift.String?
        /// A string to string map of the configuration details of a batch inference job.
        public var batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig?
        /// The job's mode.
        public var batchInferenceJobMode: PersonalizeClientTypes.BatchInferenceJobMode?
        /// The time at which the batch inference job was created.
        public var creationDateTime: Foundation.Date?
        /// If the batch inference job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter used on the batch inference job.
        public var filterArn: Swift.String?
        /// The Amazon S3 path that leads to the input data used to generate the batch inference job.
        public var jobInput: PersonalizeClientTypes.BatchInferenceJobInput?
        /// The name of the batch inference job.
        public var jobName: Swift.String?
        /// The Amazon S3 bucket that contains the output data generated by the batch inference job.
        public var jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput?
        /// The time at which the batch inference job was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The number of recommendations generated by the batch inference job. This number includes the error messages generated for failed input records.
        public var numResults: Swift.Int?
        /// The ARN of the Amazon Identity and Access Management (IAM) role that requested the batch inference job.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the solution version from which the batch inference job was created.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch inference job. The status is one of the following values:
        ///
        /// * PENDING
        ///
        /// * IN PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        public var status: Swift.String?
        /// The job's theme generation settings.
        public var themeGenerationConfig: PersonalizeClientTypes.ThemeGenerationConfig?

        public init(
            batchInferenceJobArn: Swift.String? = nil,
            batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig? = nil,
            batchInferenceJobMode: PersonalizeClientTypes.BatchInferenceJobMode? = nil,
            creationDateTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            jobInput: PersonalizeClientTypes.BatchInferenceJobInput? = nil,
            jobName: Swift.String? = nil,
            jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            numResults: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil,
            themeGenerationConfig: PersonalizeClientTypes.ThemeGenerationConfig? = nil
        )
        {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.batchInferenceJobConfig = batchInferenceJobConfig
            self.batchInferenceJobMode = batchInferenceJobMode
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
            self.status = status
            self.themeGenerationConfig = themeGenerationConfig
        }
    }
}

public struct DescribeBatchInferenceJobOutput: Swift.Sendable {
    /// Information on the specified batch inference job.
    public var batchInferenceJob: PersonalizeClientTypes.BatchInferenceJob?

    public init(
        batchInferenceJob: PersonalizeClientTypes.BatchInferenceJob? = nil
    )
    {
        self.batchInferenceJob = batchInferenceJob
    }
}

public struct DescribeBatchSegmentJobInput: Swift.Sendable {
    /// The ARN of the batch segment job to describe.
    /// This member is required.
    public var batchSegmentJobArn: Swift.String?

    public init(
        batchSegmentJobArn: Swift.String? = nil
    )
    {
        self.batchSegmentJobArn = batchSegmentJobArn
    }
}

extension PersonalizeClientTypes {

    /// Contains information on a batch segment job.
    public struct BatchSegmentJob: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the batch segment job.
        public var batchSegmentJobArn: Swift.String?
        /// The time at which the batch segment job was created.
        public var creationDateTime: Foundation.Date?
        /// If the batch segment job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter used on the batch segment job.
        public var filterArn: Swift.String?
        /// The Amazon S3 path that leads to the input data used to generate the batch segment job.
        public var jobInput: PersonalizeClientTypes.BatchSegmentJobInput?
        /// The name of the batch segment job.
        public var jobName: Swift.String?
        /// The Amazon S3 bucket that contains the output data generated by the batch segment job.
        public var jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput?
        /// The time at which the batch segment job last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The number of predicted users generated by the batch segment job for each line of input data. The maximum number of users per segment is 5 million.
        public var numResults: Swift.Int?
        /// The ARN of the Amazon Identity and Access Management (IAM) role that requested the batch segment job.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the solution version used by the batch segment job to generate batch segments.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch segment job. The status is one of the following values:
        ///
        /// * PENDING
        ///
        /// * IN PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        public var status: Swift.String?

        public init(
            batchSegmentJobArn: Swift.String? = nil,
            creationDateTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            jobInput: PersonalizeClientTypes.BatchSegmentJobInput? = nil,
            jobName: Swift.String? = nil,
            jobOutput: PersonalizeClientTypes.BatchSegmentJobOutput? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            numResults: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.batchSegmentJobArn = batchSegmentJobArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }
}

public struct DescribeBatchSegmentJobOutput: Swift.Sendable {
    /// Information on the specified batch segment job.
    public var batchSegmentJob: PersonalizeClientTypes.BatchSegmentJob?

    public init(
        batchSegmentJob: PersonalizeClientTypes.BatchSegmentJob? = nil
    )
    {
        self.batchSegmentJob = batchSegmentJob
    }
}

public struct DescribeCampaignInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the campaign.
    /// This member is required.
    public var campaignArn: Swift.String?

    public init(
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a campaign update. For a complete listing, call the [DescribeCampaign](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeCampaign.html) API.
    public struct CampaignUpdateSummary: Swift.Sendable {
        /// The configuration details of a campaign.
        public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
        /// The date and time (in Unix time) that the campaign update was created.
        public var creationDateTime: Foundation.Date?
        /// If a campaign update fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the campaign update was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
        public var minProvisionedTPS: Swift.Int?
        /// The Amazon Resource Name (ARN) of the deployed solution version.
        public var solutionVersionArn: Swift.String?
        /// The status of the campaign update. A campaign update can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
            creationDateTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            minProvisionedTPS: Swift.Int? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.minProvisionedTPS = minProvisionedTPS
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }
}

extension PersonalizeClientTypes {

    /// An object that describes the deployment of a solution version. For more information on campaigns, see [CreateCampaign](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateCampaign.html).
    public struct Campaign: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the campaign.
        public var campaignArn: Swift.String?
        /// The configuration details of a campaign.
        public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
        /// The date and time (in Unix format) that the campaign was created.
        public var creationDateTime: Foundation.Date?
        /// If a campaign fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix format) that the campaign was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// Provides a summary of the properties of a campaign update. For a complete listing, call the [DescribeCampaign](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeCampaign.html) API.
        public var latestCampaignUpdate: PersonalizeClientTypes.CampaignUpdateSummary?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second. A high minProvisionedTPS will increase your bill. We recommend starting with 1 for minProvisionedTPS (the default). Track your usage using Amazon CloudWatch metrics, and increase the minProvisionedTPS as necessary.
        public var minProvisionedTPS: Swift.Int?
        /// The name of the campaign.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the solution version the campaign uses.
        public var solutionVersionArn: Swift.String?
        /// The status of the campaign. A campaign can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            campaignArn: Swift.String? = nil,
            campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
            creationDateTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            latestCampaignUpdate: PersonalizeClientTypes.CampaignUpdateSummary? = nil,
            minProvisionedTPS: Swift.Int? = nil,
            name: Swift.String? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.campaignArn = campaignArn
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestCampaignUpdate = latestCampaignUpdate
            self.minProvisionedTPS = minProvisionedTPS
            self.name = name
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }
}

public struct DescribeCampaignOutput: Swift.Sendable {
    /// The properties of the campaign.
    public var campaign: PersonalizeClientTypes.Campaign?

    public init(
        campaign: PersonalizeClientTypes.Campaign? = nil
    )
    {
        self.campaign = campaign
    }
}

public struct DescribeDataDeletionJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the data deletion job.
    /// This member is required.
    public var dataDeletionJobArn: Swift.String?

    public init(
        dataDeletionJobArn: Swift.String? = nil
    )
    {
        self.dataDeletionJobArn = dataDeletionJobArn
    }
}

extension PersonalizeClientTypes {

    /// Describes a job that deletes all references to specific users from an Amazon Personalize dataset group in batches. For information about creating a data deletion job, see [Deleting users](https://docs.aws.amazon.com/personalize/latest/dg/delete-records.html).
    public struct DataDeletionJob: Swift.Sendable {
        /// The creation date and time (in Unix time) of the data deletion job.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the data deletion job.
        public var dataDeletionJobArn: Swift.String?
        /// Describes the data source that contains the data to upload to a dataset, or the list of records to delete from Amazon Personalize.
        public var dataSource: PersonalizeClientTypes.DataSource?
        /// The Amazon Resource Name (ARN) of the dataset group the job deletes records from.
        public var datasetGroupArn: Swift.String?
        /// If a data deletion job fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The name of the data deletion job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) the data deletion job was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The number of records deleted by a COMPLETED job.
        public var numDeleted: Swift.Int?
        /// The Amazon Resource Name (ARN) of the IAM role that has permissions to read from the Amazon S3 data source.
        public var roleArn: Swift.String?
        /// The status of the data deletion job. A data deletion job can have one of the following statuses:
        ///
        /// * PENDING > IN_PROGRESS > COMPLETED -or- FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            dataDeletionJobArn: Swift.String? = nil,
            dataSource: PersonalizeClientTypes.DataSource? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            numDeleted: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.dataDeletionJobArn = dataDeletionJobArn
            self.dataSource = dataSource
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.numDeleted = numDeleted
            self.roleArn = roleArn
            self.status = status
        }
    }
}

public struct DescribeDataDeletionJobOutput: Swift.Sendable {
    /// Information about the data deletion job, including the status. The status is one of the following values:
    ///
    /// * PENDING
    ///
    /// * IN_PROGRESS
    ///
    /// * COMPLETED
    ///
    /// * FAILED
    public var dataDeletionJob: PersonalizeClientTypes.DataDeletionJob?

    public init(
        dataDeletionJob: PersonalizeClientTypes.DataDeletionJob? = nil
    )
    {
        self.dataDeletionJob = dataDeletionJob
    }
}

public struct DescribeDatasetInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset to describe.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

extension PersonalizeClientTypes {

    /// Describes an update to a dataset.
    public struct DatasetUpdateSummary: Swift.Sendable {
        /// The creation date and time (in Unix time) of the dataset update.
        public var creationDateTime: Foundation.Date?
        /// If updating a dataset fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The last update date and time (in Unix time) of the dataset.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the schema that replaced the previous schema of the dataset.
        public var schemaArn: Swift.String?
        /// The status of the dataset update.
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            schemaArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.schemaArn = schemaArn
            self.status = status
        }
    }
}

extension PersonalizeClientTypes {

    /// Provides metadata for a dataset.
    public struct Dataset: Swift.Sendable {
        /// The creation date and time (in Unix time) of the dataset.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset that you want metadata for.
        public var datasetArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// One of the following values:
        ///
        /// * Interactions
        ///
        /// * Items
        ///
        /// * Users
        ///
        /// * Actions
        ///
        /// * Action_Interactions
        public var datasetType: Swift.String?
        /// A time stamp that shows when the dataset was updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// Describes the latest update to the dataset.
        public var latestDatasetUpdate: PersonalizeClientTypes.DatasetUpdateSummary?
        /// The name of the dataset.
        public var name: Swift.String?
        /// The ARN of the associated schema.
        public var schemaArn: Swift.String?
        /// The status of the dataset. A dataset can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?
        /// The ID of the event tracker for an Action interactions dataset. You specify the tracker's ID in the PutActionInteractions API operation. Amazon Personalize uses it to direct new data to the Action interactions dataset in your dataset group.
        public var trackingId: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetGroupArn: Swift.String? = nil,
            datasetType: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            latestDatasetUpdate: PersonalizeClientTypes.DatasetUpdateSummary? = nil,
            name: Swift.String? = nil,
            schemaArn: Swift.String? = nil,
            status: Swift.String? = nil,
            trackingId: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetGroupArn = datasetGroupArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestDatasetUpdate = latestDatasetUpdate
            self.name = name
            self.schemaArn = schemaArn
            self.status = status
            self.trackingId = trackingId
        }
    }
}

public struct DescribeDatasetOutput: Swift.Sendable {
    /// A listing of the dataset's properties.
    public var dataset: PersonalizeClientTypes.Dataset?

    public init(
        dataset: PersonalizeClientTypes.Dataset? = nil
    )
    {
        self.dataset = dataset
    }
}

public struct DescribeDatasetExportJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset export job to describe.
    /// This member is required.
    public var datasetExportJobArn: Swift.String?

    public init(
        datasetExportJobArn: Swift.String? = nil
    )
    {
        self.datasetExportJobArn = datasetExportJobArn
    }
}

extension PersonalizeClientTypes {

    /// Describes a job that exports a dataset to an Amazon S3 bucket. For more information, see [CreateDatasetExportJob](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateDatasetExportJob.html). A dataset export job can be in one of the following states:
    ///
    /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    public struct DatasetExportJob: Swift.Sendable {
        /// The creation date and time (in Unix time) of the dataset export job.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset to export.
        public var datasetArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public var datasetExportJobArn: Swift.String?
        /// If a dataset export job fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The data to export, based on how you imported the data. You can choose to export BULK data that you imported using a dataset import job, PUT data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or ALL for both types. The default value is PUT.
        public var ingestionMode: PersonalizeClientTypes.IngestionMode?
        /// The name of the export job.
        public var jobName: Swift.String?
        /// The path to the Amazon S3 bucket where the job's output is stored. For example: s3://bucket-name/folder-name/
        public var jobOutput: PersonalizeClientTypes.DatasetExportJobOutput?
        /// The date and time (in Unix time) the status of the dataset export job was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your output Amazon S3 bucket.
        public var roleArn: Swift.String?
        /// The status of the dataset export job. A dataset export job can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetExportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            ingestionMode: PersonalizeClientTypes.IngestionMode? = nil,
            jobName: Swift.String? = nil,
            jobOutput: PersonalizeClientTypes.DatasetExportJobOutput? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetExportJobArn = datasetExportJobArn
            self.failureReason = failureReason
            self.ingestionMode = ingestionMode
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
            self.status = status
        }
    }
}

public struct DescribeDatasetExportJobOutput: Swift.Sendable {
    /// Information about the dataset export job, including the status. The status is one of the following values:
    ///
    /// * CREATE PENDING
    ///
    /// * CREATE IN_PROGRESS
    ///
    /// * ACTIVE
    ///
    /// * CREATE FAILED
    public var datasetExportJob: PersonalizeClientTypes.DatasetExportJob?

    public init(
        datasetExportJob: PersonalizeClientTypes.DatasetExportJob? = nil
    )
    {
        self.datasetExportJob = datasetExportJob
    }
}

public struct DescribeDatasetGroupInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset group to describe.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

extension PersonalizeClientTypes {

    /// A dataset group is a collection of related datasets (Item interactions, Users, Items, Actions, Action interactions). You create a dataset group by calling [CreateDatasetGroup](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateDatasetGroup.html). You then create a dataset and add it to a dataset group by calling [CreateDataset](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateDataset.html). The dataset group is used to create and train a solution by calling [CreateSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSolution.html). A dataset group can contain only one of each type of dataset. You can specify an Key Management Service (KMS) key to encrypt the datasets in the group.
    public struct DatasetGroup: Swift.Sendable {
        /// The creation date and time (in Unix time) of the dataset group.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// The domain of a Domain dataset group.
        public var domain: PersonalizeClientTypes.Domain?
        /// If creating a dataset group fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key used to encrypt the datasets.
        public var kmsKeyArn: Swift.String?
        /// The last update date and time (in Unix time) of the dataset group.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the dataset group.
        public var name: Swift.String?
        /// The ARN of the Identity and Access Management (IAM) role that has permissions to access the Key Management Service (KMS) key. Supplying an IAM role is only valid when also specifying a KMS key.
        public var roleArn: Swift.String?
        /// The current status of the dataset group. A dataset group can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            failureReason: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.domain = domain
            self.failureReason = failureReason
            self.kmsKeyArn = kmsKeyArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.status = status
        }
    }
}

public struct DescribeDatasetGroupOutput: Swift.Sendable {
    /// A listing of the dataset group's properties.
    public var datasetGroup: PersonalizeClientTypes.DatasetGroup?

    public init(
        datasetGroup: PersonalizeClientTypes.DatasetGroup? = nil
    )
    {
        self.datasetGroup = datasetGroup
    }
}

public struct DescribeDatasetImportJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset import job to describe.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init(
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

extension PersonalizeClientTypes {

    /// Describes a job that imports training data from a data source (Amazon S3 bucket) to an Amazon Personalize dataset. For more information, see [CreateDatasetImportJob](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateDatasetImportJob.html). A dataset import job can be in one of the following states:
    ///
    /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    public struct DatasetImportJob: Swift.Sendable {
        /// The creation date and time (in Unix time) of the dataset import job.
        public var creationDateTime: Foundation.Date?
        /// The Amazon S3 bucket that contains the training data to import.
        public var dataSource: PersonalizeClientTypes.DataSource?
        /// The Amazon Resource Name (ARN) of the dataset that receives the imported data.
        public var datasetArn: Swift.String?
        /// The ARN of the dataset import job.
        public var datasetImportJobArn: Swift.String?
        /// If a dataset import job fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The import mode used by the dataset import job to import new records.
        public var importMode: PersonalizeClientTypes.ImportMode?
        /// The name of the import job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) the dataset was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// Whether the job publishes metrics to Amazon S3 for a metric attribution.
        public var publishAttributionMetricsToS3: Swift.Bool?
        /// The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
        public var roleArn: Swift.String?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            dataSource: PersonalizeClientTypes.DataSource? = nil,
            datasetArn: Swift.String? = nil,
            datasetImportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            importMode: PersonalizeClientTypes.ImportMode? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            publishAttributionMetricsToS3: Swift.Bool? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.dataSource = dataSource
            self.datasetArn = datasetArn
            self.datasetImportJobArn = datasetImportJobArn
            self.failureReason = failureReason
            self.importMode = importMode
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.publishAttributionMetricsToS3 = publishAttributionMetricsToS3
            self.roleArn = roleArn
            self.status = status
        }
    }
}

public struct DescribeDatasetImportJobOutput: Swift.Sendable {
    /// Information about the dataset import job, including the status. The status is one of the following values:
    ///
    /// * CREATE PENDING
    ///
    /// * CREATE IN_PROGRESS
    ///
    /// * ACTIVE
    ///
    /// * CREATE FAILED
    public var datasetImportJob: PersonalizeClientTypes.DatasetImportJob?

    public init(
        datasetImportJob: PersonalizeClientTypes.DatasetImportJob? = nil
    )
    {
        self.datasetImportJob = datasetImportJob
    }
}

public struct DescribeEventTrackerInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the event tracker to describe.
    /// This member is required.
    public var eventTrackerArn: Swift.String?

    public init(
        eventTrackerArn: Swift.String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
    }
}

extension PersonalizeClientTypes {

    /// Provides information about an event tracker.
    public struct EventTracker: Swift.Sendable {
        /// The Amazon Web Services account that owns the event tracker.
        public var accountId: Swift.String?
        /// The date and time (in Unix format) that the event tracker was created.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
        public var datasetGroupArn: Swift.String?
        /// The ARN of the event tracker.
        public var eventTrackerArn: Swift.String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the event tracker.
        public var name: Swift.String?
        /// The status of the event tracker. An event tracker can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?
        /// The ID of the event tracker. Include this ID in requests to the [PutEvents](https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html) API.
        public var trackingId: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            creationDateTime: Foundation.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            eventTrackerArn: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil,
            trackingId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
            self.trackingId = trackingId
        }
    }
}

public struct DescribeEventTrackerOutput: Swift.Sendable {
    /// An object that describes the event tracker.
    public var eventTracker: PersonalizeClientTypes.EventTracker?

    public init(
        eventTracker: PersonalizeClientTypes.EventTracker? = nil
    )
    {
        self.eventTracker = eventTracker
    }
}

public struct DescribeFeatureTransformationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the feature transformation to describe.
    /// This member is required.
    public var featureTransformationArn: Swift.String?

    public init(
        featureTransformationArn: Swift.String? = nil
    )
    {
        self.featureTransformationArn = featureTransformationArn
    }
}

extension PersonalizeClientTypes {

    /// Provides feature transformation information. Feature transformation is the process of modifying raw input data into a form more suitable for model training.
    public struct FeatureTransformation: Swift.Sendable {
        /// The creation date and time (in Unix time) of the feature transformation.
        public var creationDateTime: Foundation.Date?
        /// Provides the default parameters for feature transformation.
        public var defaultParameters: [Swift.String: Swift.String]?
        /// The Amazon Resource Name (ARN) of the FeatureTransformation object.
        public var featureTransformationArn: Swift.String?
        /// The last update date and time (in Unix time) of the feature transformation.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the feature transformation.
        public var name: Swift.String?
        /// The status of the feature transformation. A feature transformation can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            defaultParameters: [Swift.String: Swift.String]? = nil,
            featureTransformationArn: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.defaultParameters = defaultParameters
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }
}

public struct DescribeFeatureTransformationOutput: Swift.Sendable {
    /// A listing of the FeatureTransformation properties.
    public var featureTransformation: PersonalizeClientTypes.FeatureTransformation?

    public init(
        featureTransformation: PersonalizeClientTypes.FeatureTransformation? = nil
    )
    {
        self.featureTransformation = featureTransformation
    }
}

public struct DescribeFilterInput: Swift.Sendable {
    /// The ARN of the filter to describe.
    /// This member is required.
    public var filterArn: Swift.String?

    public init(
        filterArn: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

extension PersonalizeClientTypes {

    /// Contains information on a recommendation filter, including its ARN, status, and filter expression.
    public struct Filter: Swift.Sendable {
        /// The time at which the filter was created.
        public var creationDateTime: Foundation.Date?
        /// The ARN of the dataset group to which the filter belongs.
        public var datasetGroupArn: Swift.String?
        /// If the filter failed, the reason for its failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter.
        public var filterArn: Swift.String?
        /// Specifies the type of item interactions to filter out of recommendation results. The filter expression must follow specific format rules. For information about filter expression structure and syntax, see [Filter expressions](https://docs.aws.amazon.com/personalize/latest/dg/filter-expressions.html).
        public var filterExpression: Swift.String?
        /// The time at which the filter was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the filter.
        public var name: Swift.String?
        /// The status of the filter.
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            filterExpression: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.filterExpression = filterExpression
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }
}

extension PersonalizeClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(creationDateTime: \(Swift.String(describing: creationDateTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), failureReason: \(Swift.String(describing: failureReason)), filterArn: \(Swift.String(describing: filterArn)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), filterExpression: \"CONTENT_REDACTED\")"}
}

public struct DescribeFilterOutput: Swift.Sendable {
    /// The filter's details.
    public var filter: PersonalizeClientTypes.Filter?

    public init(
        filter: PersonalizeClientTypes.Filter? = nil
    )
    {
        self.filter = filter
    }
}

public struct DescribeMetricAttributionInput: Swift.Sendable {
    /// The metric attribution's Amazon Resource Name (ARN).
    /// This member is required.
    public var metricAttributionArn: Swift.String?

    public init(
        metricAttributionArn: Swift.String? = nil
    )
    {
        self.metricAttributionArn = metricAttributionArn
    }
}

extension PersonalizeClientTypes {

    /// Contains information on a metric attribution. A metric attribution creates reports on the data that you import into Amazon Personalize. Depending on how you import the data, you can view reports in Amazon CloudWatch or Amazon S3. For more information, see [Measuring impact of recommendations](https://docs.aws.amazon.com/personalize/latest/dg/measuring-recommendation-impact.html).
    public struct MetricAttribution: Swift.Sendable {
        /// The metric attribution's creation date time.
        public var creationDateTime: Foundation.Date?
        /// The metric attribution's dataset group Amazon Resource Name (ARN).
        public var datasetGroupArn: Swift.String?
        /// The metric attribution's failure reason.
        public var failureReason: Swift.String?
        /// The metric attribution's last updated date time.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The metric attribution's Amazon Resource Name (ARN).
        public var metricAttributionArn: Swift.String?
        /// The metric attribution's output configuration.
        public var metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput?
        /// The metric attribution's name.
        public var name: Swift.String?
        /// The metric attribution's status.
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            metricAttributionArn: Swift.String? = nil,
            metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.metricAttributionArn = metricAttributionArn
            self.metricsOutputConfig = metricsOutputConfig
            self.name = name
            self.status = status
        }
    }
}

public struct DescribeMetricAttributionOutput: Swift.Sendable {
    /// The details of the metric attribution.
    public var metricAttribution: PersonalizeClientTypes.MetricAttribution?

    public init(
        metricAttribution: PersonalizeClientTypes.MetricAttribution? = nil
    )
    {
        self.metricAttribution = metricAttribution
    }
}

public struct DescribeRecipeInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the recipe to describe.
    /// This member is required.
    public var recipeArn: Swift.String?

    public init(
        recipeArn: Swift.String? = nil
    )
    {
        self.recipeArn = recipeArn
    }
}

extension PersonalizeClientTypes {

    /// Provides information about a recipe. Each recipe provides an algorithm that Amazon Personalize uses in model training when you use the [CreateSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSolution.html) operation.
    public struct Recipe: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the algorithm that Amazon Personalize uses to train the model.
        public var algorithmArn: Swift.String?
        /// The date and time (in Unix format) that the recipe was created.
        public var creationDateTime: Foundation.Date?
        /// The description of the recipe.
        public var description: Swift.String?
        /// The ARN of the FeatureTransformation object.
        public var featureTransformationArn: Swift.String?
        /// The date and time (in Unix format) that the recipe was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the recipe.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public var recipeArn: Swift.String?
        /// One of the following values:
        ///
        /// * PERSONALIZED_RANKING
        ///
        /// * RELATED_ITEMS
        ///
        /// * USER_PERSONALIZATION
        public var recipeType: Swift.String?
        /// The status of the recipe.
        public var status: Swift.String?

        public init(
            algorithmArn: Swift.String? = nil,
            creationDateTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            featureTransformationArn: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            recipeType: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.creationDateTime = creationDateTime
            self.description = description
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.recipeType = recipeType
            self.status = status
        }
    }
}

public struct DescribeRecipeOutput: Swift.Sendable {
    /// An object that describes the recipe.
    public var recipe: PersonalizeClientTypes.Recipe?

    public init(
        recipe: PersonalizeClientTypes.Recipe? = nil
    )
    {
        self.recipe = recipe
    }
}

public struct DescribeRecommenderInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the recommender to describe.
    /// This member is required.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a recommender update. For a complete listing, call the [DescribeRecommender](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeRecommender.html) API.
    public struct RecommenderUpdateSummary: Swift.Sendable {
        /// The date and time (in Unix format) that the recommender update was created.
        public var creationDateTime: Foundation.Date?
        /// If a recommender update fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the recommender update was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The configuration details of the recommender update.
        public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
        /// The status of the recommender update. A recommender update can be in one of the following states: CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.recommenderConfig = recommenderConfig
            self.status = status
        }
    }
}

extension PersonalizeClientTypes {

    /// Describes a recommendation generator for a Domain dataset group. You create a recommender in a Domain dataset group for a specific domain use case (domain recipe), and specify the recommender in a [GetRecommendations](https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html) request.
    public struct Recommender: Swift.Sendable {
        /// The date and time (in Unix format) that the recommender was created.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the Domain dataset group that contains the recommender.
        public var datasetGroupArn: Swift.String?
        /// If a recommender fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix format) that the recommender was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// Provides a summary of the latest updates to the recommender.
        public var latestRecommenderUpdate: PersonalizeClientTypes.RecommenderUpdateSummary?
        /// Provides evaluation metrics that help you determine the performance of a recommender. For more information, see [ Evaluating a recommender](https://docs.aws.amazon.com/personalize/latest/dg/evaluating-recommenders.html).
        public var modelMetrics: [Swift.String: Swift.Double]?
        /// The name of the recommender.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe (Domain dataset group use case) that the recommender was created for.
        public var recipeArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the recommender.
        public var recommenderArn: Swift.String?
        /// The configuration details of the recommender.
        public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
        /// The status of the recommender. A recommender can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * STOP PENDING > STOP IN_PROGRESS > INACTIVE > START PENDING > START IN_PROGRESS > ACTIVE
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            latestRecommenderUpdate: PersonalizeClientTypes.RecommenderUpdateSummary? = nil,
            modelMetrics: [Swift.String: Swift.Double]? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            recommenderArn: Swift.String? = nil,
            recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestRecommenderUpdate = latestRecommenderUpdate
            self.modelMetrics = modelMetrics
            self.name = name
            self.recipeArn = recipeArn
            self.recommenderArn = recommenderArn
            self.recommenderConfig = recommenderConfig
            self.status = status
        }
    }
}

public struct DescribeRecommenderOutput: Swift.Sendable {
    /// The properties of the recommender.
    public var recommender: PersonalizeClientTypes.Recommender?

    public init(
        recommender: PersonalizeClientTypes.Recommender? = nil
    )
    {
        self.recommender = recommender
    }
}

public struct DescribeSchemaInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the schema to retrieve.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

extension PersonalizeClientTypes {

    /// Describes the schema for a dataset. For more information on schemas, see [CreateSchema](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSchema.html).
    public struct DatasetSchema: Swift.Sendable {
        /// The date and time (in Unix time) that the schema was created.
        public var creationDateTime: Foundation.Date?
        /// The domain of a schema that you created for a dataset in a Domain dataset group.
        public var domain: PersonalizeClientTypes.Domain?
        /// The date and time (in Unix time) that the schema was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the schema.
        public var name: Swift.String?
        /// The schema.
        public var schema: Swift.String?
        /// The Amazon Resource Name (ARN) of the schema.
        public var schemaArn: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.domain = domain
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schema = schema
            self.schemaArn = schemaArn
        }
    }
}

public struct DescribeSchemaOutput: Swift.Sendable {
    /// The requested schema.
    public var schema: PersonalizeClientTypes.DatasetSchema?

    public init(
        schema: PersonalizeClientTypes.DatasetSchema? = nil
    )
    {
        self.schema = schema
    }
}

public struct DescribeSolutionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the solution to describe.
    /// This member is required.
    public var solutionArn: Swift.String?

    public init(
        solutionArn: Swift.String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

extension PersonalizeClientTypes {

    /// When the solution performs AutoML (performAutoML is true in [CreateSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_CreateSolution.html)), specifies the recipe that best optimized the specified metric.
    public struct AutoMLResult: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the best recipe.
        public var bestRecipeArn: Swift.String?

        public init(
            bestRecipeArn: Swift.String? = nil
        )
        {
            self.bestRecipeArn = bestRecipeArn
        }
    }
}

extension PersonalizeClientTypes {

    /// The configuration details of the solution update.
    public struct SolutionUpdateConfig: Swift.Sendable {
        /// The automatic training configuration to use when performAutoTraining is true.
        public var autoTrainingConfig: PersonalizeClientTypes.AutoTrainingConfig?

        public init(
            autoTrainingConfig: PersonalizeClientTypes.AutoTrainingConfig? = nil
        )
        {
            self.autoTrainingConfig = autoTrainingConfig
        }
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a solution update. For a complete listing, call the [DescribeSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeSolution.html) API.
    public struct SolutionUpdateSummary: Swift.Sendable {
        /// The date and time (in Unix format) that the solution update was created.
        public var creationDateTime: Foundation.Date?
        /// If a solution update fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the solution update was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// Whether the solution automatically creates solution versions.
        public var performAutoTraining: Swift.Bool?
        /// The configuration details of the solution.
        public var solutionUpdateConfig: PersonalizeClientTypes.SolutionUpdateConfig?
        /// The status of the solution update. A solution update can be in one of the following states: CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            performAutoTraining: Swift.Bool? = nil,
            solutionUpdateConfig: PersonalizeClientTypes.SolutionUpdateConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.performAutoTraining = performAutoTraining
            self.solutionUpdateConfig = solutionUpdateConfig
            self.status = status
        }
    }
}

extension PersonalizeClientTypes {

    public enum TrainingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automatic
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [TrainingType] {
            return [
                .automatic,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a solution version. For a complete listing, call the [DescribeSolutionVersion](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeSolutionVersion.html) API.
    public struct SolutionVersionSummary: Swift.Sendable {
        /// The date and time (in Unix time) that this version of a solution was created.
        public var creationDateTime: Foundation.Date?
        /// If a solution version fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the solution version was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the solution version.
        public var solutionVersionArn: Swift.String?
        /// The status of the solution version. A solution version can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?
        /// The scope of training to be performed when creating the solution version. A FULL training considers all of the data in your dataset group. An UPDATE processes only the data that has changed since the latest training. Only solution versions created with the User-Personalization recipe can use UPDATE.
        public var trainingMode: PersonalizeClientTypes.TrainingMode?
        /// Whether the solution version was created automatically or manually.
        public var trainingType: PersonalizeClientTypes.TrainingType?

        public init(
            creationDateTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil,
            trainingMode: PersonalizeClientTypes.TrainingMode? = nil,
            trainingType: PersonalizeClientTypes.TrainingType? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
            self.trainingMode = trainingMode
            self.trainingType = trainingType
        }
    }
}

extension PersonalizeClientTypes {

    /// By default, all new solutions use automatic training. With automatic training, you incur training costs while your solution is active. To avoid unnecessary costs, when you are finished you can [update the solution](https://docs.aws.amazon.com/personalize/latest/dg/API_UpdateSolution.html) to turn off automatic training. For information about training costs, see [Amazon Personalize pricing](https://aws.amazon.com/personalize/pricing/). An object that provides information about a solution. A solution includes the custom recipe, customized parameters, and trained models (Solution Versions) that Amazon Personalize uses to generate recommendations. After you create a solution, you can’t change its configuration. If you need to make changes, you can [clone the solution](https://docs.aws.amazon.com/personalize/latest/dg/cloning-solution.html) with the Amazon Personalize console or create a new one.
    public struct Solution: Swift.Sendable {
        /// When performAutoML is true, specifies the best recipe found.
        public var autoMLResult: PersonalizeClientTypes.AutoMLResult?
        /// The creation date and time (in Unix time) of the solution.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
        public var datasetGroupArn: Swift.String?
        /// The event type (for example, 'click' or 'like') that is used for training the model. If no eventType is provided, Amazon Personalize uses all interactions for training with equal weight regardless of type.
        public var eventType: Swift.String?
        /// The date and time (in Unix time) that the solution was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// Provides a summary of the latest updates to the solution.
        public var latestSolutionUpdate: PersonalizeClientTypes.SolutionUpdateSummary?
        /// Describes the latest version of the solution, including the status and the ARN.
        public var latestSolutionVersion: PersonalizeClientTypes.SolutionVersionSummary?
        /// The name of the solution.
        public var name: Swift.String?
        /// We don't recommend enabling automated machine learning. Instead, match your use case to the available Amazon Personalize recipes. For more information, see [Determining your use case.](https://docs.aws.amazon.com/personalize/latest/dg/determining-use-case.html) When true, Amazon Personalize performs a search for the best USER_PERSONALIZATION recipe from the list specified in the solution configuration (recipeArn must not be specified). When false (the default), Amazon Personalize uses recipeArn for training.
        public var performAutoML: Swift.Bool
        /// Specifies whether the solution automatically creates solution versions. The default is True and the solution automatically creates new solution versions every 7 days. For more information about auto training, see [Creating and configuring a solution](https://docs.aws.amazon.com/personalize/latest/dg/customizing-solution-config.html).
        public var performAutoTraining: Swift.Bool?
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public var performHPO: Swift.Bool
        /// The ARN of the recipe used to create the solution. This is required when performAutoML is false.
        public var recipeArn: Swift.String?
        /// The ARN of the solution.
        public var solutionArn: Swift.String?
        /// Describes the configuration properties for the solution.
        public var solutionConfig: PersonalizeClientTypes.SolutionConfig?
        /// The status of the solution. A solution can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            autoMLResult: PersonalizeClientTypes.AutoMLResult? = nil,
            creationDateTime: Foundation.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            eventType: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            latestSolutionUpdate: PersonalizeClientTypes.SolutionUpdateSummary? = nil,
            latestSolutionVersion: PersonalizeClientTypes.SolutionVersionSummary? = nil,
            name: Swift.String? = nil,
            performAutoML: Swift.Bool = false,
            performAutoTraining: Swift.Bool? = nil,
            performHPO: Swift.Bool = false,
            recipeArn: Swift.String? = nil,
            solutionArn: Swift.String? = nil,
            solutionConfig: PersonalizeClientTypes.SolutionConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.autoMLResult = autoMLResult
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestSolutionUpdate = latestSolutionUpdate
            self.latestSolutionVersion = latestSolutionVersion
            self.name = name
            self.performAutoML = performAutoML
            self.performAutoTraining = performAutoTraining
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.status = status
        }
    }
}

public struct DescribeSolutionOutput: Swift.Sendable {
    /// An object that describes the solution.
    public var solution: PersonalizeClientTypes.Solution?

    public init(
        solution: PersonalizeClientTypes.Solution? = nil
    )
    {
        self.solution = solution
    }
}

public struct DescribeSolutionVersionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the solution version.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init(
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

extension PersonalizeClientTypes {

    /// If hyperparameter optimization (HPO) was performed, contains the hyperparameter values of the best performing model.
    public struct TunedHPOParams: Swift.Sendable {
        /// A list of the hyperparameter values of the best performing model.
        public var algorithmHyperParameters: [Swift.String: Swift.String]?

        public init(
            algorithmHyperParameters: [Swift.String: Swift.String]? = nil
        )
        {
            self.algorithmHyperParameters = algorithmHyperParameters
        }
    }
}

extension PersonalizeClientTypes {

    /// An object that provides information about a specific version of a [Solution](https://docs.aws.amazon.com/personalize/latest/dg/API_Solution.html) in a Custom dataset group.
    public struct SolutionVersion: Swift.Sendable {
        /// The date and time (in Unix time) that this version of the solution was created.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset group providing the training data.
        public var datasetGroupArn: Swift.String?
        /// The event type (for example, 'click' or 'like') that is used for training the model.
        public var eventType: Swift.String?
        /// If training a solution version fails, the reason for the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the solution was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the solution version.
        public var name: Swift.String?
        /// When true, Amazon Personalize searches for the most optimal recipe according to the solution configuration. When false (the default), Amazon Personalize uses recipeArn.
        public var performAutoML: Swift.Bool
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public var performHPO: Swift.Bool
        /// The ARN of the recipe used in the solution.
        public var recipeArn: Swift.String?
        /// The ARN of the solution.
        public var solutionArn: Swift.String?
        /// Describes the configuration properties for the solution.
        public var solutionConfig: PersonalizeClientTypes.SolutionConfig?
        /// The ARN of the solution version.
        public var solutionVersionArn: Swift.String?
        /// The status of the solution version. A solution version can be in one of the following states:
        ///
        /// * CREATE PENDING
        ///
        /// * CREATE IN_PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        ///
        /// * CREATE STOPPING
        ///
        /// * CREATE STOPPED
        public var status: Swift.String?
        /// The time used to train the model. You are billed for the time it takes to train a model. This field is visible only after Amazon Personalize successfully trains a model.
        public var trainingHours: Swift.Double?
        /// The scope of training to be performed when creating the solution version. A FULL training considers all of the data in your dataset group. An UPDATE processes only the data that has changed since the latest training. Only solution versions created with the User-Personalization recipe can use UPDATE.
        public var trainingMode: PersonalizeClientTypes.TrainingMode?
        /// Whether the solution version was created automatically or manually.
        public var trainingType: PersonalizeClientTypes.TrainingType?
        /// If hyperparameter optimization was performed, contains the hyperparameter values of the best performing model.
        public var tunedHPOParams: PersonalizeClientTypes.TunedHPOParams?

        public init(
            creationDateTime: Foundation.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            eventType: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            performAutoML: Swift.Bool = false,
            performHPO: Swift.Bool = false,
            recipeArn: Swift.String? = nil,
            solutionArn: Swift.String? = nil,
            solutionConfig: PersonalizeClientTypes.SolutionConfig? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil,
            trainingHours: Swift.Double? = nil,
            trainingMode: PersonalizeClientTypes.TrainingMode? = nil,
            trainingType: PersonalizeClientTypes.TrainingType? = nil,
            tunedHPOParams: PersonalizeClientTypes.TunedHPOParams? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.solutionVersionArn = solutionVersionArn
            self.status = status
            self.trainingHours = trainingHours
            self.trainingMode = trainingMode
            self.trainingType = trainingType
            self.tunedHPOParams = tunedHPOParams
        }
    }
}

public struct DescribeSolutionVersionOutput: Swift.Sendable {
    /// The solution version.
    public var solutionVersion: PersonalizeClientTypes.SolutionVersion?

    public init(
        solutionVersion: PersonalizeClientTypes.SolutionVersion? = nil
    )
    {
        self.solutionVersion = solutionVersion
    }
}

public struct GetSolutionMetricsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the solution version for which to get metrics.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init(
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

public struct GetSolutionMetricsOutput: Swift.Sendable {
    /// The metrics for the solution version. For more information, see [ Evaluating a solution version with metrics ](https://docs.aws.amazon.com/personalize/latest/dg/working-with-training-metrics.html).
    public var metrics: [Swift.String: Swift.Double]?
    /// The same solution version ARN as specified in the request.
    public var solutionVersionArn: Swift.String?

    public init(
        metrics: [Swift.String: Swift.Double]? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.metrics = metrics
        self.solutionVersionArn = solutionVersionArn
    }
}

/// The token is not valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListBatchInferenceJobsInput: Swift.Sendable {
    /// The maximum number of batch inference job results to return in each page. The default value is 100.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version from which the batch inference jobs were created.
    public var solutionVersionArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionVersionArn = solutionVersionArn
    }
}

extension PersonalizeClientTypes {

    /// A truncated version of the [BatchInferenceJob](https://docs.aws.amazon.com/personalize/latest/dg/API_BatchInferenceJob.html). The [ListBatchInferenceJobs](https://docs.aws.amazon.com/personalize/latest/dg/API_ListBatchInferenceJobs.html) operation returns a list of batch inference job summaries.
    public struct BatchInferenceJobSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public var batchInferenceJobArn: Swift.String?
        /// The job's mode.
        public var batchInferenceJobMode: PersonalizeClientTypes.BatchInferenceJobMode?
        /// The time at which the batch inference job was created.
        public var creationDateTime: Foundation.Date?
        /// If the batch inference job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The name of the batch inference job.
        public var jobName: Swift.String?
        /// The time at which the batch inference job was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The ARN of the solution version used by the batch inference job.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch inference job. The status is one of the following values:
        ///
        /// * PENDING
        ///
        /// * IN PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        public var status: Swift.String?

        public init(
            batchInferenceJobArn: Swift.String? = nil,
            batchInferenceJobMode: PersonalizeClientTypes.BatchInferenceJobMode? = nil,
            creationDateTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.batchInferenceJobMode = batchInferenceJobMode
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }
}

public struct ListBatchInferenceJobsOutput: Swift.Sendable {
    /// A list containing information on each job that is returned.
    public var batchInferenceJobs: [PersonalizeClientTypes.BatchInferenceJobSummary]?
    /// The token to use to retrieve the next page of results. The value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        batchInferenceJobs: [PersonalizeClientTypes.BatchInferenceJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchInferenceJobs = batchInferenceJobs
        self.nextToken = nextToken
    }
}

public struct ListBatchSegmentJobsInput: Swift.Sendable {
    /// The maximum number of batch segment job results to return in each page. The default value is 100.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version that the batch segment jobs used to generate batch segments.
    public var solutionVersionArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionVersionArn = solutionVersionArn
    }
}

extension PersonalizeClientTypes {

    /// A truncated version of the [BatchSegmentJob](https://docs.aws.amazon.com/personalize/latest/dg/API_BatchSegmentJob.html) datatype. [ListBatchSegmentJobs](https://docs.aws.amazon.com/personalize/latest/dg/API_ListBatchSegmentJobs.html) operation returns a list of batch segment job summaries.
    public struct BatchSegmentJobSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the batch segment job.
        public var batchSegmentJobArn: Swift.String?
        /// The time at which the batch segment job was created.
        public var creationDateTime: Foundation.Date?
        /// If the batch segment job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The name of the batch segment job.
        public var jobName: Swift.String?
        /// The time at which the batch segment job was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the solution version used by the batch segment job to generate batch segments.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch segment job. The status is one of the following values:
        ///
        /// * PENDING
        ///
        /// * IN PROGRESS
        ///
        /// * ACTIVE
        ///
        /// * CREATE FAILED
        public var status: Swift.String?

        public init(
            batchSegmentJobArn: Swift.String? = nil,
            creationDateTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.batchSegmentJobArn = batchSegmentJobArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }
}

public struct ListBatchSegmentJobsOutput: Swift.Sendable {
    /// A list containing information on each job that is returned.
    public var batchSegmentJobs: [PersonalizeClientTypes.BatchSegmentJobSummary]?
    /// The token to use to retrieve the next page of results. The value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        batchSegmentJobs: [PersonalizeClientTypes.BatchSegmentJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchSegmentJobs = batchSegmentJobs
        self.nextToken = nextToken
    }
}

public struct ListCampaignsInput: Swift.Sendable {
    /// The maximum number of campaigns to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to [ListCampaigns](https://docs.aws.amazon.com/personalize/latest/dg/API_ListCampaigns.html) for getting the next set of campaigns (if they exist).
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution to list the campaigns for. When a solution is not specified, all the campaigns associated with the account are listed.
    public var solutionArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionArn = solutionArn
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a campaign. For a complete listing, call the [DescribeCampaign](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeCampaign.html) API.
    public struct CampaignSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the campaign.
        public var campaignArn: Swift.String?
        /// The date and time (in Unix time) that the campaign was created.
        public var creationDateTime: Foundation.Date?
        /// If a campaign fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the campaign was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the campaign.
        public var name: Swift.String?
        /// The status of the campaign. A campaign can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            campaignArn: Swift.String? = nil,
            creationDateTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.campaignArn = campaignArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }
}

public struct ListCampaignsOutput: Swift.Sendable {
    /// A list of the campaigns.
    public var campaigns: [PersonalizeClientTypes.CampaignSummary]?
    /// A token for getting the next set of campaigns (if they exist).
    public var nextToken: Swift.String?

    public init(
        campaigns: [PersonalizeClientTypes.CampaignSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.campaigns = campaigns
        self.nextToken = nextToken
    }
}

public struct ListDataDeletionJobsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset group to list data deletion jobs for.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of data deletion jobs to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDataDeletionJobs for getting the next set of jobs (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a data deletion job. For a complete listing, call the [DescribeDataDeletionJob](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeDataDeletionJob.html) API operation.
    public struct DataDeletionJobSummary: Swift.Sendable {
        /// The creation date and time (in Unix time) of the data deletion job.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the data deletion job.
        public var dataDeletionJobArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the dataset group the job deleted records from.
        public var datasetGroupArn: Swift.String?
        /// If a data deletion job fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The name of the data deletion job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) the data deletion job was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The status of the data deletion job. A data deletion job can have one of the following statuses:
        ///
        /// * PENDING > IN_PROGRESS > COMPLETED -or- FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            dataDeletionJobArn: Swift.String? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.dataDeletionJobArn = dataDeletionJobArn
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }
    }
}

public struct ListDataDeletionJobsOutput: Swift.Sendable {
    /// The list of data deletion jobs.
    public var dataDeletionJobs: [PersonalizeClientTypes.DataDeletionJobSummary]?
    /// A token for getting the next set of data deletion jobs (if they exist).
    public var nextToken: Swift.String?

    public init(
        dataDeletionJobs: [PersonalizeClientTypes.DataDeletionJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataDeletionJobs = dataDeletionJobs
        self.nextToken = nextToken
    }
}

public struct ListDatasetExportJobsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset to list the dataset export jobs for.
    public var datasetArn: Swift.String?
    /// The maximum number of dataset export jobs to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetExportJobs for getting the next set of dataset export jobs (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a dataset export job. For a complete listing, call the [DescribeDatasetExportJob](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeDatasetExportJob.html) API.
    public struct DatasetExportJobSummary: Swift.Sendable {
        /// The date and time (in Unix time) that the dataset export job was created.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public var datasetExportJobArn: Swift.String?
        /// If a dataset export job fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The name of the dataset export job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) that the dataset export job status was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The status of the dataset export job. A dataset export job can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            datasetExportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetExportJobArn = datasetExportJobArn
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }
    }
}

public struct ListDatasetExportJobsOutput: Swift.Sendable {
    /// The list of dataset export jobs.
    public var datasetExportJobs: [PersonalizeClientTypes.DatasetExportJobSummary]?
    /// A token for getting the next set of dataset export jobs (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetExportJobs: [PersonalizeClientTypes.DatasetExportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetExportJobs = datasetExportJobs
        self.nextToken = nextToken
    }
}

public struct ListDatasetGroupsInput: Swift.Sendable {
    /// The maximum number of dataset groups to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetGroups for getting the next set of dataset groups (if they exist).
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a dataset group. For a complete listing, call the [DescribeDatasetGroup](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeDatasetGroup.html) API.
    public struct DatasetGroupSummary: Swift.Sendable {
        /// The date and time (in Unix time) that the dataset group was created.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// The domain of a Domain dataset group.
        public var domain: PersonalizeClientTypes.Domain?
        /// If creating a dataset group fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the dataset group was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the dataset group.
        public var name: Swift.String?
        /// The status of the dataset group. A dataset group can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.domain = domain
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }
}

public struct ListDatasetGroupsOutput: Swift.Sendable {
    /// The list of your dataset groups.
    public var datasetGroups: [PersonalizeClientTypes.DatasetGroupSummary]?
    /// A token for getting the next set of dataset groups (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetGroups: [PersonalizeClientTypes.DatasetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroups = datasetGroups
        self.nextToken = nextToken
    }
}

public struct ListDatasetImportJobsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset to list the dataset import jobs for.
    public var datasetArn: Swift.String?
    /// The maximum number of dataset import jobs to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetImportJobs for getting the next set of dataset import jobs (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a dataset import job. For a complete listing, call the [DescribeDatasetImportJob](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeDatasetImportJob.html) API.
    public struct DatasetImportJobSummary: Swift.Sendable {
        /// The date and time (in Unix time) that the dataset import job was created.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public var datasetImportJobArn: Swift.String?
        /// If a dataset import job fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The import mode the dataset import job used to update the data in the dataset. For more information see [Updating existing bulk data](https://docs.aws.amazon.com/personalize/latest/dg/updating-existing-bulk-data.html).
        public var importMode: PersonalizeClientTypes.ImportMode?
        /// The name of the dataset import job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) that the dataset import job status was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            datasetImportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            importMode: PersonalizeClientTypes.ImportMode? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetImportJobArn = datasetImportJobArn
            self.failureReason = failureReason
            self.importMode = importMode
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }
    }
}

public struct ListDatasetImportJobsOutput: Swift.Sendable {
    /// The list of dataset import jobs.
    public var datasetImportJobs: [PersonalizeClientTypes.DatasetImportJobSummary]?
    /// A token for getting the next set of dataset import jobs (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetImportJobs: [PersonalizeClientTypes.DatasetImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetImportJobs = datasetImportJobs
        self.nextToken = nextToken
    }
}

public struct ListDatasetsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset group that contains the datasets to list.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of datasets to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasets for getting the next set of dataset import jobs (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a dataset. For a complete listing, call the [DescribeDataset](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeDataset.html) API.
    public struct DatasetSummary: Swift.Sendable {
        /// The date and time (in Unix time) that the dataset was created.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the dataset.
        public var datasetArn: Swift.String?
        /// The dataset type. One of the following values:
        ///
        /// * Interactions
        ///
        /// * Items
        ///
        /// * Users
        ///
        /// * Event-Interactions
        public var datasetType: Swift.String?
        /// The date and time (in Unix time) that the dataset was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the dataset.
        public var name: Swift.String?
        /// The status of the dataset. A dataset can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetType: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }
}

public struct ListDatasetsOutput: Swift.Sendable {
    /// An array of Dataset objects. Each object provides metadata information.
    public var datasets: [PersonalizeClientTypes.DatasetSummary]?
    /// A token for getting the next set of datasets (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasets: [PersonalizeClientTypes.DatasetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

public struct ListEventTrackersInput: Swift.Sendable {
    /// The ARN of a dataset group used to filter the response.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of event trackers to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListEventTrackers for getting the next set of event trackers (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of an event tracker. For a complete listing, call the [DescribeEventTracker](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeEventTracker.html) API.
    public struct EventTrackerSummary: Swift.Sendable {
        /// The date and time (in Unix time) that the event tracker was created.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the event tracker.
        public var eventTrackerArn: Swift.String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the event tracker.
        public var name: Swift.String?
        /// The status of the event tracker. An event tracker can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            eventTrackerArn: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }
}

public struct ListEventTrackersOutput: Swift.Sendable {
    /// A list of event trackers.
    public var eventTrackers: [PersonalizeClientTypes.EventTrackerSummary]?
    /// A token for getting the next set of event trackers (if they exist).
    public var nextToken: Swift.String?

    public init(
        eventTrackers: [PersonalizeClientTypes.EventTrackerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventTrackers = eventTrackers
        self.nextToken = nextToken
    }
}

public struct ListFiltersInput: Swift.Sendable {
    /// The ARN of the dataset group that contains the filters.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of filters to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListFilters for getting the next set of filters (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PersonalizeClientTypes {

    /// A short summary of a filter's attributes.
    public struct FilterSummary: Swift.Sendable {
        /// The time at which the filter was created.
        public var creationDateTime: Foundation.Date?
        /// The ARN of the dataset group to which the filter belongs.
        public var datasetGroupArn: Swift.String?
        /// If the filter failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter.
        public var filterArn: Swift.String?
        /// The time at which the filter was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the filter.
        public var name: Swift.String?
        /// The status of the filter.
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }
}

public struct ListFiltersOutput: Swift.Sendable {
    /// A list of returned filters.
    public var filters: [PersonalizeClientTypes.FilterSummary]?
    /// A token for getting the next set of filters (if they exist).
    public var nextToken: Swift.String?

    public init(
        filters: [PersonalizeClientTypes.FilterSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.nextToken = nextToken
    }
}

public struct ListMetricAttributionMetricsInput: Swift.Sendable {
    /// The maximum number of metrics to return in one page of results.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the metric attribution to retrieve attributes for.
    public var metricAttributionArn: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        metricAttributionArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.metricAttributionArn = metricAttributionArn
        self.nextToken = nextToken
    }
}

public struct ListMetricAttributionMetricsOutput: Swift.Sendable {
    /// The metrics for the specified metric attribution.
    public var metrics: [PersonalizeClientTypes.MetricAttribute]?
    /// Specify the pagination token from a previous ListMetricAttributionMetricsResponse request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        metrics: [PersonalizeClientTypes.MetricAttribute]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metrics = metrics
        self.nextToken = nextToken
    }
}

public struct ListMetricAttributionsInput: Swift.Sendable {
    /// The metric attributions' dataset group Amazon Resource Name (ARN).
    public var datasetGroupArn: Swift.String?
    /// The maximum number of metric attributions to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a metric attribution. For a complete listing, call the [DescribeMetricAttribution](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeMetricAttribution.html).
    public struct MetricAttributionSummary: Swift.Sendable {
        /// The metric attribution's creation date time.
        public var creationDateTime: Foundation.Date?
        /// The metric attribution's failure reason.
        public var failureReason: Swift.String?
        /// The metric attribution's last updated date time.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The metric attribution's Amazon Resource Name (ARN).
        public var metricAttributionArn: Swift.String?
        /// The name of the metric attribution.
        public var name: Swift.String?
        /// The metric attribution's status.
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            metricAttributionArn: Swift.String? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.metricAttributionArn = metricAttributionArn
            self.name = name
            self.status = status
        }
    }
}

public struct ListMetricAttributionsOutput: Swift.Sendable {
    /// The list of metric attributions.
    public var metricAttributions: [PersonalizeClientTypes.MetricAttributionSummary]?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        metricAttributions: [PersonalizeClientTypes.MetricAttributionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricAttributions = metricAttributions
        self.nextToken = nextToken
    }
}

extension PersonalizeClientTypes {

    public enum RecipeProvider: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [RecipeProvider] {
            return [
                .service
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListRecipesInput: Swift.Sendable {
    /// Filters returned recipes by domain for a Domain dataset group. Only recipes (Domain dataset group use cases) for this domain are included in the response. If you don't specify a domain, all recipes are returned.
    public var domain: PersonalizeClientTypes.Domain?
    /// The maximum number of recipes to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListRecipes for getting the next set of recipes (if they exist).
    public var nextToken: Swift.String?
    /// The default is SERVICE.
    public var recipeProvider: PersonalizeClientTypes.RecipeProvider?

    public init(
        domain: PersonalizeClientTypes.Domain? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recipeProvider: PersonalizeClientTypes.RecipeProvider? = nil
    )
    {
        self.domain = domain
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recipeProvider = recipeProvider
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a recipe. For a complete listing, call the [DescribeRecipe](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeRecipe.html) API.
    public struct RecipeSummary: Swift.Sendable {
        /// The date and time (in Unix time) that the recipe was created.
        public var creationDateTime: Foundation.Date?
        /// The domain of the recipe (if the recipe is a Domain dataset group use case).
        public var domain: PersonalizeClientTypes.Domain?
        /// The date and time (in Unix time) that the recipe was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the recipe.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public var recipeArn: Swift.String?
        /// The status of the recipe.
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.domain = domain
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.status = status
        }
    }
}

public struct ListRecipesOutput: Swift.Sendable {
    /// A token for getting the next set of recipes.
    public var nextToken: Swift.String?
    /// The list of available recipes.
    public var recipes: [PersonalizeClientTypes.RecipeSummary]?

    public init(
        nextToken: Swift.String? = nil,
        recipes: [PersonalizeClientTypes.RecipeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recipes = recipes
    }
}

public struct ListRecommendersInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Domain dataset group to list the recommenders for. When a Domain dataset group is not specified, all the recommenders associated with the account are listed.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of recommenders to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListRecommenders for getting the next set of recommenders (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of the recommender.
    public struct RecommenderSummary: Swift.Sendable {
        /// The date and time (in Unix format) that the recommender was created.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the Domain dataset group that contains the recommender.
        public var datasetGroupArn: Swift.String?
        /// The date and time (in Unix format) that the recommender was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the recommender.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe (Domain dataset group use case) that the recommender was created for.
        public var recipeArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the recommender.
        public var recommenderArn: Swift.String?
        /// The configuration details of the recommender.
        public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?
        /// The status of the recommender. A recommender can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * STOP PENDING > STOP IN_PROGRESS > INACTIVE > START PENDING > START IN_PROGRESS > ACTIVE
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            recommenderArn: Swift.String? = nil,
            recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.recommenderArn = recommenderArn
            self.recommenderConfig = recommenderConfig
            self.status = status
        }
    }
}

public struct ListRecommendersOutput: Swift.Sendable {
    /// A token for getting the next set of recommenders (if they exist).
    public var nextToken: Swift.String?
    /// A list of the recommenders.
    public var recommenders: [PersonalizeClientTypes.RecommenderSummary]?

    public init(
        nextToken: Swift.String? = nil,
        recommenders: [PersonalizeClientTypes.RecommenderSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommenders = recommenders
    }
}

public struct ListSchemasInput: Swift.Sendable {
    /// The maximum number of schemas to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListSchemas for getting the next set of schemas (if they exist).
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a dataset schema. For a complete listing, call the [DescribeSchema](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeSchema.html) API.
    public struct DatasetSchemaSummary: Swift.Sendable {
        /// The date and time (in Unix time) that the schema was created.
        public var creationDateTime: Foundation.Date?
        /// The domain of a schema that you created for a dataset in a Domain dataset group.
        public var domain: PersonalizeClientTypes.Domain?
        /// The date and time (in Unix time) that the schema was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the schema.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the schema.
        public var schemaArn: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            domain: PersonalizeClientTypes.Domain? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.domain = domain
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schemaArn = schemaArn
        }
    }
}

public struct ListSchemasOutput: Swift.Sendable {
    /// A token used to get the next set of schemas (if they exist).
    public var nextToken: Swift.String?
    /// A list of schemas.
    public var schemas: [PersonalizeClientTypes.DatasetSchemaSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemas: [PersonalizeClientTypes.DatasetSchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

public struct ListSolutionsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset group.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of solutions to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListSolutions for getting the next set of solutions (if they exist).
    public var nextToken: Swift.String?

    public init(
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PersonalizeClientTypes {

    /// Provides a summary of the properties of a solution. For a complete listing, call the [DescribeSolution](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeSolution.html) API.
    public struct SolutionSummary: Swift.Sendable {
        /// The date and time (in Unix time) that the solution was created.
        public var creationDateTime: Foundation.Date?
        /// The date and time (in Unix time) that the solution was last updated.
        public var lastUpdatedDateTime: Foundation.Date?
        /// The name of the solution.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe used by the solution.
        public var recipeArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the solution.
        public var solutionArn: Swift.String?
        /// The status of the solution. A solution can be in one of the following states:
        ///
        /// * CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        /// * DELETE PENDING > DELETE IN_PROGRESS
        public var status: Swift.String?

        public init(
            creationDateTime: Foundation.Date? = nil,
            lastUpdatedDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            solutionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.status = status
        }
    }
}

public struct ListSolutionsOutput: Swift.Sendable {
    /// A token for getting the next set of solutions (if they exist).
    public var nextToken: Swift.String?
    /// A list of the current solutions.
    public var solutions: [PersonalizeClientTypes.SolutionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        solutions: [PersonalizeClientTypes.SolutionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.solutions = solutions
    }
}

public struct ListSolutionVersionsInput: Swift.Sendable {
    /// The maximum number of solution versions to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListSolutionVersions for getting the next set of solution versions (if they exist).
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution.
    public var solutionArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionArn = solutionArn
    }
}

public struct ListSolutionVersionsOutput: Swift.Sendable {
    /// A token for getting the next set of solution versions (if they exist).
    public var nextToken: Swift.String?
    /// A list of solution versions describing the version properties.
    public var solutionVersions: [PersonalizeClientTypes.SolutionVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        solutionVersions: [PersonalizeClientTypes.SolutionVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.solutionVersions = solutionVersions
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The resource's tags.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct StartRecommenderInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the recommender to start.
    /// This member is required.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

public struct StartRecommenderOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the recommender you started.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

public struct StopRecommenderInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the recommender to stop.
    /// This member is required.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

public struct StopRecommenderOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the recommender you stopped.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

public struct StopSolutionVersionCreationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the solution version you want to stop creating.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init(
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags to apply to the resource. For more information see [Tagging Amazon Personalize resources](https://docs.aws.amazon.com/personalize/latest/dg/tagging-resources.html).
    /// This member is required.
    public var tags: [PersonalizeClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [PersonalizeClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

/// The request contains more tag keys than can be associated with a resource (50 tag keys per resource).
public struct TooManyTagKeysException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagKeysException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateCampaignInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the campaign.
    /// This member is required.
    public var campaignArn: Swift.String?
    /// The configuration details of a campaign.
    public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
    /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support. A high minProvisionedTPS will increase your bill. We recommend starting with 1 for minProvisionedTPS (the default). Track your usage using Amazon CloudWatch metrics, and increase the minProvisionedTPS as necessary.
    public var minProvisionedTPS: Swift.Int?
    /// The Amazon Resource Name (ARN) of a new model to deploy. To specify the latest solution version of your solution, specify the ARN of your solution in SolutionArn/$LATEST format. You must use this format if you set syncWithLatestSolutionVersion to True in the [CampaignConfig](https://docs.aws.amazon.com/personalize/latest/dg/API_CampaignConfig.html). To deploy a model that isn't the latest solution version of your solution, specify the ARN of the solution version. For more information about automatic campaign updates, see [Enabling automatic campaign updates](https://docs.aws.amazon.com/personalize/latest/dg/campaigns.html#create-campaign-automatic-latest-sv-update).
    public var solutionVersionArn: Swift.String?

    public init(
        campaignArn: Swift.String? = nil,
        campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
        minProvisionedTPS: Swift.Int? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
        self.campaignConfig = campaignConfig
        self.minProvisionedTPS = minProvisionedTPS
        self.solutionVersionArn = solutionVersionArn
    }
}

public struct UpdateCampaignOutput: Swift.Sendable {
    /// The same campaign ARN as given in the request.
    public var campaignArn: Swift.String?

    public init(
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

public struct UpdateDatasetInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset that you want to update.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the new schema you want use.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.schemaArn = schemaArn
    }
}

public struct UpdateDatasetOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset you updated.
    public var datasetArn: Swift.String?

    public init(
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

public struct UpdateMetricAttributionInput: Swift.Sendable {
    /// Add new metric attributes to the metric attribution.
    public var addMetrics: [PersonalizeClientTypes.MetricAttribute]?
    /// The Amazon Resource Name (ARN) for the metric attribution to update.
    public var metricAttributionArn: Swift.String?
    /// An output config for the metric attribution.
    public var metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput?
    /// Remove metric attributes from the metric attribution.
    public var removeMetrics: [Swift.String]?

    public init(
        addMetrics: [PersonalizeClientTypes.MetricAttribute]? = nil,
        metricAttributionArn: Swift.String? = nil,
        metricsOutputConfig: PersonalizeClientTypes.MetricAttributionOutput? = nil,
        removeMetrics: [Swift.String]? = nil
    )
    {
        self.addMetrics = addMetrics
        self.metricAttributionArn = metricAttributionArn
        self.metricsOutputConfig = metricsOutputConfig
        self.removeMetrics = removeMetrics
    }
}

public struct UpdateMetricAttributionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the metric attribution that you updated.
    public var metricAttributionArn: Swift.String?

    public init(
        metricAttributionArn: Swift.String? = nil
    )
    {
        self.metricAttributionArn = metricAttributionArn
    }
}

public struct UpdateRecommenderInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the recommender to modify.
    /// This member is required.
    public var recommenderArn: Swift.String?
    /// The configuration details of the recommender.
    /// This member is required.
    public var recommenderConfig: PersonalizeClientTypes.RecommenderConfig?

    public init(
        recommenderArn: Swift.String? = nil,
        recommenderConfig: PersonalizeClientTypes.RecommenderConfig? = nil
    )
    {
        self.recommenderArn = recommenderArn
        self.recommenderConfig = recommenderConfig
    }
}

public struct UpdateRecommenderOutput: Swift.Sendable {
    /// The same recommender Amazon Resource Name (ARN) as given in the request.
    public var recommenderArn: Swift.String?

    public init(
        recommenderArn: Swift.String? = nil
    )
    {
        self.recommenderArn = recommenderArn
    }
}

public struct UpdateSolutionInput: Swift.Sendable {
    /// Whether the solution uses automatic training to create new solution versions (trained models). You can change the training frequency by specifying a schedulingExpression in the AutoTrainingConfig as part of solution configuration. If you turn on automatic training, the first automatic training starts within one hour after the solution update completes. If you manually create a solution version within the hour, the solution skips the first automatic training. For more information about automatic training, see [Configuring automatic training](https://docs.aws.amazon.com/personalize/latest/dg/solution-config-auto-training.html). After training starts, you can get the solution version's Amazon Resource Name (ARN) with the [ListSolutionVersions](https://docs.aws.amazon.com/personalize/latest/dg/API_ListSolutionVersions.html) API operation. To get its status, use the [DescribeSolutionVersion](https://docs.aws.amazon.com/personalize/latest/dg/API_DescribeSolutionVersion.html).
    public var performAutoTraining: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the solution to update.
    /// This member is required.
    public var solutionArn: Swift.String?
    /// The new configuration details of the solution.
    public var solutionUpdateConfig: PersonalizeClientTypes.SolutionUpdateConfig?

    public init(
        performAutoTraining: Swift.Bool? = nil,
        solutionArn: Swift.String? = nil,
        solutionUpdateConfig: PersonalizeClientTypes.SolutionUpdateConfig? = nil
    )
    {
        self.performAutoTraining = performAutoTraining
        self.solutionArn = solutionArn
        self.solutionUpdateConfig = solutionUpdateConfig
    }
}

public struct UpdateSolutionOutput: Swift.Sendable {
    /// The same solution Amazon Resource Name (ARN) as given in the request.
    public var solutionArn: Swift.String?

    public init(
        solutionArn: Swift.String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

extension CreateBatchInferenceJobInput {

    static func urlPathProvider(_ value: CreateBatchInferenceJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBatchSegmentJobInput {

    static func urlPathProvider(_ value: CreateBatchSegmentJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCampaignInput {

    static func urlPathProvider(_ value: CreateCampaignInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDataDeletionJobInput {

    static func urlPathProvider(_ value: CreateDataDeletionJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDatasetInput {

    static func urlPathProvider(_ value: CreateDatasetInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDatasetExportJobInput {

    static func urlPathProvider(_ value: CreateDatasetExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDatasetGroupInput {

    static func urlPathProvider(_ value: CreateDatasetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDatasetImportJobInput {

    static func urlPathProvider(_ value: CreateDatasetImportJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEventTrackerInput {

    static func urlPathProvider(_ value: CreateEventTrackerInput) -> Swift.String? {
        return "/"
    }
}

extension CreateFilterInput {

    static func urlPathProvider(_ value: CreateFilterInput) -> Swift.String? {
        return "/"
    }
}

extension CreateMetricAttributionInput {

    static func urlPathProvider(_ value: CreateMetricAttributionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRecommenderInput {

    static func urlPathProvider(_ value: CreateRecommenderInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSchemaInput {

    static func urlPathProvider(_ value: CreateSchemaInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSolutionInput {

    static func urlPathProvider(_ value: CreateSolutionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSolutionVersionInput {

    static func urlPathProvider(_ value: CreateSolutionVersionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCampaignInput {

    static func urlPathProvider(_ value: DeleteCampaignInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDatasetInput {

    static func urlPathProvider(_ value: DeleteDatasetInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDatasetGroupInput {

    static func urlPathProvider(_ value: DeleteDatasetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEventTrackerInput {

    static func urlPathProvider(_ value: DeleteEventTrackerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFilterInput {

    static func urlPathProvider(_ value: DeleteFilterInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteMetricAttributionInput {

    static func urlPathProvider(_ value: DeleteMetricAttributionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRecommenderInput {

    static func urlPathProvider(_ value: DeleteRecommenderInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSchemaInput {

    static func urlPathProvider(_ value: DeleteSchemaInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSolutionInput {

    static func urlPathProvider(_ value: DeleteSolutionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAlgorithmInput {

    static func urlPathProvider(_ value: DescribeAlgorithmInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBatchInferenceJobInput {

    static func urlPathProvider(_ value: DescribeBatchInferenceJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBatchSegmentJobInput {

    static func urlPathProvider(_ value: DescribeBatchSegmentJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCampaignInput {

    static func urlPathProvider(_ value: DescribeCampaignInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDataDeletionJobInput {

    static func urlPathProvider(_ value: DescribeDataDeletionJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDatasetInput {

    static func urlPathProvider(_ value: DescribeDatasetInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDatasetExportJobInput {

    static func urlPathProvider(_ value: DescribeDatasetExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDatasetGroupInput {

    static func urlPathProvider(_ value: DescribeDatasetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDatasetImportJobInput {

    static func urlPathProvider(_ value: DescribeDatasetImportJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEventTrackerInput {

    static func urlPathProvider(_ value: DescribeEventTrackerInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFeatureTransformationInput {

    static func urlPathProvider(_ value: DescribeFeatureTransformationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFilterInput {

    static func urlPathProvider(_ value: DescribeFilterInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMetricAttributionInput {

    static func urlPathProvider(_ value: DescribeMetricAttributionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRecipeInput {

    static func urlPathProvider(_ value: DescribeRecipeInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRecommenderInput {

    static func urlPathProvider(_ value: DescribeRecommenderInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSchemaInput {

    static func urlPathProvider(_ value: DescribeSchemaInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSolutionInput {

    static func urlPathProvider(_ value: DescribeSolutionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSolutionVersionInput {

    static func urlPathProvider(_ value: DescribeSolutionVersionInput) -> Swift.String? {
        return "/"
    }
}

extension GetSolutionMetricsInput {

    static func urlPathProvider(_ value: GetSolutionMetricsInput) -> Swift.String? {
        return "/"
    }
}

extension ListBatchInferenceJobsInput {

    static func urlPathProvider(_ value: ListBatchInferenceJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListBatchSegmentJobsInput {

    static func urlPathProvider(_ value: ListBatchSegmentJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCampaignsInput {

    static func urlPathProvider(_ value: ListCampaignsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDataDeletionJobsInput {

    static func urlPathProvider(_ value: ListDataDeletionJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDatasetExportJobsInput {

    static func urlPathProvider(_ value: ListDatasetExportJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDatasetGroupsInput {

    static func urlPathProvider(_ value: ListDatasetGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDatasetImportJobsInput {

    static func urlPathProvider(_ value: ListDatasetImportJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDatasetsInput {

    static func urlPathProvider(_ value: ListDatasetsInput) -> Swift.String? {
        return "/"
    }
}

extension ListEventTrackersInput {

    static func urlPathProvider(_ value: ListEventTrackersInput) -> Swift.String? {
        return "/"
    }
}

extension ListFiltersInput {

    static func urlPathProvider(_ value: ListFiltersInput) -> Swift.String? {
        return "/"
    }
}

extension ListMetricAttributionMetricsInput {

    static func urlPathProvider(_ value: ListMetricAttributionMetricsInput) -> Swift.String? {
        return "/"
    }
}

extension ListMetricAttributionsInput {

    static func urlPathProvider(_ value: ListMetricAttributionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListRecipesInput {

    static func urlPathProvider(_ value: ListRecipesInput) -> Swift.String? {
        return "/"
    }
}

extension ListRecommendersInput {

    static func urlPathProvider(_ value: ListRecommendersInput) -> Swift.String? {
        return "/"
    }
}

extension ListSchemasInput {

    static func urlPathProvider(_ value: ListSchemasInput) -> Swift.String? {
        return "/"
    }
}

extension ListSolutionsInput {

    static func urlPathProvider(_ value: ListSolutionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSolutionVersionsInput {

    static func urlPathProvider(_ value: ListSolutionVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension StartRecommenderInput {

    static func urlPathProvider(_ value: StartRecommenderInput) -> Swift.String? {
        return "/"
    }
}

extension StopRecommenderInput {

    static func urlPathProvider(_ value: StopRecommenderInput) -> Swift.String? {
        return "/"
    }
}

extension StopSolutionVersionCreationInput {

    static func urlPathProvider(_ value: StopSolutionVersionCreationInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCampaignInput {

    static func urlPathProvider(_ value: UpdateCampaignInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDatasetInput {

    static func urlPathProvider(_ value: UpdateDatasetInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateMetricAttributionInput {

    static func urlPathProvider(_ value: UpdateMetricAttributionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRecommenderInput {

    static func urlPathProvider(_ value: UpdateRecommenderInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSolutionInput {

    static func urlPathProvider(_ value: UpdateSolutionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBatchInferenceJobInput {

    static func write(value: CreateBatchInferenceJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["batchInferenceJobConfig"].write(value.batchInferenceJobConfig, with: PersonalizeClientTypes.BatchInferenceJobConfig.write(value:to:))
        try writer["batchInferenceJobMode"].write(value.batchInferenceJobMode)
        try writer["filterArn"].write(value.filterArn)
        try writer["jobInput"].write(value.jobInput, with: PersonalizeClientTypes.BatchInferenceJobInput.write(value:to:))
        try writer["jobName"].write(value.jobName)
        try writer["jobOutput"].write(value.jobOutput, with: PersonalizeClientTypes.BatchInferenceJobOutput.write(value:to:))
        try writer["numResults"].write(value.numResults)
        try writer["roleArn"].write(value.roleArn)
        try writer["solutionVersionArn"].write(value.solutionVersionArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["themeGenerationConfig"].write(value.themeGenerationConfig, with: PersonalizeClientTypes.ThemeGenerationConfig.write(value:to:))
    }
}

extension CreateBatchSegmentJobInput {

    static func write(value: CreateBatchSegmentJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterArn"].write(value.filterArn)
        try writer["jobInput"].write(value.jobInput, with: PersonalizeClientTypes.BatchSegmentJobInput.write(value:to:))
        try writer["jobName"].write(value.jobName)
        try writer["jobOutput"].write(value.jobOutput, with: PersonalizeClientTypes.BatchSegmentJobOutput.write(value:to:))
        try writer["numResults"].write(value.numResults)
        try writer["roleArn"].write(value.roleArn)
        try writer["solutionVersionArn"].write(value.solutionVersionArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCampaignInput {

    static func write(value: CreateCampaignInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["campaignConfig"].write(value.campaignConfig, with: PersonalizeClientTypes.CampaignConfig.write(value:to:))
        try writer["minProvisionedTPS"].write(value.minProvisionedTPS)
        try writer["name"].write(value.name)
        try writer["solutionVersionArn"].write(value.solutionVersionArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDataDeletionJobInput {

    static func write(value: CreateDataDeletionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataSource"].write(value.dataSource, with: PersonalizeClientTypes.DataSource.write(value:to:))
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["jobName"].write(value.jobName)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDatasetInput {

    static func write(value: CreateDatasetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["datasetType"].write(value.datasetType)
        try writer["name"].write(value.name)
        try writer["schemaArn"].write(value.schemaArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDatasetExportJobInput {

    static func write(value: CreateDatasetExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetArn"].write(value.datasetArn)
        try writer["ingestionMode"].write(value.ingestionMode)
        try writer["jobName"].write(value.jobName)
        try writer["jobOutput"].write(value.jobOutput, with: PersonalizeClientTypes.DatasetExportJobOutput.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDatasetGroupInput {

    static func write(value: CreateDatasetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domain"].write(value.domain)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
        try writer["name"].write(value.name)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDatasetImportJobInput {

    static func write(value: CreateDatasetImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataSource"].write(value.dataSource, with: PersonalizeClientTypes.DataSource.write(value:to:))
        try writer["datasetArn"].write(value.datasetArn)
        try writer["importMode"].write(value.importMode)
        try writer["jobName"].write(value.jobName)
        try writer["publishAttributionMetricsToS3"].write(value.publishAttributionMetricsToS3)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateEventTrackerInput {

    static func write(value: CreateEventTrackerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["name"].write(value.name)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateFilterInput {

    static func write(value: CreateFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["filterExpression"].write(value.filterExpression)
        try writer["name"].write(value.name)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMetricAttributionInput {

    static func write(value: CreateMetricAttributionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["metrics"].writeList(value.metrics, memberWritingClosure: PersonalizeClientTypes.MetricAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["metricsOutputConfig"].write(value.metricsOutputConfig, with: PersonalizeClientTypes.MetricAttributionOutput.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension CreateRecommenderInput {

    static func write(value: CreateRecommenderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["name"].write(value.name)
        try writer["recipeArn"].write(value.recipeArn)
        try writer["recommenderConfig"].write(value.recommenderConfig, with: PersonalizeClientTypes.RecommenderConfig.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSchemaInput {

    static func write(value: CreateSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domain"].write(value.domain)
        try writer["name"].write(value.name)
        try writer["schema"].write(value.schema)
    }
}

extension CreateSolutionInput {

    static func write(value: CreateSolutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["eventType"].write(value.eventType)
        try writer["name"].write(value.name)
        try writer["performAutoML"].write(value.performAutoML)
        try writer["performAutoTraining"].write(value.performAutoTraining)
        try writer["performHPO"].write(value.performHPO)
        try writer["recipeArn"].write(value.recipeArn)
        try writer["solutionConfig"].write(value.solutionConfig, with: PersonalizeClientTypes.SolutionConfig.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSolutionVersionInput {

    static func write(value: CreateSolutionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["solutionArn"].write(value.solutionArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["trainingMode"].write(value.trainingMode)
    }
}

extension DeleteCampaignInput {

    static func write(value: DeleteCampaignInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["campaignArn"].write(value.campaignArn)
    }
}

extension DeleteDatasetInput {

    static func write(value: DeleteDatasetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetArn"].write(value.datasetArn)
    }
}

extension DeleteDatasetGroupInput {

    static func write(value: DeleteDatasetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
    }
}

extension DeleteEventTrackerInput {

    static func write(value: DeleteEventTrackerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventTrackerArn"].write(value.eventTrackerArn)
    }
}

extension DeleteFilterInput {

    static func write(value: DeleteFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterArn"].write(value.filterArn)
    }
}

extension DeleteMetricAttributionInput {

    static func write(value: DeleteMetricAttributionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metricAttributionArn"].write(value.metricAttributionArn)
    }
}

extension DeleteRecommenderInput {

    static func write(value: DeleteRecommenderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recommenderArn"].write(value.recommenderArn)
    }
}

extension DeleteSchemaInput {

    static func write(value: DeleteSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["schemaArn"].write(value.schemaArn)
    }
}

extension DeleteSolutionInput {

    static func write(value: DeleteSolutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["solutionArn"].write(value.solutionArn)
    }
}

extension DescribeAlgorithmInput {

    static func write(value: DescribeAlgorithmInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["algorithmArn"].write(value.algorithmArn)
    }
}

extension DescribeBatchInferenceJobInput {

    static func write(value: DescribeBatchInferenceJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["batchInferenceJobArn"].write(value.batchInferenceJobArn)
    }
}

extension DescribeBatchSegmentJobInput {

    static func write(value: DescribeBatchSegmentJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["batchSegmentJobArn"].write(value.batchSegmentJobArn)
    }
}

extension DescribeCampaignInput {

    static func write(value: DescribeCampaignInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["campaignArn"].write(value.campaignArn)
    }
}

extension DescribeDataDeletionJobInput {

    static func write(value: DescribeDataDeletionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataDeletionJobArn"].write(value.dataDeletionJobArn)
    }
}

extension DescribeDatasetInput {

    static func write(value: DescribeDatasetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetArn"].write(value.datasetArn)
    }
}

extension DescribeDatasetExportJobInput {

    static func write(value: DescribeDatasetExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetExportJobArn"].write(value.datasetExportJobArn)
    }
}

extension DescribeDatasetGroupInput {

    static func write(value: DescribeDatasetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
    }
}

extension DescribeDatasetImportJobInput {

    static func write(value: DescribeDatasetImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetImportJobArn"].write(value.datasetImportJobArn)
    }
}

extension DescribeEventTrackerInput {

    static func write(value: DescribeEventTrackerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventTrackerArn"].write(value.eventTrackerArn)
    }
}

extension DescribeFeatureTransformationInput {

    static func write(value: DescribeFeatureTransformationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["featureTransformationArn"].write(value.featureTransformationArn)
    }
}

extension DescribeFilterInput {

    static func write(value: DescribeFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterArn"].write(value.filterArn)
    }
}

extension DescribeMetricAttributionInput {

    static func write(value: DescribeMetricAttributionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metricAttributionArn"].write(value.metricAttributionArn)
    }
}

extension DescribeRecipeInput {

    static func write(value: DescribeRecipeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recipeArn"].write(value.recipeArn)
    }
}

extension DescribeRecommenderInput {

    static func write(value: DescribeRecommenderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recommenderArn"].write(value.recommenderArn)
    }
}

extension DescribeSchemaInput {

    static func write(value: DescribeSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["schemaArn"].write(value.schemaArn)
    }
}

extension DescribeSolutionInput {

    static func write(value: DescribeSolutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["solutionArn"].write(value.solutionArn)
    }
}

extension DescribeSolutionVersionInput {

    static func write(value: DescribeSolutionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["solutionVersionArn"].write(value.solutionVersionArn)
    }
}

extension GetSolutionMetricsInput {

    static func write(value: GetSolutionMetricsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["solutionVersionArn"].write(value.solutionVersionArn)
    }
}

extension ListBatchInferenceJobsInput {

    static func write(value: ListBatchInferenceJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["solutionVersionArn"].write(value.solutionVersionArn)
    }
}

extension ListBatchSegmentJobsInput {

    static func write(value: ListBatchSegmentJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["solutionVersionArn"].write(value.solutionVersionArn)
    }
}

extension ListCampaignsInput {

    static func write(value: ListCampaignsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["solutionArn"].write(value.solutionArn)
    }
}

extension ListDataDeletionJobsInput {

    static func write(value: ListDataDeletionJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListDatasetExportJobsInput {

    static func write(value: ListDatasetExportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetArn"].write(value.datasetArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListDatasetGroupsInput {

    static func write(value: ListDatasetGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListDatasetImportJobsInput {

    static func write(value: ListDatasetImportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetArn"].write(value.datasetArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListDatasetsInput {

    static func write(value: ListDatasetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListEventTrackersInput {

    static func write(value: ListEventTrackersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListFiltersInput {

    static func write(value: ListFiltersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListMetricAttributionMetricsInput {

    static func write(value: ListMetricAttributionMetricsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["metricAttributionArn"].write(value.metricAttributionArn)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListMetricAttributionsInput {

    static func write(value: ListMetricAttributionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListRecipesInput {

    static func write(value: ListRecipesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domain"].write(value.domain)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["recipeProvider"].write(value.recipeProvider)
    }
}

extension ListRecommendersInput {

    static func write(value: ListRecommendersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListSchemasInput {

    static func write(value: ListSchemasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListSolutionsInput {

    static func write(value: ListSolutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetGroupArn"].write(value.datasetGroupArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListSolutionVersionsInput {

    static func write(value: ListSolutionVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["solutionArn"].write(value.solutionArn)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension StartRecommenderInput {

    static func write(value: StartRecommenderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recommenderArn"].write(value.recommenderArn)
    }
}

extension StopRecommenderInput {

    static func write(value: StopRecommenderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recommenderArn"].write(value.recommenderArn)
    }
}

extension StopSolutionVersionCreationInput {

    static func write(value: StopSolutionVersionCreationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["solutionVersionArn"].write(value.solutionVersionArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PersonalizeClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateCampaignInput {

    static func write(value: UpdateCampaignInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["campaignArn"].write(value.campaignArn)
        try writer["campaignConfig"].write(value.campaignConfig, with: PersonalizeClientTypes.CampaignConfig.write(value:to:))
        try writer["minProvisionedTPS"].write(value.minProvisionedTPS)
        try writer["solutionVersionArn"].write(value.solutionVersionArn)
    }
}

extension UpdateDatasetInput {

    static func write(value: UpdateDatasetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetArn"].write(value.datasetArn)
        try writer["schemaArn"].write(value.schemaArn)
    }
}

extension UpdateMetricAttributionInput {

    static func write(value: UpdateMetricAttributionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addMetrics"].writeList(value.addMetrics, memberWritingClosure: PersonalizeClientTypes.MetricAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["metricAttributionArn"].write(value.metricAttributionArn)
        try writer["metricsOutputConfig"].write(value.metricsOutputConfig, with: PersonalizeClientTypes.MetricAttributionOutput.write(value:to:))
        try writer["removeMetrics"].writeList(value.removeMetrics, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateRecommenderInput {

    static func write(value: UpdateRecommenderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recommenderArn"].write(value.recommenderArn)
        try writer["recommenderConfig"].write(value.recommenderConfig, with: PersonalizeClientTypes.RecommenderConfig.write(value:to:))
    }
}

extension UpdateSolutionInput {

    static func write(value: UpdateSolutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["performAutoTraining"].write(value.performAutoTraining)
        try writer["solutionArn"].write(value.solutionArn)
        try writer["solutionUpdateConfig"].write(value.solutionUpdateConfig, with: PersonalizeClientTypes.SolutionUpdateConfig.write(value:to:))
    }
}

extension CreateBatchInferenceJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBatchInferenceJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBatchInferenceJobOutput()
        value.batchInferenceJobArn = try reader["batchInferenceJobArn"].readIfPresent()
        return value
    }
}

extension CreateBatchSegmentJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBatchSegmentJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBatchSegmentJobOutput()
        value.batchSegmentJobArn = try reader["batchSegmentJobArn"].readIfPresent()
        return value
    }
}

extension CreateCampaignOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCampaignOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCampaignOutput()
        value.campaignArn = try reader["campaignArn"].readIfPresent()
        return value
    }
}

extension CreateDataDeletionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataDeletionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataDeletionJobOutput()
        value.dataDeletionJobArn = try reader["dataDeletionJobArn"].readIfPresent()
        return value
    }
}

extension CreateDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDatasetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDatasetOutput()
        value.datasetArn = try reader["datasetArn"].readIfPresent()
        return value
    }
}

extension CreateDatasetExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDatasetExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDatasetExportJobOutput()
        value.datasetExportJobArn = try reader["datasetExportJobArn"].readIfPresent()
        return value
    }
}

extension CreateDatasetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDatasetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDatasetGroupOutput()
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.domain = try reader["domain"].readIfPresent()
        return value
    }
}

extension CreateDatasetImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDatasetImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDatasetImportJobOutput()
        value.datasetImportJobArn = try reader["datasetImportJobArn"].readIfPresent()
        return value
    }
}

extension CreateEventTrackerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventTrackerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventTrackerOutput()
        value.eventTrackerArn = try reader["eventTrackerArn"].readIfPresent()
        value.trackingId = try reader["trackingId"].readIfPresent()
        return value
    }
}

extension CreateFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFilterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFilterOutput()
        value.filterArn = try reader["filterArn"].readIfPresent()
        return value
    }
}

extension CreateMetricAttributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMetricAttributionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMetricAttributionOutput()
        value.metricAttributionArn = try reader["metricAttributionArn"].readIfPresent()
        return value
    }
}

extension CreateRecommenderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRecommenderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRecommenderOutput()
        value.recommenderArn = try reader["recommenderArn"].readIfPresent()
        return value
    }
}

extension CreateSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSchemaOutput()
        value.schemaArn = try reader["schemaArn"].readIfPresent()
        return value
    }
}

extension CreateSolutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSolutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSolutionOutput()
        value.solutionArn = try reader["solutionArn"].readIfPresent()
        return value
    }
}

extension CreateSolutionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSolutionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSolutionVersionOutput()
        value.solutionVersionArn = try reader["solutionVersionArn"].readIfPresent()
        return value
    }
}

extension DeleteCampaignOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCampaignOutput {
        return DeleteCampaignOutput()
    }
}

extension DeleteDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDatasetOutput {
        return DeleteDatasetOutput()
    }
}

extension DeleteDatasetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDatasetGroupOutput {
        return DeleteDatasetGroupOutput()
    }
}

extension DeleteEventTrackerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventTrackerOutput {
        return DeleteEventTrackerOutput()
    }
}

extension DeleteFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFilterOutput {
        return DeleteFilterOutput()
    }
}

extension DeleteMetricAttributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMetricAttributionOutput {
        return DeleteMetricAttributionOutput()
    }
}

extension DeleteRecommenderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRecommenderOutput {
        return DeleteRecommenderOutput()
    }
}

extension DeleteSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSchemaOutput {
        return DeleteSchemaOutput()
    }
}

extension DeleteSolutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSolutionOutput {
        return DeleteSolutionOutput()
    }
}

extension DescribeAlgorithmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAlgorithmOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAlgorithmOutput()
        value.algorithm = try reader["algorithm"].readIfPresent(with: PersonalizeClientTypes.Algorithm.read(from:))
        return value
    }
}

extension DescribeBatchInferenceJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBatchInferenceJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBatchInferenceJobOutput()
        value.batchInferenceJob = try reader["batchInferenceJob"].readIfPresent(with: PersonalizeClientTypes.BatchInferenceJob.read(from:))
        return value
    }
}

extension DescribeBatchSegmentJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBatchSegmentJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBatchSegmentJobOutput()
        value.batchSegmentJob = try reader["batchSegmentJob"].readIfPresent(with: PersonalizeClientTypes.BatchSegmentJob.read(from:))
        return value
    }
}

extension DescribeCampaignOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCampaignOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCampaignOutput()
        value.campaign = try reader["campaign"].readIfPresent(with: PersonalizeClientTypes.Campaign.read(from:))
        return value
    }
}

extension DescribeDataDeletionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDataDeletionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDataDeletionJobOutput()
        value.dataDeletionJob = try reader["dataDeletionJob"].readIfPresent(with: PersonalizeClientTypes.DataDeletionJob.read(from:))
        return value
    }
}

extension DescribeDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDatasetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDatasetOutput()
        value.dataset = try reader["dataset"].readIfPresent(with: PersonalizeClientTypes.Dataset.read(from:))
        return value
    }
}

extension DescribeDatasetExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDatasetExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDatasetExportJobOutput()
        value.datasetExportJob = try reader["datasetExportJob"].readIfPresent(with: PersonalizeClientTypes.DatasetExportJob.read(from:))
        return value
    }
}

extension DescribeDatasetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDatasetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDatasetGroupOutput()
        value.datasetGroup = try reader["datasetGroup"].readIfPresent(with: PersonalizeClientTypes.DatasetGroup.read(from:))
        return value
    }
}

extension DescribeDatasetImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDatasetImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDatasetImportJobOutput()
        value.datasetImportJob = try reader["datasetImportJob"].readIfPresent(with: PersonalizeClientTypes.DatasetImportJob.read(from:))
        return value
    }
}

extension DescribeEventTrackerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventTrackerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventTrackerOutput()
        value.eventTracker = try reader["eventTracker"].readIfPresent(with: PersonalizeClientTypes.EventTracker.read(from:))
        return value
    }
}

extension DescribeFeatureTransformationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFeatureTransformationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFeatureTransformationOutput()
        value.featureTransformation = try reader["featureTransformation"].readIfPresent(with: PersonalizeClientTypes.FeatureTransformation.read(from:))
        return value
    }
}

extension DescribeFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFilterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFilterOutput()
        value.filter = try reader["filter"].readIfPresent(with: PersonalizeClientTypes.Filter.read(from:))
        return value
    }
}

extension DescribeMetricAttributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMetricAttributionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMetricAttributionOutput()
        value.metricAttribution = try reader["metricAttribution"].readIfPresent(with: PersonalizeClientTypes.MetricAttribution.read(from:))
        return value
    }
}

extension DescribeRecipeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRecipeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRecipeOutput()
        value.recipe = try reader["recipe"].readIfPresent(with: PersonalizeClientTypes.Recipe.read(from:))
        return value
    }
}

extension DescribeRecommenderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRecommenderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRecommenderOutput()
        value.recommender = try reader["recommender"].readIfPresent(with: PersonalizeClientTypes.Recommender.read(from:))
        return value
    }
}

extension DescribeSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSchemaOutput()
        value.schema = try reader["schema"].readIfPresent(with: PersonalizeClientTypes.DatasetSchema.read(from:))
        return value
    }
}

extension DescribeSolutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSolutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSolutionOutput()
        value.solution = try reader["solution"].readIfPresent(with: PersonalizeClientTypes.Solution.read(from:))
        return value
    }
}

extension DescribeSolutionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSolutionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSolutionVersionOutput()
        value.solutionVersion = try reader["solutionVersion"].readIfPresent(with: PersonalizeClientTypes.SolutionVersion.read(from:))
        return value
    }
}

extension GetSolutionMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSolutionMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSolutionMetricsOutput()
        value.metrics = try reader["metrics"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.solutionVersionArn = try reader["solutionVersionArn"].readIfPresent()
        return value
    }
}

extension ListBatchInferenceJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBatchInferenceJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBatchInferenceJobsOutput()
        value.batchInferenceJobs = try reader["batchInferenceJobs"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.BatchInferenceJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBatchSegmentJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBatchSegmentJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBatchSegmentJobsOutput()
        value.batchSegmentJobs = try reader["batchSegmentJobs"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.BatchSegmentJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCampaignsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCampaignsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCampaignsOutput()
        value.campaigns = try reader["campaigns"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.CampaignSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataDeletionJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataDeletionJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataDeletionJobsOutput()
        value.dataDeletionJobs = try reader["dataDeletionJobs"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.DataDeletionJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDatasetExportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDatasetExportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDatasetExportJobsOutput()
        value.datasetExportJobs = try reader["datasetExportJobs"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.DatasetExportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDatasetGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDatasetGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDatasetGroupsOutput()
        value.datasetGroups = try reader["datasetGroups"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.DatasetGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDatasetImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDatasetImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDatasetImportJobsOutput()
        value.datasetImportJobs = try reader["datasetImportJobs"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.DatasetImportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDatasetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDatasetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDatasetsOutput()
        value.datasets = try reader["datasets"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.DatasetSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEventTrackersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventTrackersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventTrackersOutput()
        value.eventTrackers = try reader["eventTrackers"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.EventTrackerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFiltersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFiltersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFiltersOutput()
        value.filters = try reader["Filters"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.FilterSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMetricAttributionMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMetricAttributionMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMetricAttributionMetricsOutput()
        value.metrics = try reader["metrics"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.MetricAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMetricAttributionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMetricAttributionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMetricAttributionsOutput()
        value.metricAttributions = try reader["metricAttributions"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.MetricAttributionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListRecipesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRecipesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecipesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.recipes = try reader["recipes"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.RecipeSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRecommendersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRecommendersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecommendersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.recommenders = try reader["recommenders"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.RecommenderSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSchemasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSchemasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSchemasOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.schemas = try reader["schemas"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.DatasetSchemaSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSolutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSolutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSolutionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.solutions = try reader["solutions"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.SolutionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSolutionVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSolutionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSolutionVersionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.solutionVersions = try reader["solutionVersions"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.SolutionVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartRecommenderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartRecommenderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartRecommenderOutput()
        value.recommenderArn = try reader["recommenderArn"].readIfPresent()
        return value
    }
}

extension StopRecommenderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopRecommenderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopRecommenderOutput()
        value.recommenderArn = try reader["recommenderArn"].readIfPresent()
        return value
    }
}

extension StopSolutionVersionCreationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopSolutionVersionCreationOutput {
        return StopSolutionVersionCreationOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCampaignOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCampaignOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCampaignOutput()
        value.campaignArn = try reader["campaignArn"].readIfPresent()
        return value
    }
}

extension UpdateDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDatasetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDatasetOutput()
        value.datasetArn = try reader["datasetArn"].readIfPresent()
        return value
    }
}

extension UpdateMetricAttributionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMetricAttributionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMetricAttributionOutput()
        value.metricAttributionArn = try reader["metricAttributionArn"].readIfPresent()
        return value
    }
}

extension UpdateRecommenderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRecommenderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRecommenderOutput()
        value.recommenderArn = try reader["recommenderArn"].readIfPresent()
        return value
    }
}

extension UpdateSolutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSolutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSolutionOutput()
        value.solutionArn = try reader["solutionArn"].readIfPresent()
        return value
    }
}

enum CreateBatchInferenceJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBatchSegmentJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCampaignOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataDeletionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDatasetExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDatasetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDatasetImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventTrackerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMetricAttributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRecommenderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSolutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSolutionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCampaignOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDatasetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventTrackerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMetricAttributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRecommenderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSolutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAlgorithmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBatchInferenceJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBatchSegmentJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCampaignOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDataDeletionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDatasetExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDatasetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDatasetImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventTrackerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFeatureTransformationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMetricAttributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRecipeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRecommenderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSolutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSolutionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSolutionMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBatchInferenceJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBatchSegmentJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCampaignsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataDeletionJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDatasetExportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDatasetGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDatasetImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDatasetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventTrackersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFiltersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMetricAttributionMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMetricAttributionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRecipesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRecommendersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSchemasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSolutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSolutionVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartRecommenderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopRecommenderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopSolutionVersionCreationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagKeysException": return try TooManyTagKeysException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCampaignOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMetricAttributionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRecommenderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSolutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInputException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInputException {
        let reader = baseError.errorBodyReader
        var value = InvalidInputException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagKeysException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagKeysException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagKeysException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PersonalizeClientTypes.Algorithm {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.Algorithm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.Algorithm()
        value.name = try reader["name"].readIfPresent()
        value.algorithmArn = try reader["algorithmArn"].readIfPresent()
        value.algorithmImage = try reader["algorithmImage"].readIfPresent(with: PersonalizeClientTypes.AlgorithmImage.read(from:))
        value.defaultHyperParameters = try reader["defaultHyperParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.defaultHyperParameterRanges = try reader["defaultHyperParameterRanges"].readIfPresent(with: PersonalizeClientTypes.DefaultHyperParameterRanges.read(from:))
        value.defaultResourceConfig = try reader["defaultResourceConfig"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.trainingInputMode = try reader["trainingInputMode"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PersonalizeClientTypes.DefaultHyperParameterRanges {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DefaultHyperParameterRanges {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DefaultHyperParameterRanges()
        value.integerHyperParameterRanges = try reader["integerHyperParameterRanges"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.DefaultIntegerHyperParameterRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.continuousHyperParameterRanges = try reader["continuousHyperParameterRanges"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.DefaultContinuousHyperParameterRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.categoricalHyperParameterRanges = try reader["categoricalHyperParameterRanges"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.DefaultCategoricalHyperParameterRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PersonalizeClientTypes.DefaultCategoricalHyperParameterRange {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DefaultCategoricalHyperParameterRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DefaultCategoricalHyperParameterRange()
        value.name = try reader["name"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.isTunable = try reader["isTunable"].readIfPresent() ?? false
        return value
    }
}

extension PersonalizeClientTypes.DefaultContinuousHyperParameterRange {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DefaultContinuousHyperParameterRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DefaultContinuousHyperParameterRange()
        value.name = try reader["name"].readIfPresent()
        value.minValue = try reader["minValue"].readIfPresent() ?? 0
        value.maxValue = try reader["maxValue"].readIfPresent() ?? 0
        value.isTunable = try reader["isTunable"].readIfPresent() ?? false
        return value
    }
}

extension PersonalizeClientTypes.DefaultIntegerHyperParameterRange {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DefaultIntegerHyperParameterRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DefaultIntegerHyperParameterRange()
        value.name = try reader["name"].readIfPresent()
        value.minValue = try reader["minValue"].readIfPresent() ?? 0
        value.maxValue = try reader["maxValue"].readIfPresent() ?? 0
        value.isTunable = try reader["isTunable"].readIfPresent() ?? false
        return value
    }
}

extension PersonalizeClientTypes.AlgorithmImage {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.AlgorithmImage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.AlgorithmImage()
        value.name = try reader["name"].readIfPresent()
        value.dockerURI = try reader["dockerURI"].readIfPresent() ?? ""
        return value
    }
}

extension PersonalizeClientTypes.BatchInferenceJob {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.BatchInferenceJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.BatchInferenceJob()
        value.jobName = try reader["jobName"].readIfPresent()
        value.batchInferenceJobArn = try reader["batchInferenceJobArn"].readIfPresent()
        value.filterArn = try reader["filterArn"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.solutionVersionArn = try reader["solutionVersionArn"].readIfPresent()
        value.numResults = try reader["numResults"].readIfPresent()
        value.jobInput = try reader["jobInput"].readIfPresent(with: PersonalizeClientTypes.BatchInferenceJobInput.read(from:))
        value.jobOutput = try reader["jobOutput"].readIfPresent(with: PersonalizeClientTypes.BatchInferenceJobOutput.read(from:))
        value.batchInferenceJobConfig = try reader["batchInferenceJobConfig"].readIfPresent(with: PersonalizeClientTypes.BatchInferenceJobConfig.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.batchInferenceJobMode = try reader["batchInferenceJobMode"].readIfPresent()
        value.themeGenerationConfig = try reader["themeGenerationConfig"].readIfPresent(with: PersonalizeClientTypes.ThemeGenerationConfig.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PersonalizeClientTypes.ThemeGenerationConfig {

    static func write(value: PersonalizeClientTypes.ThemeGenerationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fieldsForThemeGeneration"].write(value.fieldsForThemeGeneration, with: PersonalizeClientTypes.FieldsForThemeGeneration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.ThemeGenerationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.ThemeGenerationConfig()
        value.fieldsForThemeGeneration = try reader["fieldsForThemeGeneration"].readIfPresent(with: PersonalizeClientTypes.FieldsForThemeGeneration.read(from:))
        return value
    }
}

extension PersonalizeClientTypes.FieldsForThemeGeneration {

    static func write(value: PersonalizeClientTypes.FieldsForThemeGeneration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["itemName"].write(value.itemName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.FieldsForThemeGeneration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.FieldsForThemeGeneration()
        value.itemName = try reader["itemName"].readIfPresent() ?? ""
        return value
    }
}

extension PersonalizeClientTypes.BatchInferenceJobConfig {

    static func write(value: PersonalizeClientTypes.BatchInferenceJobConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["itemExplorationConfig"].writeMap(value.itemExplorationConfig, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.BatchInferenceJobConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.BatchInferenceJobConfig()
        value.itemExplorationConfig = try reader["itemExplorationConfig"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PersonalizeClientTypes.BatchInferenceJobOutput {

    static func write(value: PersonalizeClientTypes.BatchInferenceJobOutput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3DataDestination"].write(value.s3DataDestination, with: PersonalizeClientTypes.S3DataConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.BatchInferenceJobOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.BatchInferenceJobOutput()
        value.s3DataDestination = try reader["s3DataDestination"].readIfPresent(with: PersonalizeClientTypes.S3DataConfig.read(from:))
        return value
    }
}

extension PersonalizeClientTypes.S3DataConfig {

    static func write(value: PersonalizeClientTypes.S3DataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
        try writer["path"].write(value.path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.S3DataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.S3DataConfig()
        value.path = try reader["path"].readIfPresent() ?? ""
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.BatchInferenceJobInput {

    static func write(value: PersonalizeClientTypes.BatchInferenceJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3DataSource"].write(value.s3DataSource, with: PersonalizeClientTypes.S3DataConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.BatchInferenceJobInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.BatchInferenceJobInput()
        value.s3DataSource = try reader["s3DataSource"].readIfPresent(with: PersonalizeClientTypes.S3DataConfig.read(from:))
        return value
    }
}

extension PersonalizeClientTypes.BatchSegmentJob {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.BatchSegmentJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.BatchSegmentJob()
        value.jobName = try reader["jobName"].readIfPresent()
        value.batchSegmentJobArn = try reader["batchSegmentJobArn"].readIfPresent()
        value.filterArn = try reader["filterArn"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.solutionVersionArn = try reader["solutionVersionArn"].readIfPresent()
        value.numResults = try reader["numResults"].readIfPresent()
        value.jobInput = try reader["jobInput"].readIfPresent(with: PersonalizeClientTypes.BatchSegmentJobInput.read(from:))
        value.jobOutput = try reader["jobOutput"].readIfPresent(with: PersonalizeClientTypes.BatchSegmentJobOutput.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PersonalizeClientTypes.BatchSegmentJobOutput {

    static func write(value: PersonalizeClientTypes.BatchSegmentJobOutput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3DataDestination"].write(value.s3DataDestination, with: PersonalizeClientTypes.S3DataConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.BatchSegmentJobOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.BatchSegmentJobOutput()
        value.s3DataDestination = try reader["s3DataDestination"].readIfPresent(with: PersonalizeClientTypes.S3DataConfig.read(from:))
        return value
    }
}

extension PersonalizeClientTypes.BatchSegmentJobInput {

    static func write(value: PersonalizeClientTypes.BatchSegmentJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3DataSource"].write(value.s3DataSource, with: PersonalizeClientTypes.S3DataConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.BatchSegmentJobInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.BatchSegmentJobInput()
        value.s3DataSource = try reader["s3DataSource"].readIfPresent(with: PersonalizeClientTypes.S3DataConfig.read(from:))
        return value
    }
}

extension PersonalizeClientTypes.Campaign {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.Campaign {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.Campaign()
        value.name = try reader["name"].readIfPresent()
        value.campaignArn = try reader["campaignArn"].readIfPresent()
        value.solutionVersionArn = try reader["solutionVersionArn"].readIfPresent()
        value.minProvisionedTPS = try reader["minProvisionedTPS"].readIfPresent()
        value.campaignConfig = try reader["campaignConfig"].readIfPresent(with: PersonalizeClientTypes.CampaignConfig.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.latestCampaignUpdate = try reader["latestCampaignUpdate"].readIfPresent(with: PersonalizeClientTypes.CampaignUpdateSummary.read(from:))
        return value
    }
}

extension PersonalizeClientTypes.CampaignUpdateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.CampaignUpdateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.CampaignUpdateSummary()
        value.solutionVersionArn = try reader["solutionVersionArn"].readIfPresent()
        value.minProvisionedTPS = try reader["minProvisionedTPS"].readIfPresent()
        value.campaignConfig = try reader["campaignConfig"].readIfPresent(with: PersonalizeClientTypes.CampaignConfig.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PersonalizeClientTypes.CampaignConfig {

    static func write(value: PersonalizeClientTypes.CampaignConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enableMetadataWithRecommendations"].write(value.enableMetadataWithRecommendations)
        try writer["itemExplorationConfig"].writeMap(value.itemExplorationConfig, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["syncWithLatestSolutionVersion"].write(value.syncWithLatestSolutionVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.CampaignConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.CampaignConfig()
        value.itemExplorationConfig = try reader["itemExplorationConfig"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.enableMetadataWithRecommendations = try reader["enableMetadataWithRecommendations"].readIfPresent()
        value.syncWithLatestSolutionVersion = try reader["syncWithLatestSolutionVersion"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.DataDeletionJob {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DataDeletionJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DataDeletionJob()
        value.jobName = try reader["jobName"].readIfPresent()
        value.dataDeletionJobArn = try reader["dataDeletionJobArn"].readIfPresent()
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.dataSource = try reader["dataSource"].readIfPresent(with: PersonalizeClientTypes.DataSource.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.numDeleted = try reader["numDeleted"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.DataSource {

    static func write(value: PersonalizeClientTypes.DataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataLocation"].write(value.dataLocation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DataSource()
        value.dataLocation = try reader["dataLocation"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.Dataset {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.Dataset {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.Dataset()
        value.name = try reader["name"].readIfPresent()
        value.datasetArn = try reader["datasetArn"].readIfPresent()
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.datasetType = try reader["datasetType"].readIfPresent()
        value.schemaArn = try reader["schemaArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.latestDatasetUpdate = try reader["latestDatasetUpdate"].readIfPresent(with: PersonalizeClientTypes.DatasetUpdateSummary.read(from:))
        value.trackingId = try reader["trackingId"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.DatasetUpdateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DatasetUpdateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DatasetUpdateSummary()
        value.schemaArn = try reader["schemaArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PersonalizeClientTypes.DatasetExportJob {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DatasetExportJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DatasetExportJob()
        value.jobName = try reader["jobName"].readIfPresent()
        value.datasetExportJobArn = try reader["datasetExportJobArn"].readIfPresent()
        value.datasetArn = try reader["datasetArn"].readIfPresent()
        value.ingestionMode = try reader["ingestionMode"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.jobOutput = try reader["jobOutput"].readIfPresent(with: PersonalizeClientTypes.DatasetExportJobOutput.read(from:))
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.DatasetExportJobOutput {

    static func write(value: PersonalizeClientTypes.DatasetExportJobOutput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3DataDestination"].write(value.s3DataDestination, with: PersonalizeClientTypes.S3DataConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DatasetExportJobOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DatasetExportJobOutput()
        value.s3DataDestination = try reader["s3DataDestination"].readIfPresent(with: PersonalizeClientTypes.S3DataConfig.read(from:))
        return value
    }
}

extension PersonalizeClientTypes.DatasetGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DatasetGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DatasetGroup()
        value.name = try reader["name"].readIfPresent()
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.domain = try reader["domain"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.DatasetImportJob {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DatasetImportJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DatasetImportJob()
        value.jobName = try reader["jobName"].readIfPresent()
        value.datasetImportJobArn = try reader["datasetImportJobArn"].readIfPresent()
        value.datasetArn = try reader["datasetArn"].readIfPresent()
        value.dataSource = try reader["dataSource"].readIfPresent(with: PersonalizeClientTypes.DataSource.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.importMode = try reader["importMode"].readIfPresent()
        value.publishAttributionMetricsToS3 = try reader["publishAttributionMetricsToS3"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.EventTracker {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.EventTracker {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.EventTracker()
        value.name = try reader["name"].readIfPresent()
        value.eventTrackerArn = try reader["eventTrackerArn"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.trackingId = try reader["trackingId"].readIfPresent()
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PersonalizeClientTypes.FeatureTransformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.FeatureTransformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.FeatureTransformation()
        value.name = try reader["name"].readIfPresent()
        value.featureTransformationArn = try reader["featureTransformationArn"].readIfPresent()
        value.defaultParameters = try reader["defaultParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.Filter {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.Filter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.Filter()
        value.name = try reader["name"].readIfPresent()
        value.filterArn = try reader["filterArn"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.filterExpression = try reader["filterExpression"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.MetricAttribution {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.MetricAttribution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.MetricAttribution()
        value.name = try reader["name"].readIfPresent()
        value.metricAttributionArn = try reader["metricAttributionArn"].readIfPresent()
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.metricsOutputConfig = try reader["metricsOutputConfig"].readIfPresent(with: PersonalizeClientTypes.MetricAttributionOutput.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.MetricAttributionOutput {

    static func write(value: PersonalizeClientTypes.MetricAttributionOutput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleArn"].write(value.roleArn)
        try writer["s3DataDestination"].write(value.s3DataDestination, with: PersonalizeClientTypes.S3DataConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.MetricAttributionOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.MetricAttributionOutput()
        value.s3DataDestination = try reader["s3DataDestination"].readIfPresent(with: PersonalizeClientTypes.S3DataConfig.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension PersonalizeClientTypes.Recipe {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.Recipe {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.Recipe()
        value.name = try reader["name"].readIfPresent()
        value.recipeArn = try reader["recipeArn"].readIfPresent()
        value.algorithmArn = try reader["algorithmArn"].readIfPresent()
        value.featureTransformationArn = try reader["featureTransformationArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.recipeType = try reader["recipeType"].readIfPresent()
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PersonalizeClientTypes.Recommender {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.Recommender {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.Recommender()
        value.recommenderArn = try reader["recommenderArn"].readIfPresent()
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.recipeArn = try reader["recipeArn"].readIfPresent()
        value.recommenderConfig = try reader["recommenderConfig"].readIfPresent(with: PersonalizeClientTypes.RecommenderConfig.read(from:))
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.latestRecommenderUpdate = try reader["latestRecommenderUpdate"].readIfPresent(with: PersonalizeClientTypes.RecommenderUpdateSummary.read(from:))
        value.modelMetrics = try reader["modelMetrics"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PersonalizeClientTypes.RecommenderUpdateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.RecommenderUpdateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.RecommenderUpdateSummary()
        value.recommenderConfig = try reader["recommenderConfig"].readIfPresent(with: PersonalizeClientTypes.RecommenderConfig.read(from:))
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.RecommenderConfig {

    static func write(value: PersonalizeClientTypes.RecommenderConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enableMetadataWithRecommendations"].write(value.enableMetadataWithRecommendations)
        try writer["itemExplorationConfig"].writeMap(value.itemExplorationConfig, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["minRecommendationRequestsPerSecond"].write(value.minRecommendationRequestsPerSecond)
        try writer["trainingDataConfig"].write(value.trainingDataConfig, with: PersonalizeClientTypes.TrainingDataConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.RecommenderConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.RecommenderConfig()
        value.itemExplorationConfig = try reader["itemExplorationConfig"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.minRecommendationRequestsPerSecond = try reader["minRecommendationRequestsPerSecond"].readIfPresent()
        value.trainingDataConfig = try reader["trainingDataConfig"].readIfPresent(with: PersonalizeClientTypes.TrainingDataConfig.read(from:))
        value.enableMetadataWithRecommendations = try reader["enableMetadataWithRecommendations"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.TrainingDataConfig {

    static func write(value: PersonalizeClientTypes.TrainingDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["excludedDatasetColumns"].writeMap(value.excludedDatasetColumns, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.TrainingDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.TrainingDataConfig()
        value.excludedDatasetColumns = try reader["excludedDatasetColumns"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PersonalizeClientTypes.DatasetSchema {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DatasetSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DatasetSchema()
        value.name = try reader["name"].readIfPresent()
        value.schemaArn = try reader["schemaArn"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.domain = try reader["domain"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.Solution {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.Solution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.Solution()
        value.name = try reader["name"].readIfPresent()
        value.solutionArn = try reader["solutionArn"].readIfPresent()
        value.performHPO = try reader["performHPO"].readIfPresent() ?? false
        value.performAutoML = try reader["performAutoML"].readIfPresent() ?? false
        value.performAutoTraining = try reader["performAutoTraining"].readIfPresent()
        value.recipeArn = try reader["recipeArn"].readIfPresent()
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.eventType = try reader["eventType"].readIfPresent()
        value.solutionConfig = try reader["solutionConfig"].readIfPresent(with: PersonalizeClientTypes.SolutionConfig.read(from:))
        value.autoMLResult = try reader["autoMLResult"].readIfPresent(with: PersonalizeClientTypes.AutoMLResult.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.latestSolutionVersion = try reader["latestSolutionVersion"].readIfPresent(with: PersonalizeClientTypes.SolutionVersionSummary.read(from:))
        value.latestSolutionUpdate = try reader["latestSolutionUpdate"].readIfPresent(with: PersonalizeClientTypes.SolutionUpdateSummary.read(from:))
        return value
    }
}

extension PersonalizeClientTypes.SolutionUpdateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.SolutionUpdateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.SolutionUpdateSummary()
        value.solutionUpdateConfig = try reader["solutionUpdateConfig"].readIfPresent(with: PersonalizeClientTypes.SolutionUpdateConfig.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.performAutoTraining = try reader["performAutoTraining"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.SolutionUpdateConfig {

    static func write(value: PersonalizeClientTypes.SolutionUpdateConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoTrainingConfig"].write(value.autoTrainingConfig, with: PersonalizeClientTypes.AutoTrainingConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.SolutionUpdateConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.SolutionUpdateConfig()
        value.autoTrainingConfig = try reader["autoTrainingConfig"].readIfPresent(with: PersonalizeClientTypes.AutoTrainingConfig.read(from:))
        return value
    }
}

extension PersonalizeClientTypes.AutoTrainingConfig {

    static func write(value: PersonalizeClientTypes.AutoTrainingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["schedulingExpression"].write(value.schedulingExpression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.AutoTrainingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.AutoTrainingConfig()
        value.schedulingExpression = try reader["schedulingExpression"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.SolutionVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.SolutionVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.SolutionVersionSummary()
        value.solutionVersionArn = try reader["solutionVersionArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.trainingMode = try reader["trainingMode"].readIfPresent()
        value.trainingType = try reader["trainingType"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.AutoMLResult {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.AutoMLResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.AutoMLResult()
        value.bestRecipeArn = try reader["bestRecipeArn"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.SolutionConfig {

    static func write(value: PersonalizeClientTypes.SolutionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["algorithmHyperParameters"].writeMap(value.algorithmHyperParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["autoMLConfig"].write(value.autoMLConfig, with: PersonalizeClientTypes.AutoMLConfig.write(value:to:))
        try writer["autoTrainingConfig"].write(value.autoTrainingConfig, with: PersonalizeClientTypes.AutoTrainingConfig.write(value:to:))
        try writer["eventValueThreshold"].write(value.eventValueThreshold)
        try writer["featureTransformationParameters"].writeMap(value.featureTransformationParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["hpoConfig"].write(value.hpoConfig, with: PersonalizeClientTypes.HPOConfig.write(value:to:))
        try writer["optimizationObjective"].write(value.optimizationObjective, with: PersonalizeClientTypes.OptimizationObjective.write(value:to:))
        try writer["trainingDataConfig"].write(value.trainingDataConfig, with: PersonalizeClientTypes.TrainingDataConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.SolutionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.SolutionConfig()
        value.eventValueThreshold = try reader["eventValueThreshold"].readIfPresent()
        value.hpoConfig = try reader["hpoConfig"].readIfPresent(with: PersonalizeClientTypes.HPOConfig.read(from:))
        value.algorithmHyperParameters = try reader["algorithmHyperParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.featureTransformationParameters = try reader["featureTransformationParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.autoMLConfig = try reader["autoMLConfig"].readIfPresent(with: PersonalizeClientTypes.AutoMLConfig.read(from:))
        value.optimizationObjective = try reader["optimizationObjective"].readIfPresent(with: PersonalizeClientTypes.OptimizationObjective.read(from:))
        value.trainingDataConfig = try reader["trainingDataConfig"].readIfPresent(with: PersonalizeClientTypes.TrainingDataConfig.read(from:))
        value.autoTrainingConfig = try reader["autoTrainingConfig"].readIfPresent(with: PersonalizeClientTypes.AutoTrainingConfig.read(from:))
        return value
    }
}

extension PersonalizeClientTypes.OptimizationObjective {

    static func write(value: PersonalizeClientTypes.OptimizationObjective?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["itemAttribute"].write(value.itemAttribute)
        try writer["objectiveSensitivity"].write(value.objectiveSensitivity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.OptimizationObjective {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.OptimizationObjective()
        value.itemAttribute = try reader["itemAttribute"].readIfPresent()
        value.objectiveSensitivity = try reader["objectiveSensitivity"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.AutoMLConfig {

    static func write(value: PersonalizeClientTypes.AutoMLConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metricName"].write(value.metricName)
        try writer["recipeList"].writeList(value.recipeList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.AutoMLConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.AutoMLConfig()
        value.metricName = try reader["metricName"].readIfPresent()
        value.recipeList = try reader["recipeList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PersonalizeClientTypes.HPOConfig {

    static func write(value: PersonalizeClientTypes.HPOConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["algorithmHyperParameterRanges"].write(value.algorithmHyperParameterRanges, with: PersonalizeClientTypes.HyperParameterRanges.write(value:to:))
        try writer["hpoObjective"].write(value.hpoObjective, with: PersonalizeClientTypes.HPOObjective.write(value:to:))
        try writer["hpoResourceConfig"].write(value.hpoResourceConfig, with: PersonalizeClientTypes.HPOResourceConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.HPOConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.HPOConfig()
        value.hpoObjective = try reader["hpoObjective"].readIfPresent(with: PersonalizeClientTypes.HPOObjective.read(from:))
        value.hpoResourceConfig = try reader["hpoResourceConfig"].readIfPresent(with: PersonalizeClientTypes.HPOResourceConfig.read(from:))
        value.algorithmHyperParameterRanges = try reader["algorithmHyperParameterRanges"].readIfPresent(with: PersonalizeClientTypes.HyperParameterRanges.read(from:))
        return value
    }
}

extension PersonalizeClientTypes.HyperParameterRanges {

    static func write(value: PersonalizeClientTypes.HyperParameterRanges?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["categoricalHyperParameterRanges"].writeList(value.categoricalHyperParameterRanges, memberWritingClosure: PersonalizeClientTypes.CategoricalHyperParameterRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["continuousHyperParameterRanges"].writeList(value.continuousHyperParameterRanges, memberWritingClosure: PersonalizeClientTypes.ContinuousHyperParameterRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["integerHyperParameterRanges"].writeList(value.integerHyperParameterRanges, memberWritingClosure: PersonalizeClientTypes.IntegerHyperParameterRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.HyperParameterRanges {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.HyperParameterRanges()
        value.integerHyperParameterRanges = try reader["integerHyperParameterRanges"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.IntegerHyperParameterRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.continuousHyperParameterRanges = try reader["continuousHyperParameterRanges"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.ContinuousHyperParameterRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.categoricalHyperParameterRanges = try reader["categoricalHyperParameterRanges"].readListIfPresent(memberReadingClosure: PersonalizeClientTypes.CategoricalHyperParameterRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PersonalizeClientTypes.CategoricalHyperParameterRange {

    static func write(value: PersonalizeClientTypes.CategoricalHyperParameterRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.CategoricalHyperParameterRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.CategoricalHyperParameterRange()
        value.name = try reader["name"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PersonalizeClientTypes.ContinuousHyperParameterRange {

    static func write(value: PersonalizeClientTypes.ContinuousHyperParameterRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxValue"].write(value.maxValue)
        try writer["minValue"].write(value.minValue)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.ContinuousHyperParameterRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.ContinuousHyperParameterRange()
        value.name = try reader["name"].readIfPresent()
        value.minValue = try reader["minValue"].readIfPresent() ?? 0
        value.maxValue = try reader["maxValue"].readIfPresent() ?? 0
        return value
    }
}

extension PersonalizeClientTypes.IntegerHyperParameterRange {

    static func write(value: PersonalizeClientTypes.IntegerHyperParameterRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxValue"].write(value.maxValue)
        try writer["minValue"].write(value.minValue)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.IntegerHyperParameterRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.IntegerHyperParameterRange()
        value.name = try reader["name"].readIfPresent()
        value.minValue = try reader["minValue"].readIfPresent() ?? 0
        value.maxValue = try reader["maxValue"].readIfPresent() ?? 0
        return value
    }
}

extension PersonalizeClientTypes.HPOResourceConfig {

    static func write(value: PersonalizeClientTypes.HPOResourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxNumberOfTrainingJobs"].write(value.maxNumberOfTrainingJobs)
        try writer["maxParallelTrainingJobs"].write(value.maxParallelTrainingJobs)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.HPOResourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.HPOResourceConfig()
        value.maxNumberOfTrainingJobs = try reader["maxNumberOfTrainingJobs"].readIfPresent()
        value.maxParallelTrainingJobs = try reader["maxParallelTrainingJobs"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.HPOObjective {

    static func write(value: PersonalizeClientTypes.HPOObjective?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metricName"].write(value.metricName)
        try writer["metricRegex"].write(value.metricRegex)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.HPOObjective {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.HPOObjective()
        value.type = try reader["type"].readIfPresent()
        value.metricName = try reader["metricName"].readIfPresent()
        value.metricRegex = try reader["metricRegex"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.SolutionVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.SolutionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.SolutionVersion()
        value.name = try reader["name"].readIfPresent()
        value.solutionVersionArn = try reader["solutionVersionArn"].readIfPresent()
        value.solutionArn = try reader["solutionArn"].readIfPresent()
        value.performHPO = try reader["performHPO"].readIfPresent() ?? false
        value.performAutoML = try reader["performAutoML"].readIfPresent() ?? false
        value.recipeArn = try reader["recipeArn"].readIfPresent()
        value.eventType = try reader["eventType"].readIfPresent()
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.solutionConfig = try reader["solutionConfig"].readIfPresent(with: PersonalizeClientTypes.SolutionConfig.read(from:))
        value.trainingHours = try reader["trainingHours"].readIfPresent()
        value.trainingMode = try reader["trainingMode"].readIfPresent()
        value.tunedHPOParams = try reader["tunedHPOParams"].readIfPresent(with: PersonalizeClientTypes.TunedHPOParams.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.trainingType = try reader["trainingType"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.TunedHPOParams {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.TunedHPOParams {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.TunedHPOParams()
        value.algorithmHyperParameters = try reader["algorithmHyperParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PersonalizeClientTypes.BatchInferenceJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.BatchInferenceJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.BatchInferenceJobSummary()
        value.batchInferenceJobArn = try reader["batchInferenceJobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.solutionVersionArn = try reader["solutionVersionArn"].readIfPresent()
        value.batchInferenceJobMode = try reader["batchInferenceJobMode"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.BatchSegmentJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.BatchSegmentJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.BatchSegmentJobSummary()
        value.batchSegmentJobArn = try reader["batchSegmentJobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.solutionVersionArn = try reader["solutionVersionArn"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.CampaignSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.CampaignSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.CampaignSummary()
        value.name = try reader["name"].readIfPresent()
        value.campaignArn = try reader["campaignArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.DataDeletionJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DataDeletionJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DataDeletionJobSummary()
        value.dataDeletionJobArn = try reader["dataDeletionJobArn"].readIfPresent()
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.DatasetExportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DatasetExportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DatasetExportJobSummary()
        value.datasetExportJobArn = try reader["datasetExportJobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.DatasetGroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DatasetGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DatasetGroupSummary()
        value.name = try reader["name"].readIfPresent()
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.domain = try reader["domain"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.DatasetImportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DatasetImportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DatasetImportJobSummary()
        value.datasetImportJobArn = try reader["datasetImportJobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.importMode = try reader["importMode"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.DatasetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DatasetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DatasetSummary()
        value.name = try reader["name"].readIfPresent()
        value.datasetArn = try reader["datasetArn"].readIfPresent()
        value.datasetType = try reader["datasetType"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PersonalizeClientTypes.EventTrackerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.EventTrackerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.EventTrackerSummary()
        value.name = try reader["name"].readIfPresent()
        value.eventTrackerArn = try reader["eventTrackerArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PersonalizeClientTypes.FilterSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.FilterSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.FilterSummary()
        value.name = try reader["name"].readIfPresent()
        value.filterArn = try reader["filterArn"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.MetricAttribute {

    static func write(value: PersonalizeClientTypes.MetricAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventType"].write(value.eventType)
        try writer["expression"].write(value.expression)
        try writer["metricName"].write(value.metricName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.MetricAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.MetricAttribute()
        value.eventType = try reader["eventType"].readIfPresent() ?? ""
        value.metricName = try reader["metricName"].readIfPresent() ?? ""
        value.expression = try reader["expression"].readIfPresent() ?? ""
        return value
    }
}

extension PersonalizeClientTypes.MetricAttributionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.MetricAttributionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.MetricAttributionSummary()
        value.name = try reader["name"].readIfPresent()
        value.metricAttributionArn = try reader["metricAttributionArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["failureReason"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.RecipeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.RecipeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.RecipeSummary()
        value.name = try reader["name"].readIfPresent()
        value.recipeArn = try reader["recipeArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.domain = try reader["domain"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.RecommenderSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.RecommenderSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.RecommenderSummary()
        value.name = try reader["name"].readIfPresent()
        value.recommenderArn = try reader["recommenderArn"].readIfPresent()
        value.datasetGroupArn = try reader["datasetGroupArn"].readIfPresent()
        value.recipeArn = try reader["recipeArn"].readIfPresent()
        value.recommenderConfig = try reader["recommenderConfig"].readIfPresent(with: PersonalizeClientTypes.RecommenderConfig.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PersonalizeClientTypes.DatasetSchemaSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.DatasetSchemaSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.DatasetSchemaSummary()
        value.name = try reader["name"].readIfPresent()
        value.schemaArn = try reader["schemaArn"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.domain = try reader["domain"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.SolutionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.SolutionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.SolutionSummary()
        value.name = try reader["name"].readIfPresent()
        value.solutionArn = try reader["solutionArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDateTime = try reader["lastUpdatedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.recipeArn = try reader["recipeArn"].readIfPresent()
        return value
    }
}

extension PersonalizeClientTypes.Tag {

    static func write(value: PersonalizeClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tagKey"].write(value.tagKey)
        try writer["tagValue"].write(value.tagValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PersonalizeClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PersonalizeClientTypes.Tag()
        value.tagKey = try reader["tagKey"].readIfPresent() ?? ""
        value.tagValue = try reader["tagValue"].readIfPresent() ?? ""
        return value
    }
}

public enum PersonalizeClientTypes {}
