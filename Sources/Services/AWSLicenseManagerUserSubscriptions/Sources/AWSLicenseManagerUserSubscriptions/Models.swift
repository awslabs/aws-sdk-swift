//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Contains a credentials secret that's stored in Secrets Manager.
    public struct SecretsManagerCredentialsProvider: Swift.Sendable {
        /// The ID of the Secrets Manager secret that contains credentials.
        public var secretId: Swift.String?

        public init(
            secretId: Swift.String? = nil
        ) {
            self.secretId = secretId
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Contains information about the credential provider for user administration.
    public enum CredentialsProvider: Swift.Sendable {
        /// Identifies the Secrets Manager secret that contains credentials needed for user administration in the Active Directory.
        case secretsmanagercredentialsprovider(LicenseManagerUserSubscriptionsClientTypes.SecretsManagerCredentialsProvider)
        case sdkUnknown(Swift.String)
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Contains network settings for the Active Directory domain.
    public struct DomainNetworkSettings: Swift.Sendable {
        /// Contains a list of subnets that apply for the Active Directory domain.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init(
            subnets: [Swift.String]? = nil
        ) {
            self.subnets = subnets
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Contains network access and credential details that are needed for user administration in the Active Directory.
    public struct ActiveDirectorySettings: Swift.Sendable {
        /// Points to the CredentialsProvider resource that contains information about the credential provider for user administration.
        public var domainCredentialsProvider: LicenseManagerUserSubscriptionsClientTypes.CredentialsProvider?
        /// A list of domain IPv4 addresses that are used for the Active Directory.
        public var domainIpv4List: [Swift.String]?
        /// The domain name for the Active Directory.
        public var domainName: Swift.String?
        /// The DomainNetworkSettings resource contains an array of subnets that apply for the Active Directory.
        public var domainNetworkSettings: LicenseManagerUserSubscriptionsClientTypes.DomainNetworkSettings?

        public init(
            domainCredentialsProvider: LicenseManagerUserSubscriptionsClientTypes.CredentialsProvider? = nil,
            domainIpv4List: [Swift.String]? = nil,
            domainName: Swift.String? = nil,
            domainNetworkSettings: LicenseManagerUserSubscriptionsClientTypes.DomainNetworkSettings? = nil
        ) {
            self.domainCredentialsProvider = domainCredentialsProvider
            self.domainIpv4List = domainIpv4List
            self.domainName = domainName
            self.domainNetworkSettings = domainNetworkSettings
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    public enum ActiveDirectoryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// AWS_MANAGED type of Active Directory
        case awsManaged
        /// SELF_MANAGED type of Active Directory
        case selfManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [ActiveDirectoryType] {
            return [
                .awsManaged,
                .selfManaged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "AWS_MANAGED"
            case .selfManaged: return "SELF_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Details about an Active Directory identity provider.
    public struct ActiveDirectoryIdentityProvider: Swift.Sendable {
        /// The ActiveDirectorySettings resource contains details about the Active Directory, including network access details such as domain name and IP addresses, and the credential provider for user administration.
        public var activeDirectorySettings: LicenseManagerUserSubscriptionsClientTypes.ActiveDirectorySettings?
        /// The type of Active Directory – either a self-managed Active Directory or an Amazon Web Services Managed Active Directory.
        public var activeDirectoryType: LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryType?
        /// The directory ID for an Active Directory identity provider.
        public var directoryId: Swift.String?
        /// Whether this directory is shared from an Amazon Web Services Managed Active Directory. The default value is false.
        public var isSharedActiveDirectory: Swift.Bool?

        public init(
            activeDirectorySettings: LicenseManagerUserSubscriptionsClientTypes.ActiveDirectorySettings? = nil,
            activeDirectoryType: LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryType? = nil,
            directoryId: Swift.String? = nil,
            isSharedActiveDirectory: Swift.Bool? = nil
        ) {
            self.activeDirectorySettings = activeDirectorySettings
            self.activeDirectoryType = activeDirectoryType
            self.directoryId = directoryId
            self.isSharedActiveDirectory = isSharedActiveDirectory
        }
    }
}

/// The request couldn't be completed because it conflicted with the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// An exception occurred with the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The resource couldn't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request failed because a service quota is exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied because of request throttling. Retry the request.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// A parameter is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Refers to an identity provider.
    public enum IdentityProvider: Swift.Sendable {
        /// The ActiveDirectoryIdentityProvider resource contains settings and other details about a specific Active Directory identity provider.
        case activedirectoryidentityprovider(LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider)
        case sdkUnknown(Swift.String)
    }
}

public struct AssociateUserInput: Swift.Sendable {
    /// The domain name of the Active Directory that contains information for the user to associate.
    public var domain: Swift.String?
    /// The identity provider for the user.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The ID of the EC2 instance that provides the user-based subscription.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The tags that apply for the user association.
    public var tags: [Swift.String: Swift.String]?
    /// The user name from the identity provider.
    /// This member is required.
    public var username: Swift.String?

    public init(
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        instanceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        username: Swift.String? = nil
    ) {
        self.domain = domain
        self.identityProvider = identityProvider
        self.instanceId = instanceId
        self.tags = tags
        self.username = username
    }
}

extension AssociateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateUserInput(domain: \(Swift.String(describing: domain)), identityProvider: \(Swift.String(describing: identityProvider)), instanceId: \(Swift.String(describing: instanceId)), username: \(Swift.String(describing: username)), tags: \"CONTENT_REDACTED\")"}
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Describes users of an EC2 instance providing user-based subscriptions.
    public struct InstanceUserSummary: Swift.Sendable {
        /// The date a user was associated with an EC2 instance.
        public var associationDate: Swift.String?
        /// The date a user was disassociated from an EC2 instance.
        public var disassociationDate: Swift.String?
        /// The domain name of the Active Directory that contains the user information for the product subscription.
        public var domain: Swift.String?
        /// The IdentityProvider resource specifies details about the identity provider.
        /// This member is required.
        public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
        /// The ID of the EC2 instance that provides user-based subscriptions.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The Amazon Resource Name (ARN) that identifies the instance user.
        public var instanceUserArn: Swift.String?
        /// The status of a user associated with an EC2 instance.
        /// This member is required.
        public var status: Swift.String?
        /// The status message for users of an EC2 instance.
        public var statusMessage: Swift.String?
        /// The user name from the identity provider for the user.
        /// This member is required.
        public var username: Swift.String?

        public init(
            associationDate: Swift.String? = nil,
            disassociationDate: Swift.String? = nil,
            domain: Swift.String? = nil,
            identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
            instanceId: Swift.String? = nil,
            instanceUserArn: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            username: Swift.String? = nil
        ) {
            self.associationDate = associationDate
            self.disassociationDate = disassociationDate
            self.domain = domain
            self.identityProvider = identityProvider
            self.instanceId = instanceId
            self.instanceUserArn = instanceUserArn
            self.status = status
            self.statusMessage = statusMessage
            self.username = username
        }
    }
}

public struct AssociateUserOutput: Swift.Sendable {
    /// Metadata that describes the associate user operation.
    /// This member is required.
    public var instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?

    public init(
        instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary? = nil
    ) {
        self.instanceUserSummary = instanceUserSummary
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Server settings that are specific to a Remote Desktop Services (RDS) license server.
    public struct RdsSalSettings: Swift.Sendable {
        /// The CredentialsProvider resource contains a reference to the credentials provider that's used for RDS license server user administration.
        /// This member is required.
        public var rdsSalCredentialsProvider: LicenseManagerUserSubscriptionsClientTypes.CredentialsProvider?

        public init(
            rdsSalCredentialsProvider: LicenseManagerUserSubscriptionsClientTypes.CredentialsProvider? = nil
        ) {
            self.rdsSalCredentialsProvider = rdsSalCredentialsProvider
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Contains settings for a specific server.
    public enum ServerSettings: Swift.Sendable {
        /// The RdsSalSettings resource contains settings to configure a specific Remote Desktop Services (RDS) license server.
        case rdssalsettings(LicenseManagerUserSubscriptionsClientTypes.RdsSalSettings)
        case sdkUnknown(Swift.String)
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    public enum ServerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        ///
        case rdsSal
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerType] {
            return [
                .rdsSal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .rdsSal: return "RDS_SAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// The settings to configure your license server.
    public struct LicenseServerSettings: Swift.Sendable {
        /// The ServerSettings resource contains the settings for your server.
        /// This member is required.
        public var serverSettings: LicenseManagerUserSubscriptionsClientTypes.ServerSettings?
        /// The type of license server.
        /// This member is required.
        public var serverType: LicenseManagerUserSubscriptionsClientTypes.ServerType?

        public init(
            serverSettings: LicenseManagerUserSubscriptionsClientTypes.ServerSettings? = nil,
            serverType: LicenseManagerUserSubscriptionsClientTypes.ServerType? = nil
        ) {
            self.serverSettings = serverSettings
            self.serverType = serverType
        }
    }
}

public struct CreateLicenseServerEndpointInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that identifies the IdentityProvider resource that contains details about a registered identity provider. In the case of Active Directory, that can be a self-managed Active Directory or an Amazon Web Services Managed Active Directory that contains user identity details.
    /// This member is required.
    public var identityProviderArn: Swift.String?
    /// The LicenseServerSettings resource to create for the endpoint. The settings include the type of license server and the Secrets Manager secret that enables administrators to add or remove users associated with the license server.
    /// This member is required.
    public var licenseServerSettings: LicenseManagerUserSubscriptionsClientTypes.LicenseServerSettings?
    /// The tags that apply for the license server endpoint.
    public var tags: [Swift.String: Swift.String]?

    public init(
        identityProviderArn: Swift.String? = nil,
        licenseServerSettings: LicenseManagerUserSubscriptionsClientTypes.LicenseServerSettings? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.identityProviderArn = identityProviderArn
        self.licenseServerSettings = licenseServerSettings
        self.tags = tags
    }
}

extension CreateLicenseServerEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLicenseServerEndpointInput(identityProviderArn: \(Swift.String(describing: identityProviderArn)), licenseServerSettings: \(Swift.String(describing: licenseServerSettings)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateLicenseServerEndpointOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the identity provider specified in the request.
    public var identityProviderArn: Swift.String?
    /// The ARN of the LicenseServerEndpoint resource.
    public var licenseServerEndpointArn: Swift.String?

    public init(
        identityProviderArn: Swift.String? = nil,
        licenseServerEndpointArn: Swift.String? = nil
    ) {
        self.identityProviderArn = identityProviderArn
        self.licenseServerEndpointArn = licenseServerEndpointArn
    }
}

public struct DeleteLicenseServerEndpointInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that identifies the LicenseServerEndpoint resource to delete.
    /// This member is required.
    public var licenseServerEndpointArn: Swift.String?
    /// The type of License Server that the delete request refers to.
    /// This member is required.
    public var serverType: LicenseManagerUserSubscriptionsClientTypes.ServerType?

    public init(
        licenseServerEndpointArn: Swift.String? = nil,
        serverType: LicenseManagerUserSubscriptionsClientTypes.ServerType? = nil
    ) {
        self.licenseServerEndpointArn = licenseServerEndpointArn
        self.serverType = serverType
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    public enum LicenseServerEndpointProvisioningStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        ///
        case deleted
        ///
        case deleting
        ///
        case deletionFailed
        ///
        case provisioned
        ///
        case provisioning
        ///
        case provisioningFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseServerEndpointProvisioningStatus] {
            return [
                .deleted,
                .deleting,
                .deletionFailed,
                .provisioned,
                .provisioning,
                .provisioningFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .deletionFailed: return "DELETION_FAILED"
            case .provisioned: return "PROVISIONED"
            case .provisioning: return "PROVISIONING"
            case .provisioningFailed: return "PROVISIONING_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    public enum LicenseServerHealthStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        ///
        case healthy
        ///
        case notApplicable
        ///
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseServerHealthStatus] {
            return [
                .healthy,
                .notApplicable,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .notApplicable: return "NOT_APPLICABLE"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Information about a Remote Desktop Services (RDS) license server.
    public struct LicenseServer: Swift.Sendable {
        /// The health status of the RDS license server.
        public var healthStatus: LicenseManagerUserSubscriptionsClientTypes.LicenseServerHealthStatus?
        /// A list of domain IPv4 addresses that are used for the RDS license server.
        public var ipv4Address: Swift.String?
        /// The current state of the provisioning process for the RDS license server.
        public var provisioningStatus: LicenseManagerUserSubscriptionsClientTypes.LicenseServerEndpointProvisioningStatus?

        public init(
            healthStatus: LicenseManagerUserSubscriptionsClientTypes.LicenseServerHealthStatus? = nil,
            ipv4Address: Swift.String? = nil,
            provisioningStatus: LicenseManagerUserSubscriptionsClientTypes.LicenseServerEndpointProvisioningStatus? = nil
        ) {
            self.healthStatus = healthStatus
            self.ipv4Address = ipv4Address
            self.provisioningStatus = provisioningStatus
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// A network endpoint through which you can access one or more servers.
    public struct ServerEndpoint: Swift.Sendable {
        /// The network address of the endpoint.
        public var endpoint: Swift.String?

        public init(
            endpoint: Swift.String? = nil
        ) {
            self.endpoint = endpoint
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Contains details about a network endpoint for a Remote Desktop Services (RDS) license server.
    public struct LicenseServerEndpoint: Swift.Sendable {
        /// The timestamp when License Manager created the license server endpoint.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the identity provider that's associated with the RDS license server endpoint.
        public var identityProviderArn: Swift.String?
        /// The ARN of the ServerEndpoint resource for the RDS license server.
        public var licenseServerEndpointArn: Swift.String?
        /// The ID of the license server endpoint.
        public var licenseServerEndpointId: Swift.String?
        /// The current state of the provisioning process for the RDS license server endpoint
        public var licenseServerEndpointProvisioningStatus: LicenseManagerUserSubscriptionsClientTypes.LicenseServerEndpointProvisioningStatus?
        /// An array of LicenseServer resources that represent the license servers that are accessed through this endpoint.
        public var licenseServers: [LicenseManagerUserSubscriptionsClientTypes.LicenseServer]?
        /// The ServerEndpoint resource contains the network address of the RDS license server endpoint.
        public var serverEndpoint: LicenseManagerUserSubscriptionsClientTypes.ServerEndpoint?
        /// The type of license server.
        public var serverType: LicenseManagerUserSubscriptionsClientTypes.ServerType?
        /// The message associated with the provisioning status, if there is one.
        public var statusMessage: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            identityProviderArn: Swift.String? = nil,
            licenseServerEndpointArn: Swift.String? = nil,
            licenseServerEndpointId: Swift.String? = nil,
            licenseServerEndpointProvisioningStatus: LicenseManagerUserSubscriptionsClientTypes.LicenseServerEndpointProvisioningStatus? = nil,
            licenseServers: [LicenseManagerUserSubscriptionsClientTypes.LicenseServer]? = nil,
            serverEndpoint: LicenseManagerUserSubscriptionsClientTypes.ServerEndpoint? = nil,
            serverType: LicenseManagerUserSubscriptionsClientTypes.ServerType? = nil,
            statusMessage: Swift.String? = nil
        ) {
            self.creationTime = creationTime
            self.identityProviderArn = identityProviderArn
            self.licenseServerEndpointArn = licenseServerEndpointArn
            self.licenseServerEndpointId = licenseServerEndpointId
            self.licenseServerEndpointProvisioningStatus = licenseServerEndpointProvisioningStatus
            self.licenseServers = licenseServers
            self.serverEndpoint = serverEndpoint
            self.serverType = serverType
            self.statusMessage = statusMessage
        }
    }
}

public struct DeleteLicenseServerEndpointOutput: Swift.Sendable {
    /// Shows details from the LicenseServerEndpoint resource that was deleted.
    public var licenseServerEndpoint: LicenseManagerUserSubscriptionsClientTypes.LicenseServerEndpoint?

    public init(
        licenseServerEndpoint: LicenseManagerUserSubscriptionsClientTypes.LicenseServerEndpoint? = nil
    ) {
        self.licenseServerEndpoint = licenseServerEndpoint
    }
}

public struct DeregisterIdentityProviderInput: Swift.Sendable {
    /// An object that specifies details for the Active Directory identity provider.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The Amazon Resource Name (ARN) that identifies the identity provider to deregister.
    public var identityProviderArn: Swift.String?
    /// The name of the user-based subscription product. Valid values: VISUAL_STUDIO_ENTERPRISE | VISUAL_STUDIO_PROFESSIONAL | OFFICE_PROFESSIONAL_PLUS | REMOTE_DESKTOP_SERVICES
    public var product: Swift.String?

    public init(
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        identityProviderArn: Swift.String? = nil,
        product: Swift.String? = nil
    ) {
        self.identityProvider = identityProvider
        self.identityProviderArn = identityProviderArn
        self.product = product
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// The registered identity provider’s product related configuration settings such as the subnets to provision VPC endpoints, and the security group ID that is associated with the VPC endpoints. The security group should permit inbound TCP port 1688 communication from resources in the VPC.
    public struct Settings: Swift.Sendable {
        /// A security group ID that allows inbound TCP port 1688 communication between resources in your VPC and the VPC endpoint for activation servers.
        /// This member is required.
        public var securityGroupId: Swift.String?
        /// The subnets defined for the registered identity provider.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init(
            securityGroupId: Swift.String? = nil,
            subnets: [Swift.String]? = nil
        ) {
            self.securityGroupId = securityGroupId
            self.subnets = subnets
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Describes an identity provider.
    public struct IdentityProviderSummary: Swift.Sendable {
        /// The failure message associated with an identity provider.
        public var failureMessage: Swift.String?
        /// The IdentityProvider resource contains information about an identity provider.
        /// This member is required.
        public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
        /// The Amazon Resource Name (ARN) of the identity provider.
        public var identityProviderArn: Swift.String?
        /// The AWS Account ID of the owner of this resource.
        public var ownerAccountId: Swift.String?
        /// The name of the user-based subscription product.
        /// This member is required.
        public var product: Swift.String?
        /// The Settings resource contains details about the registered identity provider’s product related configuration settings, such as the subnets to provision VPC endpoints.
        /// This member is required.
        public var settings: LicenseManagerUserSubscriptionsClientTypes.Settings?
        /// The status of the identity provider.
        /// This member is required.
        public var status: Swift.String?

        public init(
            failureMessage: Swift.String? = nil,
            identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
            identityProviderArn: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            product: Swift.String? = nil,
            settings: LicenseManagerUserSubscriptionsClientTypes.Settings? = nil,
            status: Swift.String? = nil
        ) {
            self.failureMessage = failureMessage
            self.identityProvider = identityProvider
            self.identityProviderArn = identityProviderArn
            self.ownerAccountId = ownerAccountId
            self.product = product
            self.settings = settings
            self.status = status
        }
    }
}

public struct DeregisterIdentityProviderOutput: Swift.Sendable {
    /// Metadata that describes the results of an identity provider operation.
    /// This member is required.
    public var identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?

    public init(
        identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary? = nil
    ) {
        self.identityProviderSummary = identityProviderSummary
    }
}

public struct DisassociateUserInput: Swift.Sendable {
    /// The domain name of the Active Directory that contains information for the user to disassociate.
    public var domain: Swift.String?
    /// An object that specifies details for the Active Directory identity provider.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The ID of the EC2 instance which provides user-based subscriptions.
    public var instanceId: Swift.String?
    /// The Amazon Resource Name (ARN) of the user to disassociate from the EC2 instance.
    public var instanceUserArn: Swift.String?
    /// The user name from the Active Directory identity provider for the user.
    public var username: Swift.String?

    public init(
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        instanceId: Swift.String? = nil,
        instanceUserArn: Swift.String? = nil,
        username: Swift.String? = nil
    ) {
        self.domain = domain
        self.identityProvider = identityProvider
        self.instanceId = instanceId
        self.instanceUserArn = instanceUserArn
        self.username = username
    }
}

public struct DisassociateUserOutput: Swift.Sendable {
    /// Metadata that describes the associate user operation.
    /// This member is required.
    public var instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?

    public init(
        instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary? = nil
    ) {
        self.instanceUserSummary = instanceUserSummary
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// A filter name and value pair that is used to return more specific results from a describe or list operation. You can use filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs.
    public struct Filter: Swift.Sendable {
        /// The name of an attribute to use as a filter.
        public var attribute: Swift.String?
        /// The type of search (For example, eq, geq, leq)
        public var operation: Swift.String?
        /// Value of the filter.
        public var value: Swift.String?

        public init(
            attribute: Swift.String? = nil,
            operation: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.attribute = attribute
            self.operation = operation
            self.value = value
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Describes an EC2 instance providing user-based subscriptions.
    public struct InstanceSummary: Swift.Sendable {
        /// The IdentityProvider resource specifies details about the identity provider.
        public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
        /// The ID of the EC2 instance, which provides user-based subscriptions.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The date of the last status check.
        public var lastStatusCheckDate: Swift.String?
        /// The AWS Account ID of the owner of this resource.
        public var ownerAccountId: Swift.String?
        /// A list of provided user-based subscription products.
        /// This member is required.
        public var products: [Swift.String]?
        /// The status of an EC2 instance resource.
        /// This member is required.
        public var status: Swift.String?
        /// The status message for an EC2 instance.
        public var statusMessage: Swift.String?

        public init(
            identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
            instanceId: Swift.String? = nil,
            lastStatusCheckDate: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            products: [Swift.String]? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        ) {
            self.identityProvider = identityProvider
            self.instanceId = instanceId
            self.lastStatusCheckDate = lastStatusCheckDate
            self.ownerAccountId = ownerAccountId
            self.products = products
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct ListIdentityProvidersInput: Swift.Sendable {
    /// You can use the following filters to streamline results:
    ///
    /// * Product
    ///
    /// * DirectoryId
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// The maximum number of results to return from a single request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListIdentityProvidersOutput: Swift.Sendable {
    /// An array of IdentityProviderSummary resources that contain details about the Active Directory identity providers that meet the request criteria.
    /// This member is required.
    public var identityProviderSummaries: [LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?

    public init(
        identityProviderSummaries: [LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.identityProviderSummaries = identityProviderSummaries
        self.nextToken = nextToken
    }
}

public struct ListInstancesInput: Swift.Sendable {
    /// You can use the following filters to streamline results:
    ///
    /// * Status
    ///
    /// * InstanceId
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// The maximum number of results to return from a single request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListInstancesOutput: Swift.Sendable {
    /// An array of InstanceSummary resources that contain details about the instances that provide user-based subscriptions and also meet the request criteria.
    public var instanceSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?

    public init(
        instanceSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.instanceSummaries = instanceSummaries
        self.nextToken = nextToken
    }
}

public struct ListLicenseServerEndpointsInput: Swift.Sendable {
    /// You can use the following filters to streamline results:
    ///
    /// * IdentityProviderArn
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// The maximum number of results to return from a single request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListLicenseServerEndpointsOutput: Swift.Sendable {
    /// An array of LicenseServerEndpoint resources that contain detailed information about the RDS License Servers that meet the request criteria.
    public var licenseServerEndpoints: [LicenseManagerUserSubscriptionsClientTypes.LicenseServerEndpoint]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?

    public init(
        licenseServerEndpoints: [LicenseManagerUserSubscriptionsClientTypes.LicenseServerEndpoint]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.licenseServerEndpoints = licenseServerEndpoints
        self.nextToken = nextToken
    }
}

public struct ListProductSubscriptionsInput: Swift.Sendable {
    /// You can use the following filters to streamline results:
    ///
    /// * Status
    ///
    /// * Username
    ///
    /// * Domain
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The maximum number of results to return from a single request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The name of the user-based subscription product. Valid values: VISUAL_STUDIO_ENTERPRISE | VISUAL_STUDIO_PROFESSIONAL | OFFICE_PROFESSIONAL_PLUS | REMOTE_DESKTOP_SERVICES
    public var product: Swift.String?

    public init(
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        product: Swift.String? = nil
    ) {
        self.filters = filters
        self.identityProvider = identityProvider
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.product = product
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// A summary of the user-based subscription products for a specific user.
    public struct ProductUserSummary: Swift.Sendable {
        /// The domain name of the Active Directory that contains the user information for the product subscription.
        public var domain: Swift.String?
        /// An object that specifies details for the identity provider.
        /// This member is required.
        public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
        /// The name of the user-based subscription product.
        /// This member is required.
        public var product: Swift.String?
        /// The Amazon Resource Name (ARN) for this product user.
        public var productUserArn: Swift.String?
        /// The status of a product for this user.
        /// This member is required.
        public var status: Swift.String?
        /// The status message for a product for this user.
        public var statusMessage: Swift.String?
        /// The end date of a subscription.
        public var subscriptionEndDate: Swift.String?
        /// The start date of a subscription.
        public var subscriptionStartDate: Swift.String?
        /// The user name from the identity provider for this product user.
        /// This member is required.
        public var username: Swift.String?

        public init(
            domain: Swift.String? = nil,
            identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
            product: Swift.String? = nil,
            productUserArn: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            subscriptionEndDate: Swift.String? = nil,
            subscriptionStartDate: Swift.String? = nil,
            username: Swift.String? = nil
        ) {
            self.domain = domain
            self.identityProvider = identityProvider
            self.product = product
            self.productUserArn = productUserArn
            self.status = status
            self.statusMessage = statusMessage
            self.subscriptionEndDate = subscriptionEndDate
            self.subscriptionStartDate = subscriptionStartDate
            self.username = username
        }
    }
}

public struct ListProductSubscriptionsOutput: Swift.Sendable {
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// Metadata that describes the list product subscriptions operation.
    public var productUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]?

    public init(
        nextToken: Swift.String? = nil,
        productUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.productUserSummaries = productUserSummaries
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags for the specified resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

public struct ListUserAssociationsInput: Swift.Sendable {
    /// You can use the following filters to streamline results:
    ///
    /// * Status
    ///
    /// * Username
    ///
    /// * Domain
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The ID of the EC2 instance, which provides user-based subscriptions.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of results to return from a single request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the nextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.identityProvider = identityProvider
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListUserAssociationsOutput: Swift.Sendable {
    /// Metadata that describes the list user association operation.
    public var instanceUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]?
    /// The next token used for paginated responses. When this field isn't empty, there are additional elements that the service hasn't included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?

    public init(
        instanceUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.instanceUserSummaries = instanceUserSummaries
        self.nextToken = nextToken
    }
}

public struct RegisterIdentityProviderInput: Swift.Sendable {
    /// An object that specifies details for the identity provider to register.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product. Valid values: VISUAL_STUDIO_ENTERPRISE | VISUAL_STUDIO_PROFESSIONAL | OFFICE_PROFESSIONAL_PLUS | REMOTE_DESKTOP_SERVICES
    /// This member is required.
    public var product: Swift.String?
    /// The registered identity provider’s product related configuration settings such as the subnets to provision VPC endpoints.
    public var settings: LicenseManagerUserSubscriptionsClientTypes.Settings?
    /// The tags that apply to the identity provider's registration.
    public var tags: [Swift.String: Swift.String]?

    public init(
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        settings: LicenseManagerUserSubscriptionsClientTypes.Settings? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.identityProvider = identityProvider
        self.product = product
        self.settings = settings
        self.tags = tags
    }
}

extension RegisterIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterIdentityProviderInput(identityProvider: \(Swift.String(describing: identityProvider)), product: \(Swift.String(describing: product)), settings: \(Swift.String(describing: settings)), tags: \"CONTENT_REDACTED\")"}
}

public struct RegisterIdentityProviderOutput: Swift.Sendable {
    /// Metadata that describes the results of an identity provider operation.
    /// This member is required.
    public var identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?

    public init(
        identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary? = nil
    ) {
        self.identityProviderSummary = identityProviderSummary
    }
}

public struct StartProductSubscriptionInput: Swift.Sendable {
    /// The domain name of the Active Directory that contains the user for whom to start the product subscription.
    public var domain: Swift.String?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product. Valid values: VISUAL_STUDIO_ENTERPRISE | VISUAL_STUDIO_PROFESSIONAL | OFFICE_PROFESSIONAL_PLUS | REMOTE_DESKTOP_SERVICES
    /// This member is required.
    public var product: Swift.String?
    /// The tags that apply to the product subscription.
    public var tags: [Swift.String: Swift.String]?
    /// The user name from the identity provider of the user.
    /// This member is required.
    public var username: Swift.String?

    public init(
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        username: Swift.String? = nil
    ) {
        self.domain = domain
        self.identityProvider = identityProvider
        self.product = product
        self.tags = tags
        self.username = username
    }
}

extension StartProductSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartProductSubscriptionInput(domain: \(Swift.String(describing: domain)), identityProvider: \(Swift.String(describing: identityProvider)), product: \(Swift.String(describing: product)), username: \(Swift.String(describing: username)), tags: \"CONTENT_REDACTED\")"}
}

public struct StartProductSubscriptionOutput: Swift.Sendable {
    /// Metadata that describes the start product subscription operation.
    /// This member is required.
    public var productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?

    public init(
        productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary? = nil
    ) {
        self.productUserSummary = productUserSummary
    }
}

public struct StopProductSubscriptionInput: Swift.Sendable {
    /// The domain name of the Active Directory that contains the user for whom to stop the product subscription.
    public var domain: Swift.String?
    /// An object that specifies details for the identity provider.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product. Valid values: VISUAL_STUDIO_ENTERPRISE | VISUAL_STUDIO_PROFESSIONAL | OFFICE_PROFESSIONAL_PLUS | REMOTE_DESKTOP_SERVICES
    public var product: Swift.String?
    /// The Amazon Resource Name (ARN) of the product user.
    public var productUserArn: Swift.String?
    /// The user name from the identity provider for the user.
    public var username: Swift.String?

    public init(
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        productUserArn: Swift.String? = nil,
        username: Swift.String? = nil
    ) {
        self.domain = domain
        self.identityProvider = identityProvider
        self.product = product
        self.productUserArn = productUserArn
        self.username = username
    }
}

public struct StopProductSubscriptionOutput: Swift.Sendable {
    /// Metadata that describes the start product subscription operation.
    /// This member is required.
    public var productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?

    public init(
        productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary? = nil
    ) {
        self.productUserSummary = productUserSummary
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to apply to the specified resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Updates the registered identity provider’s product related configuration settings such as the subnets to provision VPC endpoints.
    public struct UpdateSettings: Swift.Sendable {
        /// The ID of one or more subnets in which License Manager will create a VPC endpoint for products that require connectivity to activation servers.
        /// This member is required.
        public var addSubnets: [Swift.String]?
        /// The ID of one or more subnets to remove.
        /// This member is required.
        public var removeSubnets: [Swift.String]?
        /// A security group ID that allows inbound TCP port 1688 communication between resources in your VPC and the VPC endpoints for activation servers.
        public var securityGroupId: Swift.String?

        public init(
            addSubnets: [Swift.String]? = nil,
            removeSubnets: [Swift.String]? = nil,
            securityGroupId: Swift.String? = nil
        ) {
            self.addSubnets = addSubnets
            self.removeSubnets = removeSubnets
            self.securityGroupId = securityGroupId
        }
    }
}

public struct UpdateIdentityProviderSettingsInput: Swift.Sendable {
    /// Refers to an identity provider.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The Amazon Resource Name (ARN) of the identity provider to update.
    public var identityProviderArn: Swift.String?
    /// The name of the user-based subscription product. Valid values: VISUAL_STUDIO_ENTERPRISE | VISUAL_STUDIO_PROFESSIONAL | OFFICE_PROFESSIONAL_PLUS | REMOTE_DESKTOP_SERVICES
    public var product: Swift.String?
    /// Updates the registered identity provider’s product related configuration settings. You can update any combination of settings in a single operation such as the:
    ///
    /// * Subnets which you want to add to provision VPC endpoints.
    ///
    /// * Subnets which you want to remove the VPC endpoints from.
    ///
    /// * Security group ID which permits traffic to the VPC endpoints.
    /// This member is required.
    public var updateSettings: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings?

    public init(
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        identityProviderArn: Swift.String? = nil,
        product: Swift.String? = nil,
        updateSettings: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings? = nil
    ) {
        self.identityProvider = identityProvider
        self.identityProviderArn = identityProviderArn
        self.product = product
        self.updateSettings = updateSettings
    }
}

public struct UpdateIdentityProviderSettingsOutput: Swift.Sendable {
    /// Describes an identity provider.
    /// This member is required.
    public var identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?

    public init(
        identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary? = nil
    ) {
        self.identityProviderSummary = identityProviderSummary
    }
}

extension AssociateUserInput {

    static func urlPathProvider(_ value: AssociateUserInput) -> Swift.String? {
        return "/user/AssociateUser"
    }
}

extension CreateLicenseServerEndpointInput {

    static func urlPathProvider(_ value: CreateLicenseServerEndpointInput) -> Swift.String? {
        return "/license-server/CreateLicenseServerEndpoint"
    }
}

extension DeleteLicenseServerEndpointInput {

    static func urlPathProvider(_ value: DeleteLicenseServerEndpointInput) -> Swift.String? {
        return "/license-server/DeleteLicenseServerEndpoint"
    }
}

extension DeregisterIdentityProviderInput {

    static func urlPathProvider(_ value: DeregisterIdentityProviderInput) -> Swift.String? {
        return "/identity-provider/DeregisterIdentityProvider"
    }
}

extension DisassociateUserInput {

    static func urlPathProvider(_ value: DisassociateUserInput) -> Swift.String? {
        return "/user/DisassociateUser"
    }
}

extension ListIdentityProvidersInput {

    static func urlPathProvider(_ value: ListIdentityProvidersInput) -> Swift.String? {
        return "/identity-provider/ListIdentityProviders"
    }
}

extension ListInstancesInput {

    static func urlPathProvider(_ value: ListInstancesInput) -> Swift.String? {
        return "/instance/ListInstances"
    }
}

extension ListLicenseServerEndpointsInput {

    static func urlPathProvider(_ value: ListLicenseServerEndpointsInput) -> Swift.String? {
        return "/license-server/ListLicenseServerEndpoints"
    }
}

extension ListProductSubscriptionsInput {

    static func urlPathProvider(_ value: ListProductSubscriptionsInput) -> Swift.String? {
        return "/user/ListProductSubscriptions"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListUserAssociationsInput {

    static func urlPathProvider(_ value: ListUserAssociationsInput) -> Swift.String? {
        return "/user/ListUserAssociations"
    }
}

extension RegisterIdentityProviderInput {

    static func urlPathProvider(_ value: RegisterIdentityProviderInput) -> Swift.String? {
        return "/identity-provider/RegisterIdentityProvider"
    }
}

extension StartProductSubscriptionInput {

    static func urlPathProvider(_ value: StartProductSubscriptionInput) -> Swift.String? {
        return "/user/StartProductSubscription"
    }
}

extension StopProductSubscriptionInput {

    static func urlPathProvider(_ value: StopProductSubscriptionInput) -> Swift.String? {
        return "/user/StopProductSubscription"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateIdentityProviderSettingsInput {

    static func urlPathProvider(_ value: UpdateIdentityProviderSettingsInput) -> Swift.String? {
        return "/identity-provider/UpdateIdentityProviderSettings"
    }
}

extension AssociateUserInput {

    static func write(value: AssociateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domain"].write(value.domain)
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["InstanceId"].write(value.instanceId)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Username"].write(value.username)
    }
}

extension CreateLicenseServerEndpointInput {

    static func write(value: CreateLicenseServerEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdentityProviderArn"].write(value.identityProviderArn)
        try writer["LicenseServerSettings"].write(value.licenseServerSettings, with: LicenseManagerUserSubscriptionsClientTypes.LicenseServerSettings.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeleteLicenseServerEndpointInput {

    static func write(value: DeleteLicenseServerEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseServerEndpointArn"].write(value.licenseServerEndpointArn)
        try writer["ServerType"].write(value.serverType)
    }
}

extension DeregisterIdentityProviderInput {

    static func write(value: DeregisterIdentityProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["IdentityProviderArn"].write(value.identityProviderArn)
        try writer["Product"].write(value.product)
    }
}

extension DisassociateUserInput {

    static func write(value: DisassociateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domain"].write(value.domain)
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["InstanceId"].write(value.instanceId)
        try writer["InstanceUserArn"].write(value.instanceUserArn)
        try writer["Username"].write(value.username)
    }
}

extension ListIdentityProvidersInput {

    static func write(value: ListIdentityProvidersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerUserSubscriptionsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListInstancesInput {

    static func write(value: ListInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerUserSubscriptionsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListLicenseServerEndpointsInput {

    static func write(value: ListLicenseServerEndpointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerUserSubscriptionsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListProductSubscriptionsInput {

    static func write(value: ListProductSubscriptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerUserSubscriptionsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Product"].write(value.product)
    }
}

extension ListUserAssociationsInput {

    static func write(value: ListUserAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerUserSubscriptionsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension RegisterIdentityProviderInput {

    static func write(value: RegisterIdentityProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["Product"].write(value.product)
        try writer["Settings"].write(value.settings, with: LicenseManagerUserSubscriptionsClientTypes.Settings.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StartProductSubscriptionInput {

    static func write(value: StartProductSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domain"].write(value.domain)
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["Product"].write(value.product)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Username"].write(value.username)
    }
}

extension StopProductSubscriptionInput {

    static func write(value: StopProductSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domain"].write(value.domain)
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["Product"].write(value.product)
        try writer["ProductUserArn"].write(value.productUserArn)
        try writer["Username"].write(value.username)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateIdentityProviderSettingsInput {

    static func write(value: UpdateIdentityProviderSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["IdentityProviderArn"].write(value.identityProviderArn)
        try writer["Product"].write(value.product)
        try writer["UpdateSettings"].write(value.updateSettings, with: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings.write(value:to:))
    }
}

extension AssociateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateUserOutput()
        value.instanceUserSummary = try reader["InstanceUserSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary.read(from:))
        return value
    }
}

extension CreateLicenseServerEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLicenseServerEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLicenseServerEndpointOutput()
        value.identityProviderArn = try reader["IdentityProviderArn"].readIfPresent()
        value.licenseServerEndpointArn = try reader["LicenseServerEndpointArn"].readIfPresent()
        return value
    }
}

extension DeleteLicenseServerEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLicenseServerEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteLicenseServerEndpointOutput()
        value.licenseServerEndpoint = try reader["LicenseServerEndpoint"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.LicenseServerEndpoint.read(from:))
        return value
    }
}

extension DeregisterIdentityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterIdentityProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterIdentityProviderOutput()
        value.identityProviderSummary = try reader["IdentityProviderSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.read(from:))
        return value
    }
}

extension DisassociateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateUserOutput()
        value.instanceUserSummary = try reader["InstanceUserSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary.read(from:))
        return value
    }
}

extension ListIdentityProvidersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIdentityProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIdentityProvidersOutput()
        value.identityProviderSummaries = try reader["IdentityProviderSummaries"].readListIfPresent(memberReadingClosure: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInstancesOutput()
        value.instanceSummaries = try reader["InstanceSummaries"].readListIfPresent(memberReadingClosure: LicenseManagerUserSubscriptionsClientTypes.InstanceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLicenseServerEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLicenseServerEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLicenseServerEndpointsOutput()
        value.licenseServerEndpoints = try reader["LicenseServerEndpoints"].readListIfPresent(memberReadingClosure: LicenseManagerUserSubscriptionsClientTypes.LicenseServerEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListProductSubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProductSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProductSubscriptionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.productUserSummaries = try reader["ProductUserSummaries"].readListIfPresent(memberReadingClosure: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListUserAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUserAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUserAssociationsOutput()
        value.instanceUserSummaries = try reader["InstanceUserSummaries"].readListIfPresent(memberReadingClosure: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension RegisterIdentityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterIdentityProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterIdentityProviderOutput()
        value.identityProviderSummary = try reader["IdentityProviderSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.read(from:))
        return value
    }
}

extension StartProductSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartProductSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartProductSubscriptionOutput()
        value.productUserSummary = try reader["ProductUserSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary.read(from:))
        return value
    }
}

extension StopProductSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopProductSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopProductSubscriptionOutput()
        value.productUserSummary = try reader["ProductUserSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateIdentityProviderSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIdentityProviderSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIdentityProviderSettingsOutput()
        value.identityProviderSummary = try reader["IdentityProviderSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.read(from:))
        return value
    }
}

enum AssociateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLicenseServerEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLicenseServerEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterIdentityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIdentityProvidersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLicenseServerEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProductSubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUserAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterIdentityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartProductSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopProductSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIdentityProviderSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary()
        value.username = try reader["Username"].readIfPresent() ?? ""
        value.instanceId = try reader["InstanceId"].readIfPresent() ?? ""
        value.identityProvider = try reader["IdentityProvider"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.read(from:))
        value.status = try reader["Status"].readIfPresent() ?? ""
        value.instanceUserArn = try reader["InstanceUserArn"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.domain = try reader["Domain"].readIfPresent()
        value.associationDate = try reader["AssociationDate"].readIfPresent()
        value.disassociationDate = try reader["DisassociationDate"].readIfPresent()
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.IdentityProvider {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .activedirectoryidentityprovider(activedirectoryidentityprovider):
                try writer["ActiveDirectoryIdentityProvider"].write(activedirectoryidentityprovider, with: LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.IdentityProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "ActiveDirectoryIdentityProvider":
                return .activedirectoryidentityprovider(try reader["ActiveDirectoryIdentityProvider"].read(with: LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActiveDirectorySettings"].write(value.activeDirectorySettings, with: LicenseManagerUserSubscriptionsClientTypes.ActiveDirectorySettings.write(value:to:))
        try writer["ActiveDirectoryType"].write(value.activeDirectoryType)
        try writer["DirectoryId"].write(value.directoryId)
        try writer["IsSharedActiveDirectory"].write(value.isSharedActiveDirectory)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider()
        value.directoryId = try reader["DirectoryId"].readIfPresent()
        value.activeDirectorySettings = try reader["ActiveDirectorySettings"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.ActiveDirectorySettings.read(from:))
        value.activeDirectoryType = try reader["ActiveDirectoryType"].readIfPresent()
        value.isSharedActiveDirectory = try reader["IsSharedActiveDirectory"].readIfPresent()
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.ActiveDirectorySettings {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.ActiveDirectorySettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainCredentialsProvider"].write(value.domainCredentialsProvider, with: LicenseManagerUserSubscriptionsClientTypes.CredentialsProvider.write(value:to:))
        try writer["DomainIpv4List"].writeList(value.domainIpv4List, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DomainName"].write(value.domainName)
        try writer["DomainNetworkSettings"].write(value.domainNetworkSettings, with: LicenseManagerUserSubscriptionsClientTypes.DomainNetworkSettings.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.ActiveDirectorySettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.ActiveDirectorySettings()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.domainIpv4List = try reader["DomainIpv4List"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.domainCredentialsProvider = try reader["DomainCredentialsProvider"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.CredentialsProvider.read(from:))
        value.domainNetworkSettings = try reader["DomainNetworkSettings"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.DomainNetworkSettings.read(from:))
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.DomainNetworkSettings {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.DomainNetworkSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.DomainNetworkSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.DomainNetworkSettings()
        value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.CredentialsProvider {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.CredentialsProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .secretsmanagercredentialsprovider(secretsmanagercredentialsprovider):
                try writer["SecretsManagerCredentialsProvider"].write(secretsmanagercredentialsprovider, with: LicenseManagerUserSubscriptionsClientTypes.SecretsManagerCredentialsProvider.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.CredentialsProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "SecretsManagerCredentialsProvider":
                return .secretsmanagercredentialsprovider(try reader["SecretsManagerCredentialsProvider"].read(with: LicenseManagerUserSubscriptionsClientTypes.SecretsManagerCredentialsProvider.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.SecretsManagerCredentialsProvider {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.SecretsManagerCredentialsProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecretId"].write(value.secretId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.SecretsManagerCredentialsProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.SecretsManagerCredentialsProvider()
        value.secretId = try reader["SecretId"].readIfPresent()
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.LicenseServerEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.LicenseServerEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.LicenseServerEndpoint()
        value.identityProviderArn = try reader["IdentityProviderArn"].readIfPresent()
        value.serverType = try reader["ServerType"].readIfPresent()
        value.serverEndpoint = try reader["ServerEndpoint"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.ServerEndpoint.read(from:))
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.licenseServerEndpointId = try reader["LicenseServerEndpointId"].readIfPresent()
        value.licenseServerEndpointArn = try reader["LicenseServerEndpointArn"].readIfPresent()
        value.licenseServerEndpointProvisioningStatus = try reader["LicenseServerEndpointProvisioningStatus"].readIfPresent()
        value.licenseServers = try reader["LicenseServers"].readListIfPresent(memberReadingClosure: LicenseManagerUserSubscriptionsClientTypes.LicenseServer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.LicenseServer {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.LicenseServer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.LicenseServer()
        value.provisioningStatus = try reader["ProvisioningStatus"].readIfPresent()
        value.healthStatus = try reader["HealthStatus"].readIfPresent()
        value.ipv4Address = try reader["Ipv4Address"].readIfPresent()
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.ServerEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.ServerEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.ServerEndpoint()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary()
        value.identityProvider = try reader["IdentityProvider"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.read(from:))
        value.settings = try reader["Settings"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.Settings.read(from:))
        value.product = try reader["Product"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? ""
        value.identityProviderArn = try reader["IdentityProviderArn"].readIfPresent()
        value.failureMessage = try reader["FailureMessage"].readIfPresent()
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.Settings {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.Settings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroupId"].write(value.securityGroupId)
        try writer["Subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.Settings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.Settings()
        value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.securityGroupId = try reader["SecurityGroupId"].readIfPresent() ?? ""
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.InstanceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.InstanceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.InstanceSummary()
        value.instanceId = try reader["InstanceId"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? ""
        value.products = try reader["Products"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.lastStatusCheckDate = try reader["LastStatusCheckDate"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        value.identityProvider = try reader["IdentityProvider"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.read(from:))
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary()
        value.username = try reader["Username"].readIfPresent() ?? ""
        value.product = try reader["Product"].readIfPresent() ?? ""
        value.identityProvider = try reader["IdentityProvider"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.read(from:))
        value.status = try reader["Status"].readIfPresent() ?? ""
        value.productUserArn = try reader["ProductUserArn"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.domain = try reader["Domain"].readIfPresent()
        value.subscriptionStartDate = try reader["SubscriptionStartDate"].readIfPresent()
        value.subscriptionEndDate = try reader["SubscriptionEndDate"].readIfPresent()
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.LicenseServerSettings {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.LicenseServerSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServerSettings"].write(value.serverSettings, with: LicenseManagerUserSubscriptionsClientTypes.ServerSettings.write(value:to:))
        try writer["ServerType"].write(value.serverType)
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.ServerSettings {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.ServerSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .rdssalsettings(rdssalsettings):
                try writer["RdsSalSettings"].write(rdssalsettings, with: LicenseManagerUserSubscriptionsClientTypes.RdsSalSettings.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.RdsSalSettings {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.RdsSalSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RdsSalCredentialsProvider"].write(value.rdsSalCredentialsProvider, with: LicenseManagerUserSubscriptionsClientTypes.CredentialsProvider.write(value:to:))
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.Filter {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attribute"].write(value.attribute)
        try writer["Operation"].write(value.operation)
        try writer["Value"].write(value.value)
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.UpdateSettings {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddSubnets"].writeList(value.addSubnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RemoveSubnets"].writeList(value.removeSubnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecurityGroupId"].write(value.securityGroupId)
    }
}

public enum LicenseManagerUserSubscriptionsClientTypes {}
