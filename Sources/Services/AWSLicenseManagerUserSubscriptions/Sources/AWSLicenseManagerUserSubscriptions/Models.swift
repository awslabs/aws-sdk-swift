//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Details about an Active Directory identity provider.
    public struct ActiveDirectoryIdentityProvider: Swift.Sendable {
        /// The directory ID for an Active Directory identity provider.
        public var directoryId: Swift.String?

        public init(
            directoryId: Swift.String? = nil
        )
        {
            self.directoryId = directoryId
        }
    }
}

/// The request couldn't be completed because it conflicted with the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An exception occurred with the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource couldn't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request failed because a service quota is exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied because of request throttling. Retry the request.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A parameter is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Details about an identity provider.
    public enum IdentityProvider: Swift.Sendable {
        /// An object that details an Active Directory identity provider.
        case activedirectoryidentityprovider(LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider)
        case sdkUnknown(Swift.String)
    }
}

public struct AssociateUserInput: Swift.Sendable {
    /// The domain name of the user.
    public var domain: Swift.String?
    /// The identity provider of the user.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The ID of the EC2 instance, which provides user-based subscriptions.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The user name from the identity provider for the user.
    /// This member is required.
    public var username: Swift.String?

    public init(
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        instanceId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.domain = domain
        self.identityProvider = identityProvider
        self.instanceId = instanceId
        self.username = username
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Describes users of an EC2 instance providing user-based subscriptions.
    public struct InstanceUserSummary: Swift.Sendable {
        /// The date a user was associated with an EC2 instance.
        public var associationDate: Swift.String?
        /// The date a user was disassociated from an EC2 instance.
        public var disassociationDate: Swift.String?
        /// The domain name of the user.
        public var domain: Swift.String?
        /// An object that specifies details for the identity provider.
        /// This member is required.
        public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
        /// The ID of the EC2 instance, which provides user-based subscriptions.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The status of a user associated with an EC2 instance.
        /// This member is required.
        public var status: Swift.String?
        /// The status message for users of an EC2 instance.
        public var statusMessage: Swift.String?
        /// The user name from the identity provider for the user.
        /// This member is required.
        public var username: Swift.String?

        public init(
            associationDate: Swift.String? = nil,
            disassociationDate: Swift.String? = nil,
            domain: Swift.String? = nil,
            identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
            instanceId: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.associationDate = associationDate
            self.disassociationDate = disassociationDate
            self.domain = domain
            self.identityProvider = identityProvider
            self.instanceId = instanceId
            self.status = status
            self.statusMessage = statusMessage
            self.username = username
        }
    }
}

public struct AssociateUserOutput: Swift.Sendable {
    /// Metadata that describes the associate user operation.
    /// This member is required.
    public var instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?

    public init(
        instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary? = nil
    )
    {
        self.instanceUserSummary = instanceUserSummary
    }
}

public struct DeregisterIdentityProviderInput: Swift.Sendable {
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?

    public init(
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil
    )
    {
        self.identityProvider = identityProvider
        self.product = product
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// The registered identity provider’s product related configuration settings such as the subnets to provision VPC endpoints, and the security group ID that is associated with the VPC endpoints. The security group should permit inbound TCP port 1688 communication from resources in the VPC.
    public struct Settings: Swift.Sendable {
        /// A security group ID that allows inbound TCP port 1688 communication between resources in your VPC and the VPC endpoint for activation servers.
        /// This member is required.
        public var securityGroupId: Swift.String?
        /// The subnets defined for the registered identity provider.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init(
            securityGroupId: Swift.String? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.securityGroupId = securityGroupId
            self.subnets = subnets
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Describes an identity provider.
    public struct IdentityProviderSummary: Swift.Sendable {
        /// The failure message associated with an identity provider.
        public var failureMessage: Swift.String?
        /// An object that specifies details for the identity provider.
        /// This member is required.
        public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
        /// The name of the user-based subscription product.
        /// This member is required.
        public var product: Swift.String?
        /// An object that details the registered identity provider’s product related configuration settings such as the subnets to provision VPC endpoints.
        /// This member is required.
        public var settings: LicenseManagerUserSubscriptionsClientTypes.Settings?
        /// The status of an identity provider.
        /// This member is required.
        public var status: Swift.String?

        public init(
            failureMessage: Swift.String? = nil,
            identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
            product: Swift.String? = nil,
            settings: LicenseManagerUserSubscriptionsClientTypes.Settings? = nil,
            status: Swift.String? = nil
        )
        {
            self.failureMessage = failureMessage
            self.identityProvider = identityProvider
            self.product = product
            self.settings = settings
            self.status = status
        }
    }
}

public struct DeregisterIdentityProviderOutput: Swift.Sendable {
    /// Metadata that describes the results of an identity provider operation.
    /// This member is required.
    public var identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?

    public init(
        identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary? = nil
    )
    {
        self.identityProviderSummary = identityProviderSummary
    }
}

public struct DisassociateUserInput: Swift.Sendable {
    /// The domain name of the user.
    public var domain: Swift.String?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The ID of the EC2 instance, which provides user-based subscriptions.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The user name from the identity provider for the user.
    /// This member is required.
    public var username: Swift.String?

    public init(
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        instanceId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.domain = domain
        self.identityProvider = identityProvider
        self.instanceId = instanceId
        self.username = username
    }
}

public struct DisassociateUserOutput: Swift.Sendable {
    /// Metadata that describes the associate user operation.
    /// This member is required.
    public var instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?

    public init(
        instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary? = nil
    )
    {
        self.instanceUserSummary = instanceUserSummary
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// A filter name and value pair that is used to return more specific results from a describe operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs.
    public struct Filter: Swift.Sendable {
        /// The name of an attribute to use as a filter.
        public var attribute: Swift.String?
        /// The type of search (For example, eq, geq, leq)
        public var operation: Swift.String?
        /// Value of the filter.
        public var value: Swift.String?

        public init(
            attribute: Swift.String? = nil,
            operation: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.attribute = attribute
            self.operation = operation
            self.value = value
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Describes an EC2 instance providing user-based subscriptions.
    public struct InstanceSummary: Swift.Sendable {
        /// The ID of the EC2 instance, which provides user-based subscriptions.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The date of the last status check.
        public var lastStatusCheckDate: Swift.String?
        /// A list of provided user-based subscription products.
        /// This member is required.
        public var products: [Swift.String]?
        /// The status of an EC2 instance resource.
        /// This member is required.
        public var status: Swift.String?
        /// The status message for an EC2 instance.
        public var statusMessage: Swift.String?

        public init(
            instanceId: Swift.String? = nil,
            lastStatusCheckDate: Swift.String? = nil,
            products: [Swift.String]? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
            self.lastStatusCheckDate = lastStatusCheckDate
            self.products = products
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct ListIdentityProvidersInput: Swift.Sendable {
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListIdentityProvidersOutput: Swift.Sendable {
    /// Metadata that describes the list identity providers operation.
    /// This member is required.
    public var identityProviderSummaries: [LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        identityProviderSummaries: [LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityProviderSummaries = identityProviderSummaries
        self.nextToken = nextToken
    }
}

public struct ListInstancesInput: Swift.Sendable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListInstancesOutput: Swift.Sendable {
    /// Metadata that describes the list instances operation.
    public var instanceSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceSummaries = instanceSummaries
        self.nextToken = nextToken
    }
}

public struct ListProductSubscriptionsInput: Swift.Sendable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?

    public init(
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        product: Swift.String? = nil
    )
    {
        self.filters = filters
        self.identityProvider = identityProvider
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.product = product
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// The summary of the user-based subscription products for a user.
    public struct ProductUserSummary: Swift.Sendable {
        /// The domain name of the user.
        public var domain: Swift.String?
        /// An object that specifies details for the identity provider.
        /// This member is required.
        public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
        /// The name of the user-based subscription product.
        /// This member is required.
        public var product: Swift.String?
        /// The status of a product for a user.
        /// This member is required.
        public var status: Swift.String?
        /// The status message for a product for a user.
        public var statusMessage: Swift.String?
        /// The end date of a subscription.
        public var subscriptionEndDate: Swift.String?
        /// The start date of a subscription.
        public var subscriptionStartDate: Swift.String?
        /// The user name from the identity provider of the user.
        /// This member is required.
        public var username: Swift.String?

        public init(
            domain: Swift.String? = nil,
            identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
            product: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            subscriptionEndDate: Swift.String? = nil,
            subscriptionStartDate: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.domain = domain
            self.identityProvider = identityProvider
            self.product = product
            self.status = status
            self.statusMessage = statusMessage
            self.subscriptionEndDate = subscriptionEndDate
            self.subscriptionStartDate = subscriptionStartDate
            self.username = username
        }
    }
}

public struct ListProductSubscriptionsOutput: Swift.Sendable {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Metadata that describes the list product subscriptions operation.
    public var productUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]?

    public init(
        nextToken: Swift.String? = nil,
        productUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.productUserSummaries = productUserSummaries
    }
}

public struct ListUserAssociationsInput: Swift.Sendable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The ID of the EC2 instance, which provides user-based subscriptions.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.identityProvider = identityProvider
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListUserAssociationsOutput: Swift.Sendable {
    /// Metadata that describes the list user association operation.
    public var instanceUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceUserSummaries = instanceUserSummaries
        self.nextToken = nextToken
    }
}

public struct RegisterIdentityProviderInput: Swift.Sendable {
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?
    /// The registered identity provider’s product related configuration settings such as the subnets to provision VPC endpoints.
    public var settings: LicenseManagerUserSubscriptionsClientTypes.Settings?

    public init(
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        settings: LicenseManagerUserSubscriptionsClientTypes.Settings? = nil
    )
    {
        self.identityProvider = identityProvider
        self.product = product
        self.settings = settings
    }
}

public struct RegisterIdentityProviderOutput: Swift.Sendable {
    /// Metadata that describes the results of an identity provider operation.
    /// This member is required.
    public var identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?

    public init(
        identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary? = nil
    )
    {
        self.identityProviderSummary = identityProviderSummary
    }
}

public struct StartProductSubscriptionInput: Swift.Sendable {
    /// The domain name of the user.
    public var domain: Swift.String?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?
    /// The user name from the identity provider of the user.
    /// This member is required.
    public var username: Swift.String?

    public init(
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.domain = domain
        self.identityProvider = identityProvider
        self.product = product
        self.username = username
    }
}

public struct StartProductSubscriptionOutput: Swift.Sendable {
    /// Metadata that describes the start product subscription operation.
    /// This member is required.
    public var productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?

    public init(
        productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary? = nil
    )
    {
        self.productUserSummary = productUserSummary
    }
}

public struct StopProductSubscriptionInput: Swift.Sendable {
    /// The domain name of the user.
    public var domain: Swift.String?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?
    /// The user name from the identity provider for the user.
    /// This member is required.
    public var username: Swift.String?

    public init(
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.domain = domain
        self.identityProvider = identityProvider
        self.product = product
        self.username = username
    }
}

public struct StopProductSubscriptionOutput: Swift.Sendable {
    /// Metadata that describes the start product subscription operation.
    /// This member is required.
    public var productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?

    public init(
        productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary? = nil
    )
    {
        self.productUserSummary = productUserSummary
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {

    /// Updates the registered identity provider’s product related configuration settings such as the subnets to provision VPC endpoints.
    public struct UpdateSettings: Swift.Sendable {
        /// The ID of one or more subnets in which License Manager will create a VPC endpoint for products that require connectivity to activation servers.
        /// This member is required.
        public var addSubnets: [Swift.String]?
        /// The ID of one or more subnets to remove.
        /// This member is required.
        public var removeSubnets: [Swift.String]?
        /// A security group ID that allows inbound TCP port 1688 communication between resources in your VPC and the VPC endpoints for activation servers.
        public var securityGroupId: Swift.String?

        public init(
            addSubnets: [Swift.String]? = nil,
            removeSubnets: [Swift.String]? = nil,
            securityGroupId: Swift.String? = nil
        )
        {
            self.addSubnets = addSubnets
            self.removeSubnets = removeSubnets
            self.securityGroupId = securityGroupId
        }
    }
}

public struct UpdateIdentityProviderSettingsInput: Swift.Sendable {
    /// Details about an identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?
    /// Updates the registered identity provider’s product related configuration settings. You can update any combination of settings in a single operation such as the:
    ///
    /// * Subnets which you want to add to provision VPC endpoints.
    ///
    /// * Subnets which you want to remove the VPC endpoints from.
    ///
    /// * Security group ID which permits traffic to the VPC endpoints.
    /// This member is required.
    public var updateSettings: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings?

    public init(
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        updateSettings: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings? = nil
    )
    {
        self.identityProvider = identityProvider
        self.product = product
        self.updateSettings = updateSettings
    }
}

public struct UpdateIdentityProviderSettingsOutput: Swift.Sendable {
    /// Describes an identity provider.
    /// This member is required.
    public var identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?

    public init(
        identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary? = nil
    )
    {
        self.identityProviderSummary = identityProviderSummary
    }
}

extension AssociateUserInput {

    static func urlPathProvider(_ value: AssociateUserInput) -> Swift.String? {
        return "/user/AssociateUser"
    }
}

extension DeregisterIdentityProviderInput {

    static func urlPathProvider(_ value: DeregisterIdentityProviderInput) -> Swift.String? {
        return "/identity-provider/DeregisterIdentityProvider"
    }
}

extension DisassociateUserInput {

    static func urlPathProvider(_ value: DisassociateUserInput) -> Swift.String? {
        return "/user/DisassociateUser"
    }
}

extension ListIdentityProvidersInput {

    static func urlPathProvider(_ value: ListIdentityProvidersInput) -> Swift.String? {
        return "/identity-provider/ListIdentityProviders"
    }
}

extension ListInstancesInput {

    static func urlPathProvider(_ value: ListInstancesInput) -> Swift.String? {
        return "/instance/ListInstances"
    }
}

extension ListProductSubscriptionsInput {

    static func urlPathProvider(_ value: ListProductSubscriptionsInput) -> Swift.String? {
        return "/user/ListProductSubscriptions"
    }
}

extension ListUserAssociationsInput {

    static func urlPathProvider(_ value: ListUserAssociationsInput) -> Swift.String? {
        return "/user/ListUserAssociations"
    }
}

extension RegisterIdentityProviderInput {

    static func urlPathProvider(_ value: RegisterIdentityProviderInput) -> Swift.String? {
        return "/identity-provider/RegisterIdentityProvider"
    }
}

extension StartProductSubscriptionInput {

    static func urlPathProvider(_ value: StartProductSubscriptionInput) -> Swift.String? {
        return "/user/StartProductSubscription"
    }
}

extension StopProductSubscriptionInput {

    static func urlPathProvider(_ value: StopProductSubscriptionInput) -> Swift.String? {
        return "/user/StopProductSubscription"
    }
}

extension UpdateIdentityProviderSettingsInput {

    static func urlPathProvider(_ value: UpdateIdentityProviderSettingsInput) -> Swift.String? {
        return "/identity-provider/UpdateIdentityProviderSettings"
    }
}

extension AssociateUserInput {

    static func write(value: AssociateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domain"].write(value.domain)
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["InstanceId"].write(value.instanceId)
        try writer["Username"].write(value.username)
    }
}

extension DeregisterIdentityProviderInput {

    static func write(value: DeregisterIdentityProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["Product"].write(value.product)
    }
}

extension DisassociateUserInput {

    static func write(value: DisassociateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domain"].write(value.domain)
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["InstanceId"].write(value.instanceId)
        try writer["Username"].write(value.username)
    }
}

extension ListIdentityProvidersInput {

    static func write(value: ListIdentityProvidersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListInstancesInput {

    static func write(value: ListInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerUserSubscriptionsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListProductSubscriptionsInput {

    static func write(value: ListProductSubscriptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerUserSubscriptionsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Product"].write(value.product)
    }
}

extension ListUserAssociationsInput {

    static func write(value: ListUserAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: LicenseManagerUserSubscriptionsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension RegisterIdentityProviderInput {

    static func write(value: RegisterIdentityProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["Product"].write(value.product)
        try writer["Settings"].write(value.settings, with: LicenseManagerUserSubscriptionsClientTypes.Settings.write(value:to:))
    }
}

extension StartProductSubscriptionInput {

    static func write(value: StartProductSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domain"].write(value.domain)
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["Product"].write(value.product)
        try writer["Username"].write(value.username)
    }
}

extension StopProductSubscriptionInput {

    static func write(value: StopProductSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domain"].write(value.domain)
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["Product"].write(value.product)
        try writer["Username"].write(value.username)
    }
}

extension UpdateIdentityProviderSettingsInput {

    static func write(value: UpdateIdentityProviderSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdentityProvider"].write(value.identityProvider, with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.write(value:to:))
        try writer["Product"].write(value.product)
        try writer["UpdateSettings"].write(value.updateSettings, with: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings.write(value:to:))
    }
}

extension AssociateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateUserOutput()
        value.instanceUserSummary = try reader["InstanceUserSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary.read(from:))
        return value
    }
}

extension DeregisterIdentityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterIdentityProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterIdentityProviderOutput()
        value.identityProviderSummary = try reader["IdentityProviderSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.read(from:))
        return value
    }
}

extension DisassociateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateUserOutput()
        value.instanceUserSummary = try reader["InstanceUserSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary.read(from:))
        return value
    }
}

extension ListIdentityProvidersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIdentityProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIdentityProvidersOutput()
        value.identityProviderSummaries = try reader["IdentityProviderSummaries"].readListIfPresent(memberReadingClosure: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInstancesOutput()
        value.instanceSummaries = try reader["InstanceSummaries"].readListIfPresent(memberReadingClosure: LicenseManagerUserSubscriptionsClientTypes.InstanceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListProductSubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProductSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProductSubscriptionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.productUserSummaries = try reader["ProductUserSummaries"].readListIfPresent(memberReadingClosure: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUserAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUserAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUserAssociationsOutput()
        value.instanceUserSummaries = try reader["InstanceUserSummaries"].readListIfPresent(memberReadingClosure: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension RegisterIdentityProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterIdentityProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterIdentityProviderOutput()
        value.identityProviderSummary = try reader["IdentityProviderSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.read(from:))
        return value
    }
}

extension StartProductSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartProductSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartProductSubscriptionOutput()
        value.productUserSummary = try reader["ProductUserSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary.read(from:))
        return value
    }
}

extension StopProductSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopProductSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopProductSubscriptionOutput()
        value.productUserSummary = try reader["ProductUserSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary.read(from:))
        return value
    }
}

extension UpdateIdentityProviderSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIdentityProviderSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIdentityProviderSettingsOutput()
        value.identityProviderSummary = try reader["IdentityProviderSummary"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.read(from:))
        return value
    }
}

enum AssociateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterIdentityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIdentityProvidersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProductSubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUserAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterIdentityProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartProductSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopProductSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIdentityProviderSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary()
        value.username = try reader["Username"].readIfPresent() ?? ""
        value.instanceId = try reader["InstanceId"].readIfPresent() ?? ""
        value.identityProvider = try reader["IdentityProvider"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.read(from:))
        value.status = try reader["Status"].readIfPresent() ?? ""
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.domain = try reader["Domain"].readIfPresent()
        value.associationDate = try reader["AssociationDate"].readIfPresent()
        value.disassociationDate = try reader["DisassociationDate"].readIfPresent()
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.IdentityProvider {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .activedirectoryidentityprovider(activedirectoryidentityprovider):
                try writer["ActiveDirectoryIdentityProvider"].write(activedirectoryidentityprovider, with: LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.IdentityProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "ActiveDirectoryIdentityProvider":
                return .activedirectoryidentityprovider(try reader["ActiveDirectoryIdentityProvider"].read(with: LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryId"].write(value.directoryId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider()
        value.directoryId = try reader["DirectoryId"].readIfPresent()
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary()
        value.identityProvider = try reader["IdentityProvider"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.read(from:))
        value.settings = try reader["Settings"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.Settings.read(from:))
        value.product = try reader["Product"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? ""
        value.failureMessage = try reader["FailureMessage"].readIfPresent()
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.Settings {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.Settings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroupId"].write(value.securityGroupId)
        try writer["Subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.Settings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.Settings()
        value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.securityGroupId = try reader["SecurityGroupId"].readIfPresent() ?? ""
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.InstanceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.InstanceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.InstanceSummary()
        value.instanceId = try reader["InstanceId"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? ""
        value.products = try reader["Products"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.lastStatusCheckDate = try reader["LastStatusCheckDate"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary()
        value.username = try reader["Username"].readIfPresent() ?? ""
        value.product = try reader["Product"].readIfPresent() ?? ""
        value.identityProvider = try reader["IdentityProvider"].readIfPresent(with: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.read(from:))
        value.status = try reader["Status"].readIfPresent() ?? ""
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.domain = try reader["Domain"].readIfPresent()
        value.subscriptionStartDate = try reader["SubscriptionStartDate"].readIfPresent()
        value.subscriptionEndDate = try reader["SubscriptionEndDate"].readIfPresent()
        return value
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.Filter {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attribute"].write(value.attribute)
        try writer["Operation"].write(value.operation)
        try writer["Value"].write(value.value)
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.UpdateSettings {

    static func write(value: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddSubnets"].writeList(value.addSubnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RemoveSubnets"].writeList(value.removeSubnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecurityGroupId"].write(value.securityGroupId)
    }
}

public enum LicenseManagerUserSubscriptionsClientTypes {}
