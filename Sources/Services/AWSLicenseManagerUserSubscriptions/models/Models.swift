// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// Details about an Active Directory identity provider.
    public struct ActiveDirectoryIdentityProvider: Swift.Equatable {
        /// The directory ID for an Active Directory identity provider.
        public var directoryId: Swift.String?

        public init(
            directoryId: Swift.String? = nil
        )
        {
            self.directoryId = directoryId
        }
    }

}

extension AssociateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension AssociateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user/AssociateUser"
    }
}

public struct AssociateUserInput: Swift.Equatable {
    /// The domain name of the user.
    public var domain: Swift.String?
    /// The identity provider of the user.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The ID of the EC2 instance, which provides user-based subscriptions.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The user name from the identity provider for the user.
    /// This member is required.
    public var username: Swift.String?

    public init(
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        instanceId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.domain = domain
        self.identityProvider = identityProvider
        self.instanceId = instanceId
        self.username = username
    }
}

struct AssociateUserInputBody: Swift.Equatable {
    let username: Swift.String?
    let instanceId: Swift.String?
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let domain: Swift.String?
}

extension AssociateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension AssociateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceUserSummary = output.instanceUserSummary
        } else {
            self.instanceUserSummary = nil
        }
    }
}

public struct AssociateUserOutput: Swift.Equatable {
    /// Metadata that describes the associate user operation.
    /// This member is required.
    public var instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?

    public init(
        instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary? = nil
    )
    {
        self.instanceUserSummary = instanceUserSummary
    }
}

struct AssociateUserOutputBody: Swift.Equatable {
    let instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?
}

extension AssociateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUserSummary = "InstanceUserSummary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUserSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary.self, forKey: .instanceUserSummary)
        instanceUserSummary = instanceUserSummaryDecoded
    }
}

enum AssociateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request couldn't be completed because it conflicted with the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeregisterIdentityProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider = "IdentityProvider"
        case product = "Product"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
    }
}

extension DeregisterIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/identity-provider/DeregisterIdentityProvider"
    }
}

public struct DeregisterIdentityProviderInput: Swift.Equatable {
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?

    public init(
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil
    )
    {
        self.identityProvider = identityProvider
        self.product = product
    }
}

struct DeregisterIdentityProviderInputBody: Swift.Equatable {
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let product: Swift.String?
}

extension DeregisterIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider = "IdentityProvider"
        case product = "Product"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
    }
}

extension DeregisterIdentityProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeregisterIdentityProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderSummary = output.identityProviderSummary
        } else {
            self.identityProviderSummary = nil
        }
    }
}

public struct DeregisterIdentityProviderOutput: Swift.Equatable {
    /// Metadata that describes the results of an identity provider operation.
    /// This member is required.
    public var identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?

    public init(
        identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary? = nil
    )
    {
        self.identityProviderSummary = identityProviderSummary
    }
}

struct DeregisterIdentityProviderOutputBody: Swift.Equatable {
    let identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?
}

extension DeregisterIdentityProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderSummary = "IdentityProviderSummary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.self, forKey: .identityProviderSummary)
        identityProviderSummary = identityProviderSummaryDecoded
    }
}

enum DeregisterIdentityProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension DisassociateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user/DisassociateUser"
    }
}

public struct DisassociateUserInput: Swift.Equatable {
    /// The domain name of the user.
    public var domain: Swift.String?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The ID of the EC2 instance, which provides user-based subscriptions.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The user name from the identity provider for the user.
    /// This member is required.
    public var username: Swift.String?

    public init(
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        instanceId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.domain = domain
        self.identityProvider = identityProvider
        self.instanceId = instanceId
        self.username = username
    }
}

struct DisassociateUserInputBody: Swift.Equatable {
    let username: Swift.String?
    let instanceId: Swift.String?
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let domain: Swift.String?
}

extension DisassociateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DisassociateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceUserSummary = output.instanceUserSummary
        } else {
            self.instanceUserSummary = nil
        }
    }
}

public struct DisassociateUserOutput: Swift.Equatable {
    /// Metadata that describes the associate user operation.
    /// This member is required.
    public var instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?

    public init(
        instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary? = nil
    )
    {
        self.instanceUserSummary = instanceUserSummary
    }
}

struct DisassociateUserOutputBody: Swift.Equatable {
    let instanceUserSummary: LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?
}

extension DisassociateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUserSummary = "InstanceUserSummary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUserSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary.self, forKey: .instanceUserSummary)
        instanceUserSummary = instanceUserSummaryDecoded
    }
}

enum DisassociateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute = "Attribute"
        case operation = "Operation"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attribute)
        attribute = attributeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// A filter name and value pair that is used to return more specific results from a describe operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs.
    public struct Filter: Swift.Equatable {
        /// The name of an attribute to use as a filter.
        public var attribute: Swift.String?
        /// The type of search (For example, eq, geq, leq)
        public var operation: Swift.String?
        /// Value of the filter.
        public var value: Swift.String?

        public init(
            attribute: Swift.String? = nil,
            operation: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.attribute = attribute
            self.operation = operation
            self.value = value
        }
    }

}

extension LicenseManagerUserSubscriptionsClientTypes.IdentityProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activedirectoryidentityprovider = "ActiveDirectoryIdentityProvider"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .activedirectoryidentityprovider(activedirectoryidentityprovider):
                try container.encode(activedirectoryidentityprovider, forKey: .activedirectoryidentityprovider)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let activedirectoryidentityproviderDecoded = try values.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider.self, forKey: .activedirectoryidentityprovider)
        if let activedirectoryidentityprovider = activedirectoryidentityproviderDecoded {
            self = .activedirectoryidentityprovider(activedirectoryidentityprovider)
            return
        }
        self = .sdkUnknown("")
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// Details about an identity provider.
    public enum IdentityProvider: Swift.Equatable {
        /// An object that details an Active Directory identity provider.
        case activedirectoryidentityprovider(LicenseManagerUserSubscriptionsClientTypes.ActiveDirectoryIdentityProvider)
        case sdkUnknown(Swift.String)
    }

}

extension LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureMessage = "FailureMessage"
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case settings = "Settings"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureMessage = self.failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// Describes an identity provider.
    public struct IdentityProviderSummary: Swift.Equatable {
        /// The failure message associated with an identity provider.
        public var failureMessage: Swift.String?
        /// An object that specifies details for the identity provider.
        /// This member is required.
        public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
        /// The name of the user-based subscription product.
        /// This member is required.
        public var product: Swift.String?
        /// An object that details the registered identity providerâ€™s product related configuration settings such as the subnets to provision VPC endpoints.
        /// This member is required.
        public var settings: LicenseManagerUserSubscriptionsClientTypes.Settings?
        /// The status of an identity provider.
        /// This member is required.
        public var status: Swift.String?

        public init(
            failureMessage: Swift.String? = nil,
            identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
            product: Swift.String? = nil,
            settings: LicenseManagerUserSubscriptionsClientTypes.Settings? = nil,
            status: Swift.String? = nil
        )
        {
            self.failureMessage = failureMessage
            self.identityProvider = identityProvider
            self.product = product
            self.settings = settings
            self.status = status
        }
    }

}

extension LicenseManagerUserSubscriptionsClientTypes.InstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case lastStatusCheckDate = "LastStatusCheckDate"
        case products = "Products"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let lastStatusCheckDate = self.lastStatusCheckDate {
            try encodeContainer.encode(lastStatusCheckDate, forKey: .lastStatusCheckDate)
        }
        if let products = products {
            var productsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .products)
            for string0 in products {
                try productsContainer.encode(string0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let productsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .products)
        var productsDecoded0:[Swift.String]? = nil
        if let productsContainer = productsContainer {
            productsDecoded0 = [Swift.String]()
            for string0 in productsContainer {
                if let string0 = string0 {
                    productsDecoded0?.append(string0)
                }
            }
        }
        products = productsDecoded0
        let lastStatusCheckDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastStatusCheckDate)
        lastStatusCheckDate = lastStatusCheckDateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// Describes an EC2 instance providing user-based subscriptions.
    public struct InstanceSummary: Swift.Equatable {
        /// The ID of the EC2 instance, which provides user-based subscriptions.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The date of the last status check.
        public var lastStatusCheckDate: Swift.String?
        /// A list of provided user-based subscription products.
        /// This member is required.
        public var products: [Swift.String]?
        /// The status of an EC2 instance resource.
        /// This member is required.
        public var status: Swift.String?
        /// The status message for an EC2 instance.
        public var statusMessage: Swift.String?

        public init(
            instanceId: Swift.String? = nil,
            lastStatusCheckDate: Swift.String? = nil,
            products: [Swift.String]? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
            self.lastStatusCheckDate = lastStatusCheckDate
            self.products = products
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationDate = "AssociationDate"
        case disassociationDate = "DisassociationDate"
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationDate = self.associationDate {
            try encodeContainer.encode(associationDate, forKey: .associationDate)
        }
        if let disassociationDate = self.disassociationDate {
            try encodeContainer.encode(disassociationDate, forKey: .disassociationDate)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let associationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationDate)
        associationDate = associationDateDecoded
        let disassociationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disassociationDate)
        disassociationDate = disassociationDateDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// Describes users of an EC2 instance providing user-based subscriptions.
    public struct InstanceUserSummary: Swift.Equatable {
        /// The date a user was associated with an EC2 instance.
        public var associationDate: Swift.String?
        /// The date a user was disassociated from an EC2 instance.
        public var disassociationDate: Swift.String?
        /// The domain name of the user.
        public var domain: Swift.String?
        /// An object that specifies details for the identity provider.
        /// This member is required.
        public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
        /// The ID of the EC2 instance, which provides user-based subscriptions.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The status of a user associated with an EC2 instance.
        /// This member is required.
        public var status: Swift.String?
        /// The status message for users of an EC2 instance.
        public var statusMessage: Swift.String?
        /// The user name from the identity provider for the user.
        /// This member is required.
        public var username: Swift.String?

        public init(
            associationDate: Swift.String? = nil,
            disassociationDate: Swift.String? = nil,
            domain: Swift.String? = nil,
            identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
            instanceId: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.associationDate = associationDate
            self.disassociationDate = disassociationDate
            self.domain = domain
            self.identityProvider = identityProvider
            self.instanceId = instanceId
            self.status = status
            self.statusMessage = statusMessage
            self.username = username
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception occurred with the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListIdentityProvidersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListIdentityProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/identity-provider/ListIdentityProviders"
    }
}

public struct ListIdentityProvidersInput: Swift.Equatable {
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentityProvidersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListIdentityProvidersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIdentityProvidersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIdentityProvidersOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderSummaries = output.identityProviderSummaries
            self.nextToken = output.nextToken
        } else {
            self.identityProviderSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListIdentityProvidersOutput: Swift.Equatable {
    /// Metadata that describes the list identity providers operation.
    /// This member is required.
    public var identityProviderSummaries: [LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        identityProviderSummaries: [LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityProviderSummaries = identityProviderSummaries
        self.nextToken = nextToken
    }
}

struct ListIdentityProvidersOutputBody: Swift.Equatable {
    let identityProviderSummaries: [LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]?
    let nextToken: Swift.String?
}

extension ListIdentityProvidersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderSummaries = "IdentityProviderSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderSummariesContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?].self, forKey: .identityProviderSummaries)
        var identityProviderSummariesDecoded0:[LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]? = nil
        if let identityProviderSummariesContainer = identityProviderSummariesContainer {
            identityProviderSummariesDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary]()
            for structure0 in identityProviderSummariesContainer {
                if let structure0 = structure0 {
                    identityProviderSummariesDecoded0?.append(structure0)
                }
            }
        }
        identityProviderSummaries = identityProviderSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIdentityProvidersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/instance/ListInstances"
    }
}

public struct ListInstancesInput: Swift.Equatable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstancesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
}

extension ListInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceSummaries = output.instanceSummaries
            self.nextToken = output.nextToken
        } else {
            self.instanceSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstancesOutput: Swift.Equatable {
    /// Metadata that describes the list instances operation.
    public var instanceSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceSummaries = instanceSummaries
        self.nextToken = nextToken
    }
}

struct ListInstancesOutputBody: Swift.Equatable {
    let instanceSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]?
    let nextToken: Swift.String?
}

extension ListInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceSummaries = "InstanceSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceSummariesContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.InstanceSummary?].self, forKey: .instanceSummaries)
        var instanceSummariesDecoded0:[LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]? = nil
        if let instanceSummariesContainer = instanceSummariesContainer {
            instanceSummariesDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.InstanceSummary]()
            for structure0 in instanceSummariesContainer {
                if let structure0 = structure0 {
                    instanceSummariesDecoded0?.append(structure0)
                }
            }
        }
        instanceSummaries = instanceSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProductSubscriptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityProvider = "IdentityProvider"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case product = "Product"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
    }
}

extension ListProductSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user/ListProductSubscriptions"
    }
}

public struct ListProductSubscriptionsInput: Swift.Equatable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?

    public init(
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        product: Swift.String? = nil
    )
    {
        self.filters = filters
        self.identityProvider = identityProvider
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.product = product
    }
}

struct ListProductSubscriptionsInputBody: Swift.Equatable {
    let product: Swift.String?
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let maxResults: Swift.Int?
    let filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    let nextToken: Swift.String?
}

extension ListProductSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityProvider = "IdentityProvider"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case product = "Product"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProductSubscriptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProductSubscriptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.productUserSummaries = output.productUserSummaries
        } else {
            self.nextToken = nil
            self.productUserSummaries = nil
        }
    }
}

public struct ListProductSubscriptionsOutput: Swift.Equatable {
    /// Token for the next set of results.
    public var nextToken: Swift.String?
    /// Metadata that describes the list product subscriptions operation.
    public var productUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]?

    public init(
        nextToken: Swift.String? = nil,
        productUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.productUserSummaries = productUserSummaries
    }
}

struct ListProductSubscriptionsOutputBody: Swift.Equatable {
    let productUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]?
    let nextToken: Swift.String?
}

extension ListProductSubscriptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case productUserSummaries = "ProductUserSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productUserSummariesContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?].self, forKey: .productUserSummaries)
        var productUserSummariesDecoded0:[LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]? = nil
        if let productUserSummariesContainer = productUserSummariesContainer {
            productUserSummariesDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary]()
            for structure0 in productUserSummariesContainer {
                if let structure0 = structure0 {
                    productUserSummariesDecoded0?.append(structure0)
                }
            }
        }
        productUserSummaries = productUserSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProductSubscriptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUserAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListUserAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user/ListUserAssociations"
    }
}

public struct ListUserAssociationsInput: Swift.Equatable {
    /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.
    public var filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The ID of the EC2 instance, which provides user-based subscriptions.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.identityProvider = identityProvider
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserAssociationsInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let maxResults: Swift.Int?
    let filters: [LicenseManagerUserSubscriptionsClientTypes.Filter]?
    let nextToken: Swift.String?
}

extension ListUserAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityProvider = "IdentityProvider"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[LicenseManagerUserSubscriptionsClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUserAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUserAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceUserSummaries = output.instanceUserSummaries
            self.nextToken = output.nextToken
        } else {
            self.instanceUserSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListUserAssociationsOutput: Swift.Equatable {
    /// Metadata that describes the list user association operation.
    public var instanceUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]?
    /// Token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceUserSummaries = instanceUserSummaries
        self.nextToken = nextToken
    }
}

struct ListUserAssociationsOutputBody: Swift.Equatable {
    let instanceUserSummaries: [LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]?
    let nextToken: Swift.String?
}

extension ListUserAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUserSummaries = "InstanceUserSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUserSummariesContainer = try containerValues.decodeIfPresent([LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary?].self, forKey: .instanceUserSummaries)
        var instanceUserSummariesDecoded0:[LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]? = nil
        if let instanceUserSummariesContainer = instanceUserSummariesContainer {
            instanceUserSummariesDecoded0 = [LicenseManagerUserSubscriptionsClientTypes.InstanceUserSummary]()
            for structure0 in instanceUserSummariesContainer {
                if let structure0 = structure0 {
                    instanceUserSummariesDecoded0?.append(structure0)
                }
            }
        }
        instanceUserSummaries = instanceUserSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUserAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case subscriptionEndDate = "SubscriptionEndDate"
        case subscriptionStartDate = "SubscriptionStartDate"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let subscriptionEndDate = self.subscriptionEndDate {
            try encodeContainer.encode(subscriptionEndDate, forKey: .subscriptionEndDate)
        }
        if let subscriptionStartDate = self.subscriptionStartDate {
            try encodeContainer.encode(subscriptionStartDate, forKey: .subscriptionStartDate)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let subscriptionStartDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionStartDate)
        subscriptionStartDate = subscriptionStartDateDecoded
        let subscriptionEndDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionEndDate)
        subscriptionEndDate = subscriptionEndDateDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// The summary of the user-based subscription products for a user.
    public struct ProductUserSummary: Swift.Equatable {
        /// The domain name of the user.
        public var domain: Swift.String?
        /// An object that specifies details for the identity provider.
        /// This member is required.
        public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
        /// The name of the user-based subscription product.
        /// This member is required.
        public var product: Swift.String?
        /// The status of a product for a user.
        /// This member is required.
        public var status: Swift.String?
        /// The status message for a product for a user.
        public var statusMessage: Swift.String?
        /// The end date of a subscription.
        public var subscriptionEndDate: Swift.String?
        /// The start date of a subscription.
        public var subscriptionStartDate: Swift.String?
        /// The user name from the identity provider of the user.
        /// This member is required.
        public var username: Swift.String?

        public init(
            domain: Swift.String? = nil,
            identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
            product: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            subscriptionEndDate: Swift.String? = nil,
            subscriptionStartDate: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.domain = domain
            self.identityProvider = identityProvider
            self.product = product
            self.status = status
            self.statusMessage = statusMessage
            self.subscriptionEndDate = subscriptionEndDate
            self.subscriptionStartDate = subscriptionStartDate
            self.username = username
        }
    }

}

extension RegisterIdentityProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case settings = "Settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }
}

extension RegisterIdentityProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/identity-provider/RegisterIdentityProvider"
    }
}

public struct RegisterIdentityProviderInput: Swift.Equatable {
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?
    /// The registered identity providerâ€™s product related configuration settings such as the subnets to provision VPC endpoints.
    public var settings: LicenseManagerUserSubscriptionsClientTypes.Settings?

    public init(
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        settings: LicenseManagerUserSubscriptionsClientTypes.Settings? = nil
    )
    {
        self.identityProvider = identityProvider
        self.product = product
        self.settings = settings
    }
}

struct RegisterIdentityProviderInputBody: Swift.Equatable {
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let product: Swift.String?
    let settings: LicenseManagerUserSubscriptionsClientTypes.Settings?
}

extension RegisterIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case settings = "Settings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension RegisterIdentityProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterIdentityProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderSummary = output.identityProviderSummary
        } else {
            self.identityProviderSummary = nil
        }
    }
}

public struct RegisterIdentityProviderOutput: Swift.Equatable {
    /// Metadata that describes the results of an identity provider operation.
    /// This member is required.
    public var identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?

    public init(
        identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary? = nil
    )
    {
        self.identityProviderSummary = identityProviderSummary
    }
}

struct RegisterIdentityProviderOutputBody: Swift.Equatable {
    let identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?
}

extension RegisterIdentityProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderSummary = "IdentityProviderSummary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.self, forKey: .identityProviderSummary)
        identityProviderSummary = identityProviderSummaryDecoded
    }
}

enum RegisterIdentityProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource couldn't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because a service quota is exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.Settings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupId = "SecurityGroupId"
        case subnets = "Subnets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupId = self.securityGroupId {
            try encodeContainer.encode(securityGroupId, forKey: .securityGroupId)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnet0 in subnets {
                try subnetsContainer.encode(subnet0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupId)
        securityGroupId = securityGroupIdDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// The registered identity providerâ€™s product related configuration settings such as the subnets to provision VPC endpoints, and the security group ID that is associated with the VPC endpoints. The security group should permit inbound TCP port 1688 communication from resources in the VPC.
    public struct Settings: Swift.Equatable {
        /// A security group ID that allows inbound TCP port 1688 communication between resources in your VPC and the VPC endpoint for activation servers.
        /// This member is required.
        public var securityGroupId: Swift.String?
        /// The subnets defined for the registered identity provider.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init(
            securityGroupId: Swift.String? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.securityGroupId = securityGroupId
            self.subnets = subnets
        }
    }

}

extension StartProductSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension StartProductSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user/StartProductSubscription"
    }
}

public struct StartProductSubscriptionInput: Swift.Equatable {
    /// The domain name of the user.
    public var domain: Swift.String?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?
    /// The user name from the identity provider of the user.
    /// This member is required.
    public var username: Swift.String?

    public init(
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.domain = domain
        self.identityProvider = identityProvider
        self.product = product
        self.username = username
    }
}

struct StartProductSubscriptionInputBody: Swift.Equatable {
    let username: Swift.String?
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let product: Swift.String?
    let domain: Swift.String?
}

extension StartProductSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension StartProductSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartProductSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.productUserSummary = output.productUserSummary
        } else {
            self.productUserSummary = nil
        }
    }
}

public struct StartProductSubscriptionOutput: Swift.Equatable {
    /// Metadata that describes the start product subscription operation.
    /// This member is required.
    public var productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?

    public init(
        productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary? = nil
    )
    {
        self.productUserSummary = productUserSummary
    }
}

struct StartProductSubscriptionOutputBody: Swift.Equatable {
    let productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?
}

extension StartProductSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productUserSummary = "ProductUserSummary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productUserSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary.self, forKey: .productUserSummary)
        productUserSummary = productUserSummaryDecoded
    }
}

enum StartProductSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopProductSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension StopProductSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user/StopProductSubscription"
    }
}

public struct StopProductSubscriptionInput: Swift.Equatable {
    /// The domain name of the user.
    public var domain: Swift.String?
    /// An object that specifies details for the identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?
    /// The user name from the identity provider for the user.
    /// This member is required.
    public var username: Swift.String?

    public init(
        domain: Swift.String? = nil,
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.domain = domain
        self.identityProvider = identityProvider
        self.product = product
        self.username = username
    }
}

struct StopProductSubscriptionInputBody: Swift.Equatable {
    let username: Swift.String?
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let product: Swift.String?
    let domain: Swift.String?
}

extension StopProductSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension StopProductSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopProductSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.productUserSummary = output.productUserSummary
        } else {
            self.productUserSummary = nil
        }
    }
}

public struct StopProductSubscriptionOutput: Swift.Equatable {
    /// Metadata that describes the start product subscription operation.
    /// This member is required.
    public var productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?

    public init(
        productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary? = nil
    )
    {
        self.productUserSummary = productUserSummary
    }
}

struct StopProductSubscriptionOutputBody: Swift.Equatable {
    let productUserSummary: LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary?
}

extension StopProductSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productUserSummary = "ProductUserSummary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productUserSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.ProductUserSummary.self, forKey: .productUserSummary)
        productUserSummary = productUserSummaryDecoded
    }
}

enum StopProductSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because of request throttling. Retry the request.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateIdentityProviderSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case updateSettings = "UpdateSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProvider = self.identityProvider {
            try encodeContainer.encode(identityProvider, forKey: .identityProvider)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let updateSettings = self.updateSettings {
            try encodeContainer.encode(updateSettings, forKey: .updateSettings)
        }
    }
}

extension UpdateIdentityProviderSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/identity-provider/UpdateIdentityProviderSettings"
    }
}

public struct UpdateIdentityProviderSettingsInput: Swift.Equatable {
    /// Details about an identity provider.
    /// This member is required.
    public var identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    /// The name of the user-based subscription product.
    /// This member is required.
    public var product: Swift.String?
    /// Updates the registered identity providerâ€™s product related configuration settings. You can update any combination of settings in a single operation such as the:
    ///
    /// * Subnets which you want to add to provision VPC endpoints.
    ///
    /// * Subnets which you want to remove the VPC endpoints from.
    ///
    /// * Security group ID which permits traffic to the VPC endpoints.
    /// This member is required.
    public var updateSettings: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings?

    public init(
        identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider? = nil,
        product: Swift.String? = nil,
        updateSettings: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings? = nil
    )
    {
        self.identityProvider = identityProvider
        self.product = product
        self.updateSettings = updateSettings
    }
}

struct UpdateIdentityProviderSettingsInputBody: Swift.Equatable {
    let identityProvider: LicenseManagerUserSubscriptionsClientTypes.IdentityProvider?
    let product: Swift.String?
    let updateSettings: LicenseManagerUserSubscriptionsClientTypes.UpdateSettings?
}

extension UpdateIdentityProviderSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider = "IdentityProvider"
        case product = "Product"
        case updateSettings = "UpdateSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
        let updateSettingsDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.UpdateSettings.self, forKey: .updateSettings)
        updateSettings = updateSettingsDecoded
    }
}

extension UpdateIdentityProviderSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIdentityProviderSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderSummary = output.identityProviderSummary
        } else {
            self.identityProviderSummary = nil
        }
    }
}

public struct UpdateIdentityProviderSettingsOutput: Swift.Equatable {
    /// Describes an identity provider.
    /// This member is required.
    public var identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?

    public init(
        identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary? = nil
    )
    {
        self.identityProviderSummary = identityProviderSummary
    }
}

struct UpdateIdentityProviderSettingsOutputBody: Swift.Equatable {
    let identityProviderSummary: LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary?
}

extension UpdateIdentityProviderSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderSummary = "IdentityProviderSummary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderSummaryDecoded = try containerValues.decodeIfPresent(LicenseManagerUserSubscriptionsClientTypes.IdentityProviderSummary.self, forKey: .identityProviderSummary)
        identityProviderSummary = identityProviderSummaryDecoded
    }
}

enum UpdateIdentityProviderSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LicenseManagerUserSubscriptionsClientTypes.UpdateSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addSubnets = "AddSubnets"
        case removeSubnets = "RemoveSubnets"
        case securityGroupId = "SecurityGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addSubnets = addSubnets {
            var addSubnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addSubnets)
            for subnet0 in addSubnets {
                try addSubnetsContainer.encode(subnet0)
            }
        }
        if let removeSubnets = removeSubnets {
            var removeSubnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeSubnets)
            for subnet0 in removeSubnets {
                try removeSubnetsContainer.encode(subnet0)
            }
        }
        if let securityGroupId = self.securityGroupId {
            try encodeContainer.encode(securityGroupId, forKey: .securityGroupId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addSubnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .addSubnets)
        var addSubnetsDecoded0:[Swift.String]? = nil
        if let addSubnetsContainer = addSubnetsContainer {
            addSubnetsDecoded0 = [Swift.String]()
            for string0 in addSubnetsContainer {
                if let string0 = string0 {
                    addSubnetsDecoded0?.append(string0)
                }
            }
        }
        addSubnets = addSubnetsDecoded0
        let removeSubnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeSubnets)
        var removeSubnetsDecoded0:[Swift.String]? = nil
        if let removeSubnetsContainer = removeSubnetsContainer {
            removeSubnetsDecoded0 = [Swift.String]()
            for string0 in removeSubnetsContainer {
                if let string0 = string0 {
                    removeSubnetsDecoded0?.append(string0)
                }
            }
        }
        removeSubnets = removeSubnetsDecoded0
        let securityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroupId)
        securityGroupId = securityGroupIdDecoded
    }
}

extension LicenseManagerUserSubscriptionsClientTypes {
    /// Updates the registered identity providerâ€™s product related configuration settings such as the subnets to provision VPC endpoints.
    public struct UpdateSettings: Swift.Equatable {
        /// The ID of one or more subnets in which License Manager will create a VPC endpoint for products that require connectivity to activation servers.
        /// This member is required.
        public var addSubnets: [Swift.String]?
        /// The ID of one or more subnets to remove.
        /// This member is required.
        public var removeSubnets: [Swift.String]?
        /// A security group ID that allows inbound TCP port 1688 communication between resources in your VPC and the VPC endpoints for activation servers.
        public var securityGroupId: Swift.String?

        public init(
            addSubnets: [Swift.String]? = nil,
            removeSubnets: [Swift.String]? = nil,
            securityGroupId: Swift.String? = nil
        )
        {
            self.addSubnets = addSubnets
            self.removeSubnets = removeSubnets
            self.securityGroupId = securityGroupId
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A parameter is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
