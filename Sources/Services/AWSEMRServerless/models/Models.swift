// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension EMRServerlessClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case architecture
        case arn
        case autoStartConfiguration
        case autoStopConfiguration
        case createdAt
        case imageConfiguration
        case initialCapacity
        case maximumCapacity
        case monitoringConfiguration
        case name
        case networkConfiguration
        case releaseLabel
        case runtimeConfiguration
        case state
        case stateDetails
        case tags
        case type
        case updatedAt
        case workerTypeSpecifications
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let autoStartConfiguration = self.autoStartConfiguration {
            try encodeContainer.encode(autoStartConfiguration, forKey: .autoStartConfiguration)
        }
        if let autoStopConfiguration = self.autoStopConfiguration {
            try encodeContainer.encode(autoStopConfiguration, forKey: .autoStopConfiguration)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let imageConfiguration = self.imageConfiguration {
            try encodeContainer.encode(imageConfiguration, forKey: .imageConfiguration)
        }
        if let initialCapacity = initialCapacity {
            var initialCapacityContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .initialCapacity)
            for (dictKey0, initialCapacityConfigMap0) in initialCapacity {
                try initialCapacityContainer.encode(initialCapacityConfigMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let maximumCapacity = self.maximumCapacity {
            try encodeContainer.encode(maximumCapacity, forKey: .maximumCapacity)
        }
        if let monitoringConfiguration = self.monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let runtimeConfiguration = runtimeConfiguration {
            var runtimeConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runtimeConfiguration)
            for configuration0 in runtimeConfiguration {
                try runtimeConfigurationContainer.encode(configuration0)
            }
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = self.stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let workerTypeSpecifications = workerTypeSpecifications {
            var workerTypeSpecificationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .workerTypeSpecifications)
            for (dictKey0, workerTypeSpecificationMap0) in workerTypeSpecifications {
                try workerTypeSpecificationsContainer.encode(workerTypeSpecificationMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.ApplicationState.self, forKey: .state)
        state = stateDecoded
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let initialCapacityContainer = try containerValues.decodeIfPresent([Swift.String: EMRServerlessClientTypes.InitialCapacityConfig?].self, forKey: .initialCapacity)
        var initialCapacityDecoded0: [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]? = nil
        if let initialCapacityContainer = initialCapacityContainer {
            initialCapacityDecoded0 = [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]()
            for (key0, initialcapacityconfig0) in initialCapacityContainer {
                if let initialcapacityconfig0 = initialcapacityconfig0 {
                    initialCapacityDecoded0?[key0] = initialcapacityconfig0
                }
            }
        }
        initialCapacity = initialCapacityDecoded0
        let maximumCapacityDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.MaximumAllowedResources.self, forKey: .maximumCapacity)
        maximumCapacity = maximumCapacityDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let autoStartConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.AutoStartConfig.self, forKey: .autoStartConfiguration)
        autoStartConfiguration = autoStartConfigurationDecoded
        let autoStopConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.AutoStopConfig.self, forKey: .autoStopConfiguration)
        autoStopConfiguration = autoStopConfigurationDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let imageConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.ImageConfiguration.self, forKey: .imageConfiguration)
        imageConfiguration = imageConfigurationDecoded
        let workerTypeSpecificationsContainer = try containerValues.decodeIfPresent([Swift.String: EMRServerlessClientTypes.WorkerTypeSpecification?].self, forKey: .workerTypeSpecifications)
        var workerTypeSpecificationsDecoded0: [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecification]? = nil
        if let workerTypeSpecificationsContainer = workerTypeSpecificationsContainer {
            workerTypeSpecificationsDecoded0 = [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecification]()
            for (key0, workertypespecification0) in workerTypeSpecificationsContainer {
                if let workertypespecification0 = workertypespecification0 {
                    workerTypeSpecificationsDecoded0?[key0] = workertypespecification0
                }
            }
        }
        workerTypeSpecifications = workerTypeSpecificationsDecoded0
        let runtimeConfigurationContainer = try containerValues.decodeIfPresent([EMRServerlessClientTypes.Configuration?].self, forKey: .runtimeConfiguration)
        var runtimeConfigurationDecoded0:[EMRServerlessClientTypes.Configuration]? = nil
        if let runtimeConfigurationContainer = runtimeConfigurationContainer {
            runtimeConfigurationDecoded0 = [EMRServerlessClientTypes.Configuration]()
            for structure0 in runtimeConfigurationContainer {
                if let structure0 = structure0 {
                    runtimeConfigurationDecoded0?.append(structure0)
                }
            }
        }
        runtimeConfiguration = runtimeConfigurationDecoded0
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.MonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
    }
}

extension EMRServerlessClientTypes {
    /// Information about an application. Amazon EMR Serverless uses applications to run jobs.
    public struct Application: Swift.Equatable {
        /// The ID of the application.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The CPU architecture of an application.
        public var architecture: EMRServerlessClientTypes.Architecture?
        /// The ARN of the application.
        /// This member is required.
        public var arn: Swift.String?
        /// The configuration for an application to automatically start on job submission.
        public var autoStartConfiguration: EMRServerlessClientTypes.AutoStartConfig?
        /// The configuration for an application to automatically stop after a certain amount of time being idle.
        public var autoStopConfiguration: EMRServerlessClientTypes.AutoStopConfig?
        /// The date and time when the application run was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The image configuration applied to all worker types.
        public var imageConfiguration: EMRServerlessClientTypes.ImageConfiguration?
        /// The initial capacity of the application.
        public var initialCapacity: [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]?
        /// The maximum capacity of the application. This is cumulative across all workers at any given point in time during the lifespan of the application is created. No new resources will be created once any one of the defined limits is hit.
        public var maximumCapacity: EMRServerlessClientTypes.MaximumAllowedResources?
        /// The configuration setting for monitoring.
        public var monitoringConfiguration: EMRServerlessClientTypes.MonitoringConfiguration?
        /// The name of the application.
        public var name: Swift.String?
        /// The network configuration for customer VPC connectivity for the application.
        public var networkConfiguration: EMRServerlessClientTypes.NetworkConfiguration?
        /// The Amazon EMR release associated with the application.
        /// This member is required.
        public var releaseLabel: Swift.String?
        /// The [Configuration](https://docs.aws.amazon.com/emr-serverless/latest/APIReference/API_Configuration.html) specifications of an application. Each configuration consists of a classification and properties. You use this parameter when creating or updating an application. To see the runtimeConfiguration object of an application, run the [GetApplication](https://docs.aws.amazon.com/emr-serverless/latest/APIReference/API_GetApplication.html) API operation.
        public var runtimeConfiguration: [EMRServerlessClientTypes.Configuration]?
        /// The state of the application.
        /// This member is required.
        public var state: EMRServerlessClientTypes.ApplicationState?
        /// The state details of the application.
        public var stateDetails: Swift.String?
        /// The tags assigned to the application.
        public var tags: [Swift.String:Swift.String]?
        /// The type of application, such as Spark or Hive.
        /// This member is required.
        public var type: Swift.String?
        /// The date and time when the application run was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The specification applied to each worker type.
        public var workerTypeSpecifications: [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecification]?

        public init(
            applicationId: Swift.String? = nil,
            architecture: EMRServerlessClientTypes.Architecture? = nil,
            arn: Swift.String? = nil,
            autoStartConfiguration: EMRServerlessClientTypes.AutoStartConfig? = nil,
            autoStopConfiguration: EMRServerlessClientTypes.AutoStopConfig? = nil,
            createdAt: ClientRuntime.Date? = nil,
            imageConfiguration: EMRServerlessClientTypes.ImageConfiguration? = nil,
            initialCapacity: [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]? = nil,
            maximumCapacity: EMRServerlessClientTypes.MaximumAllowedResources? = nil,
            monitoringConfiguration: EMRServerlessClientTypes.MonitoringConfiguration? = nil,
            name: Swift.String? = nil,
            networkConfiguration: EMRServerlessClientTypes.NetworkConfiguration? = nil,
            releaseLabel: Swift.String? = nil,
            runtimeConfiguration: [EMRServerlessClientTypes.Configuration]? = nil,
            state: EMRServerlessClientTypes.ApplicationState? = nil,
            stateDetails: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            workerTypeSpecifications: [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecification]? = nil
        )
        {
            self.applicationId = applicationId
            self.architecture = architecture
            self.arn = arn
            self.autoStartConfiguration = autoStartConfiguration
            self.autoStopConfiguration = autoStopConfiguration
            self.createdAt = createdAt
            self.imageConfiguration = imageConfiguration
            self.initialCapacity = initialCapacity
            self.maximumCapacity = maximumCapacity
            self.monitoringConfiguration = monitoringConfiguration
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.releaseLabel = releaseLabel
            self.runtimeConfiguration = runtimeConfiguration
            self.state = state
            self.stateDetails = stateDetails
            self.tags = tags
            self.type = type
            self.updatedAt = updatedAt
            self.workerTypeSpecifications = workerTypeSpecifications
        }
    }

}

extension EMRServerlessClientTypes {
    public enum ApplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case started
        case starting
        case stopped
        case stopping
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationState] {
            return [
                .created,
                .creating,
                .started,
                .starting,
                .stopped,
                .stopping,
                .terminated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .started: return "STARTED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationState(rawValue: rawValue) ?? ApplicationState.sdkUnknown(rawValue)
        }
    }
}

extension EMRServerlessClientTypes.ApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case arn
        case createdAt
        case id
        case name
        case releaseLabel
        case state
        case stateDetails
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = self.stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.ApplicationState.self, forKey: .state)
        state = stateDecoded
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The summary of attributes associated with an application.
    public struct ApplicationSummary: Swift.Equatable {
        /// The CPU architecture of an application.
        public var architecture: EMRServerlessClientTypes.Architecture?
        /// The ARN of the application.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the application was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the application.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the application.
        public var name: Swift.String?
        /// The Amazon EMR release associated with the application.
        /// This member is required.
        public var releaseLabel: Swift.String?
        /// The state of the application.
        /// This member is required.
        public var state: EMRServerlessClientTypes.ApplicationState?
        /// The state details of the application.
        public var stateDetails: Swift.String?
        /// The type of application, such as Spark or Hive.
        /// This member is required.
        public var type: Swift.String?
        /// The date and time when the application was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            architecture: EMRServerlessClientTypes.Architecture? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            releaseLabel: Swift.String? = nil,
            state: EMRServerlessClientTypes.ApplicationState? = nil,
            stateDetails: Swift.String? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.architecture = architecture
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.releaseLabel = releaseLabel
            self.state = state
            self.stateDetails = stateDetails
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension EMRServerlessClientTypes {
    public enum Architecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arm64
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .arm64,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "ARM64"
            case .x8664: return "X86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Architecture(rawValue: rawValue) ?? Architecture.sdkUnknown(rawValue)
        }
    }
}

extension EMRServerlessClientTypes.AutoStartConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The configuration for an application to automatically start on job submission.
    public struct AutoStartConfig: Swift.Equatable {
        /// Enables the application to automatically start on job submission. Defaults to true.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension EMRServerlessClientTypes.AutoStopConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case idleTimeoutMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let idleTimeoutMinutes = self.idleTimeoutMinutes {
            try encodeContainer.encode(idleTimeoutMinutes, forKey: .idleTimeoutMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let idleTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleTimeoutMinutes)
        idleTimeoutMinutes = idleTimeoutMinutesDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The configuration for an application to automatically stop after a certain amount of time being idle.
    public struct AutoStopConfig: Swift.Equatable {
        /// Enables the application to automatically stop after a certain amount of time being idle. Defaults to true.
        public var enabled: Swift.Bool?
        /// The amount of idle time in minutes after which your application will automatically stop. Defaults to 15 minutes.
        public var idleTimeoutMinutes: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            idleTimeoutMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.idleTimeoutMinutes = idleTimeoutMinutes
        }
    }

}

extension CancelJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let jobRunId = jobRunId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/jobruns/\(jobRunId.urlPercentEncoding())"
    }
}

public struct CancelJobRunInput: Swift.Equatable {
    /// The ID of the application on which the job run will be canceled.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the job run to cancel.
    /// This member is required.
    public var jobRunId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        jobRunId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.jobRunId = jobRunId
    }
}

struct CancelJobRunInputBody: Swift.Equatable {
}

extension CancelJobRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelJobRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelJobRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.jobRunId = output.jobRunId
        } else {
            self.applicationId = nil
            self.jobRunId = nil
        }
    }
}

public struct CancelJobRunOutput: Swift.Equatable {
    /// The output contains the application ID on which the job run is cancelled.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The output contains the ID of the cancelled job run.
    /// This member is required.
    public var jobRunId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        jobRunId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.jobRunId = jobRunId
    }
}

struct CancelJobRunOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let jobRunId: Swift.String?
}

extension CancelJobRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case jobRunId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let jobRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobRunId)
        jobRunId = jobRunIdDecoded
    }
}

enum CancelJobRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EMRServerlessClientTypes.CloudWatchLoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case encryptionKeyArn
        case logGroupName
        case logStreamNamePrefix
        case logTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let logStreamNamePrefix = self.logStreamNamePrefix {
            try encodeContainer.encode(logStreamNamePrefix, forKey: .logStreamNamePrefix)
        }
        if let logTypes = logTypes {
            var logTypesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logTypes)
            for (dictKey0, logTypeMap0) in logTypes {
                var logTypeMap0Container = logTypesContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for logtypestring1 in logTypeMap0 {
                    try logTypeMap0Container.encode(logtypestring1)
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let logStreamNamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStreamNamePrefix)
        logStreamNamePrefix = logStreamNamePrefixDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let logTypesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .logTypes)
        var logTypesDecoded0: [Swift.String:[Swift.String]]? = nil
        if let logTypesContainer = logTypesContainer {
            logTypesDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, logtypelist0) in logTypesContainer {
                var logtypelist0Decoded0: [Swift.String]? = nil
                if let logtypelist0 = logtypelist0 {
                    logtypelist0Decoded0 = [Swift.String]()
                    for string1 in logtypelist0 {
                        if let string1 = string1 {
                            logtypelist0Decoded0?.append(string1)
                        }
                    }
                }
                logTypesDecoded0?[key0] = logtypelist0Decoded0
            }
        }
        logTypes = logTypesDecoded0
    }
}

extension EMRServerlessClientTypes {
    /// The Amazon CloudWatch configuration for monitoring logs. You can configure your jobs to send log information to CloudWatch.
    public struct CloudWatchLoggingConfiguration: Swift.Equatable {
        /// Enables CloudWatch logging.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The Key Management Service (KMS) key ARN to encrypt the logs that you store in CloudWatch Logs.
        public var encryptionKeyArn: Swift.String?
        /// The name of the log group in Amazon CloudWatch Logs where you want to publish your logs.
        public var logGroupName: Swift.String?
        /// Prefix for the CloudWatch log stream name.
        public var logStreamNamePrefix: Swift.String?
        /// The types of logs that you want to publish to CloudWatch. If you don't specify any log types, driver STDOUT and STDERR logs will be published to CloudWatch Logs by default. For more information including the supported worker types for Hive and Spark, see [Logging for EMR Serverless with CloudWatch](https://docs.aws.amazon.com/emr/latest/EMR-Serverless-UserGuide/logging.html#jobs-log-storage-cw).
        ///
        /// * Key Valid Values: SPARK_DRIVER, SPARK_EXECUTOR, HIVE_DRIVER, TEZ_TASK
        ///
        /// * Array Members Valid Values: STDOUT, STDERR, HIVE_LOG, TEZ_AM, SYSTEM_LOGS
        public var logTypes: [Swift.String:[Swift.String]]?

        public init(
            enabled: Swift.Bool? = nil,
            encryptionKeyArn: Swift.String? = nil,
            logGroupName: Swift.String? = nil,
            logStreamNamePrefix: Swift.String? = nil,
            logTypes: [Swift.String:[Swift.String]]? = nil
        )
        {
            self.enabled = enabled
            self.encryptionKeyArn = encryptionKeyArn
            self.logGroupName = logGroupName
            self.logStreamNamePrefix = logStreamNamePrefix
            self.logTypes = logTypes
        }
    }

}

extension EMRServerlessClientTypes.Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classification
        case configurations
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classification = self.classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurations)
            for configuration0 in configurations {
                try configurationsContainer.encode(configuration0)
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, sensitivePropertiesMap0) in properties {
                try propertiesContainer.encode(sensitivePropertiesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classificationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .classification)
        classification = classificationDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string10240) in propertiesContainer {
                if let string10240 = string10240 {
                    propertiesDecoded0?[key0] = string10240
                }
            }
        }
        properties = propertiesDecoded0
        let configurationsContainer = try containerValues.decodeIfPresent([EMRServerlessClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0:[EMRServerlessClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [EMRServerlessClientTypes.Configuration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
    }
}

extension EMRServerlessClientTypes.Configuration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Configuration(classification: \(Swift.String(describing: classification)), configurations: \(Swift.String(describing: configurations)), properties: \"CONTENT_REDACTED\")"}
}

extension EMRServerlessClientTypes {
    /// A configuration specification to be used when provisioning an application. A configuration consists of a classification, properties, and optional nested configurations. A classification refers to an application-specific configuration file. Properties are the settings you want to change in that file.
    public struct Configuration: Swift.Equatable {
        /// The classification within a configuration.
        /// This member is required.
        public var classification: Swift.String?
        /// A list of additional configurations to apply within a configuration object.
        public var configurations: [EMRServerlessClientTypes.Configuration]?
        /// A set of properties specified within a configuration classification.
        public var properties: [Swift.String:Swift.String]?

        public init(
            classification: Swift.String? = nil,
            configurations: [EMRServerlessClientTypes.Configuration]? = nil,
            properties: [Swift.String:Swift.String]? = nil
        )
        {
            self.classification = classification
            self.configurations = configurations
            self.properties = properties
        }
    }

}

extension EMRServerlessClientTypes.ConfigurationOverrides: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfiguration
        case monitoringConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfiguration = applicationConfiguration {
            var applicationConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationConfiguration)
            for configuration0 in applicationConfiguration {
                try applicationConfigurationContainer.encode(configuration0)
            }
        }
        if let monitoringConfiguration = self.monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationConfigurationContainer = try containerValues.decodeIfPresent([EMRServerlessClientTypes.Configuration?].self, forKey: .applicationConfiguration)
        var applicationConfigurationDecoded0:[EMRServerlessClientTypes.Configuration]? = nil
        if let applicationConfigurationContainer = applicationConfigurationContainer {
            applicationConfigurationDecoded0 = [EMRServerlessClientTypes.Configuration]()
            for structure0 in applicationConfigurationContainer {
                if let structure0 = structure0 {
                    applicationConfigurationDecoded0?.append(structure0)
                }
            }
        }
        applicationConfiguration = applicationConfigurationDecoded0
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.MonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
    }
}

extension EMRServerlessClientTypes {
    /// A configuration specification to be used to override existing configurations.
    public struct ConfigurationOverrides: Swift.Equatable {
        /// The override configurations for the application.
        public var applicationConfiguration: [EMRServerlessClientTypes.Configuration]?
        /// The override configurations for monitoring.
        public var monitoringConfiguration: EMRServerlessClientTypes.MonitoringConfiguration?

        public init(
            applicationConfiguration: [EMRServerlessClientTypes.Configuration]? = nil,
            monitoringConfiguration: EMRServerlessClientTypes.MonitoringConfiguration? = nil
        )
        {
            self.applicationConfiguration = applicationConfiguration
            self.monitoringConfiguration = monitoringConfiguration
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case autoStartConfiguration
        case autoStopConfiguration
        case clientToken
        case imageConfiguration
        case initialCapacity
        case maximumCapacity
        case monitoringConfiguration
        case name
        case networkConfiguration
        case releaseLabel
        case runtimeConfiguration
        case tags
        case type
        case workerTypeSpecifications
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let autoStartConfiguration = self.autoStartConfiguration {
            try encodeContainer.encode(autoStartConfiguration, forKey: .autoStartConfiguration)
        }
        if let autoStopConfiguration = self.autoStopConfiguration {
            try encodeContainer.encode(autoStopConfiguration, forKey: .autoStopConfiguration)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let imageConfiguration = self.imageConfiguration {
            try encodeContainer.encode(imageConfiguration, forKey: .imageConfiguration)
        }
        if let initialCapacity = initialCapacity {
            var initialCapacityContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .initialCapacity)
            for (dictKey0, initialCapacityConfigMap0) in initialCapacity {
                try initialCapacityContainer.encode(initialCapacityConfigMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let maximumCapacity = self.maximumCapacity {
            try encodeContainer.encode(maximumCapacity, forKey: .maximumCapacity)
        }
        if let monitoringConfiguration = self.monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let runtimeConfiguration = runtimeConfiguration {
            var runtimeConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runtimeConfiguration)
            for configuration0 in runtimeConfiguration {
                try runtimeConfigurationContainer.encode(configuration0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let workerTypeSpecifications = workerTypeSpecifications {
            var workerTypeSpecificationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .workerTypeSpecifications)
            for (dictKey0, workerTypeSpecificationInputMap0) in workerTypeSpecifications {
                try workerTypeSpecificationsContainer.encode(workerTypeSpecificationInputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// The CPU architecture of an application.
    public var architecture: EMRServerlessClientTypes.Architecture?
    /// The configuration for an application to automatically start on job submission.
    public var autoStartConfiguration: EMRServerlessClientTypes.AutoStartConfig?
    /// The configuration for an application to automatically stop after a certain amount of time being idle.
    public var autoStopConfiguration: EMRServerlessClientTypes.AutoStopConfig?
    /// The client idempotency token of the application to create. Its value must be unique for each request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The image configuration for all worker types. You can either set this parameter or imageConfiguration for each worker type in workerTypeSpecifications.
    public var imageConfiguration: EMRServerlessClientTypes.ImageConfigurationInput?
    /// The capacity to initialize when the application is created.
    public var initialCapacity: [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]?
    /// The maximum capacity to allocate when the application is created. This is cumulative across all workers at any given point in time, not just when an application is created. No new resources will be created once any one of the defined limits is hit.
    public var maximumCapacity: EMRServerlessClientTypes.MaximumAllowedResources?
    /// The configuration setting for monitoring.
    public var monitoringConfiguration: EMRServerlessClientTypes.MonitoringConfiguration?
    /// The name of the application.
    public var name: Swift.String?
    /// The network configuration for customer VPC connectivity.
    public var networkConfiguration: EMRServerlessClientTypes.NetworkConfiguration?
    /// The Amazon EMR release associated with the application.
    /// This member is required.
    public var releaseLabel: Swift.String?
    /// The [Configuration](https://docs.aws.amazon.com/emr-serverless/latest/APIReference/API_Configuration.html) specifications to use when creating an application. Each configuration consists of a classification and properties. This configuration is applied to all the job runs submitted under the application.
    public var runtimeConfiguration: [EMRServerlessClientTypes.Configuration]?
    /// The tags assigned to the application.
    public var tags: [Swift.String:Swift.String]?
    /// The type of application you want to start, such as Spark or Hive.
    /// This member is required.
    public var type: Swift.String?
    /// The key-value pairs that specify worker type to WorkerTypeSpecificationInput. This parameter must contain all valid worker types for a Spark or Hive application. Valid worker types include Driver and Executor for Spark applications and HiveDriver and TezTask for Hive applications. You can either set image details in this parameter for each worker type, or in imageConfiguration for all worker types.
    public var workerTypeSpecifications: [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecificationInput]?

    public init(
        architecture: EMRServerlessClientTypes.Architecture? = nil,
        autoStartConfiguration: EMRServerlessClientTypes.AutoStartConfig? = nil,
        autoStopConfiguration: EMRServerlessClientTypes.AutoStopConfig? = nil,
        clientToken: Swift.String? = nil,
        imageConfiguration: EMRServerlessClientTypes.ImageConfigurationInput? = nil,
        initialCapacity: [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]? = nil,
        maximumCapacity: EMRServerlessClientTypes.MaximumAllowedResources? = nil,
        monitoringConfiguration: EMRServerlessClientTypes.MonitoringConfiguration? = nil,
        name: Swift.String? = nil,
        networkConfiguration: EMRServerlessClientTypes.NetworkConfiguration? = nil,
        releaseLabel: Swift.String? = nil,
        runtimeConfiguration: [EMRServerlessClientTypes.Configuration]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        workerTypeSpecifications: [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecificationInput]? = nil
    )
    {
        self.architecture = architecture
        self.autoStartConfiguration = autoStartConfiguration
        self.autoStopConfiguration = autoStopConfiguration
        self.clientToken = clientToken
        self.imageConfiguration = imageConfiguration
        self.initialCapacity = initialCapacity
        self.maximumCapacity = maximumCapacity
        self.monitoringConfiguration = monitoringConfiguration
        self.name = name
        self.networkConfiguration = networkConfiguration
        self.releaseLabel = releaseLabel
        self.runtimeConfiguration = runtimeConfiguration
        self.tags = tags
        self.type = type
        self.workerTypeSpecifications = workerTypeSpecifications
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let releaseLabel: Swift.String?
    let type: Swift.String?
    let clientToken: Swift.String?
    let initialCapacity: [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]?
    let maximumCapacity: EMRServerlessClientTypes.MaximumAllowedResources?
    let tags: [Swift.String:Swift.String]?
    let autoStartConfiguration: EMRServerlessClientTypes.AutoStartConfig?
    let autoStopConfiguration: EMRServerlessClientTypes.AutoStopConfig?
    let networkConfiguration: EMRServerlessClientTypes.NetworkConfiguration?
    let architecture: EMRServerlessClientTypes.Architecture?
    let imageConfiguration: EMRServerlessClientTypes.ImageConfigurationInput?
    let workerTypeSpecifications: [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecificationInput]?
    let runtimeConfiguration: [EMRServerlessClientTypes.Configuration]?
    let monitoringConfiguration: EMRServerlessClientTypes.MonitoringConfiguration?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case autoStartConfiguration
        case autoStopConfiguration
        case clientToken
        case imageConfiguration
        case initialCapacity
        case maximumCapacity
        case monitoringConfiguration
        case name
        case networkConfiguration
        case releaseLabel
        case runtimeConfiguration
        case tags
        case type
        case workerTypeSpecifications
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let initialCapacityContainer = try containerValues.decodeIfPresent([Swift.String: EMRServerlessClientTypes.InitialCapacityConfig?].self, forKey: .initialCapacity)
        var initialCapacityDecoded0: [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]? = nil
        if let initialCapacityContainer = initialCapacityContainer {
            initialCapacityDecoded0 = [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]()
            for (key0, initialcapacityconfig0) in initialCapacityContainer {
                if let initialcapacityconfig0 = initialcapacityconfig0 {
                    initialCapacityDecoded0?[key0] = initialcapacityconfig0
                }
            }
        }
        initialCapacity = initialCapacityDecoded0
        let maximumCapacityDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.MaximumAllowedResources.self, forKey: .maximumCapacity)
        maximumCapacity = maximumCapacityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let autoStartConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.AutoStartConfig.self, forKey: .autoStartConfiguration)
        autoStartConfiguration = autoStartConfigurationDecoded
        let autoStopConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.AutoStopConfig.self, forKey: .autoStopConfiguration)
        autoStopConfiguration = autoStopConfigurationDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let imageConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.ImageConfigurationInput.self, forKey: .imageConfiguration)
        imageConfiguration = imageConfigurationDecoded
        let workerTypeSpecificationsContainer = try containerValues.decodeIfPresent([Swift.String: EMRServerlessClientTypes.WorkerTypeSpecificationInput?].self, forKey: .workerTypeSpecifications)
        var workerTypeSpecificationsDecoded0: [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecificationInput]? = nil
        if let workerTypeSpecificationsContainer = workerTypeSpecificationsContainer {
            workerTypeSpecificationsDecoded0 = [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecificationInput]()
            for (key0, workertypespecificationinput0) in workerTypeSpecificationsContainer {
                if let workertypespecificationinput0 = workertypespecificationinput0 {
                    workerTypeSpecificationsDecoded0?[key0] = workertypespecificationinput0
                }
            }
        }
        workerTypeSpecifications = workerTypeSpecificationsDecoded0
        let runtimeConfigurationContainer = try containerValues.decodeIfPresent([EMRServerlessClientTypes.Configuration?].self, forKey: .runtimeConfiguration)
        var runtimeConfigurationDecoded0:[EMRServerlessClientTypes.Configuration]? = nil
        if let runtimeConfigurationContainer = runtimeConfigurationContainer {
            runtimeConfigurationDecoded0 = [EMRServerlessClientTypes.Configuration]()
            for structure0 in runtimeConfigurationContainer {
                if let structure0 = structure0 {
                    runtimeConfigurationDecoded0?.append(structure0)
                }
            }
        }
        runtimeConfiguration = runtimeConfigurationDecoded0
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.MonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
    }
}

extension CreateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.name = output.name
        } else {
            self.applicationId = nil
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateApplicationOutput: Swift.Equatable {
    /// The output contains the application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The output contains the ARN of the application.
    /// This member is required.
    public var arn: Swift.String?
    /// The output contains the name of the application.
    public var name: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.name = name
    }
}

struct CreateApplicationOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
}

extension CreateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The ID of the application that will be deleted.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
}

extension DeleteApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct GetApplicationInput: Swift.Equatable {
    /// The ID of the application that will be described.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct GetApplicationOutput: Swift.Equatable {
    /// The output displays information about the specified application.
    /// This member is required.
    public var application: EMRServerlessClientTypes.Application?

    public init(
        application: EMRServerlessClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

struct GetApplicationOutputBody: Swift.Equatable {
    let application: EMRServerlessClientTypes.Application?
}

extension GetApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
    }
}

enum GetApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDashboardForJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let jobRunId = jobRunId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/jobruns/\(jobRunId.urlPercentEncoding())/dashboard"
    }
}

public struct GetDashboardForJobRunInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the job run.
    /// This member is required.
    public var jobRunId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        jobRunId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.jobRunId = jobRunId
    }
}

struct GetDashboardForJobRunInputBody: Swift.Equatable {
}

extension GetDashboardForJobRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDashboardForJobRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDashboardForJobRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.url = output.url
        } else {
            self.url = nil
        }
    }
}

public struct GetDashboardForJobRunOutput: Swift.Equatable {
    /// The URL to view job run's dashboard.
    public var url: Swift.String?

    public init(
        url: Swift.String? = nil
    )
    {
        self.url = url
    }
}

struct GetDashboardForJobRunOutputBody: Swift.Equatable {
    let url: Swift.String?
}

extension GetDashboardForJobRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case url
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

enum GetDashboardForJobRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let jobRunId = jobRunId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/jobruns/\(jobRunId.urlPercentEncoding())"
    }
}

public struct GetJobRunInput: Swift.Equatable {
    /// The ID of the application on which the job run is submitted.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the job run.
    /// This member is required.
    public var jobRunId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        jobRunId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.jobRunId = jobRunId
    }
}

struct GetJobRunInputBody: Swift.Equatable {
}

extension GetJobRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetJobRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetJobRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobRun = output.jobRun
        } else {
            self.jobRun = nil
        }
    }
}

public struct GetJobRunOutput: Swift.Equatable {
    /// The output displays information about the job run.
    /// This member is required.
    public var jobRun: EMRServerlessClientTypes.JobRun?

    public init(
        jobRun: EMRServerlessClientTypes.JobRun? = nil
    )
    {
        self.jobRun = jobRun
    }
}

struct GetJobRunOutputBody: Swift.Equatable {
    let jobRun: EMRServerlessClientTypes.JobRun?
}

extension GetJobRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobRun
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.JobRun.self, forKey: .jobRun)
        jobRun = jobRunDecoded
    }
}

enum GetJobRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EMRServerlessClientTypes.Hive: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initQueryFile
        case parameters
        case query
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initQueryFile = self.initQueryFile {
            try encodeContainer.encode(initQueryFile, forKey: .initQueryFile)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let query = self.query {
            try encodeContainer.encode(query, forKey: .query)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .query)
        query = queryDecoded
        let initQueryFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initQueryFile)
        initQueryFile = initQueryFileDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension EMRServerlessClientTypes.Hive: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Hive(initQueryFile: \"CONTENT_REDACTED\", parameters: \"CONTENT_REDACTED\", query: \"CONTENT_REDACTED\")"}
}

extension EMRServerlessClientTypes {
    /// The configurations for the Hive job driver.
    public struct Hive: Swift.Equatable {
        /// The query file for the Hive job run.
        public var initQueryFile: Swift.String?
        /// The parameters for the Hive job run.
        public var parameters: Swift.String?
        /// The query for the Hive job run.
        /// This member is required.
        public var query: Swift.String?

        public init(
            initQueryFile: Swift.String? = nil,
            parameters: Swift.String? = nil,
            query: Swift.String? = nil
        )
        {
            self.initQueryFile = initQueryFile
            self.parameters = parameters
            self.query = query
        }
    }

}

extension EMRServerlessClientTypes.ImageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageUri
        case resolvedImageDigest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUri = self.imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
        if let resolvedImageDigest = self.resolvedImageDigest {
            try encodeContainer.encode(resolvedImageDigest, forKey: .resolvedImageDigest)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
        let resolvedImageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolvedImageDigest)
        resolvedImageDigest = resolvedImageDigestDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The applied image configuration.
    public struct ImageConfiguration: Swift.Equatable {
        /// The image URI.
        /// This member is required.
        public var imageUri: Swift.String?
        /// The SHA256 digest of the image URI. This indicates which specific image the application is configured for. The image digest doesn't exist until an application has started.
        public var resolvedImageDigest: Swift.String?

        public init(
            imageUri: Swift.String? = nil,
            resolvedImageDigest: Swift.String? = nil
        )
        {
            self.imageUri = imageUri
            self.resolvedImageDigest = resolvedImageDigest
        }
    }

}

extension EMRServerlessClientTypes.ImageConfigurationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUri = self.imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The image configuration.
    public struct ImageConfigurationInput: Swift.Equatable {
        /// The URI of an image in the Amazon ECR registry. This field is required when you create a new application. If you leave this field blank in an update, Amazon EMR will remove the image configuration.
        public var imageUri: Swift.String?

        public init(
            imageUri: Swift.String? = nil
        )
        {
            self.imageUri = imageUri
        }
    }

}

extension EMRServerlessClientTypes.InitialCapacityConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workerConfiguration
        case workerCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workerConfiguration = self.workerConfiguration {
            try encodeContainer.encode(workerConfiguration, forKey: .workerConfiguration)
        }
        if workerCount != 0 {
            try encodeContainer.encode(workerCount, forKey: .workerCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workerCount) ?? 0
        workerCount = workerCountDecoded
        let workerConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.WorkerResourceConfig.self, forKey: .workerConfiguration)
        workerConfiguration = workerConfigurationDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The initial capacity configuration per worker.
    public struct InitialCapacityConfig: Swift.Equatable {
        /// The resource configuration of the initial capacity configuration.
        public var workerConfiguration: EMRServerlessClientTypes.WorkerResourceConfig?
        /// The number of workers in the initial capacity configuration.
        /// This member is required.
        public var workerCount: Swift.Int

        public init(
            workerConfiguration: EMRServerlessClientTypes.WorkerResourceConfig? = nil,
            workerCount: Swift.Int = 0
        )
        {
            self.workerConfiguration = workerConfiguration
            self.workerCount = workerCount
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request processing failed because of an error or failure with the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EMRServerlessClientTypes.JobDriver: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hive
        case sdkUnknown
        case sparksubmit = "sparkSubmit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .hive(hive):
                try container.encode(hive, forKey: .hive)
            case let .sparksubmit(sparksubmit):
                try container.encode(sparksubmit, forKey: .sparksubmit)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let sparksubmitDecoded = try values.decodeIfPresent(EMRServerlessClientTypes.SparkSubmit.self, forKey: .sparksubmit)
        if let sparksubmit = sparksubmitDecoded {
            self = .sparksubmit(sparksubmit)
            return
        }
        let hiveDecoded = try values.decodeIfPresent(EMRServerlessClientTypes.Hive.self, forKey: .hive)
        if let hive = hiveDecoded {
            self = .hive(hive)
            return
        }
        self = .sdkUnknown("")
    }
}

extension EMRServerlessClientTypes {
    /// The driver that the job runs on.
    public enum JobDriver: Swift.Equatable {
        /// The job driver parameters specified for Spark.
        case sparksubmit(EMRServerlessClientTypes.SparkSubmit)
        /// The job driver parameters specified for Hive.
        case hive(EMRServerlessClientTypes.Hive)
        case sdkUnknown(Swift.String)
    }

}

extension EMRServerlessClientTypes.JobRun: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case arn
        case billedResourceUtilization
        case configurationOverrides
        case createdAt
        case createdBy
        case executionRole
        case executionTimeoutMinutes
        case jobDriver
        case jobRunId
        case name
        case networkConfiguration
        case releaseLabel
        case state
        case stateDetails
        case tags
        case totalExecutionDurationSeconds
        case totalResourceUtilization
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billedResourceUtilization = self.billedResourceUtilization {
            try encodeContainer.encode(billedResourceUtilization, forKey: .billedResourceUtilization)
        }
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let executionTimeoutMinutes = self.executionTimeoutMinutes {
            try encodeContainer.encode(executionTimeoutMinutes, forKey: .executionTimeoutMinutes)
        }
        if let jobDriver = self.jobDriver {
            try encodeContainer.encode(jobDriver, forKey: .jobDriver)
        }
        if let jobRunId = self.jobRunId {
            try encodeContainer.encode(jobRunId, forKey: .jobRunId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = self.stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let totalExecutionDurationSeconds = self.totalExecutionDurationSeconds {
            try encodeContainer.encode(totalExecutionDurationSeconds, forKey: .totalExecutionDurationSeconds)
        }
        if let totalResourceUtilization = self.totalResourceUtilization {
            try encodeContainer.encode(totalResourceUtilization, forKey: .totalResourceUtilization)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let jobRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobRunId)
        jobRunId = jobRunIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.JobRunState.self, forKey: .state)
        state = stateDecoded
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let jobDriverDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.JobDriver.self, forKey: .jobDriver)
        jobDriver = jobDriverDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let totalResourceUtilizationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.TotalResourceUtilization.self, forKey: .totalResourceUtilization)
        totalResourceUtilization = totalResourceUtilizationDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let totalExecutionDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalExecutionDurationSeconds)
        totalExecutionDurationSeconds = totalExecutionDurationSecondsDecoded
        let executionTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionTimeoutMinutes)
        executionTimeoutMinutes = executionTimeoutMinutesDecoded
        let billedResourceUtilizationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.ResourceUtilization.self, forKey: .billedResourceUtilization)
        billedResourceUtilization = billedResourceUtilizationDecoded
    }
}

extension EMRServerlessClientTypes {
    /// Information about a job run. A job run is a unit of work, such as a Spark JAR, Hive query, or SparkSQL query, that you submit to an Amazon EMR Serverless application.
    public struct JobRun: Swift.Equatable {
        /// The ID of the application the job is running on.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The execution role ARN of the job run.
        /// This member is required.
        public var arn: Swift.String?
        /// The aggregate vCPU, memory, and storage that Amazon Web Services has billed for the job run. The billed resources include a 1-minute minimum usage for workers, plus additional storage over 20 GB per worker. Note that billed resources do not include usage for idle pre-initialized workers.
        public var billedResourceUtilization: EMRServerlessClientTypes.ResourceUtilization?
        /// The configuration settings that are used to override default configuration.
        public var configurationOverrides: EMRServerlessClientTypes.ConfigurationOverrides?
        /// The date and time when the job run was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user who created the job run.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The execution role ARN of the job run.
        /// This member is required.
        public var executionRole: Swift.String?
        /// Returns the job run timeout value from the StartJobRun call. If no timeout was specified, then it returns the default timeout of 720 minutes.
        public var executionTimeoutMinutes: Swift.Int?
        /// The job driver for the job run.
        /// This member is required.
        public var jobDriver: EMRServerlessClientTypes.JobDriver?
        /// The ID of the job run.
        /// This member is required.
        public var jobRunId: Swift.String?
        /// The optional job run name. This doesn't have to be unique.
        public var name: Swift.String?
        /// The network configuration for customer VPC connectivity.
        public var networkConfiguration: EMRServerlessClientTypes.NetworkConfiguration?
        /// The Amazon EMR release associated with the application your job is running on.
        /// This member is required.
        public var releaseLabel: Swift.String?
        /// The state of the job run.
        /// This member is required.
        public var state: EMRServerlessClientTypes.JobRunState?
        /// The state details of the job run.
        /// This member is required.
        public var stateDetails: Swift.String?
        /// The tags assigned to the job run.
        public var tags: [Swift.String:Swift.String]?
        /// The job run total execution duration in seconds. This field is only available for job runs in a COMPLETED, FAILED, or CANCELLED state.
        public var totalExecutionDurationSeconds: Swift.Int?
        /// The aggregate vCPU, memory, and storage resources used from the time the job starts to execute, until the time the job terminates, rounded up to the nearest second.
        public var totalResourceUtilization: EMRServerlessClientTypes.TotalResourceUtilization?
        /// The date and time when the job run was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            billedResourceUtilization: EMRServerlessClientTypes.ResourceUtilization? = nil,
            configurationOverrides: EMRServerlessClientTypes.ConfigurationOverrides? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            executionTimeoutMinutes: Swift.Int? = nil,
            jobDriver: EMRServerlessClientTypes.JobDriver? = nil,
            jobRunId: Swift.String? = nil,
            name: Swift.String? = nil,
            networkConfiguration: EMRServerlessClientTypes.NetworkConfiguration? = nil,
            releaseLabel: Swift.String? = nil,
            state: EMRServerlessClientTypes.JobRunState? = nil,
            stateDetails: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            totalExecutionDurationSeconds: Swift.Int? = nil,
            totalResourceUtilization: EMRServerlessClientTypes.TotalResourceUtilization? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.billedResourceUtilization = billedResourceUtilization
            self.configurationOverrides = configurationOverrides
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.executionRole = executionRole
            self.executionTimeoutMinutes = executionTimeoutMinutes
            self.jobDriver = jobDriver
            self.jobRunId = jobRunId
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.releaseLabel = releaseLabel
            self.state = state
            self.stateDetails = stateDetails
            self.tags = tags
            self.totalExecutionDurationSeconds = totalExecutionDurationSeconds
            self.totalResourceUtilization = totalResourceUtilization
            self.updatedAt = updatedAt
        }
    }

}

extension EMRServerlessClientTypes {
    public enum JobRunState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case pending
        case running
        case scheduled
        case submitted
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [JobRunState] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .pending,
                .running,
                .scheduled,
                .submitted,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .scheduled: return "SCHEDULED"
            case .submitted: return "SUBMITTED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobRunState(rawValue: rawValue) ?? JobRunState.sdkUnknown(rawValue)
        }
    }
}

extension EMRServerlessClientTypes.JobRunSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case arn
        case createdAt
        case createdBy
        case executionRole
        case id
        case name
        case releaseLabel
        case state
        case stateDetails
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = self.stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.JobRunState.self, forKey: .state)
        state = stateDecoded
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The summary of attributes associated with a job run.
    public struct JobRunSummary: Swift.Equatable {
        /// The ID of the application the job is running on.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The ARN of the job run.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the job run was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user who created the job run.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The execution role ARN of the job run.
        /// This member is required.
        public var executionRole: Swift.String?
        /// The ID of the job run.
        /// This member is required.
        public var id: Swift.String?
        /// The optional job run name. This doesn't have to be unique.
        public var name: Swift.String?
        /// The Amazon EMR release associated with the application your job is running on.
        /// This member is required.
        public var releaseLabel: Swift.String?
        /// The state of the job run.
        /// This member is required.
        public var state: EMRServerlessClientTypes.JobRunState?
        /// The state details of the job run.
        /// This member is required.
        public var stateDetails: Swift.String?
        /// The type of job run, such as Spark or Hive.
        public var type: Swift.String?
        /// The date and time when the job run was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            releaseLabel: Swift.String? = nil,
            state: EMRServerlessClientTypes.JobRunState? = nil,
            stateDetails: Swift.String? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.executionRole = executionRole
            self.id = id
            self.name = name
            self.releaseLabel = releaseLabel
            self.state = state
            self.stateDetails = stateDetails
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension ListApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let states = states {
                states.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The maximum number of applications that can be listed.
    public var maxResults: Swift.Int?
    /// The token for the next set of application results.
    public var nextToken: Swift.String?
    /// An optional filter for application states. Note that if this filter contains multiple states, the resulting list will be grouped by the state.
    public var states: [EMRServerlessClientTypes.ApplicationState]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        states: [EMRServerlessClientTypes.ApplicationState]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutput: Swift.Equatable {
    /// The output lists the specified applications.
    /// This member is required.
    public var applications: [EMRServerlessClientTypes.ApplicationSummary]?
    /// The output displays the token for the next set of application results. This is required for pagination and is available as a response of the previous request.
    public var nextToken: Swift.String?

    public init(
        applications: [EMRServerlessClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputBody: Swift.Equatable {
    let applications: [EMRServerlessClientTypes.ApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([EMRServerlessClientTypes.ApplicationSummary?].self, forKey: .applications)
        var applicationsDecoded0:[EMRServerlessClientTypes.ApplicationSummary]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [EMRServerlessClientTypes.ApplicationSummary]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJobRunsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let createdAtAfter = createdAtAfter {
                let createdAtAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAtAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdAtAfter)).urlPercentEncoding())
                items.append(createdAtAfterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let createdAtBefore = createdAtBefore {
                let createdAtBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdAtBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdAtBefore)).urlPercentEncoding())
                items.append(createdAtBeforeQueryItem)
            }
            if let states = states {
                states.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListJobRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/jobruns"
    }
}

public struct ListJobRunsInput: Swift.Equatable {
    /// The ID of the application for which to list the job run.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The lower bound of the option to filter by creation date and time.
    public var createdAtAfter: ClientRuntime.Date?
    /// The upper bound of the option to filter by creation date and time.
    public var createdAtBefore: ClientRuntime.Date?
    /// The maximum number of job runs that can be listed.
    public var maxResults: Swift.Int?
    /// The token for the next set of job run results.
    public var nextToken: Swift.String?
    /// An optional filter for job run states. Note that if this filter contains multiple states, the resulting list will be grouped by the state.
    public var states: [EMRServerlessClientTypes.JobRunState]?

    public init(
        applicationId: Swift.String? = nil,
        createdAtAfter: ClientRuntime.Date? = nil,
        createdAtBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        states: [EMRServerlessClientTypes.JobRunState]? = nil
    )
    {
        self.applicationId = applicationId
        self.createdAtAfter = createdAtAfter
        self.createdAtBefore = createdAtBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
    }
}

struct ListJobRunsInputBody: Swift.Equatable {
}

extension ListJobRunsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobRunsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobRunsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobRuns = output.jobRuns
            self.nextToken = output.nextToken
        } else {
            self.jobRuns = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobRunsOutput: Swift.Equatable {
    /// The output lists information about the specified job runs.
    /// This member is required.
    public var jobRuns: [EMRServerlessClientTypes.JobRunSummary]?
    /// The output displays the token for the next set of job run results. This is required for pagination and is available as a response of the previous request.
    public var nextToken: Swift.String?

    public init(
        jobRuns: [EMRServerlessClientTypes.JobRunSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobRuns = jobRuns
        self.nextToken = nextToken
    }
}

struct ListJobRunsOutputBody: Swift.Equatable {
    let jobRuns: [EMRServerlessClientTypes.JobRunSummary]?
    let nextToken: Swift.String?
}

extension ListJobRunsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobRuns
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunsContainer = try containerValues.decodeIfPresent([EMRServerlessClientTypes.JobRunSummary?].self, forKey: .jobRuns)
        var jobRunsDecoded0:[EMRServerlessClientTypes.JobRunSummary]? = nil
        if let jobRunsContainer = jobRunsContainer {
            jobRunsDecoded0 = [EMRServerlessClientTypes.JobRunSummary]()
            for structure0 in jobRunsContainer {
                if let structure0 = structure0 {
                    jobRunsDecoded0?.append(structure0)
                }
            }
        }
        jobRuns = jobRunsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobRunsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for. Currently, the supported resources are Amazon EMR Serverless applications and job runs.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EMRServerlessClientTypes.ManagedPersistenceMonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case encryptionKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The managed log persistence configuration for a job run.
    public struct ManagedPersistenceMonitoringConfiguration: Swift.Equatable {
        /// Enables managed logging and defaults to true. If set to false, managed logging will be turned off.
        public var enabled: Swift.Bool?
        /// The KMS key ARN to encrypt the logs stored in managed log persistence.
        public var encryptionKeyArn: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            encryptionKeyArn: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.encryptionKeyArn = encryptionKeyArn
        }
    }

}

extension EMRServerlessClientTypes.MaximumAllowedResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpu
        case disk
        case memory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpu = self.cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let disk = self.disk {
            try encodeContainer.encode(disk, forKey: .disk)
        }
        if let memory = self.memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpu)
        cpu = cpuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memory)
        memory = memoryDecoded
        let diskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disk)
        disk = diskDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The maximum allowed cumulative resources for an application. No new resources will be created once the limit is hit.
    public struct MaximumAllowedResources: Swift.Equatable {
        /// The maximum allowed CPU for an application.
        /// This member is required.
        public var cpu: Swift.String?
        /// The maximum allowed disk for an application.
        public var disk: Swift.String?
        /// The maximum allowed resources for an application.
        /// This member is required.
        public var memory: Swift.String?

        public init(
            cpu: Swift.String? = nil,
            disk: Swift.String? = nil,
            memory: Swift.String? = nil
        )
        {
            self.cpu = cpu
            self.disk = disk
            self.memory = memory
        }
    }

}

extension EMRServerlessClientTypes.MonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLoggingConfiguration
        case managedPersistenceMonitoringConfiguration
        case s3MonitoringConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLoggingConfiguration = self.cloudWatchLoggingConfiguration {
            try encodeContainer.encode(cloudWatchLoggingConfiguration, forKey: .cloudWatchLoggingConfiguration)
        }
        if let managedPersistenceMonitoringConfiguration = self.managedPersistenceMonitoringConfiguration {
            try encodeContainer.encode(managedPersistenceMonitoringConfiguration, forKey: .managedPersistenceMonitoringConfiguration)
        }
        if let s3MonitoringConfiguration = self.s3MonitoringConfiguration {
            try encodeContainer.encode(s3MonitoringConfiguration, forKey: .s3MonitoringConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3MonitoringConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.S3MonitoringConfiguration.self, forKey: .s3MonitoringConfiguration)
        s3MonitoringConfiguration = s3MonitoringConfigurationDecoded
        let managedPersistenceMonitoringConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.ManagedPersistenceMonitoringConfiguration.self, forKey: .managedPersistenceMonitoringConfiguration)
        managedPersistenceMonitoringConfiguration = managedPersistenceMonitoringConfigurationDecoded
        let cloudWatchLoggingConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.CloudWatchLoggingConfiguration.self, forKey: .cloudWatchLoggingConfiguration)
        cloudWatchLoggingConfiguration = cloudWatchLoggingConfigurationDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The configuration setting for monitoring.
    public struct MonitoringConfiguration: Swift.Equatable {
        /// The Amazon CloudWatch configuration for monitoring logs. You can configure your jobs to send log information to CloudWatch.
        public var cloudWatchLoggingConfiguration: EMRServerlessClientTypes.CloudWatchLoggingConfiguration?
        /// The managed log persistence configuration for a job run.
        public var managedPersistenceMonitoringConfiguration: EMRServerlessClientTypes.ManagedPersistenceMonitoringConfiguration?
        /// The Amazon S3 configuration for monitoring log publishing.
        public var s3MonitoringConfiguration: EMRServerlessClientTypes.S3MonitoringConfiguration?

        public init(
            cloudWatchLoggingConfiguration: EMRServerlessClientTypes.CloudWatchLoggingConfiguration? = nil,
            managedPersistenceMonitoringConfiguration: EMRServerlessClientTypes.ManagedPersistenceMonitoringConfiguration? = nil,
            s3MonitoringConfiguration: EMRServerlessClientTypes.S3MonitoringConfiguration? = nil
        )
        {
            self.cloudWatchLoggingConfiguration = cloudWatchLoggingConfiguration
            self.managedPersistenceMonitoringConfiguration = managedPersistenceMonitoringConfiguration
            self.s3MonitoringConfiguration = s3MonitoringConfiguration
        }
    }

}

extension EMRServerlessClientTypes.NetworkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
        case subnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupstring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupstring0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetstring0 in subnetIds {
                try subnetIdsContainer.encode(subnetstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension EMRServerlessClientTypes {
    /// The network configuration for customer VPC connectivity.
    public struct NetworkConfiguration: Swift.Equatable {
        /// The array of security group Ids for customer VPC connectivity.
        public var securityGroupIds: [Swift.String]?
        /// The array of subnet Ids for customer VPC connectivity.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EMRServerlessClientTypes.ResourceUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memoryGBHour
        case storageGBHour
        case vCPUHour
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memoryGBHour = self.memoryGBHour {
            try encodeContainer.encode(memoryGBHour, forKey: .memoryGBHour)
        }
        if let storageGBHour = self.storageGBHour {
            try encodeContainer.encode(storageGBHour, forKey: .storageGBHour)
        }
        if let vCPUHour = self.vCPUHour {
            try encodeContainer.encode(vCPUHour, forKey: .vCPUHour)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vCPUHourDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .vCPUHour)
        vCPUHour = vCPUHourDecoded
        let memoryGBHourDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .memoryGBHour)
        memoryGBHour = memoryGBHourDecoded
        let storageGBHourDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .storageGBHour)
        storageGBHour = storageGBHourDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The resource utilization for memory, storage, and vCPU for jobs.
    public struct ResourceUtilization: Swift.Equatable {
        /// The aggregated memory used per hour from the time the job starts executing until the job is terminated.
        public var memoryGBHour: Swift.Double?
        /// The aggregated storage used per hour from the time the job starts executing until the job is terminated.
        public var storageGBHour: Swift.Double?
        /// The aggregated vCPU used per hour from the time the job starts executing until the job is terminated.
        public var vCPUHour: Swift.Double?

        public init(
            memoryGBHour: Swift.Double? = nil,
            storageGBHour: Swift.Double? = nil,
            vCPUHour: Swift.Double? = nil
        )
        {
            self.memoryGBHour = memoryGBHour
            self.storageGBHour = storageGBHour
            self.vCPUHour = vCPUHour
        }
    }

}

extension EMRServerlessClientTypes.S3MonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKeyArn
        case logUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let logUri = self.logUri {
            try encodeContainer.encode(logUri, forKey: .logUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUri)
        logUri = logUriDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The Amazon S3 configuration for monitoring log publishing. You can configure your jobs to send log information to Amazon S3.
    public struct S3MonitoringConfiguration: Swift.Equatable {
        /// The KMS key ARN to encrypt the logs published to the given Amazon S3 destination.
        public var encryptionKeyArn: Swift.String?
        /// The Amazon S3 destination URI for log publishing.
        public var logUri: Swift.String?

        public init(
            encryptionKeyArn: Swift.String? = nil,
            logUri: Swift.String? = nil
        )
        {
            self.encryptionKeyArn = encryptionKeyArn
            self.logUri = logUri
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of resources per account has been reached.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EMRServerlessClientTypes.SparkSubmit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryPoint
        case entryPointArguments
        case sparkSubmitParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryPoint = self.entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let entryPointArguments = entryPointArguments {
            var entryPointArgumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entryPointArguments)
            for entrypointargument0 in entryPointArguments {
                try entryPointArgumentsContainer.encode(entrypointargument0)
            }
        }
        if let sparkSubmitParameters = self.sparkSubmitParameters {
            try encodeContainer.encode(sparkSubmitParameters, forKey: .sparkSubmitParameters)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let entryPointArgumentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entryPointArguments)
        var entryPointArgumentsDecoded0:[Swift.String]? = nil
        if let entryPointArgumentsContainer = entryPointArgumentsContainer {
            entryPointArgumentsDecoded0 = [Swift.String]()
            for string0 in entryPointArgumentsContainer {
                if let string0 = string0 {
                    entryPointArgumentsDecoded0?.append(string0)
                }
            }
        }
        entryPointArguments = entryPointArgumentsDecoded0
        let sparkSubmitParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sparkSubmitParameters)
        sparkSubmitParameters = sparkSubmitParametersDecoded
    }
}

extension EMRServerlessClientTypes.SparkSubmit: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SparkSubmit(entryPointArguments: \(Swift.String(describing: entryPointArguments)), entryPoint: \"CONTENT_REDACTED\", sparkSubmitParameters: \"CONTENT_REDACTED\")"}
}

extension EMRServerlessClientTypes {
    /// The configurations for the Spark submit job driver.
    public struct SparkSubmit: Swift.Equatable {
        /// The entry point for the Spark submit job run.
        /// This member is required.
        public var entryPoint: Swift.String?
        /// The arguments for the Spark submit job run.
        public var entryPointArguments: [Swift.String]?
        /// The parameters for the Spark submit job run.
        public var sparkSubmitParameters: Swift.String?

        public init(
            entryPoint: Swift.String? = nil,
            entryPointArguments: [Swift.String]? = nil,
            sparkSubmitParameters: Swift.String? = nil
        )
        {
            self.entryPoint = entryPoint
            self.entryPointArguments = entryPointArguments
            self.sparkSubmitParameters = sparkSubmitParameters
        }
    }

}

extension StartApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/start"
    }
}

public struct StartApplicationInput: Swift.Equatable {
    /// The ID of the application to start.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct StartApplicationInputBody: Swift.Equatable {
}

extension StartApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartApplicationOutput: Swift.Equatable {

    public init() { }
}

enum StartApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartJobRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case executionTimeoutMinutes
        case jobDriver
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let executionTimeoutMinutes = self.executionTimeoutMinutes {
            try encodeContainer.encode(executionTimeoutMinutes, forKey: .executionTimeoutMinutes)
        }
        if let jobDriver = self.jobDriver {
            try encodeContainer.encode(jobDriver, forKey: .jobDriver)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/jobruns"
    }
}

public struct StartJobRunInput: Swift.Equatable {
    /// The ID of the application on which to run the job.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The client idempotency token of the job run to start. Its value must be unique for each request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The configuration overrides for the job run.
    public var configurationOverrides: EMRServerlessClientTypes.ConfigurationOverrides?
    /// The execution role ARN for the job run.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The maximum duration for the job run to run. If the job run runs beyond this duration, it will be automatically cancelled.
    public var executionTimeoutMinutes: Swift.Int?
    /// The job driver for the job run.
    public var jobDriver: EMRServerlessClientTypes.JobDriver?
    /// The optional job run name. This doesn't have to be unique.
    public var name: Swift.String?
    /// The tags assigned to the job run.
    public var tags: [Swift.String:Swift.String]?

    public init(
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configurationOverrides: EMRServerlessClientTypes.ConfigurationOverrides? = nil,
        executionRoleArn: Swift.String? = nil,
        executionTimeoutMinutes: Swift.Int? = nil,
        jobDriver: EMRServerlessClientTypes.JobDriver? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
        self.configurationOverrides = configurationOverrides
        self.executionRoleArn = executionRoleArn
        self.executionTimeoutMinutes = executionTimeoutMinutes
        self.jobDriver = jobDriver
        self.name = name
        self.tags = tags
    }
}

struct StartJobRunInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let executionRoleArn: Swift.String?
    let jobDriver: EMRServerlessClientTypes.JobDriver?
    let configurationOverrides: EMRServerlessClientTypes.ConfigurationOverrides?
    let tags: [Swift.String:Swift.String]?
    let executionTimeoutMinutes: Swift.Int?
    let name: Swift.String?
}

extension StartJobRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case executionTimeoutMinutes
        case jobDriver
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let jobDriverDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.JobDriver.self, forKey: .jobDriver)
        jobDriver = jobDriverDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let executionTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionTimeoutMinutes)
        executionTimeoutMinutes = executionTimeoutMinutesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartJobRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartJobRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.jobRunId = output.jobRunId
        } else {
            self.applicationId = nil
            self.arn = nil
            self.jobRunId = nil
        }
    }
}

public struct StartJobRunOutput: Swift.Equatable {
    /// This output displays the application ID on which the job run was submitted.
    /// This member is required.
    public var applicationId: Swift.String?
    /// This output displays the ARN of the job run..
    /// This member is required.
    public var arn: Swift.String?
    /// The output contains the ID of the started job run.
    /// This member is required.
    public var jobRunId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        jobRunId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.jobRunId = jobRunId
    }
}

struct StartJobRunOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let jobRunId: Swift.String?
    let arn: Swift.String?
}

extension StartJobRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case arn
        case jobRunId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let jobRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobRunId)
        jobRunId = jobRunIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum StartJobRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/stop"
    }
}

public struct StopApplicationInput: Swift.Equatable {
    /// The ID of the application to stop.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct StopApplicationInputBody: Swift.Equatable {
}

extension StopApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopApplicationOutput: Swift.Equatable {

    public init() { }
}

enum StopApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for. Currently, the supported resources are Amazon EMR Serverless applications and job runs.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EMRServerlessClientTypes.TotalResourceUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memoryGBHour
        case storageGBHour
        case vCPUHour
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memoryGBHour = self.memoryGBHour {
            try encodeContainer.encode(memoryGBHour, forKey: .memoryGBHour)
        }
        if let storageGBHour = self.storageGBHour {
            try encodeContainer.encode(storageGBHour, forKey: .storageGBHour)
        }
        if let vCPUHour = self.vCPUHour {
            try encodeContainer.encode(vCPUHour, forKey: .vCPUHour)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vCPUHourDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .vCPUHour)
        vCPUHour = vCPUHourDecoded
        let memoryGBHourDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .memoryGBHour)
        memoryGBHour = memoryGBHourDecoded
        let storageGBHourDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .storageGBHour)
        storageGBHour = storageGBHourDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The aggregate vCPU, memory, and storage resources used from the time job start executing till the time job is terminated, rounded up to the nearest second.
    public struct TotalResourceUtilization: Swift.Equatable {
        /// The aggregated memory used per hour from the time job start executing till the time job is terminated.
        public var memoryGBHour: Swift.Double?
        /// The aggregated storage used per hour from the time job start executing till the time job is terminated.
        public var storageGBHour: Swift.Double?
        /// The aggregated vCPU used per hour from the time job start executing till the time job is terminated.
        public var vCPUHour: Swift.Double?

        public init(
            memoryGBHour: Swift.Double? = nil,
            storageGBHour: Swift.Double? = nil,
            vCPUHour: Swift.Double? = nil
        )
        {
            self.memoryGBHour = memoryGBHour
            self.storageGBHour = storageGBHour
            self.vCPUHour = vCPUHour
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for. Currently, the supported resources are Amazon EMR Serverless applications and job runs.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case autoStartConfiguration
        case autoStopConfiguration
        case clientToken
        case imageConfiguration
        case initialCapacity
        case maximumCapacity
        case monitoringConfiguration
        case networkConfiguration
        case releaseLabel
        case runtimeConfiguration
        case workerTypeSpecifications
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let autoStartConfiguration = self.autoStartConfiguration {
            try encodeContainer.encode(autoStartConfiguration, forKey: .autoStartConfiguration)
        }
        if let autoStopConfiguration = self.autoStopConfiguration {
            try encodeContainer.encode(autoStopConfiguration, forKey: .autoStopConfiguration)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let imageConfiguration = self.imageConfiguration {
            try encodeContainer.encode(imageConfiguration, forKey: .imageConfiguration)
        }
        if let initialCapacity = initialCapacity {
            var initialCapacityContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .initialCapacity)
            for (dictKey0, initialCapacityConfigMap0) in initialCapacity {
                try initialCapacityContainer.encode(initialCapacityConfigMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let maximumCapacity = self.maximumCapacity {
            try encodeContainer.encode(maximumCapacity, forKey: .maximumCapacity)
        }
        if let monitoringConfiguration = self.monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let runtimeConfiguration = runtimeConfiguration {
            var runtimeConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runtimeConfiguration)
            for configuration0 in runtimeConfiguration {
                try runtimeConfigurationContainer.encode(configuration0)
            }
        }
        if let workerTypeSpecifications = workerTypeSpecifications {
            var workerTypeSpecificationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .workerTypeSpecifications)
            for (dictKey0, workerTypeSpecificationInputMap0) in workerTypeSpecifications {
                try workerTypeSpecificationsContainer.encode(workerTypeSpecificationInputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// The ID of the application to update.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The CPU architecture of an application.
    public var architecture: EMRServerlessClientTypes.Architecture?
    /// The configuration for an application to automatically start on job submission.
    public var autoStartConfiguration: EMRServerlessClientTypes.AutoStartConfig?
    /// The configuration for an application to automatically stop after a certain amount of time being idle.
    public var autoStopConfiguration: EMRServerlessClientTypes.AutoStopConfig?
    /// The client idempotency token of the application to update. Its value must be unique for each request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The image configuration to be used for all worker types. You can either set this parameter or imageConfiguration for each worker type in WorkerTypeSpecificationInput.
    public var imageConfiguration: EMRServerlessClientTypes.ImageConfigurationInput?
    /// The capacity to initialize when the application is updated.
    public var initialCapacity: [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]?
    /// The maximum capacity to allocate when the application is updated. This is cumulative across all workers at any given point in time during the lifespan of the application. No new resources will be created once any one of the defined limits is hit.
    public var maximumCapacity: EMRServerlessClientTypes.MaximumAllowedResources?
    /// The configuration setting for monitoring.
    public var monitoringConfiguration: EMRServerlessClientTypes.MonitoringConfiguration?
    /// The network configuration for customer VPC connectivity.
    public var networkConfiguration: EMRServerlessClientTypes.NetworkConfiguration?
    /// The Amazon EMR release label for the application. You can change the release label to use a different release of Amazon EMR.
    public var releaseLabel: Swift.String?
    /// The [Configuration](https://docs.aws.amazon.com/emr-serverless/latest/APIReference/API_Configuration.html) specifications to use when updating an application. Each configuration consists of a classification and properties. This configuration is applied across all the job runs submitted under the application.
    public var runtimeConfiguration: [EMRServerlessClientTypes.Configuration]?
    /// The key-value pairs that specify worker type to WorkerTypeSpecificationInput. This parameter must contain all valid worker types for a Spark or Hive application. Valid worker types include Driver and Executor for Spark applications and HiveDriver and TezTask for Hive applications. You can either set image details in this parameter for each worker type, or in imageConfiguration for all worker types.
    public var workerTypeSpecifications: [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecificationInput]?

    public init(
        applicationId: Swift.String? = nil,
        architecture: EMRServerlessClientTypes.Architecture? = nil,
        autoStartConfiguration: EMRServerlessClientTypes.AutoStartConfig? = nil,
        autoStopConfiguration: EMRServerlessClientTypes.AutoStopConfig? = nil,
        clientToken: Swift.String? = nil,
        imageConfiguration: EMRServerlessClientTypes.ImageConfigurationInput? = nil,
        initialCapacity: [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]? = nil,
        maximumCapacity: EMRServerlessClientTypes.MaximumAllowedResources? = nil,
        monitoringConfiguration: EMRServerlessClientTypes.MonitoringConfiguration? = nil,
        networkConfiguration: EMRServerlessClientTypes.NetworkConfiguration? = nil,
        releaseLabel: Swift.String? = nil,
        runtimeConfiguration: [EMRServerlessClientTypes.Configuration]? = nil,
        workerTypeSpecifications: [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecificationInput]? = nil
    )
    {
        self.applicationId = applicationId
        self.architecture = architecture
        self.autoStartConfiguration = autoStartConfiguration
        self.autoStopConfiguration = autoStopConfiguration
        self.clientToken = clientToken
        self.imageConfiguration = imageConfiguration
        self.initialCapacity = initialCapacity
        self.maximumCapacity = maximumCapacity
        self.monitoringConfiguration = monitoringConfiguration
        self.networkConfiguration = networkConfiguration
        self.releaseLabel = releaseLabel
        self.runtimeConfiguration = runtimeConfiguration
        self.workerTypeSpecifications = workerTypeSpecifications
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let initialCapacity: [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]?
    let maximumCapacity: EMRServerlessClientTypes.MaximumAllowedResources?
    let autoStartConfiguration: EMRServerlessClientTypes.AutoStartConfig?
    let autoStopConfiguration: EMRServerlessClientTypes.AutoStopConfig?
    let networkConfiguration: EMRServerlessClientTypes.NetworkConfiguration?
    let architecture: EMRServerlessClientTypes.Architecture?
    let imageConfiguration: EMRServerlessClientTypes.ImageConfigurationInput?
    let workerTypeSpecifications: [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecificationInput]?
    let releaseLabel: Swift.String?
    let runtimeConfiguration: [EMRServerlessClientTypes.Configuration]?
    let monitoringConfiguration: EMRServerlessClientTypes.MonitoringConfiguration?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case autoStartConfiguration
        case autoStopConfiguration
        case clientToken
        case imageConfiguration
        case initialCapacity
        case maximumCapacity
        case monitoringConfiguration
        case networkConfiguration
        case releaseLabel
        case runtimeConfiguration
        case workerTypeSpecifications
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let initialCapacityContainer = try containerValues.decodeIfPresent([Swift.String: EMRServerlessClientTypes.InitialCapacityConfig?].self, forKey: .initialCapacity)
        var initialCapacityDecoded0: [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]? = nil
        if let initialCapacityContainer = initialCapacityContainer {
            initialCapacityDecoded0 = [Swift.String:EMRServerlessClientTypes.InitialCapacityConfig]()
            for (key0, initialcapacityconfig0) in initialCapacityContainer {
                if let initialcapacityconfig0 = initialcapacityconfig0 {
                    initialCapacityDecoded0?[key0] = initialcapacityconfig0
                }
            }
        }
        initialCapacity = initialCapacityDecoded0
        let maximumCapacityDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.MaximumAllowedResources.self, forKey: .maximumCapacity)
        maximumCapacity = maximumCapacityDecoded
        let autoStartConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.AutoStartConfig.self, forKey: .autoStartConfiguration)
        autoStartConfiguration = autoStartConfigurationDecoded
        let autoStopConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.AutoStopConfig.self, forKey: .autoStopConfiguration)
        autoStopConfiguration = autoStopConfigurationDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let imageConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.ImageConfigurationInput.self, forKey: .imageConfiguration)
        imageConfiguration = imageConfigurationDecoded
        let workerTypeSpecificationsContainer = try containerValues.decodeIfPresent([Swift.String: EMRServerlessClientTypes.WorkerTypeSpecificationInput?].self, forKey: .workerTypeSpecifications)
        var workerTypeSpecificationsDecoded0: [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecificationInput]? = nil
        if let workerTypeSpecificationsContainer = workerTypeSpecificationsContainer {
            workerTypeSpecificationsDecoded0 = [Swift.String:EMRServerlessClientTypes.WorkerTypeSpecificationInput]()
            for (key0, workertypespecificationinput0) in workerTypeSpecificationsContainer {
                if let workertypespecificationinput0 = workertypespecificationinput0 {
                    workerTypeSpecificationsDecoded0?[key0] = workertypespecificationinput0
                }
            }
        }
        workerTypeSpecifications = workerTypeSpecificationsDecoded0
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let runtimeConfigurationContainer = try containerValues.decodeIfPresent([EMRServerlessClientTypes.Configuration?].self, forKey: .runtimeConfiguration)
        var runtimeConfigurationDecoded0:[EMRServerlessClientTypes.Configuration]? = nil
        if let runtimeConfigurationContainer = runtimeConfigurationContainer {
            runtimeConfigurationDecoded0 = [EMRServerlessClientTypes.Configuration]()
            for structure0 in runtimeConfigurationContainer {
                if let structure0 = structure0 {
                    runtimeConfigurationDecoded0?.append(structure0)
                }
            }
        }
        runtimeConfiguration = runtimeConfigurationDecoded0
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.MonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
    }
}

extension UpdateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct UpdateApplicationOutput: Swift.Equatable {
    /// Information about the updated application.
    /// This member is required.
    public var application: EMRServerlessClientTypes.Application?

    public init(
        application: EMRServerlessClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

struct UpdateApplicationOutputBody: Swift.Equatable {
    let application: EMRServerlessClientTypes.Application?
}

extension UpdateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
    }
}

enum UpdateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EMRServerlessClientTypes.WorkerResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpu
        case disk
        case memory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpu = self.cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let disk = self.disk {
            try encodeContainer.encode(disk, forKey: .disk)
        }
        if let memory = self.memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpu)
        cpu = cpuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memory)
        memory = memoryDecoded
        let diskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disk)
        disk = diskDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The cumulative configuration requirements for every worker instance of the worker type.
    public struct WorkerResourceConfig: Swift.Equatable {
        /// The CPU requirements for every worker instance of the worker type.
        /// This member is required.
        public var cpu: Swift.String?
        /// The disk requirements for every worker instance of the worker type.
        public var disk: Swift.String?
        /// The memory requirements for every worker instance of the worker type.
        /// This member is required.
        public var memory: Swift.String?

        public init(
            cpu: Swift.String? = nil,
            disk: Swift.String? = nil,
            memory: Swift.String? = nil
        )
        {
            self.cpu = cpu
            self.disk = disk
            self.memory = memory
        }
    }

}

extension EMRServerlessClientTypes.WorkerTypeSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageConfiguration = self.imageConfiguration {
            try encodeContainer.encode(imageConfiguration, forKey: .imageConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.ImageConfiguration.self, forKey: .imageConfiguration)
        imageConfiguration = imageConfigurationDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The specifications for a worker type.
    public struct WorkerTypeSpecification: Swift.Equatable {
        /// The image configuration for a worker type.
        public var imageConfiguration: EMRServerlessClientTypes.ImageConfiguration?

        public init(
            imageConfiguration: EMRServerlessClientTypes.ImageConfiguration? = nil
        )
        {
            self.imageConfiguration = imageConfiguration
        }
    }

}

extension EMRServerlessClientTypes.WorkerTypeSpecificationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageConfiguration = self.imageConfiguration {
            try encodeContainer.encode(imageConfiguration, forKey: .imageConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageConfigurationDecoded = try containerValues.decodeIfPresent(EMRServerlessClientTypes.ImageConfigurationInput.self, forKey: .imageConfiguration)
        imageConfiguration = imageConfigurationDecoded
    }
}

extension EMRServerlessClientTypes {
    /// The specifications for a worker type.
    public struct WorkerTypeSpecificationInput: Swift.Equatable {
        /// The image configuration for a worker type.
        public var imageConfiguration: EMRServerlessClientTypes.ImageConfigurationInput?

        public init(
            imageConfiguration: EMRServerlessClientTypes.ImageConfigurationInput? = nil
        )
        {
            self.imageConfiguration = imageConfiguration
        }
    }

}
