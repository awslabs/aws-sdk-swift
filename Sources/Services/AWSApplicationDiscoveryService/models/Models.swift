// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ApplicationDiscoveryClientTypes.AgentConfigurationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case description
        case operationSucceeded
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if operationSucceeded != false {
            try encodeContainer.encode(operationSucceeded, forKey: .operationSucceeded)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let operationSucceededDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .operationSucceeded) ?? false
        operationSucceeded = operationSucceededDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Information about agents that were instructed to start collecting data. Information includes the agent ID, a description of the operation, and whether the agent configuration was updated.
    public struct AgentConfigurationStatus: Swift.Equatable {
        /// The agent ID.
        public var agentId: Swift.String?
        /// A description of the operation performed.
        public var description: Swift.String?
        /// Information about the status of the StartDataCollection and StopDataCollection operations. The system has recorded the data collection operation. The agent receives this command the next time it polls for a new command.
        public var operationSucceeded: Swift.Bool

        public init(
            agentId: Swift.String? = nil,
            description: Swift.String? = nil,
            operationSucceeded: Swift.Bool = false
        )
        {
            self.agentId = agentId
            self.description = description
            self.operationSucceeded = operationSucceeded
        }
    }

}

extension ApplicationDiscoveryClientTypes.AgentInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case agentNetworkInfoList
        case agentType
        case collectionStatus
        case connectorId
        case health
        case hostName
        case lastHealthPingTime
        case registeredTime
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentNetworkInfoList = agentNetworkInfoList {
            var agentNetworkInfoListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentNetworkInfoList)
            for agentnetworkinfo0 in agentNetworkInfoList {
                try agentNetworkInfoListContainer.encode(agentnetworkinfo0)
            }
        }
        if let agentType = self.agentType {
            try encodeContainer.encode(agentType, forKey: .agentType)
        }
        if let collectionStatus = self.collectionStatus {
            try encodeContainer.encode(collectionStatus, forKey: .collectionStatus)
        }
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let health = self.health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
        if let hostName = self.hostName {
            try encodeContainer.encode(hostName, forKey: .hostName)
        }
        if let lastHealthPingTime = self.lastHealthPingTime {
            try encodeContainer.encode(lastHealthPingTime, forKey: .lastHealthPingTime)
        }
        if let registeredTime = self.registeredTime {
            try encodeContainer.encode(registeredTime, forKey: .registeredTime)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let agentNetworkInfoListContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.AgentNetworkInfo?].self, forKey: .agentNetworkInfoList)
        var agentNetworkInfoListDecoded0:[ApplicationDiscoveryClientTypes.AgentNetworkInfo]? = nil
        if let agentNetworkInfoListContainer = agentNetworkInfoListContainer {
            agentNetworkInfoListDecoded0 = [ApplicationDiscoveryClientTypes.AgentNetworkInfo]()
            for structure0 in agentNetworkInfoListContainer {
                if let structure0 = structure0 {
                    agentNetworkInfoListDecoded0?.append(structure0)
                }
            }
        }
        agentNetworkInfoList = agentNetworkInfoListDecoded0
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let healthDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.AgentStatus.self, forKey: .health)
        health = healthDecoded
        let lastHealthPingTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastHealthPingTime)
        lastHealthPingTime = lastHealthPingTimeDecoded
        let collectionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionStatus)
        collectionStatus = collectionStatusDecoded
        let agentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentType)
        agentType = agentTypeDecoded
        let registeredTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredTime)
        registeredTime = registeredTimeDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Information about agents associated with the user’s Amazon Web Services account. Information includes agent IDs, IP addresses, media access control (MAC) addresses, agent or collector status, hostname where the agent resides, and agent version for each agent.
    public struct AgentInfo: Swift.Equatable {
        /// The agent or collector ID.
        public var agentId: Swift.String?
        /// Network details about the host where the agent or collector resides.
        public var agentNetworkInfoList: [ApplicationDiscoveryClientTypes.AgentNetworkInfo]?
        /// Type of agent.
        public var agentType: Swift.String?
        /// Status of the collection process for an agent.
        public var collectionStatus: Swift.String?
        /// The ID of the connector.
        public var connectorId: Swift.String?
        /// The health of the agent.
        public var health: ApplicationDiscoveryClientTypes.AgentStatus?
        /// The name of the host where the agent or collector resides. The host can be a server or virtual machine.
        public var hostName: Swift.String?
        /// Time since agent health was reported.
        public var lastHealthPingTime: Swift.String?
        /// Agent's first registration timestamp in UTC.
        public var registeredTime: Swift.String?
        /// The agent or collector version.
        public var version: Swift.String?

        public init(
            agentId: Swift.String? = nil,
            agentNetworkInfoList: [ApplicationDiscoveryClientTypes.AgentNetworkInfo]? = nil,
            agentType: Swift.String? = nil,
            collectionStatus: Swift.String? = nil,
            connectorId: Swift.String? = nil,
            health: ApplicationDiscoveryClientTypes.AgentStatus? = nil,
            hostName: Swift.String? = nil,
            lastHealthPingTime: Swift.String? = nil,
            registeredTime: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.agentId = agentId
            self.agentNetworkInfoList = agentNetworkInfoList
            self.agentType = agentType
            self.collectionStatus = collectionStatus
            self.connectorId = connectorId
            self.health = health
            self.hostName = hostName
            self.lastHealthPingTime = lastHealthPingTime
            self.registeredTime = registeredTime
            self.version = version
        }
    }

}

extension ApplicationDiscoveryClientTypes.AgentNetworkInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress
        case macAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let macAddress = self.macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
    }
}

extension ApplicationDiscoveryClientTypes.AgentNetworkInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Network details about the host where the agent/collector resides.
    public struct AgentNetworkInfo: Swift.Equatable {
        /// The IP address for the host where the agent/collector resides.
        public var ipAddress: Swift.String?
        /// The MAC address for the host where the agent/collector resides.
        public var macAddress: Swift.String?

        public init(
            ipAddress: Swift.String? = nil,
            macAddress: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
            self.macAddress = macAddress
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum AgentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case blacklisted
        case healthy
        case running
        case shutdown
        case unhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatus] {
            return [
                .blacklisted,
                .healthy,
                .running,
                .shutdown,
                .unhealthy,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .blacklisted: return "BLACKLISTED"
            case .healthy: return "HEALTHY"
            case .running: return "RUNNING"
            case .shutdown: return "SHUTDOWN"
            case .unhealthy: return "UNHEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentStatus(rawValue: rawValue) ?? AgentStatus.sdkUnknown(rawValue)
        }
    }
}

extension AssociateConfigurationItemsToApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationId
        case configurationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfigurationId = self.applicationConfigurationId {
            try encodeContainer.encode(applicationConfigurationId, forKey: .applicationConfigurationId)
        }
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationid0 in configurationIds {
                try configurationIdsContainer.encode(configurationid0)
            }
        }
    }
}

extension AssociateConfigurationItemsToApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateConfigurationItemsToApplicationInput: Swift.Equatable {
    /// The configuration ID of an application with which items are to be associated.
    /// This member is required.
    public var applicationConfigurationId: Swift.String?
    /// The ID of each configuration item to be associated with an application.
    /// This member is required.
    public var configurationIds: [Swift.String]?

    public init(
        applicationConfigurationId: Swift.String? = nil,
        configurationIds: [Swift.String]? = nil
    )
    {
        self.applicationConfigurationId = applicationConfigurationId
        self.configurationIds = configurationIds
    }
}

struct AssociateConfigurationItemsToApplicationInputBody: Swift.Equatable {
    let applicationConfigurationId: Swift.String?
    let configurationIds: [Swift.String]?
}

extension AssociateConfigurationItemsToApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationId
        case configurationIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationConfigurationId)
        applicationConfigurationId = applicationConfigurationIdDecoded
        let configurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[Swift.String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [Swift.String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
    }
}

extension AssociateConfigurationItemsToApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateConfigurationItemsToApplicationOutput: Swift.Equatable {

    public init() { }
}

enum AssociateConfigurationItemsToApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AuthorizationErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AuthorizationErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user does not have permission to perform the action. Check the IAM policy associated with this user.
public struct AuthorizationErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AuthorizationErrorException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AuthorizationErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AuthorizationErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationDiscoveryClientTypes.BatchDeleteImportDataError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorDescription
        case importTaskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorDescription = self.errorDescription {
            try encodeContainer.encode(errorDescription, forKey: .errorDescription)
        }
        if let importTaskId = self.importTaskId {
            try encodeContainer.encode(importTaskId, forKey: .importTaskId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importTaskId)
        importTaskId = importTaskIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.BatchDeleteImportDataErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorDescription)
        errorDescription = errorDescriptionDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Error messages returned for each import task that you deleted as a response for this command.
    public struct BatchDeleteImportDataError: Swift.Equatable {
        /// The type of error that occurred for a specific import task.
        public var errorCode: ApplicationDiscoveryClientTypes.BatchDeleteImportDataErrorCode?
        /// The description of the error that occurred for a specific import task.
        public var errorDescription: Swift.String?
        /// The unique import ID associated with the error that occurred.
        public var importTaskId: Swift.String?

        public init(
            errorCode: ApplicationDiscoveryClientTypes.BatchDeleteImportDataErrorCode? = nil,
            errorDescription: Swift.String? = nil,
            importTaskId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorDescription = errorDescription
            self.importTaskId = importTaskId
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum BatchDeleteImportDataErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalServerError
        case notFound
        case overLimit
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchDeleteImportDataErrorCode] {
            return [
                .internalServerError,
                .notFound,
                .overLimit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .notFound: return "NOT_FOUND"
            case .overLimit: return "OVER_LIMIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchDeleteImportDataErrorCode(rawValue: rawValue) ?? BatchDeleteImportDataErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension BatchDeleteImportDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importTaskIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importTaskIds = importTaskIds {
            var importTaskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .importTaskIds)
            for importtaskidentifier0 in importTaskIds {
                try importTaskIdsContainer.encode(importtaskidentifier0)
            }
        }
    }
}

extension BatchDeleteImportDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchDeleteImportDataInput: Swift.Equatable {
    /// The IDs for the import tasks that you want to delete.
    /// This member is required.
    public var importTaskIds: [Swift.String]?

    public init(
        importTaskIds: [Swift.String]? = nil
    )
    {
        self.importTaskIds = importTaskIds
    }
}

struct BatchDeleteImportDataInputBody: Swift.Equatable {
    let importTaskIds: [Swift.String]?
}

extension BatchDeleteImportDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importTaskIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importTaskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importTaskIds)
        var importTaskIdsDecoded0:[Swift.String]? = nil
        if let importTaskIdsContainer = importTaskIdsContainer {
            importTaskIdsDecoded0 = [Swift.String]()
            for string0 in importTaskIdsContainer {
                if let string0 = string0 {
                    importTaskIdsDecoded0?.append(string0)
                }
            }
        }
        importTaskIds = importTaskIdsDecoded0
    }
}

extension BatchDeleteImportDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeleteImportDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteImportDataOutput: Swift.Equatable {
    /// Error messages returned for each import task that you deleted as a response for this command.
    public var errors: [ApplicationDiscoveryClientTypes.BatchDeleteImportDataError]?

    public init(
        errors: [ApplicationDiscoveryClientTypes.BatchDeleteImportDataError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteImportDataOutputBody: Swift.Equatable {
    let errors: [ApplicationDiscoveryClientTypes.BatchDeleteImportDataError]?
}

extension BatchDeleteImportDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.BatchDeleteImportDataError?].self, forKey: .errors)
        var errorsDecoded0:[ApplicationDiscoveryClientTypes.BatchDeleteImportDataError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ApplicationDiscoveryClientTypes.BatchDeleteImportDataError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchDeleteImportDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationDiscoveryClientTypes {
    public enum ConfigurationItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case application
        case connections
        case process
        case server
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationItemType] {
            return [
                .application,
                .connections,
                .process,
                .server,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .connections: return "CONNECTION"
            case .process: return "PROCESS"
            case .server: return "SERVER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationItemType(rawValue: rawValue) ?? ConfigurationItemType.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationDiscoveryClientTypes.ConfigurationTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
        case configurationType
        case key
        case timeOfCreation
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = self.configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if let configurationType = self.configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let timeOfCreation = self.timeOfCreation {
            try encodeContainer.encodeTimestamp(timeOfCreation, format: .epochSeconds, forKey: .timeOfCreation)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ConfigurationItemType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let timeOfCreationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timeOfCreation)
        timeOfCreation = timeOfCreationDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Tags for a configuration item. Tags are metadata that help you categorize IT assets.
    public struct ConfigurationTag: Swift.Equatable {
        /// The configuration ID for the item to tag. You can specify a list of keys and values.
        public var configurationId: Swift.String?
        /// A type of IT asset to tag.
        public var configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType?
        /// A type of tag on which to filter. For example, serverType.
        public var key: Swift.String?
        /// The time the configuration tag was created in Coordinated Universal Time (UTC).
        public var timeOfCreation: ClientRuntime.Date?
        /// A value on which to filter. For example key = serverType and value = web server.
        public var value: Swift.String?

        public init(
            configurationId: Swift.String? = nil,
            configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType? = nil,
            key: Swift.String? = nil,
            timeOfCreation: ClientRuntime.Date? = nil,
            value: Swift.String? = nil
        )
        {
            self.configurationId = configurationId
            self.configurationType = configurationType
            self.key = key
            self.timeOfCreation = timeOfCreation
            self.value = value
        }
    }

}

extension ConflictErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ConflictErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictErrorException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationDiscoveryClientTypes.ContinuousExportDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case exportId
        case s3Bucket
        case schemaStorageConfig
        case startTime
        case status
        case statusDetail
        case stopTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let exportId = self.exportId {
            try encodeContainer.encode(exportId, forKey: .exportId)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let schemaStorageConfig = schemaStorageConfig {
            var schemaStorageConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .schemaStorageConfig)
            for (dictKey0, schemaStorageConfig0) in schemaStorageConfig {
                try schemaStorageConfigContainer.encode(schemaStorageConfig0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetail = self.statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
        if let stopTime = self.stopTime {
            try encodeContainer.encodeTimestamp(stopTime, format: .epochSeconds, forKey: .stopTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ContinuousExportStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopTime)
        stopTime = stopTimeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaStorageConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .schemaStorageConfig)
        var schemaStorageConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let schemaStorageConfigContainer = schemaStorageConfigContainer {
            schemaStorageConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in schemaStorageConfigContainer {
                if let string0 = string0 {
                    schemaStorageConfigDecoded0?[key0] = string0
                }
            }
        }
        schemaStorageConfig = schemaStorageConfigDecoded0
    }
}

extension ApplicationDiscoveryClientTypes {
    /// A list of continuous export descriptions.
    public struct ContinuousExportDescription: Swift.Equatable {
        /// The type of data collector used to gather this data (currently only offered for AGENT).
        public var dataSource: ApplicationDiscoveryClientTypes.DataSource?
        /// The unique ID assigned to this export.
        public var exportId: Swift.String?
        /// The name of the s3 bucket where the export data parquet files are stored.
        public var s3Bucket: Swift.String?
        /// An object which describes how the data is stored.
        ///
        /// * databaseName - the name of the Glue database used to store the schema.
        public var schemaStorageConfig: [Swift.String:Swift.String]?
        /// The timestamp representing when the continuous export was started.
        public var startTime: ClientRuntime.Date?
        /// Describes the status of the export. Can be one of the following values:
        ///
        /// * START_IN_PROGRESS - setting up resources to start continuous export.
        ///
        /// * START_FAILED - an error occurred setting up continuous export. To recover, call start-continuous-export again.
        ///
        /// * ACTIVE - data is being exported to the customer bucket.
        ///
        /// * ERROR - an error occurred during export. To fix the issue, call stop-continuous-export and start-continuous-export.
        ///
        /// * STOP_IN_PROGRESS - stopping the export.
        ///
        /// * STOP_FAILED - an error occurred stopping the export. To recover, call stop-continuous-export again.
        ///
        /// * INACTIVE - the continuous export has been stopped. Data is no longer being exported to the customer bucket.
        public var status: ApplicationDiscoveryClientTypes.ContinuousExportStatus?
        /// Contains information about any errors that have occurred. This data type can have the following values:
        ///
        /// * ACCESS_DENIED - You don’t have permission to start Data Exploration in Amazon Athena. Contact your Amazon Web Services administrator for help. For more information, see [Setting Up Amazon Web Services Application Discovery Service](http://docs.aws.amazon.com/application-discovery/latest/userguide/setting-up.html) in the Application Discovery Service User Guide.
        ///
        /// * DELIVERY_STREAM_LIMIT_FAILURE - You reached the limit for Amazon Kinesis Data Firehose delivery streams. Reduce the number of streams or request a limit increase and try again. For more information, see [Kinesis Data Streams Limits](http://docs.aws.amazon.com/streams/latest/dev/service-sizes-and-limits.html) in the Amazon Kinesis Data Streams Developer Guide.
        ///
        /// * FIREHOSE_ROLE_MISSING - The Data Exploration feature is in an error state because your user is missing the Amazon Web ServicesApplicationDiscoveryServiceFirehose role. Turn on Data Exploration in Amazon Athena and try again. For more information, see [Creating the Amazon Web ServicesApplicationDiscoveryServiceFirehose Role](https://docs.aws.amazon.com/application-discovery/latest/userguide/security-iam-awsmanpol.html#security-iam-awsmanpol-create-firehose-role) in the Application Discovery Service User Guide.
        ///
        /// * FIREHOSE_STREAM_DOES_NOT_EXIST - The Data Exploration feature is in an error state because your user is missing one or more of the Kinesis data delivery streams.
        ///
        /// * INTERNAL_FAILURE - The Data Exploration feature is in an error state because of an internal failure. Try again later. If this problem persists, contact Amazon Web Services Support.
        ///
        /// * LAKE_FORMATION_ACCESS_DENIED - You don't have sufficient lake formation permissions to start continuous export. For more information, see [ Upgrading Amazon Web Services Glue Data Permissions to the Amazon Web Services Lake Formation Model ](http://docs.aws.amazon.com/lake-formation/latest/dg/upgrade-glue-lake-formation.html) in the Amazon Web Services Lake Formation Developer Guide. You can use one of the following two ways to resolve this issue.
        ///
        /// * If you don’t want to use the Lake Formation permission model, you can change the default Data Catalog settings to use only Amazon Web Services Identity and Access Management (IAM) access control for new databases. For more information, see [Change Data Catalog Settings](https://docs.aws.amazon.com/lake-formation/latest/dg/getting-started-setup.html#setup-change-cat-settings) in the Lake Formation Developer Guide.
        ///
        /// * You can give the service-linked IAM roles AWSServiceRoleForApplicationDiscoveryServiceContinuousExport and AWSApplicationDiscoveryServiceFirehose the required Lake Formation permissions. For more information, see [ Granting Database Permissions](https://docs.aws.amazon.com/lake-formation/latest/dg/granting-database-permissions.html) in the Lake Formation Developer Guide.
        ///
        /// * AWSServiceRoleForApplicationDiscoveryServiceContinuousExport - Grant database creator permissions, which gives the role database creation ability and implicit permissions for any created tables. For more information, see [ Implicit Lake Formation Permissions ](https://docs.aws.amazon.com/lake-formation/latest/dg/implicit-permissions.html) in the Lake Formation Developer Guide.
        ///
        /// * AWSApplicationDiscoveryServiceFirehose - Grant describe permissions for all tables in the database.
        ///
        ///
        ///
        ///
        ///
        ///
        ///
        /// * S3_BUCKET_LIMIT_FAILURE - You reached the limit for Amazon S3 buckets. Reduce the number of S3 buckets or request a limit increase and try again. For more information, see [Bucket Restrictions and Limitations](http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html) in the Amazon Simple Storage Service Developer Guide.
        ///
        /// * S3_NOT_SIGNED_UP - Your account is not signed up for the Amazon S3 service. You must sign up before you can use Amazon S3. You can sign up at the following URL: [https://aws.amazon.com/s3](https://aws.amazon.com/s3).
        public var statusDetail: Swift.String?
        /// The timestamp that represents when this continuous export was stopped.
        public var stopTime: ClientRuntime.Date?

        public init(
            dataSource: ApplicationDiscoveryClientTypes.DataSource? = nil,
            exportId: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            schemaStorageConfig: [Swift.String:Swift.String]? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ApplicationDiscoveryClientTypes.ContinuousExportStatus? = nil,
            statusDetail: Swift.String? = nil,
            stopTime: ClientRuntime.Date? = nil
        )
        {
            self.dataSource = dataSource
            self.exportId = exportId
            self.s3Bucket = s3Bucket
            self.schemaStorageConfig = schemaStorageConfig
            self.startTime = startTime
            self.status = status
            self.statusDetail = statusDetail
            self.stopTime = stopTime
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum ContinuousExportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case error
        case inactive
        case startFailed
        case startInProgress
        case stopFailed
        case stopInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ContinuousExportStatus] {
            return [
                .active,
                .error,
                .inactive,
                .startFailed,
                .startInProgress,
                .stopFailed,
                .stopInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case .startFailed: return "START_FAILED"
            case .startInProgress: return "START_IN_PROGRESS"
            case .stopFailed: return "STOP_FAILED"
            case .stopInProgress: return "STOP_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContinuousExportStatus(rawValue: rawValue) ?? ContinuousExportStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// Description of the application to be created.
    public var description: Swift.String?
    /// Name of the application to be created.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationId = output.configurationId
        } else {
            self.configurationId = nil
        }
    }
}

public struct CreateApplicationOutput: Swift.Equatable {
    /// Configuration ID of an application to be created.
    public var configurationId: Swift.String?

    public init(
        configurationId: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
    }
}

struct CreateApplicationOutputBody: Swift.Equatable {
    let configurationId: Swift.String?
}

extension CreateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
    }
}

enum CreateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationid0 in configurationIds {
                try configurationIdsContainer.encode(configurationid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTagsInput: Swift.Equatable {
    /// A list of configuration items that you want to tag.
    /// This member is required.
    public var configurationIds: [Swift.String]?
    /// Tags that you want to associate with one or more configuration items. Specify the tags that you want to create in a key-value format. For example: {"key": "serverType", "value": "webServer"}
    /// This member is required.
    public var tags: [ApplicationDiscoveryClientTypes.Tag]?

    public init(
        configurationIds: [Swift.String]? = nil,
        tags: [ApplicationDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.configurationIds = configurationIds
        self.tags = tags
    }
}

struct CreateTagsInputBody: Swift.Equatable {
    let configurationIds: [Swift.String]?
    let tags: [ApplicationDiscoveryClientTypes.Tag]?
}

extension CreateTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[Swift.String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [Swift.String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ApplicationDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ApplicationDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateTagsOutput: Swift.Equatable {

    public init() { }
}

enum CreateTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationDiscoveryClientTypes.CustomerAgentInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeAgents
        case blackListedAgents
        case healthyAgents
        case shutdownAgents
        case totalAgents
        case unhealthyAgents
        case unknownAgents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeAgents != 0 {
            try encodeContainer.encode(activeAgents, forKey: .activeAgents)
        }
        if blackListedAgents != 0 {
            try encodeContainer.encode(blackListedAgents, forKey: .blackListedAgents)
        }
        if healthyAgents != 0 {
            try encodeContainer.encode(healthyAgents, forKey: .healthyAgents)
        }
        if shutdownAgents != 0 {
            try encodeContainer.encode(shutdownAgents, forKey: .shutdownAgents)
        }
        if totalAgents != 0 {
            try encodeContainer.encode(totalAgents, forKey: .totalAgents)
        }
        if unhealthyAgents != 0 {
            try encodeContainer.encode(unhealthyAgents, forKey: .unhealthyAgents)
        }
        if unknownAgents != 0 {
            try encodeContainer.encode(unknownAgents, forKey: .unknownAgents)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeAgents) ?? 0
        activeAgents = activeAgentsDecoded
        let healthyAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyAgents) ?? 0
        healthyAgents = healthyAgentsDecoded
        let blackListedAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blackListedAgents) ?? 0
        blackListedAgents = blackListedAgentsDecoded
        let shutdownAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shutdownAgents) ?? 0
        shutdownAgents = shutdownAgentsDecoded
        let unhealthyAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyAgents) ?? 0
        unhealthyAgents = unhealthyAgentsDecoded
        let totalAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAgents) ?? 0
        totalAgents = totalAgentsDecoded
        let unknownAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknownAgents) ?? 0
        unknownAgents = unknownAgentsDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Inventory data for installed discovery agents.
    public struct CustomerAgentInfo: Swift.Equatable {
        /// Number of active discovery agents.
        /// This member is required.
        public var activeAgents: Swift.Int
        /// Number of blacklisted discovery agents.
        /// This member is required.
        public var blackListedAgents: Swift.Int
        /// Number of healthy discovery agents
        /// This member is required.
        public var healthyAgents: Swift.Int
        /// Number of discovery agents with status SHUTDOWN.
        /// This member is required.
        public var shutdownAgents: Swift.Int
        /// Total number of discovery agents.
        /// This member is required.
        public var totalAgents: Swift.Int
        /// Number of unhealthy discovery agents.
        /// This member is required.
        public var unhealthyAgents: Swift.Int
        /// Number of unknown discovery agents.
        /// This member is required.
        public var unknownAgents: Swift.Int

        public init(
            activeAgents: Swift.Int = 0,
            blackListedAgents: Swift.Int = 0,
            healthyAgents: Swift.Int = 0,
            shutdownAgents: Swift.Int = 0,
            totalAgents: Swift.Int = 0,
            unhealthyAgents: Swift.Int = 0,
            unknownAgents: Swift.Int = 0
        )
        {
            self.activeAgents = activeAgents
            self.blackListedAgents = blackListedAgents
            self.healthyAgents = healthyAgents
            self.shutdownAgents = shutdownAgents
            self.totalAgents = totalAgents
            self.unhealthyAgents = unhealthyAgents
            self.unknownAgents = unknownAgents
        }
    }

}

extension ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeAgentlessCollectors
        case denyListedAgentlessCollectors
        case healthyAgentlessCollectors
        case shutdownAgentlessCollectors
        case totalAgentlessCollectors
        case unhealthyAgentlessCollectors
        case unknownAgentlessCollectors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeAgentlessCollectors != 0 {
            try encodeContainer.encode(activeAgentlessCollectors, forKey: .activeAgentlessCollectors)
        }
        if denyListedAgentlessCollectors != 0 {
            try encodeContainer.encode(denyListedAgentlessCollectors, forKey: .denyListedAgentlessCollectors)
        }
        if healthyAgentlessCollectors != 0 {
            try encodeContainer.encode(healthyAgentlessCollectors, forKey: .healthyAgentlessCollectors)
        }
        if shutdownAgentlessCollectors != 0 {
            try encodeContainer.encode(shutdownAgentlessCollectors, forKey: .shutdownAgentlessCollectors)
        }
        if totalAgentlessCollectors != 0 {
            try encodeContainer.encode(totalAgentlessCollectors, forKey: .totalAgentlessCollectors)
        }
        if unhealthyAgentlessCollectors != 0 {
            try encodeContainer.encode(unhealthyAgentlessCollectors, forKey: .unhealthyAgentlessCollectors)
        }
        if unknownAgentlessCollectors != 0 {
            try encodeContainer.encode(unknownAgentlessCollectors, forKey: .unknownAgentlessCollectors)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeAgentlessCollectors) ?? 0
        activeAgentlessCollectors = activeAgentlessCollectorsDecoded
        let healthyAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyAgentlessCollectors) ?? 0
        healthyAgentlessCollectors = healthyAgentlessCollectorsDecoded
        let denyListedAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .denyListedAgentlessCollectors) ?? 0
        denyListedAgentlessCollectors = denyListedAgentlessCollectorsDecoded
        let shutdownAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shutdownAgentlessCollectors) ?? 0
        shutdownAgentlessCollectors = shutdownAgentlessCollectorsDecoded
        let unhealthyAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyAgentlessCollectors) ?? 0
        unhealthyAgentlessCollectors = unhealthyAgentlessCollectorsDecoded
        let totalAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAgentlessCollectors) ?? 0
        totalAgentlessCollectors = totalAgentlessCollectorsDecoded
        let unknownAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknownAgentlessCollectors) ?? 0
        unknownAgentlessCollectors = unknownAgentlessCollectorsDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// The inventory data for installed Agentless Collector collectors.
    public struct CustomerAgentlessCollectorInfo: Swift.Equatable {
        /// The number of active Agentless Collector collectors.
        /// This member is required.
        public var activeAgentlessCollectors: Swift.Int
        /// The number of deny-listed Agentless Collector collectors.
        /// This member is required.
        public var denyListedAgentlessCollectors: Swift.Int
        /// The number of healthy Agentless Collector collectors.
        /// This member is required.
        public var healthyAgentlessCollectors: Swift.Int
        /// The number of Agentless Collector collectors with SHUTDOWN status.
        /// This member is required.
        public var shutdownAgentlessCollectors: Swift.Int
        /// The total number of Agentless Collector collectors.
        /// This member is required.
        public var totalAgentlessCollectors: Swift.Int
        /// The number of unhealthy Agentless Collector collectors.
        /// This member is required.
        public var unhealthyAgentlessCollectors: Swift.Int
        /// The number of unknown Agentless Collector collectors.
        /// This member is required.
        public var unknownAgentlessCollectors: Swift.Int

        public init(
            activeAgentlessCollectors: Swift.Int = 0,
            denyListedAgentlessCollectors: Swift.Int = 0,
            healthyAgentlessCollectors: Swift.Int = 0,
            shutdownAgentlessCollectors: Swift.Int = 0,
            totalAgentlessCollectors: Swift.Int = 0,
            unhealthyAgentlessCollectors: Swift.Int = 0,
            unknownAgentlessCollectors: Swift.Int = 0
        )
        {
            self.activeAgentlessCollectors = activeAgentlessCollectors
            self.denyListedAgentlessCollectors = denyListedAgentlessCollectors
            self.healthyAgentlessCollectors = healthyAgentlessCollectors
            self.shutdownAgentlessCollectors = shutdownAgentlessCollectors
            self.totalAgentlessCollectors = totalAgentlessCollectors
            self.unhealthyAgentlessCollectors = unhealthyAgentlessCollectors
            self.unknownAgentlessCollectors = unknownAgentlessCollectors
        }
    }

}

extension ApplicationDiscoveryClientTypes.CustomerConnectorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeConnectors
        case blackListedConnectors
        case healthyConnectors
        case shutdownConnectors
        case totalConnectors
        case unhealthyConnectors
        case unknownConnectors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeConnectors != 0 {
            try encodeContainer.encode(activeConnectors, forKey: .activeConnectors)
        }
        if blackListedConnectors != 0 {
            try encodeContainer.encode(blackListedConnectors, forKey: .blackListedConnectors)
        }
        if healthyConnectors != 0 {
            try encodeContainer.encode(healthyConnectors, forKey: .healthyConnectors)
        }
        if shutdownConnectors != 0 {
            try encodeContainer.encode(shutdownConnectors, forKey: .shutdownConnectors)
        }
        if totalConnectors != 0 {
            try encodeContainer.encode(totalConnectors, forKey: .totalConnectors)
        }
        if unhealthyConnectors != 0 {
            try encodeContainer.encode(unhealthyConnectors, forKey: .unhealthyConnectors)
        }
        if unknownConnectors != 0 {
            try encodeContainer.encode(unknownConnectors, forKey: .unknownConnectors)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeConnectors) ?? 0
        activeConnectors = activeConnectorsDecoded
        let healthyConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyConnectors) ?? 0
        healthyConnectors = healthyConnectorsDecoded
        let blackListedConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blackListedConnectors) ?? 0
        blackListedConnectors = blackListedConnectorsDecoded
        let shutdownConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shutdownConnectors) ?? 0
        shutdownConnectors = shutdownConnectorsDecoded
        let unhealthyConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyConnectors) ?? 0
        unhealthyConnectors = unhealthyConnectorsDecoded
        let totalConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalConnectors) ?? 0
        totalConnectors = totalConnectorsDecoded
        let unknownConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknownConnectors) ?? 0
        unknownConnectors = unknownConnectorsDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Inventory data for installed discovery connectors.
    public struct CustomerConnectorInfo: Swift.Equatable {
        /// Number of active discovery connectors.
        /// This member is required.
        public var activeConnectors: Swift.Int
        /// Number of blacklisted discovery connectors.
        /// This member is required.
        public var blackListedConnectors: Swift.Int
        /// Number of healthy discovery connectors.
        /// This member is required.
        public var healthyConnectors: Swift.Int
        /// Number of discovery connectors with status SHUTDOWN,
        /// This member is required.
        public var shutdownConnectors: Swift.Int
        /// Total number of discovery connectors.
        /// This member is required.
        public var totalConnectors: Swift.Int
        /// Number of unhealthy discovery connectors.
        /// This member is required.
        public var unhealthyConnectors: Swift.Int
        /// Number of unknown discovery connectors.
        /// This member is required.
        public var unknownConnectors: Swift.Int

        public init(
            activeConnectors: Swift.Int = 0,
            blackListedConnectors: Swift.Int = 0,
            healthyConnectors: Swift.Int = 0,
            shutdownConnectors: Swift.Int = 0,
            totalConnectors: Swift.Int = 0,
            unhealthyConnectors: Swift.Int = 0,
            unknownConnectors: Swift.Int = 0
        )
        {
            self.activeConnectors = activeConnectors
            self.blackListedConnectors = blackListedConnectors
            self.healthyConnectors = healthyConnectors
            self.shutdownConnectors = shutdownConnectors
            self.totalConnectors = totalConnectors
            self.unhealthyConnectors = unhealthyConnectors
            self.unknownConnectors = unknownConnectors
        }
    }

}

extension ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeMeCollectors
        case denyListedMeCollectors
        case healthyMeCollectors
        case shutdownMeCollectors
        case totalMeCollectors
        case unhealthyMeCollectors
        case unknownMeCollectors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeMeCollectors != 0 {
            try encodeContainer.encode(activeMeCollectors, forKey: .activeMeCollectors)
        }
        if denyListedMeCollectors != 0 {
            try encodeContainer.encode(denyListedMeCollectors, forKey: .denyListedMeCollectors)
        }
        if healthyMeCollectors != 0 {
            try encodeContainer.encode(healthyMeCollectors, forKey: .healthyMeCollectors)
        }
        if shutdownMeCollectors != 0 {
            try encodeContainer.encode(shutdownMeCollectors, forKey: .shutdownMeCollectors)
        }
        if totalMeCollectors != 0 {
            try encodeContainer.encode(totalMeCollectors, forKey: .totalMeCollectors)
        }
        if unhealthyMeCollectors != 0 {
            try encodeContainer.encode(unhealthyMeCollectors, forKey: .unhealthyMeCollectors)
        }
        if unknownMeCollectors != 0 {
            try encodeContainer.encode(unknownMeCollectors, forKey: .unknownMeCollectors)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeMeCollectors) ?? 0
        activeMeCollectors = activeMeCollectorsDecoded
        let healthyMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyMeCollectors) ?? 0
        healthyMeCollectors = healthyMeCollectorsDecoded
        let denyListedMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .denyListedMeCollectors) ?? 0
        denyListedMeCollectors = denyListedMeCollectorsDecoded
        let shutdownMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shutdownMeCollectors) ?? 0
        shutdownMeCollectors = shutdownMeCollectorsDecoded
        let unhealthyMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyMeCollectors) ?? 0
        unhealthyMeCollectors = unhealthyMeCollectorsDecoded
        let totalMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalMeCollectors) ?? 0
        totalMeCollectors = totalMeCollectorsDecoded
        let unknownMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknownMeCollectors) ?? 0
        unknownMeCollectors = unknownMeCollectorsDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// The inventory data for installed Migration Evaluator collectors.
    public struct CustomerMeCollectorInfo: Swift.Equatable {
        /// The number of active Migration Evaluator collectors.
        /// This member is required.
        public var activeMeCollectors: Swift.Int
        /// The number of deny-listed Migration Evaluator collectors.
        /// This member is required.
        public var denyListedMeCollectors: Swift.Int
        /// The number of healthy Migration Evaluator collectors.
        /// This member is required.
        public var healthyMeCollectors: Swift.Int
        /// The number of Migration Evaluator collectors with SHUTDOWN status.
        /// This member is required.
        public var shutdownMeCollectors: Swift.Int
        /// The total number of Migration Evaluator collectors.
        /// This member is required.
        public var totalMeCollectors: Swift.Int
        /// The number of unhealthy Migration Evaluator collectors.
        /// This member is required.
        public var unhealthyMeCollectors: Swift.Int
        /// The number of unknown Migration Evaluator collectors.
        /// This member is required.
        public var unknownMeCollectors: Swift.Int

        public init(
            activeMeCollectors: Swift.Int = 0,
            denyListedMeCollectors: Swift.Int = 0,
            healthyMeCollectors: Swift.Int = 0,
            shutdownMeCollectors: Swift.Int = 0,
            totalMeCollectors: Swift.Int = 0,
            unhealthyMeCollectors: Swift.Int = 0,
            unknownMeCollectors: Swift.Int = 0
        )
        {
            self.activeMeCollectors = activeMeCollectors
            self.denyListedMeCollectors = denyListedMeCollectors
            self.healthyMeCollectors = healthyMeCollectors
            self.shutdownMeCollectors = shutdownMeCollectors
            self.totalMeCollectors = totalMeCollectors
            self.unhealthyMeCollectors = unhealthyMeCollectors
            self.unknownMeCollectors = unknownMeCollectors
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum DataSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSource] {
            return [
                .agent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSource(rawValue: rawValue) ?? DataSource.sdkUnknown(rawValue)
        }
    }
}

extension DeleteApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for applicationid0 in configurationIds {
                try configurationIdsContainer.encode(applicationid0)
            }
        }
    }
}

extension DeleteApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationsInput: Swift.Equatable {
    /// Configuration ID of an application to be deleted.
    /// This member is required.
    public var configurationIds: [Swift.String]?

    public init(
        configurationIds: [Swift.String]? = nil
    )
    {
        self.configurationIds = configurationIds
    }
}

struct DeleteApplicationsInputBody: Swift.Equatable {
    let configurationIds: [Swift.String]?
}

extension DeleteApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[Swift.String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [Swift.String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
    }
}

extension DeleteApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationid0 in configurationIds {
                try configurationIdsContainer.encode(configurationid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension DeleteTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTagsInput: Swift.Equatable {
    /// A list of configuration items with tags that you want to delete.
    /// This member is required.
    public var configurationIds: [Swift.String]?
    /// Tags that you want to delete from one or more configuration items. Specify the tags that you want to delete in a key-value format. For example: {"key": "serverType", "value": "webServer"}
    public var tags: [ApplicationDiscoveryClientTypes.Tag]?

    public init(
        configurationIds: [Swift.String]? = nil,
        tags: [ApplicationDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.configurationIds = configurationIds
        self.tags = tags
    }
}

struct DeleteTagsInputBody: Swift.Equatable {
    let configurationIds: [Swift.String]?
    let tags: [ApplicationDiscoveryClientTypes.Tag]?
}

extension DeleteTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[Swift.String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [Swift.String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ApplicationDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ApplicationDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DeleteTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTagsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAgentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentIds = agentIds {
            var agentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentIds)
            for agentid0 in agentIds {
                try agentIdsContainer.encode(agentid0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAgentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAgentsInput: Swift.Equatable {
    /// The agent or the collector IDs for which you want information. If you specify no IDs, the system returns information about all agents/collectors associated with your user.
    public var agentIds: [Swift.String]?
    /// You can filter the request using various logical operators and a key-value format. For example: {"key": "collectionStatus", "value": "STARTED"}
    public var filters: [ApplicationDiscoveryClientTypes.Filter]?
    /// The total number of agents/collectors to return in a single page of output. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// Token to retrieve the next set of results. For example, if you previously specified 100 IDs for DescribeAgentsRequest$agentIds but set DescribeAgentsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
    public var nextToken: Swift.String?

    public init(
        agentIds: [Swift.String]? = nil,
        filters: [ApplicationDiscoveryClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentIds = agentIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAgentsInputBody: Swift.Equatable {
    let agentIds: [Swift.String]?
    let filters: [ApplicationDiscoveryClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeAgentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .agentIds)
        var agentIdsDecoded0:[Swift.String]? = nil
        if let agentIdsContainer = agentIdsContainer {
            agentIdsDecoded0 = [Swift.String]()
            for string0 in agentIdsContainer {
                if let string0 = string0 {
                    agentIdsDecoded0?.append(string0)
                }
            }
        }
        agentIds = agentIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ApplicationDiscoveryClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ApplicationDiscoveryClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAgentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAgentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentsInfo = output.agentsInfo
            self.nextToken = output.nextToken
        } else {
            self.agentsInfo = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAgentsOutput: Swift.Equatable {
    /// Lists agents or the collector by ID or lists all agents/collectors associated with your user, if you did not specify an agent/collector ID. The output includes agent/collector IDs, IP addresses, media access control (MAC) addresses, agent/collector health, host name where the agent/collector resides, and the version number of each agent/collector.
    public var agentsInfo: [ApplicationDiscoveryClientTypes.AgentInfo]?
    /// Token to retrieve the next set of results. For example, if you specified 100 IDs for DescribeAgentsRequest$agentIds but set DescribeAgentsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init(
        agentsInfo: [ApplicationDiscoveryClientTypes.AgentInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentsInfo = agentsInfo
        self.nextToken = nextToken
    }
}

struct DescribeAgentsOutputBody: Swift.Equatable {
    let agentsInfo: [ApplicationDiscoveryClientTypes.AgentInfo]?
    let nextToken: Swift.String?
}

extension DescribeAgentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentsInfo
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentsInfoContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.AgentInfo?].self, forKey: .agentsInfo)
        var agentsInfoDecoded0:[ApplicationDiscoveryClientTypes.AgentInfo]? = nil
        if let agentsInfoContainer = agentsInfoContainer {
            agentsInfoDecoded0 = [ApplicationDiscoveryClientTypes.AgentInfo]()
            for structure0 in agentsInfoContainer {
                if let structure0 = structure0 {
                    agentsInfoDecoded0?.append(structure0)
                }
            }
        }
        agentsInfo = agentsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAgentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationid0 in configurationIds {
                try configurationIdsContainer.encode(configurationid0)
            }
        }
    }
}

extension DescribeConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConfigurationsInput: Swift.Equatable {
    /// One or more configuration IDs.
    /// This member is required.
    public var configurationIds: [Swift.String]?

    public init(
        configurationIds: [Swift.String]? = nil
    )
    {
        self.configurationIds = configurationIds
    }
}

struct DescribeConfigurationsInputBody: Swift.Equatable {
    let configurationIds: [Swift.String]?
}

extension DescribeConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[Swift.String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [Swift.String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
    }
}

extension DescribeConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurations = output.configurations
        } else {
            self.configurations = nil
        }
    }
}

public struct DescribeConfigurationsOutput: Swift.Equatable {
    /// A key in the response map. The value is an array of data.
    public var configurations: [[Swift.String:Swift.String]]?

    public init(
        configurations: [[Swift.String:Swift.String]]? = nil
    )
    {
        self.configurations = configurations
    }
}

struct DescribeConfigurationsOutputBody: Swift.Equatable {
    let configurations: [[Swift.String:Swift.String]]?
}

extension DescribeConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .configurations)
        var configurationsDecoded0:[[Swift.String:Swift.String]]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in configurationsContainer {
                var configurationsContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    configurationsContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in map0 {
                        if let string1 = string1 {
                            configurationsContainerDecoded0?[key1] = string1
                        }
                    }
                }
                if let configurationsContainerDecoded0 = configurationsContainerDecoded0 {
                    configurationsDecoded0?.append(configurationsContainerDecoded0)
                }
            }
        }
        configurations = configurationsDecoded0
    }
}

enum DescribeConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeContinuousExportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportIds
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportIds = exportIds {
            var exportIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportIds)
            for configurationsexportid0 in exportIds {
                try exportIdsContainer.encode(configurationsexportid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeContinuousExportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeContinuousExportsInput: Swift.Equatable {
    /// The unique IDs assigned to the exports.
    public var exportIds: [Swift.String]?
    /// A number between 1 and 100 specifying the maximum number of continuous export descriptions returned.
    public var maxResults: Swift.Int?
    /// The token from the previous call to DescribeExportTasks.
    public var nextToken: Swift.String?

    public init(
        exportIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportIds = exportIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeContinuousExportsInputBody: Swift.Equatable {
    let exportIds: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeContinuousExportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportIds
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exportIds)
        var exportIdsDecoded0:[Swift.String]? = nil
        if let exportIdsContainer = exportIdsContainer {
            exportIdsDecoded0 = [Swift.String]()
            for string0 in exportIdsContainer {
                if let string0 = string0 {
                    exportIdsDecoded0?.append(string0)
                }
            }
        }
        exportIds = exportIdsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeContinuousExportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeContinuousExportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.descriptions = output.descriptions
            self.nextToken = output.nextToken
        } else {
            self.descriptions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeContinuousExportsOutput: Swift.Equatable {
    /// A list of continuous export descriptions.
    public var descriptions: [ApplicationDiscoveryClientTypes.ContinuousExportDescription]?
    /// The token from the previous call to DescribeExportTasks.
    public var nextToken: Swift.String?

    public init(
        descriptions: [ApplicationDiscoveryClientTypes.ContinuousExportDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.descriptions = descriptions
        self.nextToken = nextToken
    }
}

struct DescribeContinuousExportsOutputBody: Swift.Equatable {
    let descriptions: [ApplicationDiscoveryClientTypes.ContinuousExportDescription]?
    let nextToken: Swift.String?
}

extension DescribeContinuousExportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case descriptions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionsContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ContinuousExportDescription?].self, forKey: .descriptions)
        var descriptionsDecoded0:[ApplicationDiscoveryClientTypes.ContinuousExportDescription]? = nil
        if let descriptionsContainer = descriptionsContainer {
            descriptionsDecoded0 = [ApplicationDiscoveryClientTypes.ContinuousExportDescription]()
            for structure0 in descriptionsContainer {
                if let structure0 = structure0 {
                    descriptionsDecoded0?.append(structure0)
                }
            }
        }
        descriptions = descriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeContinuousExportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeExportConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportIds
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportIds = exportIds {
            var exportIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportIds)
            for configurationsexportid0 in exportIds {
                try exportIdsContainer.encode(configurationsexportid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeExportConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExportConfigurationsInput: Swift.Equatable {
    /// A list of continuous export IDs to search for.
    public var exportIds: [Swift.String]?
    /// A number between 1 and 100 specifying the maximum number of continuous export descriptions returned.
    public var maxResults: Swift.Int?
    /// The token from the previous call to describe-export-tasks.
    public var nextToken: Swift.String?

    public init(
        exportIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportIds = exportIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeExportConfigurationsInputBody: Swift.Equatable {
    let exportIds: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeExportConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportIds
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exportIds)
        var exportIdsDecoded0:[Swift.String]? = nil
        if let exportIdsContainer = exportIdsContainer {
            exportIdsDecoded0 = [Swift.String]()
            for string0 in exportIdsContainer {
                if let string0 = string0 {
                    exportIdsDecoded0?.append(string0)
                }
            }
        }
        exportIds = exportIdsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeExportConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeExportConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.exportsInfo = output.exportsInfo
            self.nextToken = output.nextToken
        } else {
            self.exportsInfo = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeExportConfigurationsOutput: Swift.Equatable {
    ///
    public var exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]?
    /// The token from the previous call to describe-export-tasks.
    public var nextToken: Swift.String?

    public init(
        exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportsInfo = exportsInfo
        self.nextToken = nextToken
    }
}

struct DescribeExportConfigurationsOutputBody: Swift.Equatable {
    let exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]?
    let nextToken: Swift.String?
}

extension DescribeExportConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportsInfo
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportsInfoContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ExportInfo?].self, forKey: .exportsInfo)
        var exportsInfoDecoded0:[ApplicationDiscoveryClientTypes.ExportInfo]? = nil
        if let exportsInfoContainer = exportsInfoContainer {
            exportsInfoDecoded0 = [ApplicationDiscoveryClientTypes.ExportInfo]()
            for structure0 in exportsInfoContainer {
                if let structure0 = structure0 {
                    exportsInfoDecoded0?.append(structure0)
                }
            }
        }
        exportsInfo = exportsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeExportConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeExportTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportIds
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportIds = exportIds {
            var exportIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportIds)
            for configurationsexportid0 in exportIds {
                try exportIdsContainer.encode(configurationsexportid0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for exportfilter0 in filters {
                try filtersContainer.encode(exportfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeExportTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExportTasksInput: Swift.Equatable {
    /// One or more unique identifiers used to query the status of an export request.
    public var exportIds: [Swift.String]?
    /// One or more filters.
    ///
    /// * AgentId - ID of the agent whose collected data will be exported
    public var filters: [ApplicationDiscoveryClientTypes.ExportFilter]?
    /// The maximum number of volume results returned by DescribeExportTasks in paginated output. When this parameter is used, DescribeExportTasks only returns maxResults results in a single page along with a nextToken response element.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated DescribeExportTasks request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        exportIds: [Swift.String]? = nil,
        filters: [ApplicationDiscoveryClientTypes.ExportFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportIds = exportIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeExportTasksInputBody: Swift.Equatable {
    let exportIds: [Swift.String]?
    let filters: [ApplicationDiscoveryClientTypes.ExportFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeExportTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportIds
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exportIds)
        var exportIdsDecoded0:[Swift.String]? = nil
        if let exportIdsContainer = exportIdsContainer {
            exportIdsDecoded0 = [Swift.String]()
            for string0 in exportIdsContainer {
                if let string0 = string0 {
                    exportIdsDecoded0?.append(string0)
                }
            }
        }
        exportIds = exportIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ExportFilter?].self, forKey: .filters)
        var filtersDecoded0:[ApplicationDiscoveryClientTypes.ExportFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ApplicationDiscoveryClientTypes.ExportFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeExportTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeExportTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.exportsInfo = output.exportsInfo
            self.nextToken = output.nextToken
        } else {
            self.exportsInfo = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeExportTasksOutput: Swift.Equatable {
    /// Contains one or more sets of export request details. When the status of a request is SUCCEEDED, the response includes a URL for an Amazon S3 bucket where you can view the data in a CSV file.
    public var exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]?
    /// The nextToken value to include in a future DescribeExportTasks request. When the results of a DescribeExportTasks request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportsInfo = exportsInfo
        self.nextToken = nextToken
    }
}

struct DescribeExportTasksOutputBody: Swift.Equatable {
    let exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]?
    let nextToken: Swift.String?
}

extension DescribeExportTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportsInfo
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportsInfoContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ExportInfo?].self, forKey: .exportsInfo)
        var exportsInfoDecoded0:[ApplicationDiscoveryClientTypes.ExportInfo]? = nil
        if let exportsInfoContainer = exportsInfoContainer {
            exportsInfoDecoded0 = [ApplicationDiscoveryClientTypes.ExportInfo]()
            for structure0 in exportsInfoContainer {
                if let structure0 = structure0 {
                    exportsInfoDecoded0?.append(structure0)
                }
            }
        }
        exportsInfo = exportsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeExportTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeImportTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for importtaskfilter0 in filters {
                try filtersContainer.encode(importtaskfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeImportTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImportTasksInput: Swift.Equatable {
    /// An array of name-value pairs that you provide to filter the results for the DescribeImportTask request to a specific subset of results. Currently, wildcard values aren't supported for filters.
    public var filters: [ApplicationDiscoveryClientTypes.ImportTaskFilter]?
    /// The maximum number of results that you want this request to return, up to 100.
    public var maxResults: Swift.Int?
    /// The token to request a specific page of results.
    public var nextToken: Swift.String?

    public init(
        filters: [ApplicationDiscoveryClientTypes.ImportTaskFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeImportTasksInputBody: Swift.Equatable {
    let filters: [ApplicationDiscoveryClientTypes.ImportTaskFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeImportTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ImportTaskFilter?].self, forKey: .filters)
        var filtersDecoded0:[ApplicationDiscoveryClientTypes.ImportTaskFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ApplicationDiscoveryClientTypes.ImportTaskFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImportTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeImportTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct DescribeImportTasksOutput: Swift.Equatable {
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// A returned array of import tasks that match any applied filters, up to the specified number of maximum results.
    public var tasks: [ApplicationDiscoveryClientTypes.ImportTask]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [ApplicationDiscoveryClientTypes.ImportTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct DescribeImportTasksOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tasks: [ApplicationDiscoveryClientTypes.ImportTask]?
}

extension DescribeImportTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tasks
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tasksContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ImportTask?].self, forKey: .tasks)
        var tasksDecoded0:[ApplicationDiscoveryClientTypes.ImportTask]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [ApplicationDiscoveryClientTypes.ImportTask]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
    }
}

enum DescribeImportTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for tagfilter0 in filters {
                try filtersContainer.encode(tagfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeTagsInput: Swift.Equatable {
    /// You can filter the list using a key-value format. You can separate these items by using logical operators. Allowed filters include tagKey, tagValue, and configurationId.
    public var filters: [ApplicationDiscoveryClientTypes.TagFilter]?
    /// The total number of items to return in a single page of output. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [ApplicationDiscoveryClientTypes.TagFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeTagsInputBody: Swift.Equatable {
    let filters: [ApplicationDiscoveryClientTypes.TagFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.TagFilter?].self, forKey: .filters)
        var filtersDecoded0:[ApplicationDiscoveryClientTypes.TagFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ApplicationDiscoveryClientTypes.TagFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct DescribeTagsOutput: Swift.Equatable {
    /// The call returns a token. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Depending on the input, this is a list of configuration items tagged with a specific tag, or a list of tags for a specific configuration item.
    public var tags: [ApplicationDiscoveryClientTypes.ConfigurationTag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [ApplicationDiscoveryClientTypes.ConfigurationTag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct DescribeTagsOutputBody: Swift.Equatable {
    let tags: [ApplicationDiscoveryClientTypes.ConfigurationTag]?
    let nextToken: Swift.String?
}

extension DescribeTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ConfigurationTag?].self, forKey: .tags)
        var tagsDecoded0:[ApplicationDiscoveryClientTypes.ConfigurationTag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ApplicationDiscoveryClientTypes.ConfigurationTag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateConfigurationItemsFromApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationId
        case configurationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfigurationId = self.applicationConfigurationId {
            try encodeContainer.encode(applicationConfigurationId, forKey: .applicationConfigurationId)
        }
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationid0 in configurationIds {
                try configurationIdsContainer.encode(configurationid0)
            }
        }
    }
}

extension DisassociateConfigurationItemsFromApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateConfigurationItemsFromApplicationInput: Swift.Equatable {
    /// Configuration ID of an application from which each item is disassociated.
    /// This member is required.
    public var applicationConfigurationId: Swift.String?
    /// Configuration ID of each item to be disassociated from an application.
    /// This member is required.
    public var configurationIds: [Swift.String]?

    public init(
        applicationConfigurationId: Swift.String? = nil,
        configurationIds: [Swift.String]? = nil
    )
    {
        self.applicationConfigurationId = applicationConfigurationId
        self.configurationIds = configurationIds
    }
}

struct DisassociateConfigurationItemsFromApplicationInputBody: Swift.Equatable {
    let applicationConfigurationId: Swift.String?
    let configurationIds: [Swift.String]?
}

extension DisassociateConfigurationItemsFromApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationId
        case configurationIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationConfigurationId)
        applicationConfigurationId = applicationConfigurationIdDecoded
        let configurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[Swift.String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [Swift.String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
    }
}

extension DisassociateConfigurationItemsFromApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateConfigurationItemsFromApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateConfigurationItemsFromApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationDiscoveryClientTypes.Ec2RecommendationsExportPreferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpuPerformanceMetricBasis
        case enabled
        case excludedInstanceTypes
        case preferredRegion
        case ramPerformanceMetricBasis
        case reservedInstanceOptions
        case tenancy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpuPerformanceMetricBasis = self.cpuPerformanceMetricBasis {
            try encodeContainer.encode(cpuPerformanceMetricBasis, forKey: .cpuPerformanceMetricBasis)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let excludedInstanceTypes = excludedInstanceTypes {
            var excludedInstanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedInstanceTypes)
            for ec2instancetype0 in excludedInstanceTypes {
                try excludedInstanceTypesContainer.encode(ec2instancetype0)
            }
        }
        if let preferredRegion = self.preferredRegion {
            try encodeContainer.encode(preferredRegion, forKey: .preferredRegion)
        }
        if let ramPerformanceMetricBasis = self.ramPerformanceMetricBasis {
            try encodeContainer.encode(ramPerformanceMetricBasis, forKey: .ramPerformanceMetricBasis)
        }
        if let reservedInstanceOptions = self.reservedInstanceOptions {
            try encodeContainer.encode(reservedInstanceOptions, forKey: .reservedInstanceOptions)
        }
        if let tenancy = self.tenancy {
            try encodeContainer.encode(tenancy.rawValue, forKey: .tenancy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let cpuPerformanceMetricBasisDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.UsageMetricBasis.self, forKey: .cpuPerformanceMetricBasis)
        cpuPerformanceMetricBasis = cpuPerformanceMetricBasisDecoded
        let ramPerformanceMetricBasisDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.UsageMetricBasis.self, forKey: .ramPerformanceMetricBasis)
        ramPerformanceMetricBasis = ramPerformanceMetricBasisDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.Tenancy.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let excludedInstanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludedInstanceTypes)
        var excludedInstanceTypesDecoded0:[Swift.String]? = nil
        if let excludedInstanceTypesContainer = excludedInstanceTypesContainer {
            excludedInstanceTypesDecoded0 = [Swift.String]()
            for string0 in excludedInstanceTypesContainer {
                if let string0 = string0 {
                    excludedInstanceTypesDecoded0?.append(string0)
                }
            }
        }
        excludedInstanceTypes = excludedInstanceTypesDecoded0
        let preferredRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredRegion)
        preferredRegion = preferredRegionDecoded
        let reservedInstanceOptionsDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ReservedInstanceOptions.self, forKey: .reservedInstanceOptions)
        reservedInstanceOptions = reservedInstanceOptionsDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Indicates that the exported data must include EC2 instance type matches for on-premises servers that are discovered through Amazon Web Services Application Discovery Service.
    public struct Ec2RecommendationsExportPreferences: Swift.Equatable {
        /// The recommended EC2 instance type that matches the CPU usage metric of server performance data.
        public var cpuPerformanceMetricBasis: ApplicationDiscoveryClientTypes.UsageMetricBasis?
        /// If set to true, the export [preferences](https://docs.aws.amazon.com/application-discovery/latest/APIReference/API_StartExportTask.html#API_StartExportTask_RequestSyntax) is set to Ec2RecommendationsExportPreferences.
        public var enabled: Swift.Bool
        /// An array of instance types to exclude from recommendations.
        public var excludedInstanceTypes: [Swift.String]?
        /// The target Amazon Web Services Region for the recommendations. You can use any of the Region codes available for the chosen service, as listed in [Amazon Web Services service endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html) in the Amazon Web Services General Reference.
        public var preferredRegion: Swift.String?
        /// The recommended EC2 instance type that matches the Memory usage metric of server performance data.
        public var ramPerformanceMetricBasis: ApplicationDiscoveryClientTypes.UsageMetricBasis?
        /// The contract type for a reserved instance. If blank, we assume an On-Demand instance is preferred.
        public var reservedInstanceOptions: ApplicationDiscoveryClientTypes.ReservedInstanceOptions?
        /// The target tenancy to use for your recommended EC2 instances.
        public var tenancy: ApplicationDiscoveryClientTypes.Tenancy?

        public init(
            cpuPerformanceMetricBasis: ApplicationDiscoveryClientTypes.UsageMetricBasis? = nil,
            enabled: Swift.Bool = false,
            excludedInstanceTypes: [Swift.String]? = nil,
            preferredRegion: Swift.String? = nil,
            ramPerformanceMetricBasis: ApplicationDiscoveryClientTypes.UsageMetricBasis? = nil,
            reservedInstanceOptions: ApplicationDiscoveryClientTypes.ReservedInstanceOptions? = nil,
            tenancy: ApplicationDiscoveryClientTypes.Tenancy? = nil
        )
        {
            self.cpuPerformanceMetricBasis = cpuPerformanceMetricBasis
            self.enabled = enabled
            self.excludedInstanceTypes = excludedInstanceTypes
            self.preferredRegion = preferredRegion
            self.ramPerformanceMetricBasis = ramPerformanceMetricBasis
            self.reservedInstanceOptions = reservedInstanceOptions
            self.tenancy = tenancy
        }
    }

}

extension ExportConfigurationsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ExportConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExportConfigurationsInput: Swift.Equatable {

    public init() { }
}

struct ExportConfigurationsInputBody: Swift.Equatable {
}

extension ExportConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ExportConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.exportId = output.exportId
        } else {
            self.exportId = nil
        }
    }
}

public struct ExportConfigurationsOutput: Swift.Equatable {
    /// A unique identifier that you can use to query the export status.
    public var exportId: Swift.String?

    public init(
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct ExportConfigurationsOutputBody: Swift.Equatable {
    let exportId: Swift.String?
}

extension ExportConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
    }
}

enum ExportConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationDiscoveryClientTypes {
    public enum ExportDataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportDataFormat] {
            return [
                .csv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportDataFormat(rawValue: rawValue) ?? ExportDataFormat.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationDiscoveryClientTypes.ExportFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Used to select which agent's data is to be exported. A single agent ID may be selected for export using the [StartExportTask](http://docs.aws.amazon.com/application-discovery/latest/APIReference/API_StartExportTask.html) action.
    public struct ExportFilter: Swift.Equatable {
        /// Supported condition: EQUALS
        /// This member is required.
        public var condition: Swift.String?
        /// A single ExportFilter name. Supported filters: agentIds.
        /// This member is required.
        public var name: Swift.String?
        /// A single agent ID for a Discovery Agent. An agent ID can be found using the [DescribeAgents](http://docs.aws.amazon.com/application-discovery/latest/APIReference/API_DescribeAgents.html) action. Typically an ADS agent ID is in the form o-0123456789abcdef0.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            condition: Swift.String? = nil,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension ApplicationDiscoveryClientTypes.ExportInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationsDownloadUrl
        case exportId
        case exportRequestTime
        case exportStatus
        case isTruncated
        case requestedEndTime
        case requestedStartTime
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationsDownloadUrl = self.configurationsDownloadUrl {
            try encodeContainer.encode(configurationsDownloadUrl, forKey: .configurationsDownloadUrl)
        }
        if let exportId = self.exportId {
            try encodeContainer.encode(exportId, forKey: .exportId)
        }
        if let exportRequestTime = self.exportRequestTime {
            try encodeContainer.encodeTimestamp(exportRequestTime, format: .epochSeconds, forKey: .exportRequestTime)
        }
        if let exportStatus = self.exportStatus {
            try encodeContainer.encode(exportStatus.rawValue, forKey: .exportStatus)
        }
        if isTruncated != false {
            try encodeContainer.encode(isTruncated, forKey: .isTruncated)
        }
        if let requestedEndTime = self.requestedEndTime {
            try encodeContainer.encodeTimestamp(requestedEndTime, format: .epochSeconds, forKey: .requestedEndTime)
        }
        if let requestedStartTime = self.requestedStartTime {
            try encodeContainer.encodeTimestamp(requestedStartTime, format: .epochSeconds, forKey: .requestedStartTime)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let configurationsDownloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationsDownloadUrl)
        configurationsDownloadUrl = configurationsDownloadUrlDecoded
        let exportRequestTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .exportRequestTime)
        exportRequestTime = exportRequestTimeDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let requestedStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .requestedStartTime)
        requestedStartTime = requestedStartTimeDecoded
        let requestedEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .requestedEndTime)
        requestedEndTime = requestedEndTimeDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Information regarding the export status of discovered data. The value is an array of objects.
    public struct ExportInfo: Swift.Equatable {
        /// A URL for an Amazon S3 bucket where you can review the exported data. The URL is displayed only if the export succeeded.
        public var configurationsDownloadUrl: Swift.String?
        /// A unique identifier used to query an export.
        /// This member is required.
        public var exportId: Swift.String?
        /// The time that the data export was initiated.
        /// This member is required.
        public var exportRequestTime: ClientRuntime.Date?
        /// The status of the data export job.
        /// This member is required.
        public var exportStatus: ApplicationDiscoveryClientTypes.ExportStatus?
        /// If true, the export of agent information exceeded the size limit for a single export and the exported data is incomplete for the requested time range. To address this, select a smaller time range for the export by using startDate and endDate.
        public var isTruncated: Swift.Bool
        /// The endTime used in the StartExportTask request. If no endTime was requested, this result does not appear in ExportInfo.
        public var requestedEndTime: ClientRuntime.Date?
        /// The value of startTime parameter in the StartExportTask request. If no startTime was requested, this result does not appear in ExportInfo.
        public var requestedStartTime: ClientRuntime.Date?
        /// A status message provided for API callers.
        /// This member is required.
        public var statusMessage: Swift.String?

        public init(
            configurationsDownloadUrl: Swift.String? = nil,
            exportId: Swift.String? = nil,
            exportRequestTime: ClientRuntime.Date? = nil,
            exportStatus: ApplicationDiscoveryClientTypes.ExportStatus? = nil,
            isTruncated: Swift.Bool = false,
            requestedEndTime: ClientRuntime.Date? = nil,
            requestedStartTime: ClientRuntime.Date? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.configurationsDownloadUrl = configurationsDownloadUrl
            self.exportId = exportId
            self.exportRequestTime = exportRequestTime
            self.exportStatus = exportStatus
            self.isTruncated = isTruncated
            self.requestedEndTime = requestedEndTime
            self.requestedStartTime = requestedStartTime
            self.statusMessage = statusMessage
        }
    }

}

extension ApplicationDiscoveryClientTypes.ExportPreferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2recommendationspreferences = "ec2RecommendationsPreferences"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .ec2recommendationspreferences(ec2recommendationspreferences):
                try container.encode(ec2recommendationspreferences, forKey: .ec2recommendationspreferences)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let ec2recommendationspreferencesDecoded = try values.decodeIfPresent(ApplicationDiscoveryClientTypes.Ec2RecommendationsExportPreferences.self, forKey: .ec2recommendationspreferences)
        if let ec2recommendationspreferences = ec2recommendationspreferencesDecoded {
            self = .ec2recommendationspreferences(ec2recommendationspreferences)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Indicates the type of data that is being exported. Only one ExportPreferences can be enabled for a [StartExportTask](https://docs.aws.amazon.com/application-discovery/latest/APIReference/API_StartExportTask.html) action.
    public enum ExportPreferences: Swift.Equatable {
        /// If enabled, exported data includes EC2 instance type matches for on-premises servers discovered through Amazon Web Services Application Discovery Service.
        case ec2recommendationspreferences(ApplicationDiscoveryClientTypes.Ec2RecommendationsExportPreferences)
        case sdkUnknown(Swift.String)
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum ExportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportStatus(rawValue: rawValue) ?? ExportStatus.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationDiscoveryClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// A filter that can use conditional operators. For more information about filters, see [Querying Discovered Configuration Items](https://docs.aws.amazon.com/application-discovery/latest/userguide/discovery-api-queries.html) in the Amazon Web Services Application Discovery Service User Guide.
    public struct Filter: Swift.Equatable {
        /// A conditional operator. The following operators are valid: EQUALS, NOT_EQUALS, CONTAINS, NOT_CONTAINS. If you specify multiple filters, the system utilizes all filters as though concatenated by AND. If you specify multiple values for a particular filter, the system differentiates the values using OR. Calling either DescribeConfigurations or ListConfigurations returns attributes of matching configuration items.
        /// This member is required.
        public var condition: Swift.String?
        /// The name of the filter.
        /// This member is required.
        public var name: Swift.String?
        /// A string value on which to filter. For example, if you choose the destinationServer.osVersion filter name, you could specify Ubuntu for the value.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            condition: Swift.String? = nil,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension GetDiscoverySummaryInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetDiscoverySummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDiscoverySummaryInput: Swift.Equatable {

    public init() { }
}

struct GetDiscoverySummaryInputBody: Swift.Equatable {
}

extension GetDiscoverySummaryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDiscoverySummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDiscoverySummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentSummary = output.agentSummary
            self.agentlessCollectorSummary = output.agentlessCollectorSummary
            self.applications = output.applications
            self.connectorSummary = output.connectorSummary
            self.meCollectorSummary = output.meCollectorSummary
            self.servers = output.servers
            self.serversMappedToApplications = output.serversMappedToApplications
            self.serversMappedtoTags = output.serversMappedtoTags
        } else {
            self.agentSummary = nil
            self.agentlessCollectorSummary = nil
            self.applications = 0
            self.connectorSummary = nil
            self.meCollectorSummary = nil
            self.servers = 0
            self.serversMappedToApplications = 0
            self.serversMappedtoTags = 0
        }
    }
}

public struct GetDiscoverySummaryOutput: Swift.Equatable {
    /// Details about discovered agents, including agent status and health.
    public var agentSummary: ApplicationDiscoveryClientTypes.CustomerAgentInfo?
    /// Details about Agentless Collector collectors, including status.
    public var agentlessCollectorSummary: ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo?
    /// The number of applications discovered.
    public var applications: Swift.Int
    /// Details about discovered connectors, including connector status and health.
    public var connectorSummary: ApplicationDiscoveryClientTypes.CustomerConnectorInfo?
    /// Details about Migration Evaluator collectors, including collector status and health.
    public var meCollectorSummary: ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo?
    /// The number of servers discovered.
    public var servers: Swift.Int
    /// The number of servers mapped to applications.
    public var serversMappedToApplications: Swift.Int
    /// The number of servers mapped to tags.
    public var serversMappedtoTags: Swift.Int

    public init(
        agentSummary: ApplicationDiscoveryClientTypes.CustomerAgentInfo? = nil,
        agentlessCollectorSummary: ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo? = nil,
        applications: Swift.Int = 0,
        connectorSummary: ApplicationDiscoveryClientTypes.CustomerConnectorInfo? = nil,
        meCollectorSummary: ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo? = nil,
        servers: Swift.Int = 0,
        serversMappedToApplications: Swift.Int = 0,
        serversMappedtoTags: Swift.Int = 0
    )
    {
        self.agentSummary = agentSummary
        self.agentlessCollectorSummary = agentlessCollectorSummary
        self.applications = applications
        self.connectorSummary = connectorSummary
        self.meCollectorSummary = meCollectorSummary
        self.servers = servers
        self.serversMappedToApplications = serversMappedToApplications
        self.serversMappedtoTags = serversMappedtoTags
    }
}

struct GetDiscoverySummaryOutputBody: Swift.Equatable {
    let servers: Swift.Int
    let applications: Swift.Int
    let serversMappedToApplications: Swift.Int
    let serversMappedtoTags: Swift.Int
    let agentSummary: ApplicationDiscoveryClientTypes.CustomerAgentInfo?
    let connectorSummary: ApplicationDiscoveryClientTypes.CustomerConnectorInfo?
    let meCollectorSummary: ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo?
    let agentlessCollectorSummary: ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo?
}

extension GetDiscoverySummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentSummary
        case agentlessCollectorSummary
        case applications
        case connectorSummary
        case meCollectorSummary
        case servers
        case serversMappedToApplications
        case serversMappedtoTags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serversDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .servers) ?? 0
        servers = serversDecoded
        let applicationsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applications) ?? 0
        applications = applicationsDecoded
        let serversMappedToApplicationsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serversMappedToApplications) ?? 0
        serversMappedToApplications = serversMappedToApplicationsDecoded
        let serversMappedtoTagsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serversMappedtoTags) ?? 0
        serversMappedtoTags = serversMappedtoTagsDecoded
        let agentSummaryDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.CustomerAgentInfo.self, forKey: .agentSummary)
        agentSummary = agentSummaryDecoded
        let connectorSummaryDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.CustomerConnectorInfo.self, forKey: .connectorSummary)
        connectorSummary = connectorSummaryDecoded
        let meCollectorSummaryDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo.self, forKey: .meCollectorSummary)
        meCollectorSummary = meCollectorSummaryDecoded
        let agentlessCollectorSummaryDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo.self, forKey: .agentlessCollectorSummary)
        agentlessCollectorSummary = agentlessCollectorSummaryDecoded
    }
}

enum GetDiscoverySummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension HomeRegionNotSetException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: HomeRegionNotSetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The home Region is not set. Set the home Region to continue.
public struct HomeRegionNotSetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "HomeRegionNotSetException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct HomeRegionNotSetExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension HomeRegionNotSetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    public enum ImportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteComplete
        case deleteFailed
        case deleteFailedLimitExceeded
        case deleteInProgress
        case importComplete
        case importCompleteWithErrors
        case importFailed
        case importFailedRecordLimitExceeded
        case importFailedServerLimitExceeded
        case importInProgress
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportStatus] {
            return [
                .deleteComplete,
                .deleteFailed,
                .deleteFailedLimitExceeded,
                .deleteInProgress,
                .importComplete,
                .importCompleteWithErrors,
                .importFailed,
                .importFailedRecordLimitExceeded,
                .importFailedServerLimitExceeded,
                .importInProgress,
                .internalError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteComplete: return "DELETE_COMPLETE"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteFailedLimitExceeded: return "DELETE_FAILED_LIMIT_EXCEEDED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .importComplete: return "IMPORT_COMPLETE"
            case .importCompleteWithErrors: return "IMPORT_COMPLETE_WITH_ERRORS"
            case .importFailed: return "IMPORT_FAILED"
            case .importFailedRecordLimitExceeded: return "IMPORT_FAILED_RECORD_LIMIT_EXCEEDED"
            case .importFailedServerLimitExceeded: return "IMPORT_FAILED_SERVER_LIMIT_EXCEEDED"
            case .importInProgress: return "IMPORT_IN_PROGRESS"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportStatus(rawValue: rawValue) ?? ImportStatus.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationDiscoveryClientTypes.ImportTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationImportFailure
        case applicationImportSuccess
        case clientRequestToken
        case errorsAndFailedEntriesZip
        case importCompletionTime
        case importDeletedTime
        case importRequestTime
        case importTaskId
        case importUrl
        case name
        case serverImportFailure
        case serverImportSuccess
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applicationImportFailure != 0 {
            try encodeContainer.encode(applicationImportFailure, forKey: .applicationImportFailure)
        }
        if applicationImportSuccess != 0 {
            try encodeContainer.encode(applicationImportSuccess, forKey: .applicationImportSuccess)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let errorsAndFailedEntriesZip = self.errorsAndFailedEntriesZip {
            try encodeContainer.encode(errorsAndFailedEntriesZip, forKey: .errorsAndFailedEntriesZip)
        }
        if let importCompletionTime = self.importCompletionTime {
            try encodeContainer.encodeTimestamp(importCompletionTime, format: .epochSeconds, forKey: .importCompletionTime)
        }
        if let importDeletedTime = self.importDeletedTime {
            try encodeContainer.encodeTimestamp(importDeletedTime, format: .epochSeconds, forKey: .importDeletedTime)
        }
        if let importRequestTime = self.importRequestTime {
            try encodeContainer.encodeTimestamp(importRequestTime, format: .epochSeconds, forKey: .importRequestTime)
        }
        if let importTaskId = self.importTaskId {
            try encodeContainer.encode(importTaskId, forKey: .importTaskId)
        }
        if let importUrl = self.importUrl {
            try encodeContainer.encode(importUrl, forKey: .importUrl)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if serverImportFailure != 0 {
            try encodeContainer.encode(serverImportFailure, forKey: .serverImportFailure)
        }
        if serverImportSuccess != 0 {
            try encodeContainer.encode(serverImportSuccess, forKey: .serverImportSuccess)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importTaskId)
        importTaskId = importTaskIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let importUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importUrl)
        importUrl = importUrlDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ImportStatus.self, forKey: .status)
        status = statusDecoded
        let importRequestTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .importRequestTime)
        importRequestTime = importRequestTimeDecoded
        let importCompletionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .importCompletionTime)
        importCompletionTime = importCompletionTimeDecoded
        let importDeletedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .importDeletedTime)
        importDeletedTime = importDeletedTimeDecoded
        let serverImportSuccessDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serverImportSuccess) ?? 0
        serverImportSuccess = serverImportSuccessDecoded
        let serverImportFailureDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serverImportFailure) ?? 0
        serverImportFailure = serverImportFailureDecoded
        let applicationImportSuccessDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationImportSuccess) ?? 0
        applicationImportSuccess = applicationImportSuccessDecoded
        let applicationImportFailureDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationImportFailure) ?? 0
        applicationImportFailure = applicationImportFailureDecoded
        let errorsAndFailedEntriesZipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorsAndFailedEntriesZip)
        errorsAndFailedEntriesZip = errorsAndFailedEntriesZipDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// An array of information related to the import task request that includes status information, times, IDs, the Amazon S3 Object URL for the import file, and more.
    public struct ImportTask: Swift.Equatable {
        /// The total number of application records in the import file that failed to be imported.
        public var applicationImportFailure: Swift.Int
        /// The total number of application records in the import file that were successfully imported.
        public var applicationImportSuccess: Swift.Int
        /// A unique token used to prevent the same import request from occurring more than once. If you didn't provide a token, a token was automatically generated when the import task request was sent.
        public var clientRequestToken: Swift.String?
        /// A link to a compressed archive folder (in the ZIP format) that contains an error log and a file of failed records. You can use these two files to quickly identify records that failed, why they failed, and correct those records. Afterward, you can upload the corrected file to your Amazon S3 bucket and create another import task request. This field also includes authorization information so you can confirm the authenticity of the compressed archive before you download it. If some records failed to be imported we recommend that you correct the records in the failed entries file and then imports that failed entries file. This prevents you from having to correct and update the larger original file and attempt importing it again.
        public var errorsAndFailedEntriesZip: Swift.String?
        /// The time that the import task request finished, presented in the Unix time stamp format.
        public var importCompletionTime: ClientRuntime.Date?
        /// The time that the import task request was deleted, presented in the Unix time stamp format.
        public var importDeletedTime: ClientRuntime.Date?
        /// The time that the import task request was made, presented in the Unix time stamp format.
        public var importRequestTime: ClientRuntime.Date?
        /// The unique ID for a specific import task. These IDs aren't globally unique, but they are unique within an Amazon Web Services account.
        public var importTaskId: Swift.String?
        /// The URL for your import file that you've uploaded to Amazon S3.
        public var importUrl: Swift.String?
        /// A descriptive name for an import task. You can use this name to filter future requests related to this import task, such as identifying applications and servers that were included in this import task. We recommend that you use a meaningful name for each import task.
        public var name: Swift.String?
        /// The total number of server records in the import file that failed to be imported.
        public var serverImportFailure: Swift.Int
        /// The total number of server records in the import file that were successfully imported.
        public var serverImportSuccess: Swift.Int
        /// The status of the import task. An import can have the status of IMPORT_COMPLETE and still have some records fail to import from the overall request. More information can be found in the downloadable archive defined in the errorsAndFailedEntriesZip field, or in the Migration Hub management console.
        public var status: ApplicationDiscoveryClientTypes.ImportStatus?

        public init(
            applicationImportFailure: Swift.Int = 0,
            applicationImportSuccess: Swift.Int = 0,
            clientRequestToken: Swift.String? = nil,
            errorsAndFailedEntriesZip: Swift.String? = nil,
            importCompletionTime: ClientRuntime.Date? = nil,
            importDeletedTime: ClientRuntime.Date? = nil,
            importRequestTime: ClientRuntime.Date? = nil,
            importTaskId: Swift.String? = nil,
            importUrl: Swift.String? = nil,
            name: Swift.String? = nil,
            serverImportFailure: Swift.Int = 0,
            serverImportSuccess: Swift.Int = 0,
            status: ApplicationDiscoveryClientTypes.ImportStatus? = nil
        )
        {
            self.applicationImportFailure = applicationImportFailure
            self.applicationImportSuccess = applicationImportSuccess
            self.clientRequestToken = clientRequestToken
            self.errorsAndFailedEntriesZip = errorsAndFailedEntriesZip
            self.importCompletionTime = importCompletionTime
            self.importDeletedTime = importDeletedTime
            self.importRequestTime = importRequestTime
            self.importTaskId = importTaskId
            self.importUrl = importUrl
            self.name = name
            self.serverImportFailure = serverImportFailure
            self.serverImportSuccess = serverImportSuccess
            self.status = status
        }
    }

}

extension ApplicationDiscoveryClientTypes.ImportTaskFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for importtaskfiltervalue0 in values {
                try valuesContainer.encode(importtaskfiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ImportTaskFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ApplicationDiscoveryClientTypes {
    /// A name-values pair of elements you can use to filter the results when querying your import tasks. Currently, wildcards are not supported for filters. When filtering by import status, all other filter values are ignored.
    public struct ImportTaskFilter: Swift.Equatable {
        /// The name, status, or import task ID for a specific import task.
        public var name: ApplicationDiscoveryClientTypes.ImportTaskFilterName?
        /// An array of strings that you can provide to match against a specific name, status, or import task ID to filter the results for your import task queries.
        public var values: [Swift.String]?

        public init(
            name: ApplicationDiscoveryClientTypes.ImportTaskFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum ImportTaskFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case importTaskId
        case name
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportTaskFilterName] {
            return [
                .importTaskId,
                .name,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .importTaskId: return "IMPORT_TASK_ID"
            case .name: return "NAME"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportTaskFilterName(rawValue: rawValue) ?? ImportTaskFilterName.sdkUnknown(rawValue)
        }
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more parameters are not valid. Verify the parameters and try again.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The value of one or more parameters are either invalid or out of range. Verify the parameter values and try again.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationType
        case filters
        case maxResults
        case nextToken
        case orderBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationType = self.configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let orderBy = orderBy {
            var orderByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderBy)
            for orderbyelement0 in orderBy {
                try orderByContainer.encode(orderbyelement0)
            }
        }
    }
}

extension ListConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListConfigurationsInput: Swift.Equatable {
    /// A valid configuration identified by Application Discovery Service.
    /// This member is required.
    public var configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType?
    /// You can filter the request using various logical operators and a key-value format. For example: {"key": "serverType", "value": "webServer"} For a complete list of filter options and guidance about using them with this action, see [Using the ListConfigurations Action](https://docs.aws.amazon.com/application-discovery/latest/userguide/discovery-api-queries.html#ListConfigurations) in the Amazon Web Services Application Discovery Service User Guide.
    public var filters: [ApplicationDiscoveryClientTypes.Filter]?
    /// The total number of items to return. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// Token to retrieve the next set of results. For example, if a previous call to ListConfigurations returned 100 items, but you set ListConfigurationsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
    public var nextToken: Swift.String?
    /// Certain filter criteria return output that can be sorted in ascending or descending order. For a list of output characteristics for each filter, see [Using the ListConfigurations Action](https://docs.aws.amazon.com/application-discovery/latest/userguide/discovery-api-queries.html#ListConfigurations) in the Amazon Web Services Application Discovery Service User Guide.
    public var orderBy: [ApplicationDiscoveryClientTypes.OrderByElement]?

    public init(
        configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType? = nil,
        filters: [ApplicationDiscoveryClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        orderBy: [ApplicationDiscoveryClientTypes.OrderByElement]? = nil
    )
    {
        self.configurationType = configurationType
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.orderBy = orderBy
    }
}

struct ListConfigurationsInputBody: Swift.Equatable {
    let configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType?
    let filters: [ApplicationDiscoveryClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let orderBy: [ApplicationDiscoveryClientTypes.OrderByElement]?
}

extension ListConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationType
        case filters
        case maxResults
        case nextToken
        case orderBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ConfigurationItemType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ApplicationDiscoveryClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ApplicationDiscoveryClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let orderByContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.OrderByElement?].self, forKey: .orderBy)
        var orderByDecoded0:[ApplicationDiscoveryClientTypes.OrderByElement]? = nil
        if let orderByContainer = orderByContainer {
            orderByDecoded0 = [ApplicationDiscoveryClientTypes.OrderByElement]()
            for structure0 in orderByContainer {
                if let structure0 = structure0 {
                    orderByDecoded0?.append(structure0)
                }
            }
        }
        orderBy = orderByDecoded0
    }
}

extension ListConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurations = output.configurations
            self.nextToken = output.nextToken
        } else {
            self.configurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationsOutput: Swift.Equatable {
    /// Returns configuration details, including the configuration ID, attribute names, and attribute values.
    public var configurations: [[Swift.String:Swift.String]]?
    /// Token to retrieve the next set of results. For example, if your call to ListConfigurations returned 100 items, but you set ListConfigurationsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init(
        configurations: [[Swift.String:Swift.String]]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurations = configurations
        self.nextToken = nextToken
    }
}

struct ListConfigurationsOutputBody: Swift.Equatable {
    let configurations: [[Swift.String:Swift.String]]?
    let nextToken: Swift.String?
}

extension ListConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .configurations)
        var configurationsDecoded0:[[Swift.String:Swift.String]]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in configurationsContainer {
                var configurationsContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    configurationsContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in map0 {
                        if let string1 = string1 {
                            configurationsContainerDecoded0?[key1] = string1
                        }
                    }
                }
                if let configurationsContainerDecoded0 = configurationsContainerDecoded0 {
                    configurationsDecoded0?.append(configurationsContainerDecoded0)
                }
            }
        }
        configurations = configurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServerNeighborsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
        case maxResults
        case neighborConfigurationIds
        case nextToken
        case portInformationNeeded
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = self.configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let neighborConfigurationIds = neighborConfigurationIds {
            var neighborConfigurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neighborConfigurationIds)
            for configurationid0 in neighborConfigurationIds {
                try neighborConfigurationIdsContainer.encode(configurationid0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let portInformationNeeded = self.portInformationNeeded {
            try encodeContainer.encode(portInformationNeeded, forKey: .portInformationNeeded)
        }
    }
}

extension ListServerNeighborsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServerNeighborsInput: Swift.Equatable {
    /// Configuration ID of the server for which neighbors are being listed.
    /// This member is required.
    public var configurationId: Swift.String?
    /// Maximum number of results to return in a single page of output.
    public var maxResults: Swift.Int?
    /// List of configuration IDs to test for one-hop-away.
    public var neighborConfigurationIds: [Swift.String]?
    /// Token to retrieve the next set of results. For example, if you previously specified 100 IDs for ListServerNeighborsRequest$neighborConfigurationIds but set ListServerNeighborsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
    public var nextToken: Swift.String?
    /// Flag to indicate if port and protocol information is needed as part of the response.
    public var portInformationNeeded: Swift.Bool?

    public init(
        configurationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        neighborConfigurationIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        portInformationNeeded: Swift.Bool? = nil
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.neighborConfigurationIds = neighborConfigurationIds
        self.nextToken = nextToken
        self.portInformationNeeded = portInformationNeeded
    }
}

struct ListServerNeighborsInputBody: Swift.Equatable {
    let configurationId: Swift.String?
    let portInformationNeeded: Swift.Bool?
    let neighborConfigurationIds: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListServerNeighborsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
        case maxResults
        case neighborConfigurationIds
        case nextToken
        case portInformationNeeded
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let portInformationNeededDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .portInformationNeeded)
        portInformationNeeded = portInformationNeededDecoded
        let neighborConfigurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .neighborConfigurationIds)
        var neighborConfigurationIdsDecoded0:[Swift.String]? = nil
        if let neighborConfigurationIdsContainer = neighborConfigurationIdsContainer {
            neighborConfigurationIdsDecoded0 = [Swift.String]()
            for string0 in neighborConfigurationIdsContainer {
                if let string0 = string0 {
                    neighborConfigurationIdsDecoded0?.append(string0)
                }
            }
        }
        neighborConfigurationIds = neighborConfigurationIdsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServerNeighborsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServerNeighborsOutputBody = try responseDecoder.decode(responseBody: data)
            self.knownDependencyCount = output.knownDependencyCount
            self.neighbors = output.neighbors
            self.nextToken = output.nextToken
        } else {
            self.knownDependencyCount = 0
            self.neighbors = nil
            self.nextToken = nil
        }
    }
}

public struct ListServerNeighborsOutput: Swift.Equatable {
    /// Count of distinct servers that are one hop away from the given server.
    public var knownDependencyCount: Swift.Int
    /// List of distinct servers that are one hop away from the given server.
    /// This member is required.
    public var neighbors: [ApplicationDiscoveryClientTypes.NeighborConnectionDetail]?
    /// Token to retrieve the next set of results. For example, if you specified 100 IDs for ListServerNeighborsRequest$neighborConfigurationIds but set ListServerNeighborsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init(
        knownDependencyCount: Swift.Int = 0,
        neighbors: [ApplicationDiscoveryClientTypes.NeighborConnectionDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knownDependencyCount = knownDependencyCount
        self.neighbors = neighbors
        self.nextToken = nextToken
    }
}

struct ListServerNeighborsOutputBody: Swift.Equatable {
    let neighbors: [ApplicationDiscoveryClientTypes.NeighborConnectionDetail]?
    let nextToken: Swift.String?
    let knownDependencyCount: Swift.Int
}

extension ListServerNeighborsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knownDependencyCount
        case neighbors
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let neighborsContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.NeighborConnectionDetail?].self, forKey: .neighbors)
        var neighborsDecoded0:[ApplicationDiscoveryClientTypes.NeighborConnectionDetail]? = nil
        if let neighborsContainer = neighborsContainer {
            neighborsDecoded0 = [ApplicationDiscoveryClientTypes.NeighborConnectionDetail]()
            for structure0 in neighborsContainer {
                if let structure0 = structure0 {
                    neighborsDecoded0?.append(structure0)
                }
            }
        }
        neighbors = neighborsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let knownDependencyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .knownDependencyCount) ?? 0
        knownDependencyCount = knownDependencyCountDecoded
    }
}

enum ListServerNeighborsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationDiscoveryClientTypes.NeighborConnectionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionsCount
        case destinationPort
        case destinationServerId
        case sourceServerId
        case transportProtocol
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if connectionsCount != 0 {
            try encodeContainer.encode(connectionsCount, forKey: .connectionsCount)
        }
        if let destinationPort = self.destinationPort {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let destinationServerId = self.destinationServerId {
            try encodeContainer.encode(destinationServerId, forKey: .destinationServerId)
        }
        if let sourceServerId = self.sourceServerId {
            try encodeContainer.encode(sourceServerId, forKey: .sourceServerId)
        }
        if let transportProtocol = self.transportProtocol {
            try encodeContainer.encode(transportProtocol, forKey: .transportProtocol)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerId)
        sourceServerId = sourceServerIdDecoded
        let destinationServerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationServerId)
        destinationServerId = destinationServerIdDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let transportProtocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transportProtocol)
        transportProtocol = transportProtocolDecoded
        let connectionsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionsCount) ?? 0
        connectionsCount = connectionsCountDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Details about neighboring servers.
    public struct NeighborConnectionDetail: Swift.Equatable {
        /// The number of open network connections with the neighboring server.
        /// This member is required.
        public var connectionsCount: Swift.Int
        /// The destination network port for the connection.
        public var destinationPort: Swift.Int?
        /// The ID of the server that accepted the network connection.
        /// This member is required.
        public var destinationServerId: Swift.String?
        /// The ID of the server that opened the network connection.
        /// This member is required.
        public var sourceServerId: Swift.String?
        /// The network protocol used for the connection.
        public var transportProtocol: Swift.String?

        public init(
            connectionsCount: Swift.Int = 0,
            destinationPort: Swift.Int? = nil,
            destinationServerId: Swift.String? = nil,
            sourceServerId: Swift.String? = nil,
            transportProtocol: Swift.String? = nil
        )
        {
            self.connectionsCount = connectionsCount
            self.destinationPort = destinationPort
            self.destinationServerId = destinationServerId
            self.sourceServerId = sourceServerId
            self.transportProtocol = transportProtocol
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum OfferingClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case convertible
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferingClass] {
            return [
                .convertible,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .convertible: return "CONVERTIBLE"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OfferingClass(rawValue: rawValue) ?? OfferingClass.sdkUnknown(rawValue)
        }
    }
}

extension OperationNotPermittedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This operation is not permitted.
public struct OperationNotPermittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotPermittedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationDiscoveryClientTypes.OrderByElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldName
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldName = self.fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.OrderString.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// A field and direction for ordered output.
    public struct OrderByElement: Swift.Equatable {
        /// The field on which to order.
        /// This member is required.
        public var fieldName: Swift.String?
        /// Ordering direction.
        public var sortOrder: ApplicationDiscoveryClientTypes.OrderString?

        public init(
            fieldName: Swift.String? = nil,
            sortOrder: ApplicationDiscoveryClientTypes.OrderString? = nil
        )
        {
            self.fieldName = fieldName
            self.sortOrder = sortOrder
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum OrderString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderString] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderString(rawValue: rawValue) ?? OrderString.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationDiscoveryClientTypes {
    public enum PurchasingOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allUpfront
        case noUpfront
        case partialUpfront
        case sdkUnknown(Swift.String)

        public static var allCases: [PurchasingOption] {
            return [
                .allUpfront,
                .noUpfront,
                .partialUpfront,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allUpfront: return "ALL_UPFRONT"
            case .noUpfront: return "NO_UPFRONT"
            case .partialUpfront: return "PARTIAL_UPFRONT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PurchasingOption(rawValue: rawValue) ?? PurchasingOption.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationDiscoveryClientTypes.ReservedInstanceOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringClass
        case purchasingOption
        case termLength
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offeringClass = self.offeringClass {
            try encodeContainer.encode(offeringClass.rawValue, forKey: .offeringClass)
        }
        if let purchasingOption = self.purchasingOption {
            try encodeContainer.encode(purchasingOption.rawValue, forKey: .purchasingOption)
        }
        if let termLength = self.termLength {
            try encodeContainer.encode(termLength.rawValue, forKey: .termLength)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let purchasingOptionDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.PurchasingOption.self, forKey: .purchasingOption)
        purchasingOption = purchasingOptionDecoded
        let offeringClassDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.OfferingClass.self, forKey: .offeringClass)
        offeringClass = offeringClassDecoded
        let termLengthDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.TermLength.self, forKey: .termLength)
        termLength = termLengthDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Used to provide Reserved Instance preferences for the recommendation.
    public struct ReservedInstanceOptions: Swift.Equatable {
        /// The flexibility to change the instance types needed for your Reserved Instance.
        /// This member is required.
        public var offeringClass: ApplicationDiscoveryClientTypes.OfferingClass?
        /// The payment plan to use for your Reserved Instance.
        /// This member is required.
        public var purchasingOption: ApplicationDiscoveryClientTypes.PurchasingOption?
        /// The preferred duration of the Reserved Instance term.
        /// This member is required.
        public var termLength: ApplicationDiscoveryClientTypes.TermLength?

        public init(
            offeringClass: ApplicationDiscoveryClientTypes.OfferingClass? = nil,
            purchasingOption: ApplicationDiscoveryClientTypes.PurchasingOption? = nil,
            termLength: ApplicationDiscoveryClientTypes.TermLength? = nil
        )
        {
            self.offeringClass = offeringClass
            self.purchasingOption = purchasingOption
            self.termLength = termLength
        }
    }

}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This issue occurs when the same clientRequestToken is used with the StartImportTask action, but with different parameters. For example, you use the same request token but have two different import URLs, you can encounter this issue. If the import tasks are meant to be different, use a different clientRequestToken, and try again.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified configuration ID was not located. Verify the configuration ID and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServerInternalErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServerInternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The server experienced an internal error. Try again.
public struct ServerInternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServerInternalErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServerInternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServerInternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartContinuousExportInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension StartContinuousExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartContinuousExportInput: Swift.Equatable {

    public init() { }
}

struct StartContinuousExportInputBody: Swift.Equatable {
}

extension StartContinuousExportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartContinuousExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartContinuousExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
            self.exportId = output.exportId
            self.s3Bucket = output.s3Bucket
            self.schemaStorageConfig = output.schemaStorageConfig
            self.startTime = output.startTime
        } else {
            self.dataSource = nil
            self.exportId = nil
            self.s3Bucket = nil
            self.schemaStorageConfig = nil
            self.startTime = nil
        }
    }
}

public struct StartContinuousExportOutput: Swift.Equatable {
    /// The type of data collector used to gather this data (currently only offered for AGENT).
    public var dataSource: ApplicationDiscoveryClientTypes.DataSource?
    /// The unique ID assigned to this export.
    public var exportId: Swift.String?
    /// The name of the s3 bucket where the export data parquet files are stored.
    public var s3Bucket: Swift.String?
    /// A dictionary which describes how the data is stored.
    ///
    /// * databaseName - the name of the Glue database used to store the schema.
    public var schemaStorageConfig: [Swift.String:Swift.String]?
    /// The timestamp representing when the continuous export was started.
    public var startTime: ClientRuntime.Date?

    public init(
        dataSource: ApplicationDiscoveryClientTypes.DataSource? = nil,
        exportId: Swift.String? = nil,
        s3Bucket: Swift.String? = nil,
        schemaStorageConfig: [Swift.String:Swift.String]? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.dataSource = dataSource
        self.exportId = exportId
        self.s3Bucket = s3Bucket
        self.schemaStorageConfig = schemaStorageConfig
        self.startTime = startTime
    }
}

struct StartContinuousExportOutputBody: Swift.Equatable {
    let exportId: Swift.String?
    let s3Bucket: Swift.String?
    let startTime: ClientRuntime.Date?
    let dataSource: ApplicationDiscoveryClientTypes.DataSource?
    let schemaStorageConfig: [Swift.String:Swift.String]?
}

extension StartContinuousExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case exportId
        case s3Bucket
        case schemaStorageConfig
        case startTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaStorageConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .schemaStorageConfig)
        var schemaStorageConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let schemaStorageConfigContainer = schemaStorageConfigContainer {
            schemaStorageConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in schemaStorageConfigContainer {
                if let string0 = string0 {
                    schemaStorageConfigDecoded0?[key0] = string0
                }
            }
        }
        schemaStorageConfig = schemaStorageConfigDecoded0
    }
}

enum StartContinuousExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictErrorException": return try await ConflictErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartDataCollectionByAgentIdsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentIds = agentIds {
            var agentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentIds)
            for agentid0 in agentIds {
                try agentIdsContainer.encode(agentid0)
            }
        }
    }
}

extension StartDataCollectionByAgentIdsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartDataCollectionByAgentIdsInput: Swift.Equatable {
    /// The IDs of the agents from which to start collecting data. If you send a request to an agent ID that you do not have permission to contact, according to your Amazon Web Services account, the service does not throw an exception. Instead, it returns the error in the Description field. If you send a request to multiple agents and you do not have permission to contact some of those agents, the system does not throw an exception. Instead, the system shows Failed in the Description field.
    /// This member is required.
    public var agentIds: [Swift.String]?

    public init(
        agentIds: [Swift.String]? = nil
    )
    {
        self.agentIds = agentIds
    }
}

struct StartDataCollectionByAgentIdsInputBody: Swift.Equatable {
    let agentIds: [Swift.String]?
}

extension StartDataCollectionByAgentIdsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .agentIds)
        var agentIdsDecoded0:[Swift.String]? = nil
        if let agentIdsContainer = agentIdsContainer {
            agentIdsDecoded0 = [Swift.String]()
            for string0 in agentIdsContainer {
                if let string0 = string0 {
                    agentIdsDecoded0?.append(string0)
                }
            }
        }
        agentIds = agentIdsDecoded0
    }
}

extension StartDataCollectionByAgentIdsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartDataCollectionByAgentIdsOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentsConfigurationStatus = output.agentsConfigurationStatus
        } else {
            self.agentsConfigurationStatus = nil
        }
    }
}

public struct StartDataCollectionByAgentIdsOutput: Swift.Equatable {
    /// Information about agents that were instructed to start collecting data. Information includes the agent ID, a description of the operation performed, and whether the agent configuration was updated.
    public var agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]?

    public init(
        agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]? = nil
    )
    {
        self.agentsConfigurationStatus = agentsConfigurationStatus
    }
}

struct StartDataCollectionByAgentIdsOutputBody: Swift.Equatable {
    let agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]?
}

extension StartDataCollectionByAgentIdsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentsConfigurationStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentsConfigurationStatusContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.AgentConfigurationStatus?].self, forKey: .agentsConfigurationStatus)
        var agentsConfigurationStatusDecoded0:[ApplicationDiscoveryClientTypes.AgentConfigurationStatus]? = nil
        if let agentsConfigurationStatusContainer = agentsConfigurationStatusContainer {
            agentsConfigurationStatusDecoded0 = [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]()
            for structure0 in agentsConfigurationStatusContainer {
                if let structure0 = structure0 {
                    agentsConfigurationStatusDecoded0?.append(structure0)
                }
            }
        }
        agentsConfigurationStatus = agentsConfigurationStatusDecoded0
    }
}

enum StartDataCollectionByAgentIdsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartExportTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case exportDataFormat
        case filters
        case preferences
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let exportDataFormat = exportDataFormat {
            var exportDataFormatContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportDataFormat)
            for exportdataformat0 in exportDataFormat {
                try exportDataFormatContainer.encode(exportdataformat0.rawValue)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for exportfilter0 in filters {
                try filtersContainer.encode(exportfilter0)
            }
        }
        if let preferences = self.preferences {
            try encodeContainer.encode(preferences, forKey: .preferences)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension StartExportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartExportTaskInput: Swift.Equatable {
    /// The end timestamp for exported data from the single Application Discovery Agent selected in the filters. If no value is specified, exported data includes the most recent data collected by the agent.
    public var endTime: ClientRuntime.Date?
    /// The file format for the returned export data. Default value is CSV. Note: The GRAPHML option has been deprecated.
    public var exportDataFormat: [ApplicationDiscoveryClientTypes.ExportDataFormat]?
    /// If a filter is present, it selects the single agentId of the Application Discovery Agent for which data is exported. The agentId can be found in the results of the DescribeAgents API or CLI. If no filter is present, startTime and endTime are ignored and exported data includes both Amazon Web Services Application Discovery Service Agentless Collector collectors data and summary data from Application Discovery Agent agents.
    public var filters: [ApplicationDiscoveryClientTypes.ExportFilter]?
    /// Indicates the type of data that needs to be exported. Only one [ExportPreferences](https://docs.aws.amazon.com/application-discovery/latest/APIReference/API_ExportPreferences.html) can be enabled at any time.
    public var preferences: ApplicationDiscoveryClientTypes.ExportPreferences?
    /// The start timestamp for exported data from the single Application Discovery Agent selected in the filters. If no value is specified, data is exported starting from the first data collected by the agent.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        exportDataFormat: [ApplicationDiscoveryClientTypes.ExportDataFormat]? = nil,
        filters: [ApplicationDiscoveryClientTypes.ExportFilter]? = nil,
        preferences: ApplicationDiscoveryClientTypes.ExportPreferences? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.exportDataFormat = exportDataFormat
        self.filters = filters
        self.preferences = preferences
        self.startTime = startTime
    }
}

struct StartExportTaskInputBody: Swift.Equatable {
    let exportDataFormat: [ApplicationDiscoveryClientTypes.ExportDataFormat]?
    let filters: [ApplicationDiscoveryClientTypes.ExportFilter]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let preferences: ApplicationDiscoveryClientTypes.ExportPreferences?
}

extension StartExportTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case exportDataFormat
        case filters
        case preferences
        case startTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportDataFormatContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ExportDataFormat?].self, forKey: .exportDataFormat)
        var exportDataFormatDecoded0:[ApplicationDiscoveryClientTypes.ExportDataFormat]? = nil
        if let exportDataFormatContainer = exportDataFormatContainer {
            exportDataFormatDecoded0 = [ApplicationDiscoveryClientTypes.ExportDataFormat]()
            for enum0 in exportDataFormatContainer {
                if let enum0 = enum0 {
                    exportDataFormatDecoded0?.append(enum0)
                }
            }
        }
        exportDataFormat = exportDataFormatDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ExportFilter?].self, forKey: .filters)
        var filtersDecoded0:[ApplicationDiscoveryClientTypes.ExportFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ApplicationDiscoveryClientTypes.ExportFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let preferencesDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ExportPreferences.self, forKey: .preferences)
        preferences = preferencesDecoded
    }
}

extension StartExportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartExportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.exportId = output.exportId
        } else {
            self.exportId = nil
        }
    }
}

public struct StartExportTaskOutput: Swift.Equatable {
    /// A unique identifier used to query the status of an export request.
    public var exportId: Swift.String?

    public init(
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct StartExportTaskOutputBody: Swift.Equatable {
    let exportId: Swift.String?
}

extension StartExportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
    }
}

enum StartExportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartImportTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case importUrl
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let importUrl = self.importUrl {
            try encodeContainer.encode(importUrl, forKey: .importUrl)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StartImportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartImportTaskInput: Swift.Equatable {
    /// Optional. A unique token that you can provide to prevent the same import request from occurring more than once. If you don't provide a token, a token is automatically generated. Sending more than one StartImportTask request with the same client request token will return information about the original import task with that client request token.
    public var clientRequestToken: Swift.String?
    /// The URL for your import file that you've uploaded to Amazon S3. If you're using the Amazon Web Services CLI, this URL is structured as follows: s3://BucketName/ImportFileName.CSV
    /// This member is required.
    public var importUrl: Swift.String?
    /// A descriptive name for this request. You can use this name to filter future requests related to this import task, such as identifying applications and servers that were included in this import task. We recommend that you use a meaningful name for each import task.
    /// This member is required.
    public var name: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        importUrl: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.importUrl = importUrl
        self.name = name
    }
}

struct StartImportTaskInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let name: Swift.String?
    let importUrl: Swift.String?
}

extension StartImportTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case importUrl
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let importUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importUrl)
        importUrl = importUrlDecoded
    }
}

extension StartImportTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartImportTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.task = output.task
        } else {
            self.task = nil
        }
    }
}

public struct StartImportTaskOutput: Swift.Equatable {
    /// An array of information related to the import task request including status information, times, IDs, the Amazon S3 Object URL for the import file, and more.
    public var task: ApplicationDiscoveryClientTypes.ImportTask?

    public init(
        task: ApplicationDiscoveryClientTypes.ImportTask? = nil
    )
    {
        self.task = task
    }
}

struct StartImportTaskOutputBody: Swift.Equatable {
    let task: ApplicationDiscoveryClientTypes.ImportTask?
}

extension StartImportTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case task
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ImportTask.self, forKey: .task)
        task = taskDecoded
    }
}

enum StartImportTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopContinuousExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportId = self.exportId {
            try encodeContainer.encode(exportId, forKey: .exportId)
        }
    }
}

extension StopContinuousExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopContinuousExportInput: Swift.Equatable {
    /// The unique ID assigned to this export.
    /// This member is required.
    public var exportId: Swift.String?

    public init(
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct StopContinuousExportInputBody: Swift.Equatable {
    let exportId: Swift.String?
}

extension StopContinuousExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
    }
}

extension StopContinuousExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopContinuousExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.startTime = output.startTime
            self.stopTime = output.stopTime
        } else {
            self.startTime = nil
            self.stopTime = nil
        }
    }
}

public struct StopContinuousExportOutput: Swift.Equatable {
    /// Timestamp that represents when this continuous export started collecting data.
    public var startTime: ClientRuntime.Date?
    /// Timestamp that represents when this continuous export was stopped.
    public var stopTime: ClientRuntime.Date?

    public init(
        startTime: ClientRuntime.Date? = nil,
        stopTime: ClientRuntime.Date? = nil
    )
    {
        self.startTime = startTime
        self.stopTime = stopTime
    }
}

struct StopContinuousExportOutputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let stopTime: ClientRuntime.Date?
}

extension StopContinuousExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startTime
        case stopTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

enum StopContinuousExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermittedException": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopDataCollectionByAgentIdsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentIds = agentIds {
            var agentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentIds)
            for agentid0 in agentIds {
                try agentIdsContainer.encode(agentid0)
            }
        }
    }
}

extension StopDataCollectionByAgentIdsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopDataCollectionByAgentIdsInput: Swift.Equatable {
    /// The IDs of the agents from which to stop collecting data.
    /// This member is required.
    public var agentIds: [Swift.String]?

    public init(
        agentIds: [Swift.String]? = nil
    )
    {
        self.agentIds = agentIds
    }
}

struct StopDataCollectionByAgentIdsInputBody: Swift.Equatable {
    let agentIds: [Swift.String]?
}

extension StopDataCollectionByAgentIdsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .agentIds)
        var agentIdsDecoded0:[Swift.String]? = nil
        if let agentIdsContainer = agentIdsContainer {
            agentIdsDecoded0 = [Swift.String]()
            for string0 in agentIdsContainer {
                if let string0 = string0 {
                    agentIdsDecoded0?.append(string0)
                }
            }
        }
        agentIds = agentIdsDecoded0
    }
}

extension StopDataCollectionByAgentIdsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopDataCollectionByAgentIdsOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentsConfigurationStatus = output.agentsConfigurationStatus
        } else {
            self.agentsConfigurationStatus = nil
        }
    }
}

public struct StopDataCollectionByAgentIdsOutput: Swift.Equatable {
    /// Information about the agents that were instructed to stop collecting data. Information includes the agent ID, a description of the operation performed, and whether the agent configuration was updated.
    public var agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]?

    public init(
        agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]? = nil
    )
    {
        self.agentsConfigurationStatus = agentsConfigurationStatus
    }
}

struct StopDataCollectionByAgentIdsOutputBody: Swift.Equatable {
    let agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]?
}

extension StopDataCollectionByAgentIdsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentsConfigurationStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentsConfigurationStatusContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.AgentConfigurationStatus?].self, forKey: .agentsConfigurationStatus)
        var agentsConfigurationStatusDecoded0:[ApplicationDiscoveryClientTypes.AgentConfigurationStatus]? = nil
        if let agentsConfigurationStatusContainer = agentsConfigurationStatusContainer {
            agentsConfigurationStatusDecoded0 = [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]()
            for structure0 in agentsConfigurationStatusContainer {
                if let structure0 = structure0 {
                    agentsConfigurationStatusDecoded0?.append(structure0)
                }
            }
        }
        agentsConfigurationStatus = agentsConfigurationStatusDecoded0
    }
}

enum StopDataCollectionByAgentIdsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationDiscoveryClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Metadata that help you categorize IT assets. Do not store sensitive information (like personal data) in tags.
    public struct Tag: Swift.Equatable {
        /// The type of tag on which to filter.
        /// This member is required.
        public var key: Swift.String?
        /// A value for a tag key on which to filter.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ApplicationDiscoveryClientTypes.TagFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ApplicationDiscoveryClientTypes {
    /// The tag filter. Valid names are: tagKey, tagValue, configurationId.
    public struct TagFilter: Swift.Equatable {
        /// A name of the tag filter.
        /// This member is required.
        public var name: Swift.String?
        /// Values for the tag filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum Tenancy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dedicated
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [Tenancy] {
            return [
                .dedicated,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "DEDICATED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Tenancy(rawValue: rawValue) ?? Tenancy.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationDiscoveryClientTypes {
    public enum TermLength: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneYear
        case threeYear
        case sdkUnknown(Swift.String)

        public static var allCases: [TermLength] {
            return [
                .oneYear,
                .threeYear,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneYear: return "ONE_YEAR"
            case .threeYear: return "THREE_YEAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TermLength(rawValue: rawValue) ?? TermLength.sdkUnknown(rawValue)
        }
    }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = self.configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// Configuration ID of the application to be updated.
    /// This member is required.
    public var configurationId: Swift.String?
    /// New description of the application to be updated.
    public var description: Swift.String?
    /// New name of the application to be updated.
    public var name: Swift.String?

    public init(
        configurationId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.description = description
        self.name = name
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let configurationId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateApplicationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AuthorizationErrorException": return try await AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterValueException": return try await InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerInternalErrorException": return try await ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationDiscoveryClientTypes.UsageMetricBasis: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case percentageAdjust
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let percentageAdjust = self.percentageAdjust {
            try encodeContainer.encode(percentageAdjust, forKey: .percentageAdjust)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let percentageAdjustDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentageAdjust)
        percentageAdjust = percentageAdjustDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Specifies the performance metrics to use for the server that is used for recommendations.
    public struct UsageMetricBasis: Swift.Equatable {
        /// A utilization metric that is used by the recommendations.
        public var name: Swift.String?
        /// Specifies the percentage of the specified utilization metric that is used by the recommendations.
        public var percentageAdjust: Swift.Double?

        public init(
            name: Swift.String? = nil,
            percentageAdjust: Swift.Double? = nil
        )
        {
            self.name = name
            self.percentageAdjust = percentageAdjust
        }
    }

}
