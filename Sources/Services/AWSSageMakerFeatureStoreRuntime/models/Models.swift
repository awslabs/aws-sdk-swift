// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessForbidden {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessForbiddenBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have permission to perform an action.
public struct AccessForbidden: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessForbiddenBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessForbiddenBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case featureGroupName = "FeatureGroupName"
        case recordIdentifierValueAsString = "RecordIdentifierValueAsString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let featureGroupName = self.featureGroupName {
            try encodeContainer.encode(featureGroupName, forKey: .featureGroupName)
        }
        if let recordIdentifierValueAsString = self.recordIdentifierValueAsString {
            try encodeContainer.encode(recordIdentifierValueAsString, forKey: .recordIdentifierValueAsString)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureGroupName)
        featureGroupName = featureGroupNameDecoded
        let recordIdentifierValueAsStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordIdentifierValueAsString)
        recordIdentifierValueAsString = recordIdentifierValueAsStringDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// The error that has occurred when attempting to retrieve a batch of Records.
    public struct BatchGetRecordError: Swift.Equatable {
        /// The error code of an error that has occured when attempting to retrieve a batch of Records. For more information on errors, see [Errors](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_feature_store_GetRecord.html#API_feature_store_GetRecord_Errors).
        /// This member is required.
        public var errorCode: Swift.String?
        /// The error message of an error that has occured when attempting to retrieve a record in the batch.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The name of the feature group that the record belongs to.
        /// This member is required.
        public var featureGroupName: Swift.String?
        /// The value for the RecordIdentifier in string format of a Record from a FeatureGroup that is causing an error when attempting to be retrieved.
        /// This member is required.
        public var recordIdentifierValueAsString: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            featureGroupName: Swift.String? = nil,
            recordIdentifierValueAsString: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.featureGroupName = featureGroupName
            self.recordIdentifierValueAsString = recordIdentifierValueAsString
        }
    }

}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureGroupName = "FeatureGroupName"
        case featureNames = "FeatureNames"
        case recordIdentifiersValueAsString = "RecordIdentifiersValueAsString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureGroupName = self.featureGroupName {
            try encodeContainer.encode(featureGroupName, forKey: .featureGroupName)
        }
        if let featureNames = featureNames {
            var featureNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featureNames)
            for featurename0 in featureNames {
                try featureNamesContainer.encode(featurename0)
            }
        }
        if let recordIdentifiersValueAsString = recordIdentifiersValueAsString {
            var recordIdentifiersValueAsStringContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordIdentifiersValueAsString)
            for valueasstring0 in recordIdentifiersValueAsString {
                try recordIdentifiersValueAsStringContainer.encode(valueasstring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureGroupName)
        featureGroupName = featureGroupNameDecoded
        let recordIdentifiersValueAsStringContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recordIdentifiersValueAsString)
        var recordIdentifiersValueAsStringDecoded0:[Swift.String]? = nil
        if let recordIdentifiersValueAsStringContainer = recordIdentifiersValueAsStringContainer {
            recordIdentifiersValueAsStringDecoded0 = [Swift.String]()
            for string0 in recordIdentifiersValueAsStringContainer {
                if let string0 = string0 {
                    recordIdentifiersValueAsStringDecoded0?.append(string0)
                }
            }
        }
        recordIdentifiersValueAsString = recordIdentifiersValueAsStringDecoded0
        let featureNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .featureNames)
        var featureNamesDecoded0:[Swift.String]? = nil
        if let featureNamesContainer = featureNamesContainer {
            featureNamesDecoded0 = [Swift.String]()
            for string0 in featureNamesContainer {
                if let string0 = string0 {
                    featureNamesDecoded0?.append(string0)
                }
            }
        }
        featureNames = featureNamesDecoded0
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// The identifier that identifies the batch of Records you are retrieving in a batch.
    public struct BatchGetRecordIdentifier: Swift.Equatable {
        /// A FeatureGroupName containing Records you are retrieving in a batch.
        /// This member is required.
        public var featureGroupName: Swift.String?
        /// List of names of Features to be retrieved. If not specified, the latest value for all the Features are returned.
        public var featureNames: [Swift.String]?
        /// The value for a list of record identifiers in string format.
        /// This member is required.
        public var recordIdentifiersValueAsString: [Swift.String]?

        public init (
            featureGroupName: Swift.String? = nil,
            featureNames: [Swift.String]? = nil,
            recordIdentifiersValueAsString: [Swift.String]? = nil
        )
        {
            self.featureGroupName = featureGroupName
            self.featureNames = featureNames
            self.recordIdentifiersValueAsString = recordIdentifiersValueAsString
        }
    }

}

extension BatchGetRecordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifiers = "Identifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifiers = identifiers {
            var identifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identifiers)
            for batchgetrecordidentifier0 in identifiers {
                try identifiersContainer.encode(batchgetrecordidentifier0)
            }
        }
    }
}

extension BatchGetRecordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BatchGetRecord"
    }
}

public struct BatchGetRecordInput: Swift.Equatable {
    /// A list of FeatureGroup names, with their corresponding RecordIdentifier value, and Feature name that have been requested to be retrieved in batch.
    /// This member is required.
    public var identifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?

    public init (
        identifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
    )
    {
        self.identifiers = identifiers
    }
}

struct BatchGetRecordInputBody: Swift.Equatable {
    let identifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?
}

extension BatchGetRecordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifiers = "Identifiers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifiersContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier?].self, forKey: .identifiers)
        var identifiersDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
        if let identifiersContainer = identifiersContainer {
            identifiersDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]()
            for structure0 in identifiersContainer {
                if let structure0 = structure0 {
                    identifiersDecoded0?.append(structure0)
                }
            }
        }
        identifiers = identifiersDecoded0
    }
}

extension BatchGetRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetRecordOutputError: Swift.Error, Swift.Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetRecordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.records = output.records
            self.unprocessedIdentifiers = output.unprocessedIdentifiers
        } else {
            self.errors = nil
            self.records = nil
            self.unprocessedIdentifiers = nil
        }
    }
}

public struct BatchGetRecordOutputResponse: Swift.Equatable {
    /// A list of errors that have occurred when retrieving a batch of Records.
    /// This member is required.
    public var errors: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]?
    /// A list of Records you requested to be retrieved in batch.
    /// This member is required.
    public var records: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]?
    /// A unprocessed list of FeatureGroup names, with their corresponding RecordIdentifier value, and Feature name.
    /// This member is required.
    public var unprocessedIdentifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?

    public init (
        errors: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]? = nil,
        records: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]? = nil,
        unprocessedIdentifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
    )
    {
        self.errors = errors
        self.records = records
        self.unprocessedIdentifiers = unprocessedIdentifiers
    }
}

struct BatchGetRecordOutputResponseBody: Swift.Equatable {
    let records: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]?
    let errors: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]?
    let unprocessedIdentifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?
}

extension BatchGetRecordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
        case records = "Records"
        case unprocessedIdentifiers = "UnprocessedIdentifiers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail?].self, forKey: .records)
        var recordsDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError?].self, forKey: .errors)
        var errorsDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let unprocessedIdentifiersContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier?].self, forKey: .unprocessedIdentifiers)
        var unprocessedIdentifiersDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
        if let unprocessedIdentifiersContainer = unprocessedIdentifiersContainer {
            unprocessedIdentifiersDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]()
            for structure0 in unprocessedIdentifiersContainer {
                if let structure0 = structure0 {
                    unprocessedIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        unprocessedIdentifiers = unprocessedIdentifiersDecoded0
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureGroupName = "FeatureGroupName"
        case record = "Record"
        case recordIdentifierValueAsString = "RecordIdentifierValueAsString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureGroupName = self.featureGroupName {
            try encodeContainer.encode(featureGroupName, forKey: .featureGroupName)
        }
        if let record = record {
            var recordContainer = encodeContainer.nestedUnkeyedContainer(forKey: .record)
            for featurevalue0 in record {
                try recordContainer.encode(featurevalue0)
            }
        }
        if let recordIdentifierValueAsString = self.recordIdentifierValueAsString {
            try encodeContainer.encode(recordIdentifierValueAsString, forKey: .recordIdentifierValueAsString)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureGroupName)
        featureGroupName = featureGroupNameDecoded
        let recordIdentifierValueAsStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordIdentifierValueAsString)
        recordIdentifierValueAsString = recordIdentifierValueAsStringDecoded
        let recordContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.FeatureValue?].self, forKey: .record)
        var recordDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]()
            for structure0 in recordContainer {
                if let structure0 = structure0 {
                    recordDecoded0?.append(structure0)
                }
            }
        }
        record = recordDecoded0
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// The output of Records that have been retrieved in a batch.
    public struct BatchGetRecordResultDetail: Swift.Equatable {
        /// The FeatureGroupName containing Records you retrieved in a batch.
        /// This member is required.
        public var featureGroupName: Swift.String?
        /// The Record retrieved.
        /// This member is required.
        public var record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
        /// The value of the record identifer in string format.
        /// This member is required.
        public var recordIdentifierValueAsString: Swift.String?

        public init (
            featureGroupName: Swift.String? = nil,
            record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil,
            recordIdentifierValueAsString: Swift.String? = nil
        )
        {
            self.featureGroupName = featureGroupName
            self.record = record
            self.recordIdentifierValueAsString = recordIdentifierValueAsString
        }
    }

}

extension DeleteRecordInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let recordIdentifierValueAsString = recordIdentifierValueAsString else {
                let message = "Creating a URL Query Item failed. recordIdentifierValueAsString is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let recordIdentifierValueAsStringQueryItem = ClientRuntime.URLQueryItem(name: "RecordIdentifierValueAsString".urlPercentEncoding(), value: Swift.String(recordIdentifierValueAsString).urlPercentEncoding())
            items.append(recordIdentifierValueAsStringQueryItem)
            if let targetStores = targetStores {
                targetStores.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "TargetStores".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            guard let eventTime = eventTime else {
                let message = "Creating a URL Query Item failed. eventTime is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let eventTimeQueryItem = ClientRuntime.URLQueryItem(name: "EventTime".urlPercentEncoding(), value: Swift.String(eventTime).urlPercentEncoding())
            items.append(eventTimeQueryItem)
            return items
        }
    }
}

extension DeleteRecordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let featureGroupName = featureGroupName else {
            return nil
        }
        return "/FeatureGroup/\(featureGroupName.urlPercentEncoding())"
    }
}

public struct DeleteRecordInput: Swift.Equatable {
    /// Timestamp indicating when the deletion event occurred. EventTime can be used to query data at a certain point in time.
    /// This member is required.
    public var eventTime: Swift.String?
    /// The name of the feature group to delete the record from.
    /// This member is required.
    public var featureGroupName: Swift.String?
    /// The value for the RecordIdentifier that uniquely identifies the record, in string format.
    /// This member is required.
    public var recordIdentifierValueAsString: Swift.String?
    /// A list of stores from which you're deleting the record. By default, Feature Store deletes the record from all of the stores that you're using for the FeatureGroup.
    public var targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]?

    public init (
        eventTime: Swift.String? = nil,
        featureGroupName: Swift.String? = nil,
        recordIdentifierValueAsString: Swift.String? = nil,
        targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]? = nil
    )
    {
        self.eventTime = eventTime
        self.featureGroupName = featureGroupName
        self.recordIdentifierValueAsString = recordIdentifierValueAsString
        self.targetStores = targetStores
    }
}

struct DeleteRecordInputBody: Swift.Equatable {
}

extension DeleteRecordInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRecordOutputError: Swift.Error, Swift.Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecordOutputResponse: Swift.Equatable {

    public init () { }
}

extension SageMakerFeatureStoreRuntimeClientTypes.FeatureValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureName = "FeatureName"
        case valueAsString = "ValueAsString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureName = self.featureName {
            try encodeContainer.encode(featureName, forKey: .featureName)
        }
        if let valueAsString = self.valueAsString {
            try encodeContainer.encode(valueAsString, forKey: .valueAsString)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
        let valueAsStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueAsString)
        valueAsString = valueAsStringDecoded
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// The value associated with a feature.
    public struct FeatureValue: Swift.Equatable {
        /// The name of a feature that a feature value corresponds to.
        /// This member is required.
        public var featureName: Swift.String?
        /// The value associated with a feature, in string format. Note that features types can be String, Integral, or Fractional. This value represents all three types as a string.
        /// This member is required.
        public var valueAsString: Swift.String?

        public init (
            featureName: Swift.String? = nil,
            valueAsString: Swift.String? = nil
        )
        {
            self.featureName = featureName
            self.valueAsString = valueAsString
        }
    }

}

extension GetRecordInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let recordIdentifierValueAsString = recordIdentifierValueAsString else {
                let message = "Creating a URL Query Item failed. recordIdentifierValueAsString is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let recordIdentifierValueAsStringQueryItem = ClientRuntime.URLQueryItem(name: "RecordIdentifierValueAsString".urlPercentEncoding(), value: Swift.String(recordIdentifierValueAsString).urlPercentEncoding())
            items.append(recordIdentifierValueAsStringQueryItem)
            if let featureNames = featureNames {
                featureNames.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "FeatureName".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetRecordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let featureGroupName = featureGroupName else {
            return nil
        }
        return "/FeatureGroup/\(featureGroupName.urlPercentEncoding())"
    }
}

public struct GetRecordInput: Swift.Equatable {
    /// The name of the feature group from which you want to retrieve a record.
    /// This member is required.
    public var featureGroupName: Swift.String?
    /// List of names of Features to be retrieved. If not specified, the latest value for all the Features are returned.
    public var featureNames: [Swift.String]?
    /// The value that corresponds to RecordIdentifier type and uniquely identifies the record in the FeatureGroup.
    /// This member is required.
    public var recordIdentifierValueAsString: Swift.String?

    public init (
        featureGroupName: Swift.String? = nil,
        featureNames: [Swift.String]? = nil,
        recordIdentifierValueAsString: Swift.String? = nil
    )
    {
        self.featureGroupName = featureGroupName
        self.featureNames = featureNames
        self.recordIdentifierValueAsString = recordIdentifierValueAsString
    }
}

struct GetRecordInputBody: Swift.Equatable {
}

extension GetRecordInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRecordOutputError: Swift.Error, Swift.Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case resourceNotFound(ResourceNotFound)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRecordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.record = output.record
        } else {
            self.record = nil
        }
    }
}

public struct GetRecordOutputResponse: Swift.Equatable {
    /// The record you requested. A list of FeatureValues.
    public var record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?

    public init (
        record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
    )
    {
        self.record = record
    }
}

struct GetRecordOutputResponseBody: Swift.Equatable {
    let record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
}

extension GetRecordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record = "Record"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.FeatureValue?].self, forKey: .record)
        var recordDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]()
            for structure0 in recordContainer {
                if let structure0 = structure0 {
                    recordDecoded0?.append(structure0)
                }
            }
        }
        record = recordDecoded0
    }
}

extension InternalFailure {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalFailureBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal failure occurred. Try your request again. If the problem persists, contact Amazon Web Services customer support.
public struct InternalFailure: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutRecordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record = "Record"
        case targetStores = "TargetStores"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let record = record {
            var recordContainer = encodeContainer.nestedUnkeyedContainer(forKey: .record)
            for featurevalue0 in record {
                try recordContainer.encode(featurevalue0)
            }
        }
        if let targetStores = targetStores {
            var targetStoresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetStores)
            for targetstore0 in targetStores {
                try targetStoresContainer.encode(targetstore0.rawValue)
            }
        }
    }
}

extension PutRecordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let featureGroupName = featureGroupName else {
            return nil
        }
        return "/FeatureGroup/\(featureGroupName.urlPercentEncoding())"
    }
}

public struct PutRecordInput: Swift.Equatable {
    /// The name of the feature group that you want to insert the record into.
    /// This member is required.
    public var featureGroupName: Swift.String?
    /// List of FeatureValues to be inserted. This will be a full over-write. If you only want to update few of the feature values, do the following:
    ///
    /// * Use GetRecord to retrieve the latest record.
    ///
    /// * Update the record returned from GetRecord.
    ///
    /// * Use PutRecord to update feature values.
    /// This member is required.
    public var record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
    /// A list of stores to which you're adding the record. By default, Feature Store adds the record to all of the stores that you're using for the FeatureGroup.
    public var targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]?

    public init (
        featureGroupName: Swift.String? = nil,
        record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil,
        targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]? = nil
    )
    {
        self.featureGroupName = featureGroupName
        self.record = record
        self.targetStores = targetStores
    }
}

struct PutRecordInputBody: Swift.Equatable {
    let record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
    let targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]?
}

extension PutRecordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record = "Record"
        case targetStores = "TargetStores"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.FeatureValue?].self, forKey: .record)
        var recordDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]()
            for structure0 in recordContainer {
                if let structure0 = structure0 {
                    recordDecoded0?.append(structure0)
                }
            }
        }
        record = recordDecoded0
        let targetStoresContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.TargetStore?].self, forKey: .targetStores)
        var targetStoresDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.TargetStore]? = nil
        if let targetStoresContainer = targetStoresContainer {
            targetStoresDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]()
            for enum0 in targetStoresContainer {
                if let enum0 = enum0 {
                    targetStoresDecoded0?.append(enum0)
                }
            }
        }
        targetStores = targetStoresDecoded0
    }
}

extension PutRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutRecordOutputError: Swift.Error, Swift.Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutRecordOutputResponse: Swift.Equatable {

    public init () { }
}

extension ResourceNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource that is required to perform an action was not found.
public struct ResourceNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailable {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailable: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    public enum TargetStore: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case offlineStore
        case onlineStore
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetStore] {
            return [
                .offlineStore,
                .onlineStore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .offlineStore: return "OfflineStore"
            case .onlineStore: return "OnlineStore"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetStore(rawValue: rawValue) ?? TargetStore.sdkUnknown(rawValue)
        }
    }
}

extension ValidationError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an error validating your request.
public struct ValidationError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
