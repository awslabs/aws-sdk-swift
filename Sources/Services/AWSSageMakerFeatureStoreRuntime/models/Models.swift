// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessForbidden {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessForbiddenBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have permission to perform an action.
public struct AccessForbidden: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessForbidden" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessForbiddenBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessForbiddenBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case featureGroupName = "FeatureGroupName"
        case recordIdentifierValueAsString = "RecordIdentifierValueAsString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let featureGroupName = self.featureGroupName {
            try encodeContainer.encode(featureGroupName, forKey: .featureGroupName)
        }
        if let recordIdentifierValueAsString = self.recordIdentifierValueAsString {
            try encodeContainer.encode(recordIdentifierValueAsString, forKey: .recordIdentifierValueAsString)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureGroupName)
        featureGroupName = featureGroupNameDecoded
        let recordIdentifierValueAsStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordIdentifierValueAsString)
        recordIdentifierValueAsString = recordIdentifierValueAsStringDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// The error that has occurred when attempting to retrieve a batch of Records.
    public struct BatchGetRecordError: Swift.Equatable {
        /// The error code of an error that has occurred when attempting to retrieve a batch of Records. For more information on errors, see [Errors](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_feature_store_GetRecord.html#API_feature_store_GetRecord_Errors).
        /// This member is required.
        public var errorCode: Swift.String?
        /// The error message of an error that has occurred when attempting to retrieve a record in the batch.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The name of the feature group that the record belongs to.
        /// This member is required.
        public var featureGroupName: Swift.String?
        /// The value for the RecordIdentifier in string format of a Record from a FeatureGroup that is causing an error when attempting to be retrieved.
        /// This member is required.
        public var recordIdentifierValueAsString: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            featureGroupName: Swift.String? = nil,
            recordIdentifierValueAsString: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.featureGroupName = featureGroupName
            self.recordIdentifierValueAsString = recordIdentifierValueAsString
        }
    }

}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureGroupName = "FeatureGroupName"
        case featureNames = "FeatureNames"
        case recordIdentifiersValueAsString = "RecordIdentifiersValueAsString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureGroupName = self.featureGroupName {
            try encodeContainer.encode(featureGroupName, forKey: .featureGroupName)
        }
        if let featureNames = featureNames {
            var featureNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featureNames)
            for featurename0 in featureNames {
                try featureNamesContainer.encode(featurename0)
            }
        }
        if let recordIdentifiersValueAsString = recordIdentifiersValueAsString {
            var recordIdentifiersValueAsStringContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordIdentifiersValueAsString)
            for valueasstring0 in recordIdentifiersValueAsString {
                try recordIdentifiersValueAsStringContainer.encode(valueasstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureGroupName)
        featureGroupName = featureGroupNameDecoded
        let recordIdentifiersValueAsStringContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recordIdentifiersValueAsString)
        var recordIdentifiersValueAsStringDecoded0:[Swift.String]? = nil
        if let recordIdentifiersValueAsStringContainer = recordIdentifiersValueAsStringContainer {
            recordIdentifiersValueAsStringDecoded0 = [Swift.String]()
            for string0 in recordIdentifiersValueAsStringContainer {
                if let string0 = string0 {
                    recordIdentifiersValueAsStringDecoded0?.append(string0)
                }
            }
        }
        recordIdentifiersValueAsString = recordIdentifiersValueAsStringDecoded0
        let featureNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .featureNames)
        var featureNamesDecoded0:[Swift.String]? = nil
        if let featureNamesContainer = featureNamesContainer {
            featureNamesDecoded0 = [Swift.String]()
            for string0 in featureNamesContainer {
                if let string0 = string0 {
                    featureNamesDecoded0?.append(string0)
                }
            }
        }
        featureNames = featureNamesDecoded0
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// The identifier that identifies the batch of Records you are retrieving in a batch.
    public struct BatchGetRecordIdentifier: Swift.Equatable {
        /// The name or Amazon Resource Name (ARN) of the FeatureGroup containing the records you are retrieving in a batch.
        /// This member is required.
        public var featureGroupName: Swift.String?
        /// List of names of Features to be retrieved. If not specified, the latest value for all the Features are returned.
        public var featureNames: [Swift.String]?
        /// The value for a list of record identifiers in string format.
        /// This member is required.
        public var recordIdentifiersValueAsString: [Swift.String]?

        public init(
            featureGroupName: Swift.String? = nil,
            featureNames: [Swift.String]? = nil,
            recordIdentifiersValueAsString: [Swift.String]? = nil
        )
        {
            self.featureGroupName = featureGroupName
            self.featureNames = featureNames
            self.recordIdentifiersValueAsString = recordIdentifiersValueAsString
        }
    }

}

extension BatchGetRecordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationTimeResponse = "ExpirationTimeResponse"
        case identifiers = "Identifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expirationTimeResponse = self.expirationTimeResponse {
            try encodeContainer.encode(expirationTimeResponse.rawValue, forKey: .expirationTimeResponse)
        }
        if let identifiers = identifiers {
            var identifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identifiers)
            for batchgetrecordidentifier0 in identifiers {
                try identifiersContainer.encode(batchgetrecordidentifier0)
            }
        }
    }
}

extension BatchGetRecordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BatchGetRecord"
    }
}

public struct BatchGetRecordInput: Swift.Equatable {
    /// Parameter to request ExpiresAt in response. If Enabled, BatchGetRecord will return the value of ExpiresAt, if it is not null. If Disabled and null, BatchGetRecord will return null.
    public var expirationTimeResponse: SageMakerFeatureStoreRuntimeClientTypes.ExpirationTimeResponse?
    /// A list containing the name or Amazon Resource Name (ARN) of the FeatureGroup, the list of names of Features to be retrieved, and the corresponding RecordIdentifier values as strings.
    /// This member is required.
    public var identifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?

    public init(
        expirationTimeResponse: SageMakerFeatureStoreRuntimeClientTypes.ExpirationTimeResponse? = nil,
        identifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
    )
    {
        self.expirationTimeResponse = expirationTimeResponse
        self.identifiers = identifiers
    }
}

struct BatchGetRecordInputBody: Swift.Equatable {
    let identifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?
    let expirationTimeResponse: SageMakerFeatureStoreRuntimeClientTypes.ExpirationTimeResponse?
}

extension BatchGetRecordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationTimeResponse = "ExpirationTimeResponse"
        case identifiers = "Identifiers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifiersContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier?].self, forKey: .identifiers)
        var identifiersDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
        if let identifiersContainer = identifiersContainer {
            identifiersDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]()
            for structure0 in identifiersContainer {
                if let structure0 = structure0 {
                    identifiersDecoded0?.append(structure0)
                }
            }
        }
        identifiers = identifiersDecoded0
        let expirationTimeResponseDecoded = try containerValues.decodeIfPresent(SageMakerFeatureStoreRuntimeClientTypes.ExpirationTimeResponse.self, forKey: .expirationTimeResponse)
        expirationTimeResponse = expirationTimeResponseDecoded
    }
}

extension BatchGetRecordOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetRecordOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.records = output.records
            self.unprocessedIdentifiers = output.unprocessedIdentifiers
        } else {
            self.errors = nil
            self.records = nil
            self.unprocessedIdentifiers = nil
        }
    }
}

public struct BatchGetRecordOutput: Swift.Equatable {
    /// A list of errors that have occurred when retrieving a batch of Records.
    /// This member is required.
    public var errors: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]?
    /// A list of Records you requested to be retrieved in batch.
    /// This member is required.
    public var records: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]?
    /// A unprocessed list of FeatureGroup names, with their corresponding RecordIdentifier value, and Feature name.
    /// This member is required.
    public var unprocessedIdentifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?

    public init(
        errors: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]? = nil,
        records: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]? = nil,
        unprocessedIdentifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
    )
    {
        self.errors = errors
        self.records = records
        self.unprocessedIdentifiers = unprocessedIdentifiers
    }
}

struct BatchGetRecordOutputBody: Swift.Equatable {
    let records: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]?
    let errors: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]?
    let unprocessedIdentifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?
}

extension BatchGetRecordOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
        case records = "Records"
        case unprocessedIdentifiers = "UnprocessedIdentifiers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail?].self, forKey: .records)
        var recordsDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError?].self, forKey: .errors)
        var errorsDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let unprocessedIdentifiersContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier?].self, forKey: .unprocessedIdentifiers)
        var unprocessedIdentifiersDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
        if let unprocessedIdentifiersContainer = unprocessedIdentifiersContainer {
            unprocessedIdentifiersDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]()
            for structure0 in unprocessedIdentifiersContainer {
                if let structure0 = structure0 {
                    unprocessedIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        unprocessedIdentifiers = unprocessedIdentifiersDecoded0
    }
}

enum BatchGetRecordOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessForbidden": return try await AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailure": return try await InternalFailure(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationError": return try await ValidationError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresAt = "ExpiresAt"
        case featureGroupName = "FeatureGroupName"
        case record = "Record"
        case recordIdentifierValueAsString = "RecordIdentifierValueAsString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiresAt = self.expiresAt {
            try encodeContainer.encode(expiresAt, forKey: .expiresAt)
        }
        if let featureGroupName = self.featureGroupName {
            try encodeContainer.encode(featureGroupName, forKey: .featureGroupName)
        }
        if let record = record {
            var recordContainer = encodeContainer.nestedUnkeyedContainer(forKey: .record)
            for featurevalue0 in record {
                try recordContainer.encode(featurevalue0)
            }
        }
        if let recordIdentifierValueAsString = self.recordIdentifierValueAsString {
            try encodeContainer.encode(recordIdentifierValueAsString, forKey: .recordIdentifierValueAsString)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureGroupName)
        featureGroupName = featureGroupNameDecoded
        let recordIdentifierValueAsStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordIdentifierValueAsString)
        recordIdentifierValueAsString = recordIdentifierValueAsStringDecoded
        let recordContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.FeatureValue?].self, forKey: .record)
        var recordDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]()
            for structure0 in recordContainer {
                if let structure0 = structure0 {
                    recordDecoded0?.append(structure0)
                }
            }
        }
        record = recordDecoded0
        let expiresAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiresAt)
        expiresAt = expiresAtDecoded
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// The output of records that have been retrieved in a batch.
    public struct BatchGetRecordResultDetail: Swift.Equatable {
        /// The ExpiresAt ISO string of the requested record.
        public var expiresAt: Swift.String?
        /// The FeatureGroupName containing Records you retrieved in a batch.
        /// This member is required.
        public var featureGroupName: Swift.String?
        /// The Record retrieved.
        /// This member is required.
        public var record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
        /// The value of the record identifier in string format.
        /// This member is required.
        public var recordIdentifierValueAsString: Swift.String?

        public init(
            expiresAt: Swift.String? = nil,
            featureGroupName: Swift.String? = nil,
            record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil,
            recordIdentifierValueAsString: Swift.String? = nil
        )
        {
            self.expiresAt = expiresAt
            self.featureGroupName = featureGroupName
            self.record = record
            self.recordIdentifierValueAsString = recordIdentifierValueAsString
        }
    }

}

extension DeleteRecordInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let recordIdentifierValueAsString = recordIdentifierValueAsString else {
                let message = "Creating a URL Query Item failed. recordIdentifierValueAsString is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let recordIdentifierValueAsStringQueryItem = ClientRuntime.URLQueryItem(name: "RecordIdentifierValueAsString".urlPercentEncoding(), value: Swift.String(recordIdentifierValueAsString).urlPercentEncoding())
            items.append(recordIdentifierValueAsStringQueryItem)
            if let targetStores = targetStores {
                targetStores.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "TargetStores".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            guard let eventTime = eventTime else {
                let message = "Creating a URL Query Item failed. eventTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let eventTimeQueryItem = ClientRuntime.URLQueryItem(name: "EventTime".urlPercentEncoding(), value: Swift.String(eventTime).urlPercentEncoding())
            items.append(eventTimeQueryItem)
            if let deletionMode = deletionMode {
                let deletionModeQueryItem = ClientRuntime.URLQueryItem(name: "DeletionMode".urlPercentEncoding(), value: Swift.String(deletionMode.rawValue).urlPercentEncoding())
                items.append(deletionModeQueryItem)
            }
            return items
        }
    }
}

extension DeleteRecordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let featureGroupName = featureGroupName else {
            return nil
        }
        return "/FeatureGroup/\(featureGroupName.urlPercentEncoding())"
    }
}

public struct DeleteRecordInput: Swift.Equatable {
    /// The name of the deletion mode for deleting the record. By default, the deletion mode is set to SoftDelete.
    public var deletionMode: SageMakerFeatureStoreRuntimeClientTypes.DeletionMode?
    /// Timestamp indicating when the deletion event occurred. EventTime can be used to query data at a certain point in time.
    /// This member is required.
    public var eventTime: Swift.String?
    /// The name or Amazon Resource Name (ARN) of the feature group to delete the record from.
    /// This member is required.
    public var featureGroupName: Swift.String?
    /// The value for the RecordIdentifier that uniquely identifies the record, in string format.
    /// This member is required.
    public var recordIdentifierValueAsString: Swift.String?
    /// A list of stores from which you're deleting the record. By default, Feature Store deletes the record from all of the stores that you're using for the FeatureGroup.
    public var targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]?

    public init(
        deletionMode: SageMakerFeatureStoreRuntimeClientTypes.DeletionMode? = nil,
        eventTime: Swift.String? = nil,
        featureGroupName: Swift.String? = nil,
        recordIdentifierValueAsString: Swift.String? = nil,
        targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]? = nil
    )
    {
        self.deletionMode = deletionMode
        self.eventTime = eventTime
        self.featureGroupName = featureGroupName
        self.recordIdentifierValueAsString = recordIdentifierValueAsString
        self.targetStores = targetStores
    }
}

struct DeleteRecordInputBody: Swift.Equatable {
}

extension DeleteRecordInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRecordOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRecordOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRecordOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessForbidden": return try await AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailure": return try await InternalFailure(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationError": return try await ValidationError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    public enum DeletionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hardDelete
        case softDelete
        case sdkUnknown(Swift.String)

        public static var allCases: [DeletionMode] {
            return [
                .hardDelete,
                .softDelete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hardDelete: return "HardDelete"
            case .softDelete: return "SoftDelete"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeletionMode(rawValue: rawValue) ?? DeletionMode.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    public enum ExpirationTimeResponse: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpirationTimeResponse] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExpirationTimeResponse(rawValue: rawValue) ?? ExpirationTimeResponse.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.FeatureValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureName = "FeatureName"
        case valueAsString = "ValueAsString"
        case valueAsStringList = "ValueAsStringList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureName = self.featureName {
            try encodeContainer.encode(featureName, forKey: .featureName)
        }
        if let valueAsString = self.valueAsString {
            try encodeContainer.encode(valueAsString, forKey: .valueAsString)
        }
        if let valueAsStringList = valueAsStringList {
            var valueAsStringListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueAsStringList)
            for valueasstring0 in valueAsStringList {
                try valueAsStringListContainer.encode(valueasstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
        let valueAsStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueAsString)
        valueAsString = valueAsStringDecoded
        let valueAsStringListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueAsStringList)
        var valueAsStringListDecoded0:[Swift.String]? = nil
        if let valueAsStringListContainer = valueAsStringListContainer {
            valueAsStringListDecoded0 = [Swift.String]()
            for string0 in valueAsStringListContainer {
                if let string0 = string0 {
                    valueAsStringListDecoded0?.append(string0)
                }
            }
        }
        valueAsStringList = valueAsStringListDecoded0
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// The value associated with a feature.
    public struct FeatureValue: Swift.Equatable {
        /// The name of a feature that a feature value corresponds to.
        /// This member is required.
        public var featureName: Swift.String?
        /// The value in string format associated with a feature. Used when your CollectionType is None. Note that features types can be String, Integral, or Fractional. This value represents all three types as a string.
        public var valueAsString: Swift.String?
        /// The list of values in string format associated with a feature. Used when your CollectionType is a List, Set, or Vector. Note that features types can be String, Integral, or Fractional. These values represents all three types as a string.
        public var valueAsStringList: [Swift.String]?

        public init(
            featureName: Swift.String? = nil,
            valueAsString: Swift.String? = nil,
            valueAsStringList: [Swift.String]? = nil
        )
        {
            self.featureName = featureName
            self.valueAsString = valueAsString
            self.valueAsStringList = valueAsStringList
        }
    }

}

extension GetRecordInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let recordIdentifierValueAsString = recordIdentifierValueAsString else {
                let message = "Creating a URL Query Item failed. recordIdentifierValueAsString is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let recordIdentifierValueAsStringQueryItem = ClientRuntime.URLQueryItem(name: "RecordIdentifierValueAsString".urlPercentEncoding(), value: Swift.String(recordIdentifierValueAsString).urlPercentEncoding())
            items.append(recordIdentifierValueAsStringQueryItem)
            if let expirationTimeResponse = expirationTimeResponse {
                let expirationTimeResponseQueryItem = ClientRuntime.URLQueryItem(name: "ExpirationTimeResponse".urlPercentEncoding(), value: Swift.String(expirationTimeResponse.rawValue).urlPercentEncoding())
                items.append(expirationTimeResponseQueryItem)
            }
            if let featureNames = featureNames {
                featureNames.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "FeatureName".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetRecordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let featureGroupName = featureGroupName else {
            return nil
        }
        return "/FeatureGroup/\(featureGroupName.urlPercentEncoding())"
    }
}

public struct GetRecordInput: Swift.Equatable {
    /// Parameter to request ExpiresAt in response. If Enabled, GetRecord will return the value of ExpiresAt, if it is not null. If Disabled and null, GetRecord will return null.
    public var expirationTimeResponse: SageMakerFeatureStoreRuntimeClientTypes.ExpirationTimeResponse?
    /// The name or Amazon Resource Name (ARN) of the feature group from which you want to retrieve a record.
    /// This member is required.
    public var featureGroupName: Swift.String?
    /// List of names of Features to be retrieved. If not specified, the latest value for all the Features are returned.
    public var featureNames: [Swift.String]?
    /// The value that corresponds to RecordIdentifier type and uniquely identifies the record in the FeatureGroup.
    /// This member is required.
    public var recordIdentifierValueAsString: Swift.String?

    public init(
        expirationTimeResponse: SageMakerFeatureStoreRuntimeClientTypes.ExpirationTimeResponse? = nil,
        featureGroupName: Swift.String? = nil,
        featureNames: [Swift.String]? = nil,
        recordIdentifierValueAsString: Swift.String? = nil
    )
    {
        self.expirationTimeResponse = expirationTimeResponse
        self.featureGroupName = featureGroupName
        self.featureNames = featureNames
        self.recordIdentifierValueAsString = recordIdentifierValueAsString
    }
}

struct GetRecordInputBody: Swift.Equatable {
}

extension GetRecordInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRecordOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRecordOutputBody = try responseDecoder.decode(responseBody: data)
            self.expiresAt = output.expiresAt
            self.record = output.record
        } else {
            self.expiresAt = nil
            self.record = nil
        }
    }
}

public struct GetRecordOutput: Swift.Equatable {
    /// The ExpiresAt ISO string of the requested record.
    public var expiresAt: Swift.String?
    /// The record you requested. A list of FeatureValues.
    public var record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?

    public init(
        expiresAt: Swift.String? = nil,
        record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
    )
    {
        self.expiresAt = expiresAt
        self.record = record
    }
}

struct GetRecordOutputBody: Swift.Equatable {
    let record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
    let expiresAt: Swift.String?
}

extension GetRecordOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresAt = "ExpiresAt"
        case record = "Record"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.FeatureValue?].self, forKey: .record)
        var recordDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]()
            for structure0 in recordContainer {
                if let structure0 = structure0 {
                    recordDecoded0?.append(structure0)
                }
            }
        }
        record = recordDecoded0
        let expiresAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiresAt)
        expiresAt = expiresAtDecoded
    }
}

enum GetRecordOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessForbidden": return try await AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailure": return try await InternalFailure(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationError": return try await ValidationError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalFailure {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalFailureBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal failure occurred. Try your request again. If the problem persists, contact Amazon Web Services customer support.
public struct InternalFailure: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailure" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalFailureBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutRecordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record = "Record"
        case targetStores = "TargetStores"
        case ttlDuration = "TtlDuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let record = record {
            var recordContainer = encodeContainer.nestedUnkeyedContainer(forKey: .record)
            for featurevalue0 in record {
                try recordContainer.encode(featurevalue0)
            }
        }
        if let targetStores = targetStores {
            var targetStoresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetStores)
            for targetstore0 in targetStores {
                try targetStoresContainer.encode(targetstore0.rawValue)
            }
        }
        if let ttlDuration = self.ttlDuration {
            try encodeContainer.encode(ttlDuration, forKey: .ttlDuration)
        }
    }
}

extension PutRecordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let featureGroupName = featureGroupName else {
            return nil
        }
        return "/FeatureGroup/\(featureGroupName.urlPercentEncoding())"
    }
}

public struct PutRecordInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the feature group that you want to insert the record into.
    /// This member is required.
    public var featureGroupName: Swift.String?
    /// List of FeatureValues to be inserted. This will be a full over-write. If you only want to update few of the feature values, do the following:
    ///
    /// * Use GetRecord to retrieve the latest record.
    ///
    /// * Update the record returned from GetRecord.
    ///
    /// * Use PutRecord to update feature values.
    /// This member is required.
    public var record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
    /// A list of stores to which you're adding the record. By default, Feature Store adds the record to all of the stores that you're using for the FeatureGroup.
    public var targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]?
    /// Time to live duration, where the record is hard deleted after the expiration time is reached; ExpiresAt = EventTime + TtlDuration. For information on HardDelete, see the [DeleteRecord](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_feature_store_DeleteRecord.html) API in the Amazon SageMaker API Reference guide.
    public var ttlDuration: SageMakerFeatureStoreRuntimeClientTypes.TtlDuration?

    public init(
        featureGroupName: Swift.String? = nil,
        record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil,
        targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]? = nil,
        ttlDuration: SageMakerFeatureStoreRuntimeClientTypes.TtlDuration? = nil
    )
    {
        self.featureGroupName = featureGroupName
        self.record = record
        self.targetStores = targetStores
        self.ttlDuration = ttlDuration
    }
}

struct PutRecordInputBody: Swift.Equatable {
    let record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
    let targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]?
    let ttlDuration: SageMakerFeatureStoreRuntimeClientTypes.TtlDuration?
}

extension PutRecordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record = "Record"
        case targetStores = "TargetStores"
        case ttlDuration = "TtlDuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.FeatureValue?].self, forKey: .record)
        var recordDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]()
            for structure0 in recordContainer {
                if let structure0 = structure0 {
                    recordDecoded0?.append(structure0)
                }
            }
        }
        record = recordDecoded0
        let targetStoresContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.TargetStore?].self, forKey: .targetStores)
        var targetStoresDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.TargetStore]? = nil
        if let targetStoresContainer = targetStoresContainer {
            targetStoresDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]()
            for enum0 in targetStoresContainer {
                if let enum0 = enum0 {
                    targetStoresDecoded0?.append(enum0)
                }
            }
        }
        targetStores = targetStoresDecoded0
        let ttlDurationDecoded = try containerValues.decodeIfPresent(SageMakerFeatureStoreRuntimeClientTypes.TtlDuration.self, forKey: .ttlDuration)
        ttlDuration = ttlDurationDecoded
    }
}

extension PutRecordOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutRecordOutput: Swift.Equatable {

    public init() { }
}

enum PutRecordOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessForbidden": return try await AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailure": return try await InternalFailure(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailable": return try await ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationError": return try await ValidationError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFound {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource that is required to perform an action was not found.
public struct ResourceNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailable {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailable: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailable" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    public enum TargetStore: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case offlineStore
        case onlineStore
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetStore] {
            return [
                .offlineStore,
                .onlineStore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .offlineStore: return "OfflineStore"
            case .onlineStore: return "OnlineStore"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetStore(rawValue: rawValue) ?? TargetStore.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.TtlDuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unitDecoded = try containerValues.decodeIfPresent(SageMakerFeatureStoreRuntimeClientTypes.TtlDurationUnit.self, forKey: .unit)
        unit = unitDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value)
        value = valueDecoded
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// Time to live duration, where the record is hard deleted after the expiration time is reached; ExpiresAt = EventTime + TtlDuration. For information on HardDelete, see the [DeleteRecord](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_feature_store_DeleteRecord.html) API in the Amazon SageMaker API Reference guide.
    public struct TtlDuration: Swift.Equatable {
        /// TtlDuration time unit.
        /// This member is required.
        public var unit: SageMakerFeatureStoreRuntimeClientTypes.TtlDurationUnit?
        /// TtlDuration time value.
        /// This member is required.
        public var value: Swift.Int?

        public init(
            unit: SageMakerFeatureStoreRuntimeClientTypes.TtlDurationUnit? = nil,
            value: Swift.Int? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension SageMakerFeatureStoreRuntimeClientTypes {
    public enum TtlDurationUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case hours
        case minutes
        case seconds
        case weeks
        case sdkUnknown(Swift.String)

        public static var allCases: [TtlDurationUnit] {
            return [
                .days,
                .hours,
                .minutes,
                .seconds,
                .weeks,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "Days"
            case .hours: return "Hours"
            case .minutes: return "Minutes"
            case .seconds: return "Seconds"
            case .weeks: return "Weeks"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TtlDurationUnit(rawValue: rawValue) ?? TtlDurationUnit.sdkUnknown(rawValue)
        }
    }
}

extension ValidationError {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationErrorBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an error validating your request.
public struct ValidationError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationError" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
