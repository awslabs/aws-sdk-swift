// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension FSxClient {
    /// Paginate over `[DescribeBackupsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeBackupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeBackupsOutputResponse`
    public func describeBackupsPaginated(input: DescribeBackupsInput) -> ClientRuntime.PaginatorSequence<DescribeBackupsInput, DescribeBackupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeBackupsInput, DescribeBackupsOutputResponse>(input: input, inputKey: \DescribeBackupsInput.nextToken, outputKey: \DescribeBackupsOutputResponse.nextToken, paginationFunction: self.describeBackups(input:))
    }
}

extension DescribeBackupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeBackupsInput {
        return DescribeBackupsInput(
            backupIds: self.backupIds,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension FSxClient {
    /// Paginate over `[DescribeDataRepositoryAssociationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDataRepositoryAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDataRepositoryAssociationsOutputResponse`
    public func describeDataRepositoryAssociationsPaginated(input: DescribeDataRepositoryAssociationsInput) -> ClientRuntime.PaginatorSequence<DescribeDataRepositoryAssociationsInput, DescribeDataRepositoryAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDataRepositoryAssociationsInput, DescribeDataRepositoryAssociationsOutputResponse>(input: input, inputKey: \DescribeDataRepositoryAssociationsInput.nextToken, outputKey: \DescribeDataRepositoryAssociationsOutputResponse.nextToken, paginationFunction: self.describeDataRepositoryAssociations(input:))
    }
}

extension DescribeDataRepositoryAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDataRepositoryAssociationsInput {
        return DescribeDataRepositoryAssociationsInput(
            associationIds: self.associationIds,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension FSxClient {
    /// Paginate over `[DescribeDataRepositoryTasksOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDataRepositoryTasksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDataRepositoryTasksOutputResponse`
    public func describeDataRepositoryTasksPaginated(input: DescribeDataRepositoryTasksInput) -> ClientRuntime.PaginatorSequence<DescribeDataRepositoryTasksInput, DescribeDataRepositoryTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDataRepositoryTasksInput, DescribeDataRepositoryTasksOutputResponse>(input: input, inputKey: \DescribeDataRepositoryTasksInput.nextToken, outputKey: \DescribeDataRepositoryTasksOutputResponse.nextToken, paginationFunction: self.describeDataRepositoryTasks(input:))
    }
}

extension DescribeDataRepositoryTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDataRepositoryTasksInput {
        return DescribeDataRepositoryTasksInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            taskIds: self.taskIds
        )}
}
extension FSxClient {
    /// Paginate over `[DescribeFileCachesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFileCachesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFileCachesOutputResponse`
    public func describeFileCachesPaginated(input: DescribeFileCachesInput) -> ClientRuntime.PaginatorSequence<DescribeFileCachesInput, DescribeFileCachesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFileCachesInput, DescribeFileCachesOutputResponse>(input: input, inputKey: \DescribeFileCachesInput.nextToken, outputKey: \DescribeFileCachesOutputResponse.nextToken, paginationFunction: self.describeFileCaches(input:))
    }
}

extension DescribeFileCachesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFileCachesInput {
        return DescribeFileCachesInput(
            fileCacheIds: self.fileCacheIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension FSxClient {
    /// Paginate over `[DescribeFileSystemAliasesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFileSystemAliasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFileSystemAliasesOutputResponse`
    public func describeFileSystemAliasesPaginated(input: DescribeFileSystemAliasesInput) -> ClientRuntime.PaginatorSequence<DescribeFileSystemAliasesInput, DescribeFileSystemAliasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFileSystemAliasesInput, DescribeFileSystemAliasesOutputResponse>(input: input, inputKey: \DescribeFileSystemAliasesInput.nextToken, outputKey: \DescribeFileSystemAliasesOutputResponse.nextToken, paginationFunction: self.describeFileSystemAliases(input:))
    }
}

extension DescribeFileSystemAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFileSystemAliasesInput {
        return DescribeFileSystemAliasesInput(
            clientRequestToken: self.clientRequestToken,
            fileSystemId: self.fileSystemId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension FSxClient {
    /// Paginate over `[DescribeFileSystemsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFileSystemsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFileSystemsOutputResponse`
    public func describeFileSystemsPaginated(input: DescribeFileSystemsInput) -> ClientRuntime.PaginatorSequence<DescribeFileSystemsInput, DescribeFileSystemsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFileSystemsInput, DescribeFileSystemsOutputResponse>(input: input, inputKey: \DescribeFileSystemsInput.nextToken, outputKey: \DescribeFileSystemsOutputResponse.nextToken, paginationFunction: self.describeFileSystems(input:))
    }
}

extension DescribeFileSystemsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFileSystemsInput {
        return DescribeFileSystemsInput(
            fileSystemIds: self.fileSystemIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension FSxClient {
    /// Paginate over `[DescribeSnapshotsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSnapshotsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSnapshotsOutputResponse`
    public func describeSnapshotsPaginated(input: DescribeSnapshotsInput) -> ClientRuntime.PaginatorSequence<DescribeSnapshotsInput, DescribeSnapshotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSnapshotsInput, DescribeSnapshotsOutputResponse>(input: input, inputKey: \DescribeSnapshotsInput.nextToken, outputKey: \DescribeSnapshotsOutputResponse.nextToken, paginationFunction: self.describeSnapshots(input:))
    }
}

extension DescribeSnapshotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSnapshotsInput {
        return DescribeSnapshotsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            snapshotIds: self.snapshotIds
        )}
}
extension FSxClient {
    /// Paginate over `[DescribeStorageVirtualMachinesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeStorageVirtualMachinesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeStorageVirtualMachinesOutputResponse`
    public func describeStorageVirtualMachinesPaginated(input: DescribeStorageVirtualMachinesInput) -> ClientRuntime.PaginatorSequence<DescribeStorageVirtualMachinesInput, DescribeStorageVirtualMachinesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeStorageVirtualMachinesInput, DescribeStorageVirtualMachinesOutputResponse>(input: input, inputKey: \DescribeStorageVirtualMachinesInput.nextToken, outputKey: \DescribeStorageVirtualMachinesOutputResponse.nextToken, paginationFunction: self.describeStorageVirtualMachines(input:))
    }
}

extension DescribeStorageVirtualMachinesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeStorageVirtualMachinesInput {
        return DescribeStorageVirtualMachinesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            storageVirtualMachineIds: self.storageVirtualMachineIds
        )}
}

extension PaginatorSequence where Input == DescribeStorageVirtualMachinesInput, Output == DescribeStorageVirtualMachinesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeStorageVirtualMachinesPaginated`
    /// to access the nested member `[FSxClientTypes.StorageVirtualMachine]`
    /// - Returns: `[FSxClientTypes.StorageVirtualMachine]`
    public func storageVirtualMachines() async throws -> [FSxClientTypes.StorageVirtualMachine] {
        return try await self.asyncCompactMap { item in item.storageVirtualMachines }
    }
}
extension FSxClient {
    /// Paginate over `[DescribeVolumesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeVolumesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeVolumesOutputResponse`
    public func describeVolumesPaginated(input: DescribeVolumesInput) -> ClientRuntime.PaginatorSequence<DescribeVolumesInput, DescribeVolumesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeVolumesInput, DescribeVolumesOutputResponse>(input: input, inputKey: \DescribeVolumesInput.nextToken, outputKey: \DescribeVolumesOutputResponse.nextToken, paginationFunction: self.describeVolumes(input:))
    }
}

extension DescribeVolumesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVolumesInput {
        return DescribeVolumesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            volumeIds: self.volumeIds
        )}
}

extension PaginatorSequence where Input == DescribeVolumesInput, Output == DescribeVolumesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeVolumesPaginated`
    /// to access the nested member `[FSxClientTypes.Volume]`
    /// - Returns: `[FSxClientTypes.Volume]`
    public func volumes() async throws -> [FSxClientTypes.Volume] {
        return try await self.asyncCompactMap { item in item.volumes }
    }
}
extension FSxClient {
    /// Paginate over `[ListTagsForResourceOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsForResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsForResourceOutputResponse`
    public func listTagsForResourcePaginated(input: ListTagsForResourceInput) -> ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse>(input: input, inputKey: \ListTagsForResourceInput.nextToken, outputKey: \ListTagsForResourceOutputResponse.nextToken, paginationFunction: self.listTagsForResource(input:))
    }
}

extension ListTagsForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsForResourceInput {
        return ListTagsForResourceInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceARN: self.resourceARN
        )}
}
