// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EC2ClientProtocol {

    static func bundleTaskCompleteWaiterConfig() throws -> WaiterConfiguration<DescribeBundleTasksInput, DescribeBundleTasksOutput> {
        let acceptors: [WaiterConfiguration<DescribeBundleTasksInput, DescribeBundleTasksOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBundleTasksInput, result: Result<DescribeBundleTasksOutput, Error>) -> Bool in
                // JMESPath expression: "BundleTasks[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "complete"
                guard case .success(let output) = result else { return false }
                let bundleTasks = output.bundleTasks
                let projection: [EC2ClientTypes.BundleTaskState]? = bundleTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "complete") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeBundleTasksInput, result: Result<DescribeBundleTasksOutput, Error>) -> Bool in
                // JMESPath expression: "BundleTasks[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "failed"
                guard case .success(let output) = result else { return false }
                let bundleTasks = output.bundleTasks
                let projection: [EC2ClientTypes.BundleTaskState]? = bundleTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "failed") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeBundleTasksInput, DescribeBundleTasksOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BundleTaskComplete event on the describeBundleTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBundleTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBundleTaskComplete(options: WaiterOptions, input: DescribeBundleTasksInput) async throws -> WaiterOutcome<DescribeBundleTasksOutput> {
        let waiter = Waiter(config: try Self.bundleTaskCompleteWaiterConfig(), operation: self.describeBundleTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func conversionTaskCancelledWaiterConfig() throws -> WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutput> {
        let acceptors: [WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeConversionTasksInput, result: Result<DescribeConversionTasksOutput, Error>) -> Bool in
                // JMESPath expression: "ConversionTasks[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "cancelled"
                guard case .success(let output) = result else { return false }
                let conversionTasks = output.conversionTasks
                let projection: [EC2ClientTypes.ConversionTaskState]? = conversionTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "cancelled") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ConversionTaskCancelled event on the describeConversionTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeConversionTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilConversionTaskCancelled(options: WaiterOptions, input: DescribeConversionTasksInput) async throws -> WaiterOutcome<DescribeConversionTasksOutput> {
        let waiter = Waiter(config: try Self.conversionTaskCancelledWaiterConfig(), operation: self.describeConversionTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func conversionTaskCompletedWaiterConfig() throws -> WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutput> {
        let acceptors: [WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeConversionTasksInput, result: Result<DescribeConversionTasksOutput, Error>) -> Bool in
                // JMESPath expression: "ConversionTasks[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "completed"
                guard case .success(let output) = result else { return false }
                let conversionTasks = output.conversionTasks
                let projection: [EC2ClientTypes.ConversionTaskState]? = conversionTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "completed") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeConversionTasksInput, result: Result<DescribeConversionTasksOutput, Error>) -> Bool in
                // JMESPath expression: "ConversionTasks[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "cancelled"
                guard case .success(let output) = result else { return false }
                let conversionTasks = output.conversionTasks
                let projection: [EC2ClientTypes.ConversionTaskState]? = conversionTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "cancelled") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeConversionTasksInput, result: Result<DescribeConversionTasksOutput, Error>) -> Bool in
                // JMESPath expression: "ConversionTasks[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "cancelling"
                guard case .success(let output) = result else { return false }
                let conversionTasks = output.conversionTasks
                let projection: [EC2ClientTypes.ConversionTaskState]? = conversionTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "cancelling") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ConversionTaskCompleted event on the describeConversionTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeConversionTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilConversionTaskCompleted(options: WaiterOptions, input: DescribeConversionTasksInput) async throws -> WaiterOutcome<DescribeConversionTasksOutput> {
        let waiter = Waiter(config: try Self.conversionTaskCompletedWaiterConfig(), operation: self.describeConversionTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func conversionTaskDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutput> {
        let acceptors: [WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeConversionTasksInput, result: Result<DescribeConversionTasksOutput, Error>) -> Bool in
                // JMESPath expression: "ConversionTasks[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let conversionTasks = output.conversionTasks
                let projection: [EC2ClientTypes.ConversionTaskState]? = conversionTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "deleted") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ConversionTaskDeleted event on the describeConversionTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeConversionTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilConversionTaskDeleted(options: WaiterOptions, input: DescribeConversionTasksInput) async throws -> WaiterOutcome<DescribeConversionTasksOutput> {
        let waiter = Waiter(config: try Self.conversionTaskDeletedWaiterConfig(), operation: self.describeConversionTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func customerGatewayAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeCustomerGatewaysInput, DescribeCustomerGatewaysOutput> {
        let acceptors: [WaiterConfiguration<DescribeCustomerGatewaysInput, DescribeCustomerGatewaysOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeCustomerGatewaysInput, result: Result<DescribeCustomerGatewaysOutput, Error>) -> Bool in
                // JMESPath expression: "CustomerGateways[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let customerGateways = output.customerGateways
                let projection: [Swift.String]? = customerGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeCustomerGatewaysInput, result: Result<DescribeCustomerGatewaysOutput, Error>) -> Bool in
                // JMESPath expression: "CustomerGateways[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let customerGateways = output.customerGateways
                let projection: [Swift.String]? = customerGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleted") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeCustomerGatewaysInput, result: Result<DescribeCustomerGatewaysOutput, Error>) -> Bool in
                // JMESPath expression: "CustomerGateways[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleting"
                guard case .success(let output) = result else { return false }
                let customerGateways = output.customerGateways
                let projection: [Swift.String]? = customerGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleting") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeCustomerGatewaysInput, DescribeCustomerGatewaysOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the CustomerGatewayAvailable event on the describeCustomerGateways operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeCustomerGatewaysInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilCustomerGatewayAvailable(options: WaiterOptions, input: DescribeCustomerGatewaysInput) async throws -> WaiterOutcome<DescribeCustomerGatewaysOutput> {
        let waiter = Waiter(config: try Self.customerGatewayAvailableWaiterConfig(), operation: self.describeCustomerGateways(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func exportTaskCancelledWaiterConfig() throws -> WaiterConfiguration<DescribeExportTasksInput, DescribeExportTasksOutput> {
        let acceptors: [WaiterConfiguration<DescribeExportTasksInput, DescribeExportTasksOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeExportTasksInput, result: Result<DescribeExportTasksOutput, Error>) -> Bool in
                // JMESPath expression: "ExportTasks[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "cancelled"
                guard case .success(let output) = result else { return false }
                let exportTasks = output.exportTasks
                let projection: [EC2ClientTypes.ExportTaskState]? = exportTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "cancelled") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeExportTasksInput, DescribeExportTasksOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ExportTaskCancelled event on the describeExportTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeExportTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilExportTaskCancelled(options: WaiterOptions, input: DescribeExportTasksInput) async throws -> WaiterOutcome<DescribeExportTasksOutput> {
        let waiter = Waiter(config: try Self.exportTaskCancelledWaiterConfig(), operation: self.describeExportTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func exportTaskCompletedWaiterConfig() throws -> WaiterConfiguration<DescribeExportTasksInput, DescribeExportTasksOutput> {
        let acceptors: [WaiterConfiguration<DescribeExportTasksInput, DescribeExportTasksOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeExportTasksInput, result: Result<DescribeExportTasksOutput, Error>) -> Bool in
                // JMESPath expression: "ExportTasks[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "completed"
                guard case .success(let output) = result else { return false }
                let exportTasks = output.exportTasks
                let projection: [EC2ClientTypes.ExportTaskState]? = exportTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "completed") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeExportTasksInput, DescribeExportTasksOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ExportTaskCompleted event on the describeExportTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeExportTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilExportTaskCompleted(options: WaiterOptions, input: DescribeExportTasksInput) async throws -> WaiterOutcome<DescribeExportTasksOutput> {
        let waiter = Waiter(config: try Self.exportTaskCompletedWaiterConfig(), operation: self.describeExportTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func imageAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeImagesInput, DescribeImagesOutput> {
        let acceptors: [WaiterConfiguration<DescribeImagesInput, DescribeImagesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeImagesInput, result: Result<DescribeImagesOutput, Error>) -> Bool in
                // JMESPath expression: "Images[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let images = output.images
                let projection: [EC2ClientTypes.ImageState]? = images?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeImagesInput, result: Result<DescribeImagesOutput, Error>) -> Bool in
                // JMESPath expression: "Images[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "failed"
                guard case .success(let output) = result else { return false }
                let images = output.images
                let projection: [EC2ClientTypes.ImageState]? = images?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "failed") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeImagesInput, DescribeImagesOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ImageAvailable event on the describeImages operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeImagesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilImageAvailable(options: WaiterOptions, input: DescribeImagesInput) async throws -> WaiterOutcome<DescribeImagesOutput> {
        let waiter = Waiter(config: try Self.imageAvailableWaiterConfig(), operation: self.describeImages(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func imageExistsWaiterConfig() throws -> WaiterConfiguration<DescribeImagesInput, DescribeImagesOutput> {
        let acceptors: [WaiterConfiguration<DescribeImagesInput, DescribeImagesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeImagesInput, result: Result<DescribeImagesOutput, Error>) -> Bool in
                // JMESPath expression: "length(Images[]) > `0`"
                // JMESPath comparator: "booleanEquals"
                // JMESPath expected value: "true"
                guard case .success(let output) = result else { return false }
                let images = output.images
                let count = Double(images?.count ?? 0)
                let number = Double(0.0)
                let comparison = JMESUtils.compare(count, >, number)
                return JMESUtils.compare(comparison, ==, true)
            }),
            .init(state: .retry, matcher: { (input: DescribeImagesInput, result: Result<DescribeImagesOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "InvalidAMIID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeImagesInput, DescribeImagesOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ImageExists event on the describeImages operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeImagesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilImageExists(options: WaiterOptions, input: DescribeImagesInput) async throws -> WaiterOutcome<DescribeImagesOutput> {
        let waiter = Waiter(config: try Self.imageExistsWaiterConfig(), operation: self.describeImages(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func snapshotImportedWaiterConfig() throws -> WaiterConfiguration<DescribeImportSnapshotTasksInput, DescribeImportSnapshotTasksOutput> {
        let acceptors: [WaiterConfiguration<DescribeImportSnapshotTasksInput, DescribeImportSnapshotTasksOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeImportSnapshotTasksInput, result: Result<DescribeImportSnapshotTasksOutput, Error>) -> Bool in
                // JMESPath expression: "ImportSnapshotTasks[].SnapshotTaskDetail.Status"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "completed"
                guard case .success(let output) = result else { return false }
                let importSnapshotTasks = output.importSnapshotTasks
                let projection: [Swift.String]? = importSnapshotTasks?.compactMap { original in
                    let snapshotTaskDetail = original.snapshotTaskDetail
                    let status = snapshotTaskDetail?.status
                    return status
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "completed") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeImportSnapshotTasksInput, result: Result<DescribeImportSnapshotTasksOutput, Error>) -> Bool in
                // JMESPath expression: "ImportSnapshotTasks[].SnapshotTaskDetail.Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "error"
                guard case .success(let output) = result else { return false }
                let importSnapshotTasks = output.importSnapshotTasks
                let projection: [Swift.String]? = importSnapshotTasks?.compactMap { original in
                    let snapshotTaskDetail = original.snapshotTaskDetail
                    let status = snapshotTaskDetail?.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "error") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeImportSnapshotTasksInput, DescribeImportSnapshotTasksOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SnapshotImported event on the describeImportSnapshotTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeImportSnapshotTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSnapshotImported(options: WaiterOptions, input: DescribeImportSnapshotTasksInput) async throws -> WaiterOutcome<DescribeImportSnapshotTasksOutput> {
        let waiter = Waiter(config: try Self.snapshotImportedWaiterConfig(), operation: self.describeImportSnapshotTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceExistsWaiterConfig() throws -> WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput> {
        let acceptors: [WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "length(Reservations[]) > `0`"
                // JMESPath comparator: "booleanEquals"
                // JMESPath expected value: "true"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let count = Double(reservations?.count ?? 0)
                let number = Double(0.0)
                let comparison = JMESUtils.compare(count, >, number)
                return JMESUtils.compare(comparison, ==, true)
            }),
            .init(state: .retry, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "InvalidInstanceID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceExists event on the describeInstances operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstancesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceExists(options: WaiterOptions, input: DescribeInstancesInput) async throws -> WaiterOutcome<DescribeInstancesOutput> {
        let waiter = Waiter(config: try Self.instanceExistsWaiterConfig(), operation: self.describeInstances(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceRunningWaiterConfig() throws -> WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput> {
        let acceptors: [WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "running"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return (projection2?.count ?? 0) > 1 && (projection2?.allSatisfy { JMESUtils.compare($0, ==, "running") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "shutting-down"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "shutting-down") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "terminated"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "terminated") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "stopping"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "stopping") }) ?? false
            }),
            .init(state: .retry, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "InvalidInstanceID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceRunning event on the describeInstances operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstancesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceRunning(options: WaiterOptions, input: DescribeInstancesInput) async throws -> WaiterOutcome<DescribeInstancesOutput> {
        let waiter = Waiter(config: try Self.instanceRunningWaiterConfig(), operation: self.describeInstances(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceStoppedWaiterConfig() throws -> WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput> {
        let acceptors: [WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "stopped"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return (projection2?.count ?? 0) > 1 && (projection2?.allSatisfy { JMESUtils.compare($0, ==, "stopped") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "pending"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "pending") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "terminated"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "terminated") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceStopped event on the describeInstances operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstancesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceStopped(options: WaiterOptions, input: DescribeInstancesInput) async throws -> WaiterOutcome<DescribeInstancesOutput> {
        let waiter = Waiter(config: try Self.instanceStoppedWaiterConfig(), operation: self.describeInstances(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceTerminatedWaiterConfig() throws -> WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput> {
        let acceptors: [WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "terminated"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return (projection2?.count ?? 0) > 1 && (projection2?.allSatisfy { JMESUtils.compare($0, ==, "terminated") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "pending"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "pending") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "stopping"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "stopping") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceTerminated event on the describeInstances operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstancesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceTerminated(options: WaiterOptions, input: DescribeInstancesInput) async throws -> WaiterOutcome<DescribeInstancesOutput> {
        let waiter = Waiter(config: try Self.instanceTerminatedWaiterConfig(), operation: self.describeInstances(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceStatusOkWaiterConfig() throws -> WaiterConfiguration<DescribeInstanceStatusInput, DescribeInstanceStatusOutput> {
        let acceptors: [WaiterConfiguration<DescribeInstanceStatusInput, DescribeInstanceStatusOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstanceStatusInput, result: Result<DescribeInstanceStatusOutput, Error>) -> Bool in
                // JMESPath expression: "InstanceStatuses[].InstanceStatus.Status"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "ok"
                guard case .success(let output) = result else { return false }
                let instanceStatuses = output.instanceStatuses
                let projection: [EC2ClientTypes.SummaryStatus]? = instanceStatuses?.compactMap { original in
                    let instanceStatus = original.instanceStatus
                    let status = instanceStatus?.status
                    return status
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "ok") } ?? false)
            }),
            .init(state: .retry, matcher: { (input: DescribeInstanceStatusInput, result: Result<DescribeInstanceStatusOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "InvalidInstanceID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeInstanceStatusInput, DescribeInstanceStatusOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceStatusOk event on the describeInstanceStatus operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstanceStatusInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceStatusOk(options: WaiterOptions, input: DescribeInstanceStatusInput) async throws -> WaiterOutcome<DescribeInstanceStatusOutput> {
        let waiter = Waiter(config: try Self.instanceStatusOkWaiterConfig(), operation: self.describeInstanceStatus(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func systemStatusOkWaiterConfig() throws -> WaiterConfiguration<DescribeInstanceStatusInput, DescribeInstanceStatusOutput> {
        let acceptors: [WaiterConfiguration<DescribeInstanceStatusInput, DescribeInstanceStatusOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstanceStatusInput, result: Result<DescribeInstanceStatusOutput, Error>) -> Bool in
                // JMESPath expression: "InstanceStatuses[].SystemStatus.Status"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "ok"
                guard case .success(let output) = result else { return false }
                let instanceStatuses = output.instanceStatuses
                let projection: [EC2ClientTypes.SummaryStatus]? = instanceStatuses?.compactMap { original in
                    let systemStatus = original.systemStatus
                    let status = systemStatus?.status
                    return status
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "ok") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeInstanceStatusInput, DescribeInstanceStatusOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SystemStatusOk event on the describeInstanceStatus operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstanceStatusInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSystemStatusOk(options: WaiterOptions, input: DescribeInstanceStatusInput) async throws -> WaiterOutcome<DescribeInstanceStatusOutput> {
        let waiter = Waiter(config: try Self.systemStatusOkWaiterConfig(), operation: self.describeInstanceStatus(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func internetGatewayExistsWaiterConfig() throws -> WaiterConfiguration<DescribeInternetGatewaysInput, DescribeInternetGatewaysOutput> {
        let acceptors: [WaiterConfiguration<DescribeInternetGatewaysInput, DescribeInternetGatewaysOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInternetGatewaysInput, result: Result<DescribeInternetGatewaysOutput, Error>) -> Bool in
                // JMESPath expression: "length(InternetGateways[].InternetGatewayId) > `0`"
                // JMESPath comparator: "booleanEquals"
                // JMESPath expected value: "true"
                guard case .success(let output) = result else { return false }
                let internetGateways = output.internetGateways
                let projection: [Swift.String]? = internetGateways?.compactMap { original in
                    let internetGatewayId = original.internetGatewayId
                    return internetGatewayId
                }
                let count = Double(projection?.count ?? 0)
                let number = Double(0.0)
                let comparison = JMESUtils.compare(count, >, number)
                return JMESUtils.compare(comparison, ==, true)
            }),
            .init(state: .retry, matcher: { (input: DescribeInternetGatewaysInput, result: Result<DescribeInternetGatewaysOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "InvalidInternetGateway.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeInternetGatewaysInput, DescribeInternetGatewaysOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InternetGatewayExists event on the describeInternetGateways operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInternetGatewaysInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInternetGatewayExists(options: WaiterOptions, input: DescribeInternetGatewaysInput) async throws -> WaiterOutcome<DescribeInternetGatewaysOutput> {
        let waiter = Waiter(config: try Self.internetGatewayExistsWaiterConfig(), operation: self.describeInternetGateways(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func keyPairExistsWaiterConfig() throws -> WaiterConfiguration<DescribeKeyPairsInput, DescribeKeyPairsOutput> {
        let acceptors: [WaiterConfiguration<DescribeKeyPairsInput, DescribeKeyPairsOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeKeyPairsInput, result: Result<DescribeKeyPairsOutput, Error>) -> Bool in
                // JMESPath expression: "length(KeyPairs[].KeyName) > `0`"
                // JMESPath comparator: "booleanEquals"
                // JMESPath expected value: "true"
                guard case .success(let output) = result else { return false }
                let keyPairs = output.keyPairs
                let projection: [Swift.String]? = keyPairs?.compactMap { original in
                    let keyName = original.keyName
                    return keyName
                }
                let count = Double(projection?.count ?? 0)
                let number = Double(0.0)
                let comparison = JMESUtils.compare(count, >, number)
                return JMESUtils.compare(comparison, ==, true)
            }),
            .init(state: .retry, matcher: { (input: DescribeKeyPairsInput, result: Result<DescribeKeyPairsOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "InvalidKeyPair.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeKeyPairsInput, DescribeKeyPairsOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the KeyPairExists event on the describeKeyPairs operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeKeyPairsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilKeyPairExists(options: WaiterOptions, input: DescribeKeyPairsInput) async throws -> WaiterOutcome<DescribeKeyPairsOutput> {
        let waiter = Waiter(config: try Self.keyPairExistsWaiterConfig(), operation: self.describeKeyPairs(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func natGatewayAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeNatGatewaysInput, DescribeNatGatewaysOutput> {
        let acceptors: [WaiterConfiguration<DescribeNatGatewaysInput, DescribeNatGatewaysOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutput, Error>) -> Bool in
                // JMESPath expression: "NatGateways[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let natGateways = output.natGateways
                let projection: [EC2ClientTypes.NatGatewayState]? = natGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutput, Error>) -> Bool in
                // JMESPath expression: "NatGateways[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "failed"
                guard case .success(let output) = result else { return false }
                let natGateways = output.natGateways
                let projection: [EC2ClientTypes.NatGatewayState]? = natGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "failed") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutput, Error>) -> Bool in
                // JMESPath expression: "NatGateways[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleting"
                guard case .success(let output) = result else { return false }
                let natGateways = output.natGateways
                let projection: [EC2ClientTypes.NatGatewayState]? = natGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleting") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutput, Error>) -> Bool in
                // JMESPath expression: "NatGateways[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let natGateways = output.natGateways
                let projection: [EC2ClientTypes.NatGatewayState]? = natGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleted") }) ?? false
            }),
            .init(state: .retry, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "NatGatewayNotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeNatGatewaysInput, DescribeNatGatewaysOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the NatGatewayAvailable event on the describeNatGateways operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeNatGatewaysInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilNatGatewayAvailable(options: WaiterOptions, input: DescribeNatGatewaysInput) async throws -> WaiterOutcome<DescribeNatGatewaysOutput> {
        let waiter = Waiter(config: try Self.natGatewayAvailableWaiterConfig(), operation: self.describeNatGateways(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func natGatewayDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeNatGatewaysInput, DescribeNatGatewaysOutput> {
        let acceptors: [WaiterConfiguration<DescribeNatGatewaysInput, DescribeNatGatewaysOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutput, Error>) -> Bool in
                // JMESPath expression: "NatGateways[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let natGateways = output.natGateways
                let projection: [EC2ClientTypes.NatGatewayState]? = natGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "deleted") } ?? false)
            }),
            .init(state: .success, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "NatGatewayNotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeNatGatewaysInput, DescribeNatGatewaysOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the NatGatewayDeleted event on the describeNatGateways operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeNatGatewaysInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilNatGatewayDeleted(options: WaiterOptions, input: DescribeNatGatewaysInput) async throws -> WaiterOutcome<DescribeNatGatewaysOutput> {
        let waiter = Waiter(config: try Self.natGatewayDeletedWaiterConfig(), operation: self.describeNatGateways(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func networkInterfaceAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeNetworkInterfacesInput, DescribeNetworkInterfacesOutput> {
        let acceptors: [WaiterConfiguration<DescribeNetworkInterfacesInput, DescribeNetworkInterfacesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeNetworkInterfacesInput, result: Result<DescribeNetworkInterfacesOutput, Error>) -> Bool in
                // JMESPath expression: "NetworkInterfaces[].Status"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let networkInterfaces = output.networkInterfaces
                let projection: [EC2ClientTypes.NetworkInterfaceStatus]? = networkInterfaces?.compactMap { original in
                    let status = original.status
                    return status
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeNetworkInterfacesInput, result: Result<DescribeNetworkInterfacesOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "InvalidNetworkInterfaceID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeNetworkInterfacesInput, DescribeNetworkInterfacesOutput>(acceptors: acceptors, minDelay: 20.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the NetworkInterfaceAvailable event on the describeNetworkInterfaces operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeNetworkInterfacesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilNetworkInterfaceAvailable(options: WaiterOptions, input: DescribeNetworkInterfacesInput) async throws -> WaiterOutcome<DescribeNetworkInterfacesOutput> {
        let waiter = Waiter(config: try Self.networkInterfaceAvailableWaiterConfig(), operation: self.describeNetworkInterfaces(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func securityGroupExistsWaiterConfig() throws -> WaiterConfiguration<DescribeSecurityGroupsInput, DescribeSecurityGroupsOutput> {
        let acceptors: [WaiterConfiguration<DescribeSecurityGroupsInput, DescribeSecurityGroupsOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeSecurityGroupsInput, result: Result<DescribeSecurityGroupsOutput, Error>) -> Bool in
                // JMESPath expression: "length(SecurityGroups[].GroupId) > `0`"
                // JMESPath comparator: "booleanEquals"
                // JMESPath expected value: "true"
                guard case .success(let output) = result else { return false }
                let securityGroups = output.securityGroups
                let projection: [Swift.String]? = securityGroups?.compactMap { original in
                    let groupId = original.groupId
                    return groupId
                }
                let count = Double(projection?.count ?? 0)
                let number = Double(0.0)
                let comparison = JMESUtils.compare(count, >, number)
                return JMESUtils.compare(comparison, ==, true)
            }),
            .init(state: .retry, matcher: { (input: DescribeSecurityGroupsInput, result: Result<DescribeSecurityGroupsOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "InvalidGroup.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeSecurityGroupsInput, DescribeSecurityGroupsOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SecurityGroupExists event on the describeSecurityGroups operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeSecurityGroupsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSecurityGroupExists(options: WaiterOptions, input: DescribeSecurityGroupsInput) async throws -> WaiterOutcome<DescribeSecurityGroupsOutput> {
        let waiter = Waiter(config: try Self.securityGroupExistsWaiterConfig(), operation: self.describeSecurityGroups(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func snapshotCompletedWaiterConfig() throws -> WaiterConfiguration<DescribeSnapshotsInput, DescribeSnapshotsOutput> {
        let acceptors: [WaiterConfiguration<DescribeSnapshotsInput, DescribeSnapshotsOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeSnapshotsInput, result: Result<DescribeSnapshotsOutput, Error>) -> Bool in
                // JMESPath expression: "Snapshots[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "completed"
                guard case .success(let output) = result else { return false }
                let snapshots = output.snapshots
                let projection: [EC2ClientTypes.SnapshotState]? = snapshots?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "completed") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeSnapshotsInput, result: Result<DescribeSnapshotsOutput, Error>) -> Bool in
                // JMESPath expression: "Snapshots[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "error"
                guard case .success(let output) = result else { return false }
                let snapshots = output.snapshots
                let projection: [EC2ClientTypes.SnapshotState]? = snapshots?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "error") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeSnapshotsInput, DescribeSnapshotsOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SnapshotCompleted event on the describeSnapshots operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeSnapshotsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSnapshotCompleted(options: WaiterOptions, input: DescribeSnapshotsInput) async throws -> WaiterOutcome<DescribeSnapshotsOutput> {
        let waiter = Waiter(config: try Self.snapshotCompletedWaiterConfig(), operation: self.describeSnapshots(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func spotInstanceRequestFulfilledWaiterConfig() throws -> WaiterConfiguration<DescribeSpotInstanceRequestsInput, DescribeSpotInstanceRequestsOutput> {
        let acceptors: [WaiterConfiguration<DescribeSpotInstanceRequestsInput, DescribeSpotInstanceRequestsOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutput, Error>) -> Bool in
                // JMESPath expression: "SpotInstanceRequests[].Status.Code"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "fulfilled"
                guard case .success(let output) = result else { return false }
                let spotInstanceRequests = output.spotInstanceRequests
                let projection: [Swift.String]? = spotInstanceRequests?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "fulfilled") } ?? false)
            }),
            .init(state: .success, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutput, Error>) -> Bool in
                // JMESPath expression: "SpotInstanceRequests[].Status.Code"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "request-canceled-and-instance-running"
                guard case .success(let output) = result else { return false }
                let spotInstanceRequests = output.spotInstanceRequests
                let projection: [Swift.String]? = spotInstanceRequests?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "request-canceled-and-instance-running") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutput, Error>) -> Bool in
                // JMESPath expression: "SpotInstanceRequests[].Status.Code"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "schedule-expired"
                guard case .success(let output) = result else { return false }
                let spotInstanceRequests = output.spotInstanceRequests
                let projection: [Swift.String]? = spotInstanceRequests?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "schedule-expired") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutput, Error>) -> Bool in
                // JMESPath expression: "SpotInstanceRequests[].Status.Code"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "canceled-before-fulfillment"
                guard case .success(let output) = result else { return false }
                let spotInstanceRequests = output.spotInstanceRequests
                let projection: [Swift.String]? = spotInstanceRequests?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "canceled-before-fulfillment") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutput, Error>) -> Bool in
                // JMESPath expression: "SpotInstanceRequests[].Status.Code"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "bad-parameters"
                guard case .success(let output) = result else { return false }
                let spotInstanceRequests = output.spotInstanceRequests
                let projection: [Swift.String]? = spotInstanceRequests?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "bad-parameters") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutput, Error>) -> Bool in
                // JMESPath expression: "SpotInstanceRequests[].Status.Code"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "system-error"
                guard case .success(let output) = result else { return false }
                let spotInstanceRequests = output.spotInstanceRequests
                let projection: [Swift.String]? = spotInstanceRequests?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "system-error") }) ?? false
            }),
            .init(state: .retry, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "InvalidSpotInstanceRequestID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeSpotInstanceRequestsInput, DescribeSpotInstanceRequestsOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SpotInstanceRequestFulfilled event on the describeSpotInstanceRequests operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeSpotInstanceRequestsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSpotInstanceRequestFulfilled(options: WaiterOptions, input: DescribeSpotInstanceRequestsInput) async throws -> WaiterOutcome<DescribeSpotInstanceRequestsOutput> {
        let waiter = Waiter(config: try Self.spotInstanceRequestFulfilledWaiterConfig(), operation: self.describeSpotInstanceRequests(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func storeImageTaskCompleteWaiterConfig() throws -> WaiterConfiguration<DescribeStoreImageTasksInput, DescribeStoreImageTasksOutput> {
        let acceptors: [WaiterConfiguration<DescribeStoreImageTasksInput, DescribeStoreImageTasksOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeStoreImageTasksInput, result: Result<DescribeStoreImageTasksOutput, Error>) -> Bool in
                // JMESPath expression: "StoreImageTaskResults[].StoreTaskState"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "Completed"
                guard case .success(let output) = result else { return false }
                let storeImageTaskResults = output.storeImageTaskResults
                let projection: [Swift.String]? = storeImageTaskResults?.compactMap { original in
                    let storeTaskState = original.storeTaskState
                    return storeTaskState
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "Completed") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeStoreImageTasksInput, result: Result<DescribeStoreImageTasksOutput, Error>) -> Bool in
                // JMESPath expression: "StoreImageTaskResults[].StoreTaskState"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let storeImageTaskResults = output.storeImageTaskResults
                let projection: [Swift.String]? = storeImageTaskResults?.compactMap { original in
                    let storeTaskState = original.storeTaskState
                    return storeTaskState
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "Failed") }) ?? false
            }),
            .init(state: .retry, matcher: { (input: DescribeStoreImageTasksInput, result: Result<DescribeStoreImageTasksOutput, Error>) -> Bool in
                // JMESPath expression: "StoreImageTaskResults[].StoreTaskState"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "InProgress"
                guard case .success(let output) = result else { return false }
                let storeImageTaskResults = output.storeImageTaskResults
                let projection: [Swift.String]? = storeImageTaskResults?.compactMap { original in
                    let storeTaskState = original.storeTaskState
                    return storeTaskState
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "InProgress") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeStoreImageTasksInput, DescribeStoreImageTasksOutput>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the StoreImageTaskComplete event on the describeStoreImageTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeStoreImageTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilStoreImageTaskComplete(options: WaiterOptions, input: DescribeStoreImageTasksInput) async throws -> WaiterOutcome<DescribeStoreImageTasksOutput> {
        let waiter = Waiter(config: try Self.storeImageTaskCompleteWaiterConfig(), operation: self.describeStoreImageTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func subnetAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeSubnetsInput, DescribeSubnetsOutput> {
        let acceptors: [WaiterConfiguration<DescribeSubnetsInput, DescribeSubnetsOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeSubnetsInput, result: Result<DescribeSubnetsOutput, Error>) -> Bool in
                // JMESPath expression: "Subnets[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let subnets = output.subnets
                let projection: [EC2ClientTypes.SubnetState]? = subnets?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeSubnetsInput, DescribeSubnetsOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SubnetAvailable event on the describeSubnets operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeSubnetsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSubnetAvailable(options: WaiterOptions, input: DescribeSubnetsInput) async throws -> WaiterOutcome<DescribeSubnetsOutput> {
        let waiter = Waiter(config: try Self.subnetAvailableWaiterConfig(), operation: self.describeSubnets(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func volumeAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutput> {
        let acceptors: [WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVolumesInput, result: Result<DescribeVolumesOutput, Error>) -> Bool in
                // JMESPath expression: "Volumes[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let volumes = output.volumes
                let projection: [EC2ClientTypes.VolumeState]? = volumes?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeVolumesInput, result: Result<DescribeVolumesOutput, Error>) -> Bool in
                // JMESPath expression: "Volumes[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let volumes = output.volumes
                let projection: [EC2ClientTypes.VolumeState]? = volumes?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleted") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VolumeAvailable event on the describeVolumes operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVolumesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVolumeAvailable(options: WaiterOptions, input: DescribeVolumesInput) async throws -> WaiterOutcome<DescribeVolumesOutput> {
        let waiter = Waiter(config: try Self.volumeAvailableWaiterConfig(), operation: self.describeVolumes(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func volumeDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutput> {
        let acceptors: [WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVolumesInput, result: Result<DescribeVolumesOutput, Error>) -> Bool in
                // JMESPath expression: "Volumes[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let volumes = output.volumes
                let projection: [EC2ClientTypes.VolumeState]? = volumes?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "deleted") } ?? false)
            }),
            .init(state: .success, matcher: { (input: DescribeVolumesInput, result: Result<DescribeVolumesOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "InvalidVolume.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VolumeDeleted event on the describeVolumes operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVolumesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVolumeDeleted(options: WaiterOptions, input: DescribeVolumesInput) async throws -> WaiterOutcome<DescribeVolumesOutput> {
        let waiter = Waiter(config: try Self.volumeDeletedWaiterConfig(), operation: self.describeVolumes(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func volumeInUseWaiterConfig() throws -> WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutput> {
        let acceptors: [WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVolumesInput, result: Result<DescribeVolumesOutput, Error>) -> Bool in
                // JMESPath expression: "Volumes[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "in-use"
                guard case .success(let output) = result else { return false }
                let volumes = output.volumes
                let projection: [EC2ClientTypes.VolumeState]? = volumes?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "in-use") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeVolumesInput, result: Result<DescribeVolumesOutput, Error>) -> Bool in
                // JMESPath expression: "Volumes[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let volumes = output.volumes
                let projection: [EC2ClientTypes.VolumeState]? = volumes?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleted") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VolumeInUse event on the describeVolumes operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVolumesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVolumeInUse(options: WaiterOptions, input: DescribeVolumesInput) async throws -> WaiterOutcome<DescribeVolumesOutput> {
        let waiter = Waiter(config: try Self.volumeInUseWaiterConfig(), operation: self.describeVolumes(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func vpcPeeringConnectionDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutput> {
        let acceptors: [WaiterConfiguration<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVpcPeeringConnectionsInput, result: Result<DescribeVpcPeeringConnectionsOutput, Error>) -> Bool in
                // JMESPath expression: "VpcPeeringConnections[].Status.Code"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let vpcPeeringConnections = output.vpcPeeringConnections
                let projection: [EC2ClientTypes.VpcPeeringConnectionStateReasonCode]? = vpcPeeringConnections?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "deleted") } ?? false)
            }),
            .init(state: .success, matcher: { (input: DescribeVpcPeeringConnectionsInput, result: Result<DescribeVpcPeeringConnectionsOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "InvalidVpcPeeringConnectionID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VpcPeeringConnectionDeleted event on the describeVpcPeeringConnections operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVpcPeeringConnectionsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVpcPeeringConnectionDeleted(options: WaiterOptions, input: DescribeVpcPeeringConnectionsInput) async throws -> WaiterOutcome<DescribeVpcPeeringConnectionsOutput> {
        let waiter = Waiter(config: try Self.vpcPeeringConnectionDeletedWaiterConfig(), operation: self.describeVpcPeeringConnections(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func vpcPeeringConnectionExistsWaiterConfig() throws -> WaiterConfiguration<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutput> {
        let acceptors: [WaiterConfiguration<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVpcPeeringConnectionsInput, result: Result<DescribeVpcPeeringConnectionsOutput, Error>) -> Bool in
                switch result {
                    case .success: return true
                    case .failure: return false
                }
            }),
            .init(state: .retry, matcher: { (input: DescribeVpcPeeringConnectionsInput, result: Result<DescribeVpcPeeringConnectionsOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "InvalidVpcPeeringConnectionID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VpcPeeringConnectionExists event on the describeVpcPeeringConnections operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVpcPeeringConnectionsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVpcPeeringConnectionExists(options: WaiterOptions, input: DescribeVpcPeeringConnectionsInput) async throws -> WaiterOutcome<DescribeVpcPeeringConnectionsOutput> {
        let waiter = Waiter(config: try Self.vpcPeeringConnectionExistsWaiterConfig(), operation: self.describeVpcPeeringConnections(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func vpcAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeVpcsInput, DescribeVpcsOutput> {
        let acceptors: [WaiterConfiguration<DescribeVpcsInput, DescribeVpcsOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVpcsInput, result: Result<DescribeVpcsOutput, Error>) -> Bool in
                // JMESPath expression: "Vpcs[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let vpcs = output.vpcs
                let projection: [EC2ClientTypes.VpcState]? = vpcs?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeVpcsInput, DescribeVpcsOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VpcAvailable event on the describeVpcs operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVpcsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVpcAvailable(options: WaiterOptions, input: DescribeVpcsInput) async throws -> WaiterOutcome<DescribeVpcsOutput> {
        let waiter = Waiter(config: try Self.vpcAvailableWaiterConfig(), operation: self.describeVpcs(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func vpcExistsWaiterConfig() throws -> WaiterConfiguration<DescribeVpcsInput, DescribeVpcsOutput> {
        let acceptors: [WaiterConfiguration<DescribeVpcsInput, DescribeVpcsOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVpcsInput, result: Result<DescribeVpcsOutput, Error>) -> Bool in
                switch result {
                    case .success: return true
                    case .failure: return false
                }
            }),
            .init(state: .retry, matcher: { (input: DescribeVpcsInput, result: Result<DescribeVpcsOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "InvalidVpcID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeVpcsInput, DescribeVpcsOutput>(acceptors: acceptors, minDelay: 1.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VpcExists event on the describeVpcs operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVpcsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVpcExists(options: WaiterOptions, input: DescribeVpcsInput) async throws -> WaiterOutcome<DescribeVpcsOutput> {
        let waiter = Waiter(config: try Self.vpcExistsWaiterConfig(), operation: self.describeVpcs(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func vpnConnectionAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeVpnConnectionsInput, DescribeVpnConnectionsOutput> {
        let acceptors: [WaiterConfiguration<DescribeVpnConnectionsInput, DescribeVpnConnectionsOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVpnConnectionsInput, result: Result<DescribeVpnConnectionsOutput, Error>) -> Bool in
                // JMESPath expression: "VpnConnections[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let vpnConnections = output.vpnConnections
                let projection: [EC2ClientTypes.VpnState]? = vpnConnections?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeVpnConnectionsInput, result: Result<DescribeVpnConnectionsOutput, Error>) -> Bool in
                // JMESPath expression: "VpnConnections[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleting"
                guard case .success(let output) = result else { return false }
                let vpnConnections = output.vpnConnections
                let projection: [EC2ClientTypes.VpnState]? = vpnConnections?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleting") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeVpnConnectionsInput, result: Result<DescribeVpnConnectionsOutput, Error>) -> Bool in
                // JMESPath expression: "VpnConnections[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let vpnConnections = output.vpnConnections
                let projection: [EC2ClientTypes.VpnState]? = vpnConnections?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleted") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeVpnConnectionsInput, DescribeVpnConnectionsOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VpnConnectionAvailable event on the describeVpnConnections operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVpnConnectionsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVpnConnectionAvailable(options: WaiterOptions, input: DescribeVpnConnectionsInput) async throws -> WaiterOutcome<DescribeVpnConnectionsOutput> {
        let waiter = Waiter(config: try Self.vpnConnectionAvailableWaiterConfig(), operation: self.describeVpnConnections(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func vpnConnectionDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeVpnConnectionsInput, DescribeVpnConnectionsOutput> {
        let acceptors: [WaiterConfiguration<DescribeVpnConnectionsInput, DescribeVpnConnectionsOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVpnConnectionsInput, result: Result<DescribeVpnConnectionsOutput, Error>) -> Bool in
                // JMESPath expression: "VpnConnections[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let vpnConnections = output.vpnConnections
                let projection: [EC2ClientTypes.VpnState]? = vpnConnections?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "deleted") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeVpnConnectionsInput, result: Result<DescribeVpnConnectionsOutput, Error>) -> Bool in
                // JMESPath expression: "VpnConnections[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "pending"
                guard case .success(let output) = result else { return false }
                let vpnConnections = output.vpnConnections
                let projection: [EC2ClientTypes.VpnState]? = vpnConnections?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "pending") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeVpnConnectionsInput, DescribeVpnConnectionsOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VpnConnectionDeleted event on the describeVpnConnections operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVpnConnectionsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVpnConnectionDeleted(options: WaiterOptions, input: DescribeVpnConnectionsInput) async throws -> WaiterOutcome<DescribeVpnConnectionsOutput> {
        let waiter = Waiter(config: try Self.vpnConnectionDeletedWaiterConfig(), operation: self.describeVpnConnections(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func passwordDataAvailableWaiterConfig() throws -> WaiterConfiguration<GetPasswordDataInput, GetPasswordDataOutput> {
        let acceptors: [WaiterConfiguration<GetPasswordDataInput, GetPasswordDataOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetPasswordDataInput, result: Result<GetPasswordDataOutput, Error>) -> Bool in
                // JMESPath expression: "length(PasswordData) > `0`"
                // JMESPath comparator: "booleanEquals"
                // JMESPath expected value: "true"
                guard case .success(let output) = result else { return false }
                let passwordData = output.passwordData
                let count = Double(passwordData?.count ?? 0)
                let number = Double(0.0)
                let comparison = JMESUtils.compare(count, >, number)
                return JMESUtils.compare(comparison, ==, true)
            }),
        ]
        return try WaiterConfiguration<GetPasswordDataInput, GetPasswordDataOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the PasswordDataAvailable event on the getPasswordData operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetPasswordDataInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilPasswordDataAvailable(options: WaiterOptions, input: GetPasswordDataInput) async throws -> WaiterOutcome<GetPasswordDataOutput> {
        let waiter = Waiter(config: try Self.passwordDataAvailableWaiterConfig(), operation: self.getPasswordData(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }
}
