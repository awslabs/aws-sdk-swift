// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EC2ClientProtocol {

    static func bundleTaskCompleteWaiterConfig() throws -> WaiterConfiguration<DescribeBundleTasksInput, DescribeBundleTasksOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeBundleTasksInput, DescribeBundleTasksOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeBundleTasksInput, result: Result<DescribeBundleTasksOutputResponse, Error>) -> Bool in
                // JMESPath expression: "BundleTasks[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "complete"
                guard case .success(let output) = result else { return false }
                let bundleTasks = output.bundleTasks
                let projection: [EC2ClientTypes.BundleTaskState]? = bundleTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "complete") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeBundleTasksInput, result: Result<DescribeBundleTasksOutputResponse, Error>) -> Bool in
                // JMESPath expression: "BundleTasks[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "failed"
                guard case .success(let output) = result else { return false }
                let bundleTasks = output.bundleTasks
                let projection: [EC2ClientTypes.BundleTaskState]? = bundleTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "failed") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeBundleTasksInput, DescribeBundleTasksOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the BundleTaskComplete event on the describeBundleTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeBundleTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilBundleTaskComplete(options: WaiterOptions, input: DescribeBundleTasksInput) async throws -> WaiterOutcome<DescribeBundleTasksOutputResponse> {
        let waiter = Waiter(config: try Self.bundleTaskCompleteWaiterConfig(), operation: self.describeBundleTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func conversionTaskCancelledWaiterConfig() throws -> WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeConversionTasksInput, result: Result<DescribeConversionTasksOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ConversionTasks[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "cancelled"
                guard case .success(let output) = result else { return false }
                let conversionTasks = output.conversionTasks
                let projection: [EC2ClientTypes.ConversionTaskState]? = conversionTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "cancelled") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ConversionTaskCancelled event on the describeConversionTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeConversionTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilConversionTaskCancelled(options: WaiterOptions, input: DescribeConversionTasksInput) async throws -> WaiterOutcome<DescribeConversionTasksOutputResponse> {
        let waiter = Waiter(config: try Self.conversionTaskCancelledWaiterConfig(), operation: self.describeConversionTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func conversionTaskCompletedWaiterConfig() throws -> WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeConversionTasksInput, result: Result<DescribeConversionTasksOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ConversionTasks[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "completed"
                guard case .success(let output) = result else { return false }
                let conversionTasks = output.conversionTasks
                let projection: [EC2ClientTypes.ConversionTaskState]? = conversionTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "completed") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeConversionTasksInput, result: Result<DescribeConversionTasksOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ConversionTasks[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "cancelled"
                guard case .success(let output) = result else { return false }
                let conversionTasks = output.conversionTasks
                let projection: [EC2ClientTypes.ConversionTaskState]? = conversionTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "cancelled") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeConversionTasksInput, result: Result<DescribeConversionTasksOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ConversionTasks[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "cancelling"
                guard case .success(let output) = result else { return false }
                let conversionTasks = output.conversionTasks
                let projection: [EC2ClientTypes.ConversionTaskState]? = conversionTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "cancelling") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ConversionTaskCompleted event on the describeConversionTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeConversionTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilConversionTaskCompleted(options: WaiterOptions, input: DescribeConversionTasksInput) async throws -> WaiterOutcome<DescribeConversionTasksOutputResponse> {
        let waiter = Waiter(config: try Self.conversionTaskCompletedWaiterConfig(), operation: self.describeConversionTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func conversionTaskDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeConversionTasksInput, result: Result<DescribeConversionTasksOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ConversionTasks[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let conversionTasks = output.conversionTasks
                let projection: [EC2ClientTypes.ConversionTaskState]? = conversionTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "deleted") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeConversionTasksInput, DescribeConversionTasksOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ConversionTaskDeleted event on the describeConversionTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeConversionTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilConversionTaskDeleted(options: WaiterOptions, input: DescribeConversionTasksInput) async throws -> WaiterOutcome<DescribeConversionTasksOutputResponse> {
        let waiter = Waiter(config: try Self.conversionTaskDeletedWaiterConfig(), operation: self.describeConversionTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func customerGatewayAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeCustomerGatewaysInput, DescribeCustomerGatewaysOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeCustomerGatewaysInput, DescribeCustomerGatewaysOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeCustomerGatewaysInput, result: Result<DescribeCustomerGatewaysOutputResponse, Error>) -> Bool in
                // JMESPath expression: "CustomerGateways[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let customerGateways = output.customerGateways
                let projection: [Swift.String]? = customerGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeCustomerGatewaysInput, result: Result<DescribeCustomerGatewaysOutputResponse, Error>) -> Bool in
                // JMESPath expression: "CustomerGateways[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let customerGateways = output.customerGateways
                let projection: [Swift.String]? = customerGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleted") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeCustomerGatewaysInput, result: Result<DescribeCustomerGatewaysOutputResponse, Error>) -> Bool in
                // JMESPath expression: "CustomerGateways[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleting"
                guard case .success(let output) = result else { return false }
                let customerGateways = output.customerGateways
                let projection: [Swift.String]? = customerGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleting") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeCustomerGatewaysInput, DescribeCustomerGatewaysOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the CustomerGatewayAvailable event on the describeCustomerGateways operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeCustomerGatewaysInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilCustomerGatewayAvailable(options: WaiterOptions, input: DescribeCustomerGatewaysInput) async throws -> WaiterOutcome<DescribeCustomerGatewaysOutputResponse> {
        let waiter = Waiter(config: try Self.customerGatewayAvailableWaiterConfig(), operation: self.describeCustomerGateways(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func exportTaskCancelledWaiterConfig() throws -> WaiterConfiguration<DescribeExportTasksInput, DescribeExportTasksOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeExportTasksInput, DescribeExportTasksOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeExportTasksInput, result: Result<DescribeExportTasksOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ExportTasks[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "cancelled"
                guard case .success(let output) = result else { return false }
                let exportTasks = output.exportTasks
                let projection: [EC2ClientTypes.ExportTaskState]? = exportTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "cancelled") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeExportTasksInput, DescribeExportTasksOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ExportTaskCancelled event on the describeExportTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeExportTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilExportTaskCancelled(options: WaiterOptions, input: DescribeExportTasksInput) async throws -> WaiterOutcome<DescribeExportTasksOutputResponse> {
        let waiter = Waiter(config: try Self.exportTaskCancelledWaiterConfig(), operation: self.describeExportTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func exportTaskCompletedWaiterConfig() throws -> WaiterConfiguration<DescribeExportTasksInput, DescribeExportTasksOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeExportTasksInput, DescribeExportTasksOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeExportTasksInput, result: Result<DescribeExportTasksOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ExportTasks[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "completed"
                guard case .success(let output) = result else { return false }
                let exportTasks = output.exportTasks
                let projection: [EC2ClientTypes.ExportTaskState]? = exportTasks?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "completed") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeExportTasksInput, DescribeExportTasksOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ExportTaskCompleted event on the describeExportTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeExportTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilExportTaskCompleted(options: WaiterOptions, input: DescribeExportTasksInput) async throws -> WaiterOutcome<DescribeExportTasksOutputResponse> {
        let waiter = Waiter(config: try Self.exportTaskCompletedWaiterConfig(), operation: self.describeExportTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func imageAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeImagesInput, DescribeImagesOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeImagesInput, DescribeImagesOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeImagesInput, result: Result<DescribeImagesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Images[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let images = output.images
                let projection: [EC2ClientTypes.ImageState]? = images?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeImagesInput, result: Result<DescribeImagesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Images[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "failed"
                guard case .success(let output) = result else { return false }
                let images = output.images
                let projection: [EC2ClientTypes.ImageState]? = images?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "failed") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeImagesInput, DescribeImagesOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ImageAvailable event on the describeImages operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeImagesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilImageAvailable(options: WaiterOptions, input: DescribeImagesInput) async throws -> WaiterOutcome<DescribeImagesOutputResponse> {
        let waiter = Waiter(config: try Self.imageAvailableWaiterConfig(), operation: self.describeImages(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func imageExistsWaiterConfig() throws -> WaiterConfiguration<DescribeImagesInput, DescribeImagesOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeImagesInput, DescribeImagesOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeImagesInput, result: Result<DescribeImagesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "length(Images[]) > `0`"
                // JMESPath comparator: "booleanEquals"
                // JMESPath expected value: "true"
                guard case .success(let output) = result else { return false }
                let images = output.images
                let count = Double(images?.count ?? 0)
                let number = Double(0.0)
                let comparison = JMESUtils.compare(count, >, number)
                return JMESUtils.compare(comparison, ==, true)
            }),
            .init(state: .retry, matcher: { (input: DescribeImagesInput, result: Result<DescribeImagesOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "InvalidAMIID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeImagesInput, DescribeImagesOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ImageExists event on the describeImages operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeImagesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilImageExists(options: WaiterOptions, input: DescribeImagesInput) async throws -> WaiterOutcome<DescribeImagesOutputResponse> {
        let waiter = Waiter(config: try Self.imageExistsWaiterConfig(), operation: self.describeImages(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func snapshotImportedWaiterConfig() throws -> WaiterConfiguration<DescribeImportSnapshotTasksInput, DescribeImportSnapshotTasksOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeImportSnapshotTasksInput, DescribeImportSnapshotTasksOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeImportSnapshotTasksInput, result: Result<DescribeImportSnapshotTasksOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ImportSnapshotTasks[].SnapshotTaskDetail.Status"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "completed"
                guard case .success(let output) = result else { return false }
                let importSnapshotTasks = output.importSnapshotTasks
                let projection: [Swift.String]? = importSnapshotTasks?.compactMap { original in
                    let snapshotTaskDetail = original.snapshotTaskDetail
                    let status = snapshotTaskDetail?.status
                    return status
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "completed") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeImportSnapshotTasksInput, result: Result<DescribeImportSnapshotTasksOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ImportSnapshotTasks[].SnapshotTaskDetail.Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "error"
                guard case .success(let output) = result else { return false }
                let importSnapshotTasks = output.importSnapshotTasks
                let projection: [Swift.String]? = importSnapshotTasks?.compactMap { original in
                    let snapshotTaskDetail = original.snapshotTaskDetail
                    let status = snapshotTaskDetail?.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "error") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeImportSnapshotTasksInput, DescribeImportSnapshotTasksOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SnapshotImported event on the describeImportSnapshotTasks operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeImportSnapshotTasksInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSnapshotImported(options: WaiterOptions, input: DescribeImportSnapshotTasksInput) async throws -> WaiterOutcome<DescribeImportSnapshotTasksOutputResponse> {
        let waiter = Waiter(config: try Self.snapshotImportedWaiterConfig(), operation: self.describeImportSnapshotTasks(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceExistsWaiterConfig() throws -> WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "length(Reservations[]) > `0`"
                // JMESPath comparator: "booleanEquals"
                // JMESPath expected value: "true"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let count = Double(reservations?.count ?? 0)
                let number = Double(0.0)
                let comparison = JMESUtils.compare(count, >, number)
                return JMESUtils.compare(comparison, ==, true)
            }),
            .init(state: .retry, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "InvalidInstanceID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutputResponse>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceExists event on the describeInstances operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstancesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceExists(options: WaiterOptions, input: DescribeInstancesInput) async throws -> WaiterOutcome<DescribeInstancesOutputResponse> {
        let waiter = Waiter(config: try Self.instanceExistsWaiterConfig(), operation: self.describeInstances(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceRunningWaiterConfig() throws -> WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "running"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return (projection2?.count ?? 0) > 1 && (projection2?.allSatisfy { JMESUtils.compare($0, ==, "running") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "shutting-down"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "shutting-down") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "terminated"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "terminated") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "stopping"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "stopping") }) ?? false
            }),
            .init(state: .retry, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "InvalidInstanceID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceRunning event on the describeInstances operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstancesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceRunning(options: WaiterOptions, input: DescribeInstancesInput) async throws -> WaiterOutcome<DescribeInstancesOutputResponse> {
        let waiter = Waiter(config: try Self.instanceRunningWaiterConfig(), operation: self.describeInstances(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceStoppedWaiterConfig() throws -> WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "stopped"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return (projection2?.count ?? 0) > 1 && (projection2?.allSatisfy { JMESUtils.compare($0, ==, "stopped") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "pending"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "pending") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "terminated"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "terminated") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceStopped event on the describeInstances operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstancesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceStopped(options: WaiterOptions, input: DescribeInstancesInput) async throws -> WaiterOutcome<DescribeInstancesOutputResponse> {
        let waiter = Waiter(config: try Self.instanceStoppedWaiterConfig(), operation: self.describeInstances(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceTerminatedWaiterConfig() throws -> WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "terminated"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return (projection2?.count ?? 0) > 1 && (projection2?.allSatisfy { JMESUtils.compare($0, ==, "terminated") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "pending"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "pending") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Reservations[].Instances[].State.Name"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "stopping"
                guard case .success(let output) = result else { return false }
                let reservations = output.reservations
                let projection: [[EC2ClientTypes.Instance]]? = reservations?.compactMap { original in
                    let instances = original.instances
                    return instances
                }
                let flattened = projection?.flatMap { $0 }
                let projection2: [EC2ClientTypes.InstanceStateName]? = flattened?.compactMap { original in
                    let state = original.state
                    let name = state?.name
                    return name
                }
                return projection2?.contains(where: { JMESUtils.compare($0, ==, "stopping") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceTerminated event on the describeInstances operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstancesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceTerminated(options: WaiterOptions, input: DescribeInstancesInput) async throws -> WaiterOutcome<DescribeInstancesOutputResponse> {
        let waiter = Waiter(config: try Self.instanceTerminatedWaiterConfig(), operation: self.describeInstances(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceStatusOkWaiterConfig() throws -> WaiterConfiguration<DescribeInstanceStatusInput, DescribeInstanceStatusOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeInstanceStatusInput, DescribeInstanceStatusOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstanceStatusInput, result: Result<DescribeInstanceStatusOutputResponse, Error>) -> Bool in
                // JMESPath expression: "InstanceStatuses[].InstanceStatus.Status"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "ok"
                guard case .success(let output) = result else { return false }
                let instanceStatuses = output.instanceStatuses
                let projection: [EC2ClientTypes.SummaryStatus]? = instanceStatuses?.compactMap { original in
                    let instanceStatus = original.instanceStatus
                    let status = instanceStatus?.status
                    return status
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "ok") } ?? false)
            }),
            .init(state: .retry, matcher: { (input: DescribeInstanceStatusInput, result: Result<DescribeInstanceStatusOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "InvalidInstanceID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeInstanceStatusInput, DescribeInstanceStatusOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceStatusOk event on the describeInstanceStatus operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstanceStatusInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceStatusOk(options: WaiterOptions, input: DescribeInstanceStatusInput) async throws -> WaiterOutcome<DescribeInstanceStatusOutputResponse> {
        let waiter = Waiter(config: try Self.instanceStatusOkWaiterConfig(), operation: self.describeInstanceStatus(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func systemStatusOkWaiterConfig() throws -> WaiterConfiguration<DescribeInstanceStatusInput, DescribeInstanceStatusOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeInstanceStatusInput, DescribeInstanceStatusOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstanceStatusInput, result: Result<DescribeInstanceStatusOutputResponse, Error>) -> Bool in
                // JMESPath expression: "InstanceStatuses[].SystemStatus.Status"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "ok"
                guard case .success(let output) = result else { return false }
                let instanceStatuses = output.instanceStatuses
                let projection: [EC2ClientTypes.SummaryStatus]? = instanceStatuses?.compactMap { original in
                    let systemStatus = original.systemStatus
                    let status = systemStatus?.status
                    return status
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "ok") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeInstanceStatusInput, DescribeInstanceStatusOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SystemStatusOk event on the describeInstanceStatus operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstanceStatusInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSystemStatusOk(options: WaiterOptions, input: DescribeInstanceStatusInput) async throws -> WaiterOutcome<DescribeInstanceStatusOutputResponse> {
        let waiter = Waiter(config: try Self.systemStatusOkWaiterConfig(), operation: self.describeInstanceStatus(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func internetGatewayExistsWaiterConfig() throws -> WaiterConfiguration<DescribeInternetGatewaysInput, DescribeInternetGatewaysOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeInternetGatewaysInput, DescribeInternetGatewaysOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInternetGatewaysInput, result: Result<DescribeInternetGatewaysOutputResponse, Error>) -> Bool in
                // JMESPath expression: "length(InternetGateways[].InternetGatewayId) > `0`"
                // JMESPath comparator: "booleanEquals"
                // JMESPath expected value: "true"
                guard case .success(let output) = result else { return false }
                let internetGateways = output.internetGateways
                let projection: [Swift.String]? = internetGateways?.compactMap { original in
                    let internetGatewayId = original.internetGatewayId
                    return internetGatewayId
                }
                let count = Double(projection?.count ?? 0)
                let number = Double(0.0)
                let comparison = JMESUtils.compare(count, >, number)
                return JMESUtils.compare(comparison, ==, true)
            }),
            .init(state: .retry, matcher: { (input: DescribeInternetGatewaysInput, result: Result<DescribeInternetGatewaysOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "InvalidInternetGateway.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeInternetGatewaysInput, DescribeInternetGatewaysOutputResponse>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InternetGatewayExists event on the describeInternetGateways operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInternetGatewaysInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInternetGatewayExists(options: WaiterOptions, input: DescribeInternetGatewaysInput) async throws -> WaiterOutcome<DescribeInternetGatewaysOutputResponse> {
        let waiter = Waiter(config: try Self.internetGatewayExistsWaiterConfig(), operation: self.describeInternetGateways(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func keyPairExistsWaiterConfig() throws -> WaiterConfiguration<DescribeKeyPairsInput, DescribeKeyPairsOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeKeyPairsInput, DescribeKeyPairsOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeKeyPairsInput, result: Result<DescribeKeyPairsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "length(KeyPairs[].KeyName) > `0`"
                // JMESPath comparator: "booleanEquals"
                // JMESPath expected value: "true"
                guard case .success(let output) = result else { return false }
                let keyPairs = output.keyPairs
                let projection: [Swift.String]? = keyPairs?.compactMap { original in
                    let keyName = original.keyName
                    return keyName
                }
                let count = Double(projection?.count ?? 0)
                let number = Double(0.0)
                let comparison = JMESUtils.compare(count, >, number)
                return JMESUtils.compare(comparison, ==, true)
            }),
            .init(state: .retry, matcher: { (input: DescribeKeyPairsInput, result: Result<DescribeKeyPairsOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "InvalidKeyPair.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeKeyPairsInput, DescribeKeyPairsOutputResponse>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the KeyPairExists event on the describeKeyPairs operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeKeyPairsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilKeyPairExists(options: WaiterOptions, input: DescribeKeyPairsInput) async throws -> WaiterOutcome<DescribeKeyPairsOutputResponse> {
        let waiter = Waiter(config: try Self.keyPairExistsWaiterConfig(), operation: self.describeKeyPairs(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func natGatewayAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeNatGatewaysInput, DescribeNatGatewaysOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeNatGatewaysInput, DescribeNatGatewaysOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutputResponse, Error>) -> Bool in
                // JMESPath expression: "NatGateways[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let natGateways = output.natGateways
                let projection: [EC2ClientTypes.NatGatewayState]? = natGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutputResponse, Error>) -> Bool in
                // JMESPath expression: "NatGateways[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "failed"
                guard case .success(let output) = result else { return false }
                let natGateways = output.natGateways
                let projection: [EC2ClientTypes.NatGatewayState]? = natGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "failed") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutputResponse, Error>) -> Bool in
                // JMESPath expression: "NatGateways[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleting"
                guard case .success(let output) = result else { return false }
                let natGateways = output.natGateways
                let projection: [EC2ClientTypes.NatGatewayState]? = natGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleting") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutputResponse, Error>) -> Bool in
                // JMESPath expression: "NatGateways[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let natGateways = output.natGateways
                let projection: [EC2ClientTypes.NatGatewayState]? = natGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleted") }) ?? false
            }),
            .init(state: .retry, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "NatGatewayNotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeNatGatewaysInput, DescribeNatGatewaysOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the NatGatewayAvailable event on the describeNatGateways operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeNatGatewaysInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilNatGatewayAvailable(options: WaiterOptions, input: DescribeNatGatewaysInput) async throws -> WaiterOutcome<DescribeNatGatewaysOutputResponse> {
        let waiter = Waiter(config: try Self.natGatewayAvailableWaiterConfig(), operation: self.describeNatGateways(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func natGatewayDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeNatGatewaysInput, DescribeNatGatewaysOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeNatGatewaysInput, DescribeNatGatewaysOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutputResponse, Error>) -> Bool in
                // JMESPath expression: "NatGateways[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let natGateways = output.natGateways
                let projection: [EC2ClientTypes.NatGatewayState]? = natGateways?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "deleted") } ?? false)
            }),
            .init(state: .success, matcher: { (input: DescribeNatGatewaysInput, result: Result<DescribeNatGatewaysOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "NatGatewayNotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeNatGatewaysInput, DescribeNatGatewaysOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the NatGatewayDeleted event on the describeNatGateways operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeNatGatewaysInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilNatGatewayDeleted(options: WaiterOptions, input: DescribeNatGatewaysInput) async throws -> WaiterOutcome<DescribeNatGatewaysOutputResponse> {
        let waiter = Waiter(config: try Self.natGatewayDeletedWaiterConfig(), operation: self.describeNatGateways(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func networkInterfaceAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeNetworkInterfacesInput, DescribeNetworkInterfacesOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeNetworkInterfacesInput, DescribeNetworkInterfacesOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeNetworkInterfacesInput, result: Result<DescribeNetworkInterfacesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "NetworkInterfaces[].Status"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let networkInterfaces = output.networkInterfaces
                let projection: [EC2ClientTypes.NetworkInterfaceStatus]? = networkInterfaces?.compactMap { original in
                    let status = original.status
                    return status
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeNetworkInterfacesInput, result: Result<DescribeNetworkInterfacesOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "InvalidNetworkInterfaceID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeNetworkInterfacesInput, DescribeNetworkInterfacesOutputResponse>(acceptors: acceptors, minDelay: 20.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the NetworkInterfaceAvailable event on the describeNetworkInterfaces operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeNetworkInterfacesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilNetworkInterfaceAvailable(options: WaiterOptions, input: DescribeNetworkInterfacesInput) async throws -> WaiterOutcome<DescribeNetworkInterfacesOutputResponse> {
        let waiter = Waiter(config: try Self.networkInterfaceAvailableWaiterConfig(), operation: self.describeNetworkInterfaces(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func securityGroupExistsWaiterConfig() throws -> WaiterConfiguration<DescribeSecurityGroupsInput, DescribeSecurityGroupsOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeSecurityGroupsInput, DescribeSecurityGroupsOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeSecurityGroupsInput, result: Result<DescribeSecurityGroupsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "length(SecurityGroups[].GroupId) > `0`"
                // JMESPath comparator: "booleanEquals"
                // JMESPath expected value: "true"
                guard case .success(let output) = result else { return false }
                let securityGroups = output.securityGroups
                let projection: [Swift.String]? = securityGroups?.compactMap { original in
                    let groupId = original.groupId
                    return groupId
                }
                let count = Double(projection?.count ?? 0)
                let number = Double(0.0)
                let comparison = JMESUtils.compare(count, >, number)
                return JMESUtils.compare(comparison, ==, true)
            }),
            .init(state: .retry, matcher: { (input: DescribeSecurityGroupsInput, result: Result<DescribeSecurityGroupsOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "InvalidGroup.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeSecurityGroupsInput, DescribeSecurityGroupsOutputResponse>(acceptors: acceptors, minDelay: 5.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SecurityGroupExists event on the describeSecurityGroups operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeSecurityGroupsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSecurityGroupExists(options: WaiterOptions, input: DescribeSecurityGroupsInput) async throws -> WaiterOutcome<DescribeSecurityGroupsOutputResponse> {
        let waiter = Waiter(config: try Self.securityGroupExistsWaiterConfig(), operation: self.describeSecurityGroups(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func snapshotCompletedWaiterConfig() throws -> WaiterConfiguration<DescribeSnapshotsInput, DescribeSnapshotsOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeSnapshotsInput, DescribeSnapshotsOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeSnapshotsInput, result: Result<DescribeSnapshotsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Snapshots[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "completed"
                guard case .success(let output) = result else { return false }
                let snapshots = output.snapshots
                let projection: [EC2ClientTypes.SnapshotState]? = snapshots?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "completed") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeSnapshotsInput, result: Result<DescribeSnapshotsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Snapshots[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "error"
                guard case .success(let output) = result else { return false }
                let snapshots = output.snapshots
                let projection: [EC2ClientTypes.SnapshotState]? = snapshots?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "error") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeSnapshotsInput, DescribeSnapshotsOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SnapshotCompleted event on the describeSnapshots operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeSnapshotsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSnapshotCompleted(options: WaiterOptions, input: DescribeSnapshotsInput) async throws -> WaiterOutcome<DescribeSnapshotsOutputResponse> {
        let waiter = Waiter(config: try Self.snapshotCompletedWaiterConfig(), operation: self.describeSnapshots(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func spotInstanceRequestFulfilledWaiterConfig() throws -> WaiterConfiguration<DescribeSpotInstanceRequestsInput, DescribeSpotInstanceRequestsOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeSpotInstanceRequestsInput, DescribeSpotInstanceRequestsOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "SpotInstanceRequests[].Status.Code"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "fulfilled"
                guard case .success(let output) = result else { return false }
                let spotInstanceRequests = output.spotInstanceRequests
                let projection: [Swift.String]? = spotInstanceRequests?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "fulfilled") } ?? false)
            }),
            .init(state: .success, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "SpotInstanceRequests[].Status.Code"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "request-canceled-and-instance-running"
                guard case .success(let output) = result else { return false }
                let spotInstanceRequests = output.spotInstanceRequests
                let projection: [Swift.String]? = spotInstanceRequests?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "request-canceled-and-instance-running") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "SpotInstanceRequests[].Status.Code"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "schedule-expired"
                guard case .success(let output) = result else { return false }
                let spotInstanceRequests = output.spotInstanceRequests
                let projection: [Swift.String]? = spotInstanceRequests?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "schedule-expired") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "SpotInstanceRequests[].Status.Code"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "canceled-before-fulfillment"
                guard case .success(let output) = result else { return false }
                let spotInstanceRequests = output.spotInstanceRequests
                let projection: [Swift.String]? = spotInstanceRequests?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "canceled-before-fulfillment") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "SpotInstanceRequests[].Status.Code"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "bad-parameters"
                guard case .success(let output) = result else { return false }
                let spotInstanceRequests = output.spotInstanceRequests
                let projection: [Swift.String]? = spotInstanceRequests?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "bad-parameters") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "SpotInstanceRequests[].Status.Code"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "system-error"
                guard case .success(let output) = result else { return false }
                let spotInstanceRequests = output.spotInstanceRequests
                let projection: [Swift.String]? = spotInstanceRequests?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "system-error") }) ?? false
            }),
            .init(state: .retry, matcher: { (input: DescribeSpotInstanceRequestsInput, result: Result<DescribeSpotInstanceRequestsOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "InvalidSpotInstanceRequestID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeSpotInstanceRequestsInput, DescribeSpotInstanceRequestsOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SpotInstanceRequestFulfilled event on the describeSpotInstanceRequests operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeSpotInstanceRequestsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSpotInstanceRequestFulfilled(options: WaiterOptions, input: DescribeSpotInstanceRequestsInput) async throws -> WaiterOutcome<DescribeSpotInstanceRequestsOutputResponse> {
        let waiter = Waiter(config: try Self.spotInstanceRequestFulfilledWaiterConfig(), operation: self.describeSpotInstanceRequests(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func subnetAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeSubnetsInput, DescribeSubnetsOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeSubnetsInput, DescribeSubnetsOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeSubnetsInput, result: Result<DescribeSubnetsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Subnets[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let subnets = output.subnets
                let projection: [EC2ClientTypes.SubnetState]? = subnets?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeSubnetsInput, DescribeSubnetsOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SubnetAvailable event on the describeSubnets operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeSubnetsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSubnetAvailable(options: WaiterOptions, input: DescribeSubnetsInput) async throws -> WaiterOutcome<DescribeSubnetsOutputResponse> {
        let waiter = Waiter(config: try Self.subnetAvailableWaiterConfig(), operation: self.describeSubnets(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func volumeAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVolumesInput, result: Result<DescribeVolumesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Volumes[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let volumes = output.volumes
                let projection: [EC2ClientTypes.VolumeState]? = volumes?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeVolumesInput, result: Result<DescribeVolumesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Volumes[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let volumes = output.volumes
                let projection: [EC2ClientTypes.VolumeState]? = volumes?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleted") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VolumeAvailable event on the describeVolumes operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVolumesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVolumeAvailable(options: WaiterOptions, input: DescribeVolumesInput) async throws -> WaiterOutcome<DescribeVolumesOutputResponse> {
        let waiter = Waiter(config: try Self.volumeAvailableWaiterConfig(), operation: self.describeVolumes(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func volumeDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVolumesInput, result: Result<DescribeVolumesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Volumes[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let volumes = output.volumes
                let projection: [EC2ClientTypes.VolumeState]? = volumes?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "deleted") } ?? false)
            }),
            .init(state: .success, matcher: { (input: DescribeVolumesInput, result: Result<DescribeVolumesOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "InvalidVolume.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VolumeDeleted event on the describeVolumes operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVolumesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVolumeDeleted(options: WaiterOptions, input: DescribeVolumesInput) async throws -> WaiterOutcome<DescribeVolumesOutputResponse> {
        let waiter = Waiter(config: try Self.volumeDeletedWaiterConfig(), operation: self.describeVolumes(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func volumeInUseWaiterConfig() throws -> WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVolumesInput, result: Result<DescribeVolumesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Volumes[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "in-use"
                guard case .success(let output) = result else { return false }
                let volumes = output.volumes
                let projection: [EC2ClientTypes.VolumeState]? = volumes?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "in-use") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeVolumesInput, result: Result<DescribeVolumesOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Volumes[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let volumes = output.volumes
                let projection: [EC2ClientTypes.VolumeState]? = volumes?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleted") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeVolumesInput, DescribeVolumesOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VolumeInUse event on the describeVolumes operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVolumesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVolumeInUse(options: WaiterOptions, input: DescribeVolumesInput) async throws -> WaiterOutcome<DescribeVolumesOutputResponse> {
        let waiter = Waiter(config: try Self.volumeInUseWaiterConfig(), operation: self.describeVolumes(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func vpcPeeringConnectionDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVpcPeeringConnectionsInput, result: Result<DescribeVpcPeeringConnectionsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "VpcPeeringConnections[].Status.Code"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let vpcPeeringConnections = output.vpcPeeringConnections
                let projection: [EC2ClientTypes.VpcPeeringConnectionStateReasonCode]? = vpcPeeringConnections?.compactMap { original in
                    let status = original.status
                    let code = status?.code
                    return code
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "deleted") } ?? false)
            }),
            .init(state: .success, matcher: { (input: DescribeVpcPeeringConnectionsInput, result: Result<DescribeVpcPeeringConnectionsOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "InvalidVpcPeeringConnectionID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VpcPeeringConnectionDeleted event on the describeVpcPeeringConnections operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVpcPeeringConnectionsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVpcPeeringConnectionDeleted(options: WaiterOptions, input: DescribeVpcPeeringConnectionsInput) async throws -> WaiterOutcome<DescribeVpcPeeringConnectionsOutputResponse> {
        let waiter = Waiter(config: try Self.vpcPeeringConnectionDeletedWaiterConfig(), operation: self.describeVpcPeeringConnections(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func vpcPeeringConnectionExistsWaiterConfig() throws -> WaiterConfiguration<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVpcPeeringConnectionsInput, result: Result<DescribeVpcPeeringConnectionsOutputResponse, Error>) -> Bool in
                switch result {
                    case .success: return true
                    case .failure: return false
                }
            }),
            .init(state: .retry, matcher: { (input: DescribeVpcPeeringConnectionsInput, result: Result<DescribeVpcPeeringConnectionsOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "InvalidVpcPeeringConnectionID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeVpcPeeringConnectionsInput, DescribeVpcPeeringConnectionsOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VpcPeeringConnectionExists event on the describeVpcPeeringConnections operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVpcPeeringConnectionsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVpcPeeringConnectionExists(options: WaiterOptions, input: DescribeVpcPeeringConnectionsInput) async throws -> WaiterOutcome<DescribeVpcPeeringConnectionsOutputResponse> {
        let waiter = Waiter(config: try Self.vpcPeeringConnectionExistsWaiterConfig(), operation: self.describeVpcPeeringConnections(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func vpcAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeVpcsInput, DescribeVpcsOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeVpcsInput, DescribeVpcsOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVpcsInput, result: Result<DescribeVpcsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "Vpcs[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let vpcs = output.vpcs
                let projection: [EC2ClientTypes.VpcState]? = vpcs?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
        ]
        return try WaiterConfiguration<DescribeVpcsInput, DescribeVpcsOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VpcAvailable event on the describeVpcs operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVpcsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVpcAvailable(options: WaiterOptions, input: DescribeVpcsInput) async throws -> WaiterOutcome<DescribeVpcsOutputResponse> {
        let waiter = Waiter(config: try Self.vpcAvailableWaiterConfig(), operation: self.describeVpcs(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func vpcExistsWaiterConfig() throws -> WaiterConfiguration<DescribeVpcsInput, DescribeVpcsOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeVpcsInput, DescribeVpcsOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVpcsInput, result: Result<DescribeVpcsOutputResponse, Error>) -> Bool in
                switch result {
                    case .success: return true
                    case .failure: return false
                }
            }),
            .init(state: .retry, matcher: { (input: DescribeVpcsInput, result: Result<DescribeVpcsOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "InvalidVpcID.NotFound"
            }),
        ]
        return try WaiterConfiguration<DescribeVpcsInput, DescribeVpcsOutputResponse>(acceptors: acceptors, minDelay: 1.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VpcExists event on the describeVpcs operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVpcsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVpcExists(options: WaiterOptions, input: DescribeVpcsInput) async throws -> WaiterOutcome<DescribeVpcsOutputResponse> {
        let waiter = Waiter(config: try Self.vpcExistsWaiterConfig(), operation: self.describeVpcs(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func vpnConnectionAvailableWaiterConfig() throws -> WaiterConfiguration<DescribeVpnConnectionsInput, DescribeVpnConnectionsOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeVpnConnectionsInput, DescribeVpnConnectionsOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVpnConnectionsInput, result: Result<DescribeVpnConnectionsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "VpnConnections[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "available"
                guard case .success(let output) = result else { return false }
                let vpnConnections = output.vpnConnections
                let projection: [EC2ClientTypes.VpnState]? = vpnConnections?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "available") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeVpnConnectionsInput, result: Result<DescribeVpnConnectionsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "VpnConnections[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleting"
                guard case .success(let output) = result else { return false }
                let vpnConnections = output.vpnConnections
                let projection: [EC2ClientTypes.VpnState]? = vpnConnections?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleting") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeVpnConnectionsInput, result: Result<DescribeVpnConnectionsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "VpnConnections[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let vpnConnections = output.vpnConnections
                let projection: [EC2ClientTypes.VpnState]? = vpnConnections?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "deleted") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeVpnConnectionsInput, DescribeVpnConnectionsOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VpnConnectionAvailable event on the describeVpnConnections operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVpnConnectionsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVpnConnectionAvailable(options: WaiterOptions, input: DescribeVpnConnectionsInput) async throws -> WaiterOutcome<DescribeVpnConnectionsOutputResponse> {
        let waiter = Waiter(config: try Self.vpnConnectionAvailableWaiterConfig(), operation: self.describeVpnConnections(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func vpnConnectionDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeVpnConnectionsInput, DescribeVpnConnectionsOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeVpnConnectionsInput, DescribeVpnConnectionsOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeVpnConnectionsInput, result: Result<DescribeVpnConnectionsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "VpnConnections[].State"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "deleted"
                guard case .success(let output) = result else { return false }
                let vpnConnections = output.vpnConnections
                let projection: [EC2ClientTypes.VpnState]? = vpnConnections?.compactMap { original in
                    let state = original.state
                    return state
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "deleted") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeVpnConnectionsInput, result: Result<DescribeVpnConnectionsOutputResponse, Error>) -> Bool in
                // JMESPath expression: "VpnConnections[].State"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "pending"
                guard case .success(let output) = result else { return false }
                let vpnConnections = output.vpnConnections
                let projection: [EC2ClientTypes.VpnState]? = vpnConnections?.compactMap { original in
                    let state = original.state
                    return state
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "pending") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeVpnConnectionsInput, DescribeVpnConnectionsOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the VpnConnectionDeleted event on the describeVpnConnections operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeVpnConnectionsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilVpnConnectionDeleted(options: WaiterOptions, input: DescribeVpnConnectionsInput) async throws -> WaiterOutcome<DescribeVpnConnectionsOutputResponse> {
        let waiter = Waiter(config: try Self.vpnConnectionDeletedWaiterConfig(), operation: self.describeVpnConnections(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func passwordDataAvailableWaiterConfig() throws -> WaiterConfiguration<GetPasswordDataInput, GetPasswordDataOutputResponse> {
        let acceptors: [WaiterConfiguration<GetPasswordDataInput, GetPasswordDataOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetPasswordDataInput, result: Result<GetPasswordDataOutputResponse, Error>) -> Bool in
                // JMESPath expression: "length(PasswordData) > `0`"
                // JMESPath comparator: "booleanEquals"
                // JMESPath expected value: "true"
                guard case .success(let output) = result else { return false }
                let passwordData = output.passwordData
                let count = Double(passwordData?.count ?? 0)
                let number = Double(0.0)
                let comparison = JMESUtils.compare(count, >, number)
                return JMESUtils.compare(comparison, ==, true)
            }),
        ]
        return try WaiterConfiguration<GetPasswordDataInput, GetPasswordDataOutputResponse>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the PasswordDataAvailable event on the getPasswordData operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetPasswordDataInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilPasswordDataAvailable(options: WaiterOptions, input: GetPasswordDataInput) async throws -> WaiterOutcome<GetPasswordDataOutputResponse> {
        let waiter = Waiter(config: try Self.passwordDataAvailableWaiterConfig(), operation: self.getPasswordData(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }
}
