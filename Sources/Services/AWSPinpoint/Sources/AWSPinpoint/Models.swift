//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension PinpointClientTypes {

    public enum __EndpointTypesElement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case adm
        case apns
        case apnsSandbox
        case apnsVoip
        case apnsVoipSandbox
        case baidu
        case custom
        case email
        case gcm
        case inApp
        case push
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [__EndpointTypesElement] {
            return [
                .adm,
                .apns,
                .apnsSandbox,
                .apnsVoip,
                .apnsVoipSandbox,
                .baidu,
                .custom,
                .email,
                .gcm,
                .inApp,
                .push,
                .sms,
                .voice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .adm: return "ADM"
            case .apns: return "APNS"
            case .apnsSandbox: return "APNS_SANDBOX"
            case .apnsVoip: return "APNS_VOIP"
            case .apnsVoipSandbox: return "APNS_VOIP_SANDBOX"
            case .baidu: return "BAIDU"
            case .custom: return "CUSTOM"
            case .email: return "EMAIL"
            case .gcm: return "GCM"
            case .inApp: return "IN_APP"
            case .push: return "PUSH"
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    public enum __TimezoneEstimationMethodsElement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case phoneNumber
        case postalCode
        case sdkUnknown(Swift.String)

        public static var allCases: [__TimezoneEstimationMethodsElement] {
            return [
                .phoneNumber,
                .postalCode
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .phoneNumber: return "PHONE_NUMBER"
            case .postalCode: return "POSTAL_CODE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    public enum Action: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deepLink
        case openApp
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [Action] {
            return [
                .deepLink,
                .openApp,
                .url
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deepLink: return "DEEP_LINK"
            case .openApp: return "OPEN_APP"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about an activity that was performed by a campaign.
    public struct ActivityResponse: Swift.Sendable {
        /// The unique identifier for the application that the campaign applies to.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The unique identifier for the campaign that the activity applies to.
        /// This member is required.
        public var campaignId: Swift.String?
        /// The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.
        public var end: Swift.String?
        /// A JSON object that contains metrics relating to the campaign execution for this campaign activity. For information about the structure and contents of the results, see [Standard Amazon Pinpoint analytics metrics](https://docs.aws.amazon.com//pinpoint/latest/developerguide/analytics-standard-metrics.html) in the Amazon Pinpoint Developer Guide.
        public var executionMetrics: [Swift.String: Swift.String]?
        /// The unique identifier for the activity.
        /// This member is required.
        public var id: Swift.String?
        /// Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.
        public var result: Swift.String?
        /// The scheduled start time, in ISO 8601 format, for the activity.
        public var scheduledStart: Swift.String?
        /// The actual start time, in ISO 8601 format, of the activity.
        public var start: Swift.String?
        /// The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.
        public var state: Swift.String?
        /// The total number of endpoints that the campaign successfully delivered messages to.
        public var successfulEndpointCount: Swift.Int?
        /// The total number of time zones that were completed.
        public var timezonesCompletedCount: Swift.Int?
        /// The total number of unique time zones that are in the segment for the campaign.
        public var timezonesTotalCount: Swift.Int?
        /// The total number of endpoints that the campaign attempted to deliver messages to.
        public var totalEndpointCount: Swift.Int?
        /// The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.
        public var treatmentId: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            campaignId: Swift.String? = nil,
            end: Swift.String? = nil,
            executionMetrics: [Swift.String: Swift.String]? = nil,
            id: Swift.String? = nil,
            result: Swift.String? = nil,
            scheduledStart: Swift.String? = nil,
            start: Swift.String? = nil,
            state: Swift.String? = nil,
            successfulEndpointCount: Swift.Int? = nil,
            timezonesCompletedCount: Swift.Int? = nil,
            timezonesTotalCount: Swift.Int? = nil,
            totalEndpointCount: Swift.Int? = nil,
            treatmentId: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.end = end
            self.executionMetrics = executionMetrics
            self.id = id
            self.result = result
            self.scheduledStart = scheduledStart
            self.start = start
            self.state = state
            self.successfulEndpointCount = successfulEndpointCount
            self.timezonesCompletedCount = timezonesCompletedCount
            self.timezonesTotalCount = timezonesTotalCount
            self.totalEndpointCount = totalEndpointCount
            self.treatmentId = treatmentId
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the activities that were performed by a campaign.
    public struct ActivitiesResponse: Swift.Sendable {
        /// An array of responses, one for each activity that was performed by the campaign.
        /// This member is required.
        public var item: [PinpointClientTypes.ActivityResponse]?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public var nextToken: Swift.String?

        public init(
            item: [PinpointClientTypes.ActivityResponse]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.item = item
            self.nextToken = nextToken
        }
    }
}

extension PinpointClientTypes {

    public enum AttributeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case after
        case before
        case between
        case contains
        case exclusive
        case inclusive
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeType] {
            return [
                .after,
                .before,
                .between,
                .contains,
                .exclusive,
                .inclusive,
                .on
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .after: return "AFTER"
            case .before: return "BEFORE"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .exclusive: return "EXCLUSIVE"
            case .inclusive: return "INCLUSIVE"
            case .on: return "ON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies attribute-based criteria for including or excluding endpoints from a segment.
    public struct AttributeDimension: Swift.Sendable {
        /// The type of segment dimension to use. Valid values are:
        ///
        /// * INCLUSIVE - endpoints that have attributes matching the values are included in the segment.
        ///
        /// * EXCLUSIVE - endpoints that have attributes matching the values are excluded in the segment.
        ///
        /// * CONTAINS - endpoints that have attributes' substrings match the values are included in the segment.
        ///
        /// * BEFORE - endpoints with attributes read as ISO_INSTANT datetimes before the value are included in the segment.
        ///
        /// * AFTER - endpoints with attributes read as ISO_INSTANT datetimes after the value are included in the segment.
        ///
        /// * ON - endpoints with attributes read as ISO_INSTANT dates on the value are included in the segment. Time is ignored in this comparison.
        ///
        /// * BETWEEN - endpoints with attributes read as ISO_INSTANT datetimes between the values are included in the segment.
        public var attributeType: PinpointClientTypes.AttributeType?
        /// The criteria values to use for the segment dimension. Depending on the value of the AttributeType property, endpoints are included or excluded from the segment if their attribute values match the criteria values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            attributeType: PinpointClientTypes.AttributeType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.attributeType = attributeType
            self.values = values
        }
    }
}

extension PinpointClientTypes {

    public enum DimensionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case exclusive
        case inclusive
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionType] {
            return [
                .exclusive,
                .inclusive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .exclusive: return "EXCLUSIVE"
            case .inclusive: return "INCLUSIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the dimension type and values for a segment dimension.
    public struct SetDimension: Swift.Sendable {
        /// The type of segment dimension to use. Valid values are: INCLUSIVE, endpoints that match the criteria are included in the segment; and, EXCLUSIVE, endpoints that match the criteria are excluded from the segment.
        public var dimensionType: PinpointClientTypes.DimensionType?
        /// The criteria values to use for the segment dimension. Depending on the value of the DimensionType property, endpoints are included or excluded from the segment if their values match the criteria values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            dimensionType: PinpointClientTypes.DimensionType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.dimensionType = dimensionType
            self.values = values
        }
    }
}

extension PinpointClientTypes {

    /// Specifies metric-based criteria for including or excluding endpoints from a segment. These criteria derive from custom metrics that you define for endpoints.
    public struct MetricDimension: Swift.Sendable {
        /// The operator to use when comparing metric values. Valid values are: GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUAL, LESS_THAN_OR_EQUAL, and EQUAL.
        /// This member is required.
        public var comparisonOperator: Swift.String?
        /// The value to compare.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            comparisonOperator: Swift.String? = nil,
            value: Swift.Double? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.value = value
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the dimensions for an event filter that determines when a campaign is sent or a journey activity is performed.
    public struct EventDimensions: Swift.Sendable {
        /// One or more custom attributes that your application reports to Amazon Pinpoint. You can use these attributes as selection criteria when you create an event filter.
        public var attributes: [Swift.String: PinpointClientTypes.AttributeDimension]?
        /// The name of the event that causes the campaign to be sent or the journey activity to be performed. This can be a standard event that Amazon Pinpoint generates, such as _email.delivered. For campaigns, this can also be a custom event that's specific to your application. For information about standard events, see [Streaming Amazon Pinpoint Events](https://docs.aws.amazon.com/pinpoint/latest/developerguide/event-streams.html) in the Amazon Pinpoint Developer Guide.
        public var eventType: PinpointClientTypes.SetDimension?
        /// One or more custom metrics that your application reports to Amazon Pinpoint. You can use these metrics as selection criteria when you create an event filter.
        public var metrics: [Swift.String: PinpointClientTypes.MetricDimension]?

        public init(
            attributes: [Swift.String: PinpointClientTypes.AttributeDimension]? = nil,
            eventType: PinpointClientTypes.SetDimension? = nil,
            metrics: [Swift.String: PinpointClientTypes.MetricDimension]? = nil
        )
        {
            self.attributes = attributes
            self.eventType = eventType
            self.metrics = metrics
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the conditions to evaluate for an event that applies to an activity in a journey.
    public struct EventCondition: Swift.Sendable {
        /// The dimensions for the event filter to use for the activity.
        public var dimensions: PinpointClientTypes.EventDimensions?
        /// The message identifier (message_id) for the message to use when determining whether message events meet the condition.
        public var messageActivity: Swift.String?

        public init(
            dimensions: PinpointClientTypes.EventDimensions? = nil,
            messageActivity: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.messageActivity = messageActivity
        }
    }
}

extension PinpointClientTypes {

    /// Specifies a segment to associate with an activity in a journey.
    public struct SegmentCondition: Swift.Sendable {
        /// The unique identifier for the segment to associate with the activity.
        /// This member is required.
        public var segmentId: Swift.String?

        public init(
            segmentId: Swift.String? = nil
        )
        {
            self.segmentId = segmentId
        }
    }
}

extension PinpointClientTypes {

    public enum Duration: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case day14
        case day30
        case day7
        case hr24
        case sdkUnknown(Swift.String)

        public static var allCases: [Duration] {
            return [
                .day14,
                .day30,
                .day7,
                .hr24
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .day14: return "DAY_14"
            case .day30: return "DAY_30"
            case .day7: return "DAY_7"
            case .hr24: return "HR_24"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    public enum RecencyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [RecencyType] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies criteria for including or excluding endpoints from a segment based on how recently an endpoint was active.
    public struct RecencyDimension: Swift.Sendable {
        /// The duration to use when determining whether an endpoint is active or inactive.
        /// This member is required.
        public var duration: PinpointClientTypes.Duration?
        /// The type of recency dimension to use for the segment. Valid values are: ACTIVE, endpoints that were active within the specified duration are included in the segment; and, INACTIVE, endpoints that weren't active within the specified duration are included in the segment.
        /// This member is required.
        public var recencyType: PinpointClientTypes.RecencyType?

        public init(
            duration: PinpointClientTypes.Duration? = nil,
            recencyType: PinpointClientTypes.RecencyType? = nil
        )
        {
            self.duration = duration
            self.recencyType = recencyType
        }
    }
}

extension PinpointClientTypes {

    /// Specifies dimension settings for including or excluding endpoints from a segment based on how recently an endpoint was active.
    public struct SegmentBehaviors: Swift.Sendable {
        /// The dimension settings that are based on how recently an endpoint was active.
        public var recency: PinpointClientTypes.RecencyDimension?

        public init(
            recency: PinpointClientTypes.RecencyDimension? = nil
        )
        {
            self.recency = recency
        }
    }
}

extension PinpointClientTypes {

    /// Specifies demographic-based dimension settings for including or excluding endpoints from a segment. These settings derive from characteristics of endpoint devices, such as platform, make, and model.
    public struct SegmentDemographics: Swift.Sendable {
        /// The app version criteria for the segment.
        public var appVersion: PinpointClientTypes.SetDimension?
        /// The channel criteria for the segment.
        public var channel: PinpointClientTypes.SetDimension?
        /// The device type criteria for the segment.
        public var deviceType: PinpointClientTypes.SetDimension?
        /// The device make criteria for the segment.
        public var make: PinpointClientTypes.SetDimension?
        /// The device model criteria for the segment.
        public var model: PinpointClientTypes.SetDimension?
        /// The device platform criteria for the segment.
        public var platform: PinpointClientTypes.SetDimension?

        public init(
            appVersion: PinpointClientTypes.SetDimension? = nil,
            channel: PinpointClientTypes.SetDimension? = nil,
            deviceType: PinpointClientTypes.SetDimension? = nil,
            make: PinpointClientTypes.SetDimension? = nil,
            model: PinpointClientTypes.SetDimension? = nil,
            platform: PinpointClientTypes.SetDimension? = nil
        )
        {
            self.appVersion = appVersion
            self.channel = channel
            self.deviceType = deviceType
            self.make = make
            self.model = model
            self.platform = platform
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the GPS coordinates of a location.
    public struct GPSCoordinates: Swift.Sendable {
        /// The latitude coordinate of the location.
        /// This member is required.
        public var latitude: Swift.Double?
        /// The longitude coordinate of the location.
        /// This member is required.
        public var longitude: Swift.Double?

        public init(
            latitude: Swift.Double? = nil,
            longitude: Swift.Double? = nil
        )
        {
            self.latitude = latitude
            self.longitude = longitude
        }
    }
}

extension PinpointClientTypes {

    /// Specifies GPS-based criteria for including or excluding endpoints from a segment.
    public struct GPSPointDimension: Swift.Sendable {
        /// The GPS coordinates to measure distance from.
        /// This member is required.
        public var coordinates: PinpointClientTypes.GPSCoordinates?
        /// The range, in kilometers, from the GPS coordinates.
        public var rangeInKilometers: Swift.Double?

        public init(
            coordinates: PinpointClientTypes.GPSCoordinates? = nil,
            rangeInKilometers: Swift.Double? = nil
        )
        {
            self.coordinates = coordinates
            self.rangeInKilometers = rangeInKilometers
        }
    }
}

extension PinpointClientTypes {

    /// Specifies geographical dimension settings for a segment.
    public struct SegmentLocation: Swift.Sendable {
        /// The country or region code, in ISO 3166-1 alpha-2 format, for the segment.
        public var country: PinpointClientTypes.SetDimension?
        /// The GPS location and range for the segment.
        public var gpsPoint: PinpointClientTypes.GPSPointDimension?

        public init(
            country: PinpointClientTypes.SetDimension? = nil,
            gpsPoint: PinpointClientTypes.GPSPointDimension? = nil
        )
        {
            self.country = country
            self.gpsPoint = gpsPoint
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the dimension settings for a segment.
    public struct SegmentDimensions: Swift.Sendable {
        /// One or more custom attributes to use as criteria for the segment.
        public var attributes: [Swift.String: PinpointClientTypes.AttributeDimension]?
        /// The behavior-based criteria, such as how recently users have used your app, for the segment.
        public var behavior: PinpointClientTypes.SegmentBehaviors?
        /// The demographic-based criteria, such as device platform, for the segment.
        public var demographic: PinpointClientTypes.SegmentDemographics?
        /// The location-based criteria, such as region or GPS coordinates, for the segment.
        public var location: PinpointClientTypes.SegmentLocation?
        /// One or more custom metrics to use as criteria for the segment.
        public var metrics: [Swift.String: PinpointClientTypes.MetricDimension]?
        /// One or more custom user attributes to use as criteria for the segment.
        public var userAttributes: [Swift.String: PinpointClientTypes.AttributeDimension]?

        public init(
            attributes: [Swift.String: PinpointClientTypes.AttributeDimension]? = nil,
            behavior: PinpointClientTypes.SegmentBehaviors? = nil,
            demographic: PinpointClientTypes.SegmentDemographics? = nil,
            location: PinpointClientTypes.SegmentLocation? = nil,
            metrics: [Swift.String: PinpointClientTypes.MetricDimension]? = nil,
            userAttributes: [Swift.String: PinpointClientTypes.AttributeDimension]? = nil
        )
        {
            self.attributes = attributes
            self.behavior = behavior
            self.demographic = demographic
            self.location = location
            self.metrics = metrics
            self.userAttributes = userAttributes
        }
    }
}

extension PinpointClientTypes {

    /// Specifies a condition to evaluate for an activity in a journey.
    public struct SimpleCondition: Swift.Sendable {
        /// The dimension settings for the event that's associated with the activity.
        public var eventCondition: PinpointClientTypes.EventCondition?
        /// The segment that's associated with the activity.
        public var segmentCondition: PinpointClientTypes.SegmentCondition?
        /// The dimension settings for the segment that's associated with the activity.
        public var segmentDimensions: PinpointClientTypes.SegmentDimensions?

        public init(
            eventCondition: PinpointClientTypes.EventCondition? = nil,
            segmentCondition: PinpointClientTypes.SegmentCondition? = nil,
            segmentDimensions: PinpointClientTypes.SegmentDimensions? = nil
        )
        {
            self.eventCondition = eventCondition
            self.segmentCondition = segmentCondition
            self.segmentDimensions = segmentDimensions
        }
    }
}

extension PinpointClientTypes {

    public enum Operator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case any
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .all,
                .any
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .any: return "ANY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the conditions to evaluate for an activity in a journey, and how to evaluate those conditions.
    public struct Condition: Swift.Sendable {
        /// The conditions to evaluate for the activity.
        public var conditions: [PinpointClientTypes.SimpleCondition]?
        /// Specifies how to handle multiple conditions for the activity. For example, if you specify two conditions for an activity, whether both or only one of the conditions must be met for the activity to be performed.
        public var `operator`: PinpointClientTypes.Operator?

        public init(
            conditions: [PinpointClientTypes.SimpleCondition]? = nil,
            `operator`: PinpointClientTypes.Operator? = nil
        )
        {
            self.conditions = conditions
            self.`operator` = `operator`
        }
    }
}

extension PinpointClientTypes {

    /// Specifies a duration or a date and time that indicates when Amazon Pinpoint determines whether an activity's conditions have been met or an activity moves participants to the next activity in a journey.
    public struct WaitTime: Swift.Sendable {
        /// The amount of time to wait, as a duration in ISO 8601 format, before determining whether the activity's conditions have been met or moving participants to the next activity in the journey.
        public var waitFor: Swift.String?
        /// The date and time, in ISO 8601 format, when Amazon Pinpoint determines whether the activity's conditions have been met or the activity moves participants to the next activity in the journey.
        public var waitUntil: Swift.String?

        public init(
            waitFor: Swift.String? = nil,
            waitUntil: Swift.String? = nil
        )
        {
            self.waitFor = waitFor
            self.waitUntil = waitUntil
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a yes/no split activity in a journey. This type of activity sends participants down one of two paths in a journey, based on conditions that you specify. To create yes/no split activities that send participants down different paths based on push notification events (such as Open or Received events), your mobile app has to specify the User ID and Endpoint ID values. For more information, see [Integrating Amazon Pinpoint with your application](https://docs.aws.amazon.com/pinpoint/latest/developerguide/integrate.html) in the Amazon Pinpoint Developer Guide.
    public struct ConditionalSplitActivity: Swift.Sendable {
        /// The conditions that define the paths for the activity, and the relationship between the conditions.
        public var condition: PinpointClientTypes.Condition?
        /// The amount of time to wait before determining whether the conditions are met, or the date and time when Amazon Pinpoint determines whether the conditions are met.
        public var evaluationWaitTime: PinpointClientTypes.WaitTime?
        /// The unique identifier for the activity to perform if the conditions aren't met.
        public var falseActivity: Swift.String?
        /// The unique identifier for the activity to perform if the conditions are met.
        public var trueActivity: Swift.String?

        public init(
            condition: PinpointClientTypes.Condition? = nil,
            evaluationWaitTime: PinpointClientTypes.WaitTime? = nil,
            falseActivity: Swift.String? = nil,
            trueActivity: Swift.String? = nil
        )
        {
            self.condition = condition
            self.evaluationWaitTime = evaluationWaitTime
            self.falseActivity = falseActivity
            self.trueActivity = trueActivity
        }
    }
}

extension PinpointClientTypes {

    public struct ContactCenterActivity: Swift.Sendable {
        /// The unique identifier for the next activity to perform after the this activity.
        public var nextActivity: Swift.String?

        public init(
            nextActivity: Swift.String? = nil
        )
        {
            self.nextActivity = nextActivity
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the message content for a custom channel message that's sent to participants in a journey.
    public struct JourneyCustomMessage: Swift.Sendable {
        /// The message content that's passed to an AWS Lambda function or to a web hook.
        public var data: Swift.String?

        public init(
            data: Swift.String? = nil
        )
        {
            self.data = data
        }
    }
}

extension PinpointClientTypes {

    /// The settings for a custom message activity. This type of activity calls an AWS Lambda function or web hook that sends messages to participants.
    public struct CustomMessageActivity: Swift.Sendable {
        /// The destination to send the campaign or treatment to. This value can be one of the following:
        ///
        /// * The name or Amazon Resource Name (ARN) of an AWS Lambda function to invoke to handle delivery of the campaign or treatment.
        ///
        /// * The URL for a web application or service that supports HTTPS and can receive the message. The URL has to be a full URL, including the HTTPS protocol.
        public var deliveryUri: Swift.String?
        /// The types of endpoints to send the custom message to. Each valid value maps to a type of channel that you can associate with an endpoint by using the ChannelType property of an endpoint.
        public var endpointTypes: [PinpointClientTypes.__EndpointTypesElement]?
        /// Specifies the message data included in a custom channel message that's sent to participants in a journey.
        public var messageConfig: PinpointClientTypes.JourneyCustomMessage?
        /// The unique identifier for the next activity to perform, after Amazon Pinpoint calls the AWS Lambda function or web hook.
        public var nextActivity: Swift.String?
        /// The name of the custom message template to use for the message. If specified, this value must match the name of an existing message template.
        public var templateName: Swift.String?
        /// The unique identifier for the version of the message template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the Template Versions resource. If you don't specify a value for this property, Amazon Pinpoint uses the active version of the template. The active version is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.
        public var templateVersion: Swift.String?

        public init(
            deliveryUri: Swift.String? = nil,
            endpointTypes: [PinpointClientTypes.__EndpointTypesElement]? = nil,
            messageConfig: PinpointClientTypes.JourneyCustomMessage? = nil,
            nextActivity: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateVersion: Swift.String? = nil
        )
        {
            self.deliveryUri = deliveryUri
            self.endpointTypes = endpointTypes
            self.messageConfig = messageConfig
            self.nextActivity = nextActivity
            self.templateName = templateName
            self.templateVersion = templateVersion
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the "From" address for an email message that's sent to participants in a journey.
    public struct JourneyEmailMessage: Swift.Sendable {
        /// The verified email address to send the email message from. The default address is the FromAddress specified for the email channel for the application.
        public var fromAddress: Swift.String?

        public init(
            fromAddress: Swift.String? = nil
        )
        {
            self.fromAddress = fromAddress
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for an email activity in a journey. This type of activity sends an email message to participants.
    public struct EmailMessageActivity: Swift.Sendable {
        /// Specifies the sender address for an email message that's sent to participants in the journey.
        public var messageConfig: PinpointClientTypes.JourneyEmailMessage?
        /// The unique identifier for the next activity to perform, after the message is sent.
        public var nextActivity: Swift.String?
        /// The name of the email message template to use for the message. If specified, this value must match the name of an existing message template.
        public var templateName: Swift.String?
        /// The unique identifier for the version of the email template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the Template Versions resource. If you don't specify a value for this property, Amazon Pinpoint uses the active version of the template. The active version is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.
        public var templateVersion: Swift.String?

        public init(
            messageConfig: PinpointClientTypes.JourneyEmailMessage? = nil,
            nextActivity: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateVersion: Swift.String? = nil
        )
        {
            self.messageConfig = messageConfig
            self.nextActivity = nextActivity
            self.templateName = templateName
            self.templateVersion = templateVersion
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a holdout activity in a journey. This type of activity stops a journey for a specified percentage of participants.
    public struct HoldoutActivity: Swift.Sendable {
        /// The unique identifier for the next activity to perform, after performing the holdout activity.
        public var nextActivity: Swift.String?
        /// The percentage of participants who shouldn't continue the journey. To determine which participants are held out, Amazon Pinpoint applies a probability-based algorithm to the percentage that you specify. Therefore, the actual percentage of participants who are held out may not be equal to the percentage that you specify.
        /// This member is required.
        public var percentage: Swift.Int?

        public init(
            nextActivity: Swift.String? = nil,
            percentage: Swift.Int? = nil
        )
        {
            self.nextActivity = nextActivity
            self.percentage = percentage
        }
    }
}

extension PinpointClientTypes {

    /// Specifies a condition to evaluate for an activity path in a journey.
    public struct MultiConditionalBranch: Swift.Sendable {
        /// The condition to evaluate for the activity path.
        public var condition: PinpointClientTypes.SimpleCondition?
        /// The unique identifier for the next activity to perform, after completing the activity for the path.
        public var nextActivity: Swift.String?

        public init(
            condition: PinpointClientTypes.SimpleCondition? = nil,
            nextActivity: Swift.String? = nil
        )
        {
            self.condition = condition
            self.nextActivity = nextActivity
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a multivariate split activity in a journey. This type of activity sends participants down one of as many as five paths (including a default Else path) in a journey, based on conditions that you specify. To create multivariate split activities that send participants down different paths based on push notification events (such as Open or Received events), your mobile app has to specify the User ID and Endpoint ID values. For more information, see [Integrating Amazon Pinpoint with your application](https://docs.aws.amazon.com/pinpoint/latest/developerguide/integrate.html) in the Amazon Pinpoint Developer Guide.
    public struct MultiConditionalSplitActivity: Swift.Sendable {
        /// The paths for the activity, including the conditions for entering each path and the activity to perform for each path.
        public var branches: [PinpointClientTypes.MultiConditionalBranch]?
        /// The unique identifier for the activity to perform for participants who don't meet any of the conditions specified for other paths in the activity.
        public var defaultActivity: Swift.String?
        /// The amount of time to wait or the date and time when Amazon Pinpoint determines whether the conditions are met.
        public var evaluationWaitTime: PinpointClientTypes.WaitTime?

        public init(
            branches: [PinpointClientTypes.MultiConditionalBranch]? = nil,
            defaultActivity: Swift.String? = nil,
            evaluationWaitTime: PinpointClientTypes.WaitTime? = nil
        )
        {
            self.branches = branches
            self.defaultActivity = defaultActivity
            self.evaluationWaitTime = evaluationWaitTime
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the message configuration for a push notification that's sent to participants in a journey.
    public struct JourneyPushMessage: Swift.Sendable {
        /// The number of seconds that the push notification service should keep the message, if the service is unable to deliver the notification the first time. This value is converted to an expiration value when it's sent to a push-notification service. If this value is 0, the service treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again. This value doesn't apply to messages that are sent through the Amazon Device Messaging (ADM) service.
        public var timeToLive: Swift.String?

        public init(
            timeToLive: Swift.String? = nil
        )
        {
            self.timeToLive = timeToLive
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a push notification activity in a journey. This type of activity sends a push notification to participants.
    public struct PushMessageActivity: Swift.Sendable {
        /// Specifies the time to live (TTL) value for push notifications that are sent to participants in a journey.
        public var messageConfig: PinpointClientTypes.JourneyPushMessage?
        /// The unique identifier for the next activity to perform, after the message is sent.
        public var nextActivity: Swift.String?
        /// The name of the push notification template to use for the message. If specified, this value must match the name of an existing message template.
        public var templateName: Swift.String?
        /// The unique identifier for the version of the push notification template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the Template Versions resource. If you don't specify a value for this property, Amazon Pinpoint uses the active version of the template. The active version is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.
        public var templateVersion: Swift.String?

        public init(
            messageConfig: PinpointClientTypes.JourneyPushMessage? = nil,
            nextActivity: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateVersion: Swift.String? = nil
        )
        {
            self.messageConfig = messageConfig
            self.nextActivity = nextActivity
            self.templateName = templateName
            self.templateVersion = templateVersion
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a path in a random split activity in a journey.
    public struct RandomSplitEntry: Swift.Sendable {
        /// The unique identifier for the next activity to perform, after completing the activity for the path.
        public var nextActivity: Swift.String?
        /// The percentage of participants to send down the activity path. To determine which participants are sent down each path, Amazon Pinpoint applies a probability-based algorithm to the percentages that you specify for the paths. Therefore, the actual percentage of participants who are sent down a path may not be equal to the percentage that you specify.
        public var percentage: Swift.Int?

        public init(
            nextActivity: Swift.String? = nil,
            percentage: Swift.Int? = nil
        )
        {
            self.nextActivity = nextActivity
            self.percentage = percentage
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a random split activity in a journey. This type of activity randomly sends specified percentages of participants down one of as many as five paths in a journey, based on conditions that you specify.
    public struct RandomSplitActivity: Swift.Sendable {
        /// The paths for the activity, including the percentage of participants to enter each path and the activity to perform for each path.
        public var branches: [PinpointClientTypes.RandomSplitEntry]?

        public init(
            branches: [PinpointClientTypes.RandomSplitEntry]? = nil
        )
        {
            self.branches = branches
        }
    }
}

extension PinpointClientTypes {

    public enum MessageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case promotional
        case transactional
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .promotional,
                .transactional
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .promotional: return "PROMOTIONAL"
            case .transactional: return "TRANSACTIONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the sender ID and message type for an SMS message that's sent to participants in a journey.
    public struct JourneySMSMessage: Swift.Sendable {
        /// The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.
        public var entityId: Swift.String?
        /// The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).
        public var messageType: PinpointClientTypes.MessageType?
        /// The long code to send the SMS message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code using an E.164 format to ensure prompt and accurate delivery of the message. For example, +12065550100.
        public var originationNumber: Swift.String?
        /// The sender ID to display as the sender of the message on a recipient's device. Support for sender IDs varies by country or region. For more information, see [Supported Countries and Regions](https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-countries.html) in the Amazon Pinpoint User Guide.
        public var senderId: Swift.String?
        /// The template ID received from the regulatory body for sending SMS in your country.
        public var templateId: Swift.String?

        public init(
            entityId: Swift.String? = nil,
            messageType: PinpointClientTypes.MessageType? = nil,
            originationNumber: Swift.String? = nil,
            senderId: Swift.String? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.entityId = entityId
            self.messageType = messageType
            self.originationNumber = originationNumber
            self.senderId = senderId
            self.templateId = templateId
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for an SMS activity in a journey. This type of activity sends a text message to participants.
    public struct SMSMessageActivity: Swift.Sendable {
        /// Specifies the sender ID and message type for an SMS message that's sent to participants in a journey.
        public var messageConfig: PinpointClientTypes.JourneySMSMessage?
        /// The unique identifier for the next activity to perform, after the message is sent.
        public var nextActivity: Swift.String?
        /// The name of the SMS message template to use for the message. If specified, this value must match the name of an existing message template.
        public var templateName: Swift.String?
        /// The unique identifier for the version of the SMS template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the Template Versions resource. If you don't specify a value for this property, Amazon Pinpoint uses the active version of the template. The active version is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.
        public var templateVersion: Swift.String?

        public init(
            messageConfig: PinpointClientTypes.JourneySMSMessage? = nil,
            nextActivity: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateVersion: Swift.String? = nil
        )
        {
            self.messageConfig = messageConfig
            self.nextActivity = nextActivity
            self.templateName = templateName
            self.templateVersion = templateVersion
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a wait activity in a journey. This type of activity waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.
    public struct WaitActivity: Swift.Sendable {
        /// The unique identifier for the next activity to perform, after performing the wait activity.
        public var nextActivity: Swift.String?
        /// The amount of time to wait or the date and time when the activity moves participants to the next activity in the journey.
        public var waitTime: PinpointClientTypes.WaitTime?

        public init(
            nextActivity: Swift.String? = nil,
            waitTime: PinpointClientTypes.WaitTime? = nil
        )
        {
            self.nextActivity = nextActivity
            self.waitTime = waitTime
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the configuration and other settings for an activity in a journey.
    public struct Activity: Swift.Sendable {
        /// The settings for a yes/no split activity. This type of activity sends participants down one of two paths in a journey, based on conditions that you specify.
        public var conditionalSplit: PinpointClientTypes.ConditionalSplitActivity?
        /// The settings for a connect activity. This type of activity initiates a contact center call to participants.
        public var contactCenter: PinpointClientTypes.ContactCenterActivity?
        /// The settings for a custom message activity. This type of activity calls an AWS Lambda function or web hook that sends messages to participants.
        public var custom: PinpointClientTypes.CustomMessageActivity?
        /// The custom description of the activity.
        public var description: Swift.String?
        /// The settings for an email activity. This type of activity sends an email message to participants.
        public var email: PinpointClientTypes.EmailMessageActivity?
        /// The settings for a holdout activity. This type of activity stops a journey for a specified percentage of participants.
        public var holdout: PinpointClientTypes.HoldoutActivity?
        /// The settings for a multivariate split activity. This type of activity sends participants down one of as many as five paths (including a default Else path) in a journey, based on conditions that you specify.
        public var multiCondition: PinpointClientTypes.MultiConditionalSplitActivity?
        /// The settings for a push notification activity. This type of activity sends a push notification to participants.
        public var push: PinpointClientTypes.PushMessageActivity?
        /// The settings for a random split activity. This type of activity randomly sends specified percentages of participants down one of as many as five paths in a journey, based on conditions that you specify.
        public var randomSplit: PinpointClientTypes.RandomSplitActivity?
        /// The settings for an SMS activity. This type of activity sends a text message to participants.
        public var sms: PinpointClientTypes.SMSMessageActivity?
        /// The settings for a wait activity. This type of activity waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.
        public var wait: PinpointClientTypes.WaitActivity?

        public init(
            conditionalSplit: PinpointClientTypes.ConditionalSplitActivity? = nil,
            contactCenter: PinpointClientTypes.ContactCenterActivity? = nil,
            custom: PinpointClientTypes.CustomMessageActivity? = nil,
            description: Swift.String? = nil,
            email: PinpointClientTypes.EmailMessageActivity? = nil,
            holdout: PinpointClientTypes.HoldoutActivity? = nil,
            multiCondition: PinpointClientTypes.MultiConditionalSplitActivity? = nil,
            push: PinpointClientTypes.PushMessageActivity? = nil,
            randomSplit: PinpointClientTypes.RandomSplitActivity? = nil,
            sms: PinpointClientTypes.SMSMessageActivity? = nil,
            wait: PinpointClientTypes.WaitActivity? = nil
        )
        {
            self.conditionalSplit = conditionalSplit
            self.contactCenter = contactCenter
            self.custom = custom
            self.description = description
            self.email = email
            self.holdout = holdout
            self.multiCondition = multiCondition
            self.push = push
            self.randomSplit = randomSplit
            self.sms = sms
            self.wait = wait
        }
    }
}

extension PinpointClientTypes {

    public enum ChannelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case adm
        case apns
        case apnsSandbox
        case apnsVoip
        case apnsVoipSandbox
        case baidu
        case custom
        case email
        case gcm
        case inApp
        case push
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelType] {
            return [
                .adm,
                .apns,
                .apnsSandbox,
                .apnsVoip,
                .apnsVoipSandbox,
                .baidu,
                .custom,
                .email,
                .gcm,
                .inApp,
                .push,
                .sms,
                .voice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .adm: return "ADM"
            case .apns: return "APNS"
            case .apnsSandbox: return "APNS_SANDBOX"
            case .apnsVoip: return "APNS_VOIP"
            case .apnsVoipSandbox: return "APNS_VOIP_SANDBOX"
            case .baidu: return "BAIDU"
            case .custom: return "CUSTOM"
            case .email: return "EMAIL"
            case .gcm: return "GCM"
            case .inApp: return "IN_APP"
            case .push: return "PUSH"
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies address-based configuration settings for a message that's sent directly to an endpoint.
    public struct AddressConfiguration: Swift.Sendable {
        /// The message body to use instead of the default message body. This value overrides the default message body.
        public var bodyOverride: Swift.String?
        /// The channel to use when sending the message.
        public var channelType: PinpointClientTypes.ChannelType?
        /// An object that maps custom attributes to attributes for the address and is attached to the message. Attribute names are case sensitive. For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.
        public var context: [Swift.String: Swift.String]?
        /// The raw, JSON-formatted string to use as the payload for the message. If specified, this value overrides all other values for the message.
        public var rawContent: Swift.String?
        /// A map of the message variables to merge with the variables specified by properties of the DefaultMessage object. The variables specified in this map take precedence over all other variables.
        public var substitutions: [Swift.String: [Swift.String]]?
        /// The message title to use instead of the default message title. This value overrides the default message title.
        public var titleOverride: Swift.String?

        public init(
            bodyOverride: Swift.String? = nil,
            channelType: PinpointClientTypes.ChannelType? = nil,
            context: [Swift.String: Swift.String]? = nil,
            rawContent: Swift.String? = nil,
            substitutions: [Swift.String: [Swift.String]]? = nil,
            titleOverride: Swift.String? = nil
        )
        {
            self.bodyOverride = bodyOverride
            self.channelType = channelType
            self.context = context
            self.rawContent = rawContent
            self.substitutions = substitutions
            self.titleOverride = titleOverride
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the status and settings of the ADM (Amazon Device Messaging) channel for an application.
    public struct ADMChannelRequest: Swift.Sendable {
        /// The Client ID that you received from Amazon to send messages by using ADM.
        /// This member is required.
        public var clientId: Swift.String?
        /// The Client Secret that you received from Amazon to send messages by using ADM.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// Specifies whether to enable the ADM channel for the application.
        public var enabled: Swift.Bool?

        public init(
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.enabled = enabled
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the status and settings of the ADM (Amazon Device Messaging) channel for an application.
    public struct ADMChannelResponse: Swift.Sendable {
        /// The unique identifier for the application that the ADM channel applies to.
        public var applicationId: Swift.String?
        /// The date and time when the ADM channel was enabled.
        public var creationDate: Swift.String?
        /// Specifies whether the ADM channel is enabled for the application.
        public var enabled: Swift.Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public var hasCredential: Swift.Bool?
        /// (Deprecated) An identifier for the ADM channel. This property is retained only for backward compatibility.
        public var id: Swift.String?
        /// Specifies whether the ADM channel is archived.
        public var isArchived: Swift.Bool?
        /// The user who last modified the ADM channel.
        public var lastModifiedBy: Swift.String?
        /// The date and time when the ADM channel was last modified.
        public var lastModifiedDate: Swift.String?
        /// The type of messaging or notification platform for the channel. For the ADM channel, this value is ADM.
        /// This member is required.
        public var platform: Swift.String?
        /// The current version of the ADM channel.
        public var version: Swift.Int?

        public init(
            applicationId: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            hasCredential: Swift.Bool? = nil,
            id: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            platform: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a one-time message that's sent directly to an endpoint through the ADM (Amazon Device Messaging) channel.
    public struct ADMMessage: Swift.Sendable {
        /// The action to occur if the recipient taps the push notification. Valid values are:
        ///
        /// * OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.
        ///
        /// * DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.
        ///
        /// * URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public var action: PinpointClientTypes.Action?
        /// The body of the notification message.
        public var body: Swift.String?
        /// An arbitrary string that indicates that multiple messages are logically the same and that Amazon Device Messaging (ADM) can drop previously enqueued messages in favor of this message.
        public var consolidationKey: Swift.String?
        /// The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.
        public var data: [Swift.String: Swift.String]?
        /// The amount of time, in seconds, that ADM should store the message if the recipient's device is offline. Amazon Pinpoint specifies this value in the expiresAfter parameter when it sends the notification message to ADM.
        public var expiresAfter: Swift.String?
        /// The icon image name of the asset saved in your app.
        public var iconReference: Swift.String?
        /// The URL of the large icon image to display in the content view of the push notification.
        public var imageIconUrl: Swift.String?
        /// The URL of an image to display in the push notification.
        public var imageUrl: Swift.String?
        /// The base64-encoded, MD5 checksum of the value specified by the Data property. ADM uses the MD5 value to verify the integrity of the data.
        public var md5: Swift.String?
        /// The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.
        public var rawContent: Swift.String?
        /// Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.
        public var silentPush: Swift.Bool?
        /// The URL of the small icon image to display in the status bar and the content view of the push notification.
        public var smallImageIconUrl: Swift.String?
        /// The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.
        public var sound: Swift.String?
        /// The default message variables to use in the notification message. You can override the default variables with individual address variables.
        public var substitutions: [Swift.String: [Swift.String]]?
        /// The title to display above the notification message on the recipient's device.
        public var title: Swift.String?
        /// The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.
        public var url: Swift.String?

        public init(
            action: PinpointClientTypes.Action? = nil,
            body: Swift.String? = nil,
            consolidationKey: Swift.String? = nil,
            data: [Swift.String: Swift.String]? = nil,
            expiresAfter: Swift.String? = nil,
            iconReference: Swift.String? = nil,
            imageIconUrl: Swift.String? = nil,
            imageUrl: Swift.String? = nil,
            md5: Swift.String? = nil,
            rawContent: Swift.String? = nil,
            silentPush: Swift.Bool? = nil,
            smallImageIconUrl: Swift.String? = nil,
            sound: Swift.String? = nil,
            substitutions: [Swift.String: [Swift.String]]? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.action = action
            self.body = body
            self.consolidationKey = consolidationKey
            self.data = data
            self.expiresAfter = expiresAfter
            self.iconReference = iconReference
            self.imageIconUrl = imageIconUrl
            self.imageUrl = imageUrl
            self.md5 = md5
            self.rawContent = rawContent
            self.silentPush = silentPush
            self.smallImageIconUrl = smallImageIconUrl
            self.sound = sound
            self.substitutions = substitutions
            self.title = title
            self.url = url
        }
    }
}

extension PinpointClientTypes {

    public enum Alignment: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case center
        case `left`
        case `right`
        case sdkUnknown(Swift.String)

        public static var allCases: [Alignment] {
            return [
                .center,
                .left,
                .right
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .center: return "CENTER"
            case .left: return "LEFT"
            case .right: return "RIGHT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies channel-specific content and settings for a message template that can be used in push notifications that are sent through the ADM (Amazon Device Messaging), Baidu (Baidu Cloud Push), or GCM (Firebase Cloud Messaging, formerly Google Cloud Messaging) channel.
    public struct AndroidPushNotificationTemplate: Swift.Sendable {
        /// The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:
        ///
        /// * OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.
        ///
        /// * DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.
        ///
        /// * URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public var action: PinpointClientTypes.Action?
        /// The message body to use in a push notification that's based on the message template.
        public var body: Swift.String?
        /// The URL of the large icon image to display in the content view of a push notification that's based on the message template.
        public var imageIconUrl: Swift.String?
        /// The URL of an image to display in a push notification that's based on the message template.
        public var imageUrl: Swift.String?
        /// The raw, JSON-formatted string to use as the payload for a push notification that's based on the message template. If specified, this value overrides all other content for the message template.
        public var rawContent: Swift.String?
        /// The URL of the small icon image to display in the status bar and the content view of a push notification that's based on the message template.
        public var smallImageIconUrl: Swift.String?
        /// The sound to play when a recipient receives a push notification that's based on the message template. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.
        public var sound: Swift.String?
        /// The title to use in a push notification that's based on the message template. This title appears above the notification message on a recipient's device.
        public var title: Swift.String?
        /// The URL to open in a recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.
        public var url: Swift.String?

        public init(
            action: PinpointClientTypes.Action? = nil,
            body: Swift.String? = nil,
            imageIconUrl: Swift.String? = nil,
            imageUrl: Swift.String? = nil,
            rawContent: Swift.String? = nil,
            smallImageIconUrl: Swift.String? = nil,
            sound: Swift.String? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.action = action
            self.body = body
            self.imageIconUrl = imageIconUrl
            self.imageUrl = imageUrl
            self.rawContent = rawContent
            self.smallImageIconUrl = smallImageIconUrl
            self.sound = sound
            self.title = title
            self.url = url
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the status and settings of the APNs (Apple Push Notification service) channel for an application.
    public struct APNSChannelRequest: Swift.Sendable {
        /// The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.
        public var bundleId: Swift.String?
        /// The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with APNs by using an APNs certificate.
        public var certificate: Swift.String?
        /// The default authentication method that you want Amazon Pinpoint to use when authenticating with APNs, key or certificate.
        public var defaultAuthenticationMethod: Swift.String?
        /// Specifies whether to enable the APNs channel for the application.
        public var enabled: Swift.Bool?
        /// The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with APNs.
        public var privateKey: Swift.String?
        /// The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.
        public var teamId: Swift.String?
        /// The authentication key to use for APNs tokens.
        public var tokenKey: Swift.String?
        /// The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with APNs by using APNs tokens.
        public var tokenKeyId: Swift.String?

        public init(
            bundleId: Swift.String? = nil,
            certificate: Swift.String? = nil,
            defaultAuthenticationMethod: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            privateKey: Swift.String? = nil,
            teamId: Swift.String? = nil,
            tokenKey: Swift.String? = nil,
            tokenKeyId: Swift.String? = nil
        )
        {
            self.bundleId = bundleId
            self.certificate = certificate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.privateKey = privateKey
            self.teamId = teamId
            self.tokenKey = tokenKey
            self.tokenKeyId = tokenKeyId
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the status and settings of the APNs (Apple Push Notification service) channel for an application.
    public struct APNSChannelResponse: Swift.Sendable {
        /// The unique identifier for the application that the APNs channel applies to.
        public var applicationId: Swift.String?
        /// The date and time when the APNs channel was enabled.
        public var creationDate: Swift.String?
        /// The default authentication method that Amazon Pinpoint uses to authenticate with APNs for this channel, key or certificate.
        public var defaultAuthenticationMethod: Swift.String?
        /// Specifies whether the APNs channel is enabled for the application.
        public var enabled: Swift.Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public var hasCredential: Swift.Bool?
        /// Specifies whether the APNs channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.
        public var hasTokenKey: Swift.Bool?
        /// (Deprecated) An identifier for the APNs channel. This property is retained only for backward compatibility.
        public var id: Swift.String?
        /// Specifies whether the APNs channel is archived.
        public var isArchived: Swift.Bool?
        /// The user who last modified the APNs channel.
        public var lastModifiedBy: Swift.String?
        /// The date and time when the APNs channel was last modified.
        public var lastModifiedDate: Swift.String?
        /// The type of messaging or notification platform for the channel. For the APNs channel, this value is APNS.
        /// This member is required.
        public var platform: Swift.String?
        /// The current version of the APNs channel.
        public var version: Swift.Int?

        public init(
            applicationId: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            defaultAuthenticationMethod: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            hasCredential: Swift.Bool? = nil,
            hasTokenKey: Swift.Bool? = nil,
            id: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            platform: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a one-time message that's sent directly to an endpoint through the APNs (Apple Push Notification service) channel.
    public struct APNSMessage: Swift.Sendable {
        /// The action to occur if the recipient taps the push notification. Valid values are:
        ///
        /// * OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.
        ///
        /// * DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS platform.
        ///
        /// * URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public var action: PinpointClientTypes.Action?
        /// The type of push notification to send. Valid values are:
        ///
        /// * alert - For a standard notification that's displayed on recipients' devices and prompts a recipient to interact with the notification.
        ///
        /// * background - For a silent notification that delivers content in the background and isn't displayed on recipients' devices.
        ///
        /// * complication - For a notification that contains update information for an app’s complication timeline.
        ///
        /// * fileprovider - For a notification that signals changes to a File Provider extension.
        ///
        /// * mdm - For a notification that tells managed devices to contact the MDM server.
        ///
        /// * voip - For a notification that provides information about an incoming VoIP call.
        ///
        ///
        /// Amazon Pinpoint specifies this value in the apns-push-type request header when it sends the notification message to APNs. If you don't specify a value for this property, Amazon Pinpoint sets the value to alert or background automatically, based on the value that you specify for the SilentPush or RawContent property of the message. For more information about the apns-push-type request header, see [Sending Notification Requests to APNs](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/sending_notification_requests_to_apns) on the Apple Developer website.
        public var apnsPushType: Swift.String?
        /// The key that indicates whether and how to modify the badge of your app's icon when the recipient receives the push notification. If this key isn't included in the dictionary, the badge doesn't change. To remove the badge, set this value to 0.
        public var badge: Swift.Int?
        /// The body of the notification message.
        public var body: Swift.String?
        /// The key that indicates the notification type for the push notification. This key is a value that's defined by the identifier property of one of your app's registered categories.
        public var category: Swift.String?
        /// An arbitrary identifier that, if assigned to multiple messages, APNs uses to coalesce the messages into a single push notification instead of delivering each message individually. This value can't exceed 64 bytes. Amazon Pinpoint specifies this value in the apns-collapse-id request header when it sends the notification message to APNs.
        public var collapseId: Swift.String?
        /// The JSON payload to use for a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.
        public var data: [Swift.String: Swift.String]?
        /// The URL of an image or video to display in the push notification.
        public var mediaUrl: Swift.String?
        /// The authentication method that you want Amazon Pinpoint to use when authenticating with APNs, CERTIFICATE or TOKEN.
        public var preferredAuthenticationMethod: Swift.String?
        /// para>5 - Low priority, the notification might be delayed, delivered as part of a group, or throttled./listitem>
        /// * 10 - High priority, the notification is sent immediately. This is the default value. A high priority notification should trigger an alert, play a sound, or badge your app's icon on the recipient's device.
        /// /para> Amazon Pinpoint specifies this value in the apns-priority request header when it sends the notification message to APNs. The equivalent values for Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), are normal, for 5, and high, for 10. If you specify an FCM value for this property, Amazon Pinpoint accepts and converts the value to the corresponding APNs value.
        public var priority: Swift.String?
        /// The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message. If you specify the raw content of an APNs push notification, the message payload has to include the content-available key. The value of the content-available key has to be an integer, and can only be 0 or 1. If you're sending a standard notification, set the value of content-available to 0. If you're sending a silent (background) notification, set the value of content-available to 1. Additionally, silent notification payloads can't include the alert, badge, or sound keys. For more information, see [Generating a Remote Notification](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification) and [Pushing Background Updates to Your App](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app) on the Apple Developer website.
        public var rawContent: Swift.String?
        /// Specifies whether the notification is a silent push notification. A silent (or background) push notification isn't displayed on recipients' devices. You can use silent push notifications to make small updates to your app, or to display messages in an in-app message center. Amazon Pinpoint uses this property to determine the correct value for the apns-push-type request header when it sends the notification message to APNs. If you specify a value of true for this property, Amazon Pinpoint sets the value for the apns-push-type header field to background. If you specify the raw content of an APNs push notification, the message payload has to include the content-available key. For silent (background) notifications, set the value of content-available to 1. Additionally, the message payload for a silent notification can't include the alert, badge, or sound keys. For more information, see [Generating a Remote Notification](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification) and [Pushing Background Updates to Your App](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app) on the Apple Developer website. Apple has indicated that they will throttle "excessive" background notifications based on current traffic volumes. To prevent your notifications being throttled, Apple recommends that you send no more than 3 silent push notifications to each recipient per hour.
        public var silentPush: Swift.Bool?
        /// The key for the sound to play when the recipient receives the push notification. The value for this key is the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.
        public var sound: Swift.String?
        /// The default message variables to use in the notification message. You can override these default variables with individual address variables.
        public var substitutions: [Swift.String: [Swift.String]]?
        /// The key that represents your app-specific identifier for grouping notifications. If you provide a Notification Content app extension, you can use this value to group your notifications together.
        public var threadId: Swift.String?
        /// The amount of time, in seconds, that APNs should store and attempt to deliver the push notification, if the service is unable to deliver the notification the first time. If this value is 0, APNs treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again. Amazon Pinpoint specifies this value in the apns-expiration request header when it sends the notification message to APNs.
        public var timeToLive: Swift.Int?
        /// The title to display above the notification message on the recipient's device.
        public var title: Swift.String?
        /// The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.
        public var url: Swift.String?

        public init(
            action: PinpointClientTypes.Action? = nil,
            apnsPushType: Swift.String? = nil,
            badge: Swift.Int? = nil,
            body: Swift.String? = nil,
            category: Swift.String? = nil,
            collapseId: Swift.String? = nil,
            data: [Swift.String: Swift.String]? = nil,
            mediaUrl: Swift.String? = nil,
            preferredAuthenticationMethod: Swift.String? = nil,
            priority: Swift.String? = nil,
            rawContent: Swift.String? = nil,
            silentPush: Swift.Bool? = nil,
            sound: Swift.String? = nil,
            substitutions: [Swift.String: [Swift.String]]? = nil,
            threadId: Swift.String? = nil,
            timeToLive: Swift.Int? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.action = action
            self.apnsPushType = apnsPushType
            self.badge = badge
            self.body = body
            self.category = category
            self.collapseId = collapseId
            self.data = data
            self.mediaUrl = mediaUrl
            self.preferredAuthenticationMethod = preferredAuthenticationMethod
            self.priority = priority
            self.rawContent = rawContent
            self.silentPush = silentPush
            self.sound = sound
            self.substitutions = substitutions
            self.threadId = threadId
            self.timeToLive = timeToLive
            self.title = title
            self.url = url
        }
    }
}

extension PinpointClientTypes {

    /// Specifies channel-specific content and settings for a message template that can be used in push notifications that are sent through the APNs (Apple Push Notification service) channel.
    public struct APNSPushNotificationTemplate: Swift.Sendable {
        /// The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:
        ///
        /// * OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.
        ///
        /// * DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS platform.
        ///
        /// * URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public var action: PinpointClientTypes.Action?
        /// The message body to use in push notifications that are based on the message template.
        public var body: Swift.String?
        /// The URL of an image or video to display in push notifications that are based on the message template.
        public var mediaUrl: Swift.String?
        /// The raw, JSON-formatted string to use as the payload for push notifications that are based on the message template. If specified, this value overrides all other content for the message template.
        public var rawContent: Swift.String?
        /// The key for the sound to play when the recipient receives a push notification that's based on the message template. The value for this key is the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.
        public var sound: Swift.String?
        /// The title to use in push notifications that are based on the message template. This title appears above the notification message on a recipient's device.
        public var title: Swift.String?
        /// The URL to open in the recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.
        public var url: Swift.String?

        public init(
            action: PinpointClientTypes.Action? = nil,
            body: Swift.String? = nil,
            mediaUrl: Swift.String? = nil,
            rawContent: Swift.String? = nil,
            sound: Swift.String? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.action = action
            self.body = body
            self.mediaUrl = mediaUrl
            self.rawContent = rawContent
            self.sound = sound
            self.title = title
            self.url = url
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.
    public struct APNSSandboxChannelRequest: Swift.Sendable {
        /// The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.
        public var bundleId: Swift.String?
        /// The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using an APNs certificate.
        public var certificate: Swift.String?
        /// The default authentication method that you want Amazon Pinpoint to use when authenticating with the APNs sandbox environment, key or certificate.
        public var defaultAuthenticationMethod: Swift.String?
        /// Specifies whether to enable the APNs sandbox channel for the application.
        public var enabled: Swift.Bool?
        /// The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with the APNs sandbox environment.
        public var privateKey: Swift.String?
        /// The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.
        public var teamId: Swift.String?
        /// The authentication key to use for APNs tokens.
        public var tokenKey: Swift.String?
        /// The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using APNs tokens.
        public var tokenKeyId: Swift.String?

        public init(
            bundleId: Swift.String? = nil,
            certificate: Swift.String? = nil,
            defaultAuthenticationMethod: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            privateKey: Swift.String? = nil,
            teamId: Swift.String? = nil,
            tokenKey: Swift.String? = nil,
            tokenKeyId: Swift.String? = nil
        )
        {
            self.bundleId = bundleId
            self.certificate = certificate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.privateKey = privateKey
            self.teamId = teamId
            self.tokenKey = tokenKey
            self.tokenKeyId = tokenKeyId
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.
    public struct APNSSandboxChannelResponse: Swift.Sendable {
        /// The unique identifier for the application that the APNs sandbox channel applies to.
        public var applicationId: Swift.String?
        /// The date and time when the APNs sandbox channel was enabled.
        public var creationDate: Swift.String?
        /// The default authentication method that Amazon Pinpoint uses to authenticate with the APNs sandbox environment for this channel, key or certificate.
        public var defaultAuthenticationMethod: Swift.String?
        /// Specifies whether the APNs sandbox channel is enabled for the application.
        public var enabled: Swift.Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public var hasCredential: Swift.Bool?
        /// Specifies whether the APNs sandbox channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.
        public var hasTokenKey: Swift.Bool?
        /// (Deprecated) An identifier for the APNs sandbox channel. This property is retained only for backward compatibility.
        public var id: Swift.String?
        /// Specifies whether the APNs sandbox channel is archived.
        public var isArchived: Swift.Bool?
        /// The user who last modified the APNs sandbox channel.
        public var lastModifiedBy: Swift.String?
        /// The date and time when the APNs sandbox channel was last modified.
        public var lastModifiedDate: Swift.String?
        /// The type of messaging or notification platform for the channel. For the APNs sandbox channel, this value is APNS_SANDBOX.
        /// This member is required.
        public var platform: Swift.String?
        /// The current version of the APNs sandbox channel.
        public var version: Swift.Int?

        public init(
            applicationId: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            defaultAuthenticationMethod: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            hasCredential: Swift.Bool? = nil,
            hasTokenKey: Swift.Bool? = nil,
            id: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            platform: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.
    public struct APNSVoipChannelRequest: Swift.Sendable {
        /// The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.
        public var bundleId: Swift.String?
        /// The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with APNs by using an APNs certificate.
        public var certificate: Swift.String?
        /// The default authentication method that you want Amazon Pinpoint to use when authenticating with APNs, key or certificate.
        public var defaultAuthenticationMethod: Swift.String?
        /// Specifies whether to enable the APNs VoIP channel for the application.
        public var enabled: Swift.Bool?
        /// The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with APNs.
        public var privateKey: Swift.String?
        /// The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.
        public var teamId: Swift.String?
        /// The authentication key to use for APNs tokens.
        public var tokenKey: Swift.String?
        /// The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with APNs by using APNs tokens.
        public var tokenKeyId: Swift.String?

        public init(
            bundleId: Swift.String? = nil,
            certificate: Swift.String? = nil,
            defaultAuthenticationMethod: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            privateKey: Swift.String? = nil,
            teamId: Swift.String? = nil,
            tokenKey: Swift.String? = nil,
            tokenKeyId: Swift.String? = nil
        )
        {
            self.bundleId = bundleId
            self.certificate = certificate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.privateKey = privateKey
            self.teamId = teamId
            self.tokenKey = tokenKey
            self.tokenKeyId = tokenKeyId
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.
    public struct APNSVoipChannelResponse: Swift.Sendable {
        /// The unique identifier for the application that the APNs VoIP channel applies to.
        public var applicationId: Swift.String?
        /// The date and time when the APNs VoIP channel was enabled.
        public var creationDate: Swift.String?
        /// The default authentication method that Amazon Pinpoint uses to authenticate with APNs for this channel, key or certificate.
        public var defaultAuthenticationMethod: Swift.String?
        /// Specifies whether the APNs VoIP channel is enabled for the application.
        public var enabled: Swift.Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public var hasCredential: Swift.Bool?
        /// Specifies whether the APNs VoIP channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.
        public var hasTokenKey: Swift.Bool?
        /// (Deprecated) An identifier for the APNs VoIP channel. This property is retained only for backward compatibility.
        public var id: Swift.String?
        /// Specifies whether the APNs VoIP channel is archived.
        public var isArchived: Swift.Bool?
        /// The user who last modified the APNs VoIP channel.
        public var lastModifiedBy: Swift.String?
        /// The date and time when the APNs VoIP channel was last modified.
        public var lastModifiedDate: Swift.String?
        /// The type of messaging or notification platform for the channel. For the APNs VoIP channel, this value is APNS_VOIP.
        /// This member is required.
        public var platform: Swift.String?
        /// The current version of the APNs VoIP channel.
        public var version: Swift.Int?

        public init(
            applicationId: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            defaultAuthenticationMethod: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            hasCredential: Swift.Bool? = nil,
            hasTokenKey: Swift.Bool? = nil,
            id: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            platform: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.
    public struct APNSVoipSandboxChannelRequest: Swift.Sendable {
        /// The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.
        public var bundleId: Swift.String?
        /// The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using an APNs certificate.
        public var certificate: Swift.String?
        /// The default authentication method that you want Amazon Pinpoint to use when authenticating with the APNs sandbox environment for this channel, key or certificate.
        public var defaultAuthenticationMethod: Swift.String?
        /// Specifies whether the APNs VoIP sandbox channel is enabled for the application.
        public var enabled: Swift.Bool?
        /// The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with the APNs sandbox environment.
        public var privateKey: Swift.String?
        /// The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.
        public var teamId: Swift.String?
        /// The authentication key to use for APNs tokens.
        public var tokenKey: Swift.String?
        /// The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using APNs tokens.
        public var tokenKeyId: Swift.String?

        public init(
            bundleId: Swift.String? = nil,
            certificate: Swift.String? = nil,
            defaultAuthenticationMethod: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            privateKey: Swift.String? = nil,
            teamId: Swift.String? = nil,
            tokenKey: Swift.String? = nil,
            tokenKeyId: Swift.String? = nil
        )
        {
            self.bundleId = bundleId
            self.certificate = certificate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.privateKey = privateKey
            self.teamId = teamId
            self.tokenKey = tokenKey
            self.tokenKeyId = tokenKeyId
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.
    public struct APNSVoipSandboxChannelResponse: Swift.Sendable {
        /// The unique identifier for the application that the APNs VoIP sandbox channel applies to.
        public var applicationId: Swift.String?
        /// The date and time when the APNs VoIP sandbox channel was enabled.
        public var creationDate: Swift.String?
        /// The default authentication method that Amazon Pinpoint uses to authenticate with the APNs sandbox environment for this channel, key or certificate.
        public var defaultAuthenticationMethod: Swift.String?
        /// Specifies whether the APNs VoIP sandbox channel is enabled for the application.
        public var enabled: Swift.Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public var hasCredential: Swift.Bool?
        /// Specifies whether the APNs VoIP sandbox channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.
        public var hasTokenKey: Swift.Bool?
        /// (Deprecated) An identifier for the APNs VoIP sandbox channel. This property is retained only for backward compatibility.
        public var id: Swift.String?
        /// Specifies whether the APNs VoIP sandbox channel is archived.
        public var isArchived: Swift.Bool?
        /// The user who last modified the APNs VoIP sandbox channel.
        public var lastModifiedBy: Swift.String?
        /// The date and time when the APNs VoIP sandbox channel was last modified.
        public var lastModifiedDate: Swift.String?
        /// The type of messaging or notification platform for the channel. For the APNs VoIP sandbox channel, this value is APNS_VOIP_SANDBOX.
        /// This member is required.
        public var platform: Swift.String?
        /// The current version of the APNs VoIP sandbox channel.
        public var version: Swift.Int?

        public init(
            applicationId: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            defaultAuthenticationMethod: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            hasCredential: Swift.Bool? = nil,
            hasTokenKey: Swift.Bool? = nil,
            id: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            platform: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }
    }
}

extension PinpointClientTypes {

    /// Provides a single value and metadata about that value as part of an array of query results for a standard metric that applies to an application, campaign, or journey.
    public struct ResultRowValue: Swift.Sendable {
        /// The friendly name of the metric whose value is specified by the Value property.
        /// This member is required.
        public var key: Swift.String?
        /// The data type of the value specified by the Value property.
        /// This member is required.
        public var type: Swift.String?
        /// In a Values object, the value for the metric that the query retrieved data for. In a GroupedBys object, the value for the field that was used to group data in a result set that contains multiple results (Values objects).
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.type = type
            self.value = value
        }
    }
}

extension PinpointClientTypes {

    /// Provides the results of a query that retrieved the data for a standard metric that applies to an application, campaign, or journey.
    public struct ResultRow: Swift.Sendable {
        /// An array of objects that defines the field and field values that were used to group data in a result set that contains multiple results. This value is null if the data in a result set isn’t grouped.
        /// This member is required.
        public var groupedBys: [PinpointClientTypes.ResultRowValue]?
        /// An array of objects that provides pre-aggregated values for a standard metric that applies to an application, campaign, or journey.
        /// This member is required.
        public var values: [PinpointClientTypes.ResultRowValue]?

        public init(
            groupedBys: [PinpointClientTypes.ResultRowValue]? = nil,
            values: [PinpointClientTypes.ResultRowValue]? = nil
        )
        {
            self.groupedBys = groupedBys
            self.values = values
        }
    }
}

extension PinpointClientTypes {

    /// Provides the results of a query that retrieved the data for a standard metric that applies to an application, campaign, or journey.
    public struct BaseKpiResult: Swift.Sendable {
        /// An array of objects that provides the results of a query that retrieved the data for a standard metric that applies to an application, campaign, or journey.
        /// This member is required.
        public var rows: [PinpointClientTypes.ResultRow]?

        public init(
            rows: [PinpointClientTypes.ResultRow]? = nil
        )
        {
            self.rows = rows
        }
    }
}

extension PinpointClientTypes {

    /// Provides the results of a query that retrieved the data for a standard metric that applies to an application, and provides information about that query.
    public struct ApplicationDateRangeKpiResponse: Swift.Sendable {
        /// The unique identifier for the application that the metric applies to.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// The name of the metric, also referred to as a key performance indicator (KPI), that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the [Amazon Pinpoint Developer Guide](https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html).
        /// This member is required.
        public var kpiName: Swift.String?
        /// An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.
        /// This member is required.
        public var kpiResult: PinpointClientTypes.BaseKpiResult?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Application Metrics resource because the resource returns all results in a single page.
        public var nextToken: Swift.String?
        /// The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            applicationId: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            kpiName: Swift.String? = nil,
            kpiResult: PinpointClientTypes.BaseKpiResult? = nil,
            nextToken: Swift.String? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.applicationId = applicationId
            self.endTime = endTime
            self.kpiName = kpiName
            self.kpiResult = kpiResult
            self.nextToken = nextToken
            self.startTime = startTime
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about an application.
    public struct ApplicationResponse: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the application.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the Application was created.
        public var creationDate: Swift.String?
        /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
        /// This member is required.
        public var id: Swift.String?
        /// The display name of the application. This name is displayed as the Project name on the Amazon Pinpoint console.
        /// This member is required.
        public var name: Swift.String?
        /// A string-to-string map of key-value pairs that identifies the tags that are associated with the application. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationDate = creationDate
            self.id = id
            self.name = name
            self.tags = tags
        }
    }
}

extension PinpointClientTypes {

    /// The number of messages that can be sent to an endpoint during the specified timeframe for all journeys.
    public struct JourneyTimeframeCap: Swift.Sendable {
        /// The maximum number of messages that all journeys can send to an endpoint during the specified timeframe. The maximum value is 100. If set to 0, this limit will not apply.
        public var cap: Swift.Int?
        /// The length of the timeframe in days. The maximum value is 30. If set to 0, this limit will not apply.
        public var days: Swift.Int?

        public init(
            cap: Swift.Int? = nil,
            days: Swift.Int? = nil
        )
        {
            self.cap = cap
            self.days = days
        }
    }
}

extension PinpointClientTypes {

    /// The default sending limits for journeys in the application. To override these limits and define custom limits for a specific journey, use the Journey resource.
    public struct ApplicationSettingsJourneyLimits: Swift.Sendable {
        /// The daily number of messages that an endpoint can receive from all journeys. The maximum value is 100. If set to 0, this limit will not apply.
        public var dailyCap: Swift.Int?
        /// The default maximum number of messages that can be sent to an endpoint during the specified timeframe for all journeys.
        public var timeframeCap: PinpointClientTypes.JourneyTimeframeCap?
        /// The default maximum number of messages that a single journey can sent to a single endpoint. The maximum value is 100. If set to 0, this limit will not apply.
        public var totalCap: Swift.Int?

        public init(
            dailyCap: Swift.Int? = nil,
            timeframeCap: PinpointClientTypes.JourneyTimeframeCap? = nil,
            totalCap: Swift.Int? = nil
        )
        {
            self.dailyCap = dailyCap
            self.timeframeCap = timeframeCap
            self.totalCap = totalCap
        }
    }
}

extension PinpointClientTypes {

    public enum Mode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delivery
        case filter
        case sdkUnknown(Swift.String)

        public static var allCases: [Mode] {
            return [
                .delivery,
                .filter
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delivery: return "DELIVERY"
            case .filter: return "FILTER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies settings for invoking an AWS Lambda function that customizes a segment for a campaign.
    public struct CampaignHook: Swift.Sendable {
        /// The name or Amazon Resource Name (ARN) of the AWS Lambda function that Amazon Pinpoint invokes to customize a segment for a campaign.
        public var lambdaFunctionName: Swift.String?
        /// The mode that Amazon Pinpoint uses to invoke the AWS Lambda function. Possible values are:
        ///
        /// * FILTER - Invoke the function to customize the segment that's used by a campaign.
        ///
        /// * DELIVERY - (Deprecated) Previously, invoked the function to send a campaign through a custom channel. This functionality is not supported anymore. To send a campaign through a custom channel, use the CustomDeliveryConfiguration and CampaignCustomMessage objects of the campaign.
        public var mode: PinpointClientTypes.Mode?
        /// The web URL that Amazon Pinpoint calls to invoke the AWS Lambda function over HTTPS.
        public var webUrl: Swift.String?

        public init(
            lambdaFunctionName: Swift.String? = nil,
            mode: PinpointClientTypes.Mode? = nil,
            webUrl: Swift.String? = nil
        )
        {
            self.lambdaFunctionName = lambdaFunctionName
            self.mode = mode
            self.webUrl = webUrl
        }
    }
}

extension PinpointClientTypes {

    /// For a campaign, specifies limits on the messages that the campaign can send. For an application, specifies the default limits for messages that campaigns in the application can send.
    public struct CampaignLimits: Swift.Sendable {
        /// The maximum number of messages that a campaign can send to a single endpoint during a 24-hour period. For an application, this value specifies the default limit for the number of messages that campaigns and journeys can send to a single endpoint during a 24-hour period. The maximum value is 100.
        public var daily: Swift.Int?
        /// The maximum amount of time, in seconds, that a campaign can attempt to deliver a message after the scheduled start time for the campaign. The minimum value is 60 seconds.
        public var maximumDuration: Swift.Int?
        /// The maximum number of messages that a campaign can send each second. For an application, this value specifies the default limit for the number of messages that campaigns can send each second. The minimum value is 1. The maximum value is 20,000.
        public var messagesPerSecond: Swift.Int?
        /// The maximum total number of messages that the campaign can send per user session.
        public var session: Swift.Int?
        /// The maximum number of messages that a campaign can send to a single endpoint during the course of the campaign. If a campaign recurs, this setting applies to all runs of the campaign. The maximum value is 100.
        public var total: Swift.Int?

        public init(
            daily: Swift.Int? = nil,
            maximumDuration: Swift.Int? = nil,
            messagesPerSecond: Swift.Int? = nil,
            session: Swift.Int? = nil,
            total: Swift.Int? = nil
        )
        {
            self.daily = daily
            self.maximumDuration = maximumDuration
            self.messagesPerSecond = messagesPerSecond
            self.session = session
            self.total = total
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the start and end times that define a time range when messages aren't sent to endpoints.
    public struct QuietTime: Swift.Sendable {
        /// The specific time when quiet time ends. This value has to use 24-hour notation and be in HH:MM format, where HH is the hour (with a leading zero, if applicable) and MM is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.
        public var end: Swift.String?
        /// The specific time when quiet time begins. This value has to use 24-hour notation and be in HH:MM format, where HH is the hour (with a leading zero, if applicable) and MM is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.
        public var start: Swift.String?

        public init(
            end: Swift.String? = nil,
            start: Swift.String? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about an application, including the default settings for an application.
    public struct ApplicationSettingsResource: Swift.Sendable {
        /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The settings for the AWS Lambda function to invoke by default as a code hook for campaigns in the application. You can use this hook to customize segments that are used by campaigns in the application.
        public var campaignHook: PinpointClientTypes.CampaignHook?
        /// The default sending limits for journeys in the application. These limits apply to each journey for the application but can be overridden, on a per journey basis, with the JourneyLimits resource.
        public var journeyLimits: PinpointClientTypes.ApplicationSettingsJourneyLimits?
        /// The date and time, in ISO 8601 format, when the application's settings were last modified.
        public var lastModifiedDate: Swift.String?
        /// The default sending limits for campaigns in the application.
        public var limits: PinpointClientTypes.CampaignLimits?
        /// The default quiet time for campaigns in the application. Quiet time is a specific time range when messages aren't sent to endpoints, if all the following conditions are met:
        ///
        /// * The EndpointDemographic.Timezone property of the endpoint is set to a valid value.
        ///
        /// * The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the application (or a campaign or journey that has custom quiet time settings).
        ///
        /// * The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the application (or a campaign or journey that has custom quiet time settings).
        ///
        ///
        /// If any of the preceding conditions isn't met, the endpoint will receive messages from a campaign or journey, even if quiet time is enabled.
        public var quietTime: PinpointClientTypes.QuietTime?

        public init(
            applicationId: Swift.String? = nil,
            campaignHook: PinpointClientTypes.CampaignHook? = nil,
            journeyLimits: PinpointClientTypes.ApplicationSettingsJourneyLimits? = nil,
            lastModifiedDate: Swift.String? = nil,
            limits: PinpointClientTypes.CampaignLimits? = nil,
            quietTime: PinpointClientTypes.QuietTime? = nil
        )
        {
            self.applicationId = applicationId
            self.campaignHook = campaignHook
            self.journeyLimits = journeyLimits
            self.lastModifiedDate = lastModifiedDate
            self.limits = limits
            self.quietTime = quietTime
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about all of your applications.
    public struct ApplicationsResponse: Swift.Sendable {
        /// An array of responses, one for each application that was returned.
        public var item: [PinpointClientTypes.ApplicationResponse]?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public var nextToken: Swift.String?

        public init(
            item: [PinpointClientTypes.ApplicationResponse]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.item = item
            self.nextToken = nextToken
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the type and the names of attributes that were removed from all the endpoints that are associated with an application.
    public struct AttributesResource: Swift.Sendable {
        /// The unique identifier for the application.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The type of attribute or attributes that were removed from the endpoints. Valid values are:
        ///
        /// * endpoint-custom-attributes - Custom attributes that describe endpoints.
        ///
        /// * endpoint-metric-attributes - Custom metrics that your app reports to Amazon Pinpoint for endpoints.
        ///
        /// * endpoint-user-attributes - Custom attributes that describe users.
        /// This member is required.
        public var attributeType: Swift.String?
        /// An array that specifies the names of the attributes that were removed from the endpoints.
        public var attributes: [Swift.String]?

        public init(
            applicationId: Swift.String? = nil,
            attributeType: Swift.String? = nil,
            attributes: [Swift.String]? = nil
        )
        {
            self.applicationId = applicationId
            self.attributeType = attributeType
            self.attributes = attributes
        }
    }
}

/// Provides information about an API request or response.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message that's returned from the API.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the request or response.
        public internal(set) var requestID: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestID: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestID = requestID
    }
}

extension PinpointClientTypes {

    /// Specifies the status and settings of the Baidu (Baidu Cloud Push) channel for an application.
    public struct BaiduChannelRequest: Swift.Sendable {
        /// The API key that you received from the Baidu Cloud Push service to communicate with the service.
        /// This member is required.
        public var apiKey: Swift.String?
        /// Specifies whether to enable the Baidu channel for the application.
        public var enabled: Swift.Bool?
        /// The secret key that you received from the Baidu Cloud Push service to communicate with the service.
        /// This member is required.
        public var secretKey: Swift.String?

        public init(
            apiKey: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            secretKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
            self.enabled = enabled
            self.secretKey = secretKey
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the status and settings of the Baidu (Baidu Cloud Push) channel for an application.
    public struct BaiduChannelResponse: Swift.Sendable {
        /// The unique identifier for the application that the Baidu channel applies to.
        public var applicationId: Swift.String?
        /// The date and time when the Baidu channel was enabled.
        public var creationDate: Swift.String?
        /// The API key that you received from the Baidu Cloud Push service to communicate with the service.
        /// This member is required.
        public var credential: Swift.String?
        /// Specifies whether the Baidu channel is enabled for the application.
        public var enabled: Swift.Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public var hasCredential: Swift.Bool?
        /// (Deprecated) An identifier for the Baidu channel. This property is retained only for backward compatibility.
        public var id: Swift.String?
        /// Specifies whether the Baidu channel is archived.
        public var isArchived: Swift.Bool?
        /// The user who last modified the Baidu channel.
        public var lastModifiedBy: Swift.String?
        /// The date and time when the Baidu channel was last modified.
        public var lastModifiedDate: Swift.String?
        /// The type of messaging or notification platform for the channel. For the Baidu channel, this value is BAIDU.
        /// This member is required.
        public var platform: Swift.String?
        /// The current version of the Baidu channel.
        public var version: Swift.Int?

        public init(
            applicationId: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            credential: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            hasCredential: Swift.Bool? = nil,
            id: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            platform: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.credential = credential
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a one-time message that's sent directly to an endpoint through the Baidu (Baidu Cloud Push) channel.
    public struct BaiduMessage: Swift.Sendable {
        /// The action to occur if the recipient taps the push notification. Valid values are:
        ///
        /// * OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.
        ///
        /// * DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.
        ///
        /// * URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public var action: PinpointClientTypes.Action?
        /// The body of the notification message.
        public var body: Swift.String?
        /// The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.
        public var data: [Swift.String: Swift.String]?
        /// The icon image name of the asset saved in your app.
        public var iconReference: Swift.String?
        /// The URL of the large icon image to display in the content view of the push notification.
        public var imageIconUrl: Swift.String?
        /// The URL of an image to display in the push notification.
        public var imageUrl: Swift.String?
        /// The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.
        public var rawContent: Swift.String?
        /// Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.
        public var silentPush: Swift.Bool?
        /// The URL of the small icon image to display in the status bar and the content view of the push notification.
        public var smallImageIconUrl: Swift.String?
        /// The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.
        public var sound: Swift.String?
        /// The default message variables to use in the notification message. You can override the default variables with individual address variables.
        public var substitutions: [Swift.String: [Swift.String]]?
        /// The amount of time, in seconds, that the Baidu Cloud Push service should store the message if the recipient's device is offline. The default value and maximum supported time is 604,800 seconds (7 days).
        public var timeToLive: Swift.Int?
        /// The title to display above the notification message on the recipient's device.
        public var title: Swift.String?
        /// The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.
        public var url: Swift.String?

        public init(
            action: PinpointClientTypes.Action? = nil,
            body: Swift.String? = nil,
            data: [Swift.String: Swift.String]? = nil,
            iconReference: Swift.String? = nil,
            imageIconUrl: Swift.String? = nil,
            imageUrl: Swift.String? = nil,
            rawContent: Swift.String? = nil,
            silentPush: Swift.Bool? = nil,
            smallImageIconUrl: Swift.String? = nil,
            sound: Swift.String? = nil,
            substitutions: [Swift.String: [Swift.String]]? = nil,
            timeToLive: Swift.Int? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.action = action
            self.body = body
            self.data = data
            self.iconReference = iconReference
            self.imageIconUrl = imageIconUrl
            self.imageUrl = imageUrl
            self.rawContent = rawContent
            self.silentPush = silentPush
            self.smallImageIconUrl = smallImageIconUrl
            self.sound = sound
            self.substitutions = substitutions
            self.timeToLive = timeToLive
            self.title = title
            self.url = url
        }
    }
}

extension PinpointClientTypes {

    public enum ButtonAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case close
        case deepLink
        case link
        case sdkUnknown(Swift.String)

        public static var allCases: [ButtonAction] {
            return [
                .close,
                .deepLink,
                .link
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .close: return "CLOSE"
            case .deepLink: return "DEEP_LINK"
            case .link: return "LINK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the contents of a message that's sent through a custom channel to recipients of a campaign.
    public struct CampaignCustomMessage: Swift.Sendable {
        /// The raw, JSON-formatted string to use as the payload for the message. The maximum size is 5 KB.
        public var data: Swift.String?

        public init(
            data: Swift.String? = nil
        )
        {
            self.data = data
        }
    }
}

extension PinpointClientTypes {

    /// Provides the results of a query that retrieved the data for a standard metric that applies to a campaign, and provides information about that query.
    public struct CampaignDateRangeKpiResponse: Swift.Sendable {
        /// The unique identifier for the application that the metric applies to.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The unique identifier for the campaign that the metric applies to.
        /// This member is required.
        public var campaignId: Swift.String?
        /// The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// The name of the metric, also referred to as a key performance indicator (KPI), that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the [Amazon Pinpoint Developer Guide](https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html).
        /// This member is required.
        public var kpiName: Swift.String?
        /// An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.
        /// This member is required.
        public var kpiResult: PinpointClientTypes.BaseKpiResult?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Campaign Metrics resource because the resource returns all results in a single page.
        public var nextToken: Swift.String?
        /// The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            applicationId: Swift.String? = nil,
            campaignId: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            kpiName: Swift.String? = nil,
            kpiResult: PinpointClientTypes.BaseKpiResult? = nil,
            nextToken: Swift.String? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.endTime = endTime
            self.kpiName = kpiName
            self.kpiResult = kpiResult
            self.nextToken = nextToken
            self.startTime = startTime
        }
    }
}

extension PinpointClientTypes {

    /// Contains the name and value pair of an email header to add to your email. You can have up to 15 MessageHeaders. A header can contain information such as the sender, receiver, route, or timestamp.
    public struct MessageHeader: Swift.Sendable {
        /// The name of the message header. The header name can contain up to 126 characters.
        public var name: Swift.String?
        /// The value of the message header. The header value can contain up to 870 characters, including the length of any rendered attributes. For example if you add the {CreationDate} attribute, it renders as YYYY-MM-DDTHH:MM:SS.SSSZ and is 24 characters in length.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the content and "From" address for an email message that's sent to recipients of a campaign.
    public struct CampaignEmailMessage: Swift.Sendable {
        /// The body of the email for recipients whose email clients don't render HTML content.
        public var body: Swift.String?
        /// The verified email address to send the email from. The default address is the FromAddress specified for the email channel for the application.
        public var fromAddress: Swift.String?
        /// The list of [MessageHeaders](https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-campaigns-campaign-id.html#apps-application-id-campaigns-campaign-id-model-messageheader) for the email. You can have up to 15 MessageHeaders for each email.
        public var headers: [PinpointClientTypes.MessageHeader]?
        /// The body of the email, in HTML format, for recipients whose email clients render HTML content.
        public var htmlBody: Swift.String?
        /// The subject line, or title, of the email.
        public var title: Swift.String?

        public init(
            body: Swift.String? = nil,
            fromAddress: Swift.String? = nil,
            headers: [PinpointClientTypes.MessageHeader]? = nil,
            htmlBody: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.body = body
            self.fromAddress = fromAddress
            self.headers = headers
            self.htmlBody = htmlBody
            self.title = title
        }
    }
}

extension PinpointClientTypes {

    public enum FilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case endpoint
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterType] {
            return [
                .endpoint,
                .system
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .endpoint: return "ENDPOINT"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for events that cause a campaign to be sent.
    public struct CampaignEventFilter: Swift.Sendable {
        /// The dimension settings of the event filter for the campaign.
        /// This member is required.
        public var dimensions: PinpointClientTypes.EventDimensions?
        /// The type of event that causes the campaign to be sent. Valid values are: SYSTEM, sends the campaign when a system event occurs; and, ENDPOINT, sends the campaign when an endpoint event (Events resource) occurs.
        /// This member is required.
        public var filterType: PinpointClientTypes.FilterType?

        public init(
            dimensions: PinpointClientTypes.EventDimensions? = nil,
            filterType: PinpointClientTypes.FilterType? = nil
        )
        {
            self.dimensions = dimensions
            self.filterType = filterType
        }
    }
}

extension PinpointClientTypes {

    /// Text config for Message Body.
    public struct InAppMessageBodyConfig: Swift.Sendable {
        /// The alignment of the text. Valid values: LEFT, CENTER, RIGHT.
        /// This member is required.
        public var alignment: PinpointClientTypes.Alignment?
        /// Message Body.
        /// This member is required.
        public var body: Swift.String?
        /// The text color.
        /// This member is required.
        public var textColor: Swift.String?

        public init(
            alignment: PinpointClientTypes.Alignment? = nil,
            body: Swift.String? = nil,
            textColor: Swift.String? = nil
        )
        {
            self.alignment = alignment
            self.body = body
            self.textColor = textColor
        }
    }
}

extension PinpointClientTypes {

    /// Text config for Message Header.
    public struct InAppMessageHeaderConfig: Swift.Sendable {
        /// The alignment of the text. Valid values: LEFT, CENTER, RIGHT.
        /// This member is required.
        public var alignment: PinpointClientTypes.Alignment?
        /// Message Header.
        /// This member is required.
        public var header: Swift.String?
        /// The text color.
        /// This member is required.
        public var textColor: Swift.String?

        public init(
            alignment: PinpointClientTypes.Alignment? = nil,
            header: Swift.String? = nil,
            textColor: Swift.String? = nil
        )
        {
            self.alignment = alignment
            self.header = header
            self.textColor = textColor
        }
    }
}

extension PinpointClientTypes {

    /// Override button configuration.
    public struct OverrideButtonConfiguration: Swift.Sendable {
        /// Action triggered by the button.
        /// This member is required.
        public var buttonAction: PinpointClientTypes.ButtonAction?
        /// Button destination.
        public var link: Swift.String?

        public init(
            buttonAction: PinpointClientTypes.ButtonAction? = nil,
            link: Swift.String? = nil
        )
        {
            self.buttonAction = buttonAction
            self.link = link
        }
    }
}

extension PinpointClientTypes {

    /// Default button configuration.
    public struct DefaultButtonConfiguration: Swift.Sendable {
        /// The background color of the button.
        public var backgroundColor: Swift.String?
        /// The border radius of the button.
        public var borderRadius: Swift.Int?
        /// Action triggered by the button.
        /// This member is required.
        public var buttonAction: PinpointClientTypes.ButtonAction?
        /// Button destination.
        public var link: Swift.String?
        /// Button text.
        /// This member is required.
        public var text: Swift.String?
        /// The text color of the button.
        public var textColor: Swift.String?

        public init(
            backgroundColor: Swift.String? = nil,
            borderRadius: Swift.Int? = nil,
            buttonAction: PinpointClientTypes.ButtonAction? = nil,
            link: Swift.String? = nil,
            text: Swift.String? = nil,
            textColor: Swift.String? = nil
        )
        {
            self.backgroundColor = backgroundColor
            self.borderRadius = borderRadius
            self.buttonAction = buttonAction
            self.link = link
            self.text = text
            self.textColor = textColor
        }
    }
}

extension PinpointClientTypes {

    /// Button Config for an in-app message.
    public struct InAppMessageButton: Swift.Sendable {
        /// Default button content.
        public var android: PinpointClientTypes.OverrideButtonConfiguration?
        /// Default button content.
        public var defaultConfig: PinpointClientTypes.DefaultButtonConfiguration?
        /// Default button content.
        public var ios: PinpointClientTypes.OverrideButtonConfiguration?
        /// Default button content.
        public var web: PinpointClientTypes.OverrideButtonConfiguration?

        public init(
            android: PinpointClientTypes.OverrideButtonConfiguration? = nil,
            defaultConfig: PinpointClientTypes.DefaultButtonConfiguration? = nil,
            ios: PinpointClientTypes.OverrideButtonConfiguration? = nil,
            web: PinpointClientTypes.OverrideButtonConfiguration? = nil
        )
        {
            self.android = android
            self.defaultConfig = defaultConfig
            self.ios = ios
            self.web = web
        }
    }
}

extension PinpointClientTypes {

    /// The configuration for the message content.
    public struct InAppMessageContent: Swift.Sendable {
        /// The background color for the message.
        public var backgroundColor: Swift.String?
        /// The configuration for the message body.
        public var bodyConfig: PinpointClientTypes.InAppMessageBodyConfig?
        /// The configuration for the message header.
        public var headerConfig: PinpointClientTypes.InAppMessageHeaderConfig?
        /// The image url for the background of message.
        public var imageUrl: Swift.String?
        /// The first button inside the message.
        public var primaryBtn: PinpointClientTypes.InAppMessageButton?
        /// The second button inside message.
        public var secondaryBtn: PinpointClientTypes.InAppMessageButton?

        public init(
            backgroundColor: Swift.String? = nil,
            bodyConfig: PinpointClientTypes.InAppMessageBodyConfig? = nil,
            headerConfig: PinpointClientTypes.InAppMessageHeaderConfig? = nil,
            imageUrl: Swift.String? = nil,
            primaryBtn: PinpointClientTypes.InAppMessageButton? = nil,
            secondaryBtn: PinpointClientTypes.InAppMessageButton? = nil
        )
        {
            self.backgroundColor = backgroundColor
            self.bodyConfig = bodyConfig
            self.headerConfig = headerConfig
            self.imageUrl = imageUrl
            self.primaryBtn = primaryBtn
            self.secondaryBtn = secondaryBtn
        }
    }
}

extension PinpointClientTypes {

    public enum Layout: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bottomBanner
        case carousel
        case middleBanner
        case mobileFeed
        case overlays
        case topBanner
        case sdkUnknown(Swift.String)

        public static var allCases: [Layout] {
            return [
                .bottomBanner,
                .carousel,
                .middleBanner,
                .mobileFeed,
                .overlays,
                .topBanner
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bottomBanner: return "BOTTOM_BANNER"
            case .carousel: return "CAROUSEL"
            case .middleBanner: return "MIDDLE_BANNER"
            case .mobileFeed: return "MOBILE_FEED"
            case .overlays: return "OVERLAYS"
            case .topBanner: return "TOP_BANNER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// In-app message configuration.
    public struct CampaignInAppMessage: Swift.Sendable {
        /// The message body of the notification, the email body or the text message.
        public var body: Swift.String?
        /// In-app message content.
        public var content: [PinpointClientTypes.InAppMessageContent]?
        /// Custom config to be sent to client.
        public var customConfig: [Swift.String: Swift.String]?
        /// In-app message layout.
        public var layout: PinpointClientTypes.Layout?

        public init(
            body: Swift.String? = nil,
            content: [PinpointClientTypes.InAppMessageContent]? = nil,
            customConfig: [Swift.String: Swift.String]? = nil,
            layout: PinpointClientTypes.Layout? = nil
        )
        {
            self.body = body
            self.content = content
            self.customConfig = customConfig
            self.layout = layout
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the delivery configuration settings for sending a campaign or campaign treatment through a custom channel. This object is required if you use the CampaignCustomMessage object to define the message to send for the campaign or campaign treatment.
    public struct CustomDeliveryConfiguration: Swift.Sendable {
        /// The destination to send the campaign or treatment to. This value can be one of the following:
        ///
        /// * The name or Amazon Resource Name (ARN) of an AWS Lambda function to invoke to handle delivery of the campaign or treatment.
        ///
        /// * The URL for a web application or service that supports HTTPS and can receive the message. The URL has to be a full URL, including the HTTPS protocol.
        /// This member is required.
        public var deliveryUri: Swift.String?
        /// The types of endpoints to send the campaign or treatment to. Each valid value maps to a type of channel that you can associate with an endpoint by using the ChannelType property of an endpoint.
        public var endpointTypes: [PinpointClientTypes.__EndpointTypesElement]?

        public init(
            deliveryUri: Swift.String? = nil,
            endpointTypes: [PinpointClientTypes.__EndpointTypesElement]? = nil
        )
        {
            self.deliveryUri = deliveryUri
            self.endpointTypes = endpointTypes
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the content and settings for a push notification that's sent to recipients of a campaign.
    public struct Message: Swift.Sendable {
        /// The action to occur if a recipient taps the push notification. Valid values are:
        ///
        /// * OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.
        ///
        /// * DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of iOS and Android.
        ///
        /// * URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public var action: PinpointClientTypes.Action?
        /// The body of the notification message. The maximum number of characters is 200.
        public var body: Swift.String?
        /// The URL of the image to display as the push-notification icon, such as the icon for the app.
        public var imageIconUrl: Swift.String?
        /// The URL of the image to display as the small, push-notification icon, such as a small version of the icon for the app.
        public var imageSmallIconUrl: Swift.String?
        /// The URL of an image to display in the push notification.
        public var imageUrl: Swift.String?
        /// The JSON payload to use for a silent push notification.
        public var jsonBody: Swift.String?
        /// The URL of the image or video to display in the push notification.
        public var mediaUrl: Swift.String?
        /// The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.
        public var rawContent: Swift.String?
        /// Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration, displaying messages in an in-app message center, or supporting phone home functionality.
        public var silentPush: Swift.Bool?
        /// The number of seconds that the push-notification service should keep the message, if the service is unable to deliver the notification the first time. This value is converted to an expiration value when it's sent to a push-notification service. If this value is 0, the service treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again. This value doesn't apply to messages that are sent through the Amazon Device Messaging (ADM) service.
        public var timeToLive: Swift.Int?
        /// The title to display above the notification message on a recipient's device.
        public var title: Swift.String?
        /// The URL to open in a recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.
        public var url: Swift.String?

        public init(
            action: PinpointClientTypes.Action? = nil,
            body: Swift.String? = nil,
            imageIconUrl: Swift.String? = nil,
            imageSmallIconUrl: Swift.String? = nil,
            imageUrl: Swift.String? = nil,
            jsonBody: Swift.String? = nil,
            mediaUrl: Swift.String? = nil,
            rawContent: Swift.String? = nil,
            silentPush: Swift.Bool? = nil,
            timeToLive: Swift.Int? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.action = action
            self.body = body
            self.imageIconUrl = imageIconUrl
            self.imageSmallIconUrl = imageSmallIconUrl
            self.imageUrl = imageUrl
            self.jsonBody = jsonBody
            self.mediaUrl = mediaUrl
            self.rawContent = rawContent
            self.silentPush = silentPush
            self.timeToLive = timeToLive
            self.title = title
            self.url = url
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the content and settings for an SMS message that's sent to recipients of a campaign.
    public struct CampaignSmsMessage: Swift.Sendable {
        /// The body of the SMS message.
        public var body: Swift.String?
        /// The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.
        public var entityId: Swift.String?
        /// The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).
        public var messageType: PinpointClientTypes.MessageType?
        /// The long code to send the SMS message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code using an E.164 format to ensure prompt and accurate delivery of the message. For example, +12065550100.
        public var originationNumber: Swift.String?
        /// The sender ID to display on recipients' devices when they receive the SMS message.
        public var senderId: Swift.String?
        /// The template ID received from the regulatory body for sending SMS in your country.
        public var templateId: Swift.String?

        public init(
            body: Swift.String? = nil,
            entityId: Swift.String? = nil,
            messageType: PinpointClientTypes.MessageType? = nil,
            originationNumber: Swift.String? = nil,
            senderId: Swift.String? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.body = body
            self.entityId = entityId
            self.messageType = messageType
            self.originationNumber = originationNumber
            self.senderId = senderId
            self.templateId = templateId
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the message configuration settings for a campaign.
    public struct MessageConfiguration: Swift.Sendable {
        /// The message that the campaign sends through the ADM (Amazon Device Messaging) channel. If specified, this message overrides the default message.
        public var admMessage: PinpointClientTypes.Message?
        /// The message that the campaign sends through the APNs (Apple Push Notification service) channel. If specified, this message overrides the default message.
        public var apnsMessage: PinpointClientTypes.Message?
        /// The message that the campaign sends through the Baidu (Baidu Cloud Push) channel. If specified, this message overrides the default message.
        public var baiduMessage: PinpointClientTypes.Message?
        /// The message that the campaign sends through a custom channel, as specified by the delivery configuration (CustomDeliveryConfiguration) settings for the campaign. If specified, this message overrides the default message.
        public var customMessage: PinpointClientTypes.CampaignCustomMessage?
        /// The default message that the campaign sends through all the channels that are configured for the campaign.
        public var defaultMessage: PinpointClientTypes.Message?
        /// The message that the campaign sends through the email channel. If specified, this message overrides the default message.
        public var emailMessage: PinpointClientTypes.CampaignEmailMessage?
        /// The message that the campaign sends through the GCM channel, which enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. If specified, this message overrides the default message.
        public var gcmMessage: PinpointClientTypes.Message?
        /// The in-app message configuration.
        public var inAppMessage: PinpointClientTypes.CampaignInAppMessage?
        /// The message that the campaign sends through the SMS channel. If specified, this message overrides the default message.
        public var smsMessage: PinpointClientTypes.CampaignSmsMessage?

        public init(
            admMessage: PinpointClientTypes.Message? = nil,
            apnsMessage: PinpointClientTypes.Message? = nil,
            baiduMessage: PinpointClientTypes.Message? = nil,
            customMessage: PinpointClientTypes.CampaignCustomMessage? = nil,
            defaultMessage: PinpointClientTypes.Message? = nil,
            emailMessage: PinpointClientTypes.CampaignEmailMessage? = nil,
            gcmMessage: PinpointClientTypes.Message? = nil,
            inAppMessage: PinpointClientTypes.CampaignInAppMessage? = nil,
            smsMessage: PinpointClientTypes.CampaignSmsMessage? = nil
        )
        {
            self.admMessage = admMessage
            self.apnsMessage = apnsMessage
            self.baiduMessage = baiduMessage
            self.customMessage = customMessage
            self.defaultMessage = defaultMessage
            self.emailMessage = emailMessage
            self.gcmMessage = gcmMessage
            self.inAppMessage = inAppMessage
            self.smsMessage = smsMessage
        }
    }
}

extension PinpointClientTypes {

    public enum Frequency: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case daily
        case event
        case hourly
        case inAppEvent
        case monthly
        case once
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [Frequency] {
            return [
                .daily,
                .event,
                .hourly,
                .inAppEvent,
                .monthly,
                .once,
                .weekly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .event: return "EVENT"
            case .hourly: return "HOURLY"
            case .inAppEvent: return "IN_APP_EVENT"
            case .monthly: return "MONTHLY"
            case .once: return "ONCE"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the schedule settings for a campaign.
    public struct Schedule: Swift.Sendable {
        /// The scheduled time, in ISO 8601 format, when the campaign ended or will end.
        public var endTime: Swift.String?
        /// The type of event that causes the campaign to be sent, if the value of the Frequency property is EVENT.
        public var eventFilter: PinpointClientTypes.CampaignEventFilter?
        /// Specifies how often the campaign is sent or whether the campaign is sent in response to a specific event.
        public var frequency: PinpointClientTypes.Frequency?
        /// Specifies whether the start and end times for the campaign schedule use each recipient's local time. To base the schedule on each recipient's local time, set this value to true.
        public var isLocalTime: Swift.Bool?
        /// The default quiet time for the campaign. Quiet time is a specific time range when a campaign doesn't send messages to endpoints, if all the following conditions are met:
        ///
        /// * The EndpointDemographic.Timezone property of the endpoint is set to a valid value.
        ///
        /// * The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the campaign.
        ///
        /// * The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the campaign.
        ///
        ///
        /// If any of the preceding conditions isn't met, the endpoint will receive messages from the campaign, even if quiet time is enabled.
        public var quietTime: PinpointClientTypes.QuietTime?
        /// The scheduled time when the campaign began or will begin. Valid values are: IMMEDIATE, to start the campaign immediately; or, a specific time in ISO 8601 format.
        /// This member is required.
        public var startTime: Swift.String?
        /// The starting UTC offset for the campaign schedule, if the value of the IsLocalTime property is true. Valid values are: UTC, UTC+01, UTC+02, UTC+03, UTC+03:30, UTC+04, UTC+04:30, UTC+05, UTC+05:30, UTC+05:45, UTC+06, UTC+06:30, UTC+07, UTC+08, UTC+09, UTC+09:30, UTC+10, UTC+10:30, UTC+11, UTC+12, UTC+13, UTC-02, UTC-03, UTC-04, UTC-05, UTC-06, UTC-07, UTC-08, UTC-09, UTC-10, and UTC-11.
        public var timezone: Swift.String?

        public init(
            endTime: Swift.String? = nil,
            eventFilter: PinpointClientTypes.CampaignEventFilter? = nil,
            frequency: PinpointClientTypes.Frequency? = nil,
            isLocalTime: Swift.Bool? = nil,
            quietTime: PinpointClientTypes.QuietTime? = nil,
            startTime: Swift.String? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.eventFilter = eventFilter
            self.frequency = frequency
            self.isLocalTime = isLocalTime
            self.quietTime = quietTime
            self.startTime = startTime
            self.timezone = timezone
        }
    }
}

extension PinpointClientTypes {

    public enum CampaignStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case deleted
        case executing
        case invalid
        case paused
        case pendingNextRun
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [CampaignStatus] {
            return [
                .completed,
                .deleted,
                .executing,
                .invalid,
                .paused,
                .pendingNextRun,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .deleted: return "DELETED"
            case .executing: return "EXECUTING"
            case .invalid: return "INVALID"
            case .paused: return "PAUSED"
            case .pendingNextRun: return "PENDING_NEXT_RUN"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the status of a campaign.
    public struct CampaignState: Swift.Sendable {
        /// The current status of the campaign, or the current status of a treatment that belongs to an A/B test campaign. If a campaign uses A/B testing, the campaign has a status of COMPLETED only if all campaign treatments have a status of COMPLETED. If you delete the segment that's associated with a campaign, the campaign fails and has a status of DELETED.
        public var campaignStatus: PinpointClientTypes.CampaignStatus?

        public init(
            campaignStatus: PinpointClientTypes.CampaignStatus? = nil
        )
        {
            self.campaignStatus = campaignStatus
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the name and version of the message template to use for the message.
    public struct Template: Swift.Sendable {
        /// The name of the message template to use for the message. If specified, this value must match the name of an existing message template.
        public var name: Swift.String?
        /// The unique identifier for the version of the message template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the Template Versions resource. If you don't specify a value for this property, Amazon Pinpoint uses the active version of the template. The active version is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.
        public var version: Swift.String?

        public init(
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the message template to use for the message, for each type of channel.
    public struct TemplateConfiguration: Swift.Sendable {
        /// The email template to use for the message.
        public var emailTemplate: PinpointClientTypes.Template?
        /// The InApp template to use for the message. The InApp template object is not supported for SendMessages.
        public var inAppTemplate: PinpointClientTypes.Template?
        /// The push notification template to use for the message.
        public var pushTemplate: PinpointClientTypes.Template?
        /// The SMS template to use for the message.
        public var smsTemplate: PinpointClientTypes.Template?
        /// The voice template to use for the message. This object isn't supported for campaigns.
        public var voiceTemplate: PinpointClientTypes.Template?

        public init(
            emailTemplate: PinpointClientTypes.Template? = nil,
            inAppTemplate: PinpointClientTypes.Template? = nil,
            pushTemplate: PinpointClientTypes.Template? = nil,
            smsTemplate: PinpointClientTypes.Template? = nil,
            voiceTemplate: PinpointClientTypes.Template? = nil
        )
        {
            self.emailTemplate = emailTemplate
            self.inAppTemplate = inAppTemplate
            self.pushTemplate = pushTemplate
            self.smsTemplate = smsTemplate
            self.voiceTemplate = voiceTemplate
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a campaign treatment. A treatment is a variation of a campaign that's used for A/B testing of a campaign.
    public struct TreatmentResource: Swift.Sendable {
        /// The delivery configuration settings for sending the treatment through a custom channel. This object is required if the MessageConfiguration object for the treatment specifies a CustomMessage object.
        public var customDeliveryConfiguration: PinpointClientTypes.CustomDeliveryConfiguration?
        /// The unique identifier for the treatment.
        /// This member is required.
        public var id: Swift.String?
        /// The message configuration settings for the treatment.
        public var messageConfiguration: PinpointClientTypes.MessageConfiguration?
        /// The schedule settings for the treatment.
        public var schedule: PinpointClientTypes.Schedule?
        /// The allocated percentage of users (segment members) that the treatment is sent to.
        /// This member is required.
        public var sizePercent: Swift.Int?
        /// The current status of the treatment.
        public var state: PinpointClientTypes.CampaignState?
        /// The message template to use for the treatment.
        public var templateConfiguration: PinpointClientTypes.TemplateConfiguration?
        /// The custom description of the treatment.
        public var treatmentDescription: Swift.String?
        /// The custom name of the treatment.
        public var treatmentName: Swift.String?

        public init(
            customDeliveryConfiguration: PinpointClientTypes.CustomDeliveryConfiguration? = nil,
            id: Swift.String? = nil,
            messageConfiguration: PinpointClientTypes.MessageConfiguration? = nil,
            schedule: PinpointClientTypes.Schedule? = nil,
            sizePercent: Swift.Int? = nil,
            state: PinpointClientTypes.CampaignState? = nil,
            templateConfiguration: PinpointClientTypes.TemplateConfiguration? = nil,
            treatmentDescription: Swift.String? = nil,
            treatmentName: Swift.String? = nil
        )
        {
            self.customDeliveryConfiguration = customDeliveryConfiguration
            self.id = id
            self.messageConfiguration = messageConfiguration
            self.schedule = schedule
            self.sizePercent = sizePercent
            self.state = state
            self.templateConfiguration = templateConfiguration
            self.treatmentDescription = treatmentDescription
            self.treatmentName = treatmentName
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the status, configuration, and other settings for a campaign.
    public struct CampaignResponse: Swift.Sendable {
        /// An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.
        public var additionalTreatments: [PinpointClientTypes.TreatmentResource]?
        /// The unique identifier for the application that the campaign applies to.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the campaign.
        /// This member is required.
        public var arn: Swift.String?
        /// The date, in ISO 8601 format, when the campaign was created.
        /// This member is required.
        public var creationDate: Swift.String?
        /// The delivery configuration settings for sending the campaign through a custom channel.
        public var customDeliveryConfiguration: PinpointClientTypes.CustomDeliveryConfiguration?
        /// The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.
        public var defaultState: PinpointClientTypes.CampaignState?
        /// The custom description of the campaign.
        public var description: Swift.String?
        /// The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.
        public var holdoutPercent: Swift.Int?
        /// The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.
        public var hook: PinpointClientTypes.CampaignHook?
        /// The unique identifier for the campaign.
        /// This member is required.
        public var id: Swift.String?
        /// Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.
        public var isPaused: Swift.Bool?
        /// The date, in ISO 8601 format, when the campaign was last modified.
        /// This member is required.
        public var lastModifiedDate: Swift.String?
        /// The messaging limits for the campaign.
        public var limits: PinpointClientTypes.CampaignLimits?
        /// The message configuration settings for the campaign.
        public var messageConfiguration: PinpointClientTypes.MessageConfiguration?
        /// The name of the campaign.
        public var name: Swift.String?
        /// Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.
        public var priority: Swift.Int?
        /// The schedule settings for the campaign.
        public var schedule: PinpointClientTypes.Schedule?
        /// The unique identifier for the segment that's associated with the campaign.
        /// This member is required.
        public var segmentId: Swift.String?
        /// The version number of the segment that's associated with the campaign.
        /// This member is required.
        public var segmentVersion: Swift.Int?
        /// The current status of the campaign.
        public var state: PinpointClientTypes.CampaignState?
        /// A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?
        /// The message template that’s used for the campaign.
        public var templateConfiguration: PinpointClientTypes.TemplateConfiguration?
        /// The custom description of the default treatment for the campaign.
        public var treatmentDescription: Swift.String?
        /// The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A treatment is a variation of a campaign that's used for A/B testing.
        public var treatmentName: Swift.String?
        /// The version number of the campaign.
        public var version: Swift.Int?

        public init(
            additionalTreatments: [PinpointClientTypes.TreatmentResource]? = nil,
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            customDeliveryConfiguration: PinpointClientTypes.CustomDeliveryConfiguration? = nil,
            defaultState: PinpointClientTypes.CampaignState? = nil,
            description: Swift.String? = nil,
            holdoutPercent: Swift.Int? = nil,
            hook: PinpointClientTypes.CampaignHook? = nil,
            id: Swift.String? = nil,
            isPaused: Swift.Bool? = nil,
            lastModifiedDate: Swift.String? = nil,
            limits: PinpointClientTypes.CampaignLimits? = nil,
            messageConfiguration: PinpointClientTypes.MessageConfiguration? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            schedule: PinpointClientTypes.Schedule? = nil,
            segmentId: Swift.String? = nil,
            segmentVersion: Swift.Int? = nil,
            state: PinpointClientTypes.CampaignState? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateConfiguration: PinpointClientTypes.TemplateConfiguration? = nil,
            treatmentDescription: Swift.String? = nil,
            treatmentName: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.additionalTreatments = additionalTreatments
            self.applicationId = applicationId
            self.arn = arn
            self.creationDate = creationDate
            self.customDeliveryConfiguration = customDeliveryConfiguration
            self.defaultState = defaultState
            self.description = description
            self.holdoutPercent = holdoutPercent
            self.hook = hook
            self.id = id
            self.isPaused = isPaused
            self.lastModifiedDate = lastModifiedDate
            self.limits = limits
            self.messageConfiguration = messageConfiguration
            self.name = name
            self.priority = priority
            self.schedule = schedule
            self.segmentId = segmentId
            self.segmentVersion = segmentVersion
            self.state = state
            self.tags = tags
            self.templateConfiguration = templateConfiguration
            self.treatmentDescription = treatmentDescription
            self.treatmentName = treatmentName
            self.version = version
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the configuration and other settings for all the campaigns that are associated with an application.
    public struct CampaignsResponse: Swift.Sendable {
        /// An array of responses, one for each campaign that's associated with the application.
        /// This member is required.
        public var item: [PinpointClientTypes.CampaignResponse]?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public var nextToken: Swift.String?

        public init(
            item: [PinpointClientTypes.CampaignResponse]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.item = item
            self.nextToken = nextToken
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the general settings and status of a channel for an application.
    public struct ChannelResponse: Swift.Sendable {
        /// The unique identifier for the application.
        public var applicationId: Swift.String?
        /// The date and time, in ISO 8601 format, when the channel was enabled.
        public var creationDate: Swift.String?
        /// Specifies whether the channel is enabled for the application.
        public var enabled: Swift.Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public var hasCredential: Swift.Bool?
        /// (Deprecated) An identifier for the channel. This property is retained only for backward compatibility.
        public var id: Swift.String?
        /// Specifies whether the channel is archived.
        public var isArchived: Swift.Bool?
        /// The user who last modified the channel.
        public var lastModifiedBy: Swift.String?
        /// The date and time, in ISO 8601 format, when the channel was last modified.
        public var lastModifiedDate: Swift.String?
        /// The current version of the channel.
        public var version: Swift.Int?

        public init(
            applicationId: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            hasCredential: Swift.Bool? = nil,
            id: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.version = version
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the general settings and status of all channels for an application, including channels that aren't enabled for the application.
    public struct ChannelsResponse: Swift.Sendable {
        /// A map that contains a multipart response for each channel. For each item in this object, the ChannelType is the key and the Channel is the value.
        /// This member is required.
        public var channels: [Swift.String: PinpointClientTypes.ChannelResponse]?

        public init(
            channels: [Swift.String: PinpointClientTypes.ChannelResponse]? = nil
        )
        {
            self.channels = channels
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the rule settings for when messages can't be sent.
    public struct ClosedDaysRule: Swift.Sendable {
        /// End DateTime ISO 8601 format
        public var endDateTime: Swift.String?
        /// The name of the closed day rule.
        public var name: Swift.String?
        /// Start DateTime ISO 8601 format
        public var startDateTime: Swift.String?

        public init(
            endDateTime: Swift.String? = nil,
            name: Swift.String? = nil,
            startDateTime: Swift.String? = nil
        )
        {
            self.endDateTime = endDateTime
            self.name = name
            self.startDateTime = startDateTime
        }
    }
}

extension PinpointClientTypes {

    /// The time when a journey will not send messages. QuietTime should be configured first and SendingSchedule should be set to true.
    public struct ClosedDays: Swift.Sendable {
        /// Rules for the Custom channel.
        public var custom: [PinpointClientTypes.ClosedDaysRule]?
        /// Rules for the Email channel.
        public var email: [PinpointClientTypes.ClosedDaysRule]?
        /// Rules for the Push channel.
        public var push: [PinpointClientTypes.ClosedDaysRule]?
        /// Rules for the SMS channel.
        public var sms: [PinpointClientTypes.ClosedDaysRule]?
        /// Rules for the Voice channel.
        public var voice: [PinpointClientTypes.ClosedDaysRule]?

        public init(
            custom: [PinpointClientTypes.ClosedDaysRule]? = nil,
            email: [PinpointClientTypes.ClosedDaysRule]? = nil,
            push: [PinpointClientTypes.ClosedDaysRule]? = nil,
            sms: [PinpointClientTypes.ClosedDaysRule]? = nil,
            voice: [PinpointClientTypes.ClosedDaysRule]? = nil
        )
        {
            self.custom = custom
            self.email = email
            self.push = push
            self.sms = sms
            self.voice = voice
        }
    }
}

/// Provides information about an API request or response.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message that's returned from the API.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the request or response.
        public internal(set) var requestID: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestID: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestID = requestID
    }
}

/// Provides information about an API request or response.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message that's returned from the API.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the request or response.
        public internal(set) var requestID: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestID: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestID = requestID
    }
}

/// Provides information about an API request or response.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message that's returned from the API.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the request or response.
        public internal(set) var requestID: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestID: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestID = requestID
    }
}

/// Provides information about an API request or response.
public struct MethodNotAllowedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message that's returned from the API.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the request or response.
        public internal(set) var requestID: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MethodNotAllowedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestID: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestID = requestID
    }
}

/// Provides information about an API request or response.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message that's returned from the API.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the request or response.
        public internal(set) var requestID: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestID: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestID = requestID
    }
}

/// Provides information about an API request or response.
public struct PayloadTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message that's returned from the API.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the request or response.
        public internal(set) var requestID: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PayloadTooLargeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestID: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestID = requestID
    }
}

/// Provides information about an API request or response.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message that's returned from the API.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier for the request or response.
        public internal(set) var requestID: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestID: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestID = requestID
    }
}

extension PinpointClientTypes {

    /// Specifies the display name of an application and the tags to associate with the application.
    public struct CreateApplicationRequest: Swift.Sendable {
        /// The display name of the application. This name is displayed as the Project name on the Amazon Pinpoint console.
        /// This member is required.
        public var name: Swift.String?
        /// A string-to-string map of key-value pairs that defines the tags to associate with the application. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?

        public init(
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.name = name
            self.tags = tags
        }
    }
}

public struct CreateAppInput: Swift.Sendable {
    /// Specifies the display name of an application and the tags to associate with the application.
    /// This member is required.
    public var createApplicationRequest: PinpointClientTypes.CreateApplicationRequest?

    public init(
        createApplicationRequest: PinpointClientTypes.CreateApplicationRequest? = nil
    )
    {
        self.createApplicationRequest = createApplicationRequest
    }
}

public struct CreateAppOutput: Swift.Sendable {
    /// Provides information about an application.
    /// This member is required.
    public var applicationResponse: PinpointClientTypes.ApplicationResponse?

    public init(
        applicationResponse: PinpointClientTypes.ApplicationResponse? = nil
    )
    {
        self.applicationResponse = applicationResponse
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a campaign treatment. A treatment is a variation of a campaign that's used for A/B testing of a campaign.
    public struct WriteTreatmentResource: Swift.Sendable {
        /// The delivery configuration settings for sending the treatment through a custom channel. This object is required if the MessageConfiguration object for the treatment specifies a CustomMessage object.
        public var customDeliveryConfiguration: PinpointClientTypes.CustomDeliveryConfiguration?
        /// The message configuration settings for the treatment.
        public var messageConfiguration: PinpointClientTypes.MessageConfiguration?
        /// The schedule settings for the treatment.
        public var schedule: PinpointClientTypes.Schedule?
        /// The allocated percentage of users (segment members) to send the treatment to.
        /// This member is required.
        public var sizePercent: Swift.Int?
        /// The message template to use for the treatment.
        public var templateConfiguration: PinpointClientTypes.TemplateConfiguration?
        /// A custom description of the treatment.
        public var treatmentDescription: Swift.String?
        /// A custom name for the treatment.
        public var treatmentName: Swift.String?

        public init(
            customDeliveryConfiguration: PinpointClientTypes.CustomDeliveryConfiguration? = nil,
            messageConfiguration: PinpointClientTypes.MessageConfiguration? = nil,
            schedule: PinpointClientTypes.Schedule? = nil,
            sizePercent: Swift.Int? = nil,
            templateConfiguration: PinpointClientTypes.TemplateConfiguration? = nil,
            treatmentDescription: Swift.String? = nil,
            treatmentName: Swift.String? = nil
        )
        {
            self.customDeliveryConfiguration = customDeliveryConfiguration
            self.messageConfiguration = messageConfiguration
            self.schedule = schedule
            self.sizePercent = sizePercent
            self.templateConfiguration = templateConfiguration
            self.treatmentDescription = treatmentDescription
            self.treatmentName = treatmentName
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the configuration and other settings for a campaign.
    public struct WriteCampaignRequest: Swift.Sendable {
        /// An array of requests that defines additional treatments for the campaign, in addition to the default treatment for the campaign.
        public var additionalTreatments: [PinpointClientTypes.WriteTreatmentResource]?
        /// The delivery configuration settings for sending the campaign through a custom channel. This object is required if the MessageConfiguration object for the campaign specifies a CustomMessage object.
        public var customDeliveryConfiguration: PinpointClientTypes.CustomDeliveryConfiguration?
        /// A custom description of the campaign.
        public var description: Swift.String?
        /// The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.
        public var holdoutPercent: Swift.Int?
        /// The settings for the AWS Lambda function to invoke as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.
        public var hook: PinpointClientTypes.CampaignHook?
        /// Specifies whether to pause the campaign. A paused campaign doesn't run unless you resume it by changing this value to false.
        public var isPaused: Swift.Bool?
        /// The messaging limits for the campaign.
        public var limits: PinpointClientTypes.CampaignLimits?
        /// The message configuration settings for the campaign.
        public var messageConfiguration: PinpointClientTypes.MessageConfiguration?
        /// A custom name for the campaign.
        public var name: Swift.String?
        /// Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.
        public var priority: Swift.Int?
        /// The schedule settings for the campaign.
        public var schedule: PinpointClientTypes.Schedule?
        /// The unique identifier for the segment to associate with the campaign.
        public var segmentId: Swift.String?
        /// The version of the segment to associate with the campaign.
        public var segmentVersion: Swift.Int?
        /// As of 22-05-2023 tags has been deprecated for update operations. After this date any value in tags is not processed and an error code is not returned. To manage tags we recommend using either [Tags](https://docs.aws.amazon.com/pinpoint/latest/apireference/tags-resource-arn.html) in the API Reference for Amazon Pinpoint, [resourcegroupstaggingapi](https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/index.html) commands in the AWS Command Line Interface Documentation or [resourcegroupstaggingapi](https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/resourcegroupstaggingapi/package-summary.html) in the AWS SDK. (Deprecated) A string-to-string map of key-value pairs that defines the tags to associate with the campaign. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?
        /// The message template to use for the campaign.
        public var templateConfiguration: PinpointClientTypes.TemplateConfiguration?
        /// A custom description of the default treatment for the campaign.
        public var treatmentDescription: Swift.String?
        /// A custom name of the default treatment for the campaign, if the campaign has multiple treatments. A treatment is a variation of a campaign that's used for A/B testing.
        public var treatmentName: Swift.String?

        public init(
            additionalTreatments: [PinpointClientTypes.WriteTreatmentResource]? = nil,
            customDeliveryConfiguration: PinpointClientTypes.CustomDeliveryConfiguration? = nil,
            description: Swift.String? = nil,
            holdoutPercent: Swift.Int? = nil,
            hook: PinpointClientTypes.CampaignHook? = nil,
            isPaused: Swift.Bool? = nil,
            limits: PinpointClientTypes.CampaignLimits? = nil,
            messageConfiguration: PinpointClientTypes.MessageConfiguration? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            schedule: PinpointClientTypes.Schedule? = nil,
            segmentId: Swift.String? = nil,
            segmentVersion: Swift.Int? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateConfiguration: PinpointClientTypes.TemplateConfiguration? = nil,
            treatmentDescription: Swift.String? = nil,
            treatmentName: Swift.String? = nil
        )
        {
            self.additionalTreatments = additionalTreatments
            self.customDeliveryConfiguration = customDeliveryConfiguration
            self.description = description
            self.holdoutPercent = holdoutPercent
            self.hook = hook
            self.isPaused = isPaused
            self.limits = limits
            self.messageConfiguration = messageConfiguration
            self.name = name
            self.priority = priority
            self.schedule = schedule
            self.segmentId = segmentId
            self.segmentVersion = segmentVersion
            self.tags = tags
            self.templateConfiguration = templateConfiguration
            self.treatmentDescription = treatmentDescription
            self.treatmentName = treatmentName
        }
    }
}

public struct CreateCampaignInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the configuration and other settings for a campaign.
    /// This member is required.
    public var writeCampaignRequest: PinpointClientTypes.WriteCampaignRequest?

    public init(
        applicationId: Swift.String? = nil,
        writeCampaignRequest: PinpointClientTypes.WriteCampaignRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.writeCampaignRequest = writeCampaignRequest
    }
}

public struct CreateCampaignOutput: Swift.Sendable {
    /// Provides information about the status, configuration, and other settings for a campaign.
    /// This member is required.
    public var campaignResponse: PinpointClientTypes.CampaignResponse?

    public init(
        campaignResponse: PinpointClientTypes.CampaignResponse? = nil
    )
    {
        self.campaignResponse = campaignResponse
    }
}

extension PinpointClientTypes {

    /// Specifies the content and settings for a message template that can be used in messages that are sent through the email channel.
    public struct EmailTemplateRequest: Swift.Sendable {
        /// A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.
        public var defaultSubstitutions: Swift.String?
        /// The list of [MessageHeaders](https://docs.aws.amazon.com/pinpoint/latest/apireference/templates-template-name-email.html#templates-template-name-email-model-messageheader) for the email. You can have up to 15 Headers.
        public var headers: [PinpointClientTypes.MessageHeader]?
        /// The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.
        public var htmlPart: Swift.String?
        /// The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.
        public var recommenderId: Swift.String?
        /// The subject line, or title, to use in email messages that are based on the message template.
        public var subject: Swift.String?
        /// As of 22-05-2023 tags has been deprecated for update operations. After this date any value in tags is not processed and an error code is not returned. To manage tags we recommend using either [Tags](https://docs.aws.amazon.com/pinpoint/latest/apireference/tags-resource-arn.html) in the API Reference for Amazon Pinpoint, [resourcegroupstaggingapi](https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/index.html) commands in the AWS Command Line Interface Documentation or [resourcegroupstaggingapi](https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/resourcegroupstaggingapi/package-summary.html) in the AWS SDK. (Deprecated) A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?
        /// A custom description of the message template.
        public var templateDescription: Swift.String?
        /// The message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.
        public var textPart: Swift.String?

        public init(
            defaultSubstitutions: Swift.String? = nil,
            headers: [PinpointClientTypes.MessageHeader]? = nil,
            htmlPart: Swift.String? = nil,
            recommenderId: Swift.String? = nil,
            subject: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateDescription: Swift.String? = nil,
            textPart: Swift.String? = nil
        )
        {
            self.defaultSubstitutions = defaultSubstitutions
            self.headers = headers
            self.htmlPart = htmlPart
            self.recommenderId = recommenderId
            self.subject = subject
            self.tags = tags
            self.templateDescription = templateDescription
            self.textPart = textPart
        }
    }
}

public struct CreateEmailTemplateInput: Swift.Sendable {
    /// Specifies the content and settings for a message template that can be used in messages that are sent through the email channel.
    /// This member is required.
    public var emailTemplateRequest: PinpointClientTypes.EmailTemplateRequest?
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        emailTemplateRequest: PinpointClientTypes.EmailTemplateRequest? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.emailTemplateRequest = emailTemplateRequest
        self.templateName = templateName
    }
}

extension PinpointClientTypes {

    /// Provides information about a request to create a message template.
    public struct CreateTemplateMessageBody: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the message template that was created.
        public var arn: Swift.String?
        /// The message that's returned from the API for the request to create the message template.
        public var message: Swift.String?
        /// The unique identifier for the request to create the message template.
        public var requestID: Swift.String?

        public init(
            arn: Swift.String? = nil,
            message: Swift.String? = nil,
            requestID: Swift.String? = nil
        )
        {
            self.arn = arn
            self.message = message
            self.requestID = requestID
        }
    }
}

public struct CreateEmailTemplateOutput: Swift.Sendable {
    /// Provides information about a request to create a message template.
    /// This member is required.
    public var createTemplateMessageBody: PinpointClientTypes.CreateTemplateMessageBody?

    public init(
        createTemplateMessageBody: PinpointClientTypes.CreateTemplateMessageBody? = nil
    )
    {
        self.createTemplateMessageBody = createTemplateMessageBody
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a job that exports endpoint definitions to an Amazon Simple Storage Service (Amazon S3) bucket.
    public struct ExportJobRequest: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location where you want to export endpoint definitions to.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The URL of the location in an Amazon Simple Storage Service (Amazon S3) bucket where you want to export endpoint definitions to. This location is typically a folder that contains multiple files. The URL should be in the following format: s3://bucket-name/folder-name/.
        /// This member is required.
        public var s3UrlPrefix: Swift.String?
        /// The identifier for the segment to export endpoint definitions from. If you don't specify this value, Amazon Pinpoint exports definitions for all the endpoints that are associated with the application.
        public var segmentId: Swift.String?
        /// The version of the segment to export endpoint definitions from, if specified.
        public var segmentVersion: Swift.Int?

        public init(
            roleArn: Swift.String? = nil,
            s3UrlPrefix: Swift.String? = nil,
            segmentId: Swift.String? = nil,
            segmentVersion: Swift.Int? = nil
        )
        {
            self.roleArn = roleArn
            self.s3UrlPrefix = s3UrlPrefix
            self.segmentId = segmentId
            self.segmentVersion = segmentVersion
        }
    }
}

public struct CreateExportJobInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the settings for a job that exports endpoint definitions to an Amazon Simple Storage Service (Amazon S3) bucket.
    /// This member is required.
    public var exportJobRequest: PinpointClientTypes.ExportJobRequest?

    public init(
        applicationId: Swift.String? = nil,
        exportJobRequest: PinpointClientTypes.ExportJobRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.exportJobRequest = exportJobRequest
    }
}

extension PinpointClientTypes {

    /// Provides information about the resource settings for a job that exports endpoint definitions to a file. The file can be added directly to an Amazon Simple Storage Service (Amazon S3) bucket by using the Amazon Pinpoint API or downloaded directly to a computer by using the Amazon Pinpoint console.
    public struct ExportJobResource: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorized Amazon Pinpoint to access the Amazon S3 location where the endpoint definitions were exported to.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The URL of the location in an Amazon Simple Storage Service (Amazon S3) bucket where the endpoint definitions were exported to. This location is typically a folder that contains multiple files. The URL should be in the following format: s3://bucket-name/folder-name/.
        /// This member is required.
        public var s3UrlPrefix: Swift.String?
        /// The identifier for the segment that the endpoint definitions were exported from. If this value isn't present, Amazon Pinpoint exported definitions for all the endpoints that are associated with the application.
        public var segmentId: Swift.String?
        /// The version of the segment that the endpoint definitions were exported from.
        public var segmentVersion: Swift.Int?

        public init(
            roleArn: Swift.String? = nil,
            s3UrlPrefix: Swift.String? = nil,
            segmentId: Swift.String? = nil,
            segmentVersion: Swift.Int? = nil
        )
        {
            self.roleArn = roleArn
            self.s3UrlPrefix = s3UrlPrefix
            self.segmentId = segmentId
            self.segmentVersion = segmentVersion
        }
    }
}

extension PinpointClientTypes {

    public enum JobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case completing
        case created
        case failed
        case failing
        case initializing
        case pendingJob
        case preparingForInitialization
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .completing,
                .created,
                .failed,
                .failing,
                .initializing,
                .pendingJob,
                .preparingForInitialization,
                .processing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completing: return "COMPLETING"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .failing: return "FAILING"
            case .initializing: return "INITIALIZING"
            case .pendingJob: return "PENDING_JOB"
            case .preparingForInitialization: return "PREPARING_FOR_INITIALIZATION"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the status and settings of a job that exports endpoint definitions to a file. The file can be added directly to an Amazon Simple Storage Service (Amazon S3) bucket by using the Amazon Pinpoint API or downloaded directly to a computer by using the Amazon Pinpoint console.
    public struct ExportJobResponse: Swift.Sendable {
        /// The unique identifier for the application that's associated with the export job.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The number of pieces that were processed successfully (completed) by the export job, as of the time of the request.
        public var completedPieces: Swift.Int?
        /// The date, in ISO 8601 format, when the export job was completed.
        public var completionDate: Swift.String?
        /// The date, in ISO 8601 format, when the export job was created.
        /// This member is required.
        public var creationDate: Swift.String?
        /// The resource settings that apply to the export job.
        /// This member is required.
        public var definition: PinpointClientTypes.ExportJobResource?
        /// The number of pieces that weren't processed successfully (failed) by the export job, as of the time of the request.
        public var failedPieces: Swift.Int?
        /// An array of entries, one for each of the first 100 entries that weren't processed successfully (failed) by the export job, if any.
        public var failures: [Swift.String]?
        /// The unique identifier for the export job.
        /// This member is required.
        public var id: Swift.String?
        /// The status of the export job. The job status is FAILED if Amazon Pinpoint wasn't able to process one or more pieces in the job.
        /// This member is required.
        public var jobStatus: PinpointClientTypes.JobStatus?
        /// The total number of endpoint definitions that weren't processed successfully (failed) by the export job, typically because an error, such as a syntax error, occurred.
        public var totalFailures: Swift.Int?
        /// The total number of pieces that must be processed to complete the export job. Each piece consists of an approximately equal portion of the endpoint definitions that are part of the export job.
        public var totalPieces: Swift.Int?
        /// The total number of endpoint definitions that were processed by the export job.
        public var totalProcessed: Swift.Int?
        /// The job type. This value is EXPORT for export jobs.
        /// This member is required.
        public var type: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            completedPieces: Swift.Int? = nil,
            completionDate: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            definition: PinpointClientTypes.ExportJobResource? = nil,
            failedPieces: Swift.Int? = nil,
            failures: [Swift.String]? = nil,
            id: Swift.String? = nil,
            jobStatus: PinpointClientTypes.JobStatus? = nil,
            totalFailures: Swift.Int? = nil,
            totalPieces: Swift.Int? = nil,
            totalProcessed: Swift.Int? = nil,
            type: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.completedPieces = completedPieces
            self.completionDate = completionDate
            self.creationDate = creationDate
            self.definition = definition
            self.failedPieces = failedPieces
            self.failures = failures
            self.id = id
            self.jobStatus = jobStatus
            self.totalFailures = totalFailures
            self.totalPieces = totalPieces
            self.totalProcessed = totalProcessed
            self.type = type
        }
    }
}

public struct CreateExportJobOutput: Swift.Sendable {
    /// Provides information about the status and settings of a job that exports endpoint definitions to a file. The file can be added directly to an Amazon Simple Storage Service (Amazon S3) bucket by using the Amazon Pinpoint API or downloaded directly to a computer by using the Amazon Pinpoint console.
    /// This member is required.
    public var exportJobResponse: PinpointClientTypes.ExportJobResponse?

    public init(
        exportJobResponse: PinpointClientTypes.ExportJobResponse? = nil
    )
    {
        self.exportJobResponse = exportJobResponse
    }
}

extension PinpointClientTypes {

    public enum Format: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .csv,
                .json
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a job that imports endpoint definitions from an Amazon Simple Storage Service (Amazon S3) bucket.
    public struct ImportJobRequest: Swift.Sendable {
        /// Specifies whether to create a segment that contains the endpoints, when the endpoint definitions are imported.
        public var defineSegment: Swift.Bool?
        /// (Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.
        public var externalId: Swift.String?
        /// The format of the files that contain the endpoint definitions to import. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format. If the Amazon S3 location stores multiple files that use different formats, Amazon Pinpoint imports data only from the files that use the specified format.
        /// This member is required.
        public var format: PinpointClientTypes.Format?
        /// Specifies whether to register the endpoints with Amazon Pinpoint, when the endpoint definitions are imported.
        public var registerEndpoints: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The URL of the Amazon Simple Storage Service (Amazon S3) bucket that contains the endpoint definitions to import. This location can be a folder or a single file. If the location is a folder, Amazon Pinpoint imports endpoint definitions from the files in this location, including any subfolders that the folder contains. The URL should be in the following format: s3://bucket-name/folder-name/file-name. The location can end with the key for an individual object or a prefix that qualifies multiple objects.
        /// This member is required.
        public var s3Url: Swift.String?
        /// The identifier for the segment to update or add the imported endpoint definitions to, if the import job is meant to update an existing segment.
        public var segmentId: Swift.String?
        /// A custom name for the segment that's created by the import job, if the value of the DefineSegment property is true.
        public var segmentName: Swift.String?

        public init(
            defineSegment: Swift.Bool? = nil,
            externalId: Swift.String? = nil,
            format: PinpointClientTypes.Format? = nil,
            registerEndpoints: Swift.Bool? = nil,
            roleArn: Swift.String? = nil,
            s3Url: Swift.String? = nil,
            segmentId: Swift.String? = nil,
            segmentName: Swift.String? = nil
        )
        {
            self.defineSegment = defineSegment
            self.externalId = externalId
            self.format = format
            self.registerEndpoints = registerEndpoints
            self.roleArn = roleArn
            self.s3Url = s3Url
            self.segmentId = segmentId
            self.segmentName = segmentName
        }
    }
}

public struct CreateImportJobInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the settings for a job that imports endpoint definitions from an Amazon Simple Storage Service (Amazon S3) bucket.
    /// This member is required.
    public var importJobRequest: PinpointClientTypes.ImportJobRequest?

    public init(
        applicationId: Swift.String? = nil,
        importJobRequest: PinpointClientTypes.ImportJobRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.importJobRequest = importJobRequest
    }
}

extension PinpointClientTypes {

    /// Provides information about the resource settings for a job that imports endpoint definitions from one or more files. The files can be stored in an Amazon Simple Storage Service (Amazon S3) bucket or uploaded directly from a computer by using the Amazon Pinpoint console.
    public struct ImportJobResource: Swift.Sendable {
        /// Specifies whether the import job creates a segment that contains the endpoints, when the endpoint definitions are imported.
        public var defineSegment: Swift.Bool?
        /// (Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.
        public var externalId: Swift.String?
        /// The format of the files that contain the endpoint definitions to import. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format. If the files are stored in an Amazon S3 location and that location contains multiple files that use different formats, Amazon Pinpoint imports data only from the files that use the specified format.
        /// This member is required.
        public var format: PinpointClientTypes.Format?
        /// Specifies whether the import job registers the endpoints with Amazon Pinpoint, when the endpoint definitions are imported.
        public var registerEndpoints: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The URL of the Amazon Simple Storage Service (Amazon S3) bucket that contains the endpoint definitions to import. This location can be a folder or a single file. If the location is a folder, Amazon Pinpoint imports endpoint definitions from the files in this location, including any subfolders that the folder contains. The URL should be in the following format: s3://bucket-name/folder-name/file-name. The location can end with the key for an individual object or a prefix that qualifies multiple objects.
        /// This member is required.
        public var s3Url: Swift.String?
        /// The identifier for the segment that the import job updates or adds endpoint definitions to, if the import job updates an existing segment.
        public var segmentId: Swift.String?
        /// The custom name for the segment that's created by the import job, if the value of the DefineSegment property is true.
        public var segmentName: Swift.String?

        public init(
            defineSegment: Swift.Bool? = nil,
            externalId: Swift.String? = nil,
            format: PinpointClientTypes.Format? = nil,
            registerEndpoints: Swift.Bool? = nil,
            roleArn: Swift.String? = nil,
            s3Url: Swift.String? = nil,
            segmentId: Swift.String? = nil,
            segmentName: Swift.String? = nil
        )
        {
            self.defineSegment = defineSegment
            self.externalId = externalId
            self.format = format
            self.registerEndpoints = registerEndpoints
            self.roleArn = roleArn
            self.s3Url = s3Url
            self.segmentId = segmentId
            self.segmentName = segmentName
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the status and settings of a job that imports endpoint definitions from one or more files. The files can be stored in an Amazon Simple Storage Service (Amazon S3) bucket or uploaded directly from a computer by using the Amazon Pinpoint console.
    public struct ImportJobResponse: Swift.Sendable {
        /// The unique identifier for the application that's associated with the import job.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The number of pieces that were processed successfully (completed) by the import job, as of the time of the request.
        public var completedPieces: Swift.Int?
        /// The date, in ISO 8601 format, when the import job was completed.
        public var completionDate: Swift.String?
        /// The date, in ISO 8601 format, when the import job was created.
        /// This member is required.
        public var creationDate: Swift.String?
        /// The resource settings that apply to the import job.
        /// This member is required.
        public var definition: PinpointClientTypes.ImportJobResource?
        /// The number of pieces that weren't processed successfully (failed) by the import job, as of the time of the request.
        public var failedPieces: Swift.Int?
        /// An array of entries, one for each of the first 100 entries that weren't processed successfully (failed) by the import job, if any.
        public var failures: [Swift.String]?
        /// The unique identifier for the import job.
        /// This member is required.
        public var id: Swift.String?
        /// The status of the import job. The job status is FAILED if Amazon Pinpoint wasn't able to process one or more pieces in the job.
        /// This member is required.
        public var jobStatus: PinpointClientTypes.JobStatus?
        /// The total number of endpoint definitions that weren't processed successfully (failed) by the import job, typically because an error, such as a syntax error, occurred.
        public var totalFailures: Swift.Int?
        /// The total number of pieces that must be processed to complete the import job. Each piece consists of an approximately equal portion of the endpoint definitions that are part of the import job.
        public var totalPieces: Swift.Int?
        /// The total number of endpoint definitions that were processed by the import job.
        public var totalProcessed: Swift.Int?
        /// The job type. This value is IMPORT for import jobs.
        /// This member is required.
        public var type: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            completedPieces: Swift.Int? = nil,
            completionDate: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            definition: PinpointClientTypes.ImportJobResource? = nil,
            failedPieces: Swift.Int? = nil,
            failures: [Swift.String]? = nil,
            id: Swift.String? = nil,
            jobStatus: PinpointClientTypes.JobStatus? = nil,
            totalFailures: Swift.Int? = nil,
            totalPieces: Swift.Int? = nil,
            totalProcessed: Swift.Int? = nil,
            type: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.completedPieces = completedPieces
            self.completionDate = completionDate
            self.creationDate = creationDate
            self.definition = definition
            self.failedPieces = failedPieces
            self.failures = failures
            self.id = id
            self.jobStatus = jobStatus
            self.totalFailures = totalFailures
            self.totalPieces = totalPieces
            self.totalProcessed = totalProcessed
            self.type = type
        }
    }
}

public struct CreateImportJobOutput: Swift.Sendable {
    /// Provides information about the status and settings of a job that imports endpoint definitions from one or more files. The files can be stored in an Amazon Simple Storage Service (Amazon S3) bucket or uploaded directly from a computer by using the Amazon Pinpoint console.
    /// This member is required.
    public var importJobResponse: PinpointClientTypes.ImportJobResponse?

    public init(
        importJobResponse: PinpointClientTypes.ImportJobResponse? = nil
    )
    {
        self.importJobResponse = importJobResponse
    }
}

extension PinpointClientTypes {

    /// InApp Template Request.
    public struct InAppTemplateRequest: Swift.Sendable {
        /// The content of the message, can include up to 5 modals. Each modal must contain a message, a header, and background color. ImageUrl and buttons are optional.
        public var content: [PinpointClientTypes.InAppMessageContent]?
        /// Custom config to be sent to client.
        public var customConfig: [Swift.String: Swift.String]?
        /// The layout of the message.
        public var layout: PinpointClientTypes.Layout?
        /// As of 22-05-2023 tags has been deprecated for update operations. After this date any value in tags is not processed and an error code is not returned. To manage tags we recommend using either [Tags](https://docs.aws.amazon.com/pinpoint/latest/apireference/tags-resource-arn.html) in the API Reference for Amazon Pinpoint, [resourcegroupstaggingapi](https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/index.html) commands in the AWS Command Line Interface Documentation or [resourcegroupstaggingapi](https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/resourcegroupstaggingapi/package-summary.html) in the AWS SDK. (Deprecated) A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?
        /// The description of the template.
        public var templateDescription: Swift.String?

        public init(
            content: [PinpointClientTypes.InAppMessageContent]? = nil,
            customConfig: [Swift.String: Swift.String]? = nil,
            layout: PinpointClientTypes.Layout? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateDescription: Swift.String? = nil
        )
        {
            self.content = content
            self.customConfig = customConfig
            self.layout = layout
            self.tags = tags
            self.templateDescription = templateDescription
        }
    }
}

public struct CreateInAppTemplateInput: Swift.Sendable {
    /// InApp Template Request.
    /// This member is required.
    public var inAppTemplateRequest: PinpointClientTypes.InAppTemplateRequest?
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        inAppTemplateRequest: PinpointClientTypes.InAppTemplateRequest? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.inAppTemplateRequest = inAppTemplateRequest
        self.templateName = templateName
    }
}

extension PinpointClientTypes {

    /// Provides information about a request to create a message template.
    public struct TemplateCreateMessageBody: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the message template that was created.
        public var arn: Swift.String?
        /// The message that's returned from the API for the request to create the message template.
        public var message: Swift.String?
        /// The unique identifier for the request to create the message template.
        public var requestID: Swift.String?

        public init(
            arn: Swift.String? = nil,
            message: Swift.String? = nil,
            requestID: Swift.String? = nil
        )
        {
            self.arn = arn
            self.message = message
            self.requestID = requestID
        }
    }
}

public struct CreateInAppTemplateOutput: Swift.Sendable {
    /// Provides information about a request to create a message template.
    /// This member is required.
    public var templateCreateMessageBody: PinpointClientTypes.TemplateCreateMessageBody?

    public init(
        templateCreateMessageBody: PinpointClientTypes.TemplateCreateMessageBody? = nil
    )
    {
        self.templateCreateMessageBody = templateCreateMessageBody
    }
}

extension PinpointClientTypes {

    /// The channel-specific configurations for the journey.
    public struct JourneyChannelSettings: Swift.Sendable {
        /// Amazon Resource Name (ARN) of the Connect Campaign.
        public var connectCampaignArn: Swift.String?
        /// IAM role ARN to be assumed when invoking Connect campaign execution APIs for dialing.
        public var connectCampaignExecutionRoleArn: Swift.String?

        public init(
            connectCampaignArn: Swift.String? = nil,
            connectCampaignExecutionRoleArn: Swift.String? = nil
        )
        {
            self.connectCampaignArn = connectCampaignArn
            self.connectCampaignExecutionRoleArn = connectCampaignExecutionRoleArn
        }
    }
}

extension PinpointClientTypes {

    /// Specifies limits on the messages that a journey can send and the number of times participants can enter a journey.
    public struct JourneyLimits: Swift.Sendable {
        /// The maximum number of messages that the journey can send to a single participant during a 24-hour period. The maximum value is 100.
        public var dailyCap: Swift.Int?
        /// The maximum number of times that a participant can enter the journey. The maximum value is 100. To allow participants to enter the journey an unlimited number of times, set this value to 0.
        public var endpointReentryCap: Swift.Int?
        /// Minimum time that must pass before an endpoint can re-enter a given journey. The duration should use an ISO 8601 format, such as PT1H.
        public var endpointReentryInterval: Swift.String?
        /// The maximum number of messages that the journey can send each second.
        public var messagesPerSecond: Swift.Int?
        /// The number of messages that an endpoint can receive during the specified timeframe.
        public var timeframeCap: PinpointClientTypes.JourneyTimeframeCap?
        /// The maximum number of messages a journey can sent to a single endpoint. The maximum value is 100. If set to 0, this limit will not apply.
        public var totalCap: Swift.Int?

        public init(
            dailyCap: Swift.Int? = nil,
            endpointReentryCap: Swift.Int? = nil,
            endpointReentryInterval: Swift.String? = nil,
            messagesPerSecond: Swift.Int? = nil,
            timeframeCap: PinpointClientTypes.JourneyTimeframeCap? = nil,
            totalCap: Swift.Int? = nil
        )
        {
            self.dailyCap = dailyCap
            self.endpointReentryCap = endpointReentryCap
            self.endpointReentryInterval = endpointReentryInterval
            self.messagesPerSecond = messagesPerSecond
            self.timeframeCap = timeframeCap
            self.totalCap = totalCap
        }
    }
}

extension PinpointClientTypes {

    public enum DayOfWeek: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the start and end time for OpenHours.
    public struct OpenHoursRule: Swift.Sendable {
        /// The end of the scheduled time, in ISO 8601 format, when the channel can't send messages.
        public var endTime: Swift.String?
        /// The start of the scheduled time, in ISO 8601 format, when the channel can send messages.
        public var startTime: Swift.String?

        public init(
            endTime: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the times when message are allowed to be sent to endpoints.
    public struct OpenHours: Swift.Sendable {
        /// Specifies the schedule settings for the custom channel.
        public var custom: [Swift.String: [PinpointClientTypes.OpenHoursRule]]?
        /// Specifies the schedule settings for the email channel.
        public var email: [Swift.String: [PinpointClientTypes.OpenHoursRule]]?
        /// Specifies the schedule settings for the push channel.
        public var push: [Swift.String: [PinpointClientTypes.OpenHoursRule]]?
        /// Specifies the schedule settings for the SMS channel.
        public var sms: [Swift.String: [PinpointClientTypes.OpenHoursRule]]?
        /// Specifies the schedule settings for the voice channel.
        public var voice: [Swift.String: [PinpointClientTypes.OpenHoursRule]]?

        public init(
            custom: [Swift.String: [PinpointClientTypes.OpenHoursRule]]? = nil,
            email: [Swift.String: [PinpointClientTypes.OpenHoursRule]]? = nil,
            push: [Swift.String: [PinpointClientTypes.OpenHoursRule]]? = nil,
            sms: [Swift.String: [PinpointClientTypes.OpenHoursRule]]? = nil,
            voice: [Swift.String: [PinpointClientTypes.OpenHoursRule]]? = nil
        )
        {
            self.custom = custom
            self.email = email
            self.push = push
            self.sms = sms
            self.voice = voice
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the schedule settings for a journey.
    public struct JourneySchedule: Swift.Sendable {
        /// The scheduled time, in ISO 8601 format, when the journey ended or will end.
        public var endTime: Foundation.Date?
        /// The scheduled time, in ISO 8601 format, when the journey began or will begin.
        public var startTime: Foundation.Date?
        /// The starting UTC offset for the journey schedule, if the value of the journey's LocalTime property is true. Valid values are: UTC, UTC+01, UTC+02, UTC+03, UTC+03:30, UTC+04, UTC+04:30, UTC+05, UTC+05:30, UTC+05:45, UTC+06, UTC+06:30, UTC+07, UTC+08, UTC+08:45, UTC+09, UTC+09:30, UTC+10, UTC+10:30, UTC+11, UTC+12, UTC+12:45, UTC+13, UTC+13:45, UTC-02, UTC-02:30, UTC-03, UTC-03:30, UTC-04, UTC-05, UTC-06, UTC-07, UTC-08, UTC-09, UTC-09:30, UTC-10, and UTC-11.
        public var timezone: Swift.String?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
            self.timezone = timezone
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for an event that causes a campaign to be sent or a journey activity to be performed.
    public struct EventFilter: Swift.Sendable {
        /// The dimensions for the event filter to use for the campaign or the journey activity.
        /// This member is required.
        public var dimensions: PinpointClientTypes.EventDimensions?
        /// The type of event that causes the campaign to be sent or the journey activity to be performed. Valid values are: SYSTEM, sends the campaign or performs the activity when a system event occurs; and, ENDPOINT, sends the campaign or performs the activity when an endpoint event (Events resource) occurs.
        /// This member is required.
        public var filterType: PinpointClientTypes.FilterType?

        public init(
            dimensions: PinpointClientTypes.EventDimensions? = nil,
            filterType: PinpointClientTypes.FilterType? = nil
        )
        {
            self.dimensions = dimensions
            self.filterType = filterType
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for an event that causes a journey activity to start.
    public struct EventStartCondition: Swift.Sendable {
        /// Specifies the settings for an event that causes a campaign to be sent or a journey activity to be performed.
        public var eventFilter: PinpointClientTypes.EventFilter?
        public var segmentId: Swift.String?

        public init(
            eventFilter: PinpointClientTypes.EventFilter? = nil,
            segmentId: Swift.String? = nil
        )
        {
            self.eventFilter = eventFilter
            self.segmentId = segmentId
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the conditions for the first activity in a journey. This activity and its conditions determine which users are participants in a journey.
    public struct StartCondition: Swift.Sendable {
        /// The custom description of the condition.
        public var description: Swift.String?
        /// Specifies the settings for an event that causes a journey activity to start.
        public var eventStartCondition: PinpointClientTypes.EventStartCondition?
        /// The segment that's associated with the first activity in the journey. This segment determines which users are participants in the journey.
        public var segmentStartCondition: PinpointClientTypes.SegmentCondition?

        public init(
            description: Swift.String? = nil,
            eventStartCondition: PinpointClientTypes.EventStartCondition? = nil,
            segmentStartCondition: PinpointClientTypes.SegmentCondition? = nil
        )
        {
            self.description = description
            self.eventStartCondition = eventStartCondition
            self.segmentStartCondition = segmentStartCondition
        }
    }
}

extension PinpointClientTypes {

    public enum State: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case cancelled
        case closed
        case completed
        case draft
        case paused
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .cancelled,
                .closed,
                .completed,
                .draft,
                .paused
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .cancelled: return "CANCELLED"
            case .closed: return "CLOSED"
            case .completed: return "COMPLETED"
            case .draft: return "DRAFT"
            case .paused: return "PAUSED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the configuration and other settings for a journey.
    public struct WriteJourneyRequest: Swift.Sendable {
        /// A map that contains a set of Activity objects, one object for each activity in the journey. For each Activity object, the key is the unique identifier (string) for an activity and the value is the settings for the activity. An activity identifier can contain a maximum of 100 characters. The characters must be alphanumeric characters.
        public var activities: [Swift.String: PinpointClientTypes.Activity]?
        /// The time when journey will stop sending messages. QuietTime should be configured first and SendingSchedule should be set to true.
        public var closedDays: PinpointClientTypes.ClosedDays?
        /// The date, in ISO 8601 format, when the journey was created.
        public var creationDate: Swift.String?
        /// The channel-specific configurations for the journey.
        public var journeyChannelSettings: PinpointClientTypes.JourneyChannelSettings?
        /// The date, in ISO 8601 format, when the journey was last modified.
        public var lastModifiedDate: Swift.String?
        /// The messaging and entry limits for the journey.
        public var limits: PinpointClientTypes.JourneyLimits?
        /// Specifies whether the journey's scheduled start and end times use each participant's local time. To base the schedule on each participant's local time, set this value to true.
        public var localTime: Swift.Bool?
        /// The name of the journey. A journey name can contain a maximum of 150 characters. The characters can be alphanumeric characters or symbols, such as underscores (_) or hyphens (-). A journey name can't contain any spaces.
        /// This member is required.
        public var name: Swift.String?
        /// The time when journey allow to send messages. QuietTime should be configured first and SendingSchedule should be set to true.
        public var openHours: PinpointClientTypes.OpenHours?
        /// The quiet time settings for the journey. Quiet time is a specific time range when a journey doesn't send messages to participants, if all the following conditions are met:
        ///
        /// * The EndpointDemographic.Timezone property of the endpoint for the participant is set to a valid value.
        ///
        /// * The current time in the participant's time zone is later than or equal to the time specified by the QuietTime.Start property for the journey.
        ///
        /// * The current time in the participant's time zone is earlier than or equal to the time specified by the QuietTime.End property for the journey.
        ///
        ///
        /// If any of the preceding conditions isn't met, the participant will receive messages from the journey, even if quiet time is enabled.
        public var quietTime: PinpointClientTypes.QuietTime?
        /// The frequency with which Amazon Pinpoint evaluates segment and event data for the journey, as a duration in ISO 8601 format.
        public var refreshFrequency: Swift.String?
        /// Indicates whether the journey participants should be refreshed when a segment is updated.
        public var refreshOnSegmentUpdate: Swift.Bool?
        /// The schedule settings for the journey.
        public var schedule: PinpointClientTypes.JourneySchedule?
        /// Indicates if journey has Advance Quiet Time enabled. This flag should be set to true in order to allow using OpenHours and ClosedDays.
        public var sendingSchedule: Swift.Bool?
        /// The unique identifier for the first activity in the journey. The identifier for this activity can contain a maximum of 128 characters. The characters must be alphanumeric characters.
        public var startActivity: Swift.String?
        /// The segment that defines which users are participants in the journey.
        public var startCondition: PinpointClientTypes.StartCondition?
        /// The status of the journey. Valid values are:
        ///
        /// * DRAFT - Saves the journey and doesn't publish it.
        ///
        /// * ACTIVE - Saves and publishes the journey. Depending on the journey's schedule, the journey starts running immediately or at the scheduled start time. If a journey's status is ACTIVE, you can't add, change, or remove activities from it.
        ///
        ///
        /// PAUSED, CANCELLED, COMPLETED, and CLOSED states are not supported in requests to create or update a journey. To cancel, pause, or resume a journey, use the Journey State resource.
        public var state: PinpointClientTypes.State?
        /// An array of time zone estimation methods, if any, to use for determining an [Endpoints](https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-endpoints-endpoint-id.html) time zone if the Endpoint does not have a value for the Demographic.Timezone attribute.
        ///
        /// * PHONE_NUMBER - A time zone is determined based on the Endpoint.Address and Endpoint.Location.Country.
        ///
        /// * POSTAL_CODE - A time zone is determined based on the Endpoint.Location.PostalCode and Endpoint.Location.Country. POSTAL_CODE detection is only supported in the United States, United Kingdom, Australia, New Zealand, Canada, France, Italy, Spain, Germany and in regions where Amazon Pinpoint is available.
        public var timezoneEstimationMethods: [PinpointClientTypes.__TimezoneEstimationMethodsElement]?
        /// Specifies whether endpoints in quiet hours should enter a wait till the end of their quiet hours.
        public var waitForQuietTime: Swift.Bool?

        public init(
            activities: [Swift.String: PinpointClientTypes.Activity]? = nil,
            closedDays: PinpointClientTypes.ClosedDays? = nil,
            creationDate: Swift.String? = nil,
            journeyChannelSettings: PinpointClientTypes.JourneyChannelSettings? = nil,
            lastModifiedDate: Swift.String? = nil,
            limits: PinpointClientTypes.JourneyLimits? = nil,
            localTime: Swift.Bool? = nil,
            name: Swift.String? = nil,
            openHours: PinpointClientTypes.OpenHours? = nil,
            quietTime: PinpointClientTypes.QuietTime? = nil,
            refreshFrequency: Swift.String? = nil,
            refreshOnSegmentUpdate: Swift.Bool? = nil,
            schedule: PinpointClientTypes.JourneySchedule? = nil,
            sendingSchedule: Swift.Bool? = nil,
            startActivity: Swift.String? = nil,
            startCondition: PinpointClientTypes.StartCondition? = nil,
            state: PinpointClientTypes.State? = nil,
            timezoneEstimationMethods: [PinpointClientTypes.__TimezoneEstimationMethodsElement]? = nil,
            waitForQuietTime: Swift.Bool? = nil
        )
        {
            self.activities = activities
            self.closedDays = closedDays
            self.creationDate = creationDate
            self.journeyChannelSettings = journeyChannelSettings
            self.lastModifiedDate = lastModifiedDate
            self.limits = limits
            self.localTime = localTime
            self.name = name
            self.openHours = openHours
            self.quietTime = quietTime
            self.refreshFrequency = refreshFrequency
            self.refreshOnSegmentUpdate = refreshOnSegmentUpdate
            self.schedule = schedule
            self.sendingSchedule = sendingSchedule
            self.startActivity = startActivity
            self.startCondition = startCondition
            self.state = state
            self.timezoneEstimationMethods = timezoneEstimationMethods
            self.waitForQuietTime = waitForQuietTime
        }
    }
}

public struct CreateJourneyInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the configuration and other settings for a journey.
    /// This member is required.
    public var writeJourneyRequest: PinpointClientTypes.WriteJourneyRequest?

    public init(
        applicationId: Swift.String? = nil,
        writeJourneyRequest: PinpointClientTypes.WriteJourneyRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.writeJourneyRequest = writeJourneyRequest
    }
}

extension PinpointClientTypes {

    /// Provides information about the status, configuration, and other settings for a journey.
    public struct JourneyResponse: Swift.Sendable {
        /// A map that contains a set of Activity objects, one object for each activity in the journey. For each Activity object, the key is the unique identifier (string) for an activity and the value is the settings for the activity.
        public var activities: [Swift.String: PinpointClientTypes.Activity]?
        /// The unique identifier for the application that the journey applies to.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The time when a journey will not send messages. QuietTime should be configured first and SendingSchedule should be set to true.
        public var closedDays: PinpointClientTypes.ClosedDays?
        /// The date, in ISO 8601 format, when the journey was created.
        public var creationDate: Swift.String?
        /// The unique identifier for the journey.
        /// This member is required.
        public var id: Swift.String?
        /// The channel-specific configurations for the journey.
        public var journeyChannelSettings: PinpointClientTypes.JourneyChannelSettings?
        /// The date, in ISO 8601 format, when the journey was last modified.
        public var lastModifiedDate: Swift.String?
        /// The messaging and entry limits for the journey.
        public var limits: PinpointClientTypes.JourneyLimits?
        /// Specifies whether the journey's scheduled start and end times use each participant's local time. If this value is true, the schedule uses each participant's local time.
        public var localTime: Swift.Bool?
        /// The name of the journey.
        /// This member is required.
        public var name: Swift.String?
        /// The time when a journey can send messages. QuietTime should be configured first and SendingSchedule should be set to true.
        public var openHours: PinpointClientTypes.OpenHours?
        /// The quiet time settings for the journey. Quiet time is a specific time range when a journey doesn't send messages to participants, if all the following conditions are met:
        ///
        /// * The EndpointDemographic.Timezone property of the endpoint for the participant is set to a valid value.
        ///
        /// * The current time in the participant's time zone is later than or equal to the time specified by the QuietTime.Start property for the journey.
        ///
        /// * The current time in the participant's time zone is earlier than or equal to the time specified by the QuietTime.End property for the journey.
        ///
        ///
        /// If any of the preceding conditions isn't met, the participant will receive messages from the journey, even if quiet time is enabled.
        public var quietTime: PinpointClientTypes.QuietTime?
        /// The frequency with which Amazon Pinpoint evaluates segment and event data for the journey, as a duration in ISO 8601 format.
        public var refreshFrequency: Swift.String?
        /// Indicates whether the journey participants should be refreshed when a segment is updated.
        public var refreshOnSegmentUpdate: Swift.Bool?
        /// The schedule settings for the journey.
        public var schedule: PinpointClientTypes.JourneySchedule?
        /// Indicates if journey has Advance Quiet Time enabled. This flag should be set to true in order to allow using OpenHours and ClosedDays.
        public var sendingSchedule: Swift.Bool?
        /// The unique identifier for the first activity in the journey.
        public var startActivity: Swift.String?
        /// The segment that defines which users are participants in the journey.
        public var startCondition: PinpointClientTypes.StartCondition?
        /// The current status of the journey. Possible values are:
        ///
        /// * DRAFT - The journey is being developed and hasn't been published yet.
        ///
        /// * ACTIVE - The journey has been developed and published. Depending on the journey's schedule, the journey may currently be running or scheduled to start running at a later time. If a journey's status is ACTIVE, you can't add, change, or remove activities from it.
        ///
        /// * COMPLETED - The journey has been published and has finished running. All participants have entered the journey and no participants are waiting to complete the journey or any activities in the journey.
        ///
        /// * CANCELLED - The journey has been stopped. If a journey's status is CANCELLED, you can't add, change, or remove activities or segment settings from the journey.
        ///
        /// * CLOSED - The journey has been published and has started running. It may have also passed its scheduled end time, or passed its scheduled start time and a refresh frequency hasn't been specified for it. If a journey's status is CLOSED, you can't add participants to it, and no existing participants can enter the journey for the first time. However, any existing participants who are currently waiting to start an activity may continue the journey.
        public var state: PinpointClientTypes.State?
        /// This object is not used or supported.
        public var tags: [Swift.String: Swift.String]?
        /// An array of time zone estimation methods, if any, to use for determining an [Endpoints](https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-endpoints-endpoint-id.html) time zone if the Endpoint does not have a value for the Demographic.Timezone attribute.
        ///
        /// * PHONE_NUMBER - A time zone is determined based on the Endpoint.Address and Endpoint.Location.Country.
        ///
        /// * POSTAL_CODE - A time zone is determined based on the Endpoint.Location.PostalCode and Endpoint.Location.Country. POSTAL_CODE detection is only supported in the United States, United Kingdom, Australia, New Zealand, Canada, France, Italy, Spain, Germany and in regions where Amazon Pinpoint is available.
        public var timezoneEstimationMethods: [PinpointClientTypes.__TimezoneEstimationMethodsElement]?
        /// Indicates whether endpoints in quiet hours should enter a wait activity until quiet hours have elapsed.
        public var waitForQuietTime: Swift.Bool?

        public init(
            activities: [Swift.String: PinpointClientTypes.Activity]? = nil,
            applicationId: Swift.String? = nil,
            closedDays: PinpointClientTypes.ClosedDays? = nil,
            creationDate: Swift.String? = nil,
            id: Swift.String? = nil,
            journeyChannelSettings: PinpointClientTypes.JourneyChannelSettings? = nil,
            lastModifiedDate: Swift.String? = nil,
            limits: PinpointClientTypes.JourneyLimits? = nil,
            localTime: Swift.Bool? = nil,
            name: Swift.String? = nil,
            openHours: PinpointClientTypes.OpenHours? = nil,
            quietTime: PinpointClientTypes.QuietTime? = nil,
            refreshFrequency: Swift.String? = nil,
            refreshOnSegmentUpdate: Swift.Bool? = nil,
            schedule: PinpointClientTypes.JourneySchedule? = nil,
            sendingSchedule: Swift.Bool? = nil,
            startActivity: Swift.String? = nil,
            startCondition: PinpointClientTypes.StartCondition? = nil,
            state: PinpointClientTypes.State? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            timezoneEstimationMethods: [PinpointClientTypes.__TimezoneEstimationMethodsElement]? = nil,
            waitForQuietTime: Swift.Bool? = nil
        )
        {
            self.activities = activities
            self.applicationId = applicationId
            self.closedDays = closedDays
            self.creationDate = creationDate
            self.id = id
            self.journeyChannelSettings = journeyChannelSettings
            self.lastModifiedDate = lastModifiedDate
            self.limits = limits
            self.localTime = localTime
            self.name = name
            self.openHours = openHours
            self.quietTime = quietTime
            self.refreshFrequency = refreshFrequency
            self.refreshOnSegmentUpdate = refreshOnSegmentUpdate
            self.schedule = schedule
            self.sendingSchedule = sendingSchedule
            self.startActivity = startActivity
            self.startCondition = startCondition
            self.state = state
            self.tags = tags
            self.timezoneEstimationMethods = timezoneEstimationMethods
            self.waitForQuietTime = waitForQuietTime
        }
    }
}

public struct CreateJourneyOutput: Swift.Sendable {
    /// Provides information about the status, configuration, and other settings for a journey.
    /// This member is required.
    public var journeyResponse: PinpointClientTypes.JourneyResponse?

    public init(
        journeyResponse: PinpointClientTypes.JourneyResponse? = nil
    )
    {
        self.journeyResponse = journeyResponse
    }
}

extension PinpointClientTypes {

    /// Specifies the default settings and content for a message template that can be used in messages that are sent through a push notification channel.
    public struct DefaultPushNotificationTemplate: Swift.Sendable {
        /// The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:
        ///
        /// * OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.
        ///
        /// * DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS and Android platforms.
        ///
        /// * URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public var action: PinpointClientTypes.Action?
        /// The message body to use in push notifications that are based on the message template.
        public var body: Swift.String?
        /// The sound to play when a recipient receives a push notification that's based on the message template. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/. For an iOS platform, this value is the key for the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.
        public var sound: Swift.String?
        /// The title to use in push notifications that are based on the message template. This title appears above the notification message on a recipient's device.
        public var title: Swift.String?
        /// The URL to open in a recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.
        public var url: Swift.String?

        public init(
            action: PinpointClientTypes.Action? = nil,
            body: Swift.String? = nil,
            sound: Swift.String? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.action = action
            self.body = body
            self.sound = sound
            self.title = title
            self.url = url
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the content and settings for a message template that can be used in messages that are sent through a push notification channel.
    public struct PushNotificationTemplateRequest: Swift.Sendable {
        /// The message template to use for the ADM (Amazon Device Messaging) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).
        public var adm: PinpointClientTypes.AndroidPushNotificationTemplate?
        /// The message template to use for the APNs (Apple Push Notification service) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).
        public var apns: PinpointClientTypes.APNSPushNotificationTemplate?
        /// The message template to use for the Baidu (Baidu Cloud Push) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).
        public var baidu: PinpointClientTypes.AndroidPushNotificationTemplate?
        /// The default message template to use for push notification channels.
        public var `default`: PinpointClientTypes.DefaultPushNotificationTemplate?
        /// A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.
        public var defaultSubstitutions: Swift.String?
        /// The message template to use for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).
        public var gcm: PinpointClientTypes.AndroidPushNotificationTemplate?
        /// The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.
        public var recommenderId: Swift.String?
        /// As of 22-05-2023 tags has been deprecated for update operations. After this date any value in tags is not processed and an error code is not returned. To manage tags we recommend using either [Tags](https://docs.aws.amazon.com/pinpoint/latest/apireference/tags-resource-arn.html) in the API Reference for Amazon Pinpoint, [resourcegroupstaggingapi](https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/index.html) commands in the AWS Command Line Interface Documentation or [resourcegroupstaggingapi](https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/resourcegroupstaggingapi/package-summary.html) in the AWS SDK. (Deprecated) A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?
        /// A custom description of the message template.
        public var templateDescription: Swift.String?

        public init(
            adm: PinpointClientTypes.AndroidPushNotificationTemplate? = nil,
            apns: PinpointClientTypes.APNSPushNotificationTemplate? = nil,
            baidu: PinpointClientTypes.AndroidPushNotificationTemplate? = nil,
            `default`: PinpointClientTypes.DefaultPushNotificationTemplate? = nil,
            defaultSubstitutions: Swift.String? = nil,
            gcm: PinpointClientTypes.AndroidPushNotificationTemplate? = nil,
            recommenderId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateDescription: Swift.String? = nil
        )
        {
            self.adm = adm
            self.apns = apns
            self.baidu = baidu
            self.`default` = `default`
            self.defaultSubstitutions = defaultSubstitutions
            self.gcm = gcm
            self.recommenderId = recommenderId
            self.tags = tags
            self.templateDescription = templateDescription
        }
    }
}

public struct CreatePushTemplateInput: Swift.Sendable {
    /// Specifies the content and settings for a message template that can be used in messages that are sent through a push notification channel.
    /// This member is required.
    public var pushNotificationTemplateRequest: PinpointClientTypes.PushNotificationTemplateRequest?
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        pushNotificationTemplateRequest: PinpointClientTypes.PushNotificationTemplateRequest? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.pushNotificationTemplateRequest = pushNotificationTemplateRequest
        self.templateName = templateName
    }
}

public struct CreatePushTemplateOutput: Swift.Sendable {
    /// Provides information about a request to create a message template.
    /// This member is required.
    public var createTemplateMessageBody: PinpointClientTypes.CreateTemplateMessageBody?

    public init(
        createTemplateMessageBody: PinpointClientTypes.CreateTemplateMessageBody? = nil
    )
    {
        self.createTemplateMessageBody = createTemplateMessageBody
    }
}

extension PinpointClientTypes {

    /// Specifies Amazon Pinpoint configuration settings for retrieving and processing recommendation data from a recommender model.
    public struct CreateRecommenderConfigurationShape: Swift.Sendable {
        /// A map of key-value pairs that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template. In the map, the key is the name of a custom attribute and the value is a custom display name for that attribute. The display name appears in the Attribute finder of the template editor on the Amazon Pinpoint console. The following restrictions apply to these names:
        ///
        /// * An attribute name must start with a letter or number and it can contain up to 50 characters. The characters can be letters, numbers, underscores (_), or hyphens (-). Attribute names are case sensitive and must be unique.
        ///
        /// * An attribute display name must start with a letter or number and it can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).
        ///
        ///
        /// This object is required if the configuration invokes an AWS Lambda function (RecommendationTransformerUri) to process recommendation data. Otherwise, don't include this object in your request.
        public var attributes: [Swift.String: Swift.String]?
        /// A custom description of the configuration for the recommender model. The description can contain up to 128 characters. The characters can be letters, numbers, spaces, or the following symbols: _ ; () , ‐.
        public var description: Swift.String?
        /// A custom name of the configuration for the recommender model. The name must start with a letter or number and it can contain up to 128 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).
        public var name: Swift.String?
        /// The type of Amazon Pinpoint ID to associate with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Valid values are:
        ///
        /// * PINPOINT_ENDPOINT_ID - Associate each user in the model with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.
        ///
        /// * PINPOINT_USER_ID - Associate each user in the model with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If you specify this value, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.
        public var recommendationProviderIdType: Swift.String?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.
        /// This member is required.
        public var recommendationProviderRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the recommender model to retrieve recommendation data from. This value must match the ARN of an Amazon Personalize campaign.
        /// This member is required.
        public var recommendationProviderUri: Swift.String?
        /// The name or Amazon Resource Name (ARN) of the AWS Lambda function to invoke for additional processing of recommendation data that's retrieved from the recommender model.
        public var recommendationTransformerUri: Swift.String?
        /// A custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This value is required if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data. This name appears in the Attribute finder of the template editor on the Amazon Pinpoint console. The name can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-). These restrictions don't apply to attribute values.
        public var recommendationsDisplayName: Swift.String?
        /// The number of recommended items to retrieve from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables. The minimum value is 1. The maximum value is 5. The default value is 5. To use multiple recommended items and custom attributes with message variables, you have to use an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.
        public var recommendationsPerMessage: Swift.Int?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            recommendationProviderIdType: Swift.String? = nil,
            recommendationProviderRoleArn: Swift.String? = nil,
            recommendationProviderUri: Swift.String? = nil,
            recommendationTransformerUri: Swift.String? = nil,
            recommendationsDisplayName: Swift.String? = nil,
            recommendationsPerMessage: Swift.Int? = nil
        )
        {
            self.attributes = attributes
            self.description = description
            self.name = name
            self.recommendationProviderIdType = recommendationProviderIdType
            self.recommendationProviderRoleArn = recommendationProviderRoleArn
            self.recommendationProviderUri = recommendationProviderUri
            self.recommendationTransformerUri = recommendationTransformerUri
            self.recommendationsDisplayName = recommendationsDisplayName
            self.recommendationsPerMessage = recommendationsPerMessage
        }
    }
}

public struct CreateRecommenderConfigurationInput: Swift.Sendable {
    /// Specifies Amazon Pinpoint configuration settings for retrieving and processing recommendation data from a recommender model.
    /// This member is required.
    public var createRecommenderConfiguration: PinpointClientTypes.CreateRecommenderConfigurationShape?

    public init(
        createRecommenderConfiguration: PinpointClientTypes.CreateRecommenderConfigurationShape? = nil
    )
    {
        self.createRecommenderConfiguration = createRecommenderConfiguration
    }
}

extension PinpointClientTypes {

    /// Provides information about Amazon Pinpoint configuration settings for retrieving and processing data from a recommender model.
    public struct RecommenderConfigurationResponse: Swift.Sendable {
        /// A map that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template. This value is null if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.
        public var attributes: [Swift.String: Swift.String]?
        /// The date, in extended ISO 8601 format, when the configuration was created for the recommender model.
        /// This member is required.
        public var creationDate: Swift.String?
        /// The custom description of the configuration for the recommender model.
        public var description: Swift.String?
        /// The unique identifier for the recommender model configuration.
        /// This member is required.
        public var id: Swift.String?
        /// The date, in extended ISO 8601 format, when the configuration for the recommender model was last modified.
        /// This member is required.
        public var lastModifiedDate: Swift.String?
        /// The custom name of the configuration for the recommender model.
        public var name: Swift.String?
        /// The type of Amazon Pinpoint ID that's associated with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Possible values are:
        ///
        /// * PINPOINT_ENDPOINT_ID - Each user in the model is associated with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.
        ///
        /// * PINPOINT_USER_ID - Each user in the model is associated with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If this value is specified, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.
        public var recommendationProviderIdType: Swift.String?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.
        /// This member is required.
        public var recommendationProviderRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the recommender model that Amazon Pinpoint retrieves the recommendation data from. This value is the ARN of an Amazon Personalize campaign.
        /// This member is required.
        public var recommendationProviderUri: Swift.String?
        /// The name or Amazon Resource Name (ARN) of the AWS Lambda function that Amazon Pinpoint invokes to perform additional processing of recommendation data that it retrieves from the recommender model.
        public var recommendationTransformerUri: Swift.String?
        /// The custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This name appears in the Attribute finder of the template editor on the Amazon Pinpoint console. This value is null if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.
        public var recommendationsDisplayName: Swift.String?
        /// The number of recommended items that are retrieved from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables.
        public var recommendationsPerMessage: Swift.Int?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            creationDate: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            name: Swift.String? = nil,
            recommendationProviderIdType: Swift.String? = nil,
            recommendationProviderRoleArn: Swift.String? = nil,
            recommendationProviderUri: Swift.String? = nil,
            recommendationTransformerUri: Swift.String? = nil,
            recommendationsDisplayName: Swift.String? = nil,
            recommendationsPerMessage: Swift.Int? = nil
        )
        {
            self.attributes = attributes
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.recommendationProviderIdType = recommendationProviderIdType
            self.recommendationProviderRoleArn = recommendationProviderRoleArn
            self.recommendationProviderUri = recommendationProviderUri
            self.recommendationTransformerUri = recommendationTransformerUri
            self.recommendationsDisplayName = recommendationsDisplayName
            self.recommendationsPerMessage = recommendationsPerMessage
        }
    }
}

public struct CreateRecommenderConfigurationOutput: Swift.Sendable {
    /// Provides information about Amazon Pinpoint configuration settings for retrieving and processing data from a recommender model.
    /// This member is required.
    public var recommenderConfigurationResponse: PinpointClientTypes.RecommenderConfigurationResponse?

    public init(
        recommenderConfigurationResponse: PinpointClientTypes.RecommenderConfigurationResponse? = nil
    )
    {
        self.recommenderConfigurationResponse = recommenderConfigurationResponse
    }
}

extension PinpointClientTypes {

    /// Specifies the segment identifier and version of a segment.
    public struct SegmentReference: Swift.Sendable {
        /// The unique identifier for the segment.
        /// This member is required.
        public var id: Swift.String?
        /// The version number of the segment.
        public var version: Swift.Int?

        public init(
            id: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.id = id
            self.version = version
        }
    }
}

extension PinpointClientTypes {

    public enum SourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case any
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .all,
                .any,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .any: return "ANY"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    public enum ModelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case any
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .all,
                .any,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .any: return "ANY"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the base segments and dimensions for a segment, and the relationships between these base segments and dimensions.
    public struct SegmentGroup: Swift.Sendable {
        /// An array that defines the dimensions for the segment.
        public var dimensions: [PinpointClientTypes.SegmentDimensions]?
        /// The base segment to build the segment on. A base segment, also referred to as a source segment, defines the initial population of endpoints for a segment. When you add dimensions to a segment, Amazon Pinpoint filters the base segment by using the dimensions that you specify. You can specify more than one dimensional segment or only one imported segment. If you specify an imported segment, the Amazon Pinpoint console displays a segment size estimate that indicates the size of the imported segment without any filters applied to it.
        public var sourceSegments: [PinpointClientTypes.SegmentReference]?
        /// Specifies how to handle multiple base segments for the segment. For example, if you specify three base segments for the segment, whether the resulting segment is based on all, any, or none of the base segments.
        public var sourceType: PinpointClientTypes.SourceType?
        /// Specifies how to handle multiple dimensions for the segment. For example, if you specify three dimensions for the segment, whether the resulting segment includes endpoints that match all, any, or none of the dimensions.
        public var type: PinpointClientTypes.ModelType?

        public init(
            dimensions: [PinpointClientTypes.SegmentDimensions]? = nil,
            sourceSegments: [PinpointClientTypes.SegmentReference]? = nil,
            sourceType: PinpointClientTypes.SourceType? = nil,
            type: PinpointClientTypes.ModelType? = nil
        )
        {
            self.dimensions = dimensions
            self.sourceSegments = sourceSegments
            self.sourceType = sourceType
            self.type = type
        }
    }
}

extension PinpointClientTypes {

    public enum Include: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case any
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [Include] {
            return [
                .all,
                .any,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .any: return "ANY"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings that define the relationships between segment groups for a segment.
    public struct SegmentGroupList: Swift.Sendable {
        /// An array that defines the set of segment criteria to evaluate when handling segment groups for the segment.
        public var groups: [PinpointClientTypes.SegmentGroup]?
        /// Specifies how to handle multiple segment groups for the segment. For example, if the segment includes three segment groups, whether the resulting segment includes endpoints that match all, any, or none of the segment groups.
        public var include: PinpointClientTypes.Include?

        public init(
            groups: [PinpointClientTypes.SegmentGroup]? = nil,
            include: PinpointClientTypes.Include? = nil
        )
        {
            self.groups = groups
            self.include = include
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the configuration, dimension, and other settings for a segment. A WriteSegmentRequest object can include a Dimensions object or a SegmentGroups object, but not both.
    public struct WriteSegmentRequest: Swift.Sendable {
        /// The criteria that define the dimensions for the segment.
        public var dimensions: PinpointClientTypes.SegmentDimensions?
        /// The name of the segment.
        public var name: Swift.String?
        /// The segment group to use and the dimensions to apply to the group's base segments in order to build the segment. A segment group can consist of zero or more base segments. Your request can include only one segment group.
        public var segmentGroups: PinpointClientTypes.SegmentGroupList?
        /// As of 22-05-2023 tags has been deprecated for update operations. After this date any value in tags is not processed and an error code is not returned. To manage tags we recommend using either [Tags](https://docs.aws.amazon.com/pinpoint/latest/apireference/tags-resource-arn.html) in the API Reference for Amazon Pinpoint, [resourcegroupstaggingapi](https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/index.html) commands in the AWS Command Line Interface Documentation or [resourcegroupstaggingapi](https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/resourcegroupstaggingapi/package-summary.html) in the AWS SDK. (Deprecated) A string-to-string map of key-value pairs that defines the tags to associate with the segment. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?

        public init(
            dimensions: PinpointClientTypes.SegmentDimensions? = nil,
            name: Swift.String? = nil,
            segmentGroups: PinpointClientTypes.SegmentGroupList? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.dimensions = dimensions
            self.name = name
            self.segmentGroups = segmentGroups
            self.tags = tags
        }
    }
}

public struct CreateSegmentInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the configuration, dimension, and other settings for a segment. A WriteSegmentRequest object can include a Dimensions object or a SegmentGroups object, but not both.
    /// This member is required.
    public var writeSegmentRequest: PinpointClientTypes.WriteSegmentRequest?

    public init(
        applicationId: Swift.String? = nil,
        writeSegmentRequest: PinpointClientTypes.WriteSegmentRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.writeSegmentRequest = writeSegmentRequest
    }
}

extension PinpointClientTypes {

    /// Provides information about the import job that created a segment. An import job is a job that creates a user segment by importing endpoint definitions.
    public struct SegmentImportResource: Swift.Sendable {
        /// The number of channel types in the endpoint definitions that were imported to create the segment.
        public var channelCounts: [Swift.String: Swift.Int]?
        /// (Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.
        /// This member is required.
        public var externalId: Swift.String?
        /// The format of the files that were imported to create the segment. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format.
        /// This member is required.
        public var format: PinpointClientTypes.Format?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorized Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The URL of the Amazon Simple Storage Service (Amazon S3) bucket that the endpoint definitions were imported from to create the segment.
        /// This member is required.
        public var s3Url: Swift.String?
        /// The number of endpoint definitions that were imported successfully to create the segment.
        /// This member is required.
        public var size: Swift.Int?

        public init(
            channelCounts: [Swift.String: Swift.Int]? = nil,
            externalId: Swift.String? = nil,
            format: PinpointClientTypes.Format? = nil,
            roleArn: Swift.String? = nil,
            s3Url: Swift.String? = nil,
            size: Swift.Int? = nil
        )
        {
            self.channelCounts = channelCounts
            self.externalId = externalId
            self.format = format
            self.roleArn = roleArn
            self.s3Url = s3Url
            self.size = size
        }
    }
}

extension PinpointClientTypes {

    public enum SegmentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dimensional
        case `import`
        case sdkUnknown(Swift.String)

        public static var allCases: [SegmentType] {
            return [
                .dimensional,
                .import
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dimensional: return "DIMENSIONAL"
            case .import: return "IMPORT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the configuration, dimension, and other settings for a segment.
    public struct SegmentResponse: Swift.Sendable {
        /// The unique identifier for the application that the segment is associated with.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the segment.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the segment was created.
        /// This member is required.
        public var creationDate: Swift.String?
        /// The dimension settings for the segment.
        public var dimensions: PinpointClientTypes.SegmentDimensions?
        /// The unique identifier for the segment.
        /// This member is required.
        public var id: Swift.String?
        /// The settings for the import job that's associated with the segment.
        public var importDefinition: PinpointClientTypes.SegmentImportResource?
        /// The date and time when the segment was last modified.
        public var lastModifiedDate: Swift.String?
        /// The name of the segment.
        public var name: Swift.String?
        /// A list of one or more segment groups that apply to the segment. Each segment group consists of zero or more base segments and the dimensions that are applied to those base segments.
        public var segmentGroups: PinpointClientTypes.SegmentGroupList?
        /// The segment type. Valid values are:
        ///
        /// * DIMENSIONAL - A dynamic segment, which is a segment that uses selection criteria that you specify and is based on endpoint data that's reported by your app. Dynamic segments can change over time.
        ///
        /// * IMPORT - A static segment, which is a segment that uses selection criteria that you specify and is based on endpoint definitions that you import from a file. Imported segments are static; they don't change over time.
        /// This member is required.
        public var segmentType: PinpointClientTypes.SegmentType?
        /// A string-to-string map of key-value pairs that identifies the tags that are associated with the segment. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?
        /// The version number of the segment.
        public var version: Swift.Int?

        public init(
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            dimensions: PinpointClientTypes.SegmentDimensions? = nil,
            id: Swift.String? = nil,
            importDefinition: PinpointClientTypes.SegmentImportResource? = nil,
            lastModifiedDate: Swift.String? = nil,
            name: Swift.String? = nil,
            segmentGroups: PinpointClientTypes.SegmentGroupList? = nil,
            segmentType: PinpointClientTypes.SegmentType? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            version: Swift.Int? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.creationDate = creationDate
            self.dimensions = dimensions
            self.id = id
            self.importDefinition = importDefinition
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.segmentGroups = segmentGroups
            self.segmentType = segmentType
            self.tags = tags
            self.version = version
        }
    }
}

public struct CreateSegmentOutput: Swift.Sendable {
    /// Provides information about the configuration, dimension, and other settings for a segment.
    /// This member is required.
    public var segmentResponse: PinpointClientTypes.SegmentResponse?

    public init(
        segmentResponse: PinpointClientTypes.SegmentResponse? = nil
    )
    {
        self.segmentResponse = segmentResponse
    }
}

extension PinpointClientTypes {

    /// Specifies the content and settings for a message template that can be used in text messages that are sent through the SMS channel.
    public struct SMSTemplateRequest: Swift.Sendable {
        /// The message body to use in text messages that are based on the message template.
        public var body: Swift.String?
        /// A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.
        public var defaultSubstitutions: Swift.String?
        /// The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.
        public var recommenderId: Swift.String?
        /// As of 22-05-2023 tags has been deprecated for update operations. After this date any value in tags is not processed and an error code is not returned. To manage tags we recommend using either [Tags](https://docs.aws.amazon.com/pinpoint/latest/apireference/tags-resource-arn.html) in the API Reference for Amazon Pinpoint, [resourcegroupstaggingapi](https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/index.html) commands in the AWS Command Line Interface Documentation or [resourcegroupstaggingapi](https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/resourcegroupstaggingapi/package-summary.html) in the AWS SDK. (Deprecated) A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?
        /// A custom description of the message template.
        public var templateDescription: Swift.String?

        public init(
            body: Swift.String? = nil,
            defaultSubstitutions: Swift.String? = nil,
            recommenderId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateDescription: Swift.String? = nil
        )
        {
            self.body = body
            self.defaultSubstitutions = defaultSubstitutions
            self.recommenderId = recommenderId
            self.tags = tags
            self.templateDescription = templateDescription
        }
    }
}

public struct CreateSmsTemplateInput: Swift.Sendable {
    /// Specifies the content and settings for a message template that can be used in text messages that are sent through the SMS channel.
    /// This member is required.
    public var smsTemplateRequest: PinpointClientTypes.SMSTemplateRequest?
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        smsTemplateRequest: PinpointClientTypes.SMSTemplateRequest? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.smsTemplateRequest = smsTemplateRequest
        self.templateName = templateName
    }
}

public struct CreateSmsTemplateOutput: Swift.Sendable {
    /// Provides information about a request to create a message template.
    /// This member is required.
    public var createTemplateMessageBody: PinpointClientTypes.CreateTemplateMessageBody?

    public init(
        createTemplateMessageBody: PinpointClientTypes.CreateTemplateMessageBody? = nil
    )
    {
        self.createTemplateMessageBody = createTemplateMessageBody
    }
}

extension PinpointClientTypes {

    /// Specifies the content and settings for a message template that can be used in messages that are sent through the voice channel.
    public struct VoiceTemplateRequest: Swift.Sendable {
        /// The text of the script to use in messages that are based on the message template, in plain text format.
        public var body: Swift.String?
        /// A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.
        public var defaultSubstitutions: Swift.String?
        /// The code for the language to use when synthesizing the text of the script in messages that are based on the message template. For a list of supported languages and the code for each one, see the [Amazon Polly Developer Guide](https://docs.aws.amazon.com/polly/latest/dg/what-is.html).
        public var languageCode: Swift.String?
        /// As of 22-05-2023 tags has been deprecated for update operations. After this date any value in tags is not processed and an error code is not returned. To manage tags we recommend using either [Tags](https://docs.aws.amazon.com/pinpoint/latest/apireference/tags-resource-arn.html) in the API Reference for Amazon Pinpoint, [resourcegroupstaggingapi](https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/index.html) commands in the AWS Command Line Interface Documentation or [resourcegroupstaggingapi](https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/resourcegroupstaggingapi/package-summary.html) in the AWS SDK. (Deprecated) A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?
        /// A custom description of the message template.
        public var templateDescription: Swift.String?
        /// The name of the voice to use when delivering messages that are based on the message template. For a list of supported voices, see the [Amazon Polly Developer Guide](https://docs.aws.amazon.com/polly/latest/dg/what-is.html).
        public var voiceId: Swift.String?

        public init(
            body: Swift.String? = nil,
            defaultSubstitutions: Swift.String? = nil,
            languageCode: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateDescription: Swift.String? = nil,
            voiceId: Swift.String? = nil
        )
        {
            self.body = body
            self.defaultSubstitutions = defaultSubstitutions
            self.languageCode = languageCode
            self.tags = tags
            self.templateDescription = templateDescription
            self.voiceId = voiceId
        }
    }
}

public struct CreateVoiceTemplateInput: Swift.Sendable {
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// Specifies the content and settings for a message template that can be used in messages that are sent through the voice channel.
    /// This member is required.
    public var voiceTemplateRequest: PinpointClientTypes.VoiceTemplateRequest?

    public init(
        templateName: Swift.String? = nil,
        voiceTemplateRequest: PinpointClientTypes.VoiceTemplateRequest? = nil
    )
    {
        self.templateName = templateName
        self.voiceTemplateRequest = voiceTemplateRequest
    }
}

public struct CreateVoiceTemplateOutput: Swift.Sendable {
    /// Provides information about a request to create a message template.
    /// This member is required.
    public var createTemplateMessageBody: PinpointClientTypes.CreateTemplateMessageBody?

    public init(
        createTemplateMessageBody: PinpointClientTypes.CreateTemplateMessageBody? = nil
    )
    {
        self.createTemplateMessageBody = createTemplateMessageBody
    }
}

extension PinpointClientTypes {

    /// Specifies the default message for all channels.
    public struct DefaultMessage: Swift.Sendable {
        /// The default body of the message.
        public var body: Swift.String?
        /// The default message variables to use in the message. You can override these default variables with individual address variables.
        public var substitutions: [Swift.String: [Swift.String]]?

        public init(
            body: Swift.String? = nil,
            substitutions: [Swift.String: [Swift.String]]? = nil
        )
        {
            self.body = body
            self.substitutions = substitutions
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the default settings and content for a push notification that's sent directly to an endpoint.
    public struct DefaultPushNotificationMessage: Swift.Sendable {
        /// The default action to occur if a recipient taps the push notification. Valid values are:
        ///
        /// * OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.
        ///
        /// * DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS and Android platforms.
        ///
        /// * URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public var action: PinpointClientTypes.Action?
        /// The default body of the notification message.
        public var body: Swift.String?
        /// The JSON data payload to use for the default push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.
        public var data: [Swift.String: Swift.String]?
        /// Specifies whether the default notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or delivering messages to an in-app notification center.
        public var silentPush: Swift.Bool?
        /// The default message variables to use in the notification message. You can override the default variables with individual address variables.
        public var substitutions: [Swift.String: [Swift.String]]?
        /// The default title to display above the notification message on a recipient's device.
        public var title: Swift.String?
        /// The default URL to open in a recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.
        public var url: Swift.String?

        public init(
            action: PinpointClientTypes.Action? = nil,
            body: Swift.String? = nil,
            data: [Swift.String: Swift.String]? = nil,
            silentPush: Swift.Bool? = nil,
            substitutions: [Swift.String: [Swift.String]]? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.action = action
            self.body = body
            self.data = data
            self.silentPush = silentPush
            self.substitutions = substitutions
            self.title = title
            self.url = url
        }
    }
}

public struct DeleteAdmChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct DeleteAdmChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the ADM (Amazon Device Messaging) channel for an application.
    /// This member is required.
    public var admChannelResponse: PinpointClientTypes.ADMChannelResponse?

    public init(
        admChannelResponse: PinpointClientTypes.ADMChannelResponse? = nil
    )
    {
        self.admChannelResponse = admChannelResponse
    }
}

public struct DeleteApnsChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct DeleteApnsChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the APNs (Apple Push Notification service) channel for an application.
    /// This member is required.
    public var apnsChannelResponse: PinpointClientTypes.APNSChannelResponse?

    public init(
        apnsChannelResponse: PinpointClientTypes.APNSChannelResponse? = nil
    )
    {
        self.apnsChannelResponse = apnsChannelResponse
    }
}

public struct DeleteApnsSandboxChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct DeleteApnsSandboxChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.
    /// This member is required.
    public var apnsSandboxChannelResponse: PinpointClientTypes.APNSSandboxChannelResponse?

    public init(
        apnsSandboxChannelResponse: PinpointClientTypes.APNSSandboxChannelResponse? = nil
    )
    {
        self.apnsSandboxChannelResponse = apnsSandboxChannelResponse
    }
}

public struct DeleteApnsVoipChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct DeleteApnsVoipChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.
    /// This member is required.
    public var apnsVoipChannelResponse: PinpointClientTypes.APNSVoipChannelResponse?

    public init(
        apnsVoipChannelResponse: PinpointClientTypes.APNSVoipChannelResponse? = nil
    )
    {
        self.apnsVoipChannelResponse = apnsVoipChannelResponse
    }
}

public struct DeleteApnsVoipSandboxChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct DeleteApnsVoipSandboxChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.
    /// This member is required.
    public var apnsVoipSandboxChannelResponse: PinpointClientTypes.APNSVoipSandboxChannelResponse?

    public init(
        apnsVoipSandboxChannelResponse: PinpointClientTypes.APNSVoipSandboxChannelResponse? = nil
    )
    {
        self.apnsVoipSandboxChannelResponse = apnsVoipSandboxChannelResponse
    }
}

public struct DeleteAppInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct DeleteAppOutput: Swift.Sendable {
    /// Provides information about an application.
    /// This member is required.
    public var applicationResponse: PinpointClientTypes.ApplicationResponse?

    public init(
        applicationResponse: PinpointClientTypes.ApplicationResponse? = nil
    )
    {
        self.applicationResponse = applicationResponse
    }
}

public struct DeleteBaiduChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct DeleteBaiduChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the Baidu (Baidu Cloud Push) channel for an application.
    /// This member is required.
    public var baiduChannelResponse: PinpointClientTypes.BaiduChannelResponse?

    public init(
        baiduChannelResponse: PinpointClientTypes.BaiduChannelResponse? = nil
    )
    {
        self.baiduChannelResponse = baiduChannelResponse
    }
}

public struct DeleteCampaignInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the campaign.
    /// This member is required.
    public var campaignId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        campaignId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
    }
}

public struct DeleteCampaignOutput: Swift.Sendable {
    /// Provides information about the status, configuration, and other settings for a campaign.
    /// This member is required.
    public var campaignResponse: PinpointClientTypes.CampaignResponse?

    public init(
        campaignResponse: PinpointClientTypes.CampaignResponse? = nil
    )
    {
        self.campaignResponse = campaignResponse
    }
}

public struct DeleteEmailChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

extension PinpointClientTypes {

    /// Provides information about the status and settings of the email channel for an application.
    public struct EmailChannelResponse: Swift.Sendable {
        /// The unique identifier for the application that the email channel applies to.
        public var applicationId: Swift.String?
        /// The [Amazon SES configuration set](https://docs.aws.amazon.com/ses/latest/APIReference/API_ConfigurationSet.html) that's applied to messages that are sent through the channel.
        public var configurationSet: Swift.String?
        /// The date and time, in ISO 8601 format, when the email channel was enabled.
        public var creationDate: Swift.String?
        /// Specifies whether the email channel is enabled for the application.
        public var enabled: Swift.Bool?
        /// The verified email address that email is sent from when you send email through the channel.
        public var fromAddress: Swift.String?
        /// (Not used) This property is retained only for backward compatibility.
        public var hasCredential: Swift.Bool?
        /// (Deprecated) An identifier for the email channel. This property is retained only for backward compatibility.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the identity, verified with Amazon Simple Email Service (Amazon SES), that's used when you send email through the channel.
        public var identity: Swift.String?
        /// Specifies whether the email channel is archived.
        public var isArchived: Swift.Bool?
        /// The user who last modified the email channel.
        public var lastModifiedBy: Swift.String?
        /// The date and time, in ISO 8601 format, when the email channel was last modified.
        public var lastModifiedDate: Swift.String?
        /// The maximum number of emails that can be sent through the channel each second.
        public var messagesPerSecond: Swift.Int?
        /// The ARN of an IAM role for Amazon Pinpoint to use to send email from your campaigns or journeys through Amazon SES.
        public var orchestrationSendingRoleArn: Swift.String?
        /// The type of messaging or notification platform for the channel. For the email channel, this value is EMAIL.
        /// This member is required.
        public var platform: Swift.String?
        /// The ARN of the AWS Identity and Access Management (IAM) role that Amazon Pinpoint uses to submit email-related event data for the channel.
        public var roleArn: Swift.String?
        /// The current version of the email channel.
        public var version: Swift.Int?

        public init(
            applicationId: Swift.String? = nil,
            configurationSet: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            fromAddress: Swift.String? = nil,
            hasCredential: Swift.Bool? = nil,
            id: Swift.String? = nil,
            identity: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            messagesPerSecond: Swift.Int? = nil,
            orchestrationSendingRoleArn: Swift.String? = nil,
            platform: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.applicationId = applicationId
            self.configurationSet = configurationSet
            self.creationDate = creationDate
            self.enabled = enabled
            self.fromAddress = fromAddress
            self.hasCredential = hasCredential
            self.id = id
            self.identity = identity
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.messagesPerSecond = messagesPerSecond
            self.orchestrationSendingRoleArn = orchestrationSendingRoleArn
            self.platform = platform
            self.roleArn = roleArn
            self.version = version
        }
    }
}

public struct DeleteEmailChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the email channel for an application.
    /// This member is required.
    public var emailChannelResponse: PinpointClientTypes.EmailChannelResponse?

    public init(
        emailChannelResponse: PinpointClientTypes.EmailChannelResponse? = nil
    )
    {
        self.emailChannelResponse = emailChannelResponse
    }
}

public struct DeleteEmailTemplateInput: Swift.Sendable {
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

extension PinpointClientTypes {

    /// Provides information about an API request or response.
    public struct MessageBody: Swift.Sendable {
        /// The message that's returned from the API.
        public var message: Swift.String?
        /// The unique identifier for the request or response.
        public var requestID: Swift.String?

        public init(
            message: Swift.String? = nil,
            requestID: Swift.String? = nil
        )
        {
            self.message = message
            self.requestID = requestID
        }
    }
}

public struct DeleteEmailTemplateOutput: Swift.Sendable {
    /// Provides information about an API request or response.
    /// This member is required.
    public var messageBody: PinpointClientTypes.MessageBody?

    public init(
        messageBody: PinpointClientTypes.MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

public struct DeleteEndpointInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The case insensitive unique identifier for the endpoint. The identifier can't contain $, { or }.
    /// This member is required.
    public var endpointId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.endpointId = endpointId
    }
}

extension PinpointClientTypes {

    /// Specifies demographic information about an endpoint, such as the applicable time zone and platform.
    public struct EndpointDemographic: Swift.Sendable {
        /// The version of the app that's associated with the endpoint.
        public var appVersion: Swift.String?
        /// The locale of the endpoint, in the following format: the ISO 639-1 alpha-2 code, followed by an underscore (_), followed by an ISO 3166-1 alpha-2 value.
        public var locale: Swift.String?
        /// The manufacturer of the endpoint device, such as apple or samsung.
        public var make: Swift.String?
        /// The model name or number of the endpoint device, such as iPhone or SM-G900F.
        public var model: Swift.String?
        /// The model version of the endpoint device.
        public var modelVersion: Swift.String?
        /// The platform of the endpoint device, such as ios.
        public var platform: Swift.String?
        /// The platform version of the endpoint device.
        public var platformVersion: Swift.String?
        /// The time zone of the endpoint, specified as a tz database name value, such as America/Los_Angeles.
        public var timezone: Swift.String?

        public init(
            appVersion: Swift.String? = nil,
            locale: Swift.String? = nil,
            make: Swift.String? = nil,
            model: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            platform: Swift.String? = nil,
            platformVersion: Swift.String? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.appVersion = appVersion
            self.locale = locale
            self.make = make
            self.model = model
            self.modelVersion = modelVersion
            self.platform = platform
            self.platformVersion = platformVersion
            self.timezone = timezone
        }
    }
}

extension PinpointClientTypes {

    /// Specifies geographic information about an endpoint.
    public struct EndpointLocation: Swift.Sendable {
        /// The name of the city where the endpoint is located.
        public var city: Swift.String?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the endpoint is located. For example, US for the United States.
        public var country: Swift.String?
        /// The latitude coordinate of the endpoint location, rounded to one decimal place.
        public var latitude: Swift.Double?
        /// The longitude coordinate of the endpoint location, rounded to one decimal place.
        public var longitude: Swift.Double?
        /// The postal or ZIP code for the area where the endpoint is located.
        public var postalCode: Swift.String?
        /// The name of the region where the endpoint is located. For locations in the United States, this value is the name of a state.
        public var region: Swift.String?

        public init(
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            latitude: Swift.Double? = nil,
            longitude: Swift.Double? = nil,
            postalCode: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.city = city
            self.country = country
            self.latitude = latitude
            self.longitude = longitude
            self.postalCode = postalCode
            self.region = region
        }
    }
}

extension PinpointClientTypes {

    /// Specifies data for one or more attributes that describe the user who's associated with an endpoint.
    public struct EndpointUser: Swift.Sendable {
        /// One or more custom attributes that describe the user by associating a name with an array of values. For example, the value of an attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive. An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.
        public var userAttributes: [Swift.String: [Swift.String]]?
        /// The unique identifier for the user.
        public var userId: Swift.String?

        public init(
            userAttributes: [Swift.String: [Swift.String]]? = nil,
            userId: Swift.String? = nil
        )
        {
            self.userAttributes = userAttributes
            self.userId = userId
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the channel type and other settings for an endpoint.
    public struct EndpointResponse: Swift.Sendable {
        /// The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For example, the address for a push-notification channel is typically the token provided by a push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. The address for the SMS channel is a phone number in E.164 format, such as +12065550100. The address for the email channel is an email address.
        public var address: Swift.String?
        /// The unique identifier for the application that's associated with the endpoint.
        public var applicationId: Swift.String?
        /// One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments.
        public var attributes: [Swift.String: [Swift.String]]?
        /// The channel that's used when sending messages or push notifications to the endpoint.
        public var channelType: PinpointClientTypes.ChannelType?
        /// A number from 0-99 that represents the cohort that the endpoint is assigned to. Endpoints are grouped into cohorts randomly, and each cohort contains approximately 1 percent of the endpoints for an application. Amazon Pinpoint assigns cohorts to the holdout or treatment allocations for campaigns.
        public var cohortId: Swift.String?
        /// The date and time, in ISO 8601 format, when the endpoint was created.
        public var creationDate: Swift.String?
        /// The demographic information for the endpoint, such as the time zone and platform.
        public var demographic: PinpointClientTypes.EndpointDemographic?
        /// The date and time, in ISO 8601 format, when the endpoint was last updated.
        public var effectiveDate: Swift.String?
        /// Specifies whether messages or push notifications are sent to the endpoint. Possible values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint. Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.
        public var endpointStatus: Swift.String?
        /// The unique identifier that you assigned to the endpoint. The identifier should be a globally unique identifier (GUID) to ensure that it doesn't conflict with other endpoint identifiers that are associated with the application.
        public var id: Swift.String?
        /// The geographic information for the endpoint.
        public var location: PinpointClientTypes.EndpointLocation?
        /// One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.
        public var metrics: [Swift.String: Swift.Double]?
        /// Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.
        public var optOut: Swift.String?
        /// The unique identifier for the most recent request to update the endpoint.
        public var requestId: Swift.String?
        /// One or more custom user attributes that your app reports to Amazon Pinpoint for the user who's associated with the endpoint.
        public var user: PinpointClientTypes.EndpointUser?

        public init(
            address: Swift.String? = nil,
            applicationId: Swift.String? = nil,
            attributes: [Swift.String: [Swift.String]]? = nil,
            channelType: PinpointClientTypes.ChannelType? = nil,
            cohortId: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            demographic: PinpointClientTypes.EndpointDemographic? = nil,
            effectiveDate: Swift.String? = nil,
            endpointStatus: Swift.String? = nil,
            id: Swift.String? = nil,
            location: PinpointClientTypes.EndpointLocation? = nil,
            metrics: [Swift.String: Swift.Double]? = nil,
            optOut: Swift.String? = nil,
            requestId: Swift.String? = nil,
            user: PinpointClientTypes.EndpointUser? = nil
        )
        {
            self.address = address
            self.applicationId = applicationId
            self.attributes = attributes
            self.channelType = channelType
            self.cohortId = cohortId
            self.creationDate = creationDate
            self.demographic = demographic
            self.effectiveDate = effectiveDate
            self.endpointStatus = endpointStatus
            self.id = id
            self.location = location
            self.metrics = metrics
            self.optOut = optOut
            self.requestId = requestId
            self.user = user
        }
    }
}

public struct DeleteEndpointOutput: Swift.Sendable {
    /// Provides information about the channel type and other settings for an endpoint.
    /// This member is required.
    public var endpointResponse: PinpointClientTypes.EndpointResponse?

    public init(
        endpointResponse: PinpointClientTypes.EndpointResponse? = nil
    )
    {
        self.endpointResponse = endpointResponse
    }
}

public struct DeleteEventStreamInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

extension PinpointClientTypes {

    /// Specifies settings for publishing event data to an Amazon Kinesis data stream or an Amazon Kinesis Data Firehose delivery stream.
    public struct EventStream: Swift.Sendable {
        /// The unique identifier for the application to publish event data for.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon Kinesis data stream or Amazon Kinesis Data Firehose delivery stream to publish event data to. For a Kinesis data stream, the ARN format is: arn:aws:kinesis:region:account-id:stream/stream_name For a Kinesis Data Firehose delivery stream, the ARN format is: arn:aws:firehose:region:account-id:deliverystream/stream_name
        /// This member is required.
        public var destinationStreamArn: Swift.String?
        /// (Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when publishing event data, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.
        public var externalId: Swift.String?
        /// The date, in ISO 8601 format, when the event stream was last modified.
        public var lastModifiedDate: Swift.String?
        /// The IAM user who last modified the event stream.
        public var lastUpdatedBy: Swift.String?
        /// The AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to publish event data to the stream in your AWS account.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            destinationStreamArn: Swift.String? = nil,
            externalId: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            lastUpdatedBy: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.destinationStreamArn = destinationStreamArn
            self.externalId = externalId
            self.lastModifiedDate = lastModifiedDate
            self.lastUpdatedBy = lastUpdatedBy
            self.roleArn = roleArn
        }
    }
}

public struct DeleteEventStreamOutput: Swift.Sendable {
    /// Specifies settings for publishing event data to an Amazon Kinesis data stream or an Amazon Kinesis Data Firehose delivery stream.
    /// This member is required.
    public var eventStream: PinpointClientTypes.EventStream?

    public init(
        eventStream: PinpointClientTypes.EventStream? = nil
    )
    {
        self.eventStream = eventStream
    }
}

public struct DeleteGcmChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

extension PinpointClientTypes {

    /// Provides information about the status and settings of the GCM channel for an application. The GCM channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.
    public struct GCMChannelResponse: Swift.Sendable {
        /// The unique identifier for the application that the GCM channel applies to.
        public var applicationId: Swift.String?
        /// The date and time when the GCM channel was enabled.
        public var creationDate: Swift.String?
        /// The Web API Key, also referred to as an API_KEY or server key, that you received from Google to communicate with Google services.
        public var credential: Swift.String?
        /// The default authentication method used for GCM. Values are either "TOKEN" or "KEY". Defaults to "KEY".
        public var defaultAuthenticationMethod: Swift.String?
        /// Specifies whether the GCM channel is enabled for the application.
        public var enabled: Swift.Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public var hasCredential: Swift.Bool?
        /// Returns true if the JSON file provided by Google during registration process was used in the ServiceJson field of the request.
        public var hasFcmServiceCredentials: Swift.Bool?
        /// (Deprecated) An identifier for the GCM channel. This property is retained only for backward compatibility.
        public var id: Swift.String?
        /// Specifies whether the GCM channel is archived.
        public var isArchived: Swift.Bool?
        /// The user who last modified the GCM channel.
        public var lastModifiedBy: Swift.String?
        /// The date and time when the GCM channel was last modified.
        public var lastModifiedDate: Swift.String?
        /// The type of messaging or notification platform for the channel. For the GCM channel, this value is GCM.
        /// This member is required.
        public var platform: Swift.String?
        /// The current version of the GCM channel.
        public var version: Swift.Int?

        public init(
            applicationId: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            credential: Swift.String? = nil,
            defaultAuthenticationMethod: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            hasCredential: Swift.Bool? = nil,
            hasFcmServiceCredentials: Swift.Bool? = nil,
            id: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            platform: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.credential = credential
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.hasFcmServiceCredentials = hasFcmServiceCredentials
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }
    }
}

public struct DeleteGcmChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the GCM channel for an application. The GCM channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.
    /// This member is required.
    public var gcmChannelResponse: PinpointClientTypes.GCMChannelResponse?

    public init(
        gcmChannelResponse: PinpointClientTypes.GCMChannelResponse? = nil
    )
    {
        self.gcmChannelResponse = gcmChannelResponse
    }
}

public struct DeleteInAppTemplateInput: Swift.Sendable {
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

public struct DeleteInAppTemplateOutput: Swift.Sendable {
    /// Provides information about an API request or response.
    /// This member is required.
    public var messageBody: PinpointClientTypes.MessageBody?

    public init(
        messageBody: PinpointClientTypes.MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

public struct DeleteJourneyInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the journey.
    /// This member is required.
    public var journeyId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        journeyId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyId = journeyId
    }
}

public struct DeleteJourneyOutput: Swift.Sendable {
    /// Provides information about the status, configuration, and other settings for a journey.
    /// This member is required.
    public var journeyResponse: PinpointClientTypes.JourneyResponse?

    public init(
        journeyResponse: PinpointClientTypes.JourneyResponse? = nil
    )
    {
        self.journeyResponse = journeyResponse
    }
}

public struct DeletePushTemplateInput: Swift.Sendable {
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

public struct DeletePushTemplateOutput: Swift.Sendable {
    /// Provides information about an API request or response.
    /// This member is required.
    public var messageBody: PinpointClientTypes.MessageBody?

    public init(
        messageBody: PinpointClientTypes.MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

public struct DeleteRecommenderConfigurationInput: Swift.Sendable {
    /// The unique identifier for the recommender model configuration. This identifier is displayed as the Recommender ID on the Amazon Pinpoint console.
    /// This member is required.
    public var recommenderId: Swift.String?

    public init(
        recommenderId: Swift.String? = nil
    )
    {
        self.recommenderId = recommenderId
    }
}

public struct DeleteRecommenderConfigurationOutput: Swift.Sendable {
    /// Provides information about Amazon Pinpoint configuration settings for retrieving and processing data from a recommender model.
    /// This member is required.
    public var recommenderConfigurationResponse: PinpointClientTypes.RecommenderConfigurationResponse?

    public init(
        recommenderConfigurationResponse: PinpointClientTypes.RecommenderConfigurationResponse? = nil
    )
    {
        self.recommenderConfigurationResponse = recommenderConfigurationResponse
    }
}

public struct DeleteSegmentInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the segment.
    /// This member is required.
    public var segmentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        segmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.segmentId = segmentId
    }
}

public struct DeleteSegmentOutput: Swift.Sendable {
    /// Provides information about the configuration, dimension, and other settings for a segment.
    /// This member is required.
    public var segmentResponse: PinpointClientTypes.SegmentResponse?

    public init(
        segmentResponse: PinpointClientTypes.SegmentResponse? = nil
    )
    {
        self.segmentResponse = segmentResponse
    }
}

public struct DeleteSmsChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

extension PinpointClientTypes {

    /// Provides information about the status and settings of the SMS channel for an application.
    public struct SMSChannelResponse: Swift.Sendable {
        /// The unique identifier for the application that the SMS channel applies to.
        public var applicationId: Swift.String?
        /// The date and time, in ISO 8601 format, when the SMS channel was enabled.
        public var creationDate: Swift.String?
        /// Specifies whether the SMS channel is enabled for the application.
        public var enabled: Swift.Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public var hasCredential: Swift.Bool?
        /// (Deprecated) An identifier for the SMS channel. This property is retained only for backward compatibility.
        public var id: Swift.String?
        /// Specifies whether the SMS channel is archived.
        public var isArchived: Swift.Bool?
        /// The user who last modified the SMS channel.
        public var lastModifiedBy: Swift.String?
        /// The date and time, in ISO 8601 format, when the SMS channel was last modified.
        public var lastModifiedDate: Swift.String?
        /// The type of messaging or notification platform for the channel. For the SMS channel, this value is SMS.
        /// This member is required.
        public var platform: Swift.String?
        /// The maximum number of promotional messages that you can send through the SMS channel each second.
        public var promotionalMessagesPerSecond: Swift.Int?
        /// The identity that displays on recipients' devices when they receive messages from the SMS channel.
        public var senderId: Swift.String?
        /// The registered short code to use when you send messages through the SMS channel.
        public var shortCode: Swift.String?
        /// The maximum number of transactional messages that you can send through the SMS channel each second.
        public var transactionalMessagesPerSecond: Swift.Int?
        /// The current version of the SMS channel.
        public var version: Swift.Int?

        public init(
            applicationId: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            hasCredential: Swift.Bool? = nil,
            id: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            platform: Swift.String? = nil,
            promotionalMessagesPerSecond: Swift.Int? = nil,
            senderId: Swift.String? = nil,
            shortCode: Swift.String? = nil,
            transactionalMessagesPerSecond: Swift.Int? = nil,
            version: Swift.Int? = nil
        )
        {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.promotionalMessagesPerSecond = promotionalMessagesPerSecond
            self.senderId = senderId
            self.shortCode = shortCode
            self.transactionalMessagesPerSecond = transactionalMessagesPerSecond
            self.version = version
        }
    }
}

public struct DeleteSmsChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the SMS channel for an application.
    /// This member is required.
    public var smsChannelResponse: PinpointClientTypes.SMSChannelResponse?

    public init(
        smsChannelResponse: PinpointClientTypes.SMSChannelResponse? = nil
    )
    {
        self.smsChannelResponse = smsChannelResponse
    }
}

public struct DeleteSmsTemplateInput: Swift.Sendable {
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

public struct DeleteSmsTemplateOutput: Swift.Sendable {
    /// Provides information about an API request or response.
    /// This member is required.
    public var messageBody: PinpointClientTypes.MessageBody?

    public init(
        messageBody: PinpointClientTypes.MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

public struct DeleteUserEndpointsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.userId = userId
    }
}

extension PinpointClientTypes {

    /// Provides information about all the endpoints that are associated with a user ID.
    public struct EndpointsResponse: Swift.Sendable {
        /// An array of responses, one for each endpoint that's associated with the user ID.
        /// This member is required.
        public var item: [PinpointClientTypes.EndpointResponse]?

        public init(
            item: [PinpointClientTypes.EndpointResponse]? = nil
        )
        {
            self.item = item
        }
    }
}

public struct DeleteUserEndpointsOutput: Swift.Sendable {
    /// Provides information about all the endpoints that are associated with a user ID.
    /// This member is required.
    public var endpointsResponse: PinpointClientTypes.EndpointsResponse?

    public init(
        endpointsResponse: PinpointClientTypes.EndpointsResponse? = nil
    )
    {
        self.endpointsResponse = endpointsResponse
    }
}

public struct DeleteVoiceChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

extension PinpointClientTypes {

    /// Provides information about the status and settings of the voice channel for an application.
    public struct VoiceChannelResponse: Swift.Sendable {
        /// The unique identifier for the application that the voice channel applies to.
        public var applicationId: Swift.String?
        /// The date and time, in ISO 8601 format, when the voice channel was enabled.
        public var creationDate: Swift.String?
        /// Specifies whether the voice channel is enabled for the application.
        public var enabled: Swift.Bool?
        /// (Not used) This property is retained only for backward compatibility.
        public var hasCredential: Swift.Bool?
        /// (Deprecated) An identifier for the voice channel. This property is retained only for backward compatibility.
        public var id: Swift.String?
        /// Specifies whether the voice channel is archived.
        public var isArchived: Swift.Bool?
        /// The user who last modified the voice channel.
        public var lastModifiedBy: Swift.String?
        /// The date and time, in ISO 8601 format, when the voice channel was last modified.
        public var lastModifiedDate: Swift.String?
        /// The type of messaging or notification platform for the channel. For the voice channel, this value is VOICE.
        /// This member is required.
        public var platform: Swift.String?
        /// The current version of the voice channel.
        public var version: Swift.Int?

        public init(
            applicationId: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            hasCredential: Swift.Bool? = nil,
            id: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            platform: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.enabled = enabled
            self.hasCredential = hasCredential
            self.id = id
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.platform = platform
            self.version = version
        }
    }
}

public struct DeleteVoiceChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the voice channel for an application.
    /// This member is required.
    public var voiceChannelResponse: PinpointClientTypes.VoiceChannelResponse?

    public init(
        voiceChannelResponse: PinpointClientTypes.VoiceChannelResponse? = nil
    )
    {
        self.voiceChannelResponse = voiceChannelResponse
    }
}

public struct DeleteVoiceTemplateInput: Swift.Sendable {
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

public struct DeleteVoiceTemplateOutput: Swift.Sendable {
    /// Provides information about an API request or response.
    /// This member is required.
    public var messageBody: PinpointClientTypes.MessageBody?

    public init(
        messageBody: PinpointClientTypes.MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

extension PinpointClientTypes {

    public enum DeliveryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case duplicate
        case optOut
        case permanentFailure
        case successful
        case temporaryFailure
        case throttled
        case unknownFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliveryStatus] {
            return [
                .duplicate,
                .optOut,
                .permanentFailure,
                .successful,
                .temporaryFailure,
                .throttled,
                .unknownFailure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .duplicate: return "DUPLICATE"
            case .optOut: return "OPT_OUT"
            case .permanentFailure: return "PERMANENT_FAILURE"
            case .successful: return "SUCCESSFUL"
            case .temporaryFailure: return "TEMPORARY_FAILURE"
            case .throttled: return "THROTTLED"
            case .unknownFailure: return "UNKNOWN_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the contents of an email message, represented as a raw MIME message.
    public struct RawEmail: Swift.Sendable {
        /// The email message, represented as a raw MIME message. The entire message must be base64 encoded.
        public var data: Foundation.Data?

        public init(
            data: Foundation.Data? = nil
        )
        {
            self.data = data
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the subject or body of an email message, represented as textual email data and the applicable character set.
    public struct SimpleEmailPart: Swift.Sendable {
        /// The applicable character set for the message content.
        public var charset: Swift.String?
        /// The textual data of the message content.
        public var data: Swift.String?

        public init(
            charset: Swift.String? = nil,
            data: Swift.String? = nil
        )
        {
            self.charset = charset
            self.data = data
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the contents of an email message, composed of a subject, a text part, and an HTML part.
    public struct SimpleEmail: Swift.Sendable {
        /// The list of MessageHeaders for the email. You can have up to 15 Headers.
        public var headers: [PinpointClientTypes.MessageHeader]?
        /// The body of the email message, in HTML format. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.
        public var htmlPart: PinpointClientTypes.SimpleEmailPart?
        /// The subject line, or title, of the email.
        public var subject: PinpointClientTypes.SimpleEmailPart?
        /// The body of the email message, in plain text format. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.
        public var textPart: PinpointClientTypes.SimpleEmailPart?

        public init(
            headers: [PinpointClientTypes.MessageHeader]? = nil,
            htmlPart: PinpointClientTypes.SimpleEmailPart? = nil,
            subject: PinpointClientTypes.SimpleEmailPart? = nil,
            textPart: PinpointClientTypes.SimpleEmailPart? = nil
        )
        {
            self.headers = headers
            self.htmlPart = htmlPart
            self.subject = subject
            self.textPart = textPart
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the default settings and content for a one-time email message that's sent directly to an endpoint.
    public struct EmailMessage: Swift.Sendable {
        /// The body of the email message.
        public var body: Swift.String?
        /// The email address to forward bounces and complaints to, if feedback forwarding is enabled.
        public var feedbackForwardingAddress: Swift.String?
        /// The verified email address to send the email message from. The default value is the FromAddress specified for the email channel.
        public var fromAddress: Swift.String?
        /// The email message, represented as a raw MIME message.
        public var rawEmail: PinpointClientTypes.RawEmail?
        /// The reply-to email address(es) for the email message. If a recipient replies to the email, each reply-to address receives the reply.
        public var replyToAddresses: [Swift.String]?
        /// The email message, composed of a subject, a text part, and an HTML part.
        public var simpleEmail: PinpointClientTypes.SimpleEmail?
        /// The default message variables to use in the email message. You can override the default variables with individual address variables.
        public var substitutions: [Swift.String: [Swift.String]]?

        public init(
            body: Swift.String? = nil,
            feedbackForwardingAddress: Swift.String? = nil,
            fromAddress: Swift.String? = nil,
            rawEmail: PinpointClientTypes.RawEmail? = nil,
            replyToAddresses: [Swift.String]? = nil,
            simpleEmail: PinpointClientTypes.SimpleEmail? = nil,
            substitutions: [Swift.String: [Swift.String]]? = nil
        )
        {
            self.body = body
            self.feedbackForwardingAddress = feedbackForwardingAddress
            self.fromAddress = fromAddress
            self.rawEmail = rawEmail
            self.replyToAddresses = replyToAddresses
            self.simpleEmail = simpleEmail
            self.substitutions = substitutions
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a one-time message that's sent directly to an endpoint through the GCM channel. The GCM channel enables Amazon Pinpoint to send messages to the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.
    public struct GCMMessage: Swift.Sendable {
        /// The action to occur if the recipient taps the push notification. Valid values are:
        ///
        /// * OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.
        ///
        /// * DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.
        ///
        /// * URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.
        public var action: PinpointClientTypes.Action?
        /// The body of the notification message.
        public var body: Swift.String?
        /// An arbitrary string that identifies a group of messages that can be collapsed to ensure that only the last message is sent when delivery can resume. This helps avoid sending too many instances of the same messages when the recipient's device comes online again or becomes active. Amazon Pinpoint specifies this value in the Firebase Cloud Messaging (FCM) collapse_key parameter when it sends the notification message to FCM.
        public var collapseKey: Swift.String?
        /// The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.
        public var data: [Swift.String: Swift.String]?
        /// The icon image name of the asset saved in your app.
        public var iconReference: Swift.String?
        /// The URL of the large icon image to display in the content view of the push notification.
        public var imageIconUrl: Swift.String?
        /// The URL of an image to display in the push notification.
        public var imageUrl: Swift.String?
        /// The preferred authentication method, with valid values "KEY" or "TOKEN". If a value isn't provided then the DefaultAuthenticationMethod is used.
        public var preferredAuthenticationMethod: Swift.String?
        /// para>normal – The notification might be delayed. Delivery is optimized for battery usage on the recipient's device. Use this value unless immediate delivery is required./listitem>
        /// * high – The notification is sent immediately and might wake a sleeping device.
        /// /para> Amazon Pinpoint specifies this value in the FCM priority parameter when it sends the notification message to FCM. The equivalent values for Apple Push Notification service (APNs) are 5, for normal, and 10, for high. If you specify an APNs value for this property, Amazon Pinpoint accepts and converts the value to the corresponding FCM value.
        public var priority: Swift.String?
        /// The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.
        public var rawContent: Swift.String?
        /// The package name of the application where registration tokens must match in order for the recipient to receive the message.
        public var restrictedPackageName: Swift.String?
        /// Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.
        public var silentPush: Swift.Bool?
        /// The URL of the small icon image to display in the status bar and the content view of the push notification.
        public var smallImageIconUrl: Swift.String?
        /// The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.
        public var sound: Swift.String?
        /// The default message variables to use in the notification message. You can override the default variables with individual address variables.
        public var substitutions: [Swift.String: [Swift.String]]?
        /// The amount of time, in seconds, that FCM should store and attempt to deliver the push notification, if the service is unable to deliver the notification the first time. If you don't specify this value, FCM defaults to the maximum value, which is 2,419,200 seconds (28 days). Amazon Pinpoint specifies this value in the FCM time_to_live parameter when it sends the notification message to FCM.
        public var timeToLive: Swift.Int?
        /// The title to display above the notification message on the recipient's device.
        public var title: Swift.String?
        /// The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.
        public var url: Swift.String?

        public init(
            action: PinpointClientTypes.Action? = nil,
            body: Swift.String? = nil,
            collapseKey: Swift.String? = nil,
            data: [Swift.String: Swift.String]? = nil,
            iconReference: Swift.String? = nil,
            imageIconUrl: Swift.String? = nil,
            imageUrl: Swift.String? = nil,
            preferredAuthenticationMethod: Swift.String? = nil,
            priority: Swift.String? = nil,
            rawContent: Swift.String? = nil,
            restrictedPackageName: Swift.String? = nil,
            silentPush: Swift.Bool? = nil,
            smallImageIconUrl: Swift.String? = nil,
            sound: Swift.String? = nil,
            substitutions: [Swift.String: [Swift.String]]? = nil,
            timeToLive: Swift.Int? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.action = action
            self.body = body
            self.collapseKey = collapseKey
            self.data = data
            self.iconReference = iconReference
            self.imageIconUrl = imageIconUrl
            self.imageUrl = imageUrl
            self.preferredAuthenticationMethod = preferredAuthenticationMethod
            self.priority = priority
            self.rawContent = rawContent
            self.restrictedPackageName = restrictedPackageName
            self.silentPush = silentPush
            self.smallImageIconUrl = smallImageIconUrl
            self.sound = sound
            self.substitutions = substitutions
            self.timeToLive = timeToLive
            self.title = title
            self.url = url
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the default settings for a one-time SMS message that's sent directly to an endpoint.
    public struct SMSMessage: Swift.Sendable {
        /// The body of the SMS message.
        public var body: Swift.String?
        /// The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.
        public var entityId: Swift.String?
        /// The SMS program name that you provided to AWS Support when you requested your dedicated number.
        public var keyword: Swift.String?
        /// This field is reserved for future use.
        public var mediaUrl: Swift.String?
        /// The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).
        public var messageType: PinpointClientTypes.MessageType?
        /// The number to send the SMS message from. This value should be one of the dedicated long or short codes that's assigned to your AWS account. If you don't specify a long or short code, Amazon Pinpoint assigns a random long code to the SMS message and sends the message from that code.
        public var originationNumber: Swift.String?
        /// The sender ID to display as the sender of the message on a recipient's device. Support for sender IDs varies by country or region.
        public var senderId: Swift.String?
        /// The message variables to use in the SMS message. You can override the default variables with individual address variables.
        public var substitutions: [Swift.String: [Swift.String]]?
        /// The template ID received from the regulatory body for sending SMS in your country.
        public var templateId: Swift.String?

        public init(
            body: Swift.String? = nil,
            entityId: Swift.String? = nil,
            keyword: Swift.String? = nil,
            mediaUrl: Swift.String? = nil,
            messageType: PinpointClientTypes.MessageType? = nil,
            originationNumber: Swift.String? = nil,
            senderId: Swift.String? = nil,
            substitutions: [Swift.String: [Swift.String]]? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.body = body
            self.entityId = entityId
            self.keyword = keyword
            self.mediaUrl = mediaUrl
            self.messageType = messageType
            self.originationNumber = originationNumber
            self.senderId = senderId
            self.substitutions = substitutions
            self.templateId = templateId
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings for a one-time voice message that's sent directly to an endpoint through the voice channel.
    public struct VoiceMessage: Swift.Sendable {
        /// The text of the script to use for the voice message.
        public var body: Swift.String?
        /// The code for the language to use when synthesizing the text of the message script. For a list of supported languages and the code for each one, see the [Amazon Polly Developer Guide](https://docs.aws.amazon.com/polly/latest/dg/what-is.html).
        public var languageCode: Swift.String?
        /// The long code to send the voice message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code in E.164 format, for example +12065550100, to ensure prompt and accurate delivery of the message.
        public var originationNumber: Swift.String?
        /// The default message variables to use in the voice message. You can override the default variables with individual address variables.
        public var substitutions: [Swift.String: [Swift.String]]?
        /// The name of the voice to use when delivering the message. For a list of supported voices, see the [Amazon Polly Developer Guide](https://docs.aws.amazon.com/polly/latest/dg/what-is.html).
        public var voiceId: Swift.String?

        public init(
            body: Swift.String? = nil,
            languageCode: Swift.String? = nil,
            originationNumber: Swift.String? = nil,
            substitutions: [Swift.String: [Swift.String]]? = nil,
            voiceId: Swift.String? = nil
        )
        {
            self.body = body
            self.languageCode = languageCode
            self.originationNumber = originationNumber
            self.substitutions = substitutions
            self.voiceId = voiceId
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the settings and content for the default message and any default messages that you tailored for specific channels.
    public struct DirectMessageConfiguration: Swift.Sendable {
        /// The default push notification message for the ADM (Amazon Device Messaging) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).
        public var admMessage: PinpointClientTypes.ADMMessage?
        /// The default push notification message for the APNs (Apple Push Notification service) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).
        public var apnsMessage: PinpointClientTypes.APNSMessage?
        /// The default push notification message for the Baidu (Baidu Cloud Push) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).
        public var baiduMessage: PinpointClientTypes.BaiduMessage?
        /// The default message for all channels.
        public var defaultMessage: PinpointClientTypes.DefaultMessage?
        /// The default push notification message for all push notification channels.
        public var defaultPushNotificationMessage: PinpointClientTypes.DefaultPushNotificationMessage?
        /// The default message for the email channel. This message overrides the default message (DefaultMessage).
        public var emailMessage: PinpointClientTypes.EmailMessage?
        /// The default push notification message for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message overrides the default push notification message (DefaultPushNotificationMessage).
        public var gcmMessage: PinpointClientTypes.GCMMessage?
        /// The default message for the SMS channel. This message overrides the default message (DefaultMessage).
        public var smsMessage: PinpointClientTypes.SMSMessage?
        /// The default message for the voice channel. This message overrides the default message (DefaultMessage).
        public var voiceMessage: PinpointClientTypes.VoiceMessage?

        public init(
            admMessage: PinpointClientTypes.ADMMessage? = nil,
            apnsMessage: PinpointClientTypes.APNSMessage? = nil,
            baiduMessage: PinpointClientTypes.BaiduMessage? = nil,
            defaultMessage: PinpointClientTypes.DefaultMessage? = nil,
            defaultPushNotificationMessage: PinpointClientTypes.DefaultPushNotificationMessage? = nil,
            emailMessage: PinpointClientTypes.EmailMessage? = nil,
            gcmMessage: PinpointClientTypes.GCMMessage? = nil,
            smsMessage: PinpointClientTypes.SMSMessage? = nil,
            voiceMessage: PinpointClientTypes.VoiceMessage? = nil
        )
        {
            self.admMessage = admMessage
            self.apnsMessage = apnsMessage
            self.baiduMessage = baiduMessage
            self.defaultMessage = defaultMessage
            self.defaultPushNotificationMessage = defaultPushNotificationMessage
            self.emailMessage = emailMessage
            self.gcmMessage = gcmMessage
            self.smsMessage = smsMessage
            self.voiceMessage = voiceMessage
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the status and settings of the email channel for an application.
    public struct EmailChannelRequest: Swift.Sendable {
        /// The [Amazon SES configuration set](https://docs.aws.amazon.com/ses/latest/APIReference/API_ConfigurationSet.html) that you want to apply to messages that you send through the channel.
        public var configurationSet: Swift.String?
        /// Specifies whether to enable the email channel for the application.
        public var enabled: Swift.Bool?
        /// The verified email address that you want to send email from when you send email through the channel.
        /// This member is required.
        public var fromAddress: Swift.String?
        /// The Amazon Resource Name (ARN) of the identity, verified with Amazon Simple Email Service (Amazon SES), that you want to use when you send email through the channel.
        /// This member is required.
        public var identity: Swift.String?
        /// The ARN of an IAM role for Amazon Pinpoint to use to send email from your campaigns or journeys through Amazon SES.
        public var orchestrationSendingRoleArn: Swift.String?
        /// The ARN of the AWS Identity and Access Management (IAM) role that you want Amazon Pinpoint to use when it submits email-related event data for the channel.
        public var roleArn: Swift.String?

        public init(
            configurationSet: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            fromAddress: Swift.String? = nil,
            identity: Swift.String? = nil,
            orchestrationSendingRoleArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.configurationSet = configurationSet
            self.enabled = enabled
            self.fromAddress = fromAddress
            self.identity = identity
            self.orchestrationSendingRoleArn = orchestrationSendingRoleArn
            self.roleArn = roleArn
        }
    }
}

extension PinpointClientTypes {

    public enum TemplateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case email
        case inapp
        case push
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateType] {
            return [
                .email,
                .inapp,
                .push,
                .sms,
                .voice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .inapp: return "INAPP"
            case .push: return "PUSH"
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the content and settings for a message template that can be used in messages that are sent through the email channel.
    public struct EmailTemplateResponse: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the message template.
        public var arn: Swift.String?
        /// The date, in ISO 8601 format, when the message template was created.
        /// This member is required.
        public var creationDate: Swift.String?
        /// The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.
        public var defaultSubstitutions: Swift.String?
        /// The list of [MessageHeaders](https://docs.aws.amazon.com/pinpoint/latest/apireference/templates-template-name-email.html#templates-template-name-email-model-messageheader) for the email. You can have up to 15 Headers.
        public var headers: [PinpointClientTypes.MessageHeader]?
        /// The message body, in HTML format, that's used in email messages that are based on the message template.
        public var htmlPart: Swift.String?
        /// The date, in ISO 8601 format, when the message template was last modified.
        /// This member is required.
        public var lastModifiedDate: Swift.String?
        /// The unique identifier for the recommender model that's used by the message template.
        public var recommenderId: Swift.String?
        /// The subject line, or title, that's used in email messages that are based on the message template.
        public var subject: Swift.String?
        /// A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?
        /// The custom description of the message template.
        public var templateDescription: Swift.String?
        /// The name of the message template.
        /// This member is required.
        public var templateName: Swift.String?
        /// The type of channel that the message template is designed for. For an email template, this value is EMAIL.
        /// This member is required.
        public var templateType: PinpointClientTypes.TemplateType?
        /// The message body, in plain text format, that's used in email messages that are based on the message template.
        public var textPart: Swift.String?
        /// The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            defaultSubstitutions: Swift.String? = nil,
            headers: [PinpointClientTypes.MessageHeader]? = nil,
            htmlPart: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            recommenderId: Swift.String? = nil,
            subject: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateDescription: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateType: PinpointClientTypes.TemplateType? = nil,
            textPart: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationDate = creationDate
            self.defaultSubstitutions = defaultSubstitutions
            self.headers = headers
            self.htmlPart = htmlPart
            self.lastModifiedDate = lastModifiedDate
            self.recommenderId = recommenderId
            self.subject = subject
            self.tags = tags
            self.templateDescription = templateDescription
            self.templateName = templateName
            self.templateType = templateType
            self.textPart = textPart
            self.version = version
        }
    }
}

extension PinpointClientTypes {

    /// Specifies an endpoint to create or update and the settings and attributes to set or change for the endpoint.
    public struct EndpointBatchItem: Swift.Sendable {
        /// The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For a push-notification channel, use the token provided by the push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.
        public var address: Swift.String?
        /// One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive. An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.
        public var attributes: [Swift.String: [Swift.String]]?
        /// The channel to use when sending messages or push notifications to the endpoint.
        public var channelType: PinpointClientTypes.ChannelType?
        /// The demographic information for the endpoint, such as the time zone and platform.
        public var demographic: PinpointClientTypes.EndpointDemographic?
        /// The date and time, in ISO 8601 format, when the endpoint was created or updated.
        public var effectiveDate: Swift.String?
        /// Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint. Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.
        public var endpointStatus: Swift.String?
        /// The unique identifier for the endpoint in the context of the batch.
        public var id: Swift.String?
        /// The geographic information for the endpoint.
        public var location: PinpointClientTypes.EndpointLocation?
        /// One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.
        public var metrics: [Swift.String: Swift.Double]?
        /// Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.
        public var optOut: Swift.String?
        /// The unique identifier for the request to create or update the endpoint.
        public var requestId: Swift.String?
        /// One or more custom attributes that describe the user who's associated with the endpoint.
        public var user: PinpointClientTypes.EndpointUser?

        public init(
            address: Swift.String? = nil,
            attributes: [Swift.String: [Swift.String]]? = nil,
            channelType: PinpointClientTypes.ChannelType? = nil,
            demographic: PinpointClientTypes.EndpointDemographic? = nil,
            effectiveDate: Swift.String? = nil,
            endpointStatus: Swift.String? = nil,
            id: Swift.String? = nil,
            location: PinpointClientTypes.EndpointLocation? = nil,
            metrics: [Swift.String: Swift.Double]? = nil,
            optOut: Swift.String? = nil,
            requestId: Swift.String? = nil,
            user: PinpointClientTypes.EndpointUser? = nil
        )
        {
            self.address = address
            self.attributes = attributes
            self.channelType = channelType
            self.demographic = demographic
            self.effectiveDate = effectiveDate
            self.endpointStatus = endpointStatus
            self.id = id
            self.location = location
            self.metrics = metrics
            self.optOut = optOut
            self.requestId = requestId
            self.user = user
        }
    }
}

extension PinpointClientTypes {

    /// Specifies a batch of endpoints to create or update and the settings and attributes to set or change for each endpoint.
    public struct EndpointBatchRequest: Swift.Sendable {
        /// An array that defines the endpoints to create or update and, for each endpoint, the property values to set or change. An array can contain a maximum of 100 items.
        /// This member is required.
        public var item: [PinpointClientTypes.EndpointBatchItem]?

        public init(
            item: [PinpointClientTypes.EndpointBatchItem]? = nil
        )
        {
            self.item = item
        }
    }
}

extension PinpointClientTypes {

    /// Provides the status code and message that result from processing data for an endpoint.
    public struct EndpointItemResponse: Swift.Sendable {
        /// The custom message that's returned in the response as a result of processing the endpoint data.
        public var message: Swift.String?
        /// The status code that's returned in the response as a result of processing the endpoint data.
        public var statusCode: Swift.Int?

        public init(
            message: Swift.String? = nil,
            statusCode: Swift.Int? = nil
        )
        {
            self.message = message
            self.statusCode = statusCode
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the delivery status and results of sending a message directly to an endpoint.
    public struct EndpointMessageResult: Swift.Sendable {
        /// The endpoint address that the message was delivered to.
        public var address: Swift.String?
        /// The delivery status of the message. Possible values are:
        ///
        /// * DUPLICATE - The endpoint address is a duplicate of another endpoint address. Amazon Pinpoint won't attempt to send the message again.
        ///
        /// * OPT_OUT - The user who's associated with the endpoint has opted out of receiving messages from you. Amazon Pinpoint won't attempt to send the message again.
        ///
        /// * PERMANENT_FAILURE - An error occurred when delivering the message to the endpoint. Amazon Pinpoint won't attempt to send the message again.
        ///
        /// * SUCCESSFUL - The message was successfully delivered to the endpoint.
        ///
        /// * TEMPORARY_FAILURE - A temporary error occurred. Amazon Pinpoint won't attempt to send the message again.
        ///
        /// * THROTTLED - Amazon Pinpoint throttled the operation to send the message to the endpoint.
        ///
        /// * UNKNOWN_FAILURE - An unknown error occurred.
        /// This member is required.
        public var deliveryStatus: PinpointClientTypes.DeliveryStatus?
        /// The unique identifier for the message that was sent.
        public var messageId: Swift.String?
        /// The downstream service status code for delivering the message.
        /// This member is required.
        public var statusCode: Swift.Int?
        /// The status message for delivering the message.
        public var statusMessage: Swift.String?
        /// For push notifications that are sent through the GCM channel, specifies whether the endpoint's device registration token was updated as part of delivering the message.
        public var updatedToken: Swift.String?

        public init(
            address: Swift.String? = nil,
            deliveryStatus: PinpointClientTypes.DeliveryStatus? = nil,
            messageId: Swift.String? = nil,
            statusCode: Swift.Int? = nil,
            statusMessage: Swift.String? = nil,
            updatedToken: Swift.String? = nil
        )
        {
            self.address = address
            self.deliveryStatus = deliveryStatus
            self.messageId = messageId
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.updatedToken = updatedToken
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the channel type and other settings for an endpoint.
    public struct EndpointRequest: Swift.Sendable {
        /// The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For a push-notification channel, use the token provided by the push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.
        public var address: Swift.String?
        /// One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive. An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.
        public var attributes: [Swift.String: [Swift.String]]?
        /// The channel to use when sending messages or push notifications to the endpoint.
        public var channelType: PinpointClientTypes.ChannelType?
        /// The demographic information for the endpoint, such as the time zone and platform.
        public var demographic: PinpointClientTypes.EndpointDemographic?
        /// The date and time, in ISO 8601 format, when the endpoint is updated.
        public var effectiveDate: Swift.String?
        /// Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint. Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.
        public var endpointStatus: Swift.String?
        /// The geographic information for the endpoint.
        public var location: PinpointClientTypes.EndpointLocation?
        /// One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.
        public var metrics: [Swift.String: Swift.Double]?
        /// Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.
        public var optOut: Swift.String?
        /// The unique identifier for the most recent request to update the endpoint.
        public var requestId: Swift.String?
        /// One or more custom attributes that describe the user who's associated with the endpoint.
        public var user: PinpointClientTypes.EndpointUser?

        public init(
            address: Swift.String? = nil,
            attributes: [Swift.String: [Swift.String]]? = nil,
            channelType: PinpointClientTypes.ChannelType? = nil,
            demographic: PinpointClientTypes.EndpointDemographic? = nil,
            effectiveDate: Swift.String? = nil,
            endpointStatus: Swift.String? = nil,
            location: PinpointClientTypes.EndpointLocation? = nil,
            metrics: [Swift.String: Swift.Double]? = nil,
            optOut: Swift.String? = nil,
            requestId: Swift.String? = nil,
            user: PinpointClientTypes.EndpointUser? = nil
        )
        {
            self.address = address
            self.attributes = attributes
            self.channelType = channelType
            self.demographic = demographic
            self.effectiveDate = effectiveDate
            self.endpointStatus = endpointStatus
            self.location = location
            self.metrics = metrics
            self.optOut = optOut
            self.requestId = requestId
            self.user = user
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the content, including message variables and attributes, to use in a message that's sent directly to an endpoint.
    public struct EndpointSendConfiguration: Swift.Sendable {
        /// The body of the message. If specified, this value overrides the default message body.
        public var bodyOverride: Swift.String?
        /// A map of custom attributes to attach to the message for the address. Attribute names are case sensitive. For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.
        public var context: [Swift.String: Swift.String]?
        /// The raw, JSON-formatted string to use as the payload for the message. If specified, this value overrides all other values for the message.
        public var rawContent: Swift.String?
        /// A map of the message variables to merge with the variables specified for the default message (DefaultMessage.Substitutions). The variables specified in this map take precedence over all other variables.
        public var substitutions: [Swift.String: [Swift.String]]?
        /// The title or subject line of the message. If specified, this value overrides the default message title or subject line.
        public var titleOverride: Swift.String?

        public init(
            bodyOverride: Swift.String? = nil,
            context: [Swift.String: Swift.String]? = nil,
            rawContent: Swift.String? = nil,
            substitutions: [Swift.String: [Swift.String]]? = nil,
            titleOverride: Swift.String? = nil
        )
        {
            self.bodyOverride = bodyOverride
            self.context = context
            self.rawContent = rawContent
            self.substitutions = substitutions
            self.titleOverride = titleOverride
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about a session.
    public struct Session: Swift.Sendable {
        /// The duration of the session, in milliseconds.
        public var duration: Swift.Int?
        /// The unique identifier for the session.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time when the session began.
        /// This member is required.
        public var startTimestamp: Swift.String?
        /// The date and time when the session ended.
        public var stopTimestamp: Swift.String?

        public init(
            duration: Swift.Int? = nil,
            id: Swift.String? = nil,
            startTimestamp: Swift.String? = nil,
            stopTimestamp: Swift.String? = nil
        )
        {
            self.duration = duration
            self.id = id
            self.startTimestamp = startTimestamp
            self.stopTimestamp = stopTimestamp
        }
    }
}

extension PinpointClientTypes {

    /// Specifies information about an event that reports data to Amazon Pinpoint.
    public struct Event: Swift.Sendable {
        /// The package name of the app that's recording the event.
        public var appPackageName: Swift.String?
        /// The title of the app that's recording the event.
        public var appTitle: Swift.String?
        /// The version number of the app that's recording the event.
        public var appVersionCode: Swift.String?
        /// One or more custom attributes that are associated with the event.
        public var attributes: [Swift.String: Swift.String]?
        /// The version of the SDK that's running on the client device.
        public var clientSdkVersion: Swift.String?
        /// The name of the event.
        /// This member is required.
        public var eventType: Swift.String?
        /// One or more custom metrics that are associated with the event.
        public var metrics: [Swift.String: Swift.Double]?
        /// The name of the SDK that's being used to record the event.
        public var sdkName: Swift.String?
        /// Information about the session in which the event occurred.
        public var session: PinpointClientTypes.Session?
        /// The date and time, in ISO 8601 format, when the event occurred.
        /// This member is required.
        public var timestamp: Swift.String?

        public init(
            appPackageName: Swift.String? = nil,
            appTitle: Swift.String? = nil,
            appVersionCode: Swift.String? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            clientSdkVersion: Swift.String? = nil,
            eventType: Swift.String? = nil,
            metrics: [Swift.String: Swift.Double]? = nil,
            sdkName: Swift.String? = nil,
            session: PinpointClientTypes.Session? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.appPackageName = appPackageName
            self.appTitle = appTitle
            self.appVersionCode = appVersionCode
            self.attributes = attributes
            self.clientSdkVersion = clientSdkVersion
            self.eventType = eventType
            self.metrics = metrics
            self.sdkName = sdkName
            self.session = session
            self.timestamp = timestamp
        }
    }
}

extension PinpointClientTypes {

    /// Provides the status code and message that result from processing an event.
    public struct EventItemResponse: Swift.Sendable {
        /// A custom message that's returned in the response as a result of processing the event.
        public var message: Swift.String?
        /// The status code that's returned in the response as a result of processing the event. Possible values are: 202, for events that were accepted; and, 400, for events that weren't valid.
        public var statusCode: Swift.Int?

        public init(
            message: Swift.String? = nil,
            statusCode: Swift.Int? = nil
        )
        {
            self.message = message
            self.statusCode = statusCode
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the properties and attributes of an endpoint that's associated with an event.
    public struct PublicEndpoint: Swift.Sendable {
        /// The unique identifier for the recipient, such as a device token, email address, or mobile phone number.
        public var address: Swift.String?
        /// One or more custom attributes that describe the endpoint by associating a name with an array of values. You can use these attributes as filter criteria when you create segments.
        public var attributes: [Swift.String: [Swift.String]]?
        /// The channel that's used when sending messages or push notifications to the endpoint.
        public var channelType: PinpointClientTypes.ChannelType?
        /// The demographic information for the endpoint, such as the time zone and platform.
        public var demographic: PinpointClientTypes.EndpointDemographic?
        /// The date and time, in ISO 8601 format, when the endpoint was last updated.
        public var effectiveDate: Swift.String?
        /// Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint. Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.
        public var endpointStatus: Swift.String?
        /// The geographic information for the endpoint.
        public var location: PinpointClientTypes.EndpointLocation?
        /// One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.
        public var metrics: [Swift.String: Swift.Double]?
        /// Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.
        public var optOut: Swift.String?
        /// A unique identifier that's generated each time the endpoint is updated.
        public var requestId: Swift.String?
        /// One or more custom user attributes that your app reports to Amazon Pinpoint for the user who's associated with the endpoint.
        public var user: PinpointClientTypes.EndpointUser?

        public init(
            address: Swift.String? = nil,
            attributes: [Swift.String: [Swift.String]]? = nil,
            channelType: PinpointClientTypes.ChannelType? = nil,
            demographic: PinpointClientTypes.EndpointDemographic? = nil,
            effectiveDate: Swift.String? = nil,
            endpointStatus: Swift.String? = nil,
            location: PinpointClientTypes.EndpointLocation? = nil,
            metrics: [Swift.String: Swift.Double]? = nil,
            optOut: Swift.String? = nil,
            requestId: Swift.String? = nil,
            user: PinpointClientTypes.EndpointUser? = nil
        )
        {
            self.address = address
            self.attributes = attributes
            self.channelType = channelType
            self.demographic = demographic
            self.effectiveDate = effectiveDate
            self.endpointStatus = endpointStatus
            self.location = location
            self.metrics = metrics
            self.optOut = optOut
            self.requestId = requestId
            self.user = user
        }
    }
}

extension PinpointClientTypes {

    /// Specifies a batch of endpoints and events to process.
    public struct EventsBatch: Swift.Sendable {
        /// A set of properties and attributes that are associated with the endpoint.
        /// This member is required.
        public var endpoint: PinpointClientTypes.PublicEndpoint?
        /// A set of properties that are associated with the event.
        /// This member is required.
        public var events: [Swift.String: PinpointClientTypes.Event]?

        public init(
            endpoint: PinpointClientTypes.PublicEndpoint? = nil,
            events: [Swift.String: PinpointClientTypes.Event]? = nil
        )
        {
            self.endpoint = endpoint
            self.events = events
        }
    }
}

extension PinpointClientTypes {

    /// Specifies a batch of events to process.
    public struct EventsRequest: Swift.Sendable {
        /// The batch of events to process. For each item in a batch, the endpoint ID acts as a key that has an EventsBatch object as its value.
        /// This member is required.
        public var batchItem: [Swift.String: PinpointClientTypes.EventsBatch]?

        public init(
            batchItem: [Swift.String: PinpointClientTypes.EventsBatch]? = nil
        )
        {
            self.batchItem = batchItem
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the results of a request to create or update an endpoint that's associated with an event.
    public struct ItemResponse: Swift.Sendable {
        /// The response that was received after the endpoint data was accepted.
        public var endpointItemResponse: PinpointClientTypes.EndpointItemResponse?
        /// A multipart response object that contains a key and a value for each event in the request. In each object, the event ID is the key and an EventItemResponse object is the value.
        public var eventsItemResponse: [Swift.String: PinpointClientTypes.EventItemResponse]?

        public init(
            endpointItemResponse: PinpointClientTypes.EndpointItemResponse? = nil,
            eventsItemResponse: [Swift.String: PinpointClientTypes.EventItemResponse]? = nil
        )
        {
            self.endpointItemResponse = endpointItemResponse
            self.eventsItemResponse = eventsItemResponse
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about endpoints and the events that they're associated with.
    public struct EventsResponse: Swift.Sendable {
        /// A map that contains a multipart response for each endpoint. For each item in this object, the endpoint ID is the key and the item response is the value. If no item response exists, the value can also be one of the following: 202, the request was processed successfully; or 400, the payload wasn't valid or required fields were missing.
        public var results: [Swift.String: PinpointClientTypes.ItemResponse]?

        public init(
            results: [Swift.String: PinpointClientTypes.ItemResponse]? = nil
        )
        {
            self.results = results
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about all the export jobs that are associated with an application or segment. An export job is a job that exports endpoint definitions to a file.
    public struct ExportJobsResponse: Swift.Sendable {
        /// An array of responses, one for each export job that's associated with the application (Export Jobs resource) or segment (Segment Export Jobs resource).
        /// This member is required.
        public var item: [PinpointClientTypes.ExportJobResponse]?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public var nextToken: Swift.String?

        public init(
            item: [PinpointClientTypes.ExportJobResponse]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.item = item
            self.nextToken = nextToken
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the status and settings of the GCM channel for an application. This channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.
    public struct GCMChannelRequest: Swift.Sendable {
        /// The Web API Key, also referred to as an API_KEY or server key, that you received from Google to communicate with Google services.
        public var apiKey: Swift.String?
        /// The default authentication method used for GCM. Values are either "TOKEN" or "KEY". Defaults to "KEY".
        public var defaultAuthenticationMethod: Swift.String?
        /// Specifies whether to enable the GCM channel for the application.
        public var enabled: Swift.Bool?
        /// The contents of the JSON file provided by Google during registration in order to generate an access token for authentication. For more information see [Migrate from legacy FCM APIs to HTTP v1](https://firebase.google.com/docs/cloud-messaging/migrate-v1).
        public var serviceJson: Swift.String?

        public init(
            apiKey: Swift.String? = nil,
            defaultAuthenticationMethod: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            serviceJson: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.enabled = enabled
            self.serviceJson = serviceJson
        }
    }
}

public struct GetAdmChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetAdmChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the ADM (Amazon Device Messaging) channel for an application.
    /// This member is required.
    public var admChannelResponse: PinpointClientTypes.ADMChannelResponse?

    public init(
        admChannelResponse: PinpointClientTypes.ADMChannelResponse? = nil
    )
    {
        self.admChannelResponse = admChannelResponse
    }
}

public struct GetApnsChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetApnsChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the APNs (Apple Push Notification service) channel for an application.
    /// This member is required.
    public var apnsChannelResponse: PinpointClientTypes.APNSChannelResponse?

    public init(
        apnsChannelResponse: PinpointClientTypes.APNSChannelResponse? = nil
    )
    {
        self.apnsChannelResponse = apnsChannelResponse
    }
}

public struct GetApnsSandboxChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetApnsSandboxChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.
    /// This member is required.
    public var apnsSandboxChannelResponse: PinpointClientTypes.APNSSandboxChannelResponse?

    public init(
        apnsSandboxChannelResponse: PinpointClientTypes.APNSSandboxChannelResponse? = nil
    )
    {
        self.apnsSandboxChannelResponse = apnsSandboxChannelResponse
    }
}

public struct GetApnsVoipChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetApnsVoipChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.
    /// This member is required.
    public var apnsVoipChannelResponse: PinpointClientTypes.APNSVoipChannelResponse?

    public init(
        apnsVoipChannelResponse: PinpointClientTypes.APNSVoipChannelResponse? = nil
    )
    {
        self.apnsVoipChannelResponse = apnsVoipChannelResponse
    }
}

public struct GetApnsVoipSandboxChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetApnsVoipSandboxChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.
    /// This member is required.
    public var apnsVoipSandboxChannelResponse: PinpointClientTypes.APNSVoipSandboxChannelResponse?

    public init(
        apnsVoipSandboxChannelResponse: PinpointClientTypes.APNSVoipSandboxChannelResponse? = nil
    )
    {
        self.apnsVoipSandboxChannelResponse = apnsVoipSandboxChannelResponse
    }
}

public struct GetAppInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetAppOutput: Swift.Sendable {
    /// Provides information about an application.
    /// This member is required.
    public var applicationResponse: PinpointClientTypes.ApplicationResponse?

    public init(
        applicationResponse: PinpointClientTypes.ApplicationResponse? = nil
    )
    {
        self.applicationResponse = applicationResponse
    }
}

public struct GetApplicationDateRangeKpiInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The last date and time to retrieve data for, as part of an inclusive date range that filters the query results. This value should be in extended ISO 8601 format and use Coordinated Universal Time (UTC), for example: 2019-07-26T20:00:00Z for 8:00 PM UTC July 26, 2019.
    public var endTime: Foundation.Date?
    /// The name of the metric, also referred to as a key performance indicator (KPI), to retrieve data for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. Examples are email-open-rate and successful-delivery-rate. For a list of valid values, see the [Amazon Pinpoint Developer Guide](https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html).
    /// This member is required.
    public var kpiName: Swift.String?
    /// The string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var nextToken: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The first date and time to retrieve data for, as part of an inclusive date range that filters the query results. This value should be in extended ISO 8601 format and use Coordinated Universal Time (UTC), for example: 2019-07-19T20:00:00Z for 8:00 PM UTC July 19, 2019. This value should also be fewer than 90 days from the current day.
    public var startTime: Foundation.Date?

    public init(
        applicationId: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        kpiName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.endTime = endTime
        self.kpiName = kpiName
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.startTime = startTime
    }
}

public struct GetApplicationDateRangeKpiOutput: Swift.Sendable {
    /// Provides the results of a query that retrieved the data for a standard metric that applies to an application, and provides information about that query.
    /// This member is required.
    public var applicationDateRangeKpiResponse: PinpointClientTypes.ApplicationDateRangeKpiResponse?

    public init(
        applicationDateRangeKpiResponse: PinpointClientTypes.ApplicationDateRangeKpiResponse? = nil
    )
    {
        self.applicationDateRangeKpiResponse = applicationDateRangeKpiResponse
    }
}

public struct GetApplicationSettingsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetApplicationSettingsOutput: Swift.Sendable {
    /// Provides information about an application, including the default settings for an application.
    /// This member is required.
    public var applicationSettingsResource: PinpointClientTypes.ApplicationSettingsResource?

    public init(
        applicationSettingsResource: PinpointClientTypes.ApplicationSettingsResource? = nil
    )
    {
        self.applicationSettingsResource = applicationSettingsResource
    }
}

public struct GetAppsInput: Swift.Sendable {
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The NextToken string that specifies which page of results to return in a paginated response.
    public var token: Swift.String?

    public init(
        pageSize: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.pageSize = pageSize
        self.token = token
    }
}

public struct GetAppsOutput: Swift.Sendable {
    /// Provides information about all of your applications.
    /// This member is required.
    public var applicationsResponse: PinpointClientTypes.ApplicationsResponse?

    public init(
        applicationsResponse: PinpointClientTypes.ApplicationsResponse? = nil
    )
    {
        self.applicationsResponse = applicationsResponse
    }
}

public struct GetBaiduChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetBaiduChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the Baidu (Baidu Cloud Push) channel for an application.
    /// This member is required.
    public var baiduChannelResponse: PinpointClientTypes.BaiduChannelResponse?

    public init(
        baiduChannelResponse: PinpointClientTypes.BaiduChannelResponse? = nil
    )
    {
        self.baiduChannelResponse = baiduChannelResponse
    }
}

public struct GetCampaignInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the campaign.
    /// This member is required.
    public var campaignId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        campaignId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
    }
}

public struct GetCampaignOutput: Swift.Sendable {
    /// Provides information about the status, configuration, and other settings for a campaign.
    /// This member is required.
    public var campaignResponse: PinpointClientTypes.CampaignResponse?

    public init(
        campaignResponse: PinpointClientTypes.CampaignResponse? = nil
    )
    {
        self.campaignResponse = campaignResponse
    }
}

public struct GetCampaignActivitiesInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the campaign.
    /// This member is required.
    public var campaignId: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The NextToken string that specifies which page of results to return in a paginated response.
    public var token: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        campaignId: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
        self.pageSize = pageSize
        self.token = token
    }
}

public struct GetCampaignActivitiesOutput: Swift.Sendable {
    /// Provides information about the activities that were performed by a campaign.
    /// This member is required.
    public var activitiesResponse: PinpointClientTypes.ActivitiesResponse?

    public init(
        activitiesResponse: PinpointClientTypes.ActivitiesResponse? = nil
    )
    {
        self.activitiesResponse = activitiesResponse
    }
}

public struct GetCampaignDateRangeKpiInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the campaign.
    /// This member is required.
    public var campaignId: Swift.String?
    /// The last date and time to retrieve data for, as part of an inclusive date range that filters the query results. This value should be in extended ISO 8601 format and use Coordinated Universal Time (UTC), for example: 2019-07-26T20:00:00Z for 8:00 PM UTC July 26, 2019.
    public var endTime: Foundation.Date?
    /// The name of the metric, also referred to as a key performance indicator (KPI), to retrieve data for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. Examples are email-open-rate and successful-delivery-rate. For a list of valid values, see the [Amazon Pinpoint Developer Guide](https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html).
    /// This member is required.
    public var kpiName: Swift.String?
    /// The string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var nextToken: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The first date and time to retrieve data for, as part of an inclusive date range that filters the query results. This value should be in extended ISO 8601 format and use Coordinated Universal Time (UTC), for example: 2019-07-19T20:00:00Z for 8:00 PM UTC July 19, 2019. This value should also be fewer than 90 days from the current day.
    public var startTime: Foundation.Date?

    public init(
        applicationId: Swift.String? = nil,
        campaignId: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        kpiName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
        self.endTime = endTime
        self.kpiName = kpiName
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.startTime = startTime
    }
}

public struct GetCampaignDateRangeKpiOutput: Swift.Sendable {
    /// Provides the results of a query that retrieved the data for a standard metric that applies to a campaign, and provides information about that query.
    /// This member is required.
    public var campaignDateRangeKpiResponse: PinpointClientTypes.CampaignDateRangeKpiResponse?

    public init(
        campaignDateRangeKpiResponse: PinpointClientTypes.CampaignDateRangeKpiResponse? = nil
    )
    {
        self.campaignDateRangeKpiResponse = campaignDateRangeKpiResponse
    }
}

public struct GetCampaignsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The NextToken string that specifies which page of results to return in a paginated response.
    public var token: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.token = token
    }
}

public struct GetCampaignsOutput: Swift.Sendable {
    /// Provides information about the configuration and other settings for all the campaigns that are associated with an application.
    /// This member is required.
    public var campaignsResponse: PinpointClientTypes.CampaignsResponse?

    public init(
        campaignsResponse: PinpointClientTypes.CampaignsResponse? = nil
    )
    {
        self.campaignsResponse = campaignsResponse
    }
}

public struct GetCampaignVersionInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the campaign.
    /// This member is required.
    public var campaignId: Swift.String?
    /// The unique version number (Version property) for the campaign version.
    /// This member is required.
    public var version: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        campaignId: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
        self.version = version
    }
}

public struct GetCampaignVersionOutput: Swift.Sendable {
    /// Provides information about the status, configuration, and other settings for a campaign.
    /// This member is required.
    public var campaignResponse: PinpointClientTypes.CampaignResponse?

    public init(
        campaignResponse: PinpointClientTypes.CampaignResponse? = nil
    )
    {
        self.campaignResponse = campaignResponse
    }
}

public struct GetCampaignVersionsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the campaign.
    /// This member is required.
    public var campaignId: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The NextToken string that specifies which page of results to return in a paginated response.
    public var token: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        campaignId: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
        self.pageSize = pageSize
        self.token = token
    }
}

public struct GetCampaignVersionsOutput: Swift.Sendable {
    /// Provides information about the configuration and other settings for all the campaigns that are associated with an application.
    /// This member is required.
    public var campaignsResponse: PinpointClientTypes.CampaignsResponse?

    public init(
        campaignsResponse: PinpointClientTypes.CampaignsResponse? = nil
    )
    {
        self.campaignsResponse = campaignsResponse
    }
}

public struct GetChannelsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetChannelsOutput: Swift.Sendable {
    /// Provides information about the general settings and status of all channels for an application, including channels that aren't enabled for the application.
    /// This member is required.
    public var channelsResponse: PinpointClientTypes.ChannelsResponse?

    public init(
        channelsResponse: PinpointClientTypes.ChannelsResponse? = nil
    )
    {
        self.channelsResponse = channelsResponse
    }
}

public struct GetEmailChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetEmailChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the email channel for an application.
    /// This member is required.
    public var emailChannelResponse: PinpointClientTypes.EmailChannelResponse?

    public init(
        emailChannelResponse: PinpointClientTypes.EmailChannelResponse? = nil
    )
    {
        self.emailChannelResponse = emailChannelResponse
    }
}

public struct GetEmailTemplateInput: Swift.Sendable {
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

public struct GetEmailTemplateOutput: Swift.Sendable {
    /// Provides information about the content and settings for a message template that can be used in messages that are sent through the email channel.
    /// This member is required.
    public var emailTemplateResponse: PinpointClientTypes.EmailTemplateResponse?

    public init(
        emailTemplateResponse: PinpointClientTypes.EmailTemplateResponse? = nil
    )
    {
        self.emailTemplateResponse = emailTemplateResponse
    }
}

public struct GetEndpointInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The case insensitive unique identifier for the endpoint. The identifier can't contain $, { or }.
    /// This member is required.
    public var endpointId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.endpointId = endpointId
    }
}

public struct GetEndpointOutput: Swift.Sendable {
    /// Provides information about the channel type and other settings for an endpoint.
    /// This member is required.
    public var endpointResponse: PinpointClientTypes.EndpointResponse?

    public init(
        endpointResponse: PinpointClientTypes.EndpointResponse? = nil
    )
    {
        self.endpointResponse = endpointResponse
    }
}

public struct GetEventStreamInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetEventStreamOutput: Swift.Sendable {
    /// Specifies settings for publishing event data to an Amazon Kinesis data stream or an Amazon Kinesis Data Firehose delivery stream.
    /// This member is required.
    public var eventStream: PinpointClientTypes.EventStream?

    public init(
        eventStream: PinpointClientTypes.EventStream? = nil
    )
    {
        self.eventStream = eventStream
    }
}

public struct GetExportJobInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.jobId = jobId
    }
}

public struct GetExportJobOutput: Swift.Sendable {
    /// Provides information about the status and settings of a job that exports endpoint definitions to a file. The file can be added directly to an Amazon Simple Storage Service (Amazon S3) bucket by using the Amazon Pinpoint API or downloaded directly to a computer by using the Amazon Pinpoint console.
    /// This member is required.
    public var exportJobResponse: PinpointClientTypes.ExportJobResponse?

    public init(
        exportJobResponse: PinpointClientTypes.ExportJobResponse? = nil
    )
    {
        self.exportJobResponse = exportJobResponse
    }
}

public struct GetExportJobsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The NextToken string that specifies which page of results to return in a paginated response.
    public var token: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.token = token
    }
}

public struct GetExportJobsOutput: Swift.Sendable {
    /// Provides information about all the export jobs that are associated with an application or segment. An export job is a job that exports endpoint definitions to a file.
    /// This member is required.
    public var exportJobsResponse: PinpointClientTypes.ExportJobsResponse?

    public init(
        exportJobsResponse: PinpointClientTypes.ExportJobsResponse? = nil
    )
    {
        self.exportJobsResponse = exportJobsResponse
    }
}

public struct GetGcmChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetGcmChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the GCM channel for an application. The GCM channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.
    /// This member is required.
    public var gcmChannelResponse: PinpointClientTypes.GCMChannelResponse?

    public init(
        gcmChannelResponse: PinpointClientTypes.GCMChannelResponse? = nil
    )
    {
        self.gcmChannelResponse = gcmChannelResponse
    }
}

public struct GetImportJobInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.jobId = jobId
    }
}

public struct GetImportJobOutput: Swift.Sendable {
    /// Provides information about the status and settings of a job that imports endpoint definitions from one or more files. The files can be stored in an Amazon Simple Storage Service (Amazon S3) bucket or uploaded directly from a computer by using the Amazon Pinpoint console.
    /// This member is required.
    public var importJobResponse: PinpointClientTypes.ImportJobResponse?

    public init(
        importJobResponse: PinpointClientTypes.ImportJobResponse? = nil
    )
    {
        self.importJobResponse = importJobResponse
    }
}

public struct GetImportJobsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The NextToken string that specifies which page of results to return in a paginated response.
    public var token: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.token = token
    }
}

extension PinpointClientTypes {

    /// Provides information about the status and settings of all the import jobs that are associated with an application or segment. An import job is a job that imports endpoint definitions from one or more files.
    public struct ImportJobsResponse: Swift.Sendable {
        /// An array of responses, one for each import job that's associated with the application (Import Jobs resource) or segment (Segment Import Jobs resource).
        /// This member is required.
        public var item: [PinpointClientTypes.ImportJobResponse]?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public var nextToken: Swift.String?

        public init(
            item: [PinpointClientTypes.ImportJobResponse]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.item = item
            self.nextToken = nextToken
        }
    }
}

public struct GetImportJobsOutput: Swift.Sendable {
    /// Provides information about the status and settings of all the import jobs that are associated with an application or segment. An import job is a job that imports endpoint definitions from one or more files.
    /// This member is required.
    public var importJobsResponse: PinpointClientTypes.ImportJobsResponse?

    public init(
        importJobsResponse: PinpointClientTypes.ImportJobsResponse? = nil
    )
    {
        self.importJobsResponse = importJobsResponse
    }
}

public struct GetInAppMessagesInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the endpoint.
    /// This member is required.
    public var endpointId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.endpointId = endpointId
    }
}

extension PinpointClientTypes {

    /// Provides all fields required for building an in-app message.
    public struct InAppMessage: Swift.Sendable {
        /// In-app message content.
        public var content: [PinpointClientTypes.InAppMessageContent]?
        /// Custom config to be sent to SDK.
        public var customConfig: [Swift.String: Swift.String]?
        /// The layout of the message.
        public var layout: PinpointClientTypes.Layout?

        public init(
            content: [PinpointClientTypes.InAppMessageContent]? = nil,
            customConfig: [Swift.String: Swift.String]? = nil,
            layout: PinpointClientTypes.Layout? = nil
        )
        {
            self.content = content
            self.customConfig = customConfig
            self.layout = layout
        }
    }
}

extension PinpointClientTypes {

    /// Schedule of the campaign.
    public struct InAppCampaignSchedule: Swift.Sendable {
        /// The scheduled time after which the in-app message should not be shown. Timestamp is in ISO 8601 format.
        public var endDate: Swift.String?
        /// The event filter the SDK has to use to show the in-app message in the application.
        public var eventFilter: PinpointClientTypes.CampaignEventFilter?
        /// Time during which the in-app message should not be shown to the user.
        public var quietTime: PinpointClientTypes.QuietTime?

        public init(
            endDate: Swift.String? = nil,
            eventFilter: PinpointClientTypes.CampaignEventFilter? = nil,
            quietTime: PinpointClientTypes.QuietTime? = nil
        )
        {
            self.endDate = endDate
            self.eventFilter = eventFilter
            self.quietTime = quietTime
        }
    }
}

extension PinpointClientTypes {

    /// Targeted in-app message campaign.
    public struct InAppMessageCampaign: Swift.Sendable {
        /// Campaign id of the corresponding campaign.
        public var campaignId: Swift.String?
        /// Daily cap which controls the number of times any in-app messages can be shown to the endpoint during a day.
        public var dailyCap: Swift.Int?
        /// In-app message content with all fields required for rendering an in-app message.
        public var inAppMessage: PinpointClientTypes.InAppMessage?
        /// Priority of the in-app message.
        public var priority: Swift.Int?
        /// Schedule of the campaign.
        public var schedule: PinpointClientTypes.InAppCampaignSchedule?
        /// Session cap which controls the number of times an in-app message can be shown to the endpoint during an application session.
        public var sessionCap: Swift.Int?
        /// Total cap which controls the number of times an in-app message can be shown to the endpoint.
        public var totalCap: Swift.Int?
        /// Treatment id of the campaign.
        public var treatmentId: Swift.String?

        public init(
            campaignId: Swift.String? = nil,
            dailyCap: Swift.Int? = nil,
            inAppMessage: PinpointClientTypes.InAppMessage? = nil,
            priority: Swift.Int? = nil,
            schedule: PinpointClientTypes.InAppCampaignSchedule? = nil,
            sessionCap: Swift.Int? = nil,
            totalCap: Swift.Int? = nil,
            treatmentId: Swift.String? = nil
        )
        {
            self.campaignId = campaignId
            self.dailyCap = dailyCap
            self.inAppMessage = inAppMessage
            self.priority = priority
            self.schedule = schedule
            self.sessionCap = sessionCap
            self.totalCap = totalCap
            self.treatmentId = treatmentId
        }
    }
}

extension PinpointClientTypes {

    /// Get in-app messages response object.
    public struct InAppMessagesResponse: Swift.Sendable {
        /// List of targeted in-app message campaigns.
        public var inAppMessageCampaigns: [PinpointClientTypes.InAppMessageCampaign]?

        public init(
            inAppMessageCampaigns: [PinpointClientTypes.InAppMessageCampaign]? = nil
        )
        {
            self.inAppMessageCampaigns = inAppMessageCampaigns
        }
    }
}

public struct GetInAppMessagesOutput: Swift.Sendable {
    /// Get in-app messages response object.
    /// This member is required.
    public var inAppMessagesResponse: PinpointClientTypes.InAppMessagesResponse?

    public init(
        inAppMessagesResponse: PinpointClientTypes.InAppMessagesResponse? = nil
    )
    {
        self.inAppMessagesResponse = inAppMessagesResponse
    }
}

public struct GetInAppTemplateInput: Swift.Sendable {
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

extension PinpointClientTypes {

    /// In-App Template Response.
    public struct InAppTemplateResponse: Swift.Sendable {
        /// The resource arn of the template.
        public var arn: Swift.String?
        /// The content of the message, can include up to 5 modals. Each modal must contain a message, a header, and background color. ImageUrl and buttons are optional.
        public var content: [PinpointClientTypes.InAppMessageContent]?
        /// The creation date of the template.
        /// This member is required.
        public var creationDate: Swift.String?
        /// Custom config to be sent to client.
        public var customConfig: [Swift.String: Swift.String]?
        /// The last modified date of the template.
        /// This member is required.
        public var lastModifiedDate: Swift.String?
        /// The layout of the message.
        public var layout: PinpointClientTypes.Layout?
        /// A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?
        /// The description of the template.
        public var templateDescription: Swift.String?
        /// The name of the template.
        /// This member is required.
        public var templateName: Swift.String?
        /// The type of the template.
        /// This member is required.
        public var templateType: PinpointClientTypes.TemplateType?
        /// The version id of the template.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            content: [PinpointClientTypes.InAppMessageContent]? = nil,
            creationDate: Swift.String? = nil,
            customConfig: [Swift.String: Swift.String]? = nil,
            lastModifiedDate: Swift.String? = nil,
            layout: PinpointClientTypes.Layout? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateDescription: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateType: PinpointClientTypes.TemplateType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.content = content
            self.creationDate = creationDate
            self.customConfig = customConfig
            self.lastModifiedDate = lastModifiedDate
            self.layout = layout
            self.tags = tags
            self.templateDescription = templateDescription
            self.templateName = templateName
            self.templateType = templateType
            self.version = version
        }
    }
}

public struct GetInAppTemplateOutput: Swift.Sendable {
    /// In-App Template Response.
    /// This member is required.
    public var inAppTemplateResponse: PinpointClientTypes.InAppTemplateResponse?

    public init(
        inAppTemplateResponse: PinpointClientTypes.InAppTemplateResponse? = nil
    )
    {
        self.inAppTemplateResponse = inAppTemplateResponse
    }
}

public struct GetJourneyInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the journey.
    /// This member is required.
    public var journeyId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        journeyId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyId = journeyId
    }
}

public struct GetJourneyOutput: Swift.Sendable {
    /// Provides information about the status, configuration, and other settings for a journey.
    /// This member is required.
    public var journeyResponse: PinpointClientTypes.JourneyResponse?

    public init(
        journeyResponse: PinpointClientTypes.JourneyResponse? = nil
    )
    {
        self.journeyResponse = journeyResponse
    }
}

public struct GetJourneyDateRangeKpiInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The last date and time to retrieve data for, as part of an inclusive date range that filters the query results. This value should be in extended ISO 8601 format and use Coordinated Universal Time (UTC), for example: 2019-07-26T20:00:00Z for 8:00 PM UTC July 26, 2019.
    public var endTime: Foundation.Date?
    /// The unique identifier for the journey.
    /// This member is required.
    public var journeyId: Swift.String?
    /// The name of the metric, also referred to as a key performance indicator (KPI), to retrieve data for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. Examples are email-open-rate and successful-delivery-rate. For a list of valid values, see the [Amazon Pinpoint Developer Guide](https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html).
    /// This member is required.
    public var kpiName: Swift.String?
    /// The string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var nextToken: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The first date and time to retrieve data for, as part of an inclusive date range that filters the query results. This value should be in extended ISO 8601 format and use Coordinated Universal Time (UTC), for example: 2019-07-19T20:00:00Z for 8:00 PM UTC July 19, 2019. This value should also be fewer than 90 days from the current day.
    public var startTime: Foundation.Date?

    public init(
        applicationId: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        journeyId: Swift.String? = nil,
        kpiName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.endTime = endTime
        self.journeyId = journeyId
        self.kpiName = kpiName
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.startTime = startTime
    }
}

extension PinpointClientTypes {

    /// Provides the results of a query that retrieved the data for a standard engagement metric that applies to a journey, and provides information about that query.
    public struct JourneyDateRangeKpiResponse: Swift.Sendable {
        /// The unique identifier for the application that the metric applies to.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// The unique identifier for the journey that the metric applies to.
        /// This member is required.
        public var journeyId: Swift.String?
        /// The name of the metric, also referred to as a key performance indicator (KPI), that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the [Amazon Pinpoint Developer Guide](https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html).
        /// This member is required.
        public var kpiName: Swift.String?
        /// An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.
        /// This member is required.
        public var kpiResult: PinpointClientTypes.BaseKpiResult?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Journey Engagement Metrics resource because the resource returns all results in a single page.
        public var nextToken: Swift.String?
        /// The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            applicationId: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            journeyId: Swift.String? = nil,
            kpiName: Swift.String? = nil,
            kpiResult: PinpointClientTypes.BaseKpiResult? = nil,
            nextToken: Swift.String? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.applicationId = applicationId
            self.endTime = endTime
            self.journeyId = journeyId
            self.kpiName = kpiName
            self.kpiResult = kpiResult
            self.nextToken = nextToken
            self.startTime = startTime
        }
    }
}

public struct GetJourneyDateRangeKpiOutput: Swift.Sendable {
    /// Provides the results of a query that retrieved the data for a standard engagement metric that applies to a journey, and provides information about that query.
    /// This member is required.
    public var journeyDateRangeKpiResponse: PinpointClientTypes.JourneyDateRangeKpiResponse?

    public init(
        journeyDateRangeKpiResponse: PinpointClientTypes.JourneyDateRangeKpiResponse? = nil
    )
    {
        self.journeyDateRangeKpiResponse = journeyDateRangeKpiResponse
    }
}

public struct GetJourneyExecutionActivityMetricsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the journey activity.
    /// This member is required.
    public var journeyActivityId: Swift.String?
    /// The unique identifier for the journey.
    /// This member is required.
    public var journeyId: Swift.String?
    /// The  string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var nextToken: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        journeyActivityId: Swift.String? = nil,
        journeyId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pageSize: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyActivityId = journeyActivityId
        self.journeyId = journeyId
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

extension PinpointClientTypes {

    /// Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey activity, and provides information about that query.
    public struct JourneyExecutionActivityMetricsResponse: Swift.Sendable {
        /// The type of activity that the metric applies to. Possible values are:
        ///
        /// * CONDITIONAL_SPLIT – For a yes/no split activity, which is an activity that sends participants down one of two paths in a journey.
        ///
        /// * HOLDOUT – For a holdout activity, which is an activity that stops a journey for a specified percentage of participants.
        ///
        /// * MESSAGE – For an email activity, which is an activity that sends an email message to participants.
        ///
        /// * MULTI_CONDITIONAL_SPLIT – For a multivariate split activity, which is an activity that sends participants down one of as many as five paths in a journey.
        ///
        /// * RANDOM_SPLIT – For a random split activity, which is an activity that sends specified percentages of participants down one of as many as five paths in a journey.
        ///
        /// * WAIT – For a wait activity, which is an activity that waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.
        /// This member is required.
        public var activityType: Swift.String?
        /// The unique identifier for the application that the metric applies to.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The unique identifier for the activity that the metric applies to.
        /// This member is required.
        public var journeyActivityId: Swift.String?
        /// The unique identifier for the journey that the metric applies to.
        /// This member is required.
        public var journeyId: Swift.String?
        /// The date and time, in ISO 8601 format, when Amazon Pinpoint last evaluated the execution status of the activity and updated the data for the metric.
        /// This member is required.
        public var lastEvaluatedTime: Swift.String?
        /// A JSON object that contains the results of the query. The results vary depending on the type of activity (ActivityType). For information about the structure and contents of the results, see the [Amazon Pinpoint Developer Guide](https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html).
        /// This member is required.
        public var metrics: [Swift.String: Swift.String]?

        public init(
            activityType: Swift.String? = nil,
            applicationId: Swift.String? = nil,
            journeyActivityId: Swift.String? = nil,
            journeyId: Swift.String? = nil,
            lastEvaluatedTime: Swift.String? = nil,
            metrics: [Swift.String: Swift.String]? = nil
        )
        {
            self.activityType = activityType
            self.applicationId = applicationId
            self.journeyActivityId = journeyActivityId
            self.journeyId = journeyId
            self.lastEvaluatedTime = lastEvaluatedTime
            self.metrics = metrics
        }
    }
}

public struct GetJourneyExecutionActivityMetricsOutput: Swift.Sendable {
    /// Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey activity, and provides information about that query.
    /// This member is required.
    public var journeyExecutionActivityMetricsResponse: PinpointClientTypes.JourneyExecutionActivityMetricsResponse?

    public init(
        journeyExecutionActivityMetricsResponse: PinpointClientTypes.JourneyExecutionActivityMetricsResponse? = nil
    )
    {
        self.journeyExecutionActivityMetricsResponse = journeyExecutionActivityMetricsResponse
    }
}

public struct GetJourneyExecutionMetricsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the journey.
    /// This member is required.
    public var journeyId: Swift.String?
    /// The  string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var nextToken: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        journeyId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pageSize: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyId = journeyId
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

extension PinpointClientTypes {

    /// Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey, and provides information about that query.
    public struct JourneyExecutionMetricsResponse: Swift.Sendable {
        /// The unique identifier for the application that the metric applies to.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The unique identifier for the journey that the metric applies to.
        /// This member is required.
        public var journeyId: Swift.String?
        /// The date and time, in ISO 8601 format, when Amazon Pinpoint last evaluated the journey and updated the data for the metric.
        /// This member is required.
        public var lastEvaluatedTime: Swift.String?
        /// A JSON object that contains the results of the query. For information about the structure and contents of the results, see the [Amazon Pinpoint Developer Guide](https://docs.aws.amazon.com//pinpoint/latest/developerguide/analytics-standard-metrics.html).
        /// This member is required.
        public var metrics: [Swift.String: Swift.String]?

        public init(
            applicationId: Swift.String? = nil,
            journeyId: Swift.String? = nil,
            lastEvaluatedTime: Swift.String? = nil,
            metrics: [Swift.String: Swift.String]? = nil
        )
        {
            self.applicationId = applicationId
            self.journeyId = journeyId
            self.lastEvaluatedTime = lastEvaluatedTime
            self.metrics = metrics
        }
    }
}

public struct GetJourneyExecutionMetricsOutput: Swift.Sendable {
    /// Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey, and provides information about that query.
    /// This member is required.
    public var journeyExecutionMetricsResponse: PinpointClientTypes.JourneyExecutionMetricsResponse?

    public init(
        journeyExecutionMetricsResponse: PinpointClientTypes.JourneyExecutionMetricsResponse? = nil
    )
    {
        self.journeyExecutionMetricsResponse = journeyExecutionMetricsResponse
    }
}

public struct GetJourneyRunExecutionActivityMetricsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the journey activity.
    /// This member is required.
    public var journeyActivityId: Swift.String?
    /// The unique identifier for the journey.
    /// This member is required.
    public var journeyId: Swift.String?
    /// The  string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var nextToken: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The unique identifier for the journey run.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        journeyActivityId: Swift.String? = nil,
        journeyId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        runId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyActivityId = journeyActivityId
        self.journeyId = journeyId
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.runId = runId
    }
}

extension PinpointClientTypes {

    /// Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey activity for a particular journey run, and provides information about that query.
    public struct JourneyRunExecutionActivityMetricsResponse: Swift.Sendable {
        /// The type of activity that the metric applies to. Possible values are:
        ///
        /// * CONDITIONAL_SPLIT – For a yes/no split activity, which is an activity that sends participants down one of two paths in a journey.
        ///
        /// * HOLDOUT – For a holdout activity, which is an activity that stops a journey for a specified percentage of participants.
        ///
        /// * MESSAGE – For an email activity, which is an activity that sends an email message to participants.
        ///
        /// * MULTI_CONDITIONAL_SPLIT – For a multivariate split activity, which is an activity that sends participants down one of as many as five paths in a journey.
        ///
        /// * RANDOM_SPLIT – For a random split activity, which is an activity that sends specified percentages of participants down one of as many as five paths in a journey.
        ///
        /// * WAIT – For a wait activity, which is an activity that waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.
        /// This member is required.
        public var activityType: Swift.String?
        /// The unique identifier for the application that the metric applies to.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The unique identifier for the activity that the metric applies to.
        /// This member is required.
        public var journeyActivityId: Swift.String?
        /// The unique identifier for the journey that the metric applies to.
        /// This member is required.
        public var journeyId: Swift.String?
        /// The date and time, in ISO 8601 format, when Amazon Pinpoint last evaluated the execution status of the activity for this journey run and updated the data for the metric.
        /// This member is required.
        public var lastEvaluatedTime: Swift.String?
        /// A JSON object that contains the results of the query. For information about the structure and contents of the results, see see [Standard Amazon Pinpoint analytics metrics](https://docs.aws.amazon.com//pinpoint/latest/developerguide/analytics-standard-metrics.html) in the Amazon Pinpoint Developer Guide.
        /// This member is required.
        public var metrics: [Swift.String: Swift.String]?
        /// The unique identifier for the journey run that the metric applies to.
        /// This member is required.
        public var runId: Swift.String?

        public init(
            activityType: Swift.String? = nil,
            applicationId: Swift.String? = nil,
            journeyActivityId: Swift.String? = nil,
            journeyId: Swift.String? = nil,
            lastEvaluatedTime: Swift.String? = nil,
            metrics: [Swift.String: Swift.String]? = nil,
            runId: Swift.String? = nil
        )
        {
            self.activityType = activityType
            self.applicationId = applicationId
            self.journeyActivityId = journeyActivityId
            self.journeyId = journeyId
            self.lastEvaluatedTime = lastEvaluatedTime
            self.metrics = metrics
            self.runId = runId
        }
    }
}

public struct GetJourneyRunExecutionActivityMetricsOutput: Swift.Sendable {
    /// Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey activity for a particular journey run, and provides information about that query.
    /// This member is required.
    public var journeyRunExecutionActivityMetricsResponse: PinpointClientTypes.JourneyRunExecutionActivityMetricsResponse?

    public init(
        journeyRunExecutionActivityMetricsResponse: PinpointClientTypes.JourneyRunExecutionActivityMetricsResponse? = nil
    )
    {
        self.journeyRunExecutionActivityMetricsResponse = journeyRunExecutionActivityMetricsResponse
    }
}

public struct GetJourneyRunExecutionMetricsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the journey.
    /// This member is required.
    public var journeyId: Swift.String?
    /// The  string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var nextToken: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The unique identifier for the journey run.
    /// This member is required.
    public var runId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        journeyId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        runId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyId = journeyId
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.runId = runId
    }
}

extension PinpointClientTypes {

    /// Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey run, and provides information about that query.
    public struct JourneyRunExecutionMetricsResponse: Swift.Sendable {
        /// The unique identifier for the application that the metric applies to.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The unique identifier for the journey that the metric applies to.
        /// This member is required.
        public var journeyId: Swift.String?
        /// The date and time, in ISO 8601 format, when Amazon Pinpoint last evaluated the journey run and updated the data for the metric.
        /// This member is required.
        public var lastEvaluatedTime: Swift.String?
        /// A JSON object that contains the results of the query. For information about the structure and contents of the results, see the [Standard Amazon Pinpoint analytics metrics](https://docs.aws.amazon.com//pinpoint/latest/developerguide/analytics-standard-metrics.html) in the Amazon Pinpoint Developer Guide.
        /// This member is required.
        public var metrics: [Swift.String: Swift.String]?
        /// The unique identifier for the journey run that the metric applies to.
        /// This member is required.
        public var runId: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            journeyId: Swift.String? = nil,
            lastEvaluatedTime: Swift.String? = nil,
            metrics: [Swift.String: Swift.String]? = nil,
            runId: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.journeyId = journeyId
            self.lastEvaluatedTime = lastEvaluatedTime
            self.metrics = metrics
            self.runId = runId
        }
    }
}

public struct GetJourneyRunExecutionMetricsOutput: Swift.Sendable {
    /// Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey run, and provides information about that query.
    /// This member is required.
    public var journeyRunExecutionMetricsResponse: PinpointClientTypes.JourneyRunExecutionMetricsResponse?

    public init(
        journeyRunExecutionMetricsResponse: PinpointClientTypes.JourneyRunExecutionMetricsResponse? = nil
    )
    {
        self.journeyRunExecutionMetricsResponse = journeyRunExecutionMetricsResponse
    }
}

public struct GetJourneyRunsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the journey.
    /// This member is required.
    public var journeyId: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The NextToken string that specifies which page of results to return in a paginated response.
    public var token: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        journeyId: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyId = journeyId
        self.pageSize = pageSize
        self.token = token
    }
}

extension PinpointClientTypes {

    public enum JourneyRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case running
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [JourneyRunStatus] {
            return [
                .cancelled,
                .completed,
                .running,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .running: return "RUNNING"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointClientTypes {

    /// Provides information from a specified run of a journey.
    public struct JourneyRunResponse: Swift.Sendable {
        /// The time when the journey run was created or scheduled, in ISO 8601 format.
        /// This member is required.
        public var creationTime: Swift.String?
        /// The last time the journey run was updated, in ISO 8601 format..
        /// This member is required.
        public var lastUpdateTime: Swift.String?
        /// The unique identifier for the run.
        /// This member is required.
        public var runId: Swift.String?
        /// The current status of the journey run.
        /// This member is required.
        public var status: PinpointClientTypes.JourneyRunStatus?

        public init(
            creationTime: Swift.String? = nil,
            lastUpdateTime: Swift.String? = nil,
            runId: Swift.String? = nil,
            status: PinpointClientTypes.JourneyRunStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.runId = runId
            self.status = status
        }
    }
}

extension PinpointClientTypes {

    /// Provides information from all runs of a journey.
    public struct JourneyRunsResponse: Swift.Sendable {
        /// An array of responses, one for each run of the journey
        /// This member is required.
        public var item: [PinpointClientTypes.JourneyRunResponse]?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public var nextToken: Swift.String?

        public init(
            item: [PinpointClientTypes.JourneyRunResponse]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.item = item
            self.nextToken = nextToken
        }
    }
}

public struct GetJourneyRunsOutput: Swift.Sendable {
    /// Provides information from all runs of a journey.
    /// This member is required.
    public var journeyRunsResponse: PinpointClientTypes.JourneyRunsResponse?

    public init(
        journeyRunsResponse: PinpointClientTypes.JourneyRunsResponse? = nil
    )
    {
        self.journeyRunsResponse = journeyRunsResponse
    }
}

public struct GetPushTemplateInput: Swift.Sendable {
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

extension PinpointClientTypes {

    /// Provides information about the content and settings for a message template that can be used in messages that are sent through a push notification channel.
    public struct PushNotificationTemplateResponse: Swift.Sendable {
        /// The message template that's used for the ADM (Amazon Device Messaging) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).
        public var adm: PinpointClientTypes.AndroidPushNotificationTemplate?
        /// The message template that's used for the APNs (Apple Push Notification service) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).
        public var apns: PinpointClientTypes.APNSPushNotificationTemplate?
        /// The Amazon Resource Name (ARN) of the message template.
        public var arn: Swift.String?
        /// The message template that's used for the Baidu (Baidu Cloud Push) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).
        public var baidu: PinpointClientTypes.AndroidPushNotificationTemplate?
        /// The date, in ISO 8601 format, when the message template was created.
        /// This member is required.
        public var creationDate: Swift.String?
        /// The default message template that's used for push notification channels.
        public var `default`: PinpointClientTypes.DefaultPushNotificationTemplate?
        /// The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.
        public var defaultSubstitutions: Swift.String?
        /// The message template that's used for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).
        public var gcm: PinpointClientTypes.AndroidPushNotificationTemplate?
        /// The date, in ISO 8601 format, when the message template was last modified.
        /// This member is required.
        public var lastModifiedDate: Swift.String?
        /// The unique identifier for the recommender model that's used by the message template.
        public var recommenderId: Swift.String?
        /// A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?
        /// The custom description of the message template.
        public var templateDescription: Swift.String?
        /// The name of the message template.
        /// This member is required.
        public var templateName: Swift.String?
        /// The type of channel that the message template is designed for. For a push notification template, this value is PUSH.
        /// This member is required.
        public var templateType: PinpointClientTypes.TemplateType?
        /// The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.
        public var version: Swift.String?

        public init(
            adm: PinpointClientTypes.AndroidPushNotificationTemplate? = nil,
            apns: PinpointClientTypes.APNSPushNotificationTemplate? = nil,
            arn: Swift.String? = nil,
            baidu: PinpointClientTypes.AndroidPushNotificationTemplate? = nil,
            creationDate: Swift.String? = nil,
            `default`: PinpointClientTypes.DefaultPushNotificationTemplate? = nil,
            defaultSubstitutions: Swift.String? = nil,
            gcm: PinpointClientTypes.AndroidPushNotificationTemplate? = nil,
            lastModifiedDate: Swift.String? = nil,
            recommenderId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateDescription: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateType: PinpointClientTypes.TemplateType? = nil,
            version: Swift.String? = nil
        )
        {
            self.adm = adm
            self.apns = apns
            self.arn = arn
            self.baidu = baidu
            self.creationDate = creationDate
            self.`default` = `default`
            self.defaultSubstitutions = defaultSubstitutions
            self.gcm = gcm
            self.lastModifiedDate = lastModifiedDate
            self.recommenderId = recommenderId
            self.tags = tags
            self.templateDescription = templateDescription
            self.templateName = templateName
            self.templateType = templateType
            self.version = version
        }
    }
}

public struct GetPushTemplateOutput: Swift.Sendable {
    /// Provides information about the content and settings for a message template that can be used in messages that are sent through a push notification channel.
    /// This member is required.
    public var pushNotificationTemplateResponse: PinpointClientTypes.PushNotificationTemplateResponse?

    public init(
        pushNotificationTemplateResponse: PinpointClientTypes.PushNotificationTemplateResponse? = nil
    )
    {
        self.pushNotificationTemplateResponse = pushNotificationTemplateResponse
    }
}

public struct GetRecommenderConfigurationInput: Swift.Sendable {
    /// The unique identifier for the recommender model configuration. This identifier is displayed as the Recommender ID on the Amazon Pinpoint console.
    /// This member is required.
    public var recommenderId: Swift.String?

    public init(
        recommenderId: Swift.String? = nil
    )
    {
        self.recommenderId = recommenderId
    }
}

public struct GetRecommenderConfigurationOutput: Swift.Sendable {
    /// Provides information about Amazon Pinpoint configuration settings for retrieving and processing data from a recommender model.
    /// This member is required.
    public var recommenderConfigurationResponse: PinpointClientTypes.RecommenderConfigurationResponse?

    public init(
        recommenderConfigurationResponse: PinpointClientTypes.RecommenderConfigurationResponse? = nil
    )
    {
        self.recommenderConfigurationResponse = recommenderConfigurationResponse
    }
}

public struct GetRecommenderConfigurationsInput: Swift.Sendable {
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The NextToken string that specifies which page of results to return in a paginated response.
    public var token: Swift.String?

    public init(
        pageSize: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.pageSize = pageSize
        self.token = token
    }
}

extension PinpointClientTypes {

    /// Provides information about all the recommender model configurations that are associated with your Amazon Pinpoint account.
    public struct ListRecommenderConfigurationsResponse: Swift.Sendable {
        /// An array of responses, one for each recommender model configuration that's associated with your Amazon Pinpoint account.
        /// This member is required.
        public var item: [PinpointClientTypes.RecommenderConfigurationResponse]?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public var nextToken: Swift.String?

        public init(
            item: [PinpointClientTypes.RecommenderConfigurationResponse]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.item = item
            self.nextToken = nextToken
        }
    }
}

public struct GetRecommenderConfigurationsOutput: Swift.Sendable {
    /// Provides information about all the recommender model configurations that are associated with your Amazon Pinpoint account.
    /// This member is required.
    public var listRecommenderConfigurationsResponse: PinpointClientTypes.ListRecommenderConfigurationsResponse?

    public init(
        listRecommenderConfigurationsResponse: PinpointClientTypes.ListRecommenderConfigurationsResponse? = nil
    )
    {
        self.listRecommenderConfigurationsResponse = listRecommenderConfigurationsResponse
    }
}

public struct GetSegmentInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the segment.
    /// This member is required.
    public var segmentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        segmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.segmentId = segmentId
    }
}

public struct GetSegmentOutput: Swift.Sendable {
    /// Provides information about the configuration, dimension, and other settings for a segment.
    /// This member is required.
    public var segmentResponse: PinpointClientTypes.SegmentResponse?

    public init(
        segmentResponse: PinpointClientTypes.SegmentResponse? = nil
    )
    {
        self.segmentResponse = segmentResponse
    }
}

public struct GetSegmentExportJobsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The unique identifier for the segment.
    /// This member is required.
    public var segmentId: Swift.String?
    /// The NextToken string that specifies which page of results to return in a paginated response.
    public var token: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        segmentId: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.segmentId = segmentId
        self.token = token
    }
}

public struct GetSegmentExportJobsOutput: Swift.Sendable {
    /// Provides information about all the export jobs that are associated with an application or segment. An export job is a job that exports endpoint definitions to a file.
    /// This member is required.
    public var exportJobsResponse: PinpointClientTypes.ExportJobsResponse?

    public init(
        exportJobsResponse: PinpointClientTypes.ExportJobsResponse? = nil
    )
    {
        self.exportJobsResponse = exportJobsResponse
    }
}

public struct GetSegmentImportJobsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The unique identifier for the segment.
    /// This member is required.
    public var segmentId: Swift.String?
    /// The NextToken string that specifies which page of results to return in a paginated response.
    public var token: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        segmentId: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.segmentId = segmentId
        self.token = token
    }
}

public struct GetSegmentImportJobsOutput: Swift.Sendable {
    /// Provides information about the status and settings of all the import jobs that are associated with an application or segment. An import job is a job that imports endpoint definitions from one or more files.
    /// This member is required.
    public var importJobsResponse: PinpointClientTypes.ImportJobsResponse?

    public init(
        importJobsResponse: PinpointClientTypes.ImportJobsResponse? = nil
    )
    {
        self.importJobsResponse = importJobsResponse
    }
}

public struct GetSegmentsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The NextToken string that specifies which page of results to return in a paginated response.
    public var token: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.token = token
    }
}

extension PinpointClientTypes {

    /// Provides information about all the segments that are associated with an application.
    public struct SegmentsResponse: Swift.Sendable {
        /// An array of responses, one for each segment that's associated with the application (Segments resource) or each version of a segment that's associated with the application (Segment Versions resource).
        /// This member is required.
        public var item: [PinpointClientTypes.SegmentResponse]?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public var nextToken: Swift.String?

        public init(
            item: [PinpointClientTypes.SegmentResponse]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.item = item
            self.nextToken = nextToken
        }
    }
}

public struct GetSegmentsOutput: Swift.Sendable {
    /// Provides information about all the segments that are associated with an application.
    /// This member is required.
    public var segmentsResponse: PinpointClientTypes.SegmentsResponse?

    public init(
        segmentsResponse: PinpointClientTypes.SegmentsResponse? = nil
    )
    {
        self.segmentsResponse = segmentsResponse
    }
}

public struct GetSegmentVersionInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the segment.
    /// This member is required.
    public var segmentId: Swift.String?
    /// The unique version number (Version property) for the campaign version.
    /// This member is required.
    public var version: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        segmentId: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.segmentId = segmentId
        self.version = version
    }
}

public struct GetSegmentVersionOutput: Swift.Sendable {
    /// Provides information about the configuration, dimension, and other settings for a segment.
    /// This member is required.
    public var segmentResponse: PinpointClientTypes.SegmentResponse?

    public init(
        segmentResponse: PinpointClientTypes.SegmentResponse? = nil
    )
    {
        self.segmentResponse = segmentResponse
    }
}

public struct GetSegmentVersionsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The unique identifier for the segment.
    /// This member is required.
    public var segmentId: Swift.String?
    /// The NextToken string that specifies which page of results to return in a paginated response.
    public var token: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        segmentId: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.segmentId = segmentId
        self.token = token
    }
}

public struct GetSegmentVersionsOutput: Swift.Sendable {
    /// Provides information about all the segments that are associated with an application.
    /// This member is required.
    public var segmentsResponse: PinpointClientTypes.SegmentsResponse?

    public init(
        segmentsResponse: PinpointClientTypes.SegmentsResponse? = nil
    )
    {
        self.segmentsResponse = segmentsResponse
    }
}

public struct GetSmsChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetSmsChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the SMS channel for an application.
    /// This member is required.
    public var smsChannelResponse: PinpointClientTypes.SMSChannelResponse?

    public init(
        smsChannelResponse: PinpointClientTypes.SMSChannelResponse? = nil
    )
    {
        self.smsChannelResponse = smsChannelResponse
    }
}

public struct GetSmsTemplateInput: Swift.Sendable {
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

extension PinpointClientTypes {

    /// Provides information about the content and settings for a message template that can be used in text messages that are sent through the SMS channel.
    public struct SMSTemplateResponse: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the message template.
        public var arn: Swift.String?
        /// The message body that's used in text messages that are based on the message template.
        public var body: Swift.String?
        /// The date, in ISO 8601 format, when the message template was created.
        /// This member is required.
        public var creationDate: Swift.String?
        /// The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.
        public var defaultSubstitutions: Swift.String?
        /// The date, in ISO 8601 format, when the message template was last modified.
        /// This member is required.
        public var lastModifiedDate: Swift.String?
        /// The unique identifier for the recommender model that's used by the message template.
        public var recommenderId: Swift.String?
        /// A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?
        /// The custom description of the message template.
        public var templateDescription: Swift.String?
        /// The name of the message template.
        /// This member is required.
        public var templateName: Swift.String?
        /// The type of channel that the message template is designed for. For an SMS template, this value is SMS.
        /// This member is required.
        public var templateType: PinpointClientTypes.TemplateType?
        /// The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            body: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            defaultSubstitutions: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            recommenderId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateDescription: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateType: PinpointClientTypes.TemplateType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.body = body
            self.creationDate = creationDate
            self.defaultSubstitutions = defaultSubstitutions
            self.lastModifiedDate = lastModifiedDate
            self.recommenderId = recommenderId
            self.tags = tags
            self.templateDescription = templateDescription
            self.templateName = templateName
            self.templateType = templateType
            self.version = version
        }
    }
}

public struct GetSmsTemplateOutput: Swift.Sendable {
    /// Provides information about the content and settings for a message template that can be used in text messages that are sent through the SMS channel.
    /// This member is required.
    public var smsTemplateResponse: PinpointClientTypes.SMSTemplateResponse?

    public init(
        smsTemplateResponse: PinpointClientTypes.SMSTemplateResponse? = nil
    )
    {
        self.smsTemplateResponse = smsTemplateResponse
    }
}

public struct GetUserEndpointsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.userId = userId
    }
}

public struct GetUserEndpointsOutput: Swift.Sendable {
    /// Provides information about all the endpoints that are associated with a user ID.
    /// This member is required.
    public var endpointsResponse: PinpointClientTypes.EndpointsResponse?

    public init(
        endpointsResponse: PinpointClientTypes.EndpointsResponse? = nil
    )
    {
        self.endpointsResponse = endpointsResponse
    }
}

public struct GetVoiceChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetVoiceChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the voice channel for an application.
    /// This member is required.
    public var voiceChannelResponse: PinpointClientTypes.VoiceChannelResponse?

    public init(
        voiceChannelResponse: PinpointClientTypes.VoiceChannelResponse? = nil
    )
    {
        self.voiceChannelResponse = voiceChannelResponse
    }
}

public struct GetVoiceTemplateInput: Swift.Sendable {
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

extension PinpointClientTypes {

    /// Provides information about the content and settings for a message template that can be used in messages that are sent through the voice channel.
    public struct VoiceTemplateResponse: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the message template.
        public var arn: Swift.String?
        /// The text of the script that's used in messages that are based on the message template, in plain text format.
        public var body: Swift.String?
        /// The date, in ISO 8601 format, when the message template was created.
        /// This member is required.
        public var creationDate: Swift.String?
        /// The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.
        public var defaultSubstitutions: Swift.String?
        /// The code for the language that's used when synthesizing the text of the script in messages that are based on the message template. For a list of supported languages and the code for each one, see the [Amazon Polly Developer Guide](https://docs.aws.amazon.com/polly/latest/dg/what-is.html).
        public var languageCode: Swift.String?
        /// The date, in ISO 8601 format, when the message template was last modified.
        /// This member is required.
        public var lastModifiedDate: Swift.String?
        /// A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.
        public var tags: [Swift.String: Swift.String]?
        /// The custom description of the message template.
        public var templateDescription: Swift.String?
        /// The name of the message template.
        /// This member is required.
        public var templateName: Swift.String?
        /// The type of channel that the message template is designed for. For a voice template, this value is VOICE.
        /// This member is required.
        public var templateType: PinpointClientTypes.TemplateType?
        /// The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.
        public var version: Swift.String?
        /// The name of the voice that's used when delivering messages that are based on the message template. For a list of supported voices, see the [Amazon Polly Developer Guide](https://docs.aws.amazon.com/polly/latest/dg/what-is.html).
        public var voiceId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            body: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            defaultSubstitutions: Swift.String? = nil,
            languageCode: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateDescription: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateType: PinpointClientTypes.TemplateType? = nil,
            version: Swift.String? = nil,
            voiceId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.body = body
            self.creationDate = creationDate
            self.defaultSubstitutions = defaultSubstitutions
            self.languageCode = languageCode
            self.lastModifiedDate = lastModifiedDate
            self.tags = tags
            self.templateDescription = templateDescription
            self.templateName = templateName
            self.templateType = templateType
            self.version = version
            self.voiceId = voiceId
        }
    }
}

public struct GetVoiceTemplateOutput: Swift.Sendable {
    /// Provides information about the content and settings for a message template that can be used in messages that are sent through the voice channel.
    /// This member is required.
    public var voiceTemplateResponse: PinpointClientTypes.VoiceTemplateResponse?

    public init(
        voiceTemplateResponse: PinpointClientTypes.VoiceTemplateResponse? = nil
    )
    {
        self.voiceTemplateResponse = voiceTemplateResponse
    }
}

extension PinpointClientTypes {

    /// Provides information about the status, configuration, and other settings for all the journeys that are associated with an application.
    public struct JourneysResponse: Swift.Sendable {
        /// An array of responses, one for each journey that's associated with the application.
        /// This member is required.
        public var item: [PinpointClientTypes.JourneyResponse]?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public var nextToken: Swift.String?

        public init(
            item: [PinpointClientTypes.JourneyResponse]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.item = item
            self.nextToken = nextToken
        }
    }
}

extension PinpointClientTypes {

    /// Changes the status of a journey.
    public struct JourneyStateRequest: Swift.Sendable {
        /// The status of the journey. Currently, Supported values are ACTIVE, PAUSED, and CANCELLED If you cancel a journey, Amazon Pinpoint continues to perform activities that are currently in progress, until those activities are complete. Amazon Pinpoint also continues to collect and aggregate analytics data for those activities, until they are complete, and any activities that were complete when you cancelled the journey. After you cancel a journey, you can't add, change, or remove any activities from the journey. In addition, Amazon Pinpoint stops evaluating the journey and doesn't perform any activities that haven't started. When the journey is paused, Amazon Pinpoint continues to perform activities that are currently in progress, until those activities are complete. Endpoints will stop entering journeys when the journey is paused and will resume entering the journey after the journey is resumed. For wait activities, wait time is paused when the journey is paused. Currently, PAUSED only supports journeys with a segment refresh interval.
        public var state: PinpointClientTypes.State?

        public init(
            state: PinpointClientTypes.State? = nil
        )
        {
            self.state = state
        }
    }
}

public struct ListJourneysInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The NextToken string that specifies which page of results to return in a paginated response.
    public var token: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.token = token
    }
}

public struct ListJourneysOutput: Swift.Sendable {
    /// Provides information about the status, configuration, and other settings for all the journeys that are associated with an application.
    /// This member is required.
    public var journeysResponse: PinpointClientTypes.JourneysResponse?

    public init(
        journeysResponse: PinpointClientTypes.JourneysResponse? = nil
    )
    {
        self.journeysResponse = journeysResponse
    }
}

extension PinpointClientTypes {

    /// Provides information about a message template that's associated with your Amazon Pinpoint account.
    public struct TemplateResponse: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the message template. This value isn't included in a TemplateResponse object. To retrieve the ARN of a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the ARN for.
        public var arn: Swift.String?
        /// The date, in ISO 8601 format, when the message template was created.
        /// This member is required.
        public var creationDate: Swift.String?
        /// The JSON object that specifies the default values that are used for message variables in the message template. This object isn't included in a TemplateResponse object. To retrieve this object for a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the object for.
        public var defaultSubstitutions: Swift.String?
        /// The date, in ISO 8601 format, when the message template was last modified.
        /// This member is required.
        public var lastModifiedDate: Swift.String?
        /// A map of key-value pairs that identifies the tags that are associated with the message template. This object isn't included in a TemplateResponse object. To retrieve this object for a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the object for.
        public var tags: [Swift.String: Swift.String]?
        /// The custom description of the message template. This value isn't included in a TemplateResponse object. To retrieve the description of a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the description for.
        public var templateDescription: Swift.String?
        /// The name of the message template.
        /// This member is required.
        public var templateName: Swift.String?
        /// The type of channel that the message template is designed for. Possible values are: EMAIL, PUSH, SMS, INAPP, and VOICE.
        /// This member is required.
        public var templateType: PinpointClientTypes.TemplateType?
        /// The unique identifier, as an integer, for the active version of the message template.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationDate: Swift.String? = nil,
            defaultSubstitutions: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateDescription: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateType: PinpointClientTypes.TemplateType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationDate = creationDate
            self.defaultSubstitutions = defaultSubstitutions
            self.lastModifiedDate = lastModifiedDate
            self.tags = tags
            self.templateDescription = templateDescription
            self.templateName = templateName
            self.templateType = templateType
            self.version = version
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about a specific version of a message template.
    public struct TemplateVersionResponse: Swift.Sendable {
        /// The date, in ISO 8601 format, when the version of the message template was created.
        /// This member is required.
        public var creationDate: Swift.String?
        /// A JSON object that specifies the default values that are used for message variables in the version of the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.
        public var defaultSubstitutions: Swift.String?
        /// The date, in ISO 8601 format, when the version of the message template was last modified.
        /// This member is required.
        public var lastModifiedDate: Swift.String?
        /// The custom description of the version of the message template.
        public var templateDescription: Swift.String?
        /// The name of the message template.
        /// This member is required.
        public var templateName: Swift.String?
        /// The type of channel that the message template is designed for. Possible values are: EMAIL, PUSH, SMS, INAPP, and VOICE.
        /// This member is required.
        public var templateType: Swift.String?
        /// The unique identifier for the version of the message template. This value is an integer that Amazon Pinpoint automatically increments and assigns to each new version of a template.
        public var version: Swift.String?

        public init(
            creationDate: Swift.String? = nil,
            defaultSubstitutions: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            templateDescription: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateType: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.defaultSubstitutions = defaultSubstitutions
            self.lastModifiedDate = lastModifiedDate
            self.templateDescription = templateDescription
            self.templateName = templateName
            self.templateType = templateType
            self.version = version
        }
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension PinpointClientTypes {

    /// Specifies the tags (keys and values) for an application, campaign, message template, or segment.
    public struct TagsModel: Swift.Sendable {
        /// A string-to-string map of key-value pairs that defines the tags for an application, campaign, message template, or segment. Each of these resources can have a maximum of 50 tags. Each tag consists of a required tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
        /// This member is required.
        public var tags: [Swift.String: Swift.String]?

        public init(
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.tags = tags
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Specifies the tags (keys and values) for an application, campaign, message template, or segment.
    /// This member is required.
    public var tagsModel: PinpointClientTypes.TagsModel?

    public init(
        tagsModel: PinpointClientTypes.TagsModel? = nil
    )
    {
        self.tagsModel = tagsModel
    }
}

public struct ListTemplatesInput: Swift.Sendable {
    /// The string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var nextToken: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The substring to match in the names of the message templates to include in the results. If you specify this value, Amazon Pinpoint returns only those templates whose names begin with the value that you specify.
    public var `prefix`: Swift.String?
    /// The type of message template to include in the results. Valid values are: EMAIL, PUSH, SMS, and VOICE. To include all types of templates in the results, don't include this parameter in your request.
    public var templateType: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        `prefix`: Swift.String? = nil,
        templateType: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.`prefix` = `prefix`
        self.templateType = templateType
    }
}

extension PinpointClientTypes {

    /// Provides information about all the message templates that are associated with your Amazon Pinpoint account.
    public struct TemplatesResponse: Swift.Sendable {
        /// An array of responses, one for each message template that's associated with your Amazon Pinpoint account and meets any filter criteria that you specified in the request.
        /// This member is required.
        public var item: [PinpointClientTypes.TemplateResponse]?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public var nextToken: Swift.String?

        public init(
            item: [PinpointClientTypes.TemplateResponse]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.item = item
            self.nextToken = nextToken
        }
    }
}

public struct ListTemplatesOutput: Swift.Sendable {
    /// Provides information about all the message templates that are associated with your Amazon Pinpoint account.
    /// This member is required.
    public var templatesResponse: PinpointClientTypes.TemplatesResponse?

    public init(
        templatesResponse: PinpointClientTypes.TemplatesResponse? = nil
    )
    {
        self.templatesResponse = templatesResponse
    }
}

public struct ListTemplateVersionsInput: Swift.Sendable {
    /// The string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var nextToken: Swift.String?
    /// The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.
    public var pageSize: Swift.String?
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The type of channel that the message template is designed for. Valid values are: EMAIL, PUSH, SMS, and VOICE.
    /// This member is required.
    public var templateType: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.String? = nil,
        templateName: Swift.String? = nil,
        templateType: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.templateName = templateName
        self.templateType = templateType
    }
}

extension PinpointClientTypes {

    /// Provides information about all the versions of a specific message template.
    public struct TemplateVersionsResponse: Swift.Sendable {
        /// An array of responses, one for each version of the message template.
        /// This member is required.
        public var item: [PinpointClientTypes.TemplateVersionResponse]?
        /// The message that's returned from the API for the request to retrieve information about all the versions of the message template.
        public var message: Swift.String?
        /// The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.
        public var nextToken: Swift.String?
        /// The unique identifier for the request to retrieve information about all the versions of the message template.
        public var requestID: Swift.String?

        public init(
            item: [PinpointClientTypes.TemplateVersionResponse]? = nil,
            message: Swift.String? = nil,
            nextToken: Swift.String? = nil,
            requestID: Swift.String? = nil
        )
        {
            self.item = item
            self.message = message
            self.nextToken = nextToken
            self.requestID = requestID
        }
    }
}

public struct ListTemplateVersionsOutput: Swift.Sendable {
    /// Provides information about all the versions of a specific message template.
    /// This member is required.
    public var templateVersionsResponse: PinpointClientTypes.TemplateVersionsResponse?

    public init(
        templateVersionsResponse: PinpointClientTypes.TemplateVersionsResponse? = nil
    )
    {
        self.templateVersionsResponse = templateVersionsResponse
    }
}

extension PinpointClientTypes {

    /// Provides information about the results of sending a message directly to an endpoint address.
    public struct MessageResult: Swift.Sendable {
        /// The delivery status of the message. Possible values are:
        ///
        /// * DUPLICATE - The endpoint address is a duplicate of another endpoint address. Amazon Pinpoint won't attempt to send the message again.
        ///
        /// * OPT_OUT - The user who's associated with the endpoint address has opted out of receiving messages from you. Amazon Pinpoint won't attempt to send the message again.
        ///
        /// * PERMANENT_FAILURE - An error occurred when delivering the message to the endpoint address. Amazon Pinpoint won't attempt to send the message again.
        ///
        /// * SUCCESSFUL - The message was successfully delivered to the endpoint address.
        ///
        /// * TEMPORARY_FAILURE - A temporary error occurred. Amazon Pinpoint won't attempt to send the message again.
        ///
        /// * THROTTLED - Amazon Pinpoint throttled the operation to send the message to the endpoint address.
        ///
        /// * UNKNOWN_FAILURE - An unknown error occurred.
        /// This member is required.
        public var deliveryStatus: PinpointClientTypes.DeliveryStatus?
        /// The unique identifier for the message that was sent.
        public var messageId: Swift.String?
        /// The downstream service status code for delivering the message.
        /// This member is required.
        public var statusCode: Swift.Int?
        /// The status message for delivering the message.
        public var statusMessage: Swift.String?
        /// For push notifications that are sent through the GCM channel, specifies whether the endpoint's device registration token was updated as part of delivering the message.
        public var updatedToken: Swift.String?

        public init(
            deliveryStatus: PinpointClientTypes.DeliveryStatus? = nil,
            messageId: Swift.String? = nil,
            statusCode: Swift.Int? = nil,
            statusMessage: Swift.String? = nil,
            updatedToken: Swift.String? = nil
        )
        {
            self.deliveryStatus = deliveryStatus
            self.messageId = messageId
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.updatedToken = updatedToken
        }
    }
}

extension PinpointClientTypes {

    /// Specifies the configuration and other settings for a message.
    public struct MessageRequest: Swift.Sendable {
        /// A map of key-value pairs, where each key is an address and each value is an [AddressConfiguration](https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-addressconfiguration) object. An address can be a push notification token, a phone number, or an email address. You can use an [AddressConfiguration](https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-addressconfiguration) object to tailor the message for an address by specifying settings such as content overrides and message variables.
        public var addresses: [Swift.String: PinpointClientTypes.AddressConfiguration]?
        /// A map of custom attributes to attach to the message. For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.
        public var context: [Swift.String: Swift.String]?
        /// A map of key-value pairs, where each key is an endpoint ID and each value is an [EndpointSendConfiguration](https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration) object. You can use an [EndpointSendConfiguration](https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration) object to tailor the message for an endpoint by specifying settings such as content overrides and message variables.
        public var endpoints: [Swift.String: PinpointClientTypes.EndpointSendConfiguration]?
        /// The settings and content for the default message and any default messages that you defined for specific channels.
        /// This member is required.
        public var messageConfiguration: PinpointClientTypes.DirectMessageConfiguration?
        /// The message template to use for the message.
        public var templateConfiguration: PinpointClientTypes.TemplateConfiguration?
        /// The unique identifier for tracing the message. This identifier is visible to message recipients.
        public var traceId: Swift.String?

        public init(
            addresses: [Swift.String: PinpointClientTypes.AddressConfiguration]? = nil,
            context: [Swift.String: Swift.String]? = nil,
            endpoints: [Swift.String: PinpointClientTypes.EndpointSendConfiguration]? = nil,
            messageConfiguration: PinpointClientTypes.DirectMessageConfiguration? = nil,
            templateConfiguration: PinpointClientTypes.TemplateConfiguration? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.addresses = addresses
            self.context = context
            self.endpoints = endpoints
            self.messageConfiguration = messageConfiguration
            self.templateConfiguration = templateConfiguration
            self.traceId = traceId
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about the results of a request to send a message to an endpoint address.
    public struct MessageResponse: Swift.Sendable {
        /// The unique identifier for the application that was used to send the message.
        /// This member is required.
        public var applicationId: Swift.String?
        /// A map that contains a multipart response for each address that the message was sent to. In the map, the endpoint ID is the key and the result is the value.
        public var endpointResult: [Swift.String: PinpointClientTypes.EndpointMessageResult]?
        /// The identifier for the original request that the message was delivered for.
        public var requestId: Swift.String?
        /// A map that contains a multipart response for each address (email address, phone number, or push notification token) that the message was sent to. In the map, the address is the key and the result is the value.
        public var result: [Swift.String: PinpointClientTypes.MessageResult]?

        public init(
            applicationId: Swift.String? = nil,
            endpointResult: [Swift.String: PinpointClientTypes.EndpointMessageResult]? = nil,
            requestId: Swift.String? = nil,
            result: [Swift.String: PinpointClientTypes.MessageResult]? = nil
        )
        {
            self.applicationId = applicationId
            self.endpointResult = endpointResult
            self.requestId = requestId
            self.result = result
        }
    }
}

extension PinpointClientTypes {

    /// Specifies a phone number to validate and retrieve information about.
    public struct NumberValidateRequest: Swift.Sendable {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the phone number was originally registered.
        public var isoCountryCode: Swift.String?
        /// The phone number to retrieve information about. The phone number that you provide should include a valid numeric country code. Otherwise, the operation might result in an error.
        public var phoneNumber: Swift.String?

        public init(
            isoCountryCode: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.isoCountryCode = isoCountryCode
            self.phoneNumber = phoneNumber
        }
    }
}

extension PinpointClientTypes {

    /// Provides information about a phone number.
    public struct NumberValidateResponse: Swift.Sendable {
        /// The carrier or service provider that the phone number is currently registered with. In some countries and regions, this value may be the carrier or service provider that the phone number was originally registered with.
        public var carrier: Swift.String?
        /// The name of the city where the phone number was originally registered.
        public var city: Swift.String?
        /// The cleansed phone number, in E.164 format, for the location where the phone number was originally registered.
        public var cleansedPhoneNumberE164: Swift.String?
        /// The cleansed phone number, in the format for the location where the phone number was originally registered.
        public var cleansedPhoneNumberNational: Swift.String?
        /// The name of the country or region where the phone number was originally registered.
        public var country: Swift.String?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the phone number was originally registered.
        public var countryCodeIso2: Swift.String?
        /// The numeric code for the country or region where the phone number was originally registered.
        public var countryCodeNumeric: Swift.String?
        /// The name of the county where the phone number was originally registered.
        public var county: Swift.String?
        /// The two-character code, in ISO 3166-1 alpha-2 format, that was sent in the request body.
        public var originalCountryCodeIso2: Swift.String?
        /// The phone number that was sent in the request body.
        public var originalPhoneNumber: Swift.String?
        /// The description of the phone type. Valid values are: MOBILE, LANDLINE, VOIP, INVALID, PREPAID, and OTHER.
        public var phoneType: Swift.String?
        /// The phone type, represented by an integer. Valid values are: 0 (mobile), 1 (landline), 2 (VoIP), 3 (invalid), 4 (other), and 5 (prepaid).
        public var phoneTypeCode: Swift.Int?
        /// The time zone for the location where the phone number was originally registered.
        public var timezone: Swift.String?
        /// The postal or ZIP code for the location where the phone number was originally registered.
        public var zipCode: Swift.String?

        public init(
            carrier: Swift.String? = nil,
            city: Swift.String? = nil,
            cleansedPhoneNumberE164: Swift.String? = nil,
            cleansedPhoneNumberNational: Swift.String? = nil,
            country: Swift.String? = nil,
            countryCodeIso2: Swift.String? = nil,
            countryCodeNumeric: Swift.String? = nil,
            county: Swift.String? = nil,
            originalCountryCodeIso2: Swift.String? = nil,
            originalPhoneNumber: Swift.String? = nil,
            phoneType: Swift.String? = nil,
            phoneTypeCode: Swift.Int? = nil,
            timezone: Swift.String? = nil,
            zipCode: Swift.String? = nil
        )
        {
            self.carrier = carrier
            self.city = city
            self.cleansedPhoneNumberE164 = cleansedPhoneNumberE164
            self.cleansedPhoneNumberNational = cleansedPhoneNumberNational
            self.country = country
            self.countryCodeIso2 = countryCodeIso2
            self.countryCodeNumeric = countryCodeNumeric
            self.county = county
            self.originalCountryCodeIso2 = originalCountryCodeIso2
            self.originalPhoneNumber = originalPhoneNumber
            self.phoneType = phoneType
            self.phoneTypeCode = phoneTypeCode
            self.timezone = timezone
            self.zipCode = zipCode
        }
    }
}

public struct PhoneNumberValidateInput: Swift.Sendable {
    /// Specifies a phone number to validate and retrieve information about.
    /// This member is required.
    public var numberValidateRequest: PinpointClientTypes.NumberValidateRequest?

    public init(
        numberValidateRequest: PinpointClientTypes.NumberValidateRequest? = nil
    )
    {
        self.numberValidateRequest = numberValidateRequest
    }
}

public struct PhoneNumberValidateOutput: Swift.Sendable {
    /// Provides information about a phone number.
    /// This member is required.
    public var numberValidateResponse: PinpointClientTypes.NumberValidateResponse?

    public init(
        numberValidateResponse: PinpointClientTypes.NumberValidateResponse? = nil
    )
    {
        self.numberValidateResponse = numberValidateResponse
    }
}

public struct PutEventsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies a batch of events to process.
    /// This member is required.
    public var eventsRequest: PinpointClientTypes.EventsRequest?

    public init(
        applicationId: Swift.String? = nil,
        eventsRequest: PinpointClientTypes.EventsRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.eventsRequest = eventsRequest
    }
}

public struct PutEventsOutput: Swift.Sendable {
    /// Provides information about endpoints and the events that they're associated with.
    /// This member is required.
    public var eventsResponse: PinpointClientTypes.EventsResponse?

    public init(
        eventsResponse: PinpointClientTypes.EventsResponse? = nil
    )
    {
        self.eventsResponse = eventsResponse
    }
}

extension PinpointClientTypes {

    /// Specifies the Amazon Resource Name (ARN) of an event stream to publish events to and the AWS Identity and Access Management (IAM) role to use when publishing those events.
    public struct WriteEventStream: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Amazon Kinesis data stream or Amazon Kinesis Data Firehose delivery stream that you want to publish event data to. For a Kinesis data stream, the ARN format is: arn:aws:kinesis:region:account-id:stream/stream_name For a Kinesis Data Firehose delivery stream, the ARN format is: arn:aws:firehose:region:account-id:deliverystream/stream_name
        /// This member is required.
        public var destinationStreamArn: Swift.String?
        /// The AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to publish event data to the stream in your AWS account.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            destinationStreamArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.destinationStreamArn = destinationStreamArn
            self.roleArn = roleArn
        }
    }
}

public struct PutEventStreamInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the Amazon Resource Name (ARN) of an event stream to publish events to and the AWS Identity and Access Management (IAM) role to use when publishing those events.
    /// This member is required.
    public var writeEventStream: PinpointClientTypes.WriteEventStream?

    public init(
        applicationId: Swift.String? = nil,
        writeEventStream: PinpointClientTypes.WriteEventStream? = nil
    )
    {
        self.applicationId = applicationId
        self.writeEventStream = writeEventStream
    }
}

public struct PutEventStreamOutput: Swift.Sendable {
    /// Specifies settings for publishing event data to an Amazon Kinesis data stream or an Amazon Kinesis Data Firehose delivery stream.
    /// This member is required.
    public var eventStream: PinpointClientTypes.EventStream?

    public init(
        eventStream: PinpointClientTypes.EventStream? = nil
    )
    {
        self.eventStream = eventStream
    }
}

extension PinpointClientTypes {

    /// Specifies one or more attributes to remove from all the endpoints that are associated with an application.
    public struct UpdateAttributesRequest: Swift.Sendable {
        /// An array of the attributes to remove from all the endpoints that are associated with the application. The array can specify the complete, exact name of each attribute to remove or it can specify a glob pattern that an attribute name must match in order for the attribute to be removed.
        public var blacklist: [Swift.String]?

        public init(
            blacklist: [Swift.String]? = nil
        )
        {
            self.blacklist = blacklist
        }
    }
}

public struct RemoveAttributesInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The type of attribute or attributes to remove. Valid values are:
    ///
    /// * endpoint-custom-attributes - Custom attributes that describe endpoints, such as the date when an associated user opted in or out of receiving communications from you through a specific type of channel.
    ///
    /// * endpoint-metric-attributes - Custom metrics that your app reports to Amazon Pinpoint for endpoints, such as the number of app sessions or the number of items left in a cart.
    ///
    /// * endpoint-user-attributes - Custom attributes that describe users, such as first name, last name, and age.
    /// This member is required.
    public var attributeType: Swift.String?
    /// Specifies one or more attributes to remove from all the endpoints that are associated with an application.
    /// This member is required.
    public var updateAttributesRequest: PinpointClientTypes.UpdateAttributesRequest?

    public init(
        applicationId: Swift.String? = nil,
        attributeType: Swift.String? = nil,
        updateAttributesRequest: PinpointClientTypes.UpdateAttributesRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.attributeType = attributeType
        self.updateAttributesRequest = updateAttributesRequest
    }
}

public struct RemoveAttributesOutput: Swift.Sendable {
    /// Provides information about the type and the names of attributes that were removed from all the endpoints that are associated with an application.
    /// This member is required.
    public var attributesResource: PinpointClientTypes.AttributesResource?

    public init(
        attributesResource: PinpointClientTypes.AttributesResource? = nil
    )
    {
        self.attributesResource = attributesResource
    }
}

public struct SendMessagesInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the configuration and other settings for a message.
    /// This member is required.
    public var messageRequest: PinpointClientTypes.MessageRequest?

    public init(
        applicationId: Swift.String? = nil,
        messageRequest: PinpointClientTypes.MessageRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.messageRequest = messageRequest
    }
}

public struct SendMessagesOutput: Swift.Sendable {
    /// Provides information about the results of a request to send a message to an endpoint address.
    /// This member is required.
    public var messageResponse: PinpointClientTypes.MessageResponse?

    public init(
        messageResponse: PinpointClientTypes.MessageResponse? = nil
    )
    {
        self.messageResponse = messageResponse
    }
}

extension PinpointClientTypes {

    /// Send OTP message request parameters.
    public struct SendOTPMessageRequestParameters: Swift.Sendable {
        /// The attempts allowed to validate an OTP.
        public var allowedAttempts: Swift.Int?
        /// The brand name that will be substituted into the OTP message body. Should be owned by calling AWS account.
        /// This member is required.
        public var brandName: Swift.String?
        /// Channel type for the OTP message. Supported values: [SMS].
        /// This member is required.
        public var channel: Swift.String?
        /// The number of characters in the generated OTP.
        public var codeLength: Swift.Int?
        /// The destination identity to send OTP to.
        /// This member is required.
        public var destinationIdentity: Swift.String?
        /// A unique Entity ID received from DLT after entity registration is approved.
        public var entityId: Swift.String?
        /// The language to be used for the outgoing message body containing the OTP.
        public var language: Swift.String?
        /// The origination identity used to send OTP from.
        /// This member is required.
        public var originationIdentity: Swift.String?
        /// Developer-specified reference identifier. Required to match during OTP verification.
        /// This member is required.
        public var referenceId: Swift.String?
        /// A unique Template ID received from DLT after entity registration is approved.
        public var templateId: Swift.String?
        /// The time in minutes before the OTP is no longer valid.
        public var validityPeriod: Swift.Int?

        public init(
            allowedAttempts: Swift.Int? = nil,
            brandName: Swift.String? = nil,
            channel: Swift.String? = nil,
            codeLength: Swift.Int? = nil,
            destinationIdentity: Swift.String? = nil,
            entityId: Swift.String? = nil,
            language: Swift.String? = nil,
            originationIdentity: Swift.String? = nil,
            referenceId: Swift.String? = nil,
            templateId: Swift.String? = nil,
            validityPeriod: Swift.Int? = nil
        )
        {
            self.allowedAttempts = allowedAttempts
            self.brandName = brandName
            self.channel = channel
            self.codeLength = codeLength
            self.destinationIdentity = destinationIdentity
            self.entityId = entityId
            self.language = language
            self.originationIdentity = originationIdentity
            self.referenceId = referenceId
            self.templateId = templateId
            self.validityPeriod = validityPeriod
        }
    }
}

public struct SendOTPMessageInput: Swift.Sendable {
    /// The unique ID of your Amazon Pinpoint application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Send OTP message request parameters.
    /// This member is required.
    public var sendOTPMessageRequestParameters: PinpointClientTypes.SendOTPMessageRequestParameters?

    public init(
        applicationId: Swift.String? = nil,
        sendOTPMessageRequestParameters: PinpointClientTypes.SendOTPMessageRequestParameters? = nil
    )
    {
        self.applicationId = applicationId
        self.sendOTPMessageRequestParameters = sendOTPMessageRequestParameters
    }
}

public struct SendOTPMessageOutput: Swift.Sendable {
    /// Provides information about the results of a request to send a message to an endpoint address.
    /// This member is required.
    public var messageResponse: PinpointClientTypes.MessageResponse?

    public init(
        messageResponse: PinpointClientTypes.MessageResponse? = nil
    )
    {
        self.messageResponse = messageResponse
    }
}

extension PinpointClientTypes {

    /// Specifies the configuration and other settings for a message to send to all the endpoints that are associated with a list of users.
    public struct SendUsersMessageRequest: Swift.Sendable {
        /// A map of custom attribute-value pairs. For a push notification, Amazon Pinpoint adds these attributes to the data.pinpoint object in the body of the notification payload. Amazon Pinpoint also provides these attributes in the events that it generates for users-messages deliveries.
        public var context: [Swift.String: Swift.String]?
        /// The settings and content for the default message and any default messages that you defined for specific channels.
        /// This member is required.
        public var messageConfiguration: PinpointClientTypes.DirectMessageConfiguration?
        /// The message template to use for the message.
        public var templateConfiguration: PinpointClientTypes.TemplateConfiguration?
        /// The unique identifier for tracing the message. This identifier is visible to message recipients.
        public var traceId: Swift.String?
        /// A map that associates user IDs with [EndpointSendConfiguration](https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration) objects. You can use an [EndpointSendConfiguration](https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration) object to tailor the message for a user by specifying settings such as content overrides and message variables.
        /// This member is required.
        public var users: [Swift.String: PinpointClientTypes.EndpointSendConfiguration]?

        public init(
            context: [Swift.String: Swift.String]? = nil,
            messageConfiguration: PinpointClientTypes.DirectMessageConfiguration? = nil,
            templateConfiguration: PinpointClientTypes.TemplateConfiguration? = nil,
            traceId: Swift.String? = nil,
            users: [Swift.String: PinpointClientTypes.EndpointSendConfiguration]? = nil
        )
        {
            self.context = context
            self.messageConfiguration = messageConfiguration
            self.templateConfiguration = templateConfiguration
            self.traceId = traceId
            self.users = users
        }
    }
}

public struct SendUsersMessagesInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the configuration and other settings for a message to send to all the endpoints that are associated with a list of users.
    /// This member is required.
    public var sendUsersMessageRequest: PinpointClientTypes.SendUsersMessageRequest?

    public init(
        applicationId: Swift.String? = nil,
        sendUsersMessageRequest: PinpointClientTypes.SendUsersMessageRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.sendUsersMessageRequest = sendUsersMessageRequest
    }
}

extension PinpointClientTypes {

    /// Provides information about which users and endpoints a message was sent to.
    public struct SendUsersMessageResponse: Swift.Sendable {
        /// The unique identifier for the application that was used to send the message.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The unique identifier that was assigned to the message request.
        public var requestId: Swift.String?
        /// An object that indicates which endpoints the message was sent to, for each user. The object lists user IDs and, for each user ID, provides the endpoint IDs that the message was sent to. For each endpoint ID, it provides an EndpointMessageResult object.
        public var result: [Swift.String: [Swift.String: PinpointClientTypes.EndpointMessageResult]]?

        public init(
            applicationId: Swift.String? = nil,
            requestId: Swift.String? = nil,
            result: [Swift.String: [Swift.String: PinpointClientTypes.EndpointMessageResult]]? = nil
        )
        {
            self.applicationId = applicationId
            self.requestId = requestId
            self.result = result
        }
    }
}

public struct SendUsersMessagesOutput: Swift.Sendable {
    /// Provides information about which users and endpoints a message was sent to.
    /// This member is required.
    public var sendUsersMessageResponse: PinpointClientTypes.SendUsersMessageResponse?

    public init(
        sendUsersMessageResponse: PinpointClientTypes.SendUsersMessageResponse? = nil
    )
    {
        self.sendUsersMessageResponse = sendUsersMessageResponse
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Specifies the tags (keys and values) for an application, campaign, message template, or segment.
    /// This member is required.
    public var tagsModel: PinpointClientTypes.TagsModel?

    public init(
        resourceArn: Swift.String? = nil,
        tagsModel: PinpointClientTypes.TagsModel? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagsModel = tagsModel
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key of the tag to remove from the resource. To remove multiple tags, append the tagKeys parameter and argument for each additional tag to remove, separated by an ampersand (&).
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UpdateAdmChannelInput: Swift.Sendable {
    /// Specifies the status and settings of the ADM (Amazon Device Messaging) channel for an application.
    /// This member is required.
    public var admChannelRequest: PinpointClientTypes.ADMChannelRequest?
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        admChannelRequest: PinpointClientTypes.ADMChannelRequest? = nil,
        applicationId: Swift.String? = nil
    )
    {
        self.admChannelRequest = admChannelRequest
        self.applicationId = applicationId
    }
}

public struct UpdateAdmChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the ADM (Amazon Device Messaging) channel for an application.
    /// This member is required.
    public var admChannelResponse: PinpointClientTypes.ADMChannelResponse?

    public init(
        admChannelResponse: PinpointClientTypes.ADMChannelResponse? = nil
    )
    {
        self.admChannelResponse = admChannelResponse
    }
}

public struct UpdateApnsChannelInput: Swift.Sendable {
    /// Specifies the status and settings of the APNs (Apple Push Notification service) channel for an application.
    /// This member is required.
    public var apnsChannelRequest: PinpointClientTypes.APNSChannelRequest?
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        apnsChannelRequest: PinpointClientTypes.APNSChannelRequest? = nil,
        applicationId: Swift.String? = nil
    )
    {
        self.apnsChannelRequest = apnsChannelRequest
        self.applicationId = applicationId
    }
}

public struct UpdateApnsChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the APNs (Apple Push Notification service) channel for an application.
    /// This member is required.
    public var apnsChannelResponse: PinpointClientTypes.APNSChannelResponse?

    public init(
        apnsChannelResponse: PinpointClientTypes.APNSChannelResponse? = nil
    )
    {
        self.apnsChannelResponse = apnsChannelResponse
    }
}

public struct UpdateApnsSandboxChannelInput: Swift.Sendable {
    /// Specifies the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.
    /// This member is required.
    public var apnsSandboxChannelRequest: PinpointClientTypes.APNSSandboxChannelRequest?
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        apnsSandboxChannelRequest: PinpointClientTypes.APNSSandboxChannelRequest? = nil,
        applicationId: Swift.String? = nil
    )
    {
        self.apnsSandboxChannelRequest = apnsSandboxChannelRequest
        self.applicationId = applicationId
    }
}

public struct UpdateApnsSandboxChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.
    /// This member is required.
    public var apnsSandboxChannelResponse: PinpointClientTypes.APNSSandboxChannelResponse?

    public init(
        apnsSandboxChannelResponse: PinpointClientTypes.APNSSandboxChannelResponse? = nil
    )
    {
        self.apnsSandboxChannelResponse = apnsSandboxChannelResponse
    }
}

public struct UpdateApnsVoipChannelInput: Swift.Sendable {
    /// Specifies the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.
    /// This member is required.
    public var apnsVoipChannelRequest: PinpointClientTypes.APNSVoipChannelRequest?
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        apnsVoipChannelRequest: PinpointClientTypes.APNSVoipChannelRequest? = nil,
        applicationId: Swift.String? = nil
    )
    {
        self.apnsVoipChannelRequest = apnsVoipChannelRequest
        self.applicationId = applicationId
    }
}

public struct UpdateApnsVoipChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.
    /// This member is required.
    public var apnsVoipChannelResponse: PinpointClientTypes.APNSVoipChannelResponse?

    public init(
        apnsVoipChannelResponse: PinpointClientTypes.APNSVoipChannelResponse? = nil
    )
    {
        self.apnsVoipChannelResponse = apnsVoipChannelResponse
    }
}

public struct UpdateApnsVoipSandboxChannelInput: Swift.Sendable {
    /// Specifies the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.
    /// This member is required.
    public var apnsVoipSandboxChannelRequest: PinpointClientTypes.APNSVoipSandboxChannelRequest?
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        apnsVoipSandboxChannelRequest: PinpointClientTypes.APNSVoipSandboxChannelRequest? = nil,
        applicationId: Swift.String? = nil
    )
    {
        self.apnsVoipSandboxChannelRequest = apnsVoipSandboxChannelRequest
        self.applicationId = applicationId
    }
}

public struct UpdateApnsVoipSandboxChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.
    /// This member is required.
    public var apnsVoipSandboxChannelResponse: PinpointClientTypes.APNSVoipSandboxChannelResponse?

    public init(
        apnsVoipSandboxChannelResponse: PinpointClientTypes.APNSVoipSandboxChannelResponse? = nil
    )
    {
        self.apnsVoipSandboxChannelResponse = apnsVoipSandboxChannelResponse
    }
}

extension PinpointClientTypes {

    /// Specifies the default settings for an application.
    public struct WriteApplicationSettingsRequest: Swift.Sendable {
        /// The settings for the AWS Lambda function to invoke by default as a code hook for campaigns in the application. You can use this hook to customize segments that are used by campaigns in the application. To override these settings and define custom settings for a specific campaign, use the CampaignHook object of the Campaign resource.
        public var campaignHook: PinpointClientTypes.CampaignHook?
        /// Specifies whether to enable application-related alarms in Amazon CloudWatch.
        public var cloudWatchMetricsEnabled: Swift.Bool?
        public var eventTaggingEnabled: Swift.Bool?
        /// The default sending limits for journeys in the application. These limits apply to each journey for the application but can be overridden, on a per journey basis, with the JourneyLimits resource.
        public var journeyLimits: PinpointClientTypes.ApplicationSettingsJourneyLimits?
        /// The default sending limits for campaigns in the application. To override these limits and define custom limits for a specific campaign or journey, use the Campaign resource or the Journey resource, respectively.
        public var limits: PinpointClientTypes.CampaignLimits?
        /// The default quiet time for campaigns in the application. Quiet time is a specific time range when messages aren't sent to endpoints, if all the following conditions are met:
        ///
        /// * The EndpointDemographic.Timezone property of the endpoint is set to a valid value.
        ///
        /// * The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the application (or a campaign or journey that has custom quiet time settings).
        ///
        /// * The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the application (or a campaign or journey that has custom quiet time settings).
        ///
        ///
        /// If any of the preceding conditions isn't met, the endpoint will receive messages from a campaign or journey, even if quiet time is enabled. To override the default quiet time settings for a specific campaign or journey, use the Campaign resource or the Journey resource to define a custom quiet time for the campaign or journey.
        public var quietTime: PinpointClientTypes.QuietTime?

        public init(
            campaignHook: PinpointClientTypes.CampaignHook? = nil,
            cloudWatchMetricsEnabled: Swift.Bool? = nil,
            eventTaggingEnabled: Swift.Bool? = nil,
            journeyLimits: PinpointClientTypes.ApplicationSettingsJourneyLimits? = nil,
            limits: PinpointClientTypes.CampaignLimits? = nil,
            quietTime: PinpointClientTypes.QuietTime? = nil
        )
        {
            self.campaignHook = campaignHook
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.eventTaggingEnabled = eventTaggingEnabled
            self.journeyLimits = journeyLimits
            self.limits = limits
            self.quietTime = quietTime
        }
    }
}

public struct UpdateApplicationSettingsInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the default settings for an application.
    /// This member is required.
    public var writeApplicationSettingsRequest: PinpointClientTypes.WriteApplicationSettingsRequest?

    public init(
        applicationId: Swift.String? = nil,
        writeApplicationSettingsRequest: PinpointClientTypes.WriteApplicationSettingsRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.writeApplicationSettingsRequest = writeApplicationSettingsRequest
    }
}

public struct UpdateApplicationSettingsOutput: Swift.Sendable {
    /// Provides information about an application, including the default settings for an application.
    /// This member is required.
    public var applicationSettingsResource: PinpointClientTypes.ApplicationSettingsResource?

    public init(
        applicationSettingsResource: PinpointClientTypes.ApplicationSettingsResource? = nil
    )
    {
        self.applicationSettingsResource = applicationSettingsResource
    }
}

public struct UpdateBaiduChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the status and settings of the Baidu (Baidu Cloud Push) channel for an application.
    /// This member is required.
    public var baiduChannelRequest: PinpointClientTypes.BaiduChannelRequest?

    public init(
        applicationId: Swift.String? = nil,
        baiduChannelRequest: PinpointClientTypes.BaiduChannelRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.baiduChannelRequest = baiduChannelRequest
    }
}

public struct UpdateBaiduChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the Baidu (Baidu Cloud Push) channel for an application.
    /// This member is required.
    public var baiduChannelResponse: PinpointClientTypes.BaiduChannelResponse?

    public init(
        baiduChannelResponse: PinpointClientTypes.BaiduChannelResponse? = nil
    )
    {
        self.baiduChannelResponse = baiduChannelResponse
    }
}

public struct UpdateCampaignInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the campaign.
    /// This member is required.
    public var campaignId: Swift.String?
    /// Specifies the configuration and other settings for a campaign.
    /// This member is required.
    public var writeCampaignRequest: PinpointClientTypes.WriteCampaignRequest?

    public init(
        applicationId: Swift.String? = nil,
        campaignId: Swift.String? = nil,
        writeCampaignRequest: PinpointClientTypes.WriteCampaignRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
        self.writeCampaignRequest = writeCampaignRequest
    }
}

public struct UpdateCampaignOutput: Swift.Sendable {
    /// Provides information about the status, configuration, and other settings for a campaign.
    /// This member is required.
    public var campaignResponse: PinpointClientTypes.CampaignResponse?

    public init(
        campaignResponse: PinpointClientTypes.CampaignResponse? = nil
    )
    {
        self.campaignResponse = campaignResponse
    }
}

public struct UpdateEmailChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the status and settings of the email channel for an application.
    /// This member is required.
    public var emailChannelRequest: PinpointClientTypes.EmailChannelRequest?

    public init(
        applicationId: Swift.String? = nil,
        emailChannelRequest: PinpointClientTypes.EmailChannelRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.emailChannelRequest = emailChannelRequest
    }
}

public struct UpdateEmailChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the email channel for an application.
    /// This member is required.
    public var emailChannelResponse: PinpointClientTypes.EmailChannelResponse?

    public init(
        emailChannelResponse: PinpointClientTypes.EmailChannelResponse? = nil
    )
    {
        self.emailChannelResponse = emailChannelResponse
    }
}

public struct UpdateEmailTemplateInput: Swift.Sendable {
    /// Specifies whether to save the updates as a new version of the message template. Valid values are: true, save the updates as a new version; and, false, save the updates to (overwrite) the latest existing version of the template. If you don't specify a value for this parameter, Amazon Pinpoint saves the updates to (overwrites) the latest existing version of the template. If you specify a value of true for this parameter, don't specify a value for the version parameter. Otherwise, an error will occur.
    public var createNewVersion: Swift.Bool?
    /// Specifies the content and settings for a message template that can be used in messages that are sent through the email channel.
    /// This member is required.
    public var emailTemplateRequest: PinpointClientTypes.EmailTemplateRequest?
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        createNewVersion: Swift.Bool? = nil,
        emailTemplateRequest: PinpointClientTypes.EmailTemplateRequest? = nil,
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createNewVersion = createNewVersion
        self.emailTemplateRequest = emailTemplateRequest
        self.templateName = templateName
        self.version = version
    }
}

public struct UpdateEmailTemplateOutput: Swift.Sendable {
    /// Provides information about an API request or response.
    /// This member is required.
    public var messageBody: PinpointClientTypes.MessageBody?

    public init(
        messageBody: PinpointClientTypes.MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

public struct UpdateEndpointInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The case insensitive unique identifier for the endpoint. The identifier can't contain $, { or }.
    /// This member is required.
    public var endpointId: Swift.String?
    /// Specifies the channel type and other settings for an endpoint.
    /// This member is required.
    public var endpointRequest: PinpointClientTypes.EndpointRequest?

    public init(
        applicationId: Swift.String? = nil,
        endpointId: Swift.String? = nil,
        endpointRequest: PinpointClientTypes.EndpointRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.endpointId = endpointId
        self.endpointRequest = endpointRequest
    }
}

public struct UpdateEndpointOutput: Swift.Sendable {
    /// Provides information about an API request or response.
    /// This member is required.
    public var messageBody: PinpointClientTypes.MessageBody?

    public init(
        messageBody: PinpointClientTypes.MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

public struct UpdateEndpointsBatchInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies a batch of endpoints to create or update and the settings and attributes to set or change for each endpoint.
    /// This member is required.
    public var endpointBatchRequest: PinpointClientTypes.EndpointBatchRequest?

    public init(
        applicationId: Swift.String? = nil,
        endpointBatchRequest: PinpointClientTypes.EndpointBatchRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.endpointBatchRequest = endpointBatchRequest
    }
}

public struct UpdateEndpointsBatchOutput: Swift.Sendable {
    /// Provides information about an API request or response.
    /// This member is required.
    public var messageBody: PinpointClientTypes.MessageBody?

    public init(
        messageBody: PinpointClientTypes.MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

public struct UpdateGcmChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the status and settings of the GCM channel for an application. This channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.
    /// This member is required.
    public var gcmChannelRequest: PinpointClientTypes.GCMChannelRequest?

    public init(
        applicationId: Swift.String? = nil,
        gcmChannelRequest: PinpointClientTypes.GCMChannelRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.gcmChannelRequest = gcmChannelRequest
    }
}

public struct UpdateGcmChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the GCM channel for an application. The GCM channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.
    /// This member is required.
    public var gcmChannelResponse: PinpointClientTypes.GCMChannelResponse?

    public init(
        gcmChannelResponse: PinpointClientTypes.GCMChannelResponse? = nil
    )
    {
        self.gcmChannelResponse = gcmChannelResponse
    }
}

public struct UpdateInAppTemplateInput: Swift.Sendable {
    /// Specifies whether to save the updates as a new version of the message template. Valid values are: true, save the updates as a new version; and, false, save the updates to (overwrite) the latest existing version of the template. If you don't specify a value for this parameter, Amazon Pinpoint saves the updates to (overwrites) the latest existing version of the template. If you specify a value of true for this parameter, don't specify a value for the version parameter. Otherwise, an error will occur.
    public var createNewVersion: Swift.Bool?
    /// InApp Template Request.
    /// This member is required.
    public var inAppTemplateRequest: PinpointClientTypes.InAppTemplateRequest?
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        createNewVersion: Swift.Bool? = nil,
        inAppTemplateRequest: PinpointClientTypes.InAppTemplateRequest? = nil,
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createNewVersion = createNewVersion
        self.inAppTemplateRequest = inAppTemplateRequest
        self.templateName = templateName
        self.version = version
    }
}

public struct UpdateInAppTemplateOutput: Swift.Sendable {
    /// Provides information about an API request or response.
    /// This member is required.
    public var messageBody: PinpointClientTypes.MessageBody?

    public init(
        messageBody: PinpointClientTypes.MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

public struct UpdateJourneyInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the journey.
    /// This member is required.
    public var journeyId: Swift.String?
    /// Specifies the configuration and other settings for a journey.
    /// This member is required.
    public var writeJourneyRequest: PinpointClientTypes.WriteJourneyRequest?

    public init(
        applicationId: Swift.String? = nil,
        journeyId: Swift.String? = nil,
        writeJourneyRequest: PinpointClientTypes.WriteJourneyRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyId = journeyId
        self.writeJourneyRequest = writeJourneyRequest
    }
}

public struct UpdateJourneyOutput: Swift.Sendable {
    /// Provides information about the status, configuration, and other settings for a journey.
    /// This member is required.
    public var journeyResponse: PinpointClientTypes.JourneyResponse?

    public init(
        journeyResponse: PinpointClientTypes.JourneyResponse? = nil
    )
    {
        self.journeyResponse = journeyResponse
    }
}

public struct UpdateJourneyStateInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the journey.
    /// This member is required.
    public var journeyId: Swift.String?
    /// Changes the status of a journey.
    /// This member is required.
    public var journeyStateRequest: PinpointClientTypes.JourneyStateRequest?

    public init(
        applicationId: Swift.String? = nil,
        journeyId: Swift.String? = nil,
        journeyStateRequest: PinpointClientTypes.JourneyStateRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyId = journeyId
        self.journeyStateRequest = journeyStateRequest
    }
}

public struct UpdateJourneyStateOutput: Swift.Sendable {
    /// Provides information about the status, configuration, and other settings for a journey.
    /// This member is required.
    public var journeyResponse: PinpointClientTypes.JourneyResponse?

    public init(
        journeyResponse: PinpointClientTypes.JourneyResponse? = nil
    )
    {
        self.journeyResponse = journeyResponse
    }
}

public struct UpdatePushTemplateInput: Swift.Sendable {
    /// Specifies whether to save the updates as a new version of the message template. Valid values are: true, save the updates as a new version; and, false, save the updates to (overwrite) the latest existing version of the template. If you don't specify a value for this parameter, Amazon Pinpoint saves the updates to (overwrites) the latest existing version of the template. If you specify a value of true for this parameter, don't specify a value for the version parameter. Otherwise, an error will occur.
    public var createNewVersion: Swift.Bool?
    /// Specifies the content and settings for a message template that can be used in messages that are sent through a push notification channel.
    /// This member is required.
    public var pushNotificationTemplateRequest: PinpointClientTypes.PushNotificationTemplateRequest?
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        createNewVersion: Swift.Bool? = nil,
        pushNotificationTemplateRequest: PinpointClientTypes.PushNotificationTemplateRequest? = nil,
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createNewVersion = createNewVersion
        self.pushNotificationTemplateRequest = pushNotificationTemplateRequest
        self.templateName = templateName
        self.version = version
    }
}

public struct UpdatePushTemplateOutput: Swift.Sendable {
    /// Provides information about an API request or response.
    /// This member is required.
    public var messageBody: PinpointClientTypes.MessageBody?

    public init(
        messageBody: PinpointClientTypes.MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

extension PinpointClientTypes {

    /// Specifies Amazon Pinpoint configuration settings for retrieving and processing recommendation data from a recommender model.
    public struct UpdateRecommenderConfigurationShape: Swift.Sendable {
        /// A map of key-value pairs that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template. In the map, the key is the name of a custom attribute and the value is a custom display name for that attribute. The display name appears in the Attribute finder of the template editor on the Amazon Pinpoint console. The following restrictions apply to these names:
        ///
        /// * An attribute name must start with a letter or number and it can contain up to 50 characters. The characters can be letters, numbers, underscores (_), or hyphens (-). Attribute names are case sensitive and must be unique.
        ///
        /// * An attribute display name must start with a letter or number and it can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).
        ///
        ///
        /// This object is required if the configuration invokes an AWS Lambda function (RecommendationTransformerUri) to process recommendation data. Otherwise, don't include this object in your request.
        public var attributes: [Swift.String: Swift.String]?
        /// A custom description of the configuration for the recommender model. The description can contain up to 128 characters. The characters can be letters, numbers, spaces, or the following symbols: _ ; () , ‐.
        public var description: Swift.String?
        /// A custom name of the configuration for the recommender model. The name must start with a letter or number and it can contain up to 128 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).
        public var name: Swift.String?
        /// The type of Amazon Pinpoint ID to associate with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Valid values are:
        ///
        /// * PINPOINT_ENDPOINT_ID - Associate each user in the model with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.
        ///
        /// * PINPOINT_USER_ID - Associate each user in the model with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If you specify this value, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.
        public var recommendationProviderIdType: Swift.String?
        /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.
        /// This member is required.
        public var recommendationProviderRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the recommender model to retrieve recommendation data from. This value must match the ARN of an Amazon Personalize campaign.
        /// This member is required.
        public var recommendationProviderUri: Swift.String?
        /// The name or Amazon Resource Name (ARN) of the AWS Lambda function to invoke for additional processing of recommendation data that's retrieved from the recommender model.
        public var recommendationTransformerUri: Swift.String?
        /// A custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This value is required if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data. This name appears in the Attribute finder of the template editor on the Amazon Pinpoint console. The name can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-). These restrictions don't apply to attribute values.
        public var recommendationsDisplayName: Swift.String?
        /// The number of recommended items to retrieve from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables. The minimum value is 1. The maximum value is 5. The default value is 5. To use multiple recommended items and custom attributes with message variables, you have to use an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.
        public var recommendationsPerMessage: Swift.Int?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            recommendationProviderIdType: Swift.String? = nil,
            recommendationProviderRoleArn: Swift.String? = nil,
            recommendationProviderUri: Swift.String? = nil,
            recommendationTransformerUri: Swift.String? = nil,
            recommendationsDisplayName: Swift.String? = nil,
            recommendationsPerMessage: Swift.Int? = nil
        )
        {
            self.attributes = attributes
            self.description = description
            self.name = name
            self.recommendationProviderIdType = recommendationProviderIdType
            self.recommendationProviderRoleArn = recommendationProviderRoleArn
            self.recommendationProviderUri = recommendationProviderUri
            self.recommendationTransformerUri = recommendationTransformerUri
            self.recommendationsDisplayName = recommendationsDisplayName
            self.recommendationsPerMessage = recommendationsPerMessage
        }
    }
}

public struct UpdateRecommenderConfigurationInput: Swift.Sendable {
    /// The unique identifier for the recommender model configuration. This identifier is displayed as the Recommender ID on the Amazon Pinpoint console.
    /// This member is required.
    public var recommenderId: Swift.String?
    /// Specifies Amazon Pinpoint configuration settings for retrieving and processing recommendation data from a recommender model.
    /// This member is required.
    public var updateRecommenderConfiguration: PinpointClientTypes.UpdateRecommenderConfigurationShape?

    public init(
        recommenderId: Swift.String? = nil,
        updateRecommenderConfiguration: PinpointClientTypes.UpdateRecommenderConfigurationShape? = nil
    )
    {
        self.recommenderId = recommenderId
        self.updateRecommenderConfiguration = updateRecommenderConfiguration
    }
}

public struct UpdateRecommenderConfigurationOutput: Swift.Sendable {
    /// Provides information about Amazon Pinpoint configuration settings for retrieving and processing data from a recommender model.
    /// This member is required.
    public var recommenderConfigurationResponse: PinpointClientTypes.RecommenderConfigurationResponse?

    public init(
        recommenderConfigurationResponse: PinpointClientTypes.RecommenderConfigurationResponse? = nil
    )
    {
        self.recommenderConfigurationResponse = recommenderConfigurationResponse
    }
}

public struct UpdateSegmentInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the segment.
    /// This member is required.
    public var segmentId: Swift.String?
    /// Specifies the configuration, dimension, and other settings for a segment. A WriteSegmentRequest object can include a Dimensions object or a SegmentGroups object, but not both.
    /// This member is required.
    public var writeSegmentRequest: PinpointClientTypes.WriteSegmentRequest?

    public init(
        applicationId: Swift.String? = nil,
        segmentId: Swift.String? = nil,
        writeSegmentRequest: PinpointClientTypes.WriteSegmentRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.segmentId = segmentId
        self.writeSegmentRequest = writeSegmentRequest
    }
}

public struct UpdateSegmentOutput: Swift.Sendable {
    /// Provides information about the configuration, dimension, and other settings for a segment.
    /// This member is required.
    public var segmentResponse: PinpointClientTypes.SegmentResponse?

    public init(
        segmentResponse: PinpointClientTypes.SegmentResponse? = nil
    )
    {
        self.segmentResponse = segmentResponse
    }
}

extension PinpointClientTypes {

    /// Specifies the status and settings of the SMS channel for an application.
    public struct SMSChannelRequest: Swift.Sendable {
        /// Specifies whether to enable the SMS channel for the application.
        public var enabled: Swift.Bool?
        /// The identity that you want to display on recipients' devices when they receive messages from the SMS channel.
        public var senderId: Swift.String?
        /// The registered short code that you want to use when you send messages through the SMS channel.
        public var shortCode: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            senderId: Swift.String? = nil,
            shortCode: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.senderId = senderId
            self.shortCode = shortCode
        }
    }
}

public struct UpdateSmsChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the status and settings of the SMS channel for an application.
    /// This member is required.
    public var smsChannelRequest: PinpointClientTypes.SMSChannelRequest?

    public init(
        applicationId: Swift.String? = nil,
        smsChannelRequest: PinpointClientTypes.SMSChannelRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.smsChannelRequest = smsChannelRequest
    }
}

public struct UpdateSmsChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the SMS channel for an application.
    /// This member is required.
    public var smsChannelResponse: PinpointClientTypes.SMSChannelResponse?

    public init(
        smsChannelResponse: PinpointClientTypes.SMSChannelResponse? = nil
    )
    {
        self.smsChannelResponse = smsChannelResponse
    }
}

public struct UpdateSmsTemplateInput: Swift.Sendable {
    /// Specifies whether to save the updates as a new version of the message template. Valid values are: true, save the updates as a new version; and, false, save the updates to (overwrite) the latest existing version of the template. If you don't specify a value for this parameter, Amazon Pinpoint saves the updates to (overwrites) the latest existing version of the template. If you specify a value of true for this parameter, don't specify a value for the version parameter. Otherwise, an error will occur.
    public var createNewVersion: Swift.Bool?
    /// Specifies the content and settings for a message template that can be used in text messages that are sent through the SMS channel.
    /// This member is required.
    public var smsTemplateRequest: PinpointClientTypes.SMSTemplateRequest?
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?

    public init(
        createNewVersion: Swift.Bool? = nil,
        smsTemplateRequest: PinpointClientTypes.SMSTemplateRequest? = nil,
        templateName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createNewVersion = createNewVersion
        self.smsTemplateRequest = smsTemplateRequest
        self.templateName = templateName
        self.version = version
    }
}

public struct UpdateSmsTemplateOutput: Swift.Sendable {
    /// Provides information about an API request or response.
    /// This member is required.
    public var messageBody: PinpointClientTypes.MessageBody?

    public init(
        messageBody: PinpointClientTypes.MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

extension PinpointClientTypes {

    /// Specifies which version of a message template to use as the active version of the template.
    public struct TemplateActiveVersionRequest: Swift.Sendable {
        /// The version of the message template to use as the active version of the template. Valid values are: latest, for the most recent version of the template; or, the unique identifier for any existing version of the template. If you specify an identifier, the value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the Template Versions resource.
        public var version: Swift.String?

        public init(
            version: Swift.String? = nil
        )
        {
            self.version = version
        }
    }
}

public struct UpdateTemplateActiveVersionInput: Swift.Sendable {
    /// Specifies which version of a message template to use as the active version of the template.
    /// This member is required.
    public var templateActiveVersionRequest: PinpointClientTypes.TemplateActiveVersionRequest?
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The type of channel that the message template is designed for. Valid values are: EMAIL, PUSH, SMS, and VOICE.
    /// This member is required.
    public var templateType: Swift.String?

    public init(
        templateActiveVersionRequest: PinpointClientTypes.TemplateActiveVersionRequest? = nil,
        templateName: Swift.String? = nil,
        templateType: Swift.String? = nil
    )
    {
        self.templateActiveVersionRequest = templateActiveVersionRequest
        self.templateName = templateName
        self.templateType = templateType
    }
}

public struct UpdateTemplateActiveVersionOutput: Swift.Sendable {
    /// Provides information about an API request or response.
    /// This member is required.
    public var messageBody: PinpointClientTypes.MessageBody?

    public init(
        messageBody: PinpointClientTypes.MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

extension PinpointClientTypes {

    /// Specifies the status and settings of the voice channel for an application.
    public struct VoiceChannelRequest: Swift.Sendable {
        /// Specifies whether to enable the voice channel for the application.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }
}

public struct UpdateVoiceChannelInput: Swift.Sendable {
    /// The unique identifier for the application. This identifier is displayed as the Project ID on the Amazon Pinpoint console.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Specifies the status and settings of the voice channel for an application.
    /// This member is required.
    public var voiceChannelRequest: PinpointClientTypes.VoiceChannelRequest?

    public init(
        applicationId: Swift.String? = nil,
        voiceChannelRequest: PinpointClientTypes.VoiceChannelRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.voiceChannelRequest = voiceChannelRequest
    }
}

public struct UpdateVoiceChannelOutput: Swift.Sendable {
    /// Provides information about the status and settings of the voice channel for an application.
    /// This member is required.
    public var voiceChannelResponse: PinpointClientTypes.VoiceChannelResponse?

    public init(
        voiceChannelResponse: PinpointClientTypes.VoiceChannelResponse? = nil
    )
    {
        self.voiceChannelResponse = voiceChannelResponse
    }
}

public struct UpdateVoiceTemplateInput: Swift.Sendable {
    /// Specifies whether to save the updates as a new version of the message template. Valid values are: true, save the updates as a new version; and, false, save the updates to (overwrite) the latest existing version of the template. If you don't specify a value for this parameter, Amazon Pinpoint saves the updates to (overwrites) the latest existing version of the template. If you specify a value of true for this parameter, don't specify a value for the version parameter. Otherwise, an error will occur.
    public var createNewVersion: Swift.Bool?
    /// The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.
    /// This member is required.
    public var templateName: Swift.String?
    /// The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the Template Versions resource. If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur. If you don't specify a value for this parameter, Amazon Pinpoint does the following:
    ///
    /// * For a get operation, retrieves information about the active version of the template.
    ///
    /// * For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.
    ///
    /// * For a delete operation, deletes the template, including all versions of the template.
    public var version: Swift.String?
    /// Specifies the content and settings for a message template that can be used in messages that are sent through the voice channel.
    /// This member is required.
    public var voiceTemplateRequest: PinpointClientTypes.VoiceTemplateRequest?

    public init(
        createNewVersion: Swift.Bool? = nil,
        templateName: Swift.String? = nil,
        version: Swift.String? = nil,
        voiceTemplateRequest: PinpointClientTypes.VoiceTemplateRequest? = nil
    )
    {
        self.createNewVersion = createNewVersion
        self.templateName = templateName
        self.version = version
        self.voiceTemplateRequest = voiceTemplateRequest
    }
}

public struct UpdateVoiceTemplateOutput: Swift.Sendable {
    /// Provides information about an API request or response.
    /// This member is required.
    public var messageBody: PinpointClientTypes.MessageBody?

    public init(
        messageBody: PinpointClientTypes.MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

extension PinpointClientTypes {

    /// Verify OTP message request.
    public struct VerifyOTPMessageRequestParameters: Swift.Sendable {
        /// The destination identity to send OTP to.
        /// This member is required.
        public var destinationIdentity: Swift.String?
        /// The OTP the end user provided for verification.
        /// This member is required.
        public var otp: Swift.String?
        /// The reference identifier provided when the OTP was previously sent.
        /// This member is required.
        public var referenceId: Swift.String?

        public init(
            destinationIdentity: Swift.String? = nil,
            otp: Swift.String? = nil,
            referenceId: Swift.String? = nil
        )
        {
            self.destinationIdentity = destinationIdentity
            self.otp = otp
            self.referenceId = referenceId
        }
    }
}

public struct VerifyOTPMessageInput: Swift.Sendable {
    /// The unique ID of your Amazon Pinpoint application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Verify OTP message request.
    /// This member is required.
    public var verifyOTPMessageRequestParameters: PinpointClientTypes.VerifyOTPMessageRequestParameters?

    public init(
        applicationId: Swift.String? = nil,
        verifyOTPMessageRequestParameters: PinpointClientTypes.VerifyOTPMessageRequestParameters? = nil
    )
    {
        self.applicationId = applicationId
        self.verifyOTPMessageRequestParameters = verifyOTPMessageRequestParameters
    }
}

extension PinpointClientTypes {

    /// Verify OTP Message Response.
    public struct VerificationResponse: Swift.Sendable {
        /// Specifies whether the OTP is valid or not.
        public var valid: Swift.Bool?

        public init(
            valid: Swift.Bool? = nil
        )
        {
            self.valid = valid
        }
    }
}

public struct VerifyOTPMessageOutput: Swift.Sendable {
    /// Verify OTP Message Response.
    /// This member is required.
    public var verificationResponse: PinpointClientTypes.VerificationResponse?

    public init(
        verificationResponse: PinpointClientTypes.VerificationResponse? = nil
    )
    {
        self.verificationResponse = verificationResponse
    }
}

extension CreateAppInput {

    static func urlPathProvider(_ value: CreateAppInput) -> Swift.String? {
        return "/v1/apps"
    }
}

extension CreateCampaignInput {

    static func urlPathProvider(_ value: CreateCampaignInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/campaigns"
    }
}

extension CreateEmailTemplateInput {

    static func urlPathProvider(_ value: CreateEmailTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/email"
    }
}

extension CreateExportJobInput {

    static func urlPathProvider(_ value: CreateExportJobInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/jobs/export"
    }
}

extension CreateImportJobInput {

    static func urlPathProvider(_ value: CreateImportJobInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/jobs/import"
    }
}

extension CreateInAppTemplateInput {

    static func urlPathProvider(_ value: CreateInAppTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/inapp"
    }
}

extension CreateJourneyInput {

    static func urlPathProvider(_ value: CreateJourneyInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/journeys"
    }
}

extension CreatePushTemplateInput {

    static func urlPathProvider(_ value: CreatePushTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/push"
    }
}

extension CreateRecommenderConfigurationInput {

    static func urlPathProvider(_ value: CreateRecommenderConfigurationInput) -> Swift.String? {
        return "/v1/recommenders"
    }
}

extension CreateSegmentInput {

    static func urlPathProvider(_ value: CreateSegmentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/segments"
    }
}

extension CreateSmsTemplateInput {

    static func urlPathProvider(_ value: CreateSmsTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/sms"
    }
}

extension CreateVoiceTemplateInput {

    static func urlPathProvider(_ value: CreateVoiceTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/voice"
    }
}

extension DeleteAdmChannelInput {

    static func urlPathProvider(_ value: DeleteAdmChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/adm"
    }
}

extension DeleteApnsChannelInput {

    static func urlPathProvider(_ value: DeleteApnsChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/apns"
    }
}

extension DeleteApnsSandboxChannelInput {

    static func urlPathProvider(_ value: DeleteApnsSandboxChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/apns_sandbox"
    }
}

extension DeleteApnsVoipChannelInput {

    static func urlPathProvider(_ value: DeleteApnsVoipChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/apns_voip"
    }
}

extension DeleteApnsVoipSandboxChannelInput {

    static func urlPathProvider(_ value: DeleteApnsVoipSandboxChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/apns_voip_sandbox"
    }
}

extension DeleteAppInput {

    static func urlPathProvider(_ value: DeleteAppInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())"
    }
}

extension DeleteBaiduChannelInput {

    static func urlPathProvider(_ value: DeleteBaiduChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/baidu"
    }
}

extension DeleteCampaignInput {

    static func urlPathProvider(_ value: DeleteCampaignInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let campaignId = value.campaignId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/campaigns/\(campaignId.urlPercentEncoding())"
    }
}

extension DeleteEmailChannelInput {

    static func urlPathProvider(_ value: DeleteEmailChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/email"
    }
}

extension DeleteEmailTemplateInput {

    static func urlPathProvider(_ value: DeleteEmailTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/email"
    }
}

extension DeleteEmailTemplateInput {

    static func queryItemProvider(_ value: DeleteEmailTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        return items
    }
}

extension DeleteEndpointInput {

    static func urlPathProvider(_ value: DeleteEndpointInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let endpointId = value.endpointId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/endpoints/\(endpointId.urlPercentEncoding())"
    }
}

extension DeleteEventStreamInput {

    static func urlPathProvider(_ value: DeleteEventStreamInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/eventstream"
    }
}

extension DeleteGcmChannelInput {

    static func urlPathProvider(_ value: DeleteGcmChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/gcm"
    }
}

extension DeleteInAppTemplateInput {

    static func urlPathProvider(_ value: DeleteInAppTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/inapp"
    }
}

extension DeleteInAppTemplateInput {

    static func queryItemProvider(_ value: DeleteInAppTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        return items
    }
}

extension DeleteJourneyInput {

    static func urlPathProvider(_ value: DeleteJourneyInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let journeyId = value.journeyId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/journeys/\(journeyId.urlPercentEncoding())"
    }
}

extension DeletePushTemplateInput {

    static func urlPathProvider(_ value: DeletePushTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/push"
    }
}

extension DeletePushTemplateInput {

    static func queryItemProvider(_ value: DeletePushTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        return items
    }
}

extension DeleteRecommenderConfigurationInput {

    static func urlPathProvider(_ value: DeleteRecommenderConfigurationInput) -> Swift.String? {
        guard let recommenderId = value.recommenderId else {
            return nil
        }
        return "/v1/recommenders/\(recommenderId.urlPercentEncoding())"
    }
}

extension DeleteSegmentInput {

    static func urlPathProvider(_ value: DeleteSegmentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let segmentId = value.segmentId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/segments/\(segmentId.urlPercentEncoding())"
    }
}

extension DeleteSmsChannelInput {

    static func urlPathProvider(_ value: DeleteSmsChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/sms"
    }
}

extension DeleteSmsTemplateInput {

    static func urlPathProvider(_ value: DeleteSmsTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/sms"
    }
}

extension DeleteSmsTemplateInput {

    static func queryItemProvider(_ value: DeleteSmsTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        return items
    }
}

extension DeleteUserEndpointsInput {

    static func urlPathProvider(_ value: DeleteUserEndpointsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

extension DeleteVoiceChannelInput {

    static func urlPathProvider(_ value: DeleteVoiceChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/voice"
    }
}

extension DeleteVoiceTemplateInput {

    static func urlPathProvider(_ value: DeleteVoiceTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/voice"
    }
}

extension DeleteVoiceTemplateInput {

    static func queryItemProvider(_ value: DeleteVoiceTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        return items
    }
}

extension GetAdmChannelInput {

    static func urlPathProvider(_ value: GetAdmChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/adm"
    }
}

extension GetApnsChannelInput {

    static func urlPathProvider(_ value: GetApnsChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/apns"
    }
}

extension GetApnsSandboxChannelInput {

    static func urlPathProvider(_ value: GetApnsSandboxChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/apns_sandbox"
    }
}

extension GetApnsVoipChannelInput {

    static func urlPathProvider(_ value: GetApnsVoipChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/apns_voip"
    }
}

extension GetApnsVoipSandboxChannelInput {

    static func urlPathProvider(_ value: GetApnsVoipSandboxChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/apns_voip_sandbox"
    }
}

extension GetAppInput {

    static func urlPathProvider(_ value: GetAppInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())"
    }
}

extension GetApplicationDateRangeKpiInput {

    static func urlPathProvider(_ value: GetApplicationDateRangeKpiInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let kpiName = value.kpiName else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/kpis/daterange/\(kpiName.urlPercentEncoding())"
    }
}

extension GetApplicationDateRangeKpiInput {

    static func queryItemProvider(_ value: GetApplicationDateRangeKpiInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let endTime = value.endTime {
            let endTimeQueryItem = Smithy.URIQueryItem(name: "end-time".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let startTime = value.startTime {
            let startTimeQueryItem = Smithy.URIQueryItem(name: "start-time".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
        }
        return items
    }
}

extension GetApplicationSettingsInput {

    static func urlPathProvider(_ value: GetApplicationSettingsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/settings"
    }
}

extension GetAppsInput {

    static func urlPathProvider(_ value: GetAppsInput) -> Swift.String? {
        return "/v1/apps"
    }
}

extension GetAppsInput {

    static func queryItemProvider(_ value: GetAppsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let token = value.token {
            let tokenQueryItem = Smithy.URIQueryItem(name: "token".urlPercentEncoding(), value: Swift.String(token).urlPercentEncoding())
            items.append(tokenQueryItem)
        }
        return items
    }
}

extension GetBaiduChannelInput {

    static func urlPathProvider(_ value: GetBaiduChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/baidu"
    }
}

extension GetCampaignInput {

    static func urlPathProvider(_ value: GetCampaignInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let campaignId = value.campaignId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/campaigns/\(campaignId.urlPercentEncoding())"
    }
}

extension GetCampaignActivitiesInput {

    static func urlPathProvider(_ value: GetCampaignActivitiesInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let campaignId = value.campaignId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/campaigns/\(campaignId.urlPercentEncoding())/activities"
    }
}

extension GetCampaignActivitiesInput {

    static func queryItemProvider(_ value: GetCampaignActivitiesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let token = value.token {
            let tokenQueryItem = Smithy.URIQueryItem(name: "token".urlPercentEncoding(), value: Swift.String(token).urlPercentEncoding())
            items.append(tokenQueryItem)
        }
        return items
    }
}

extension GetCampaignDateRangeKpiInput {

    static func urlPathProvider(_ value: GetCampaignDateRangeKpiInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let campaignId = value.campaignId else {
            return nil
        }
        guard let kpiName = value.kpiName else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/campaigns/\(campaignId.urlPercentEncoding())/kpis/daterange/\(kpiName.urlPercentEncoding())"
    }
}

extension GetCampaignDateRangeKpiInput {

    static func queryItemProvider(_ value: GetCampaignDateRangeKpiInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let endTime = value.endTime {
            let endTimeQueryItem = Smithy.URIQueryItem(name: "end-time".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let startTime = value.startTime {
            let startTimeQueryItem = Smithy.URIQueryItem(name: "start-time".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
        }
        return items
    }
}

extension GetCampaignsInput {

    static func urlPathProvider(_ value: GetCampaignsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/campaigns"
    }
}

extension GetCampaignsInput {

    static func queryItemProvider(_ value: GetCampaignsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let token = value.token {
            let tokenQueryItem = Smithy.URIQueryItem(name: "token".urlPercentEncoding(), value: Swift.String(token).urlPercentEncoding())
            items.append(tokenQueryItem)
        }
        return items
    }
}

extension GetCampaignVersionInput {

    static func urlPathProvider(_ value: GetCampaignVersionInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let campaignId = value.campaignId else {
            return nil
        }
        guard let version = value.version else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/campaigns/\(campaignId.urlPercentEncoding())/versions/\(version.urlPercentEncoding())"
    }
}

extension GetCampaignVersionsInput {

    static func urlPathProvider(_ value: GetCampaignVersionsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let campaignId = value.campaignId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/campaigns/\(campaignId.urlPercentEncoding())/versions"
    }
}

extension GetCampaignVersionsInput {

    static func queryItemProvider(_ value: GetCampaignVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let token = value.token {
            let tokenQueryItem = Smithy.URIQueryItem(name: "token".urlPercentEncoding(), value: Swift.String(token).urlPercentEncoding())
            items.append(tokenQueryItem)
        }
        return items
    }
}

extension GetChannelsInput {

    static func urlPathProvider(_ value: GetChannelsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels"
    }
}

extension GetEmailChannelInput {

    static func urlPathProvider(_ value: GetEmailChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/email"
    }
}

extension GetEmailTemplateInput {

    static func urlPathProvider(_ value: GetEmailTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/email"
    }
}

extension GetEmailTemplateInput {

    static func queryItemProvider(_ value: GetEmailTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        return items
    }
}

extension GetEndpointInput {

    static func urlPathProvider(_ value: GetEndpointInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let endpointId = value.endpointId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/endpoints/\(endpointId.urlPercentEncoding())"
    }
}

extension GetEventStreamInput {

    static func urlPathProvider(_ value: GetEventStreamInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/eventstream"
    }
}

extension GetExportJobInput {

    static func urlPathProvider(_ value: GetExportJobInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/jobs/export/\(jobId.urlPercentEncoding())"
    }
}

extension GetExportJobsInput {

    static func urlPathProvider(_ value: GetExportJobsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/jobs/export"
    }
}

extension GetExportJobsInput {

    static func queryItemProvider(_ value: GetExportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let token = value.token {
            let tokenQueryItem = Smithy.URIQueryItem(name: "token".urlPercentEncoding(), value: Swift.String(token).urlPercentEncoding())
            items.append(tokenQueryItem)
        }
        return items
    }
}

extension GetGcmChannelInput {

    static func urlPathProvider(_ value: GetGcmChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/gcm"
    }
}

extension GetImportJobInput {

    static func urlPathProvider(_ value: GetImportJobInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/jobs/import/\(jobId.urlPercentEncoding())"
    }
}

extension GetImportJobsInput {

    static func urlPathProvider(_ value: GetImportJobsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/jobs/import"
    }
}

extension GetImportJobsInput {

    static func queryItemProvider(_ value: GetImportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let token = value.token {
            let tokenQueryItem = Smithy.URIQueryItem(name: "token".urlPercentEncoding(), value: Swift.String(token).urlPercentEncoding())
            items.append(tokenQueryItem)
        }
        return items
    }
}

extension GetInAppMessagesInput {

    static func urlPathProvider(_ value: GetInAppMessagesInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let endpointId = value.endpointId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/endpoints/\(endpointId.urlPercentEncoding())/inappmessages"
    }
}

extension GetInAppTemplateInput {

    static func urlPathProvider(_ value: GetInAppTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/inapp"
    }
}

extension GetInAppTemplateInput {

    static func queryItemProvider(_ value: GetInAppTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        return items
    }
}

extension GetJourneyInput {

    static func urlPathProvider(_ value: GetJourneyInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let journeyId = value.journeyId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/journeys/\(journeyId.urlPercentEncoding())"
    }
}

extension GetJourneyDateRangeKpiInput {

    static func urlPathProvider(_ value: GetJourneyDateRangeKpiInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let journeyId = value.journeyId else {
            return nil
        }
        guard let kpiName = value.kpiName else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/journeys/\(journeyId.urlPercentEncoding())/kpis/daterange/\(kpiName.urlPercentEncoding())"
    }
}

extension GetJourneyDateRangeKpiInput {

    static func queryItemProvider(_ value: GetJourneyDateRangeKpiInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let endTime = value.endTime {
            let endTimeQueryItem = Smithy.URIQueryItem(name: "end-time".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let startTime = value.startTime {
            let startTimeQueryItem = Smithy.URIQueryItem(name: "start-time".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
        }
        return items
    }
}

extension GetJourneyExecutionActivityMetricsInput {

    static func urlPathProvider(_ value: GetJourneyExecutionActivityMetricsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let journeyId = value.journeyId else {
            return nil
        }
        guard let journeyActivityId = value.journeyActivityId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/journeys/\(journeyId.urlPercentEncoding())/activities/\(journeyActivityId.urlPercentEncoding())/execution-metrics"
    }
}

extension GetJourneyExecutionActivityMetricsInput {

    static func queryItemProvider(_ value: GetJourneyExecutionActivityMetricsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension GetJourneyExecutionMetricsInput {

    static func urlPathProvider(_ value: GetJourneyExecutionMetricsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let journeyId = value.journeyId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/journeys/\(journeyId.urlPercentEncoding())/execution-metrics"
    }
}

extension GetJourneyExecutionMetricsInput {

    static func queryItemProvider(_ value: GetJourneyExecutionMetricsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension GetJourneyRunExecutionActivityMetricsInput {

    static func urlPathProvider(_ value: GetJourneyRunExecutionActivityMetricsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let journeyId = value.journeyId else {
            return nil
        }
        guard let runId = value.runId else {
            return nil
        }
        guard let journeyActivityId = value.journeyActivityId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/journeys/\(journeyId.urlPercentEncoding())/runs/\(runId.urlPercentEncoding())/activities/\(journeyActivityId.urlPercentEncoding())/execution-metrics"
    }
}

extension GetJourneyRunExecutionActivityMetricsInput {

    static func queryItemProvider(_ value: GetJourneyRunExecutionActivityMetricsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension GetJourneyRunExecutionMetricsInput {

    static func urlPathProvider(_ value: GetJourneyRunExecutionMetricsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let journeyId = value.journeyId else {
            return nil
        }
        guard let runId = value.runId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/journeys/\(journeyId.urlPercentEncoding())/runs/\(runId.urlPercentEncoding())/execution-metrics"
    }
}

extension GetJourneyRunExecutionMetricsInput {

    static func queryItemProvider(_ value: GetJourneyRunExecutionMetricsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension GetJourneyRunsInput {

    static func urlPathProvider(_ value: GetJourneyRunsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let journeyId = value.journeyId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/journeys/\(journeyId.urlPercentEncoding())/runs"
    }
}

extension GetJourneyRunsInput {

    static func queryItemProvider(_ value: GetJourneyRunsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let token = value.token {
            let tokenQueryItem = Smithy.URIQueryItem(name: "token".urlPercentEncoding(), value: Swift.String(token).urlPercentEncoding())
            items.append(tokenQueryItem)
        }
        return items
    }
}

extension GetPushTemplateInput {

    static func urlPathProvider(_ value: GetPushTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/push"
    }
}

extension GetPushTemplateInput {

    static func queryItemProvider(_ value: GetPushTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        return items
    }
}

extension GetRecommenderConfigurationInput {

    static func urlPathProvider(_ value: GetRecommenderConfigurationInput) -> Swift.String? {
        guard let recommenderId = value.recommenderId else {
            return nil
        }
        return "/v1/recommenders/\(recommenderId.urlPercentEncoding())"
    }
}

extension GetRecommenderConfigurationsInput {

    static func urlPathProvider(_ value: GetRecommenderConfigurationsInput) -> Swift.String? {
        return "/v1/recommenders"
    }
}

extension GetRecommenderConfigurationsInput {

    static func queryItemProvider(_ value: GetRecommenderConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let token = value.token {
            let tokenQueryItem = Smithy.URIQueryItem(name: "token".urlPercentEncoding(), value: Swift.String(token).urlPercentEncoding())
            items.append(tokenQueryItem)
        }
        return items
    }
}

extension GetSegmentInput {

    static func urlPathProvider(_ value: GetSegmentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let segmentId = value.segmentId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/segments/\(segmentId.urlPercentEncoding())"
    }
}

extension GetSegmentExportJobsInput {

    static func urlPathProvider(_ value: GetSegmentExportJobsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let segmentId = value.segmentId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/segments/\(segmentId.urlPercentEncoding())/jobs/export"
    }
}

extension GetSegmentExportJobsInput {

    static func queryItemProvider(_ value: GetSegmentExportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let token = value.token {
            let tokenQueryItem = Smithy.URIQueryItem(name: "token".urlPercentEncoding(), value: Swift.String(token).urlPercentEncoding())
            items.append(tokenQueryItem)
        }
        return items
    }
}

extension GetSegmentImportJobsInput {

    static func urlPathProvider(_ value: GetSegmentImportJobsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let segmentId = value.segmentId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/segments/\(segmentId.urlPercentEncoding())/jobs/import"
    }
}

extension GetSegmentImportJobsInput {

    static func queryItemProvider(_ value: GetSegmentImportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let token = value.token {
            let tokenQueryItem = Smithy.URIQueryItem(name: "token".urlPercentEncoding(), value: Swift.String(token).urlPercentEncoding())
            items.append(tokenQueryItem)
        }
        return items
    }
}

extension GetSegmentsInput {

    static func urlPathProvider(_ value: GetSegmentsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/segments"
    }
}

extension GetSegmentsInput {

    static func queryItemProvider(_ value: GetSegmentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let token = value.token {
            let tokenQueryItem = Smithy.URIQueryItem(name: "token".urlPercentEncoding(), value: Swift.String(token).urlPercentEncoding())
            items.append(tokenQueryItem)
        }
        return items
    }
}

extension GetSegmentVersionInput {

    static func urlPathProvider(_ value: GetSegmentVersionInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let segmentId = value.segmentId else {
            return nil
        }
        guard let version = value.version else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/segments/\(segmentId.urlPercentEncoding())/versions/\(version.urlPercentEncoding())"
    }
}

extension GetSegmentVersionsInput {

    static func urlPathProvider(_ value: GetSegmentVersionsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let segmentId = value.segmentId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/segments/\(segmentId.urlPercentEncoding())/versions"
    }
}

extension GetSegmentVersionsInput {

    static func queryItemProvider(_ value: GetSegmentVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let token = value.token {
            let tokenQueryItem = Smithy.URIQueryItem(name: "token".urlPercentEncoding(), value: Swift.String(token).urlPercentEncoding())
            items.append(tokenQueryItem)
        }
        return items
    }
}

extension GetSmsChannelInput {

    static func urlPathProvider(_ value: GetSmsChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/sms"
    }
}

extension GetSmsTemplateInput {

    static func urlPathProvider(_ value: GetSmsTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/sms"
    }
}

extension GetSmsTemplateInput {

    static func queryItemProvider(_ value: GetSmsTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        return items
    }
}

extension GetUserEndpointsInput {

    static func urlPathProvider(_ value: GetUserEndpointsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

extension GetVoiceChannelInput {

    static func urlPathProvider(_ value: GetVoiceChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/voice"
    }
}

extension GetVoiceTemplateInput {

    static func urlPathProvider(_ value: GetVoiceTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/voice"
    }
}

extension GetVoiceTemplateInput {

    static func queryItemProvider(_ value: GetVoiceTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        return items
    }
}

extension ListJourneysInput {

    static func urlPathProvider(_ value: ListJourneysInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/journeys"
    }
}

extension ListJourneysInput {

    static func queryItemProvider(_ value: ListJourneysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let token = value.token {
            let tokenQueryItem = Smithy.URIQueryItem(name: "token".urlPercentEncoding(), value: Swift.String(token).urlPercentEncoding())
            items.append(tokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTemplatesInput {

    static func urlPathProvider(_ value: ListTemplatesInput) -> Swift.String? {
        return "/v1/templates"
    }
}

extension ListTemplatesInput {

    static func queryItemProvider(_ value: ListTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let `prefix` = value.`prefix` {
            let prefixQueryItem = Smithy.URIQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
            items.append(prefixQueryItem)
        }
        if let templateType = value.templateType {
            let templateTypeQueryItem = Smithy.URIQueryItem(name: "template-type".urlPercentEncoding(), value: Swift.String(templateType).urlPercentEncoding())
            items.append(templateTypeQueryItem)
        }
        return items
    }
}

extension ListTemplateVersionsInput {

    static func urlPathProvider(_ value: ListTemplateVersionsInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        guard let templateType = value.templateType else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/\(templateType.urlPercentEncoding())/versions"
    }
}

extension ListTemplateVersionsInput {

    static func queryItemProvider(_ value: ListTemplateVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "page-size".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension PhoneNumberValidateInput {

    static func urlPathProvider(_ value: PhoneNumberValidateInput) -> Swift.String? {
        return "/v1/phone/number/validate"
    }
}

extension PutEventsInput {

    static func urlPathProvider(_ value: PutEventsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/events"
    }
}

extension PutEventStreamInput {

    static func urlPathProvider(_ value: PutEventStreamInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/eventstream"
    }
}

extension RemoveAttributesInput {

    static func urlPathProvider(_ value: RemoveAttributesInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let attributeType = value.attributeType else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/attributes/\(attributeType.urlPercentEncoding())"
    }
}

extension SendMessagesInput {

    static func urlPathProvider(_ value: SendMessagesInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/messages"
    }
}

extension SendOTPMessageInput {

    static func urlPathProvider(_ value: SendOTPMessageInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/otp"
    }
}

extension SendUsersMessagesInput {

    static func urlPathProvider(_ value: SendUsersMessagesInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/users-messages"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAdmChannelInput {

    static func urlPathProvider(_ value: UpdateAdmChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/adm"
    }
}

extension UpdateApnsChannelInput {

    static func urlPathProvider(_ value: UpdateApnsChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/apns"
    }
}

extension UpdateApnsSandboxChannelInput {

    static func urlPathProvider(_ value: UpdateApnsSandboxChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/apns_sandbox"
    }
}

extension UpdateApnsVoipChannelInput {

    static func urlPathProvider(_ value: UpdateApnsVoipChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/apns_voip"
    }
}

extension UpdateApnsVoipSandboxChannelInput {

    static func urlPathProvider(_ value: UpdateApnsVoipSandboxChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/apns_voip_sandbox"
    }
}

extension UpdateApplicationSettingsInput {

    static func urlPathProvider(_ value: UpdateApplicationSettingsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/settings"
    }
}

extension UpdateBaiduChannelInput {

    static func urlPathProvider(_ value: UpdateBaiduChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/baidu"
    }
}

extension UpdateCampaignInput {

    static func urlPathProvider(_ value: UpdateCampaignInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let campaignId = value.campaignId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/campaigns/\(campaignId.urlPercentEncoding())"
    }
}

extension UpdateEmailChannelInput {

    static func urlPathProvider(_ value: UpdateEmailChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/email"
    }
}

extension UpdateEmailTemplateInput {

    static func urlPathProvider(_ value: UpdateEmailTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/email"
    }
}

extension UpdateEmailTemplateInput {

    static func queryItemProvider(_ value: UpdateEmailTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        if let createNewVersion = value.createNewVersion {
            let createNewVersionQueryItem = Smithy.URIQueryItem(name: "create-new-version".urlPercentEncoding(), value: Swift.String(createNewVersion).urlPercentEncoding())
            items.append(createNewVersionQueryItem)
        }
        return items
    }
}

extension UpdateEndpointInput {

    static func urlPathProvider(_ value: UpdateEndpointInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let endpointId = value.endpointId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/endpoints/\(endpointId.urlPercentEncoding())"
    }
}

extension UpdateEndpointsBatchInput {

    static func urlPathProvider(_ value: UpdateEndpointsBatchInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/endpoints"
    }
}

extension UpdateGcmChannelInput {

    static func urlPathProvider(_ value: UpdateGcmChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/gcm"
    }
}

extension UpdateInAppTemplateInput {

    static func urlPathProvider(_ value: UpdateInAppTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/inapp"
    }
}

extension UpdateInAppTemplateInput {

    static func queryItemProvider(_ value: UpdateInAppTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        if let createNewVersion = value.createNewVersion {
            let createNewVersionQueryItem = Smithy.URIQueryItem(name: "create-new-version".urlPercentEncoding(), value: Swift.String(createNewVersion).urlPercentEncoding())
            items.append(createNewVersionQueryItem)
        }
        return items
    }
}

extension UpdateJourneyInput {

    static func urlPathProvider(_ value: UpdateJourneyInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let journeyId = value.journeyId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/journeys/\(journeyId.urlPercentEncoding())"
    }
}

extension UpdateJourneyStateInput {

    static func urlPathProvider(_ value: UpdateJourneyStateInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let journeyId = value.journeyId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/journeys/\(journeyId.urlPercentEncoding())/state"
    }
}

extension UpdatePushTemplateInput {

    static func urlPathProvider(_ value: UpdatePushTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/push"
    }
}

extension UpdatePushTemplateInput {

    static func queryItemProvider(_ value: UpdatePushTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        if let createNewVersion = value.createNewVersion {
            let createNewVersionQueryItem = Smithy.URIQueryItem(name: "create-new-version".urlPercentEncoding(), value: Swift.String(createNewVersion).urlPercentEncoding())
            items.append(createNewVersionQueryItem)
        }
        return items
    }
}

extension UpdateRecommenderConfigurationInput {

    static func urlPathProvider(_ value: UpdateRecommenderConfigurationInput) -> Swift.String? {
        guard let recommenderId = value.recommenderId else {
            return nil
        }
        return "/v1/recommenders/\(recommenderId.urlPercentEncoding())"
    }
}

extension UpdateSegmentInput {

    static func urlPathProvider(_ value: UpdateSegmentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let segmentId = value.segmentId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/segments/\(segmentId.urlPercentEncoding())"
    }
}

extension UpdateSmsChannelInput {

    static func urlPathProvider(_ value: UpdateSmsChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/sms"
    }
}

extension UpdateSmsTemplateInput {

    static func urlPathProvider(_ value: UpdateSmsTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/sms"
    }
}

extension UpdateSmsTemplateInput {

    static func queryItemProvider(_ value: UpdateSmsTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        if let createNewVersion = value.createNewVersion {
            let createNewVersionQueryItem = Smithy.URIQueryItem(name: "create-new-version".urlPercentEncoding(), value: Swift.String(createNewVersion).urlPercentEncoding())
            items.append(createNewVersionQueryItem)
        }
        return items
    }
}

extension UpdateTemplateActiveVersionInput {

    static func urlPathProvider(_ value: UpdateTemplateActiveVersionInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        guard let templateType = value.templateType else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/\(templateType.urlPercentEncoding())/active-version"
    }
}

extension UpdateVoiceChannelInput {

    static func urlPathProvider(_ value: UpdateVoiceChannelInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/channels/voice"
    }
}

extension UpdateVoiceTemplateInput {

    static func urlPathProvider(_ value: UpdateVoiceTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/v1/templates/\(templateName.urlPercentEncoding())/voice"
    }
}

extension UpdateVoiceTemplateInput {

    static func queryItemProvider(_ value: UpdateVoiceTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let version = value.version {
            let versionQueryItem = Smithy.URIQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(version).urlPercentEncoding())
            items.append(versionQueryItem)
        }
        if let createNewVersion = value.createNewVersion {
            let createNewVersionQueryItem = Smithy.URIQueryItem(name: "create-new-version".urlPercentEncoding(), value: Swift.String(createNewVersion).urlPercentEncoding())
            items.append(createNewVersionQueryItem)
        }
        return items
    }
}

extension VerifyOTPMessageInput {

    static func urlPathProvider(_ value: VerifyOTPMessageInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/v1/apps/\(applicationId.urlPercentEncoding())/verify-otp"
    }
}

extension CreateAppInput {

    static func write(value: CreateAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreateApplicationRequest"].write(value.createApplicationRequest, with: PinpointClientTypes.CreateApplicationRequest.write(value:to:))
    }
}

extension CreateCampaignInput {

    static func write(value: CreateCampaignInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WriteCampaignRequest"].write(value.writeCampaignRequest, with: PinpointClientTypes.WriteCampaignRequest.write(value:to:))
    }
}

extension CreateEmailTemplateInput {

    static func write(value: CreateEmailTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EmailTemplateRequest"].write(value.emailTemplateRequest, with: PinpointClientTypes.EmailTemplateRequest.write(value:to:))
    }
}

extension CreateExportJobInput {

    static func write(value: CreateExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExportJobRequest"].write(value.exportJobRequest, with: PinpointClientTypes.ExportJobRequest.write(value:to:))
    }
}

extension CreateImportJobInput {

    static func write(value: CreateImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImportJobRequest"].write(value.importJobRequest, with: PinpointClientTypes.ImportJobRequest.write(value:to:))
    }
}

extension CreateInAppTemplateInput {

    static func write(value: CreateInAppTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InAppTemplateRequest"].write(value.inAppTemplateRequest, with: PinpointClientTypes.InAppTemplateRequest.write(value:to:))
    }
}

extension CreateJourneyInput {

    static func write(value: CreateJourneyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WriteJourneyRequest"].write(value.writeJourneyRequest, with: PinpointClientTypes.WriteJourneyRequest.write(value:to:))
    }
}

extension CreatePushTemplateInput {

    static func write(value: CreatePushTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PushNotificationTemplateRequest"].write(value.pushNotificationTemplateRequest, with: PinpointClientTypes.PushNotificationTemplateRequest.write(value:to:))
    }
}

extension CreateRecommenderConfigurationInput {

    static func write(value: CreateRecommenderConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreateRecommenderConfiguration"].write(value.createRecommenderConfiguration, with: PinpointClientTypes.CreateRecommenderConfigurationShape.write(value:to:))
    }
}

extension CreateSegmentInput {

    static func write(value: CreateSegmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WriteSegmentRequest"].write(value.writeSegmentRequest, with: PinpointClientTypes.WriteSegmentRequest.write(value:to:))
    }
}

extension CreateSmsTemplateInput {

    static func write(value: CreateSmsTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SMSTemplateRequest"].write(value.smsTemplateRequest, with: PinpointClientTypes.SMSTemplateRequest.write(value:to:))
    }
}

extension CreateVoiceTemplateInput {

    static func write(value: CreateVoiceTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VoiceTemplateRequest"].write(value.voiceTemplateRequest, with: PinpointClientTypes.VoiceTemplateRequest.write(value:to:))
    }
}

extension PhoneNumberValidateInput {

    static func write(value: PhoneNumberValidateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NumberValidateRequest"].write(value.numberValidateRequest, with: PinpointClientTypes.NumberValidateRequest.write(value:to:))
    }
}

extension PutEventsInput {

    static func write(value: PutEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventsRequest"].write(value.eventsRequest, with: PinpointClientTypes.EventsRequest.write(value:to:))
    }
}

extension PutEventStreamInput {

    static func write(value: PutEventStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WriteEventStream"].write(value.writeEventStream, with: PinpointClientTypes.WriteEventStream.write(value:to:))
    }
}

extension RemoveAttributesInput {

    static func write(value: RemoveAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UpdateAttributesRequest"].write(value.updateAttributesRequest, with: PinpointClientTypes.UpdateAttributesRequest.write(value:to:))
    }
}

extension SendMessagesInput {

    static func write(value: SendMessagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MessageRequest"].write(value.messageRequest, with: PinpointClientTypes.MessageRequest.write(value:to:))
    }
}

extension SendOTPMessageInput {

    static func write(value: SendOTPMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SendOTPMessageRequestParameters"].write(value.sendOTPMessageRequestParameters, with: PinpointClientTypes.SendOTPMessageRequestParameters.write(value:to:))
    }
}

extension SendUsersMessagesInput {

    static func write(value: SendUsersMessagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SendUsersMessageRequest"].write(value.sendUsersMessageRequest, with: PinpointClientTypes.SendUsersMessageRequest.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagsModel"].write(value.tagsModel, with: PinpointClientTypes.TagsModel.write(value:to:))
    }
}

extension UpdateAdmChannelInput {

    static func write(value: UpdateAdmChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ADMChannelRequest"].write(value.admChannelRequest, with: PinpointClientTypes.ADMChannelRequest.write(value:to:))
    }
}

extension UpdateApnsChannelInput {

    static func write(value: UpdateApnsChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["APNSChannelRequest"].write(value.apnsChannelRequest, with: PinpointClientTypes.APNSChannelRequest.write(value:to:))
    }
}

extension UpdateApnsSandboxChannelInput {

    static func write(value: UpdateApnsSandboxChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["APNSSandboxChannelRequest"].write(value.apnsSandboxChannelRequest, with: PinpointClientTypes.APNSSandboxChannelRequest.write(value:to:))
    }
}

extension UpdateApnsVoipChannelInput {

    static func write(value: UpdateApnsVoipChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["APNSVoipChannelRequest"].write(value.apnsVoipChannelRequest, with: PinpointClientTypes.APNSVoipChannelRequest.write(value:to:))
    }
}

extension UpdateApnsVoipSandboxChannelInput {

    static func write(value: UpdateApnsVoipSandboxChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["APNSVoipSandboxChannelRequest"].write(value.apnsVoipSandboxChannelRequest, with: PinpointClientTypes.APNSVoipSandboxChannelRequest.write(value:to:))
    }
}

extension UpdateApplicationSettingsInput {

    static func write(value: UpdateApplicationSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WriteApplicationSettingsRequest"].write(value.writeApplicationSettingsRequest, with: PinpointClientTypes.WriteApplicationSettingsRequest.write(value:to:))
    }
}

extension UpdateBaiduChannelInput {

    static func write(value: UpdateBaiduChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaiduChannelRequest"].write(value.baiduChannelRequest, with: PinpointClientTypes.BaiduChannelRequest.write(value:to:))
    }
}

extension UpdateCampaignInput {

    static func write(value: UpdateCampaignInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WriteCampaignRequest"].write(value.writeCampaignRequest, with: PinpointClientTypes.WriteCampaignRequest.write(value:to:))
    }
}

extension UpdateEmailChannelInput {

    static func write(value: UpdateEmailChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EmailChannelRequest"].write(value.emailChannelRequest, with: PinpointClientTypes.EmailChannelRequest.write(value:to:))
    }
}

extension UpdateEmailTemplateInput {

    static func write(value: UpdateEmailTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EmailTemplateRequest"].write(value.emailTemplateRequest, with: PinpointClientTypes.EmailTemplateRequest.write(value:to:))
    }
}

extension UpdateEndpointInput {

    static func write(value: UpdateEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointRequest"].write(value.endpointRequest, with: PinpointClientTypes.EndpointRequest.write(value:to:))
    }
}

extension UpdateEndpointsBatchInput {

    static func write(value: UpdateEndpointsBatchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointBatchRequest"].write(value.endpointBatchRequest, with: PinpointClientTypes.EndpointBatchRequest.write(value:to:))
    }
}

extension UpdateGcmChannelInput {

    static func write(value: UpdateGcmChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GCMChannelRequest"].write(value.gcmChannelRequest, with: PinpointClientTypes.GCMChannelRequest.write(value:to:))
    }
}

extension UpdateInAppTemplateInput {

    static func write(value: UpdateInAppTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InAppTemplateRequest"].write(value.inAppTemplateRequest, with: PinpointClientTypes.InAppTemplateRequest.write(value:to:))
    }
}

extension UpdateJourneyInput {

    static func write(value: UpdateJourneyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WriteJourneyRequest"].write(value.writeJourneyRequest, with: PinpointClientTypes.WriteJourneyRequest.write(value:to:))
    }
}

extension UpdateJourneyStateInput {

    static func write(value: UpdateJourneyStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JourneyStateRequest"].write(value.journeyStateRequest, with: PinpointClientTypes.JourneyStateRequest.write(value:to:))
    }
}

extension UpdatePushTemplateInput {

    static func write(value: UpdatePushTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PushNotificationTemplateRequest"].write(value.pushNotificationTemplateRequest, with: PinpointClientTypes.PushNotificationTemplateRequest.write(value:to:))
    }
}

extension UpdateRecommenderConfigurationInput {

    static func write(value: UpdateRecommenderConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UpdateRecommenderConfiguration"].write(value.updateRecommenderConfiguration, with: PinpointClientTypes.UpdateRecommenderConfigurationShape.write(value:to:))
    }
}

extension UpdateSegmentInput {

    static func write(value: UpdateSegmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WriteSegmentRequest"].write(value.writeSegmentRequest, with: PinpointClientTypes.WriteSegmentRequest.write(value:to:))
    }
}

extension UpdateSmsChannelInput {

    static func write(value: UpdateSmsChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SMSChannelRequest"].write(value.smsChannelRequest, with: PinpointClientTypes.SMSChannelRequest.write(value:to:))
    }
}

extension UpdateSmsTemplateInput {

    static func write(value: UpdateSmsTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SMSTemplateRequest"].write(value.smsTemplateRequest, with: PinpointClientTypes.SMSTemplateRequest.write(value:to:))
    }
}

extension UpdateTemplateActiveVersionInput {

    static func write(value: UpdateTemplateActiveVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TemplateActiveVersionRequest"].write(value.templateActiveVersionRequest, with: PinpointClientTypes.TemplateActiveVersionRequest.write(value:to:))
    }
}

extension UpdateVoiceChannelInput {

    static func write(value: UpdateVoiceChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VoiceChannelRequest"].write(value.voiceChannelRequest, with: PinpointClientTypes.VoiceChannelRequest.write(value:to:))
    }
}

extension UpdateVoiceTemplateInput {

    static func write(value: UpdateVoiceTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VoiceTemplateRequest"].write(value.voiceTemplateRequest, with: PinpointClientTypes.VoiceTemplateRequest.write(value:to:))
    }
}

extension VerifyOTPMessageInput {

    static func write(value: VerifyOTPMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VerifyOTPMessageRequestParameters"].write(value.verifyOTPMessageRequestParameters, with: PinpointClientTypes.VerifyOTPMessageRequestParameters.write(value:to:))
    }
}

extension CreateAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppOutput()
        value.applicationResponse = try reader.readIfPresent(with: PinpointClientTypes.ApplicationResponse.read(from:))
        return value
    }
}

extension CreateCampaignOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCampaignOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCampaignOutput()
        value.campaignResponse = try reader.readIfPresent(with: PinpointClientTypes.CampaignResponse.read(from:))
        return value
    }
}

extension CreateEmailTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEmailTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEmailTemplateOutput()
        value.createTemplateMessageBody = try reader.readIfPresent(with: PinpointClientTypes.CreateTemplateMessageBody.read(from:))
        return value
    }
}

extension CreateExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateExportJobOutput()
        value.exportJobResponse = try reader.readIfPresent(with: PinpointClientTypes.ExportJobResponse.read(from:))
        return value
    }
}

extension CreateImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateImportJobOutput()
        value.importJobResponse = try reader.readIfPresent(with: PinpointClientTypes.ImportJobResponse.read(from:))
        return value
    }
}

extension CreateInAppTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInAppTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInAppTemplateOutput()
        value.templateCreateMessageBody = try reader.readIfPresent(with: PinpointClientTypes.TemplateCreateMessageBody.read(from:))
        return value
    }
}

extension CreateJourneyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateJourneyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateJourneyOutput()
        value.journeyResponse = try reader.readIfPresent(with: PinpointClientTypes.JourneyResponse.read(from:))
        return value
    }
}

extension CreatePushTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePushTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePushTemplateOutput()
        value.createTemplateMessageBody = try reader.readIfPresent(with: PinpointClientTypes.CreateTemplateMessageBody.read(from:))
        return value
    }
}

extension CreateRecommenderConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRecommenderConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRecommenderConfigurationOutput()
        value.recommenderConfigurationResponse = try reader.readIfPresent(with: PinpointClientTypes.RecommenderConfigurationResponse.read(from:))
        return value
    }
}

extension CreateSegmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSegmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSegmentOutput()
        value.segmentResponse = try reader.readIfPresent(with: PinpointClientTypes.SegmentResponse.read(from:))
        return value
    }
}

extension CreateSmsTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSmsTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSmsTemplateOutput()
        value.createTemplateMessageBody = try reader.readIfPresent(with: PinpointClientTypes.CreateTemplateMessageBody.read(from:))
        return value
    }
}

extension CreateVoiceTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVoiceTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVoiceTemplateOutput()
        value.createTemplateMessageBody = try reader.readIfPresent(with: PinpointClientTypes.CreateTemplateMessageBody.read(from:))
        return value
    }
}

extension DeleteAdmChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAdmChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAdmChannelOutput()
        value.admChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.ADMChannelResponse.read(from:))
        return value
    }
}

extension DeleteApnsChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApnsChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteApnsChannelOutput()
        value.apnsChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.APNSChannelResponse.read(from:))
        return value
    }
}

extension DeleteApnsSandboxChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApnsSandboxChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteApnsSandboxChannelOutput()
        value.apnsSandboxChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.APNSSandboxChannelResponse.read(from:))
        return value
    }
}

extension DeleteApnsVoipChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApnsVoipChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteApnsVoipChannelOutput()
        value.apnsVoipChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.APNSVoipChannelResponse.read(from:))
        return value
    }
}

extension DeleteApnsVoipSandboxChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApnsVoipSandboxChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteApnsVoipSandboxChannelOutput()
        value.apnsVoipSandboxChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.APNSVoipSandboxChannelResponse.read(from:))
        return value
    }
}

extension DeleteAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAppOutput()
        value.applicationResponse = try reader.readIfPresent(with: PinpointClientTypes.ApplicationResponse.read(from:))
        return value
    }
}

extension DeleteBaiduChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBaiduChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBaiduChannelOutput()
        value.baiduChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.BaiduChannelResponse.read(from:))
        return value
    }
}

extension DeleteCampaignOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCampaignOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCampaignOutput()
        value.campaignResponse = try reader.readIfPresent(with: PinpointClientTypes.CampaignResponse.read(from:))
        return value
    }
}

extension DeleteEmailChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEmailChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEmailChannelOutput()
        value.emailChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.EmailChannelResponse.read(from:))
        return value
    }
}

extension DeleteEmailTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEmailTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEmailTemplateOutput()
        value.messageBody = try reader.readIfPresent(with: PinpointClientTypes.MessageBody.read(from:))
        return value
    }
}

extension DeleteEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEndpointOutput()
        value.endpointResponse = try reader.readIfPresent(with: PinpointClientTypes.EndpointResponse.read(from:))
        return value
    }
}

extension DeleteEventStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEventStreamOutput()
        value.eventStream = try reader.readIfPresent(with: PinpointClientTypes.EventStream.read(from:))
        return value
    }
}

extension DeleteGcmChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGcmChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGcmChannelOutput()
        value.gcmChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.GCMChannelResponse.read(from:))
        return value
    }
}

extension DeleteInAppTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInAppTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteInAppTemplateOutput()
        value.messageBody = try reader.readIfPresent(with: PinpointClientTypes.MessageBody.read(from:))
        return value
    }
}

extension DeleteJourneyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteJourneyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteJourneyOutput()
        value.journeyResponse = try reader.readIfPresent(with: PinpointClientTypes.JourneyResponse.read(from:))
        return value
    }
}

extension DeletePushTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePushTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePushTemplateOutput()
        value.messageBody = try reader.readIfPresent(with: PinpointClientTypes.MessageBody.read(from:))
        return value
    }
}

extension DeleteRecommenderConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRecommenderConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRecommenderConfigurationOutput()
        value.recommenderConfigurationResponse = try reader.readIfPresent(with: PinpointClientTypes.RecommenderConfigurationResponse.read(from:))
        return value
    }
}

extension DeleteSegmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSegmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSegmentOutput()
        value.segmentResponse = try reader.readIfPresent(with: PinpointClientTypes.SegmentResponse.read(from:))
        return value
    }
}

extension DeleteSmsChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSmsChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSmsChannelOutput()
        value.smsChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.SMSChannelResponse.read(from:))
        return value
    }
}

extension DeleteSmsTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSmsTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSmsTemplateOutput()
        value.messageBody = try reader.readIfPresent(with: PinpointClientTypes.MessageBody.read(from:))
        return value
    }
}

extension DeleteUserEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteUserEndpointsOutput()
        value.endpointsResponse = try reader.readIfPresent(with: PinpointClientTypes.EndpointsResponse.read(from:))
        return value
    }
}

extension DeleteVoiceChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVoiceChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVoiceChannelOutput()
        value.voiceChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.VoiceChannelResponse.read(from:))
        return value
    }
}

extension DeleteVoiceTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVoiceTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVoiceTemplateOutput()
        value.messageBody = try reader.readIfPresent(with: PinpointClientTypes.MessageBody.read(from:))
        return value
    }
}

extension GetAdmChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAdmChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAdmChannelOutput()
        value.admChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.ADMChannelResponse.read(from:))
        return value
    }
}

extension GetApnsChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApnsChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApnsChannelOutput()
        value.apnsChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.APNSChannelResponse.read(from:))
        return value
    }
}

extension GetApnsSandboxChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApnsSandboxChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApnsSandboxChannelOutput()
        value.apnsSandboxChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.APNSSandboxChannelResponse.read(from:))
        return value
    }
}

extension GetApnsVoipChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApnsVoipChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApnsVoipChannelOutput()
        value.apnsVoipChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.APNSVoipChannelResponse.read(from:))
        return value
    }
}

extension GetApnsVoipSandboxChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApnsVoipSandboxChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApnsVoipSandboxChannelOutput()
        value.apnsVoipSandboxChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.APNSVoipSandboxChannelResponse.read(from:))
        return value
    }
}

extension GetAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppOutput()
        value.applicationResponse = try reader.readIfPresent(with: PinpointClientTypes.ApplicationResponse.read(from:))
        return value
    }
}

extension GetApplicationDateRangeKpiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationDateRangeKpiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationDateRangeKpiOutput()
        value.applicationDateRangeKpiResponse = try reader.readIfPresent(with: PinpointClientTypes.ApplicationDateRangeKpiResponse.read(from:))
        return value
    }
}

extension GetApplicationSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationSettingsOutput()
        value.applicationSettingsResource = try reader.readIfPresent(with: PinpointClientTypes.ApplicationSettingsResource.read(from:))
        return value
    }
}

extension GetAppsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppsOutput()
        value.applicationsResponse = try reader.readIfPresent(with: PinpointClientTypes.ApplicationsResponse.read(from:))
        return value
    }
}

extension GetBaiduChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBaiduChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBaiduChannelOutput()
        value.baiduChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.BaiduChannelResponse.read(from:))
        return value
    }
}

extension GetCampaignOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCampaignOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCampaignOutput()
        value.campaignResponse = try reader.readIfPresent(with: PinpointClientTypes.CampaignResponse.read(from:))
        return value
    }
}

extension GetCampaignActivitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCampaignActivitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCampaignActivitiesOutput()
        value.activitiesResponse = try reader.readIfPresent(with: PinpointClientTypes.ActivitiesResponse.read(from:))
        return value
    }
}

extension GetCampaignDateRangeKpiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCampaignDateRangeKpiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCampaignDateRangeKpiOutput()
        value.campaignDateRangeKpiResponse = try reader.readIfPresent(with: PinpointClientTypes.CampaignDateRangeKpiResponse.read(from:))
        return value
    }
}

extension GetCampaignsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCampaignsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCampaignsOutput()
        value.campaignsResponse = try reader.readIfPresent(with: PinpointClientTypes.CampaignsResponse.read(from:))
        return value
    }
}

extension GetCampaignVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCampaignVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCampaignVersionOutput()
        value.campaignResponse = try reader.readIfPresent(with: PinpointClientTypes.CampaignResponse.read(from:))
        return value
    }
}

extension GetCampaignVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCampaignVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCampaignVersionsOutput()
        value.campaignsResponse = try reader.readIfPresent(with: PinpointClientTypes.CampaignsResponse.read(from:))
        return value
    }
}

extension GetChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetChannelsOutput()
        value.channelsResponse = try reader.readIfPresent(with: PinpointClientTypes.ChannelsResponse.read(from:))
        return value
    }
}

extension GetEmailChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEmailChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEmailChannelOutput()
        value.emailChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.EmailChannelResponse.read(from:))
        return value
    }
}

extension GetEmailTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEmailTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEmailTemplateOutput()
        value.emailTemplateResponse = try reader.readIfPresent(with: PinpointClientTypes.EmailTemplateResponse.read(from:))
        return value
    }
}

extension GetEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEndpointOutput()
        value.endpointResponse = try reader.readIfPresent(with: PinpointClientTypes.EndpointResponse.read(from:))
        return value
    }
}

extension GetEventStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventStreamOutput()
        value.eventStream = try reader.readIfPresent(with: PinpointClientTypes.EventStream.read(from:))
        return value
    }
}

extension GetExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExportJobOutput()
        value.exportJobResponse = try reader.readIfPresent(with: PinpointClientTypes.ExportJobResponse.read(from:))
        return value
    }
}

extension GetExportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetExportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExportJobsOutput()
        value.exportJobsResponse = try reader.readIfPresent(with: PinpointClientTypes.ExportJobsResponse.read(from:))
        return value
    }
}

extension GetGcmChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGcmChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGcmChannelOutput()
        value.gcmChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.GCMChannelResponse.read(from:))
        return value
    }
}

extension GetImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImportJobOutput()
        value.importJobResponse = try reader.readIfPresent(with: PinpointClientTypes.ImportJobResponse.read(from:))
        return value
    }
}

extension GetImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImportJobsOutput()
        value.importJobsResponse = try reader.readIfPresent(with: PinpointClientTypes.ImportJobsResponse.read(from:))
        return value
    }
}

extension GetInAppMessagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInAppMessagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInAppMessagesOutput()
        value.inAppMessagesResponse = try reader.readIfPresent(with: PinpointClientTypes.InAppMessagesResponse.read(from:))
        return value
    }
}

extension GetInAppTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInAppTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInAppTemplateOutput()
        value.inAppTemplateResponse = try reader.readIfPresent(with: PinpointClientTypes.InAppTemplateResponse.read(from:))
        return value
    }
}

extension GetJourneyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJourneyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJourneyOutput()
        value.journeyResponse = try reader.readIfPresent(with: PinpointClientTypes.JourneyResponse.read(from:))
        return value
    }
}

extension GetJourneyDateRangeKpiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJourneyDateRangeKpiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJourneyDateRangeKpiOutput()
        value.journeyDateRangeKpiResponse = try reader.readIfPresent(with: PinpointClientTypes.JourneyDateRangeKpiResponse.read(from:))
        return value
    }
}

extension GetJourneyExecutionActivityMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJourneyExecutionActivityMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJourneyExecutionActivityMetricsOutput()
        value.journeyExecutionActivityMetricsResponse = try reader.readIfPresent(with: PinpointClientTypes.JourneyExecutionActivityMetricsResponse.read(from:))
        return value
    }
}

extension GetJourneyExecutionMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJourneyExecutionMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJourneyExecutionMetricsOutput()
        value.journeyExecutionMetricsResponse = try reader.readIfPresent(with: PinpointClientTypes.JourneyExecutionMetricsResponse.read(from:))
        return value
    }
}

extension GetJourneyRunExecutionActivityMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJourneyRunExecutionActivityMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJourneyRunExecutionActivityMetricsOutput()
        value.journeyRunExecutionActivityMetricsResponse = try reader.readIfPresent(with: PinpointClientTypes.JourneyRunExecutionActivityMetricsResponse.read(from:))
        return value
    }
}

extension GetJourneyRunExecutionMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJourneyRunExecutionMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJourneyRunExecutionMetricsOutput()
        value.journeyRunExecutionMetricsResponse = try reader.readIfPresent(with: PinpointClientTypes.JourneyRunExecutionMetricsResponse.read(from:))
        return value
    }
}

extension GetJourneyRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJourneyRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJourneyRunsOutput()
        value.journeyRunsResponse = try reader.readIfPresent(with: PinpointClientTypes.JourneyRunsResponse.read(from:))
        return value
    }
}

extension GetPushTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPushTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPushTemplateOutput()
        value.pushNotificationTemplateResponse = try reader.readIfPresent(with: PinpointClientTypes.PushNotificationTemplateResponse.read(from:))
        return value
    }
}

extension GetRecommenderConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRecommenderConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRecommenderConfigurationOutput()
        value.recommenderConfigurationResponse = try reader.readIfPresent(with: PinpointClientTypes.RecommenderConfigurationResponse.read(from:))
        return value
    }
}

extension GetRecommenderConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRecommenderConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRecommenderConfigurationsOutput()
        value.listRecommenderConfigurationsResponse = try reader.readIfPresent(with: PinpointClientTypes.ListRecommenderConfigurationsResponse.read(from:))
        return value
    }
}

extension GetSegmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSegmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSegmentOutput()
        value.segmentResponse = try reader.readIfPresent(with: PinpointClientTypes.SegmentResponse.read(from:))
        return value
    }
}

extension GetSegmentExportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSegmentExportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSegmentExportJobsOutput()
        value.exportJobsResponse = try reader.readIfPresent(with: PinpointClientTypes.ExportJobsResponse.read(from:))
        return value
    }
}

extension GetSegmentImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSegmentImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSegmentImportJobsOutput()
        value.importJobsResponse = try reader.readIfPresent(with: PinpointClientTypes.ImportJobsResponse.read(from:))
        return value
    }
}

extension GetSegmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSegmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSegmentsOutput()
        value.segmentsResponse = try reader.readIfPresent(with: PinpointClientTypes.SegmentsResponse.read(from:))
        return value
    }
}

extension GetSegmentVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSegmentVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSegmentVersionOutput()
        value.segmentResponse = try reader.readIfPresent(with: PinpointClientTypes.SegmentResponse.read(from:))
        return value
    }
}

extension GetSegmentVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSegmentVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSegmentVersionsOutput()
        value.segmentsResponse = try reader.readIfPresent(with: PinpointClientTypes.SegmentsResponse.read(from:))
        return value
    }
}

extension GetSmsChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSmsChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSmsChannelOutput()
        value.smsChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.SMSChannelResponse.read(from:))
        return value
    }
}

extension GetSmsTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSmsTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSmsTemplateOutput()
        value.smsTemplateResponse = try reader.readIfPresent(with: PinpointClientTypes.SMSTemplateResponse.read(from:))
        return value
    }
}

extension GetUserEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUserEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUserEndpointsOutput()
        value.endpointsResponse = try reader.readIfPresent(with: PinpointClientTypes.EndpointsResponse.read(from:))
        return value
    }
}

extension GetVoiceChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVoiceChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVoiceChannelOutput()
        value.voiceChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.VoiceChannelResponse.read(from:))
        return value
    }
}

extension GetVoiceTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVoiceTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVoiceTemplateOutput()
        value.voiceTemplateResponse = try reader.readIfPresent(with: PinpointClientTypes.VoiceTemplateResponse.read(from:))
        return value
    }
}

extension ListJourneysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJourneysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJourneysOutput()
        value.journeysResponse = try reader.readIfPresent(with: PinpointClientTypes.JourneysResponse.read(from:))
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tagsModel = try reader.readIfPresent(with: PinpointClientTypes.TagsModel.read(from:))
        return value
    }
}

extension ListTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTemplatesOutput()
        value.templatesResponse = try reader.readIfPresent(with: PinpointClientTypes.TemplatesResponse.read(from:))
        return value
    }
}

extension ListTemplateVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTemplateVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTemplateVersionsOutput()
        value.templateVersionsResponse = try reader.readIfPresent(with: PinpointClientTypes.TemplateVersionsResponse.read(from:))
        return value
    }
}

extension PhoneNumberValidateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PhoneNumberValidateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PhoneNumberValidateOutput()
        value.numberValidateResponse = try reader.readIfPresent(with: PinpointClientTypes.NumberValidateResponse.read(from:))
        return value
    }
}

extension PutEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutEventsOutput()
        value.eventsResponse = try reader.readIfPresent(with: PinpointClientTypes.EventsResponse.read(from:))
        return value
    }
}

extension PutEventStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutEventStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutEventStreamOutput()
        value.eventStream = try reader.readIfPresent(with: PinpointClientTypes.EventStream.read(from:))
        return value
    }
}

extension RemoveAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveAttributesOutput()
        value.attributesResource = try reader.readIfPresent(with: PinpointClientTypes.AttributesResource.read(from:))
        return value
    }
}

extension SendMessagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendMessagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendMessagesOutput()
        value.messageResponse = try reader.readIfPresent(with: PinpointClientTypes.MessageResponse.read(from:))
        return value
    }
}

extension SendOTPMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendOTPMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendOTPMessageOutput()
        value.messageResponse = try reader.readIfPresent(with: PinpointClientTypes.MessageResponse.read(from:))
        return value
    }
}

extension SendUsersMessagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendUsersMessagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendUsersMessagesOutput()
        value.sendUsersMessageResponse = try reader.readIfPresent(with: PinpointClientTypes.SendUsersMessageResponse.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAdmChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAdmChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAdmChannelOutput()
        value.admChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.ADMChannelResponse.read(from:))
        return value
    }
}

extension UpdateApnsChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApnsChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApnsChannelOutput()
        value.apnsChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.APNSChannelResponse.read(from:))
        return value
    }
}

extension UpdateApnsSandboxChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApnsSandboxChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApnsSandboxChannelOutput()
        value.apnsSandboxChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.APNSSandboxChannelResponse.read(from:))
        return value
    }
}

extension UpdateApnsVoipChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApnsVoipChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApnsVoipChannelOutput()
        value.apnsVoipChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.APNSVoipChannelResponse.read(from:))
        return value
    }
}

extension UpdateApnsVoipSandboxChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApnsVoipSandboxChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApnsVoipSandboxChannelOutput()
        value.apnsVoipSandboxChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.APNSVoipSandboxChannelResponse.read(from:))
        return value
    }
}

extension UpdateApplicationSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApplicationSettingsOutput()
        value.applicationSettingsResource = try reader.readIfPresent(with: PinpointClientTypes.ApplicationSettingsResource.read(from:))
        return value
    }
}

extension UpdateBaiduChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBaiduChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBaiduChannelOutput()
        value.baiduChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.BaiduChannelResponse.read(from:))
        return value
    }
}

extension UpdateCampaignOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCampaignOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCampaignOutput()
        value.campaignResponse = try reader.readIfPresent(with: PinpointClientTypes.CampaignResponse.read(from:))
        return value
    }
}

extension UpdateEmailChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEmailChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEmailChannelOutput()
        value.emailChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.EmailChannelResponse.read(from:))
        return value
    }
}

extension UpdateEmailTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEmailTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEmailTemplateOutput()
        value.messageBody = try reader.readIfPresent(with: PinpointClientTypes.MessageBody.read(from:))
        return value
    }
}

extension UpdateEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEndpointOutput()
        value.messageBody = try reader.readIfPresent(with: PinpointClientTypes.MessageBody.read(from:))
        return value
    }
}

extension UpdateEndpointsBatchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEndpointsBatchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEndpointsBatchOutput()
        value.messageBody = try reader.readIfPresent(with: PinpointClientTypes.MessageBody.read(from:))
        return value
    }
}

extension UpdateGcmChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGcmChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGcmChannelOutput()
        value.gcmChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.GCMChannelResponse.read(from:))
        return value
    }
}

extension UpdateInAppTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInAppTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateInAppTemplateOutput()
        value.messageBody = try reader.readIfPresent(with: PinpointClientTypes.MessageBody.read(from:))
        return value
    }
}

extension UpdateJourneyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateJourneyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateJourneyOutput()
        value.journeyResponse = try reader.readIfPresent(with: PinpointClientTypes.JourneyResponse.read(from:))
        return value
    }
}

extension UpdateJourneyStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateJourneyStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateJourneyStateOutput()
        value.journeyResponse = try reader.readIfPresent(with: PinpointClientTypes.JourneyResponse.read(from:))
        return value
    }
}

extension UpdatePushTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePushTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePushTemplateOutput()
        value.messageBody = try reader.readIfPresent(with: PinpointClientTypes.MessageBody.read(from:))
        return value
    }
}

extension UpdateRecommenderConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRecommenderConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRecommenderConfigurationOutput()
        value.recommenderConfigurationResponse = try reader.readIfPresent(with: PinpointClientTypes.RecommenderConfigurationResponse.read(from:))
        return value
    }
}

extension UpdateSegmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSegmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSegmentOutput()
        value.segmentResponse = try reader.readIfPresent(with: PinpointClientTypes.SegmentResponse.read(from:))
        return value
    }
}

extension UpdateSmsChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSmsChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSmsChannelOutput()
        value.smsChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.SMSChannelResponse.read(from:))
        return value
    }
}

extension UpdateSmsTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSmsTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSmsTemplateOutput()
        value.messageBody = try reader.readIfPresent(with: PinpointClientTypes.MessageBody.read(from:))
        return value
    }
}

extension UpdateTemplateActiveVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTemplateActiveVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTemplateActiveVersionOutput()
        value.messageBody = try reader.readIfPresent(with: PinpointClientTypes.MessageBody.read(from:))
        return value
    }
}

extension UpdateVoiceChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVoiceChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVoiceChannelOutput()
        value.voiceChannelResponse = try reader.readIfPresent(with: PinpointClientTypes.VoiceChannelResponse.read(from:))
        return value
    }
}

extension UpdateVoiceTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVoiceTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVoiceTemplateOutput()
        value.messageBody = try reader.readIfPresent(with: PinpointClientTypes.MessageBody.read(from:))
        return value
    }
}

extension VerifyOTPMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> VerifyOTPMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = VerifyOTPMessageOutput()
        value.verificationResponse = try reader.readIfPresent(with: PinpointClientTypes.VerificationResponse.read(from:))
        return value
    }
}

enum CreateAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCampaignOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEmailTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInAppTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateJourneyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePushTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRecommenderConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSegmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSmsTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVoiceTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAdmChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApnsChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApnsSandboxChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApnsVoipChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApnsVoipSandboxChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBaiduChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCampaignOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEmailChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEmailTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGcmChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInAppTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteJourneyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePushTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRecommenderConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSegmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSmsChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSmsTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVoiceChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVoiceTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAdmChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApnsChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApnsSandboxChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApnsVoipChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApnsVoipSandboxChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationDateRangeKpiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBaiduChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCampaignOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCampaignActivitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCampaignDateRangeKpiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCampaignsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCampaignVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCampaignVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEmailChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEmailTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetExportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGcmChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInAppMessagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInAppTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJourneyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJourneyDateRangeKpiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJourneyExecutionActivityMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJourneyExecutionMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJourneyRunExecutionActivityMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJourneyRunExecutionMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJourneyRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPushTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRecommenderConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRecommenderConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSegmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSegmentExportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSegmentImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSegmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSegmentVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSegmentVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSmsChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSmsTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUserEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVoiceChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVoiceTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJourneysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTemplateVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PhoneNumberValidateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutEventStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendMessagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendOTPMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendUsersMessagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAdmChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApnsChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApnsSandboxChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApnsVoipChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApnsVoipSandboxChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBaiduChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCampaignOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEmailChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEmailTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEndpointsBatchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGcmChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInAppTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateJourneyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateJourneyStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePushTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRecommenderConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSegmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSmsChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSmsTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTemplateActiveVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVoiceChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVoiceTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum VerifyOTPMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "PayloadTooLargeException": return try PayloadTooLargeException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestID = try reader["RequestID"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestID = try reader["RequestID"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PayloadTooLargeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PayloadTooLargeException {
        let reader = baseError.errorBodyReader
        var value = PayloadTooLargeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestID = try reader["RequestID"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestID = try reader["RequestID"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestID = try reader["RequestID"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MethodNotAllowedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MethodNotAllowedException {
        let reader = baseError.errorBodyReader
        var value = MethodNotAllowedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestID = try reader["RequestID"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestID = try reader["RequestID"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestID = try reader["RequestID"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PinpointClientTypes.ApplicationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ApplicationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ApplicationResponse()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.creationDate = try reader["CreationDate"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.CampaignResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CampaignResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CampaignResponse()
        value.additionalTreatments = try reader["AdditionalTreatments"].readListIfPresent(memberReadingClosure: PinpointClientTypes.TreatmentResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.creationDate = try reader["CreationDate"].readIfPresent() ?? ""
        value.customDeliveryConfiguration = try reader["CustomDeliveryConfiguration"].readIfPresent(with: PinpointClientTypes.CustomDeliveryConfiguration.read(from:))
        value.defaultState = try reader["DefaultState"].readIfPresent(with: PinpointClientTypes.CampaignState.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.holdoutPercent = try reader["HoldoutPercent"].readIfPresent()
        value.hook = try reader["Hook"].readIfPresent(with: PinpointClientTypes.CampaignHook.read(from:))
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.isPaused = try reader["IsPaused"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent() ?? ""
        value.limits = try reader["Limits"].readIfPresent(with: PinpointClientTypes.CampaignLimits.read(from:))
        value.messageConfiguration = try reader["MessageConfiguration"].readIfPresent(with: PinpointClientTypes.MessageConfiguration.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.schedule = try reader["Schedule"].readIfPresent(with: PinpointClientTypes.Schedule.read(from:))
        value.segmentId = try reader["SegmentId"].readIfPresent() ?? ""
        value.segmentVersion = try reader["SegmentVersion"].readIfPresent() ?? 0
        value.state = try reader["State"].readIfPresent(with: PinpointClientTypes.CampaignState.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateConfiguration = try reader["TemplateConfiguration"].readIfPresent(with: PinpointClientTypes.TemplateConfiguration.read(from:))
        value.treatmentDescription = try reader["TreatmentDescription"].readIfPresent()
        value.treatmentName = try reader["TreatmentName"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        value.priority = try reader["Priority"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.TemplateConfiguration {

    static func write(value: PinpointClientTypes.TemplateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EmailTemplate"].write(value.emailTemplate, with: PinpointClientTypes.Template.write(value:to:))
        try writer["InAppTemplate"].write(value.inAppTemplate, with: PinpointClientTypes.Template.write(value:to:))
        try writer["PushTemplate"].write(value.pushTemplate, with: PinpointClientTypes.Template.write(value:to:))
        try writer["SMSTemplate"].write(value.smsTemplate, with: PinpointClientTypes.Template.write(value:to:))
        try writer["VoiceTemplate"].write(value.voiceTemplate, with: PinpointClientTypes.Template.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.TemplateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.TemplateConfiguration()
        value.emailTemplate = try reader["EmailTemplate"].readIfPresent(with: PinpointClientTypes.Template.read(from:))
        value.pushTemplate = try reader["PushTemplate"].readIfPresent(with: PinpointClientTypes.Template.read(from:))
        value.smsTemplate = try reader["SMSTemplate"].readIfPresent(with: PinpointClientTypes.Template.read(from:))
        value.voiceTemplate = try reader["VoiceTemplate"].readIfPresent(with: PinpointClientTypes.Template.read(from:))
        value.inAppTemplate = try reader["InAppTemplate"].readIfPresent(with: PinpointClientTypes.Template.read(from:))
        return value
    }
}

extension PinpointClientTypes.Template {

    static func write(value: PinpointClientTypes.Template?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.Template {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.Template()
        value.name = try reader["Name"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.CampaignState {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CampaignState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CampaignState()
        value.campaignStatus = try reader["CampaignStatus"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.Schedule {

    static func write(value: PinpointClientTypes.Schedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].write(value.endTime)
        try writer["EventFilter"].write(value.eventFilter, with: PinpointClientTypes.CampaignEventFilter.write(value:to:))
        try writer["Frequency"].write(value.frequency)
        try writer["IsLocalTime"].write(value.isLocalTime)
        try writer["QuietTime"].write(value.quietTime, with: PinpointClientTypes.QuietTime.write(value:to:))
        try writer["StartTime"].write(value.startTime)
        try writer["Timezone"].write(value.timezone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.Schedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.Schedule()
        value.endTime = try reader["EndTime"].readIfPresent()
        value.eventFilter = try reader["EventFilter"].readIfPresent(with: PinpointClientTypes.CampaignEventFilter.read(from:))
        value.frequency = try reader["Frequency"].readIfPresent()
        value.isLocalTime = try reader["IsLocalTime"].readIfPresent()
        value.quietTime = try reader["QuietTime"].readIfPresent(with: PinpointClientTypes.QuietTime.read(from:))
        value.startTime = try reader["StartTime"].readIfPresent() ?? ""
        value.timezone = try reader["Timezone"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.QuietTime {

    static func write(value: PinpointClientTypes.QuietTime?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["End"].write(value.end)
        try writer["Start"].write(value.start)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.QuietTime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.QuietTime()
        value.end = try reader["End"].readIfPresent()
        value.start = try reader["Start"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.CampaignEventFilter {

    static func write(value: PinpointClientTypes.CampaignEventFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dimensions"].write(value.dimensions, with: PinpointClientTypes.EventDimensions.write(value:to:))
        try writer["FilterType"].write(value.filterType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CampaignEventFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CampaignEventFilter()
        value.dimensions = try reader["Dimensions"].readIfPresent(with: PinpointClientTypes.EventDimensions.read(from:))
        value.filterType = try reader["FilterType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PinpointClientTypes.EventDimensions {

    static func write(value: PinpointClientTypes.EventDimensions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: PinpointClientTypes.AttributeDimension.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["EventType"].write(value.eventType, with: PinpointClientTypes.SetDimension.write(value:to:))
        try writer["Metrics"].writeMap(value.metrics, valueWritingClosure: PinpointClientTypes.MetricDimension.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EventDimensions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EventDimensions()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: PinpointClientTypes.AttributeDimension.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.eventType = try reader["EventType"].readIfPresent(with: PinpointClientTypes.SetDimension.read(from:))
        value.metrics = try reader["Metrics"].readMapIfPresent(valueReadingClosure: PinpointClientTypes.MetricDimension.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.MetricDimension {

    static func write(value: PinpointClientTypes.MetricDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComparisonOperator"].write(value.comparisonOperator)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.MetricDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.MetricDimension()
        value.comparisonOperator = try reader["ComparisonOperator"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? 0.0
        return value
    }
}

extension PinpointClientTypes.SetDimension {

    static func write(value: PinpointClientTypes.SetDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionType"].write(value.dimensionType)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SetDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SetDimension()
        value.dimensionType = try reader["DimensionType"].readIfPresent()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PinpointClientTypes.AttributeDimension {

    static func write(value: PinpointClientTypes.AttributeDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeType"].write(value.attributeType)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.AttributeDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.AttributeDimension()
        value.attributeType = try reader["AttributeType"].readIfPresent()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PinpointClientTypes.MessageConfiguration {

    static func write(value: PinpointClientTypes.MessageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ADMMessage"].write(value.admMessage, with: PinpointClientTypes.Message.write(value:to:))
        try writer["APNSMessage"].write(value.apnsMessage, with: PinpointClientTypes.Message.write(value:to:))
        try writer["BaiduMessage"].write(value.baiduMessage, with: PinpointClientTypes.Message.write(value:to:))
        try writer["CustomMessage"].write(value.customMessage, with: PinpointClientTypes.CampaignCustomMessage.write(value:to:))
        try writer["DefaultMessage"].write(value.defaultMessage, with: PinpointClientTypes.Message.write(value:to:))
        try writer["EmailMessage"].write(value.emailMessage, with: PinpointClientTypes.CampaignEmailMessage.write(value:to:))
        try writer["GCMMessage"].write(value.gcmMessage, with: PinpointClientTypes.Message.write(value:to:))
        try writer["InAppMessage"].write(value.inAppMessage, with: PinpointClientTypes.CampaignInAppMessage.write(value:to:))
        try writer["SMSMessage"].write(value.smsMessage, with: PinpointClientTypes.CampaignSmsMessage.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.MessageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.MessageConfiguration()
        value.admMessage = try reader["ADMMessage"].readIfPresent(with: PinpointClientTypes.Message.read(from:))
        value.apnsMessage = try reader["APNSMessage"].readIfPresent(with: PinpointClientTypes.Message.read(from:))
        value.baiduMessage = try reader["BaiduMessage"].readIfPresent(with: PinpointClientTypes.Message.read(from:))
        value.customMessage = try reader["CustomMessage"].readIfPresent(with: PinpointClientTypes.CampaignCustomMessage.read(from:))
        value.defaultMessage = try reader["DefaultMessage"].readIfPresent(with: PinpointClientTypes.Message.read(from:))
        value.emailMessage = try reader["EmailMessage"].readIfPresent(with: PinpointClientTypes.CampaignEmailMessage.read(from:))
        value.gcmMessage = try reader["GCMMessage"].readIfPresent(with: PinpointClientTypes.Message.read(from:))
        value.smsMessage = try reader["SMSMessage"].readIfPresent(with: PinpointClientTypes.CampaignSmsMessage.read(from:))
        value.inAppMessage = try reader["InAppMessage"].readIfPresent(with: PinpointClientTypes.CampaignInAppMessage.read(from:))
        return value
    }
}

extension PinpointClientTypes.CampaignInAppMessage {

    static func write(value: PinpointClientTypes.CampaignInAppMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Body"].write(value.body)
        try writer["Content"].writeList(value.content, memberWritingClosure: PinpointClientTypes.InAppMessageContent.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CustomConfig"].writeMap(value.customConfig, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Layout"].write(value.layout)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CampaignInAppMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CampaignInAppMessage()
        value.body = try reader["Body"].readIfPresent()
        value.content = try reader["Content"].readListIfPresent(memberReadingClosure: PinpointClientTypes.InAppMessageContent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.customConfig = try reader["CustomConfig"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.layout = try reader["Layout"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.InAppMessageContent {

    static func write(value: PinpointClientTypes.InAppMessageContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackgroundColor"].write(value.backgroundColor)
        try writer["BodyConfig"].write(value.bodyConfig, with: PinpointClientTypes.InAppMessageBodyConfig.write(value:to:))
        try writer["HeaderConfig"].write(value.headerConfig, with: PinpointClientTypes.InAppMessageHeaderConfig.write(value:to:))
        try writer["ImageUrl"].write(value.imageUrl)
        try writer["PrimaryBtn"].write(value.primaryBtn, with: PinpointClientTypes.InAppMessageButton.write(value:to:))
        try writer["SecondaryBtn"].write(value.secondaryBtn, with: PinpointClientTypes.InAppMessageButton.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.InAppMessageContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.InAppMessageContent()
        value.backgroundColor = try reader["BackgroundColor"].readIfPresent()
        value.bodyConfig = try reader["BodyConfig"].readIfPresent(with: PinpointClientTypes.InAppMessageBodyConfig.read(from:))
        value.headerConfig = try reader["HeaderConfig"].readIfPresent(with: PinpointClientTypes.InAppMessageHeaderConfig.read(from:))
        value.imageUrl = try reader["ImageUrl"].readIfPresent()
        value.primaryBtn = try reader["PrimaryBtn"].readIfPresent(with: PinpointClientTypes.InAppMessageButton.read(from:))
        value.secondaryBtn = try reader["SecondaryBtn"].readIfPresent(with: PinpointClientTypes.InAppMessageButton.read(from:))
        return value
    }
}

extension PinpointClientTypes.InAppMessageButton {

    static func write(value: PinpointClientTypes.InAppMessageButton?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Android"].write(value.android, with: PinpointClientTypes.OverrideButtonConfiguration.write(value:to:))
        try writer["DefaultConfig"].write(value.defaultConfig, with: PinpointClientTypes.DefaultButtonConfiguration.write(value:to:))
        try writer["IOS"].write(value.ios, with: PinpointClientTypes.OverrideButtonConfiguration.write(value:to:))
        try writer["Web"].write(value.web, with: PinpointClientTypes.OverrideButtonConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.InAppMessageButton {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.InAppMessageButton()
        value.android = try reader["Android"].readIfPresent(with: PinpointClientTypes.OverrideButtonConfiguration.read(from:))
        value.defaultConfig = try reader["DefaultConfig"].readIfPresent(with: PinpointClientTypes.DefaultButtonConfiguration.read(from:))
        value.ios = try reader["IOS"].readIfPresent(with: PinpointClientTypes.OverrideButtonConfiguration.read(from:))
        value.web = try reader["Web"].readIfPresent(with: PinpointClientTypes.OverrideButtonConfiguration.read(from:))
        return value
    }
}

extension PinpointClientTypes.OverrideButtonConfiguration {

    static func write(value: PinpointClientTypes.OverrideButtonConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ButtonAction"].write(value.buttonAction)
        try writer["Link"].write(value.link)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.OverrideButtonConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.OverrideButtonConfiguration()
        value.buttonAction = try reader["ButtonAction"].readIfPresent() ?? .sdkUnknown("")
        value.link = try reader["Link"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.DefaultButtonConfiguration {

    static func write(value: PinpointClientTypes.DefaultButtonConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackgroundColor"].write(value.backgroundColor)
        try writer["BorderRadius"].write(value.borderRadius)
        try writer["ButtonAction"].write(value.buttonAction)
        try writer["Link"].write(value.link)
        try writer["Text"].write(value.text)
        try writer["TextColor"].write(value.textColor)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.DefaultButtonConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.DefaultButtonConfiguration()
        value.backgroundColor = try reader["BackgroundColor"].readIfPresent()
        value.borderRadius = try reader["BorderRadius"].readIfPresent()
        value.buttonAction = try reader["ButtonAction"].readIfPresent() ?? .sdkUnknown("")
        value.link = try reader["Link"].readIfPresent()
        value.text = try reader["Text"].readIfPresent() ?? ""
        value.textColor = try reader["TextColor"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.InAppMessageHeaderConfig {

    static func write(value: PinpointClientTypes.InAppMessageHeaderConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Alignment"].write(value.alignment)
        try writer["Header"].write(value.header)
        try writer["TextColor"].write(value.textColor)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.InAppMessageHeaderConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.InAppMessageHeaderConfig()
        value.alignment = try reader["Alignment"].readIfPresent() ?? .sdkUnknown("")
        value.header = try reader["Header"].readIfPresent() ?? ""
        value.textColor = try reader["TextColor"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointClientTypes.InAppMessageBodyConfig {

    static func write(value: PinpointClientTypes.InAppMessageBodyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Alignment"].write(value.alignment)
        try writer["Body"].write(value.body)
        try writer["TextColor"].write(value.textColor)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.InAppMessageBodyConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.InAppMessageBodyConfig()
        value.alignment = try reader["Alignment"].readIfPresent() ?? .sdkUnknown("")
        value.body = try reader["Body"].readIfPresent() ?? ""
        value.textColor = try reader["TextColor"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointClientTypes.CampaignSmsMessage {

    static func write(value: PinpointClientTypes.CampaignSmsMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Body"].write(value.body)
        try writer["EntityId"].write(value.entityId)
        try writer["MessageType"].write(value.messageType)
        try writer["OriginationNumber"].write(value.originationNumber)
        try writer["SenderId"].write(value.senderId)
        try writer["TemplateId"].write(value.templateId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CampaignSmsMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CampaignSmsMessage()
        value.body = try reader["Body"].readIfPresent()
        value.messageType = try reader["MessageType"].readIfPresent()
        value.originationNumber = try reader["OriginationNumber"].readIfPresent()
        value.senderId = try reader["SenderId"].readIfPresent()
        value.entityId = try reader["EntityId"].readIfPresent()
        value.templateId = try reader["TemplateId"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.Message {

    static func write(value: PinpointClientTypes.Message?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Body"].write(value.body)
        try writer["ImageIconUrl"].write(value.imageIconUrl)
        try writer["ImageSmallIconUrl"].write(value.imageSmallIconUrl)
        try writer["ImageUrl"].write(value.imageUrl)
        try writer["JsonBody"].write(value.jsonBody)
        try writer["MediaUrl"].write(value.mediaUrl)
        try writer["RawContent"].write(value.rawContent)
        try writer["SilentPush"].write(value.silentPush)
        try writer["TimeToLive"].write(value.timeToLive)
        try writer["Title"].write(value.title)
        try writer["Url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.Message {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.Message()
        value.action = try reader["Action"].readIfPresent()
        value.body = try reader["Body"].readIfPresent()
        value.imageIconUrl = try reader["ImageIconUrl"].readIfPresent()
        value.imageSmallIconUrl = try reader["ImageSmallIconUrl"].readIfPresent()
        value.imageUrl = try reader["ImageUrl"].readIfPresent()
        value.jsonBody = try reader["JsonBody"].readIfPresent()
        value.mediaUrl = try reader["MediaUrl"].readIfPresent()
        value.rawContent = try reader["RawContent"].readIfPresent()
        value.silentPush = try reader["SilentPush"].readIfPresent()
        value.timeToLive = try reader["TimeToLive"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.CampaignEmailMessage {

    static func write(value: PinpointClientTypes.CampaignEmailMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Body"].write(value.body)
        try writer["FromAddress"].write(value.fromAddress)
        try writer["Headers"].writeList(value.headers, memberWritingClosure: PinpointClientTypes.MessageHeader.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HtmlBody"].write(value.htmlBody)
        try writer["Title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CampaignEmailMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CampaignEmailMessage()
        value.body = try reader["Body"].readIfPresent()
        value.fromAddress = try reader["FromAddress"].readIfPresent()
        value.headers = try reader["Headers"].readListIfPresent(memberReadingClosure: PinpointClientTypes.MessageHeader.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.htmlBody = try reader["HtmlBody"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.MessageHeader {

    static func write(value: PinpointClientTypes.MessageHeader?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.MessageHeader {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.MessageHeader()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.CampaignCustomMessage {

    static func write(value: PinpointClientTypes.CampaignCustomMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Data"].write(value.data)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CampaignCustomMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CampaignCustomMessage()
        value.data = try reader["Data"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.CampaignLimits {

    static func write(value: PinpointClientTypes.CampaignLimits?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Daily"].write(value.daily)
        try writer["MaximumDuration"].write(value.maximumDuration)
        try writer["MessagesPerSecond"].write(value.messagesPerSecond)
        try writer["Session"].write(value.session)
        try writer["Total"].write(value.total)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CampaignLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CampaignLimits()
        value.daily = try reader["Daily"].readIfPresent()
        value.maximumDuration = try reader["MaximumDuration"].readIfPresent()
        value.messagesPerSecond = try reader["MessagesPerSecond"].readIfPresent()
        value.total = try reader["Total"].readIfPresent()
        value.session = try reader["Session"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.CampaignHook {

    static func write(value: PinpointClientTypes.CampaignHook?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LambdaFunctionName"].write(value.lambdaFunctionName)
        try writer["Mode"].write(value.mode)
        try writer["WebUrl"].write(value.webUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CampaignHook {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CampaignHook()
        value.lambdaFunctionName = try reader["LambdaFunctionName"].readIfPresent()
        value.mode = try reader["Mode"].readIfPresent()
        value.webUrl = try reader["WebUrl"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.CustomDeliveryConfiguration {

    static func write(value: PinpointClientTypes.CustomDeliveryConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeliveryUri"].write(value.deliveryUri)
        try writer["EndpointTypes"].writeList(value.endpointTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PinpointClientTypes.__EndpointTypesElement>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CustomDeliveryConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CustomDeliveryConfiguration()
        value.deliveryUri = try reader["DeliveryUri"].readIfPresent() ?? ""
        value.endpointTypes = try reader["EndpointTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PinpointClientTypes.__EndpointTypesElement>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.TreatmentResource {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.TreatmentResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.TreatmentResource()
        value.customDeliveryConfiguration = try reader["CustomDeliveryConfiguration"].readIfPresent(with: PinpointClientTypes.CustomDeliveryConfiguration.read(from:))
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.messageConfiguration = try reader["MessageConfiguration"].readIfPresent(with: PinpointClientTypes.MessageConfiguration.read(from:))
        value.schedule = try reader["Schedule"].readIfPresent(with: PinpointClientTypes.Schedule.read(from:))
        value.sizePercent = try reader["SizePercent"].readIfPresent() ?? 0
        value.state = try reader["State"].readIfPresent(with: PinpointClientTypes.CampaignState.read(from:))
        value.templateConfiguration = try reader["TemplateConfiguration"].readIfPresent(with: PinpointClientTypes.TemplateConfiguration.read(from:))
        value.treatmentDescription = try reader["TreatmentDescription"].readIfPresent()
        value.treatmentName = try reader["TreatmentName"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.CreateTemplateMessageBody {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CreateTemplateMessageBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CreateTemplateMessageBody()
        value.arn = try reader["Arn"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.requestID = try reader["RequestID"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.ExportJobResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ExportJobResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ExportJobResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.completedPieces = try reader["CompletedPieces"].readIfPresent()
        value.completionDate = try reader["CompletionDate"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent() ?? ""
        value.definition = try reader["Definition"].readIfPresent(with: PinpointClientTypes.ExportJobResource.read(from:))
        value.failedPieces = try reader["FailedPieces"].readIfPresent()
        value.failures = try reader["Failures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.jobStatus = try reader["JobStatus"].readIfPresent() ?? .sdkUnknown("")
        value.totalFailures = try reader["TotalFailures"].readIfPresent()
        value.totalPieces = try reader["TotalPieces"].readIfPresent()
        value.totalProcessed = try reader["TotalProcessed"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointClientTypes.ExportJobResource {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ExportJobResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ExportJobResource()
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        value.s3UrlPrefix = try reader["S3UrlPrefix"].readIfPresent() ?? ""
        value.segmentId = try reader["SegmentId"].readIfPresent()
        value.segmentVersion = try reader["SegmentVersion"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.ImportJobResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ImportJobResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ImportJobResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.completedPieces = try reader["CompletedPieces"].readIfPresent()
        value.completionDate = try reader["CompletionDate"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent() ?? ""
        value.definition = try reader["Definition"].readIfPresent(with: PinpointClientTypes.ImportJobResource.read(from:))
        value.failedPieces = try reader["FailedPieces"].readIfPresent()
        value.failures = try reader["Failures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.jobStatus = try reader["JobStatus"].readIfPresent() ?? .sdkUnknown("")
        value.totalFailures = try reader["TotalFailures"].readIfPresent()
        value.totalPieces = try reader["TotalPieces"].readIfPresent()
        value.totalProcessed = try reader["TotalProcessed"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointClientTypes.ImportJobResource {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ImportJobResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ImportJobResource()
        value.defineSegment = try reader["DefineSegment"].readIfPresent()
        value.externalId = try reader["ExternalId"].readIfPresent()
        value.format = try reader["Format"].readIfPresent() ?? .sdkUnknown("")
        value.registerEndpoints = try reader["RegisterEndpoints"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        value.s3Url = try reader["S3Url"].readIfPresent() ?? ""
        value.segmentId = try reader["SegmentId"].readIfPresent()
        value.segmentName = try reader["SegmentName"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.TemplateCreateMessageBody {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.TemplateCreateMessageBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.TemplateCreateMessageBody()
        value.arn = try reader["Arn"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.requestID = try reader["RequestID"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.JourneyResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyResponse()
        value.activities = try reader["Activities"].readMapIfPresent(valueReadingClosure: PinpointClientTypes.Activity.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.limits = try reader["Limits"].readIfPresent(with: PinpointClientTypes.JourneyLimits.read(from:))
        value.localTime = try reader["LocalTime"].readIfPresent()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.quietTime = try reader["QuietTime"].readIfPresent(with: PinpointClientTypes.QuietTime.read(from:))
        value.refreshFrequency = try reader["RefreshFrequency"].readIfPresent()
        value.schedule = try reader["Schedule"].readIfPresent(with: PinpointClientTypes.JourneySchedule.read(from:))
        value.startActivity = try reader["StartActivity"].readIfPresent()
        value.startCondition = try reader["StartCondition"].readIfPresent(with: PinpointClientTypes.StartCondition.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.waitForQuietTime = try reader["WaitForQuietTime"].readIfPresent()
        value.refreshOnSegmentUpdate = try reader["RefreshOnSegmentUpdate"].readIfPresent()
        value.journeyChannelSettings = try reader["JourneyChannelSettings"].readIfPresent(with: PinpointClientTypes.JourneyChannelSettings.read(from:))
        value.sendingSchedule = try reader["SendingSchedule"].readIfPresent()
        value.openHours = try reader["OpenHours"].readIfPresent(with: PinpointClientTypes.OpenHours.read(from:))
        value.closedDays = try reader["ClosedDays"].readIfPresent(with: PinpointClientTypes.ClosedDays.read(from:))
        value.timezoneEstimationMethods = try reader["TimezoneEstimationMethods"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PinpointClientTypes.__TimezoneEstimationMethodsElement>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.ClosedDays {

    static func write(value: PinpointClientTypes.ClosedDays?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CUSTOM"].writeList(value.custom, memberWritingClosure: PinpointClientTypes.ClosedDaysRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EMAIL"].writeList(value.email, memberWritingClosure: PinpointClientTypes.ClosedDaysRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PUSH"].writeList(value.push, memberWritingClosure: PinpointClientTypes.ClosedDaysRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SMS"].writeList(value.sms, memberWritingClosure: PinpointClientTypes.ClosedDaysRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VOICE"].writeList(value.voice, memberWritingClosure: PinpointClientTypes.ClosedDaysRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ClosedDays {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ClosedDays()
        value.email = try reader["EMAIL"].readListIfPresent(memberReadingClosure: PinpointClientTypes.ClosedDaysRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sms = try reader["SMS"].readListIfPresent(memberReadingClosure: PinpointClientTypes.ClosedDaysRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.push = try reader["PUSH"].readListIfPresent(memberReadingClosure: PinpointClientTypes.ClosedDaysRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.voice = try reader["VOICE"].readListIfPresent(memberReadingClosure: PinpointClientTypes.ClosedDaysRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.custom = try reader["CUSTOM"].readListIfPresent(memberReadingClosure: PinpointClientTypes.ClosedDaysRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.ClosedDaysRule {

    static func write(value: PinpointClientTypes.ClosedDaysRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndDateTime"].write(value.endDateTime)
        try writer["Name"].write(value.name)
        try writer["StartDateTime"].write(value.startDateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ClosedDaysRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ClosedDaysRule()
        value.name = try reader["Name"].readIfPresent()
        value.startDateTime = try reader["StartDateTime"].readIfPresent()
        value.endDateTime = try reader["EndDateTime"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.OpenHours {

    static func write(value: PinpointClientTypes.OpenHours?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CUSTOM"].writeMap(value.custom, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: PinpointClientTypes.OpenHoursRule.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["EMAIL"].writeMap(value.email, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: PinpointClientTypes.OpenHoursRule.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["PUSH"].writeMap(value.push, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: PinpointClientTypes.OpenHoursRule.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SMS"].writeMap(value.sms, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: PinpointClientTypes.OpenHoursRule.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["VOICE"].writeMap(value.voice, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: PinpointClientTypes.OpenHoursRule.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.OpenHours {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.OpenHours()
        value.email = try reader["EMAIL"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: PinpointClientTypes.OpenHoursRule.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.sms = try reader["SMS"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: PinpointClientTypes.OpenHoursRule.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.push = try reader["PUSH"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: PinpointClientTypes.OpenHoursRule.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.voice = try reader["VOICE"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: PinpointClientTypes.OpenHoursRule.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.custom = try reader["CUSTOM"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: PinpointClientTypes.OpenHoursRule.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.OpenHoursRule {

    static func write(value: PinpointClientTypes.OpenHoursRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].write(value.endTime)
        try writer["StartTime"].write(value.startTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.OpenHoursRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.OpenHoursRule()
        value.startTime = try reader["StartTime"].readIfPresent()
        value.endTime = try reader["EndTime"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.JourneyChannelSettings {

    static func write(value: PinpointClientTypes.JourneyChannelSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectCampaignArn"].write(value.connectCampaignArn)
        try writer["ConnectCampaignExecutionRoleArn"].write(value.connectCampaignExecutionRoleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyChannelSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyChannelSettings()
        value.connectCampaignArn = try reader["ConnectCampaignArn"].readIfPresent()
        value.connectCampaignExecutionRoleArn = try reader["ConnectCampaignExecutionRoleArn"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.StartCondition {

    static func write(value: PinpointClientTypes.StartCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["EventStartCondition"].write(value.eventStartCondition, with: PinpointClientTypes.EventStartCondition.write(value:to:))
        try writer["SegmentStartCondition"].write(value.segmentStartCondition, with: PinpointClientTypes.SegmentCondition.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.StartCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.StartCondition()
        value.description = try reader["Description"].readIfPresent()
        value.eventStartCondition = try reader["EventStartCondition"].readIfPresent(with: PinpointClientTypes.EventStartCondition.read(from:))
        value.segmentStartCondition = try reader["SegmentStartCondition"].readIfPresent(with: PinpointClientTypes.SegmentCondition.read(from:))
        return value
    }
}

extension PinpointClientTypes.SegmentCondition {

    static func write(value: PinpointClientTypes.SegmentCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SegmentId"].write(value.segmentId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SegmentCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SegmentCondition()
        value.segmentId = try reader["SegmentId"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointClientTypes.EventStartCondition {

    static func write(value: PinpointClientTypes.EventStartCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventFilter"].write(value.eventFilter, with: PinpointClientTypes.EventFilter.write(value:to:))
        try writer["SegmentId"].write(value.segmentId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EventStartCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EventStartCondition()
        value.eventFilter = try reader["EventFilter"].readIfPresent(with: PinpointClientTypes.EventFilter.read(from:))
        value.segmentId = try reader["SegmentId"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.EventFilter {

    static func write(value: PinpointClientTypes.EventFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dimensions"].write(value.dimensions, with: PinpointClientTypes.EventDimensions.write(value:to:))
        try writer["FilterType"].write(value.filterType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EventFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EventFilter()
        value.dimensions = try reader["Dimensions"].readIfPresent(with: PinpointClientTypes.EventDimensions.read(from:))
        value.filterType = try reader["FilterType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PinpointClientTypes.JourneySchedule {

    static func write(value: PinpointClientTypes.JourneySchedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["Timezone"].write(value.timezone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneySchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneySchedule()
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.timezone = try reader["Timezone"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.JourneyLimits {

    static func write(value: PinpointClientTypes.JourneyLimits?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DailyCap"].write(value.dailyCap)
        try writer["EndpointReentryCap"].write(value.endpointReentryCap)
        try writer["EndpointReentryInterval"].write(value.endpointReentryInterval)
        try writer["MessagesPerSecond"].write(value.messagesPerSecond)
        try writer["TimeframeCap"].write(value.timeframeCap, with: PinpointClientTypes.JourneyTimeframeCap.write(value:to:))
        try writer["TotalCap"].write(value.totalCap)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyLimits()
        value.dailyCap = try reader["DailyCap"].readIfPresent()
        value.endpointReentryCap = try reader["EndpointReentryCap"].readIfPresent()
        value.messagesPerSecond = try reader["MessagesPerSecond"].readIfPresent()
        value.endpointReentryInterval = try reader["EndpointReentryInterval"].readIfPresent()
        value.timeframeCap = try reader["TimeframeCap"].readIfPresent(with: PinpointClientTypes.JourneyTimeframeCap.read(from:))
        value.totalCap = try reader["TotalCap"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.JourneyTimeframeCap {

    static func write(value: PinpointClientTypes.JourneyTimeframeCap?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cap"].write(value.cap)
        try writer["Days"].write(value.days)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyTimeframeCap {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyTimeframeCap()
        value.cap = try reader["Cap"].readIfPresent()
        value.days = try reader["Days"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.Activity {

    static func write(value: PinpointClientTypes.Activity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CUSTOM"].write(value.custom, with: PinpointClientTypes.CustomMessageActivity.write(value:to:))
        try writer["ConditionalSplit"].write(value.conditionalSplit, with: PinpointClientTypes.ConditionalSplitActivity.write(value:to:))
        try writer["ContactCenter"].write(value.contactCenter, with: PinpointClientTypes.ContactCenterActivity.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["EMAIL"].write(value.email, with: PinpointClientTypes.EmailMessageActivity.write(value:to:))
        try writer["Holdout"].write(value.holdout, with: PinpointClientTypes.HoldoutActivity.write(value:to:))
        try writer["MultiCondition"].write(value.multiCondition, with: PinpointClientTypes.MultiConditionalSplitActivity.write(value:to:))
        try writer["PUSH"].write(value.push, with: PinpointClientTypes.PushMessageActivity.write(value:to:))
        try writer["RandomSplit"].write(value.randomSplit, with: PinpointClientTypes.RandomSplitActivity.write(value:to:))
        try writer["SMS"].write(value.sms, with: PinpointClientTypes.SMSMessageActivity.write(value:to:))
        try writer["Wait"].write(value.wait, with: PinpointClientTypes.WaitActivity.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.Activity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.Activity()
        value.custom = try reader["CUSTOM"].readIfPresent(with: PinpointClientTypes.CustomMessageActivity.read(from:))
        value.conditionalSplit = try reader["ConditionalSplit"].readIfPresent(with: PinpointClientTypes.ConditionalSplitActivity.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.email = try reader["EMAIL"].readIfPresent(with: PinpointClientTypes.EmailMessageActivity.read(from:))
        value.holdout = try reader["Holdout"].readIfPresent(with: PinpointClientTypes.HoldoutActivity.read(from:))
        value.multiCondition = try reader["MultiCondition"].readIfPresent(with: PinpointClientTypes.MultiConditionalSplitActivity.read(from:))
        value.push = try reader["PUSH"].readIfPresent(with: PinpointClientTypes.PushMessageActivity.read(from:))
        value.randomSplit = try reader["RandomSplit"].readIfPresent(with: PinpointClientTypes.RandomSplitActivity.read(from:))
        value.sms = try reader["SMS"].readIfPresent(with: PinpointClientTypes.SMSMessageActivity.read(from:))
        value.wait = try reader["Wait"].readIfPresent(with: PinpointClientTypes.WaitActivity.read(from:))
        value.contactCenter = try reader["ContactCenter"].readIfPresent(with: PinpointClientTypes.ContactCenterActivity.read(from:))
        return value
    }
}

extension PinpointClientTypes.ContactCenterActivity {

    static func write(value: PinpointClientTypes.ContactCenterActivity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextActivity"].write(value.nextActivity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ContactCenterActivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ContactCenterActivity()
        value.nextActivity = try reader["NextActivity"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.WaitActivity {

    static func write(value: PinpointClientTypes.WaitActivity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextActivity"].write(value.nextActivity)
        try writer["WaitTime"].write(value.waitTime, with: PinpointClientTypes.WaitTime.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.WaitActivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.WaitActivity()
        value.nextActivity = try reader["NextActivity"].readIfPresent()
        value.waitTime = try reader["WaitTime"].readIfPresent(with: PinpointClientTypes.WaitTime.read(from:))
        return value
    }
}

extension PinpointClientTypes.WaitTime {

    static func write(value: PinpointClientTypes.WaitTime?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WaitFor"].write(value.waitFor)
        try writer["WaitUntil"].write(value.waitUntil)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.WaitTime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.WaitTime()
        value.waitFor = try reader["WaitFor"].readIfPresent()
        value.waitUntil = try reader["WaitUntil"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.SMSMessageActivity {

    static func write(value: PinpointClientTypes.SMSMessageActivity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MessageConfig"].write(value.messageConfig, with: PinpointClientTypes.JourneySMSMessage.write(value:to:))
        try writer["NextActivity"].write(value.nextActivity)
        try writer["TemplateName"].write(value.templateName)
        try writer["TemplateVersion"].write(value.templateVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SMSMessageActivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SMSMessageActivity()
        value.messageConfig = try reader["MessageConfig"].readIfPresent(with: PinpointClientTypes.JourneySMSMessage.read(from:))
        value.nextActivity = try reader["NextActivity"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent()
        value.templateVersion = try reader["TemplateVersion"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.JourneySMSMessage {

    static func write(value: PinpointClientTypes.JourneySMSMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId)
        try writer["MessageType"].write(value.messageType)
        try writer["OriginationNumber"].write(value.originationNumber)
        try writer["SenderId"].write(value.senderId)
        try writer["TemplateId"].write(value.templateId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneySMSMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneySMSMessage()
        value.messageType = try reader["MessageType"].readIfPresent()
        value.originationNumber = try reader["OriginationNumber"].readIfPresent()
        value.senderId = try reader["SenderId"].readIfPresent()
        value.entityId = try reader["EntityId"].readIfPresent()
        value.templateId = try reader["TemplateId"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.RandomSplitActivity {

    static func write(value: PinpointClientTypes.RandomSplitActivity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Branches"].writeList(value.branches, memberWritingClosure: PinpointClientTypes.RandomSplitEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.RandomSplitActivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.RandomSplitActivity()
        value.branches = try reader["Branches"].readListIfPresent(memberReadingClosure: PinpointClientTypes.RandomSplitEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.RandomSplitEntry {

    static func write(value: PinpointClientTypes.RandomSplitEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextActivity"].write(value.nextActivity)
        try writer["Percentage"].write(value.percentage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.RandomSplitEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.RandomSplitEntry()
        value.nextActivity = try reader["NextActivity"].readIfPresent()
        value.percentage = try reader["Percentage"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.PushMessageActivity {

    static func write(value: PinpointClientTypes.PushMessageActivity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MessageConfig"].write(value.messageConfig, with: PinpointClientTypes.JourneyPushMessage.write(value:to:))
        try writer["NextActivity"].write(value.nextActivity)
        try writer["TemplateName"].write(value.templateName)
        try writer["TemplateVersion"].write(value.templateVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.PushMessageActivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.PushMessageActivity()
        value.messageConfig = try reader["MessageConfig"].readIfPresent(with: PinpointClientTypes.JourneyPushMessage.read(from:))
        value.nextActivity = try reader["NextActivity"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent()
        value.templateVersion = try reader["TemplateVersion"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.JourneyPushMessage {

    static func write(value: PinpointClientTypes.JourneyPushMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TimeToLive"].write(value.timeToLive)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyPushMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyPushMessage()
        value.timeToLive = try reader["TimeToLive"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.MultiConditionalSplitActivity {

    static func write(value: PinpointClientTypes.MultiConditionalSplitActivity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Branches"].writeList(value.branches, memberWritingClosure: PinpointClientTypes.MultiConditionalBranch.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DefaultActivity"].write(value.defaultActivity)
        try writer["EvaluationWaitTime"].write(value.evaluationWaitTime, with: PinpointClientTypes.WaitTime.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.MultiConditionalSplitActivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.MultiConditionalSplitActivity()
        value.branches = try reader["Branches"].readListIfPresent(memberReadingClosure: PinpointClientTypes.MultiConditionalBranch.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.defaultActivity = try reader["DefaultActivity"].readIfPresent()
        value.evaluationWaitTime = try reader["EvaluationWaitTime"].readIfPresent(with: PinpointClientTypes.WaitTime.read(from:))
        return value
    }
}

extension PinpointClientTypes.MultiConditionalBranch {

    static func write(value: PinpointClientTypes.MultiConditionalBranch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Condition"].write(value.condition, with: PinpointClientTypes.SimpleCondition.write(value:to:))
        try writer["NextActivity"].write(value.nextActivity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.MultiConditionalBranch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.MultiConditionalBranch()
        value.condition = try reader["Condition"].readIfPresent(with: PinpointClientTypes.SimpleCondition.read(from:))
        value.nextActivity = try reader["NextActivity"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.SimpleCondition {

    static func write(value: PinpointClientTypes.SimpleCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventCondition"].write(value.eventCondition, with: PinpointClientTypes.EventCondition.write(value:to:))
        try writer["SegmentCondition"].write(value.segmentCondition, with: PinpointClientTypes.SegmentCondition.write(value:to:))
        try writer["segmentDimensions"].write(value.segmentDimensions, with: PinpointClientTypes.SegmentDimensions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SimpleCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SimpleCondition()
        value.eventCondition = try reader["EventCondition"].readIfPresent(with: PinpointClientTypes.EventCondition.read(from:))
        value.segmentCondition = try reader["SegmentCondition"].readIfPresent(with: PinpointClientTypes.SegmentCondition.read(from:))
        value.segmentDimensions = try reader["segmentDimensions"].readIfPresent(with: PinpointClientTypes.SegmentDimensions.read(from:))
        return value
    }
}

extension PinpointClientTypes.SegmentDimensions {

    static func write(value: PinpointClientTypes.SegmentDimensions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: PinpointClientTypes.AttributeDimension.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Behavior"].write(value.behavior, with: PinpointClientTypes.SegmentBehaviors.write(value:to:))
        try writer["Demographic"].write(value.demographic, with: PinpointClientTypes.SegmentDemographics.write(value:to:))
        try writer["Location"].write(value.location, with: PinpointClientTypes.SegmentLocation.write(value:to:))
        try writer["Metrics"].writeMap(value.metrics, valueWritingClosure: PinpointClientTypes.MetricDimension.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["UserAttributes"].writeMap(value.userAttributes, valueWritingClosure: PinpointClientTypes.AttributeDimension.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SegmentDimensions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SegmentDimensions()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: PinpointClientTypes.AttributeDimension.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.behavior = try reader["Behavior"].readIfPresent(with: PinpointClientTypes.SegmentBehaviors.read(from:))
        value.demographic = try reader["Demographic"].readIfPresent(with: PinpointClientTypes.SegmentDemographics.read(from:))
        value.location = try reader["Location"].readIfPresent(with: PinpointClientTypes.SegmentLocation.read(from:))
        value.metrics = try reader["Metrics"].readMapIfPresent(valueReadingClosure: PinpointClientTypes.MetricDimension.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userAttributes = try reader["UserAttributes"].readMapIfPresent(valueReadingClosure: PinpointClientTypes.AttributeDimension.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.SegmentLocation {

    static func write(value: PinpointClientTypes.SegmentLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Country"].write(value.country, with: PinpointClientTypes.SetDimension.write(value:to:))
        try writer["GPSPoint"].write(value.gpsPoint, with: PinpointClientTypes.GPSPointDimension.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SegmentLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SegmentLocation()
        value.country = try reader["Country"].readIfPresent(with: PinpointClientTypes.SetDimension.read(from:))
        value.gpsPoint = try reader["GPSPoint"].readIfPresent(with: PinpointClientTypes.GPSPointDimension.read(from:))
        return value
    }
}

extension PinpointClientTypes.GPSPointDimension {

    static func write(value: PinpointClientTypes.GPSPointDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Coordinates"].write(value.coordinates, with: PinpointClientTypes.GPSCoordinates.write(value:to:))
        try writer["RangeInKilometers"].write(value.rangeInKilometers)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.GPSPointDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.GPSPointDimension()
        value.coordinates = try reader["Coordinates"].readIfPresent(with: PinpointClientTypes.GPSCoordinates.read(from:))
        value.rangeInKilometers = try reader["RangeInKilometers"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.GPSCoordinates {

    static func write(value: PinpointClientTypes.GPSCoordinates?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Latitude"].write(value.latitude)
        try writer["Longitude"].write(value.longitude)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.GPSCoordinates {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.GPSCoordinates()
        value.latitude = try reader["Latitude"].readIfPresent() ?? 0.0
        value.longitude = try reader["Longitude"].readIfPresent() ?? 0.0
        return value
    }
}

extension PinpointClientTypes.SegmentDemographics {

    static func write(value: PinpointClientTypes.SegmentDemographics?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppVersion"].write(value.appVersion, with: PinpointClientTypes.SetDimension.write(value:to:))
        try writer["Channel"].write(value.channel, with: PinpointClientTypes.SetDimension.write(value:to:))
        try writer["DeviceType"].write(value.deviceType, with: PinpointClientTypes.SetDimension.write(value:to:))
        try writer["Make"].write(value.make, with: PinpointClientTypes.SetDimension.write(value:to:))
        try writer["Model"].write(value.model, with: PinpointClientTypes.SetDimension.write(value:to:))
        try writer["Platform"].write(value.platform, with: PinpointClientTypes.SetDimension.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SegmentDemographics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SegmentDemographics()
        value.appVersion = try reader["AppVersion"].readIfPresent(with: PinpointClientTypes.SetDimension.read(from:))
        value.channel = try reader["Channel"].readIfPresent(with: PinpointClientTypes.SetDimension.read(from:))
        value.deviceType = try reader["DeviceType"].readIfPresent(with: PinpointClientTypes.SetDimension.read(from:))
        value.make = try reader["Make"].readIfPresent(with: PinpointClientTypes.SetDimension.read(from:))
        value.model = try reader["Model"].readIfPresent(with: PinpointClientTypes.SetDimension.read(from:))
        value.platform = try reader["Platform"].readIfPresent(with: PinpointClientTypes.SetDimension.read(from:))
        return value
    }
}

extension PinpointClientTypes.SegmentBehaviors {

    static func write(value: PinpointClientTypes.SegmentBehaviors?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Recency"].write(value.recency, with: PinpointClientTypes.RecencyDimension.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SegmentBehaviors {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SegmentBehaviors()
        value.recency = try reader["Recency"].readIfPresent(with: PinpointClientTypes.RecencyDimension.read(from:))
        return value
    }
}

extension PinpointClientTypes.RecencyDimension {

    static func write(value: PinpointClientTypes.RecencyDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Duration"].write(value.duration)
        try writer["RecencyType"].write(value.recencyType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.RecencyDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.RecencyDimension()
        value.duration = try reader["Duration"].readIfPresent() ?? .sdkUnknown("")
        value.recencyType = try reader["RecencyType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PinpointClientTypes.EventCondition {

    static func write(value: PinpointClientTypes.EventCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dimensions"].write(value.dimensions, with: PinpointClientTypes.EventDimensions.write(value:to:))
        try writer["MessageActivity"].write(value.messageActivity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EventCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EventCondition()
        value.dimensions = try reader["Dimensions"].readIfPresent(with: PinpointClientTypes.EventDimensions.read(from:))
        value.messageActivity = try reader["MessageActivity"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.HoldoutActivity {

    static func write(value: PinpointClientTypes.HoldoutActivity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextActivity"].write(value.nextActivity)
        try writer["Percentage"].write(value.percentage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.HoldoutActivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.HoldoutActivity()
        value.nextActivity = try reader["NextActivity"].readIfPresent()
        value.percentage = try reader["Percentage"].readIfPresent() ?? 0
        return value
    }
}

extension PinpointClientTypes.EmailMessageActivity {

    static func write(value: PinpointClientTypes.EmailMessageActivity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MessageConfig"].write(value.messageConfig, with: PinpointClientTypes.JourneyEmailMessage.write(value:to:))
        try writer["NextActivity"].write(value.nextActivity)
        try writer["TemplateName"].write(value.templateName)
        try writer["TemplateVersion"].write(value.templateVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EmailMessageActivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EmailMessageActivity()
        value.messageConfig = try reader["MessageConfig"].readIfPresent(with: PinpointClientTypes.JourneyEmailMessage.read(from:))
        value.nextActivity = try reader["NextActivity"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent()
        value.templateVersion = try reader["TemplateVersion"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.JourneyEmailMessage {

    static func write(value: PinpointClientTypes.JourneyEmailMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromAddress"].write(value.fromAddress)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyEmailMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyEmailMessage()
        value.fromAddress = try reader["FromAddress"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.ConditionalSplitActivity {

    static func write(value: PinpointClientTypes.ConditionalSplitActivity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Condition"].write(value.condition, with: PinpointClientTypes.Condition.write(value:to:))
        try writer["EvaluationWaitTime"].write(value.evaluationWaitTime, with: PinpointClientTypes.WaitTime.write(value:to:))
        try writer["FalseActivity"].write(value.falseActivity)
        try writer["TrueActivity"].write(value.trueActivity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ConditionalSplitActivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ConditionalSplitActivity()
        value.condition = try reader["Condition"].readIfPresent(with: PinpointClientTypes.Condition.read(from:))
        value.evaluationWaitTime = try reader["EvaluationWaitTime"].readIfPresent(with: PinpointClientTypes.WaitTime.read(from:))
        value.falseActivity = try reader["FalseActivity"].readIfPresent()
        value.trueActivity = try reader["TrueActivity"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.Condition {

    static func write(value: PinpointClientTypes.Condition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Conditions"].writeList(value.conditions, memberWritingClosure: PinpointClientTypes.SimpleCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Operator"].write(value.`operator`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.Condition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.Condition()
        value.conditions = try reader["Conditions"].readListIfPresent(memberReadingClosure: PinpointClientTypes.SimpleCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.`operator` = try reader["Operator"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.CustomMessageActivity {

    static func write(value: PinpointClientTypes.CustomMessageActivity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeliveryUri"].write(value.deliveryUri)
        try writer["EndpointTypes"].writeList(value.endpointTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PinpointClientTypes.__EndpointTypesElement>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MessageConfig"].write(value.messageConfig, with: PinpointClientTypes.JourneyCustomMessage.write(value:to:))
        try writer["NextActivity"].write(value.nextActivity)
        try writer["TemplateName"].write(value.templateName)
        try writer["TemplateVersion"].write(value.templateVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CustomMessageActivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CustomMessageActivity()
        value.deliveryUri = try reader["DeliveryUri"].readIfPresent()
        value.endpointTypes = try reader["EndpointTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PinpointClientTypes.__EndpointTypesElement>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.messageConfig = try reader["MessageConfig"].readIfPresent(with: PinpointClientTypes.JourneyCustomMessage.read(from:))
        value.nextActivity = try reader["NextActivity"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent()
        value.templateVersion = try reader["TemplateVersion"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.JourneyCustomMessage {

    static func write(value: PinpointClientTypes.JourneyCustomMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Data"].write(value.data)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyCustomMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyCustomMessage()
        value.data = try reader["Data"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.RecommenderConfigurationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.RecommenderConfigurationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.RecommenderConfigurationResponse()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.creationDate = try reader["CreationDate"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.recommendationProviderIdType = try reader["RecommendationProviderIdType"].readIfPresent()
        value.recommendationProviderRoleArn = try reader["RecommendationProviderRoleArn"].readIfPresent() ?? ""
        value.recommendationProviderUri = try reader["RecommendationProviderUri"].readIfPresent() ?? ""
        value.recommendationTransformerUri = try reader["RecommendationTransformerUri"].readIfPresent()
        value.recommendationsDisplayName = try reader["RecommendationsDisplayName"].readIfPresent()
        value.recommendationsPerMessage = try reader["RecommendationsPerMessage"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.SegmentResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SegmentResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SegmentResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.creationDate = try reader["CreationDate"].readIfPresent() ?? ""
        value.dimensions = try reader["Dimensions"].readIfPresent(with: PinpointClientTypes.SegmentDimensions.read(from:))
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.importDefinition = try reader["ImportDefinition"].readIfPresent(with: PinpointClientTypes.SegmentImportResource.read(from:))
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.segmentGroups = try reader["SegmentGroups"].readIfPresent(with: PinpointClientTypes.SegmentGroupList.read(from:))
        value.segmentType = try reader["SegmentType"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.SegmentGroupList {

    static func write(value: PinpointClientTypes.SegmentGroupList?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Groups"].writeList(value.groups, memberWritingClosure: PinpointClientTypes.SegmentGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Include"].write(value.include)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SegmentGroupList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SegmentGroupList()
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: PinpointClientTypes.SegmentGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.include = try reader["Include"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.SegmentGroup {

    static func write(value: PinpointClientTypes.SegmentGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dimensions"].writeList(value.dimensions, memberWritingClosure: PinpointClientTypes.SegmentDimensions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceSegments"].writeList(value.sourceSegments, memberWritingClosure: PinpointClientTypes.SegmentReference.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceType"].write(value.sourceType)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SegmentGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SegmentGroup()
        value.dimensions = try reader["Dimensions"].readListIfPresent(memberReadingClosure: PinpointClientTypes.SegmentDimensions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceSegments = try reader["SourceSegments"].readListIfPresent(memberReadingClosure: PinpointClientTypes.SegmentReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.SegmentReference {

    static func write(value: PinpointClientTypes.SegmentReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SegmentReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SegmentReference()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.SegmentImportResource {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SegmentImportResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SegmentImportResource()
        value.channelCounts = try reader["ChannelCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.externalId = try reader["ExternalId"].readIfPresent() ?? ""
        value.format = try reader["Format"].readIfPresent() ?? .sdkUnknown("")
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        value.s3Url = try reader["S3Url"].readIfPresent() ?? ""
        value.size = try reader["Size"].readIfPresent() ?? 0
        return value
    }
}

extension PinpointClientTypes.ADMChannelResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ADMChannelResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ADMChannelResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.hasCredential = try reader["HasCredential"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.isArchived = try reader["IsArchived"].readIfPresent()
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.APNSChannelResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.APNSChannelResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.APNSChannelResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.defaultAuthenticationMethod = try reader["DefaultAuthenticationMethod"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.hasCredential = try reader["HasCredential"].readIfPresent()
        value.hasTokenKey = try reader["HasTokenKey"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.isArchived = try reader["IsArchived"].readIfPresent()
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.APNSSandboxChannelResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.APNSSandboxChannelResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.APNSSandboxChannelResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.defaultAuthenticationMethod = try reader["DefaultAuthenticationMethod"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.hasCredential = try reader["HasCredential"].readIfPresent()
        value.hasTokenKey = try reader["HasTokenKey"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.isArchived = try reader["IsArchived"].readIfPresent()
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.APNSVoipChannelResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.APNSVoipChannelResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.APNSVoipChannelResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.defaultAuthenticationMethod = try reader["DefaultAuthenticationMethod"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.hasCredential = try reader["HasCredential"].readIfPresent()
        value.hasTokenKey = try reader["HasTokenKey"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.isArchived = try reader["IsArchived"].readIfPresent()
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.APNSVoipSandboxChannelResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.APNSVoipSandboxChannelResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.APNSVoipSandboxChannelResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.defaultAuthenticationMethod = try reader["DefaultAuthenticationMethod"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.hasCredential = try reader["HasCredential"].readIfPresent()
        value.hasTokenKey = try reader["HasTokenKey"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.isArchived = try reader["IsArchived"].readIfPresent()
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.BaiduChannelResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.BaiduChannelResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.BaiduChannelResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.credential = try reader["Credential"].readIfPresent() ?? ""
        value.enabled = try reader["Enabled"].readIfPresent()
        value.hasCredential = try reader["HasCredential"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.isArchived = try reader["IsArchived"].readIfPresent()
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.EmailChannelResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EmailChannelResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EmailChannelResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.configurationSet = try reader["ConfigurationSet"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.fromAddress = try reader["FromAddress"].readIfPresent()
        value.hasCredential = try reader["HasCredential"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.identity = try reader["Identity"].readIfPresent()
        value.isArchived = try reader["IsArchived"].readIfPresent()
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.messagesPerSecond = try reader["MessagesPerSecond"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent() ?? ""
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.orchestrationSendingRoleArn = try reader["OrchestrationSendingRoleArn"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.MessageBody {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.MessageBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.MessageBody()
        value.message = try reader["Message"].readIfPresent()
        value.requestID = try reader["RequestID"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.EndpointResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EndpointResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EndpointResponse()
        value.address = try reader["Address"].readIfPresent()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.channelType = try reader["ChannelType"].readIfPresent()
        value.cohortId = try reader["CohortId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.demographic = try reader["Demographic"].readIfPresent(with: PinpointClientTypes.EndpointDemographic.read(from:))
        value.effectiveDate = try reader["EffectiveDate"].readIfPresent()
        value.endpointStatus = try reader["EndpointStatus"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.location = try reader["Location"].readIfPresent(with: PinpointClientTypes.EndpointLocation.read(from:))
        value.metrics = try reader["Metrics"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.optOut = try reader["OptOut"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.user = try reader["User"].readIfPresent(with: PinpointClientTypes.EndpointUser.read(from:))
        return value
    }
}

extension PinpointClientTypes.EndpointUser {

    static func write(value: PinpointClientTypes.EndpointUser?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UserAttributes"].writeMap(value.userAttributes, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["UserId"].write(value.userId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EndpointUser {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EndpointUser()
        value.userAttributes = try reader["UserAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userId = try reader["UserId"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.EndpointLocation {

    static func write(value: PinpointClientTypes.EndpointLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["City"].write(value.city)
        try writer["Country"].write(value.country)
        try writer["Latitude"].write(value.latitude)
        try writer["Longitude"].write(value.longitude)
        try writer["PostalCode"].write(value.postalCode)
        try writer["Region"].write(value.region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EndpointLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EndpointLocation()
        value.city = try reader["City"].readIfPresent()
        value.country = try reader["Country"].readIfPresent()
        value.latitude = try reader["Latitude"].readIfPresent()
        value.longitude = try reader["Longitude"].readIfPresent()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.EndpointDemographic {

    static func write(value: PinpointClientTypes.EndpointDemographic?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppVersion"].write(value.appVersion)
        try writer["Locale"].write(value.locale)
        try writer["Make"].write(value.make)
        try writer["Model"].write(value.model)
        try writer["ModelVersion"].write(value.modelVersion)
        try writer["Platform"].write(value.platform)
        try writer["PlatformVersion"].write(value.platformVersion)
        try writer["Timezone"].write(value.timezone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EndpointDemographic {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EndpointDemographic()
        value.appVersion = try reader["AppVersion"].readIfPresent()
        value.locale = try reader["Locale"].readIfPresent()
        value.make = try reader["Make"].readIfPresent()
        value.model = try reader["Model"].readIfPresent()
        value.modelVersion = try reader["ModelVersion"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent()
        value.platformVersion = try reader["PlatformVersion"].readIfPresent()
        value.timezone = try reader["Timezone"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.EventStream {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EventStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EventStream()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.destinationStreamArn = try reader["DestinationStreamArn"].readIfPresent() ?? ""
        value.externalId = try reader["ExternalId"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.lastUpdatedBy = try reader["LastUpdatedBy"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointClientTypes.GCMChannelResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.GCMChannelResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.GCMChannelResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.credential = try reader["Credential"].readIfPresent()
        value.defaultAuthenticationMethod = try reader["DefaultAuthenticationMethod"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.hasCredential = try reader["HasCredential"].readIfPresent()
        value.hasFcmServiceCredentials = try reader["HasFcmServiceCredentials"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.isArchived = try reader["IsArchived"].readIfPresent()
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.SMSChannelResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SMSChannelResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SMSChannelResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.hasCredential = try reader["HasCredential"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.isArchived = try reader["IsArchived"].readIfPresent()
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent() ?? ""
        value.promotionalMessagesPerSecond = try reader["PromotionalMessagesPerSecond"].readIfPresent()
        value.senderId = try reader["SenderId"].readIfPresent()
        value.shortCode = try reader["ShortCode"].readIfPresent()
        value.transactionalMessagesPerSecond = try reader["TransactionalMessagesPerSecond"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.EndpointsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EndpointsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EndpointsResponse()
        value.item = try reader["Item"].readListIfPresent(memberReadingClosure: PinpointClientTypes.EndpointResponse.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PinpointClientTypes.VoiceChannelResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.VoiceChannelResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.VoiceChannelResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.hasCredential = try reader["HasCredential"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.isArchived = try reader["IsArchived"].readIfPresent()
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.ApplicationDateRangeKpiResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ApplicationDateRangeKpiResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ApplicationDateRangeKpiResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.kpiName = try reader["KpiName"].readIfPresent() ?? ""
        value.kpiResult = try reader["KpiResult"].readIfPresent(with: PinpointClientTypes.BaseKpiResult.read(from:))
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PinpointClientTypes.BaseKpiResult {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.BaseKpiResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.BaseKpiResult()
        value.rows = try reader["Rows"].readListIfPresent(memberReadingClosure: PinpointClientTypes.ResultRow.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PinpointClientTypes.ResultRow {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ResultRow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ResultRow()
        value.groupedBys = try reader["GroupedBys"].readListIfPresent(memberReadingClosure: PinpointClientTypes.ResultRowValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: PinpointClientTypes.ResultRowValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PinpointClientTypes.ResultRowValue {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ResultRowValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ResultRowValue()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointClientTypes.ApplicationSettingsResource {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ApplicationSettingsResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ApplicationSettingsResource()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.campaignHook = try reader["CampaignHook"].readIfPresent(with: PinpointClientTypes.CampaignHook.read(from:))
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.limits = try reader["Limits"].readIfPresent(with: PinpointClientTypes.CampaignLimits.read(from:))
        value.quietTime = try reader["QuietTime"].readIfPresent(with: PinpointClientTypes.QuietTime.read(from:))
        value.journeyLimits = try reader["JourneyLimits"].readIfPresent(with: PinpointClientTypes.ApplicationSettingsJourneyLimits.read(from:))
        return value
    }
}

extension PinpointClientTypes.ApplicationSettingsJourneyLimits {

    static func write(value: PinpointClientTypes.ApplicationSettingsJourneyLimits?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DailyCap"].write(value.dailyCap)
        try writer["TimeframeCap"].write(value.timeframeCap, with: PinpointClientTypes.JourneyTimeframeCap.write(value:to:))
        try writer["TotalCap"].write(value.totalCap)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ApplicationSettingsJourneyLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ApplicationSettingsJourneyLimits()
        value.dailyCap = try reader["DailyCap"].readIfPresent()
        value.timeframeCap = try reader["TimeframeCap"].readIfPresent(with: PinpointClientTypes.JourneyTimeframeCap.read(from:))
        value.totalCap = try reader["TotalCap"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.ApplicationsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ApplicationsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ApplicationsResponse()
        value.item = try reader["Item"].readListIfPresent(memberReadingClosure: PinpointClientTypes.ApplicationResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.ActivitiesResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ActivitiesResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ActivitiesResponse()
        value.item = try reader["Item"].readListIfPresent(memberReadingClosure: PinpointClientTypes.ActivityResponse.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.ActivityResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ActivityResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ActivityResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.campaignId = try reader["CampaignId"].readIfPresent() ?? ""
        value.end = try reader["End"].readIfPresent()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.result = try reader["Result"].readIfPresent()
        value.scheduledStart = try reader["ScheduledStart"].readIfPresent()
        value.start = try reader["Start"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.successfulEndpointCount = try reader["SuccessfulEndpointCount"].readIfPresent()
        value.timezonesCompletedCount = try reader["TimezonesCompletedCount"].readIfPresent()
        value.timezonesTotalCount = try reader["TimezonesTotalCount"].readIfPresent()
        value.totalEndpointCount = try reader["TotalEndpointCount"].readIfPresent()
        value.treatmentId = try reader["TreatmentId"].readIfPresent()
        value.executionMetrics = try reader["ExecutionMetrics"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.CampaignDateRangeKpiResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CampaignDateRangeKpiResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CampaignDateRangeKpiResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.campaignId = try reader["CampaignId"].readIfPresent() ?? ""
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.kpiName = try reader["KpiName"].readIfPresent() ?? ""
        value.kpiResult = try reader["KpiResult"].readIfPresent(with: PinpointClientTypes.BaseKpiResult.read(from:))
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PinpointClientTypes.CampaignsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.CampaignsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.CampaignsResponse()
        value.item = try reader["Item"].readListIfPresent(memberReadingClosure: PinpointClientTypes.CampaignResponse.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.ChannelsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ChannelsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ChannelsResponse()
        value.channels = try reader["Channels"].readMapIfPresent(valueReadingClosure: PinpointClientTypes.ChannelResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension PinpointClientTypes.ChannelResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ChannelResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ChannelResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.hasCredential = try reader["HasCredential"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.isArchived = try reader["IsArchived"].readIfPresent()
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.EmailTemplateResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EmailTemplateResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EmailTemplateResponse()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent() ?? ""
        value.defaultSubstitutions = try reader["DefaultSubstitutions"].readIfPresent()
        value.htmlPart = try reader["HtmlPart"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent() ?? ""
        value.recommenderId = try reader["RecommenderId"].readIfPresent()
        value.subject = try reader["Subject"].readIfPresent()
        value.headers = try reader["Headers"].readListIfPresent(memberReadingClosure: PinpointClientTypes.MessageHeader.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateDescription = try reader["TemplateDescription"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent() ?? ""
        value.templateType = try reader["TemplateType"].readIfPresent() ?? .sdkUnknown("")
        value.textPart = try reader["TextPart"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.ExportJobsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ExportJobsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ExportJobsResponse()
        value.item = try reader["Item"].readListIfPresent(memberReadingClosure: PinpointClientTypes.ExportJobResponse.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.ImportJobsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ImportJobsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ImportJobsResponse()
        value.item = try reader["Item"].readListIfPresent(memberReadingClosure: PinpointClientTypes.ImportJobResponse.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.InAppMessagesResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.InAppMessagesResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.InAppMessagesResponse()
        value.inAppMessageCampaigns = try reader["InAppMessageCampaigns"].readListIfPresent(memberReadingClosure: PinpointClientTypes.InAppMessageCampaign.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.InAppMessageCampaign {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.InAppMessageCampaign {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.InAppMessageCampaign()
        value.campaignId = try reader["CampaignId"].readIfPresent()
        value.dailyCap = try reader["DailyCap"].readIfPresent()
        value.inAppMessage = try reader["InAppMessage"].readIfPresent(with: PinpointClientTypes.InAppMessage.read(from:))
        value.priority = try reader["Priority"].readIfPresent()
        value.schedule = try reader["Schedule"].readIfPresent(with: PinpointClientTypes.InAppCampaignSchedule.read(from:))
        value.sessionCap = try reader["SessionCap"].readIfPresent()
        value.totalCap = try reader["TotalCap"].readIfPresent()
        value.treatmentId = try reader["TreatmentId"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.InAppCampaignSchedule {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.InAppCampaignSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.InAppCampaignSchedule()
        value.endDate = try reader["EndDate"].readIfPresent()
        value.eventFilter = try reader["EventFilter"].readIfPresent(with: PinpointClientTypes.CampaignEventFilter.read(from:))
        value.quietTime = try reader["QuietTime"].readIfPresent(with: PinpointClientTypes.QuietTime.read(from:))
        return value
    }
}

extension PinpointClientTypes.InAppMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.InAppMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.InAppMessage()
        value.content = try reader["Content"].readListIfPresent(memberReadingClosure: PinpointClientTypes.InAppMessageContent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.customConfig = try reader["CustomConfig"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.layout = try reader["Layout"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.InAppTemplateResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.InAppTemplateResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.InAppTemplateResponse()
        value.arn = try reader["Arn"].readIfPresent()
        value.content = try reader["Content"].readListIfPresent(memberReadingClosure: PinpointClientTypes.InAppMessageContent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationDate = try reader["CreationDate"].readIfPresent() ?? ""
        value.customConfig = try reader["CustomConfig"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent() ?? ""
        value.layout = try reader["Layout"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateDescription = try reader["TemplateDescription"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent() ?? ""
        value.templateType = try reader["TemplateType"].readIfPresent() ?? .sdkUnknown("")
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.JourneyDateRangeKpiResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyDateRangeKpiResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyDateRangeKpiResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.journeyId = try reader["JourneyId"].readIfPresent() ?? ""
        value.kpiName = try reader["KpiName"].readIfPresent() ?? ""
        value.kpiResult = try reader["KpiResult"].readIfPresent(with: PinpointClientTypes.BaseKpiResult.read(from:))
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PinpointClientTypes.JourneyExecutionActivityMetricsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyExecutionActivityMetricsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyExecutionActivityMetricsResponse()
        value.activityType = try reader["ActivityType"].readIfPresent() ?? ""
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.journeyActivityId = try reader["JourneyActivityId"].readIfPresent() ?? ""
        value.journeyId = try reader["JourneyId"].readIfPresent() ?? ""
        value.lastEvaluatedTime = try reader["LastEvaluatedTime"].readIfPresent() ?? ""
        value.metrics = try reader["Metrics"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension PinpointClientTypes.JourneyExecutionMetricsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyExecutionMetricsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyExecutionMetricsResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.journeyId = try reader["JourneyId"].readIfPresent() ?? ""
        value.lastEvaluatedTime = try reader["LastEvaluatedTime"].readIfPresent() ?? ""
        value.metrics = try reader["Metrics"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension PinpointClientTypes.JourneyRunExecutionActivityMetricsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyRunExecutionActivityMetricsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyRunExecutionActivityMetricsResponse()
        value.activityType = try reader["ActivityType"].readIfPresent() ?? ""
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.journeyActivityId = try reader["JourneyActivityId"].readIfPresent() ?? ""
        value.journeyId = try reader["JourneyId"].readIfPresent() ?? ""
        value.lastEvaluatedTime = try reader["LastEvaluatedTime"].readIfPresent() ?? ""
        value.metrics = try reader["Metrics"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.runId = try reader["RunId"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointClientTypes.JourneyRunExecutionMetricsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyRunExecutionMetricsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyRunExecutionMetricsResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.journeyId = try reader["JourneyId"].readIfPresent() ?? ""
        value.lastEvaluatedTime = try reader["LastEvaluatedTime"].readIfPresent() ?? ""
        value.metrics = try reader["Metrics"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.runId = try reader["RunId"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointClientTypes.JourneyRunsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyRunsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyRunsResponse()
        value.item = try reader["Item"].readListIfPresent(memberReadingClosure: PinpointClientTypes.JourneyRunResponse.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.JourneyRunResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneyRunResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneyRunResponse()
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? ""
        value.lastUpdateTime = try reader["LastUpdateTime"].readIfPresent() ?? ""
        value.runId = try reader["RunId"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PinpointClientTypes.PushNotificationTemplateResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.PushNotificationTemplateResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.PushNotificationTemplateResponse()
        value.adm = try reader["ADM"].readIfPresent(with: PinpointClientTypes.AndroidPushNotificationTemplate.read(from:))
        value.apns = try reader["APNS"].readIfPresent(with: PinpointClientTypes.APNSPushNotificationTemplate.read(from:))
        value.arn = try reader["Arn"].readIfPresent()
        value.baidu = try reader["Baidu"].readIfPresent(with: PinpointClientTypes.AndroidPushNotificationTemplate.read(from:))
        value.creationDate = try reader["CreationDate"].readIfPresent() ?? ""
        value.`default` = try reader["Default"].readIfPresent(with: PinpointClientTypes.DefaultPushNotificationTemplate.read(from:))
        value.defaultSubstitutions = try reader["DefaultSubstitutions"].readIfPresent()
        value.gcm = try reader["GCM"].readIfPresent(with: PinpointClientTypes.AndroidPushNotificationTemplate.read(from:))
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent() ?? ""
        value.recommenderId = try reader["RecommenderId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateDescription = try reader["TemplateDescription"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent() ?? ""
        value.templateType = try reader["TemplateType"].readIfPresent() ?? .sdkUnknown("")
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.AndroidPushNotificationTemplate {

    static func write(value: PinpointClientTypes.AndroidPushNotificationTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Body"].write(value.body)
        try writer["ImageIconUrl"].write(value.imageIconUrl)
        try writer["ImageUrl"].write(value.imageUrl)
        try writer["RawContent"].write(value.rawContent)
        try writer["SmallImageIconUrl"].write(value.smallImageIconUrl)
        try writer["Sound"].write(value.sound)
        try writer["Title"].write(value.title)
        try writer["Url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.AndroidPushNotificationTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.AndroidPushNotificationTemplate()
        value.action = try reader["Action"].readIfPresent()
        value.body = try reader["Body"].readIfPresent()
        value.imageIconUrl = try reader["ImageIconUrl"].readIfPresent()
        value.imageUrl = try reader["ImageUrl"].readIfPresent()
        value.rawContent = try reader["RawContent"].readIfPresent()
        value.smallImageIconUrl = try reader["SmallImageIconUrl"].readIfPresent()
        value.sound = try reader["Sound"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.DefaultPushNotificationTemplate {

    static func write(value: PinpointClientTypes.DefaultPushNotificationTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Body"].write(value.body)
        try writer["Sound"].write(value.sound)
        try writer["Title"].write(value.title)
        try writer["Url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.DefaultPushNotificationTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.DefaultPushNotificationTemplate()
        value.action = try reader["Action"].readIfPresent()
        value.body = try reader["Body"].readIfPresent()
        value.sound = try reader["Sound"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.APNSPushNotificationTemplate {

    static func write(value: PinpointClientTypes.APNSPushNotificationTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Body"].write(value.body)
        try writer["MediaUrl"].write(value.mediaUrl)
        try writer["RawContent"].write(value.rawContent)
        try writer["Sound"].write(value.sound)
        try writer["Title"].write(value.title)
        try writer["Url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.APNSPushNotificationTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.APNSPushNotificationTemplate()
        value.action = try reader["Action"].readIfPresent()
        value.body = try reader["Body"].readIfPresent()
        value.mediaUrl = try reader["MediaUrl"].readIfPresent()
        value.rawContent = try reader["RawContent"].readIfPresent()
        value.sound = try reader["Sound"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.ListRecommenderConfigurationsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ListRecommenderConfigurationsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ListRecommenderConfigurationsResponse()
        value.item = try reader["Item"].readListIfPresent(memberReadingClosure: PinpointClientTypes.RecommenderConfigurationResponse.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.SegmentsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SegmentsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SegmentsResponse()
        value.item = try reader["Item"].readListIfPresent(memberReadingClosure: PinpointClientTypes.SegmentResponse.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.SMSTemplateResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SMSTemplateResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SMSTemplateResponse()
        value.arn = try reader["Arn"].readIfPresent()
        value.body = try reader["Body"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent() ?? ""
        value.defaultSubstitutions = try reader["DefaultSubstitutions"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent() ?? ""
        value.recommenderId = try reader["RecommenderId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateDescription = try reader["TemplateDescription"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent() ?? ""
        value.templateType = try reader["TemplateType"].readIfPresent() ?? .sdkUnknown("")
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.VoiceTemplateResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.VoiceTemplateResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.VoiceTemplateResponse()
        value.arn = try reader["Arn"].readIfPresent()
        value.body = try reader["Body"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent() ?? ""
        value.defaultSubstitutions = try reader["DefaultSubstitutions"].readIfPresent()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateDescription = try reader["TemplateDescription"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent() ?? ""
        value.templateType = try reader["TemplateType"].readIfPresent() ?? .sdkUnknown("")
        value.version = try reader["Version"].readIfPresent()
        value.voiceId = try reader["VoiceId"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.JourneysResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.JourneysResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.JourneysResponse()
        value.item = try reader["Item"].readListIfPresent(memberReadingClosure: PinpointClientTypes.JourneyResponse.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.TagsModel {

    static func write(value: PinpointClientTypes.TagsModel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.TagsModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.TagsModel()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension PinpointClientTypes.TemplatesResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.TemplatesResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.TemplatesResponse()
        value.item = try reader["Item"].readListIfPresent(memberReadingClosure: PinpointClientTypes.TemplateResponse.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.TemplateResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.TemplateResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.TemplateResponse()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent() ?? ""
        value.defaultSubstitutions = try reader["DefaultSubstitutions"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateDescription = try reader["TemplateDescription"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent() ?? ""
        value.templateType = try reader["TemplateType"].readIfPresent() ?? .sdkUnknown("")
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.TemplateVersionsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.TemplateVersionsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.TemplateVersionsResponse()
        value.item = try reader["Item"].readListIfPresent(memberReadingClosure: PinpointClientTypes.TemplateVersionResponse.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.message = try reader["Message"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestID = try reader["RequestID"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.TemplateVersionResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.TemplateVersionResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.TemplateVersionResponse()
        value.creationDate = try reader["CreationDate"].readIfPresent() ?? ""
        value.defaultSubstitutions = try reader["DefaultSubstitutions"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent() ?? ""
        value.templateDescription = try reader["TemplateDescription"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent() ?? ""
        value.templateType = try reader["TemplateType"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.NumberValidateResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.NumberValidateResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.NumberValidateResponse()
        value.carrier = try reader["Carrier"].readIfPresent()
        value.city = try reader["City"].readIfPresent()
        value.cleansedPhoneNumberE164 = try reader["CleansedPhoneNumberE164"].readIfPresent()
        value.cleansedPhoneNumberNational = try reader["CleansedPhoneNumberNational"].readIfPresent()
        value.country = try reader["Country"].readIfPresent()
        value.countryCodeIso2 = try reader["CountryCodeIso2"].readIfPresent()
        value.countryCodeNumeric = try reader["CountryCodeNumeric"].readIfPresent()
        value.county = try reader["County"].readIfPresent()
        value.originalCountryCodeIso2 = try reader["OriginalCountryCodeIso2"].readIfPresent()
        value.originalPhoneNumber = try reader["OriginalPhoneNumber"].readIfPresent()
        value.phoneType = try reader["PhoneType"].readIfPresent()
        value.phoneTypeCode = try reader["PhoneTypeCode"].readIfPresent()
        value.timezone = try reader["Timezone"].readIfPresent()
        value.zipCode = try reader["ZipCode"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.EventsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EventsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EventsResponse()
        value.results = try reader["Results"].readMapIfPresent(valueReadingClosure: PinpointClientTypes.ItemResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.ItemResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.ItemResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.ItemResponse()
        value.endpointItemResponse = try reader["EndpointItemResponse"].readIfPresent(with: PinpointClientTypes.EndpointItemResponse.read(from:))
        value.eventsItemResponse = try reader["EventsItemResponse"].readMapIfPresent(valueReadingClosure: PinpointClientTypes.EventItemResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.EventItemResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EventItemResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EventItemResponse()
        value.message = try reader["Message"].readIfPresent()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.EndpointItemResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EndpointItemResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EndpointItemResponse()
        value.message = try reader["Message"].readIfPresent()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.AttributesResource {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.AttributesResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.AttributesResource()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.attributeType = try reader["AttributeType"].readIfPresent() ?? ""
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.MessageResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.MessageResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.MessageResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.endpointResult = try reader["EndpointResult"].readMapIfPresent(valueReadingClosure: PinpointClientTypes.EndpointMessageResult.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.result = try reader["Result"].readMapIfPresent(valueReadingClosure: PinpointClientTypes.MessageResult.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.MessageResult {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.MessageResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.MessageResult()
        value.deliveryStatus = try reader["DeliveryStatus"].readIfPresent() ?? .sdkUnknown("")
        value.messageId = try reader["MessageId"].readIfPresent()
        value.statusCode = try reader["StatusCode"].readIfPresent() ?? 0
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.updatedToken = try reader["UpdatedToken"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.EndpointMessageResult {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.EndpointMessageResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.EndpointMessageResult()
        value.address = try reader["Address"].readIfPresent()
        value.deliveryStatus = try reader["DeliveryStatus"].readIfPresent() ?? .sdkUnknown("")
        value.messageId = try reader["MessageId"].readIfPresent()
        value.statusCode = try reader["StatusCode"].readIfPresent() ?? 0
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.updatedToken = try reader["UpdatedToken"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.SendUsersMessageResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.SendUsersMessageResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.SendUsersMessageResponse()
        value.applicationId = try reader["ApplicationId"].readIfPresent() ?? ""
        value.requestId = try reader["RequestId"].readIfPresent()
        value.result = try reader["Result"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: PinpointClientTypes.EndpointMessageResult.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PinpointClientTypes.VerificationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointClientTypes.VerificationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointClientTypes.VerificationResponse()
        value.valid = try reader["Valid"].readIfPresent()
        return value
    }
}

extension PinpointClientTypes.CreateApplicationRequest {

    static func write(value: PinpointClientTypes.CreateApplicationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PinpointClientTypes.WriteCampaignRequest {

    static func write(value: PinpointClientTypes.WriteCampaignRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalTreatments"].writeList(value.additionalTreatments, memberWritingClosure: PinpointClientTypes.WriteTreatmentResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CustomDeliveryConfiguration"].write(value.customDeliveryConfiguration, with: PinpointClientTypes.CustomDeliveryConfiguration.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["HoldoutPercent"].write(value.holdoutPercent)
        try writer["Hook"].write(value.hook, with: PinpointClientTypes.CampaignHook.write(value:to:))
        try writer["IsPaused"].write(value.isPaused)
        try writer["Limits"].write(value.limits, with: PinpointClientTypes.CampaignLimits.write(value:to:))
        try writer["MessageConfiguration"].write(value.messageConfiguration, with: PinpointClientTypes.MessageConfiguration.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Priority"].write(value.priority)
        try writer["Schedule"].write(value.schedule, with: PinpointClientTypes.Schedule.write(value:to:))
        try writer["SegmentId"].write(value.segmentId)
        try writer["SegmentVersion"].write(value.segmentVersion)
        try writer["TemplateConfiguration"].write(value.templateConfiguration, with: PinpointClientTypes.TemplateConfiguration.write(value:to:))
        try writer["TreatmentDescription"].write(value.treatmentDescription)
        try writer["TreatmentName"].write(value.treatmentName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PinpointClientTypes.WriteTreatmentResource {

    static func write(value: PinpointClientTypes.WriteTreatmentResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomDeliveryConfiguration"].write(value.customDeliveryConfiguration, with: PinpointClientTypes.CustomDeliveryConfiguration.write(value:to:))
        try writer["MessageConfiguration"].write(value.messageConfiguration, with: PinpointClientTypes.MessageConfiguration.write(value:to:))
        try writer["Schedule"].write(value.schedule, with: PinpointClientTypes.Schedule.write(value:to:))
        try writer["SizePercent"].write(value.sizePercent)
        try writer["TemplateConfiguration"].write(value.templateConfiguration, with: PinpointClientTypes.TemplateConfiguration.write(value:to:))
        try writer["TreatmentDescription"].write(value.treatmentDescription)
        try writer["TreatmentName"].write(value.treatmentName)
    }
}

extension PinpointClientTypes.EmailTemplateRequest {

    static func write(value: PinpointClientTypes.EmailTemplateRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultSubstitutions"].write(value.defaultSubstitutions)
        try writer["Headers"].writeList(value.headers, memberWritingClosure: PinpointClientTypes.MessageHeader.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HtmlPart"].write(value.htmlPart)
        try writer["RecommenderId"].write(value.recommenderId)
        try writer["Subject"].write(value.subject)
        try writer["TemplateDescription"].write(value.templateDescription)
        try writer["TextPart"].write(value.textPart)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PinpointClientTypes.ExportJobRequest {

    static func write(value: PinpointClientTypes.ExportJobRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoleArn"].write(value.roleArn)
        try writer["S3UrlPrefix"].write(value.s3UrlPrefix)
        try writer["SegmentId"].write(value.segmentId)
        try writer["SegmentVersion"].write(value.segmentVersion)
    }
}

extension PinpointClientTypes.ImportJobRequest {

    static func write(value: PinpointClientTypes.ImportJobRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefineSegment"].write(value.defineSegment)
        try writer["ExternalId"].write(value.externalId)
        try writer["Format"].write(value.format)
        try writer["RegisterEndpoints"].write(value.registerEndpoints)
        try writer["RoleArn"].write(value.roleArn)
        try writer["S3Url"].write(value.s3Url)
        try writer["SegmentId"].write(value.segmentId)
        try writer["SegmentName"].write(value.segmentName)
    }
}

extension PinpointClientTypes.InAppTemplateRequest {

    static func write(value: PinpointClientTypes.InAppTemplateRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].writeList(value.content, memberWritingClosure: PinpointClientTypes.InAppMessageContent.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CustomConfig"].writeMap(value.customConfig, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Layout"].write(value.layout)
        try writer["TemplateDescription"].write(value.templateDescription)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PinpointClientTypes.WriteJourneyRequest {

    static func write(value: PinpointClientTypes.WriteJourneyRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Activities"].writeMap(value.activities, valueWritingClosure: PinpointClientTypes.Activity.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ClosedDays"].write(value.closedDays, with: PinpointClientTypes.ClosedDays.write(value:to:))
        try writer["CreationDate"].write(value.creationDate)
        try writer["JourneyChannelSettings"].write(value.journeyChannelSettings, with: PinpointClientTypes.JourneyChannelSettings.write(value:to:))
        try writer["LastModifiedDate"].write(value.lastModifiedDate)
        try writer["Limits"].write(value.limits, with: PinpointClientTypes.JourneyLimits.write(value:to:))
        try writer["LocalTime"].write(value.localTime)
        try writer["Name"].write(value.name)
        try writer["OpenHours"].write(value.openHours, with: PinpointClientTypes.OpenHours.write(value:to:))
        try writer["QuietTime"].write(value.quietTime, with: PinpointClientTypes.QuietTime.write(value:to:))
        try writer["RefreshFrequency"].write(value.refreshFrequency)
        try writer["RefreshOnSegmentUpdate"].write(value.refreshOnSegmentUpdate)
        try writer["Schedule"].write(value.schedule, with: PinpointClientTypes.JourneySchedule.write(value:to:))
        try writer["SendingSchedule"].write(value.sendingSchedule)
        try writer["StartActivity"].write(value.startActivity)
        try writer["StartCondition"].write(value.startCondition, with: PinpointClientTypes.StartCondition.write(value:to:))
        try writer["State"].write(value.state)
        try writer["TimezoneEstimationMethods"].writeList(value.timezoneEstimationMethods, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PinpointClientTypes.__TimezoneEstimationMethodsElement>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WaitForQuietTime"].write(value.waitForQuietTime)
    }
}

extension PinpointClientTypes.PushNotificationTemplateRequest {

    static func write(value: PinpointClientTypes.PushNotificationTemplateRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ADM"].write(value.adm, with: PinpointClientTypes.AndroidPushNotificationTemplate.write(value:to:))
        try writer["APNS"].write(value.apns, with: PinpointClientTypes.APNSPushNotificationTemplate.write(value:to:))
        try writer["Baidu"].write(value.baidu, with: PinpointClientTypes.AndroidPushNotificationTemplate.write(value:to:))
        try writer["Default"].write(value.`default`, with: PinpointClientTypes.DefaultPushNotificationTemplate.write(value:to:))
        try writer["DefaultSubstitutions"].write(value.defaultSubstitutions)
        try writer["GCM"].write(value.gcm, with: PinpointClientTypes.AndroidPushNotificationTemplate.write(value:to:))
        try writer["RecommenderId"].write(value.recommenderId)
        try writer["TemplateDescription"].write(value.templateDescription)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PinpointClientTypes.CreateRecommenderConfigurationShape {

    static func write(value: PinpointClientTypes.CreateRecommenderConfigurationShape?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["RecommendationProviderIdType"].write(value.recommendationProviderIdType)
        try writer["RecommendationProviderRoleArn"].write(value.recommendationProviderRoleArn)
        try writer["RecommendationProviderUri"].write(value.recommendationProviderUri)
        try writer["RecommendationTransformerUri"].write(value.recommendationTransformerUri)
        try writer["RecommendationsDisplayName"].write(value.recommendationsDisplayName)
        try writer["RecommendationsPerMessage"].write(value.recommendationsPerMessage)
    }
}

extension PinpointClientTypes.WriteSegmentRequest {

    static func write(value: PinpointClientTypes.WriteSegmentRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dimensions"].write(value.dimensions, with: PinpointClientTypes.SegmentDimensions.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["SegmentGroups"].write(value.segmentGroups, with: PinpointClientTypes.SegmentGroupList.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PinpointClientTypes.SMSTemplateRequest {

    static func write(value: PinpointClientTypes.SMSTemplateRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Body"].write(value.body)
        try writer["DefaultSubstitutions"].write(value.defaultSubstitutions)
        try writer["RecommenderId"].write(value.recommenderId)
        try writer["TemplateDescription"].write(value.templateDescription)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PinpointClientTypes.VoiceTemplateRequest {

    static func write(value: PinpointClientTypes.VoiceTemplateRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Body"].write(value.body)
        try writer["DefaultSubstitutions"].write(value.defaultSubstitutions)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["TemplateDescription"].write(value.templateDescription)
        try writer["VoiceId"].write(value.voiceId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PinpointClientTypes.NumberValidateRequest {

    static func write(value: PinpointClientTypes.NumberValidateRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsoCountryCode"].write(value.isoCountryCode)
        try writer["PhoneNumber"].write(value.phoneNumber)
    }
}

extension PinpointClientTypes.EventsRequest {

    static func write(value: PinpointClientTypes.EventsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BatchItem"].writeMap(value.batchItem, valueWritingClosure: PinpointClientTypes.EventsBatch.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PinpointClientTypes.EventsBatch {

    static func write(value: PinpointClientTypes.EventsBatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Endpoint"].write(value.endpoint, with: PinpointClientTypes.PublicEndpoint.write(value:to:))
        try writer["Events"].writeMap(value.events, valueWritingClosure: PinpointClientTypes.Event.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PinpointClientTypes.Event {

    static func write(value: PinpointClientTypes.Event?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppPackageName"].write(value.appPackageName)
        try writer["AppTitle"].write(value.appTitle)
        try writer["AppVersionCode"].write(value.appVersionCode)
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ClientSdkVersion"].write(value.clientSdkVersion)
        try writer["EventType"].write(value.eventType)
        try writer["Metrics"].writeMap(value.metrics, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SdkName"].write(value.sdkName)
        try writer["Session"].write(value.session, with: PinpointClientTypes.Session.write(value:to:))
        try writer["Timestamp"].write(value.timestamp)
    }
}

extension PinpointClientTypes.Session {

    static func write(value: PinpointClientTypes.Session?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Duration"].write(value.duration)
        try writer["Id"].write(value.id)
        try writer["StartTimestamp"].write(value.startTimestamp)
        try writer["StopTimestamp"].write(value.stopTimestamp)
    }
}

extension PinpointClientTypes.PublicEndpoint {

    static func write(value: PinpointClientTypes.PublicEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address)
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ChannelType"].write(value.channelType)
        try writer["Demographic"].write(value.demographic, with: PinpointClientTypes.EndpointDemographic.write(value:to:))
        try writer["EffectiveDate"].write(value.effectiveDate)
        try writer["EndpointStatus"].write(value.endpointStatus)
        try writer["Location"].write(value.location, with: PinpointClientTypes.EndpointLocation.write(value:to:))
        try writer["Metrics"].writeMap(value.metrics, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["OptOut"].write(value.optOut)
        try writer["RequestId"].write(value.requestId)
        try writer["User"].write(value.user, with: PinpointClientTypes.EndpointUser.write(value:to:))
    }
}

extension PinpointClientTypes.WriteEventStream {

    static func write(value: PinpointClientTypes.WriteEventStream?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationStreamArn"].write(value.destinationStreamArn)
        try writer["RoleArn"].write(value.roleArn)
    }
}

extension PinpointClientTypes.UpdateAttributesRequest {

    static func write(value: PinpointClientTypes.UpdateAttributesRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Blacklist"].writeList(value.blacklist, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointClientTypes.MessageRequest {

    static func write(value: PinpointClientTypes.MessageRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Addresses"].writeMap(value.addresses, valueWritingClosure: PinpointClientTypes.AddressConfiguration.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Context"].writeMap(value.context, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Endpoints"].writeMap(value.endpoints, valueWritingClosure: PinpointClientTypes.EndpointSendConfiguration.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["MessageConfiguration"].write(value.messageConfiguration, with: PinpointClientTypes.DirectMessageConfiguration.write(value:to:))
        try writer["TemplateConfiguration"].write(value.templateConfiguration, with: PinpointClientTypes.TemplateConfiguration.write(value:to:))
        try writer["TraceId"].write(value.traceId)
    }
}

extension PinpointClientTypes.DirectMessageConfiguration {

    static func write(value: PinpointClientTypes.DirectMessageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ADMMessage"].write(value.admMessage, with: PinpointClientTypes.ADMMessage.write(value:to:))
        try writer["APNSMessage"].write(value.apnsMessage, with: PinpointClientTypes.APNSMessage.write(value:to:))
        try writer["BaiduMessage"].write(value.baiduMessage, with: PinpointClientTypes.BaiduMessage.write(value:to:))
        try writer["DefaultMessage"].write(value.defaultMessage, with: PinpointClientTypes.DefaultMessage.write(value:to:))
        try writer["DefaultPushNotificationMessage"].write(value.defaultPushNotificationMessage, with: PinpointClientTypes.DefaultPushNotificationMessage.write(value:to:))
        try writer["EmailMessage"].write(value.emailMessage, with: PinpointClientTypes.EmailMessage.write(value:to:))
        try writer["GCMMessage"].write(value.gcmMessage, with: PinpointClientTypes.GCMMessage.write(value:to:))
        try writer["SMSMessage"].write(value.smsMessage, with: PinpointClientTypes.SMSMessage.write(value:to:))
        try writer["VoiceMessage"].write(value.voiceMessage, with: PinpointClientTypes.VoiceMessage.write(value:to:))
    }
}

extension PinpointClientTypes.VoiceMessage {

    static func write(value: PinpointClientTypes.VoiceMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Body"].write(value.body)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["OriginationNumber"].write(value.originationNumber)
        try writer["Substitutions"].writeMap(value.substitutions, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["VoiceId"].write(value.voiceId)
    }
}

extension PinpointClientTypes.SMSMessage {

    static func write(value: PinpointClientTypes.SMSMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Body"].write(value.body)
        try writer["EntityId"].write(value.entityId)
        try writer["Keyword"].write(value.keyword)
        try writer["MediaUrl"].write(value.mediaUrl)
        try writer["MessageType"].write(value.messageType)
        try writer["OriginationNumber"].write(value.originationNumber)
        try writer["SenderId"].write(value.senderId)
        try writer["Substitutions"].writeMap(value.substitutions, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TemplateId"].write(value.templateId)
    }
}

extension PinpointClientTypes.GCMMessage {

    static func write(value: PinpointClientTypes.GCMMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Body"].write(value.body)
        try writer["CollapseKey"].write(value.collapseKey)
        try writer["Data"].writeMap(value.data, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["IconReference"].write(value.iconReference)
        try writer["ImageIconUrl"].write(value.imageIconUrl)
        try writer["ImageUrl"].write(value.imageUrl)
        try writer["PreferredAuthenticationMethod"].write(value.preferredAuthenticationMethod)
        try writer["Priority"].write(value.priority)
        try writer["RawContent"].write(value.rawContent)
        try writer["RestrictedPackageName"].write(value.restrictedPackageName)
        try writer["SilentPush"].write(value.silentPush)
        try writer["SmallImageIconUrl"].write(value.smallImageIconUrl)
        try writer["Sound"].write(value.sound)
        try writer["Substitutions"].writeMap(value.substitutions, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TimeToLive"].write(value.timeToLive)
        try writer["Title"].write(value.title)
        try writer["Url"].write(value.url)
    }
}

extension PinpointClientTypes.EmailMessage {

    static func write(value: PinpointClientTypes.EmailMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Body"].write(value.body)
        try writer["FeedbackForwardingAddress"].write(value.feedbackForwardingAddress)
        try writer["FromAddress"].write(value.fromAddress)
        try writer["RawEmail"].write(value.rawEmail, with: PinpointClientTypes.RawEmail.write(value:to:))
        try writer["ReplyToAddresses"].writeList(value.replyToAddresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SimpleEmail"].write(value.simpleEmail, with: PinpointClientTypes.SimpleEmail.write(value:to:))
        try writer["Substitutions"].writeMap(value.substitutions, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PinpointClientTypes.SimpleEmail {

    static func write(value: PinpointClientTypes.SimpleEmail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Headers"].writeList(value.headers, memberWritingClosure: PinpointClientTypes.MessageHeader.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HtmlPart"].write(value.htmlPart, with: PinpointClientTypes.SimpleEmailPart.write(value:to:))
        try writer["Subject"].write(value.subject, with: PinpointClientTypes.SimpleEmailPart.write(value:to:))
        try writer["TextPart"].write(value.textPart, with: PinpointClientTypes.SimpleEmailPart.write(value:to:))
    }
}

extension PinpointClientTypes.SimpleEmailPart {

    static func write(value: PinpointClientTypes.SimpleEmailPart?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Charset"].write(value.charset)
        try writer["Data"].write(value.data)
    }
}

extension PinpointClientTypes.RawEmail {

    static func write(value: PinpointClientTypes.RawEmail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Data"].write(value.data)
    }
}

extension PinpointClientTypes.DefaultPushNotificationMessage {

    static func write(value: PinpointClientTypes.DefaultPushNotificationMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Body"].write(value.body)
        try writer["Data"].writeMap(value.data, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SilentPush"].write(value.silentPush)
        try writer["Substitutions"].writeMap(value.substitutions, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Title"].write(value.title)
        try writer["Url"].write(value.url)
    }
}

extension PinpointClientTypes.DefaultMessage {

    static func write(value: PinpointClientTypes.DefaultMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Body"].write(value.body)
        try writer["Substitutions"].writeMap(value.substitutions, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PinpointClientTypes.BaiduMessage {

    static func write(value: PinpointClientTypes.BaiduMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Body"].write(value.body)
        try writer["Data"].writeMap(value.data, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["IconReference"].write(value.iconReference)
        try writer["ImageIconUrl"].write(value.imageIconUrl)
        try writer["ImageUrl"].write(value.imageUrl)
        try writer["RawContent"].write(value.rawContent)
        try writer["SilentPush"].write(value.silentPush)
        try writer["SmallImageIconUrl"].write(value.smallImageIconUrl)
        try writer["Sound"].write(value.sound)
        try writer["Substitutions"].writeMap(value.substitutions, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TimeToLive"].write(value.timeToLive)
        try writer["Title"].write(value.title)
        try writer["Url"].write(value.url)
    }
}

extension PinpointClientTypes.APNSMessage {

    static func write(value: PinpointClientTypes.APNSMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["APNSPushType"].write(value.apnsPushType)
        try writer["Action"].write(value.action)
        try writer["Badge"].write(value.badge)
        try writer["Body"].write(value.body)
        try writer["Category"].write(value.category)
        try writer["CollapseId"].write(value.collapseId)
        try writer["Data"].writeMap(value.data, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["MediaUrl"].write(value.mediaUrl)
        try writer["PreferredAuthenticationMethod"].write(value.preferredAuthenticationMethod)
        try writer["Priority"].write(value.priority)
        try writer["RawContent"].write(value.rawContent)
        try writer["SilentPush"].write(value.silentPush)
        try writer["Sound"].write(value.sound)
        try writer["Substitutions"].writeMap(value.substitutions, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ThreadId"].write(value.threadId)
        try writer["TimeToLive"].write(value.timeToLive)
        try writer["Title"].write(value.title)
        try writer["Url"].write(value.url)
    }
}

extension PinpointClientTypes.ADMMessage {

    static func write(value: PinpointClientTypes.ADMMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Body"].write(value.body)
        try writer["ConsolidationKey"].write(value.consolidationKey)
        try writer["Data"].writeMap(value.data, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ExpiresAfter"].write(value.expiresAfter)
        try writer["IconReference"].write(value.iconReference)
        try writer["ImageIconUrl"].write(value.imageIconUrl)
        try writer["ImageUrl"].write(value.imageUrl)
        try writer["MD5"].write(value.md5)
        try writer["RawContent"].write(value.rawContent)
        try writer["SilentPush"].write(value.silentPush)
        try writer["SmallImageIconUrl"].write(value.smallImageIconUrl)
        try writer["Sound"].write(value.sound)
        try writer["Substitutions"].writeMap(value.substitutions, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Title"].write(value.title)
        try writer["Url"].write(value.url)
    }
}

extension PinpointClientTypes.EndpointSendConfiguration {

    static func write(value: PinpointClientTypes.EndpointSendConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BodyOverride"].write(value.bodyOverride)
        try writer["Context"].writeMap(value.context, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RawContent"].write(value.rawContent)
        try writer["Substitutions"].writeMap(value.substitutions, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TitleOverride"].write(value.titleOverride)
    }
}

extension PinpointClientTypes.AddressConfiguration {

    static func write(value: PinpointClientTypes.AddressConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BodyOverride"].write(value.bodyOverride)
        try writer["ChannelType"].write(value.channelType)
        try writer["Context"].writeMap(value.context, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RawContent"].write(value.rawContent)
        try writer["Substitutions"].writeMap(value.substitutions, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TitleOverride"].write(value.titleOverride)
    }
}

extension PinpointClientTypes.SendOTPMessageRequestParameters {

    static func write(value: PinpointClientTypes.SendOTPMessageRequestParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedAttempts"].write(value.allowedAttempts)
        try writer["BrandName"].write(value.brandName)
        try writer["Channel"].write(value.channel)
        try writer["CodeLength"].write(value.codeLength)
        try writer["DestinationIdentity"].write(value.destinationIdentity)
        try writer["EntityId"].write(value.entityId)
        try writer["Language"].write(value.language)
        try writer["OriginationIdentity"].write(value.originationIdentity)
        try writer["ReferenceId"].write(value.referenceId)
        try writer["TemplateId"].write(value.templateId)
        try writer["ValidityPeriod"].write(value.validityPeriod)
    }
}

extension PinpointClientTypes.SendUsersMessageRequest {

    static func write(value: PinpointClientTypes.SendUsersMessageRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Context"].writeMap(value.context, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["MessageConfiguration"].write(value.messageConfiguration, with: PinpointClientTypes.DirectMessageConfiguration.write(value:to:))
        try writer["TemplateConfiguration"].write(value.templateConfiguration, with: PinpointClientTypes.TemplateConfiguration.write(value:to:))
        try writer["TraceId"].write(value.traceId)
        try writer["Users"].writeMap(value.users, valueWritingClosure: PinpointClientTypes.EndpointSendConfiguration.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PinpointClientTypes.ADMChannelRequest {

    static func write(value: PinpointClientTypes.ADMChannelRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientId"].write(value.clientId)
        try writer["ClientSecret"].write(value.clientSecret)
        try writer["Enabled"].write(value.enabled)
    }
}

extension PinpointClientTypes.APNSChannelRequest {

    static func write(value: PinpointClientTypes.APNSChannelRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BundleId"].write(value.bundleId)
        try writer["Certificate"].write(value.certificate)
        try writer["DefaultAuthenticationMethod"].write(value.defaultAuthenticationMethod)
        try writer["Enabled"].write(value.enabled)
        try writer["PrivateKey"].write(value.privateKey)
        try writer["TeamId"].write(value.teamId)
        try writer["TokenKey"].write(value.tokenKey)
        try writer["TokenKeyId"].write(value.tokenKeyId)
    }
}

extension PinpointClientTypes.APNSSandboxChannelRequest {

    static func write(value: PinpointClientTypes.APNSSandboxChannelRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BundleId"].write(value.bundleId)
        try writer["Certificate"].write(value.certificate)
        try writer["DefaultAuthenticationMethod"].write(value.defaultAuthenticationMethod)
        try writer["Enabled"].write(value.enabled)
        try writer["PrivateKey"].write(value.privateKey)
        try writer["TeamId"].write(value.teamId)
        try writer["TokenKey"].write(value.tokenKey)
        try writer["TokenKeyId"].write(value.tokenKeyId)
    }
}

extension PinpointClientTypes.APNSVoipChannelRequest {

    static func write(value: PinpointClientTypes.APNSVoipChannelRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BundleId"].write(value.bundleId)
        try writer["Certificate"].write(value.certificate)
        try writer["DefaultAuthenticationMethod"].write(value.defaultAuthenticationMethod)
        try writer["Enabled"].write(value.enabled)
        try writer["PrivateKey"].write(value.privateKey)
        try writer["TeamId"].write(value.teamId)
        try writer["TokenKey"].write(value.tokenKey)
        try writer["TokenKeyId"].write(value.tokenKeyId)
    }
}

extension PinpointClientTypes.APNSVoipSandboxChannelRequest {

    static func write(value: PinpointClientTypes.APNSVoipSandboxChannelRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BundleId"].write(value.bundleId)
        try writer["Certificate"].write(value.certificate)
        try writer["DefaultAuthenticationMethod"].write(value.defaultAuthenticationMethod)
        try writer["Enabled"].write(value.enabled)
        try writer["PrivateKey"].write(value.privateKey)
        try writer["TeamId"].write(value.teamId)
        try writer["TokenKey"].write(value.tokenKey)
        try writer["TokenKeyId"].write(value.tokenKeyId)
    }
}

extension PinpointClientTypes.WriteApplicationSettingsRequest {

    static func write(value: PinpointClientTypes.WriteApplicationSettingsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CampaignHook"].write(value.campaignHook, with: PinpointClientTypes.CampaignHook.write(value:to:))
        try writer["CloudWatchMetricsEnabled"].write(value.cloudWatchMetricsEnabled)
        try writer["EventTaggingEnabled"].write(value.eventTaggingEnabled)
        try writer["JourneyLimits"].write(value.journeyLimits, with: PinpointClientTypes.ApplicationSettingsJourneyLimits.write(value:to:))
        try writer["Limits"].write(value.limits, with: PinpointClientTypes.CampaignLimits.write(value:to:))
        try writer["QuietTime"].write(value.quietTime, with: PinpointClientTypes.QuietTime.write(value:to:))
    }
}

extension PinpointClientTypes.BaiduChannelRequest {

    static func write(value: PinpointClientTypes.BaiduChannelRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApiKey"].write(value.apiKey)
        try writer["Enabled"].write(value.enabled)
        try writer["SecretKey"].write(value.secretKey)
    }
}

extension PinpointClientTypes.EmailChannelRequest {

    static func write(value: PinpointClientTypes.EmailChannelRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSet"].write(value.configurationSet)
        try writer["Enabled"].write(value.enabled)
        try writer["FromAddress"].write(value.fromAddress)
        try writer["Identity"].write(value.identity)
        try writer["OrchestrationSendingRoleArn"].write(value.orchestrationSendingRoleArn)
        try writer["RoleArn"].write(value.roleArn)
    }
}

extension PinpointClientTypes.EndpointRequest {

    static func write(value: PinpointClientTypes.EndpointRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address)
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ChannelType"].write(value.channelType)
        try writer["Demographic"].write(value.demographic, with: PinpointClientTypes.EndpointDemographic.write(value:to:))
        try writer["EffectiveDate"].write(value.effectiveDate)
        try writer["EndpointStatus"].write(value.endpointStatus)
        try writer["Location"].write(value.location, with: PinpointClientTypes.EndpointLocation.write(value:to:))
        try writer["Metrics"].writeMap(value.metrics, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["OptOut"].write(value.optOut)
        try writer["RequestId"].write(value.requestId)
        try writer["User"].write(value.user, with: PinpointClientTypes.EndpointUser.write(value:to:))
    }
}

extension PinpointClientTypes.EndpointBatchRequest {

    static func write(value: PinpointClientTypes.EndpointBatchRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Item"].writeList(value.item, memberWritingClosure: PinpointClientTypes.EndpointBatchItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointClientTypes.EndpointBatchItem {

    static func write(value: PinpointClientTypes.EndpointBatchItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address)
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ChannelType"].write(value.channelType)
        try writer["Demographic"].write(value.demographic, with: PinpointClientTypes.EndpointDemographic.write(value:to:))
        try writer["EffectiveDate"].write(value.effectiveDate)
        try writer["EndpointStatus"].write(value.endpointStatus)
        try writer["Id"].write(value.id)
        try writer["Location"].write(value.location, with: PinpointClientTypes.EndpointLocation.write(value:to:))
        try writer["Metrics"].writeMap(value.metrics, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["OptOut"].write(value.optOut)
        try writer["RequestId"].write(value.requestId)
        try writer["User"].write(value.user, with: PinpointClientTypes.EndpointUser.write(value:to:))
    }
}

extension PinpointClientTypes.GCMChannelRequest {

    static func write(value: PinpointClientTypes.GCMChannelRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApiKey"].write(value.apiKey)
        try writer["DefaultAuthenticationMethod"].write(value.defaultAuthenticationMethod)
        try writer["Enabled"].write(value.enabled)
        try writer["ServiceJson"].write(value.serviceJson)
    }
}

extension PinpointClientTypes.JourneyStateRequest {

    static func write(value: PinpointClientTypes.JourneyStateRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["State"].write(value.state)
    }
}

extension PinpointClientTypes.UpdateRecommenderConfigurationShape {

    static func write(value: PinpointClientTypes.UpdateRecommenderConfigurationShape?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["RecommendationProviderIdType"].write(value.recommendationProviderIdType)
        try writer["RecommendationProviderRoleArn"].write(value.recommendationProviderRoleArn)
        try writer["RecommendationProviderUri"].write(value.recommendationProviderUri)
        try writer["RecommendationTransformerUri"].write(value.recommendationTransformerUri)
        try writer["RecommendationsDisplayName"].write(value.recommendationsDisplayName)
        try writer["RecommendationsPerMessage"].write(value.recommendationsPerMessage)
    }
}

extension PinpointClientTypes.SMSChannelRequest {

    static func write(value: PinpointClientTypes.SMSChannelRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["SenderId"].write(value.senderId)
        try writer["ShortCode"].write(value.shortCode)
    }
}

extension PinpointClientTypes.TemplateActiveVersionRequest {

    static func write(value: PinpointClientTypes.TemplateActiveVersionRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Version"].write(value.version)
    }
}

extension PinpointClientTypes.VoiceChannelRequest {

    static func write(value: PinpointClientTypes.VoiceChannelRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }
}

extension PinpointClientTypes.VerifyOTPMessageRequestParameters {

    static func write(value: PinpointClientTypes.VerifyOTPMessageRequestParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationIdentity"].write(value.destinationIdentity)
        try writer["Otp"].write(value.otp)
        try writer["ReferenceId"].write(value.referenceId)
    }
}

public enum PinpointClientTypes {}
