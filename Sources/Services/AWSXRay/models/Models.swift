// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension XRayClientTypes.Alias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case names = "Names"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for string0 in names {
                try namesContainer.encode(string0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension XRayClientTypes {
    /// An alias for an edge.
    public struct Alias: Swift.Equatable {
        /// The canonical name of the alias.
        public var name: Swift.String?
        /// A list of names for the alias, including the canonical name.
        public var names: [Swift.String]?
        /// The type of the alias.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.names = names
            self.type = type
        }
    }

}

extension XRayClientTypes.AnnotationValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case booleanvalue = "BooleanValue"
        case numbervalue = "NumberValue"
        case stringvalue = "StringValue"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .booleanvalue(booleanvalue):
                try container.encode(booleanvalue, forKey: .booleanvalue)
            case let .numbervalue(numbervalue):
                try container.encode(numbervalue, forKey: .numbervalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let numbervalueDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .numbervalue)
        if let numbervalue = numbervalueDecoded {
            self = .numbervalue(numbervalue)
            return
        }
        let booleanvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .booleanvalue)
        if let booleanvalue = booleanvalueDecoded {
            self = .booleanvalue(booleanvalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension XRayClientTypes {
    /// Value of a segment annotation. Has one of three value types: Number, Boolean, or String.
    public enum AnnotationValue: Swift.Equatable {
        /// Value for a Number annotation.
        case numbervalue(Swift.Double)
        /// Value for a Boolean annotation.
        case booleanvalue(Swift.Bool)
        /// Value for a String annotation.
        case stringvalue(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension XRayClientTypes.AnomalousService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceId = self.serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(XRayClientTypes.ServiceId.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
    }
}

extension XRayClientTypes {
    /// The service within the service graph that has anomalously high fault rates.
    public struct AnomalousService: Swift.Equatable {
        ///
        public var serviceId: XRayClientTypes.ServiceId?

        public init(
            serviceId: XRayClientTypes.ServiceId? = nil
        )
        {
            self.serviceId = serviceId
        }
    }

}

extension XRayClientTypes.AvailabilityZoneDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension XRayClientTypes {
    /// A list of Availability Zones corresponding to the segments in a trace.
    public struct AvailabilityZoneDetail: Swift.Equatable {
        /// The name of a corresponding Availability Zone.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension XRayClientTypes.BackendConnectionErrors: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionRefusedCount = "ConnectionRefusedCount"
        case httpCode4XXCount = "HTTPCode4XXCount"
        case httpCode5XXCount = "HTTPCode5XXCount"
        case otherCount = "OtherCount"
        case timeoutCount = "TimeoutCount"
        case unknownHostCount = "UnknownHostCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionRefusedCount = self.connectionRefusedCount {
            try encodeContainer.encode(connectionRefusedCount, forKey: .connectionRefusedCount)
        }
        if let httpCode4XXCount = self.httpCode4XXCount {
            try encodeContainer.encode(httpCode4XXCount, forKey: .httpCode4XXCount)
        }
        if let httpCode5XXCount = self.httpCode5XXCount {
            try encodeContainer.encode(httpCode5XXCount, forKey: .httpCode5XXCount)
        }
        if let otherCount = self.otherCount {
            try encodeContainer.encode(otherCount, forKey: .otherCount)
        }
        if let timeoutCount = self.timeoutCount {
            try encodeContainer.encode(timeoutCount, forKey: .timeoutCount)
        }
        if let unknownHostCount = self.unknownHostCount {
            try encodeContainer.encode(unknownHostCount, forKey: .unknownHostCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutCount)
        timeoutCount = timeoutCountDecoded
        let connectionRefusedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionRefusedCount)
        connectionRefusedCount = connectionRefusedCountDecoded
        let httpCode4XXCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpCode4XXCount)
        httpCode4XXCount = httpCode4XXCountDecoded
        let httpCode5XXCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpCode5XXCount)
        httpCode5XXCount = httpCode5XXCountDecoded
        let unknownHostCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknownHostCount)
        unknownHostCount = unknownHostCountDecoded
        let otherCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .otherCount)
        otherCount = otherCountDecoded
    }
}

extension XRayClientTypes {
    ///
    public struct BackendConnectionErrors: Swift.Equatable {
        ///
        public var connectionRefusedCount: Swift.Int?
        ///
        public var httpCode4XXCount: Swift.Int?
        ///
        public var httpCode5XXCount: Swift.Int?
        ///
        public var otherCount: Swift.Int?
        ///
        public var timeoutCount: Swift.Int?
        ///
        public var unknownHostCount: Swift.Int?

        public init(
            connectionRefusedCount: Swift.Int? = nil,
            httpCode4XXCount: Swift.Int? = nil,
            httpCode5XXCount: Swift.Int? = nil,
            otherCount: Swift.Int? = nil,
            timeoutCount: Swift.Int? = nil,
            unknownHostCount: Swift.Int? = nil
        )
        {
            self.connectionRefusedCount = connectionRefusedCount
            self.httpCode4XXCount = httpCode4XXCount
            self.httpCode5XXCount = httpCode5XXCount
            self.otherCount = otherCount
            self.timeoutCount = timeoutCount
            self.unknownHostCount = unknownHostCount
        }
    }

}

extension BatchGetTracesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case traceIds = "TraceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let traceIds = traceIds {
            var traceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traceIds)
            for traceid0 in traceIds {
                try traceIdsContainer.encode(traceid0)
            }
        }
    }
}

extension BatchGetTracesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/Traces"
    }
}

public struct BatchGetTracesInput: Swift.Equatable {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// Specify the trace IDs of requests for which to retrieve segments.
    /// This member is required.
    public var traceIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        traceIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.traceIds = traceIds
    }
}

struct BatchGetTracesInputBody: Swift.Equatable {
    let traceIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension BatchGetTracesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case traceIds = "TraceIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .traceIds)
        var traceIdsDecoded0:[Swift.String]? = nil
        if let traceIdsContainer = traceIdsContainer {
            traceIdsDecoded0 = [Swift.String]()
            for string0 in traceIdsContainer {
                if let string0 = string0 {
                    traceIdsDecoded0?.append(string0)
                }
            }
        }
        traceIds = traceIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchGetTracesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetTracesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.traces = output.traces
            self.unprocessedTraceIds = output.unprocessedTraceIds
        } else {
            self.nextToken = nil
            self.traces = nil
            self.unprocessedTraceIds = nil
        }
    }
}

public struct BatchGetTracesOutput: Swift.Equatable {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// Full traces for the specified requests.
    public var traces: [XRayClientTypes.Trace]?
    /// Trace IDs of requests that haven't been processed.
    public var unprocessedTraceIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        traces: [XRayClientTypes.Trace]? = nil,
        unprocessedTraceIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.traces = traces
        self.unprocessedTraceIds = unprocessedTraceIds
    }
}

struct BatchGetTracesOutputBody: Swift.Equatable {
    let traces: [XRayClientTypes.Trace]?
    let unprocessedTraceIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension BatchGetTracesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case traces = "Traces"
        case unprocessedTraceIds = "UnprocessedTraceIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tracesContainer = try containerValues.decodeIfPresent([XRayClientTypes.Trace?].self, forKey: .traces)
        var tracesDecoded0:[XRayClientTypes.Trace]? = nil
        if let tracesContainer = tracesContainer {
            tracesDecoded0 = [XRayClientTypes.Trace]()
            for structure0 in tracesContainer {
                if let structure0 = structure0 {
                    tracesDecoded0?.append(structure0)
                }
            }
        }
        traces = tracesDecoded0
        let unprocessedTraceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .unprocessedTraceIds)
        var unprocessedTraceIdsDecoded0:[Swift.String]? = nil
        if let unprocessedTraceIdsContainer = unprocessedTraceIdsContainer {
            unprocessedTraceIdsDecoded0 = [Swift.String]()
            for string0 in unprocessedTraceIdsContainer {
                if let string0 = string0 {
                    unprocessedTraceIdsDecoded0?.append(string0)
                }
            }
        }
        unprocessedTraceIds = unprocessedTraceIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum BatchGetTracesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpression = "FilterExpression"
        case groupName = "GroupName"
        case insightsConfiguration = "InsightsConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterExpression = self.filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let insightsConfiguration = self.insightsConfiguration {
            try encodeContainer.encode(insightsConfiguration, forKey: .insightsConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateGroup"
    }
}

public struct CreateGroupInput: Swift.Equatable {
    /// The filter expression defining criteria by which to group traces.
    public var filterExpression: Swift.String?
    /// The case-sensitive name of the new group. Default is a reserved name and names must be unique.
    /// This member is required.
    public var groupName: Swift.String?
    /// The structure containing configurations related to insights.
    ///
    /// * The InsightsEnabled boolean can be set to true to enable insights for the new group or false to disable insights for the new group.
    ///
    /// * The NotificationsEnabled boolean can be set to true to enable insights notifications for the new group. Notifications may only be enabled on a group with InsightsEnabled set to true.
    public var insightsConfiguration: XRayClientTypes.InsightsConfiguration?
    /// A map that contains one or more tag keys and tag values to attach to an X-Ray group. For more information about ways to use tags, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference. The following restrictions apply to tags:
    ///
    /// * Maximum number of user-applied tags per resource: 50
    ///
    /// * Maximum tag key length: 128 Unicode characters
    ///
    /// * Maximum tag value length: 256 Unicode characters
    ///
    /// * Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Don't use aws: as a prefix for keys; it's reserved for Amazon Web Services use.
    public var tags: [XRayClientTypes.Tag]?

    public init(
        filterExpression: Swift.String? = nil,
        groupName: Swift.String? = nil,
        insightsConfiguration: XRayClientTypes.InsightsConfiguration? = nil,
        tags: [XRayClientTypes.Tag]? = nil
    )
    {
        self.filterExpression = filterExpression
        self.groupName = groupName
        self.insightsConfiguration = insightsConfiguration
        self.tags = tags
    }
}

struct CreateGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let filterExpression: Swift.String?
    let insightsConfiguration: XRayClientTypes.InsightsConfiguration?
    let tags: [XRayClientTypes.Tag]?
}

extension CreateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpression = "FilterExpression"
        case groupName = "GroupName"
        case insightsConfiguration = "InsightsConfiguration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let insightsConfigurationDecoded = try containerValues.decodeIfPresent(XRayClientTypes.InsightsConfiguration.self, forKey: .insightsConfiguration)
        insightsConfiguration = insightsConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([XRayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[XRayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [XRayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

public struct CreateGroupOutput: Swift.Equatable {
    /// The group that was created. Contains the name of the group that was created, the Amazon Resource Name (ARN) of the group that was generated based on the group name, the filter expression, and the insight configuration that was assigned to the group.
    public var group: XRayClientTypes.Group?

    public init(
        group: XRayClientTypes.Group? = nil
    )
    {
        self.group = group
    }
}

struct CreateGroupOutputBody: Swift.Equatable {
    let group: XRayClientTypes.Group?
}

extension CreateGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(XRayClientTypes.Group.self, forKey: .group)
        group = groupDecoded
    }
}

enum CreateGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSamplingRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samplingRule = "SamplingRule"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let samplingRule = self.samplingRule {
            try encodeContainer.encode(samplingRule, forKey: .samplingRule)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSamplingRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateSamplingRule"
    }
}

public struct CreateSamplingRuleInput: Swift.Equatable {
    /// The rule definition.
    /// This member is required.
    public var samplingRule: XRayClientTypes.SamplingRule?
    /// A map that contains one or more tag keys and tag values to attach to an X-Ray sampling rule. For more information about ways to use tags, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference. The following restrictions apply to tags:
    ///
    /// * Maximum number of user-applied tags per resource: 50
    ///
    /// * Maximum tag key length: 128 Unicode characters
    ///
    /// * Maximum tag value length: 256 Unicode characters
    ///
    /// * Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Don't use aws: as a prefix for keys; it's reserved for Amazon Web Services use.
    public var tags: [XRayClientTypes.Tag]?

    public init(
        samplingRule: XRayClientTypes.SamplingRule? = nil,
        tags: [XRayClientTypes.Tag]? = nil
    )
    {
        self.samplingRule = samplingRule
        self.tags = tags
    }
}

struct CreateSamplingRuleInputBody: Swift.Equatable {
    let samplingRule: XRayClientTypes.SamplingRule?
    let tags: [XRayClientTypes.Tag]?
}

extension CreateSamplingRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samplingRule = "SamplingRule"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleDecoded = try containerValues.decodeIfPresent(XRayClientTypes.SamplingRule.self, forKey: .samplingRule)
        samplingRule = samplingRuleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([XRayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[XRayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [XRayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSamplingRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSamplingRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.samplingRuleRecord = output.samplingRuleRecord
        } else {
            self.samplingRuleRecord = nil
        }
    }
}

public struct CreateSamplingRuleOutput: Swift.Equatable {
    /// The saved rule definition and metadata.
    public var samplingRuleRecord: XRayClientTypes.SamplingRuleRecord?

    public init(
        samplingRuleRecord: XRayClientTypes.SamplingRuleRecord? = nil
    )
    {
        self.samplingRuleRecord = samplingRuleRecord
    }
}

struct CreateSamplingRuleOutputBody: Swift.Equatable {
    let samplingRuleRecord: XRayClientTypes.SamplingRuleRecord?
}

extension CreateSamplingRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samplingRuleRecord = "SamplingRuleRecord"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleRecordDecoded = try containerValues.decodeIfPresent(XRayClientTypes.SamplingRuleRecord.self, forKey: .samplingRuleRecord)
        samplingRuleRecord = samplingRuleRecordDecoded
    }
}

enum CreateSamplingRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RuleLimitExceededException": return try await RuleLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupARN = "GroupARN"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupARN = self.groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }
}

extension DeleteGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteGroup"
    }
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The ARN of the group that was generated on creation.
    public var groupARN: Swift.String?
    /// The case-sensitive name of the group.
    public var groupName: Swift.String?

    public init(
        groupARN: Swift.String? = nil,
        groupName: Swift.String? = nil
    )
    {
        self.groupARN = groupARN
        self.groupName = groupName
    }
}

struct DeleteGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let groupARN: Swift.String?
}

extension DeleteGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupARN = "GroupARN"
        case groupName = "GroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
    }
}

extension DeleteGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case policyRevisionId = "PolicyRevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyRevisionId = self.policyRevisionId {
            try encodeContainer.encode(policyRevisionId, forKey: .policyRevisionId)
        }
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteResourcePolicy"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The name of the resource policy to delete.
    /// This member is required.
    public var policyName: Swift.String?
    /// Specifies a specific policy revision to delete. Provide a PolicyRevisionId to ensure an atomic delete operation. If the provided revision id does not match the latest policy revision id, an InvalidPolicyRevisionIdException exception is returned.
    public var policyRevisionId: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        policyRevisionId: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.policyRevisionId = policyRevisionId
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
    let policyName: Swift.String?
    let policyRevisionId: Swift.String?
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
        case policyRevisionId = "PolicyRevisionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyRevisionId)
        policyRevisionId = policyRevisionIdDecoded
    }
}

extension DeleteResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResourcePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidPolicyRevisionIdException": return try await InvalidPolicyRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSamplingRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ruleARN = "RuleARN"
        case ruleName = "RuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleARN = self.ruleARN {
            try encodeContainer.encode(ruleARN, forKey: .ruleARN)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }
}

extension DeleteSamplingRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteSamplingRule"
    }
}

public struct DeleteSamplingRuleInput: Swift.Equatable {
    /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
    public var ruleARN: Swift.String?
    /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
    public var ruleName: Swift.String?

    public init(
        ruleARN: Swift.String? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.ruleARN = ruleARN
        self.ruleName = ruleName
    }
}

struct DeleteSamplingRuleInputBody: Swift.Equatable {
    let ruleName: Swift.String?
    let ruleARN: Swift.String?
}

extension DeleteSamplingRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ruleARN = "RuleARN"
        case ruleName = "RuleName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let ruleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleARN)
        ruleARN = ruleARNDecoded
    }
}

extension DeleteSamplingRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSamplingRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.samplingRuleRecord = output.samplingRuleRecord
        } else {
            self.samplingRuleRecord = nil
        }
    }
}

public struct DeleteSamplingRuleOutput: Swift.Equatable {
    /// The deleted rule definition and metadata.
    public var samplingRuleRecord: XRayClientTypes.SamplingRuleRecord?

    public init(
        samplingRuleRecord: XRayClientTypes.SamplingRuleRecord? = nil
    )
    {
        self.samplingRuleRecord = samplingRuleRecord
    }
}

struct DeleteSamplingRuleOutputBody: Swift.Equatable {
    let samplingRuleRecord: XRayClientTypes.SamplingRuleRecord?
}

extension DeleteSamplingRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samplingRuleRecord = "SamplingRuleRecord"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleRecordDecoded = try containerValues.decodeIfPresent(XRayClientTypes.SamplingRuleRecord.self, forKey: .samplingRuleRecord)
        samplingRuleRecord = samplingRuleRecordDecoded
    }
}

enum DeleteSamplingRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension XRayClientTypes.Edge: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case edgeType = "EdgeType"
        case endTime = "EndTime"
        case receivedEventAgeHistogram = "ReceivedEventAgeHistogram"
        case referenceId = "ReferenceId"
        case responseTimeHistogram = "ResponseTimeHistogram"
        case startTime = "StartTime"
        case summaryStatistics = "SummaryStatistics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliases = aliases {
            var aliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliases)
            for alias0 in aliases {
                try aliasesContainer.encode(alias0)
            }
        }
        if let edgeType = self.edgeType {
            try encodeContainer.encode(edgeType, forKey: .edgeType)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let receivedEventAgeHistogram = receivedEventAgeHistogram {
            var receivedEventAgeHistogramContainer = encodeContainer.nestedUnkeyedContainer(forKey: .receivedEventAgeHistogram)
            for histogramentry0 in receivedEventAgeHistogram {
                try receivedEventAgeHistogramContainer.encode(histogramentry0)
            }
        }
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let responseTimeHistogram = responseTimeHistogram {
            var responseTimeHistogramContainer = encodeContainer.nestedUnkeyedContainer(forKey: .responseTimeHistogram)
            for histogramentry0 in responseTimeHistogram {
                try responseTimeHistogramContainer.encode(histogramentry0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let summaryStatistics = self.summaryStatistics {
            try encodeContainer.encode(summaryStatistics, forKey: .summaryStatistics)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let summaryStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.EdgeStatistics.self, forKey: .summaryStatistics)
        summaryStatistics = summaryStatisticsDecoded
        let responseTimeHistogramContainer = try containerValues.decodeIfPresent([XRayClientTypes.HistogramEntry?].self, forKey: .responseTimeHistogram)
        var responseTimeHistogramDecoded0:[XRayClientTypes.HistogramEntry]? = nil
        if let responseTimeHistogramContainer = responseTimeHistogramContainer {
            responseTimeHistogramDecoded0 = [XRayClientTypes.HistogramEntry]()
            for structure0 in responseTimeHistogramContainer {
                if let structure0 = structure0 {
                    responseTimeHistogramDecoded0?.append(structure0)
                }
            }
        }
        responseTimeHistogram = responseTimeHistogramDecoded0
        let aliasesContainer = try containerValues.decodeIfPresent([XRayClientTypes.Alias?].self, forKey: .aliases)
        var aliasesDecoded0:[XRayClientTypes.Alias]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [XRayClientTypes.Alias]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
        let edgeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edgeType)
        edgeType = edgeTypeDecoded
        let receivedEventAgeHistogramContainer = try containerValues.decodeIfPresent([XRayClientTypes.HistogramEntry?].self, forKey: .receivedEventAgeHistogram)
        var receivedEventAgeHistogramDecoded0:[XRayClientTypes.HistogramEntry]? = nil
        if let receivedEventAgeHistogramContainer = receivedEventAgeHistogramContainer {
            receivedEventAgeHistogramDecoded0 = [XRayClientTypes.HistogramEntry]()
            for structure0 in receivedEventAgeHistogramContainer {
                if let structure0 = structure0 {
                    receivedEventAgeHistogramDecoded0?.append(structure0)
                }
            }
        }
        receivedEventAgeHistogram = receivedEventAgeHistogramDecoded0
    }
}

extension XRayClientTypes {
    /// Information about a connection between two services. An edge can be a synchronous connection, such as typical call between client and service, or an asynchronous link, such as a Lambda function which retrieves an event from an SNS queue.
    public struct Edge: Swift.Equatable {
        /// Aliases for the edge.
        public var aliases: [XRayClientTypes.Alias]?
        /// Describes an asynchronous connection, with a value of link.
        public var edgeType: Swift.String?
        /// The end time of the last segment on the edge.
        public var endTime: ClientRuntime.Date?
        /// A histogram that maps the spread of event age when received by consumers. Age is calculated each time an event is received. Only populated when EdgeType is link.
        public var receivedEventAgeHistogram: [XRayClientTypes.HistogramEntry]?
        /// Identifier of the edge. Unique within a service map.
        public var referenceId: Swift.Int?
        /// A histogram that maps the spread of client response times on an edge. Only populated for synchronous edges.
        public var responseTimeHistogram: [XRayClientTypes.HistogramEntry]?
        /// The start time of the first segment on the edge.
        public var startTime: ClientRuntime.Date?
        /// Response statistics for segments on the edge.
        public var summaryStatistics: XRayClientTypes.EdgeStatistics?

        public init(
            aliases: [XRayClientTypes.Alias]? = nil,
            edgeType: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            receivedEventAgeHistogram: [XRayClientTypes.HistogramEntry]? = nil,
            referenceId: Swift.Int? = nil,
            responseTimeHistogram: [XRayClientTypes.HistogramEntry]? = nil,
            startTime: ClientRuntime.Date? = nil,
            summaryStatistics: XRayClientTypes.EdgeStatistics? = nil
        )
        {
            self.aliases = aliases
            self.edgeType = edgeType
            self.endTime = endTime
            self.receivedEventAgeHistogram = receivedEventAgeHistogram
            self.referenceId = referenceId
            self.responseTimeHistogram = responseTimeHistogram
            self.startTime = startTime
            self.summaryStatistics = summaryStatistics
        }
    }

}

extension XRayClientTypes.EdgeStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorStatistics = "ErrorStatistics"
        case faultStatistics = "FaultStatistics"
        case okCount = "OkCount"
        case totalCount = "TotalCount"
        case totalResponseTime = "TotalResponseTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorStatistics = self.errorStatistics {
            try encodeContainer.encode(errorStatistics, forKey: .errorStatistics)
        }
        if let faultStatistics = self.faultStatistics {
            try encodeContainer.encode(faultStatistics, forKey: .faultStatistics)
        }
        if let okCount = self.okCount {
            try encodeContainer.encode(okCount, forKey: .okCount)
        }
        if let totalCount = self.totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
        if let totalResponseTime = self.totalResponseTime {
            try encodeContainer.encode(totalResponseTime, forKey: .totalResponseTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let okCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .okCount)
        okCount = okCountDecoded
        let errorStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.ErrorStatistics.self, forKey: .errorStatistics)
        errorStatistics = errorStatisticsDecoded
        let faultStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.FaultStatistics.self, forKey: .faultStatistics)
        faultStatistics = faultStatisticsDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let totalResponseTimeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .totalResponseTime)
        totalResponseTime = totalResponseTimeDecoded
    }
}

extension XRayClientTypes {
    /// Response statistics for an edge.
    public struct EdgeStatistics: Swift.Equatable {
        /// Information about requests that failed with a 4xx Client Error status code.
        public var errorStatistics: XRayClientTypes.ErrorStatistics?
        /// Information about requests that failed with a 5xx Server Error status code.
        public var faultStatistics: XRayClientTypes.FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public var okCount: Swift.Int?
        /// The total number of completed requests.
        public var totalCount: Swift.Int?
        /// The aggregate response time of completed requests.
        public var totalResponseTime: Swift.Double?

        public init(
            errorStatistics: XRayClientTypes.ErrorStatistics? = nil,
            faultStatistics: XRayClientTypes.FaultStatistics? = nil,
            okCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil,
            totalResponseTime: Swift.Double? = nil
        )
        {
            self.errorStatistics = errorStatistics
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.totalCount = totalCount
            self.totalResponseTime = totalResponseTime
        }
    }

}

extension XRayClientTypes.EncryptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyId = "KeyId"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = self.keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(XRayClientTypes.EncryptionStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(XRayClientTypes.EncryptionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension XRayClientTypes {
    /// A configuration document that specifies encryption configuration settings.
    public struct EncryptionConfig: Swift.Equatable {
        /// The ID of the KMS key used for encryption, if applicable.
        public var keyId: Swift.String?
        /// The encryption status. While the status is UPDATING, X-Ray may encrypt data with a combination of the new and old settings.
        public var status: XRayClientTypes.EncryptionStatus?
        /// The type of encryption. Set to KMS for encryption with KMS keys. Set to NONE for default encryption.
        public var type: XRayClientTypes.EncryptionType?

        public init(
            keyId: Swift.String? = nil,
            status: XRayClientTypes.EncryptionStatus? = nil,
            type: XRayClientTypes.EncryptionType? = nil
        )
        {
            self.keyId = keyId
            self.status = status
            self.type = type
        }
    }

}

extension XRayClientTypes {
    public enum EncryptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionStatus] {
            return [
                .active,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionStatus(rawValue: rawValue) ?? EncryptionStatus.sdkUnknown(rawValue)
        }
    }
}

extension XRayClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kms
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kms,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kms: return "KMS"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension XRayClientTypes.ErrorRootCause: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientImpacting = "ClientImpacting"
        case services = "Services"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientImpacting = self.clientImpacting {
            try encodeContainer.encode(clientImpacting, forKey: .clientImpacting)
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for errorrootcauseservice0 in services {
                try servicesContainer.encode(errorrootcauseservice0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([XRayClientTypes.ErrorRootCauseService?].self, forKey: .services)
        var servicesDecoded0:[XRayClientTypes.ErrorRootCauseService]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [XRayClientTypes.ErrorRootCauseService]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let clientImpactingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clientImpacting)
        clientImpacting = clientImpactingDecoded
    }
}

extension XRayClientTypes {
    /// The root cause of a trace summary error.
    public struct ErrorRootCause: Swift.Equatable {
        /// A flag that denotes that the root cause impacts the trace client.
        public var clientImpacting: Swift.Bool?
        /// A list of services corresponding to an error. A service identifies a segment and it contains a name, account ID, type, and inferred flag.
        public var services: [XRayClientTypes.ErrorRootCauseService]?

        public init(
            clientImpacting: Swift.Bool? = nil,
            services: [XRayClientTypes.ErrorRootCauseService]? = nil
        )
        {
            self.clientImpacting = clientImpacting
            self.services = services
        }
    }

}

extension XRayClientTypes.ErrorRootCauseEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptions = "Exceptions"
        case name = "Name"
        case remote = "Remote"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptions = exceptions {
            var exceptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exceptions)
            for rootcauseexception0 in exceptions {
                try exceptionsContainer.encode(rootcauseexception0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let remote = self.remote {
            try encodeContainer.encode(remote, forKey: .remote)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let exceptionsContainer = try containerValues.decodeIfPresent([XRayClientTypes.RootCauseException?].self, forKey: .exceptions)
        var exceptionsDecoded0:[XRayClientTypes.RootCauseException]? = nil
        if let exceptionsContainer = exceptionsContainer {
            exceptionsDecoded0 = [XRayClientTypes.RootCauseException]()
            for structure0 in exceptionsContainer {
                if let structure0 = structure0 {
                    exceptionsDecoded0?.append(structure0)
                }
            }
        }
        exceptions = exceptionsDecoded0
        let remoteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remote)
        remote = remoteDecoded
    }
}

extension XRayClientTypes {
    /// A collection of segments and corresponding subsegments associated to a trace summary error.
    public struct ErrorRootCauseEntity: Swift.Equatable {
        /// The types and messages of the exceptions.
        public var exceptions: [XRayClientTypes.RootCauseException]?
        /// The name of the entity.
        public var name: Swift.String?
        /// A flag that denotes a remote subsegment.
        public var remote: Swift.Bool?

        public init(
            exceptions: [XRayClientTypes.RootCauseException]? = nil,
            name: Swift.String? = nil,
            remote: Swift.Bool? = nil
        )
        {
            self.exceptions = exceptions
            self.name = name
            self.remote = remote
        }
    }

}

extension XRayClientTypes.ErrorRootCauseService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case entityPath = "EntityPath"
        case inferred = "Inferred"
        case name = "Name"
        case names = "Names"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let entityPath = entityPath {
            var entityPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityPath)
            for errorrootcauseentity0 in entityPath {
                try entityPathContainer.encode(errorrootcauseentity0)
            }
        }
        if let inferred = self.inferred {
            try encodeContainer.encode(inferred, forKey: .inferred)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for string0 in names {
                try namesContainer.encode(string0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let entityPathContainer = try containerValues.decodeIfPresent([XRayClientTypes.ErrorRootCauseEntity?].self, forKey: .entityPath)
        var entityPathDecoded0:[XRayClientTypes.ErrorRootCauseEntity]? = nil
        if let entityPathContainer = entityPathContainer {
            entityPathDecoded0 = [XRayClientTypes.ErrorRootCauseEntity]()
            for structure0 in entityPathContainer {
                if let structure0 = structure0 {
                    entityPathDecoded0?.append(structure0)
                }
            }
        }
        entityPath = entityPathDecoded0
        let inferredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inferred)
        inferred = inferredDecoded
    }
}

extension XRayClientTypes {
    /// A collection of fields identifying the services in a trace summary error.
    public struct ErrorRootCauseService: Swift.Equatable {
        /// The account ID associated to the service.
        public var accountId: Swift.String?
        /// The path of root cause entities found on the service.
        public var entityPath: [XRayClientTypes.ErrorRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public var inferred: Swift.Bool?
        /// The service name.
        public var name: Swift.String?
        /// A collection of associated service names.
        public var names: [Swift.String]?
        /// The type associated to the service.
        public var type: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            entityPath: [XRayClientTypes.ErrorRootCauseEntity]? = nil,
            inferred: Swift.Bool? = nil,
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.type = type
        }
    }

}

extension XRayClientTypes.ErrorStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case otherCount = "OtherCount"
        case throttleCount = "ThrottleCount"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let otherCount = self.otherCount {
            try encodeContainer.encode(otherCount, forKey: .otherCount)
        }
        if let throttleCount = self.throttleCount {
            try encodeContainer.encode(throttleCount, forKey: .throttleCount)
        }
        if let totalCount = self.totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let throttleCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throttleCount)
        throttleCount = throttleCountDecoded
        let otherCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .otherCount)
        otherCount = otherCountDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension XRayClientTypes {
    /// Information about requests that failed with a 4xx Client Error status code.
    public struct ErrorStatistics: Swift.Equatable {
        /// The number of requests that failed with untracked 4xx Client Error status codes.
        public var otherCount: Swift.Int?
        /// The number of requests that failed with a 419 throttling status code.
        public var throttleCount: Swift.Int?
        /// The total number of requests that failed with a 4xx Client Error status code.
        public var totalCount: Swift.Int?

        public init(
            otherCount: Swift.Int? = nil,
            throttleCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil
        )
        {
            self.otherCount = otherCount
            self.throttleCount = throttleCount
            self.totalCount = totalCount
        }
    }

}

extension XRayClientTypes.FaultRootCause: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientImpacting = "ClientImpacting"
        case services = "Services"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientImpacting = self.clientImpacting {
            try encodeContainer.encode(clientImpacting, forKey: .clientImpacting)
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for faultrootcauseservice0 in services {
                try servicesContainer.encode(faultrootcauseservice0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([XRayClientTypes.FaultRootCauseService?].self, forKey: .services)
        var servicesDecoded0:[XRayClientTypes.FaultRootCauseService]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [XRayClientTypes.FaultRootCauseService]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let clientImpactingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clientImpacting)
        clientImpacting = clientImpactingDecoded
    }
}

extension XRayClientTypes {
    /// The root cause information for a trace summary fault.
    public struct FaultRootCause: Swift.Equatable {
        /// A flag that denotes that the root cause impacts the trace client.
        public var clientImpacting: Swift.Bool?
        /// A list of corresponding services. A service identifies a segment and it contains a name, account ID, type, and inferred flag.
        public var services: [XRayClientTypes.FaultRootCauseService]?

        public init(
            clientImpacting: Swift.Bool? = nil,
            services: [XRayClientTypes.FaultRootCauseService]? = nil
        )
        {
            self.clientImpacting = clientImpacting
            self.services = services
        }
    }

}

extension XRayClientTypes.FaultRootCauseEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptions = "Exceptions"
        case name = "Name"
        case remote = "Remote"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptions = exceptions {
            var exceptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exceptions)
            for rootcauseexception0 in exceptions {
                try exceptionsContainer.encode(rootcauseexception0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let remote = self.remote {
            try encodeContainer.encode(remote, forKey: .remote)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let exceptionsContainer = try containerValues.decodeIfPresent([XRayClientTypes.RootCauseException?].self, forKey: .exceptions)
        var exceptionsDecoded0:[XRayClientTypes.RootCauseException]? = nil
        if let exceptionsContainer = exceptionsContainer {
            exceptionsDecoded0 = [XRayClientTypes.RootCauseException]()
            for structure0 in exceptionsContainer {
                if let structure0 = structure0 {
                    exceptionsDecoded0?.append(structure0)
                }
            }
        }
        exceptions = exceptionsDecoded0
        let remoteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remote)
        remote = remoteDecoded
    }
}

extension XRayClientTypes {
    /// A collection of segments and corresponding subsegments associated to a trace summary fault error.
    public struct FaultRootCauseEntity: Swift.Equatable {
        /// The types and messages of the exceptions.
        public var exceptions: [XRayClientTypes.RootCauseException]?
        /// The name of the entity.
        public var name: Swift.String?
        /// A flag that denotes a remote subsegment.
        public var remote: Swift.Bool?

        public init(
            exceptions: [XRayClientTypes.RootCauseException]? = nil,
            name: Swift.String? = nil,
            remote: Swift.Bool? = nil
        )
        {
            self.exceptions = exceptions
            self.name = name
            self.remote = remote
        }
    }

}

extension XRayClientTypes.FaultRootCauseService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case entityPath = "EntityPath"
        case inferred = "Inferred"
        case name = "Name"
        case names = "Names"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let entityPath = entityPath {
            var entityPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityPath)
            for faultrootcauseentity0 in entityPath {
                try entityPathContainer.encode(faultrootcauseentity0)
            }
        }
        if let inferred = self.inferred {
            try encodeContainer.encode(inferred, forKey: .inferred)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for string0 in names {
                try namesContainer.encode(string0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let entityPathContainer = try containerValues.decodeIfPresent([XRayClientTypes.FaultRootCauseEntity?].self, forKey: .entityPath)
        var entityPathDecoded0:[XRayClientTypes.FaultRootCauseEntity]? = nil
        if let entityPathContainer = entityPathContainer {
            entityPathDecoded0 = [XRayClientTypes.FaultRootCauseEntity]()
            for structure0 in entityPathContainer {
                if let structure0 = structure0 {
                    entityPathDecoded0?.append(structure0)
                }
            }
        }
        entityPath = entityPathDecoded0
        let inferredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inferred)
        inferred = inferredDecoded
    }
}

extension XRayClientTypes {
    /// A collection of fields identifying the services in a trace summary fault.
    public struct FaultRootCauseService: Swift.Equatable {
        /// The account ID associated to the service.
        public var accountId: Swift.String?
        /// The path of root cause entities found on the service.
        public var entityPath: [XRayClientTypes.FaultRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public var inferred: Swift.Bool?
        /// The service name.
        public var name: Swift.String?
        /// A collection of associated service names.
        public var names: [Swift.String]?
        /// The type associated to the service.
        public var type: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            entityPath: [XRayClientTypes.FaultRootCauseEntity]? = nil,
            inferred: Swift.Bool? = nil,
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.type = type
        }
    }

}

extension XRayClientTypes.FaultStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case otherCount = "OtherCount"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let otherCount = self.otherCount {
            try encodeContainer.encode(otherCount, forKey: .otherCount)
        }
        if let totalCount = self.totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otherCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .otherCount)
        otherCount = otherCountDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension XRayClientTypes {
    /// Information about requests that failed with a 5xx Server Error status code.
    public struct FaultStatistics: Swift.Equatable {
        /// The number of requests that failed with untracked 5xx Server Error status codes.
        public var otherCount: Swift.Int?
        /// The total number of requests that failed with a 5xx Server Error status code.
        public var totalCount: Swift.Int?

        public init(
            otherCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil
        )
        {
            self.otherCount = otherCount
            self.totalCount = totalCount
        }
    }

}

extension XRayClientTypes.ForecastStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case faultCountHigh = "FaultCountHigh"
        case faultCountLow = "FaultCountLow"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let faultCountHigh = self.faultCountHigh {
            try encodeContainer.encode(faultCountHigh, forKey: .faultCountHigh)
        }
        if let faultCountLow = self.faultCountLow {
            try encodeContainer.encode(faultCountLow, forKey: .faultCountLow)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let faultCountHighDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .faultCountHigh)
        faultCountHigh = faultCountHighDecoded
        let faultCountLowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .faultCountLow)
        faultCountLow = faultCountLowDecoded
    }
}

extension XRayClientTypes {
    /// The predicted high and low fault count. This is used to determine if a service has become anomalous and if an insight should be created.
    public struct ForecastStatistics: Swift.Equatable {
        /// The upper limit of fault counts for a service.
        public var faultCountHigh: Swift.Int?
        /// The lower limit of fault counts for a service.
        public var faultCountLow: Swift.Int?

        public init(
            faultCountHigh: Swift.Int? = nil,
            faultCountLow: Swift.Int? = nil
        )
        {
            self.faultCountHigh = faultCountHigh
            self.faultCountLow = faultCountLow
        }
    }

}

extension GetEncryptionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/EncryptionConfig"
    }
}

public struct GetEncryptionConfigInput: Swift.Equatable {

    public init() { }
}

struct GetEncryptionConfigInputBody: Swift.Equatable {
}

extension GetEncryptionConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEncryptionConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEncryptionConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.encryptionConfig = output.encryptionConfig
        } else {
            self.encryptionConfig = nil
        }
    }
}

public struct GetEncryptionConfigOutput: Swift.Equatable {
    /// The encryption configuration document.
    public var encryptionConfig: XRayClientTypes.EncryptionConfig?

    public init(
        encryptionConfig: XRayClientTypes.EncryptionConfig? = nil
    )
    {
        self.encryptionConfig = encryptionConfig
    }
}

struct GetEncryptionConfigOutputBody: Swift.Equatable {
    let encryptionConfig: XRayClientTypes.EncryptionConfig?
}

extension GetEncryptionConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfig = "EncryptionConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(XRayClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

enum GetEncryptionConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupARN = "GroupARN"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupARN = self.groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }
}

extension GetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetGroup"
    }
}

public struct GetGroupInput: Swift.Equatable {
    /// The ARN of the group that was generated on creation.
    public var groupARN: Swift.String?
    /// The case-sensitive name of the group.
    public var groupName: Swift.String?

    public init(
        groupARN: Swift.String? = nil,
        groupName: Swift.String? = nil
    )
    {
        self.groupARN = groupARN
        self.groupName = groupName
    }
}

struct GetGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let groupARN: Swift.String?
}

extension GetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupARN = "GroupARN"
        case groupName = "GroupName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
    }
}

extension GetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

public struct GetGroupOutput: Swift.Equatable {
    /// The group that was requested. Contains the name of the group, the ARN of the group, the filter expression, and the insight configuration assigned to the group.
    public var group: XRayClientTypes.Group?

    public init(
        group: XRayClientTypes.Group? = nil
    )
    {
        self.group = group
    }
}

struct GetGroupOutputBody: Swift.Equatable {
    let group: XRayClientTypes.Group?
}

extension GetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(XRayClientTypes.Group.self, forKey: .group)
        group = groupDecoded
    }
}

enum GetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/Groups"
    }
}

public struct GetGroupsInput: Swift.Equatable {
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct GetGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension GetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct GetGroupsOutput: Swift.Equatable {
    /// The collection of all active groups.
    public var groups: [XRayClientTypes.GroupSummary]?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        groups: [XRayClientTypes.GroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct GetGroupsOutputBody: Swift.Equatable {
    let groups: [XRayClientTypes.GroupSummary]?
    let nextToken: Swift.String?
}

extension GetGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([XRayClientTypes.GroupSummary?].self, forKey: .groups)
        var groupsDecoded0:[XRayClientTypes.GroupSummary]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [XRayClientTypes.GroupSummary]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInsightEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightId = "InsightId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightId = self.insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetInsightEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/InsightEvents"
    }
}

public struct GetInsightEventsInput: Swift.Equatable {
    /// The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.
    /// This member is required.
    public var insightId: Swift.String?
    /// Used to retrieve at most the specified value of events.
    public var maxResults: Swift.Int?
    /// Specify the pagination token returned by a previous request to retrieve the next page of events.
    public var nextToken: Swift.String?

    public init(
        insightId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.insightId = insightId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetInsightEventsInputBody: Swift.Equatable {
    let insightId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetInsightEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightId = "InsightId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInsightEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInsightEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.insightEvents = output.insightEvents
            self.nextToken = output.nextToken
        } else {
            self.insightEvents = nil
            self.nextToken = nil
        }
    }
}

public struct GetInsightEventsOutput: Swift.Equatable {
    /// A detailed description of the event. This includes the time of the event, client and root cause impact statistics, and the top anomalous service at the time of the event.
    public var insightEvents: [XRayClientTypes.InsightEvent]?
    /// Use this token to retrieve the next page of insight events.
    public var nextToken: Swift.String?

    public init(
        insightEvents: [XRayClientTypes.InsightEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.insightEvents = insightEvents
        self.nextToken = nextToken
    }
}

struct GetInsightEventsOutputBody: Swift.Equatable {
    let insightEvents: [XRayClientTypes.InsightEvent]?
    let nextToken: Swift.String?
}

extension GetInsightEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightEvents = "InsightEvents"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightEventsContainer = try containerValues.decodeIfPresent([XRayClientTypes.InsightEvent?].self, forKey: .insightEvents)
        var insightEventsDecoded0:[XRayClientTypes.InsightEvent]? = nil
        if let insightEventsContainer = insightEventsContainer {
            insightEventsDecoded0 = [XRayClientTypes.InsightEvent]()
            for structure0 in insightEventsContainer {
                if let structure0 = structure0 {
                    insightEventsDecoded0?.append(structure0)
                }
            }
        }
        insightEvents = insightEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetInsightEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInsightImpactGraphInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case insightId = "InsightId"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let insightId = self.insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension GetInsightImpactGraphInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/InsightImpactGraph"
    }
}

public struct GetInsightImpactGraphInput: Swift.Equatable {
    /// The estimated end time of the insight, in Unix time seconds. The EndTime is exclusive of the value provided. The time range between the start time and end time can't be more than six hours.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.
    /// This member is required.
    public var insightId: Swift.String?
    /// Specify the pagination token returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The estimated start time of the insight, in Unix time seconds. The StartTime is inclusive of the value provided and can't be more than 30 days old.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        insightId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.insightId = insightId
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct GetInsightImpactGraphInputBody: Swift.Equatable {
    let insightId: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let nextToken: Swift.String?
}

extension GetInsightImpactGraphInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case insightId = "InsightId"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInsightImpactGraphOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInsightImpactGraphOutputBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.insightId = output.insightId
            self.nextToken = output.nextToken
            self.serviceGraphEndTime = output.serviceGraphEndTime
            self.serviceGraphStartTime = output.serviceGraphStartTime
            self.services = output.services
            self.startTime = output.startTime
        } else {
            self.endTime = nil
            self.insightId = nil
            self.nextToken = nil
            self.serviceGraphEndTime = nil
            self.serviceGraphStartTime = nil
            self.services = nil
            self.startTime = nil
        }
    }
}

public struct GetInsightImpactGraphOutput: Swift.Equatable {
    /// The provided end time.
    public var endTime: ClientRuntime.Date?
    /// The insight's unique identifier.
    public var insightId: Swift.String?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The time, in Unix seconds, at which the service graph ended.
    public var serviceGraphEndTime: ClientRuntime.Date?
    /// The time, in Unix seconds, at which the service graph started.
    public var serviceGraphStartTime: ClientRuntime.Date?
    /// The Amazon Web Services instrumented services related to the insight.
    public var services: [XRayClientTypes.InsightImpactGraphService]?
    /// The provided start time.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        insightId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceGraphEndTime: ClientRuntime.Date? = nil,
        serviceGraphStartTime: ClientRuntime.Date? = nil,
        services: [XRayClientTypes.InsightImpactGraphService]? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.insightId = insightId
        self.nextToken = nextToken
        self.serviceGraphEndTime = serviceGraphEndTime
        self.serviceGraphStartTime = serviceGraphStartTime
        self.services = services
        self.startTime = startTime
    }
}

struct GetInsightImpactGraphOutputBody: Swift.Equatable {
    let insightId: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let serviceGraphStartTime: ClientRuntime.Date?
    let serviceGraphEndTime: ClientRuntime.Date?
    let services: [XRayClientTypes.InsightImpactGraphService]?
    let nextToken: Swift.String?
}

extension GetInsightImpactGraphOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case insightId = "InsightId"
        case nextToken = "NextToken"
        case serviceGraphEndTime = "ServiceGraphEndTime"
        case serviceGraphStartTime = "ServiceGraphStartTime"
        case services = "Services"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let serviceGraphStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .serviceGraphStartTime)
        serviceGraphStartTime = serviceGraphStartTimeDecoded
        let serviceGraphEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .serviceGraphEndTime)
        serviceGraphEndTime = serviceGraphEndTimeDecoded
        let servicesContainer = try containerValues.decodeIfPresent([XRayClientTypes.InsightImpactGraphService?].self, forKey: .services)
        var servicesDecoded0:[XRayClientTypes.InsightImpactGraphService]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [XRayClientTypes.InsightImpactGraphService]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetInsightImpactGraphOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInsightInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightId = "InsightId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightId = self.insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
    }
}

extension GetInsightInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/Insight"
    }
}

public struct GetInsightInput: Swift.Equatable {
    /// The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.
    /// This member is required.
    public var insightId: Swift.String?

    public init(
        insightId: Swift.String? = nil
    )
    {
        self.insightId = insightId
    }
}

struct GetInsightInputBody: Swift.Equatable {
    let insightId: Swift.String?
}

extension GetInsightInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightId = "InsightId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
    }
}

extension GetInsightOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInsightOutputBody = try responseDecoder.decode(responseBody: data)
            self.insight = output.insight
        } else {
            self.insight = nil
        }
    }
}

public struct GetInsightOutput: Swift.Equatable {
    /// The summary information of an insight.
    public var insight: XRayClientTypes.Insight?

    public init(
        insight: XRayClientTypes.Insight? = nil
    )
    {
        self.insight = insight
    }
}

struct GetInsightOutputBody: Swift.Equatable {
    let insight: XRayClientTypes.Insight?
}

extension GetInsightOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insight = "Insight"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightDecoded = try containerValues.decodeIfPresent(XRayClientTypes.Insight.self, forKey: .insight)
        insight = insightDecoded
    }
}

enum GetInsightOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInsightSummariesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
        case states = "States"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let groupARN = self.groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let states = states {
            var statesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .states)
            for insightstate0 in states {
                try statesContainer.encode(insightstate0.rawValue)
            }
        }
    }
}

extension GetInsightSummariesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/InsightSummaries"
    }
}

public struct GetInsightSummariesInput: Swift.Equatable {
    /// The end of the time frame in which the insights ended. The end time can't be more than 30 days old.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the group. Required if the GroupName isn't provided.
    public var groupARN: Swift.String?
    /// The name of the group. Required if the GroupARN isn't provided.
    public var groupName: Swift.String?
    /// The maximum number of results to display.
    public var maxResults: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The beginning of the time frame in which the insights started. The start time can't be more than 30 days old.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// The list of insight states.
    public var states: [XRayClientTypes.InsightState]?

    public init(
        endTime: ClientRuntime.Date? = nil,
        groupARN: Swift.String? = nil,
        groupName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        states: [XRayClientTypes.InsightState]? = nil
    )
    {
        self.endTime = endTime
        self.groupARN = groupARN
        self.groupName = groupName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.states = states
    }
}

struct GetInsightSummariesInputBody: Swift.Equatable {
    let states: [XRayClientTypes.InsightState]?
    let groupARN: Swift.String?
    let groupName: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetInsightSummariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
        case states = "States"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statesContainer = try containerValues.decodeIfPresent([XRayClientTypes.InsightState?].self, forKey: .states)
        var statesDecoded0:[XRayClientTypes.InsightState]? = nil
        if let statesContainer = statesContainer {
            statesDecoded0 = [XRayClientTypes.InsightState]()
            for enum0 in statesContainer {
                if let enum0 = enum0 {
                    statesDecoded0?.append(enum0)
                }
            }
        }
        states = statesDecoded0
        let groupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInsightSummariesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInsightSummariesOutputBody = try responseDecoder.decode(responseBody: data)
            self.insightSummaries = output.insightSummaries
            self.nextToken = output.nextToken
        } else {
            self.insightSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct GetInsightSummariesOutput: Swift.Equatable {
    /// The summary of each insight within the group matching the provided filters. The summary contains the InsightID, start and end time, the root cause service, the root cause and client impact statistics, the top anomalous services, and the status of the insight.
    public var insightSummaries: [XRayClientTypes.InsightSummary]?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        insightSummaries: [XRayClientTypes.InsightSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.insightSummaries = insightSummaries
        self.nextToken = nextToken
    }
}

struct GetInsightSummariesOutputBody: Swift.Equatable {
    let insightSummaries: [XRayClientTypes.InsightSummary]?
    let nextToken: Swift.String?
}

extension GetInsightSummariesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightSummaries = "InsightSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightSummariesContainer = try containerValues.decodeIfPresent([XRayClientTypes.InsightSummary?].self, forKey: .insightSummaries)
        var insightSummariesDecoded0:[XRayClientTypes.InsightSummary]? = nil
        if let insightSummariesContainer = insightSummariesContainer {
            insightSummariesDecoded0 = [XRayClientTypes.InsightSummary]()
            for structure0 in insightSummariesContainer {
                if let structure0 = structure0 {
                    insightSummariesDecoded0?.append(structure0)
                }
            }
        }
        insightSummaries = insightSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetInsightSummariesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSamplingRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetSamplingRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetSamplingRules"
    }
}

public struct GetSamplingRulesInput: Swift.Equatable {
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct GetSamplingRulesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension GetSamplingRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetSamplingRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSamplingRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.samplingRuleRecords = output.samplingRuleRecords
        } else {
            self.nextToken = nil
            self.samplingRuleRecords = nil
        }
    }
}

public struct GetSamplingRulesOutput: Swift.Equatable {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// Rule definitions and metadata.
    public var samplingRuleRecords: [XRayClientTypes.SamplingRuleRecord]?

    public init(
        nextToken: Swift.String? = nil,
        samplingRuleRecords: [XRayClientTypes.SamplingRuleRecord]? = nil
    )
    {
        self.nextToken = nextToken
        self.samplingRuleRecords = samplingRuleRecords
    }
}

struct GetSamplingRulesOutputBody: Swift.Equatable {
    let samplingRuleRecords: [XRayClientTypes.SamplingRuleRecord]?
    let nextToken: Swift.String?
}

extension GetSamplingRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case samplingRuleRecords = "SamplingRuleRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleRecordsContainer = try containerValues.decodeIfPresent([XRayClientTypes.SamplingRuleRecord?].self, forKey: .samplingRuleRecords)
        var samplingRuleRecordsDecoded0:[XRayClientTypes.SamplingRuleRecord]? = nil
        if let samplingRuleRecordsContainer = samplingRuleRecordsContainer {
            samplingRuleRecordsDecoded0 = [XRayClientTypes.SamplingRuleRecord]()
            for structure0 in samplingRuleRecordsContainer {
                if let structure0 = structure0 {
                    samplingRuleRecordsDecoded0?.append(structure0)
                }
            }
        }
        samplingRuleRecords = samplingRuleRecordsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetSamplingRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSamplingStatisticSummariesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetSamplingStatisticSummariesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/SamplingStatisticSummaries"
    }
}

public struct GetSamplingStatisticSummariesInput: Swift.Equatable {
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct GetSamplingStatisticSummariesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension GetSamplingStatisticSummariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetSamplingStatisticSummariesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSamplingStatisticSummariesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.samplingStatisticSummaries = output.samplingStatisticSummaries
        } else {
            self.nextToken = nil
            self.samplingStatisticSummaries = nil
        }
    }
}

public struct GetSamplingStatisticSummariesOutput: Swift.Equatable {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// Information about the number of requests instrumented for each sampling rule.
    public var samplingStatisticSummaries: [XRayClientTypes.SamplingStatisticSummary]?

    public init(
        nextToken: Swift.String? = nil,
        samplingStatisticSummaries: [XRayClientTypes.SamplingStatisticSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.samplingStatisticSummaries = samplingStatisticSummaries
    }
}

struct GetSamplingStatisticSummariesOutputBody: Swift.Equatable {
    let samplingStatisticSummaries: [XRayClientTypes.SamplingStatisticSummary]?
    let nextToken: Swift.String?
}

extension GetSamplingStatisticSummariesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case samplingStatisticSummaries = "SamplingStatisticSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingStatisticSummariesContainer = try containerValues.decodeIfPresent([XRayClientTypes.SamplingStatisticSummary?].self, forKey: .samplingStatisticSummaries)
        var samplingStatisticSummariesDecoded0:[XRayClientTypes.SamplingStatisticSummary]? = nil
        if let samplingStatisticSummariesContainer = samplingStatisticSummariesContainer {
            samplingStatisticSummariesDecoded0 = [XRayClientTypes.SamplingStatisticSummary]()
            for structure0 in samplingStatisticSummariesContainer {
                if let structure0 = structure0 {
                    samplingStatisticSummariesDecoded0?.append(structure0)
                }
            }
        }
        samplingStatisticSummaries = samplingStatisticSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetSamplingStatisticSummariesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSamplingTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samplingStatisticsDocuments = "SamplingStatisticsDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let samplingStatisticsDocuments = samplingStatisticsDocuments {
            var samplingStatisticsDocumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .samplingStatisticsDocuments)
            for samplingstatisticsdocument0 in samplingStatisticsDocuments {
                try samplingStatisticsDocumentsContainer.encode(samplingstatisticsdocument0)
            }
        }
    }
}

extension GetSamplingTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/SamplingTargets"
    }
}

public struct GetSamplingTargetsInput: Swift.Equatable {
    /// Information about rules that the service is using to sample requests.
    /// This member is required.
    public var samplingStatisticsDocuments: [XRayClientTypes.SamplingStatisticsDocument]?

    public init(
        samplingStatisticsDocuments: [XRayClientTypes.SamplingStatisticsDocument]? = nil
    )
    {
        self.samplingStatisticsDocuments = samplingStatisticsDocuments
    }
}

struct GetSamplingTargetsInputBody: Swift.Equatable {
    let samplingStatisticsDocuments: [XRayClientTypes.SamplingStatisticsDocument]?
}

extension GetSamplingTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samplingStatisticsDocuments = "SamplingStatisticsDocuments"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingStatisticsDocumentsContainer = try containerValues.decodeIfPresent([XRayClientTypes.SamplingStatisticsDocument?].self, forKey: .samplingStatisticsDocuments)
        var samplingStatisticsDocumentsDecoded0:[XRayClientTypes.SamplingStatisticsDocument]? = nil
        if let samplingStatisticsDocumentsContainer = samplingStatisticsDocumentsContainer {
            samplingStatisticsDocumentsDecoded0 = [XRayClientTypes.SamplingStatisticsDocument]()
            for structure0 in samplingStatisticsDocumentsContainer {
                if let structure0 = structure0 {
                    samplingStatisticsDocumentsDecoded0?.append(structure0)
                }
            }
        }
        samplingStatisticsDocuments = samplingStatisticsDocumentsDecoded0
    }
}

extension GetSamplingTargetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSamplingTargetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastRuleModification = output.lastRuleModification
            self.samplingTargetDocuments = output.samplingTargetDocuments
            self.unprocessedStatistics = output.unprocessedStatistics
        } else {
            self.lastRuleModification = nil
            self.samplingTargetDocuments = nil
            self.unprocessedStatistics = nil
        }
    }
}

public struct GetSamplingTargetsOutput: Swift.Equatable {
    /// The last time a user changed the sampling rule configuration. If the sampling rule configuration changed since the service last retrieved it, the service should call [GetSamplingRules](https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingRules.html) to get the latest version.
    public var lastRuleModification: ClientRuntime.Date?
    /// Updated rules that the service should use to sample requests.
    public var samplingTargetDocuments: [XRayClientTypes.SamplingTargetDocument]?
    /// Information about [SamplingStatisticsDocument](https://docs.aws.amazon.com/xray/latest/api/API_SamplingStatisticsDocument.html) that X-Ray could not process.
    public var unprocessedStatistics: [XRayClientTypes.UnprocessedStatistics]?

    public init(
        lastRuleModification: ClientRuntime.Date? = nil,
        samplingTargetDocuments: [XRayClientTypes.SamplingTargetDocument]? = nil,
        unprocessedStatistics: [XRayClientTypes.UnprocessedStatistics]? = nil
    )
    {
        self.lastRuleModification = lastRuleModification
        self.samplingTargetDocuments = samplingTargetDocuments
        self.unprocessedStatistics = unprocessedStatistics
    }
}

struct GetSamplingTargetsOutputBody: Swift.Equatable {
    let samplingTargetDocuments: [XRayClientTypes.SamplingTargetDocument]?
    let lastRuleModification: ClientRuntime.Date?
    let unprocessedStatistics: [XRayClientTypes.UnprocessedStatistics]?
}

extension GetSamplingTargetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastRuleModification = "LastRuleModification"
        case samplingTargetDocuments = "SamplingTargetDocuments"
        case unprocessedStatistics = "UnprocessedStatistics"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingTargetDocumentsContainer = try containerValues.decodeIfPresent([XRayClientTypes.SamplingTargetDocument?].self, forKey: .samplingTargetDocuments)
        var samplingTargetDocumentsDecoded0:[XRayClientTypes.SamplingTargetDocument]? = nil
        if let samplingTargetDocumentsContainer = samplingTargetDocumentsContainer {
            samplingTargetDocumentsDecoded0 = [XRayClientTypes.SamplingTargetDocument]()
            for structure0 in samplingTargetDocumentsContainer {
                if let structure0 = structure0 {
                    samplingTargetDocumentsDecoded0?.append(structure0)
                }
            }
        }
        samplingTargetDocuments = samplingTargetDocumentsDecoded0
        let lastRuleModificationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRuleModification)
        lastRuleModification = lastRuleModificationDecoded
        let unprocessedStatisticsContainer = try containerValues.decodeIfPresent([XRayClientTypes.UnprocessedStatistics?].self, forKey: .unprocessedStatistics)
        var unprocessedStatisticsDecoded0:[XRayClientTypes.UnprocessedStatistics]? = nil
        if let unprocessedStatisticsContainer = unprocessedStatisticsContainer {
            unprocessedStatisticsDecoded0 = [XRayClientTypes.UnprocessedStatistics]()
            for structure0 in unprocessedStatisticsContainer {
                if let structure0 = structure0 {
                    unprocessedStatisticsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedStatistics = unprocessedStatisticsDecoded0
    }
}

enum GetSamplingTargetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceGraphInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let groupARN = self.groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension GetServiceGraphInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ServiceGraph"
    }
}

public struct GetServiceGraphInput: Swift.Equatable {
    /// The end of the timeframe for which to generate a graph.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of a group based on which you want to generate a graph.
    public var groupARN: Swift.String?
    /// The name of a group based on which you want to generate a graph.
    public var groupName: Swift.String?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The start of the time frame for which to generate a graph.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        groupARN: Swift.String? = nil,
        groupName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.groupARN = groupARN
        self.groupName = groupName
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct GetServiceGraphInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let groupName: Swift.String?
    let groupARN: Swift.String?
    let nextToken: Swift.String?
}

extension GetServiceGraphInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetServiceGraphOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceGraphOutputBody = try responseDecoder.decode(responseBody: data)
            self.containsOldGroupVersions = output.containsOldGroupVersions
            self.endTime = output.endTime
            self.nextToken = output.nextToken
            self.services = output.services
            self.startTime = output.startTime
        } else {
            self.containsOldGroupVersions = false
            self.endTime = nil
            self.nextToken = nil
            self.services = nil
            self.startTime = nil
        }
    }
}

public struct GetServiceGraphOutput: Swift.Equatable {
    /// A flag indicating whether the group's filter expression has been consistent, or if the returned service graph may show traces from an older version of the group's filter expression.
    public var containsOldGroupVersions: Swift.Bool
    /// The end of the time frame for which the graph was generated.
    public var endTime: ClientRuntime.Date?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The services that have processed a traced request during the specified time frame.
    public var services: [XRayClientTypes.Service]?
    /// The start of the time frame for which the graph was generated.
    public var startTime: ClientRuntime.Date?

    public init(
        containsOldGroupVersions: Swift.Bool = false,
        endTime: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        services: [XRayClientTypes.Service]? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.containsOldGroupVersions = containsOldGroupVersions
        self.endTime = endTime
        self.nextToken = nextToken
        self.services = services
        self.startTime = startTime
    }
}

struct GetServiceGraphOutputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let services: [XRayClientTypes.Service]?
    let containsOldGroupVersions: Swift.Bool
    let nextToken: Swift.String?
}

extension GetServiceGraphOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containsOldGroupVersions = "ContainsOldGroupVersions"
        case endTime = "EndTime"
        case nextToken = "NextToken"
        case services = "Services"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let servicesContainer = try containerValues.decodeIfPresent([XRayClientTypes.Service?].self, forKey: .services)
        var servicesDecoded0:[XRayClientTypes.Service]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [XRayClientTypes.Service]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let containsOldGroupVersionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .containsOldGroupVersions) ?? false
        containsOldGroupVersions = containsOldGroupVersionsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetServiceGraphOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTimeSeriesServiceStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case entitySelectorExpression = "EntitySelectorExpression"
        case forecastStatistics = "ForecastStatistics"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case nextToken = "NextToken"
        case period = "Period"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let entitySelectorExpression = self.entitySelectorExpression {
            try encodeContainer.encode(entitySelectorExpression, forKey: .entitySelectorExpression)
        }
        if let forecastStatistics = self.forecastStatistics {
            try encodeContainer.encode(forecastStatistics, forKey: .forecastStatistics)
        }
        if let groupARN = self.groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let period = self.period {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension GetTimeSeriesServiceStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TimeSeriesServiceStatistics"
    }
}

public struct GetTimeSeriesServiceStatisticsInput: Swift.Equatable {
    /// The end of the time frame for which to aggregate statistics.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// A filter expression defining entities that will be aggregated for statistics. Supports ID, service, and edge functions. If no selector expression is specified, edge statistics are returned.
    public var entitySelectorExpression: Swift.String?
    /// The forecasted high and low fault count values. Forecast enabled requests require the EntitySelectorExpression ID be provided.
    public var forecastStatistics: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the group for which to pull statistics from.
    public var groupARN: Swift.String?
    /// The case-sensitive name of the group for which to pull statistics from.
    public var groupName: Swift.String?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// Aggregation period in seconds.
    public var period: Swift.Int?
    /// The start of the time frame for which to aggregate statistics.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        entitySelectorExpression: Swift.String? = nil,
        forecastStatistics: Swift.Bool? = nil,
        groupARN: Swift.String? = nil,
        groupName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        period: Swift.Int? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.entitySelectorExpression = entitySelectorExpression
        self.forecastStatistics = forecastStatistics
        self.groupARN = groupARN
        self.groupName = groupName
        self.nextToken = nextToken
        self.period = period
        self.startTime = startTime
    }
}

struct GetTimeSeriesServiceStatisticsInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let groupName: Swift.String?
    let groupARN: Swift.String?
    let entitySelectorExpression: Swift.String?
    let period: Swift.Int?
    let forecastStatistics: Swift.Bool?
    let nextToken: Swift.String?
}

extension GetTimeSeriesServiceStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case entitySelectorExpression = "EntitySelectorExpression"
        case forecastStatistics = "ForecastStatistics"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case nextToken = "NextToken"
        case period = "Period"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let entitySelectorExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitySelectorExpression)
        entitySelectorExpression = entitySelectorExpressionDecoded
        let periodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .period)
        period = periodDecoded
        let forecastStatisticsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forecastStatistics)
        forecastStatistics = forecastStatisticsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTimeSeriesServiceStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTimeSeriesServiceStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.containsOldGroupVersions = output.containsOldGroupVersions
            self.nextToken = output.nextToken
            self.timeSeriesServiceStatistics = output.timeSeriesServiceStatistics
        } else {
            self.containsOldGroupVersions = false
            self.nextToken = nil
            self.timeSeriesServiceStatistics = nil
        }
    }
}

public struct GetTimeSeriesServiceStatisticsOutput: Swift.Equatable {
    /// A flag indicating whether or not a group's filter expression has been consistent, or if a returned aggregation might show statistics from an older version of the group's filter expression.
    public var containsOldGroupVersions: Swift.Bool
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The collection of statistics.
    public var timeSeriesServiceStatistics: [XRayClientTypes.TimeSeriesServiceStatistics]?

    public init(
        containsOldGroupVersions: Swift.Bool = false,
        nextToken: Swift.String? = nil,
        timeSeriesServiceStatistics: [XRayClientTypes.TimeSeriesServiceStatistics]? = nil
    )
    {
        self.containsOldGroupVersions = containsOldGroupVersions
        self.nextToken = nextToken
        self.timeSeriesServiceStatistics = timeSeriesServiceStatistics
    }
}

struct GetTimeSeriesServiceStatisticsOutputBody: Swift.Equatable {
    let timeSeriesServiceStatistics: [XRayClientTypes.TimeSeriesServiceStatistics]?
    let containsOldGroupVersions: Swift.Bool
    let nextToken: Swift.String?
}

extension GetTimeSeriesServiceStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containsOldGroupVersions = "ContainsOldGroupVersions"
        case nextToken = "NextToken"
        case timeSeriesServiceStatistics = "TimeSeriesServiceStatistics"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesServiceStatisticsContainer = try containerValues.decodeIfPresent([XRayClientTypes.TimeSeriesServiceStatistics?].self, forKey: .timeSeriesServiceStatistics)
        var timeSeriesServiceStatisticsDecoded0:[XRayClientTypes.TimeSeriesServiceStatistics]? = nil
        if let timeSeriesServiceStatisticsContainer = timeSeriesServiceStatisticsContainer {
            timeSeriesServiceStatisticsDecoded0 = [XRayClientTypes.TimeSeriesServiceStatistics]()
            for structure0 in timeSeriesServiceStatisticsContainer {
                if let structure0 = structure0 {
                    timeSeriesServiceStatisticsDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesServiceStatistics = timeSeriesServiceStatisticsDecoded0
        let containsOldGroupVersionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .containsOldGroupVersions) ?? false
        containsOldGroupVersions = containsOldGroupVersionsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetTimeSeriesServiceStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTraceGraphInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case traceIds = "TraceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let traceIds = traceIds {
            var traceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traceIds)
            for traceid0 in traceIds {
                try traceIdsContainer.encode(traceid0)
            }
        }
    }
}

extension GetTraceGraphInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TraceGraph"
    }
}

public struct GetTraceGraphInput: Swift.Equatable {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// Trace IDs of requests for which to generate a service graph.
    /// This member is required.
    public var traceIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        traceIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.traceIds = traceIds
    }
}

struct GetTraceGraphInputBody: Swift.Equatable {
    let traceIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension GetTraceGraphInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case traceIds = "TraceIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .traceIds)
        var traceIdsDecoded0:[Swift.String]? = nil
        if let traceIdsContainer = traceIdsContainer {
            traceIdsDecoded0 = [Swift.String]()
            for string0 in traceIdsContainer {
                if let string0 = string0 {
                    traceIdsDecoded0?.append(string0)
                }
            }
        }
        traceIds = traceIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTraceGraphOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTraceGraphOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct GetTraceGraphOutput: Swift.Equatable {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The services that have processed one of the specified requests.
    public var services: [XRayClientTypes.Service]?

    public init(
        nextToken: Swift.String? = nil,
        services: [XRayClientTypes.Service]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

struct GetTraceGraphOutputBody: Swift.Equatable {
    let services: [XRayClientTypes.Service]?
    let nextToken: Swift.String?
}

extension GetTraceGraphOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case services = "Services"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([XRayClientTypes.Service?].self, forKey: .services)
        var servicesDecoded0:[XRayClientTypes.Service]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [XRayClientTypes.Service]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetTraceGraphOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTraceSummariesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case filterExpression = "FilterExpression"
        case nextToken = "NextToken"
        case sampling = "Sampling"
        case samplingStrategy = "SamplingStrategy"
        case startTime = "StartTime"
        case timeRangeType = "TimeRangeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let filterExpression = self.filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sampling = self.sampling {
            try encodeContainer.encode(sampling, forKey: .sampling)
        }
        if let samplingStrategy = self.samplingStrategy {
            try encodeContainer.encode(samplingStrategy, forKey: .samplingStrategy)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let timeRangeType = self.timeRangeType {
            try encodeContainer.encode(timeRangeType.rawValue, forKey: .timeRangeType)
        }
    }
}

extension GetTraceSummariesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TraceSummaries"
    }
}

public struct GetTraceSummariesInput: Swift.Equatable {
    /// The end of the time frame for which to retrieve traces.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// Specify a filter expression to retrieve trace summaries for services or requests that meet certain requirements.
    public var filterExpression: Swift.String?
    /// Specify the pagination token returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Set to true to get summaries for only a subset of available traces.
    public var sampling: Swift.Bool?
    /// A parameter to indicate whether to enable sampling on trace summaries. Input parameters are Name and Value.
    public var samplingStrategy: XRayClientTypes.SamplingStrategy?
    /// The start of the time frame for which to retrieve traces.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// A parameter to indicate whether to query trace summaries by TraceId or Event time.
    public var timeRangeType: XRayClientTypes.TimeRangeType?

    public init(
        endTime: ClientRuntime.Date? = nil,
        filterExpression: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sampling: Swift.Bool? = nil,
        samplingStrategy: XRayClientTypes.SamplingStrategy? = nil,
        startTime: ClientRuntime.Date? = nil,
        timeRangeType: XRayClientTypes.TimeRangeType? = nil
    )
    {
        self.endTime = endTime
        self.filterExpression = filterExpression
        self.nextToken = nextToken
        self.sampling = sampling
        self.samplingStrategy = samplingStrategy
        self.startTime = startTime
        self.timeRangeType = timeRangeType
    }
}

struct GetTraceSummariesInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let timeRangeType: XRayClientTypes.TimeRangeType?
    let sampling: Swift.Bool?
    let samplingStrategy: XRayClientTypes.SamplingStrategy?
    let filterExpression: Swift.String?
    let nextToken: Swift.String?
}

extension GetTraceSummariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case filterExpression = "FilterExpression"
        case nextToken = "NextToken"
        case sampling = "Sampling"
        case samplingStrategy = "SamplingStrategy"
        case startTime = "StartTime"
        case timeRangeType = "TimeRangeType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let timeRangeTypeDecoded = try containerValues.decodeIfPresent(XRayClientTypes.TimeRangeType.self, forKey: .timeRangeType)
        timeRangeType = timeRangeTypeDecoded
        let samplingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sampling)
        sampling = samplingDecoded
        let samplingStrategyDecoded = try containerValues.decodeIfPresent(XRayClientTypes.SamplingStrategy.self, forKey: .samplingStrategy)
        samplingStrategy = samplingStrategyDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTraceSummariesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTraceSummariesOutputBody = try responseDecoder.decode(responseBody: data)
            self.approximateTime = output.approximateTime
            self.nextToken = output.nextToken
            self.traceSummaries = output.traceSummaries
            self.tracesProcessedCount = output.tracesProcessedCount
        } else {
            self.approximateTime = nil
            self.nextToken = nil
            self.traceSummaries = nil
            self.tracesProcessedCount = nil
        }
    }
}

public struct GetTraceSummariesOutput: Swift.Equatable {
    /// The start time of this page of results.
    public var approximateTime: ClientRuntime.Date?
    /// If the requested time frame contained more than one page of results, you can use this token to retrieve the next page. The first page contains the most recent results, closest to the end of the time frame.
    public var nextToken: Swift.String?
    /// Trace IDs and annotations for traces that were found in the specified time frame.
    public var traceSummaries: [XRayClientTypes.TraceSummary]?
    /// The total number of traces processed, including traces that did not match the specified filter expression.
    public var tracesProcessedCount: Swift.Int?

    public init(
        approximateTime: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        traceSummaries: [XRayClientTypes.TraceSummary]? = nil,
        tracesProcessedCount: Swift.Int? = nil
    )
    {
        self.approximateTime = approximateTime
        self.nextToken = nextToken
        self.traceSummaries = traceSummaries
        self.tracesProcessedCount = tracesProcessedCount
    }
}

struct GetTraceSummariesOutputBody: Swift.Equatable {
    let traceSummaries: [XRayClientTypes.TraceSummary]?
    let approximateTime: ClientRuntime.Date?
    let tracesProcessedCount: Swift.Int?
    let nextToken: Swift.String?
}

extension GetTraceSummariesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateTime = "ApproximateTime"
        case nextToken = "NextToken"
        case traceSummaries = "TraceSummaries"
        case tracesProcessedCount = "TracesProcessedCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceSummariesContainer = try containerValues.decodeIfPresent([XRayClientTypes.TraceSummary?].self, forKey: .traceSummaries)
        var traceSummariesDecoded0:[XRayClientTypes.TraceSummary]? = nil
        if let traceSummariesContainer = traceSummariesContainer {
            traceSummariesDecoded0 = [XRayClientTypes.TraceSummary]()
            for structure0 in traceSummariesContainer {
                if let structure0 = structure0 {
                    traceSummariesDecoded0?.append(structure0)
                }
            }
        }
        traceSummaries = traceSummariesDecoded0
        let approximateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .approximateTime)
        approximateTime = approximateTimeDecoded
        let tracesProcessedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tracesProcessedCount)
        tracesProcessedCount = tracesProcessedCountDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetTraceSummariesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension XRayClientTypes.Group: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpression = "FilterExpression"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case insightsConfiguration = "InsightsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterExpression = self.filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let groupARN = self.groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let insightsConfiguration = self.insightsConfiguration {
            try encodeContainer.encode(insightsConfiguration, forKey: .insightsConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let insightsConfigurationDecoded = try containerValues.decodeIfPresent(XRayClientTypes.InsightsConfiguration.self, forKey: .insightsConfiguration)
        insightsConfiguration = insightsConfigurationDecoded
    }
}

extension XRayClientTypes {
    /// Details and metadata for a group.
    public struct Group: Swift.Equatable {
        /// The filter expression defining the parameters to include traces.
        public var filterExpression: Swift.String?
        /// The Amazon Resource Name (ARN) of the group generated based on the GroupName.
        public var groupARN: Swift.String?
        /// The unique case-sensitive name of the group.
        public var groupName: Swift.String?
        /// The structure containing configurations related to insights.
        ///
        /// * The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.
        ///
        /// * The NotificationsEnabled boolean can be set to true to enable insights notifications through Amazon EventBridge for the group.
        public var insightsConfiguration: XRayClientTypes.InsightsConfiguration?

        public init(
            filterExpression: Swift.String? = nil,
            groupARN: Swift.String? = nil,
            groupName: Swift.String? = nil,
            insightsConfiguration: XRayClientTypes.InsightsConfiguration? = nil
        )
        {
            self.filterExpression = filterExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
        }
    }

}

extension XRayClientTypes.GroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpression = "FilterExpression"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case insightsConfiguration = "InsightsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterExpression = self.filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let groupARN = self.groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let insightsConfiguration = self.insightsConfiguration {
            try encodeContainer.encode(insightsConfiguration, forKey: .insightsConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let insightsConfigurationDecoded = try containerValues.decodeIfPresent(XRayClientTypes.InsightsConfiguration.self, forKey: .insightsConfiguration)
        insightsConfiguration = insightsConfigurationDecoded
    }
}

extension XRayClientTypes {
    /// Details for a group without metadata.
    public struct GroupSummary: Swift.Equatable {
        /// The filter expression defining the parameters to include traces.
        public var filterExpression: Swift.String?
        /// The ARN of the group generated based on the GroupName.
        public var groupARN: Swift.String?
        /// The unique case-sensitive name of the group.
        public var groupName: Swift.String?
        /// The structure containing configurations related to insights.
        ///
        /// * The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.
        ///
        /// * The NotificationsEnabled boolean can be set to true to enable insights notifications. Notifications can only be enabled on a group with InsightsEnabled set to true.
        public var insightsConfiguration: XRayClientTypes.InsightsConfiguration?

        public init(
            filterExpression: Swift.String? = nil,
            groupARN: Swift.String? = nil,
            groupName: Swift.String? = nil,
            insightsConfiguration: XRayClientTypes.InsightsConfiguration? = nil
        )
        {
            self.filterExpression = filterExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
        }
    }

}

extension XRayClientTypes.HistogramEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value) ?? 0.0
        value = valueDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
    }
}

extension XRayClientTypes {
    /// An entry in a histogram for a statistic. A histogram maps the range of observed values on the X axis, and the prevalence of each value on the Y axis.
    public struct HistogramEntry: Swift.Equatable {
        /// The prevalence of the entry.
        public var count: Swift.Int
        /// The value of the entry.
        public var value: Swift.Double

        public init(
            count: Swift.Int = 0,
            value: Swift.Double = 0.0
        )
        {
            self.count = count
            self.value = value
        }
    }

}

extension XRayClientTypes.Http: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientIp = "ClientIp"
        case httpMethod = "HttpMethod"
        case httpStatus = "HttpStatus"
        case httpURL = "HttpURL"
        case userAgent = "UserAgent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIp = self.clientIp {
            try encodeContainer.encode(clientIp, forKey: .clientIp)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let httpStatus = self.httpStatus {
            try encodeContainer.encode(httpStatus, forKey: .httpStatus)
        }
        if let httpURL = self.httpURL {
            try encodeContainer.encode(httpURL, forKey: .httpURL)
        }
        if let userAgent = self.userAgent {
            try encodeContainer.encode(userAgent, forKey: .userAgent)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpURL)
        httpURL = httpURLDecoded
        let httpStatusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpStatus)
        httpStatus = httpStatusDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let userAgentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAgent)
        userAgent = userAgentDecoded
        let clientIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientIp)
        clientIp = clientIpDecoded
    }
}

extension XRayClientTypes {
    /// Information about an HTTP request.
    public struct Http: Swift.Equatable {
        /// The IP address of the requestor.
        public var clientIp: Swift.String?
        /// The request method.
        public var httpMethod: Swift.String?
        /// The response status.
        public var httpStatus: Swift.Int?
        /// The request URL.
        public var httpURL: Swift.String?
        /// The request's user agent string.
        public var userAgent: Swift.String?

        public init(
            clientIp: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            httpStatus: Swift.Int? = nil,
            httpURL: Swift.String? = nil,
            userAgent: Swift.String? = nil
        )
        {
            self.clientIp = clientIp
            self.httpMethod = httpMethod
            self.httpStatus = httpStatus
            self.httpURL = httpURL
            self.userAgent = userAgent
        }
    }

}

extension XRayClientTypes.Insight: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categories = "Categories"
        case clientRequestImpactStatistics = "ClientRequestImpactStatistics"
        case endTime = "EndTime"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case insightId = "InsightId"
        case rootCauseServiceId = "RootCauseServiceId"
        case rootCauseServiceRequestImpactStatistics = "RootCauseServiceRequestImpactStatistics"
        case startTime = "StartTime"
        case state = "State"
        case summary = "Summary"
        case topAnomalousServices = "TopAnomalousServices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categories = categories {
            var categoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categories)
            for insightcategory0 in categories {
                try categoriesContainer.encode(insightcategory0.rawValue)
            }
        }
        if let clientRequestImpactStatistics = self.clientRequestImpactStatistics {
            try encodeContainer.encode(clientRequestImpactStatistics, forKey: .clientRequestImpactStatistics)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let groupARN = self.groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let insightId = self.insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let rootCauseServiceId = self.rootCauseServiceId {
            try encodeContainer.encode(rootCauseServiceId, forKey: .rootCauseServiceId)
        }
        if let rootCauseServiceRequestImpactStatistics = self.rootCauseServiceRequestImpactStatistics {
            try encodeContainer.encode(rootCauseServiceRequestImpactStatistics, forKey: .rootCauseServiceRequestImpactStatistics)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let topAnomalousServices = topAnomalousServices {
            var topAnomalousServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topAnomalousServices)
            for anomalousservice0 in topAnomalousServices {
                try topAnomalousServicesContainer.encode(anomalousservice0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let rootCauseServiceIdDecoded = try containerValues.decodeIfPresent(XRayClientTypes.ServiceId.self, forKey: .rootCauseServiceId)
        rootCauseServiceId = rootCauseServiceIdDecoded
        let categoriesContainer = try containerValues.decodeIfPresent([XRayClientTypes.InsightCategory?].self, forKey: .categories)
        var categoriesDecoded0:[XRayClientTypes.InsightCategory]? = nil
        if let categoriesContainer = categoriesContainer {
            categoriesDecoded0 = [XRayClientTypes.InsightCategory]()
            for enum0 in categoriesContainer {
                if let enum0 = enum0 {
                    categoriesDecoded0?.append(enum0)
                }
            }
        }
        categories = categoriesDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(XRayClientTypes.InsightState.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .summary)
        summary = summaryDecoded
        let clientRequestImpactStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.RequestImpactStatistics.self, forKey: .clientRequestImpactStatistics)
        clientRequestImpactStatistics = clientRequestImpactStatisticsDecoded
        let rootCauseServiceRequestImpactStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.RequestImpactStatistics.self, forKey: .rootCauseServiceRequestImpactStatistics)
        rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatisticsDecoded
        let topAnomalousServicesContainer = try containerValues.decodeIfPresent([XRayClientTypes.AnomalousService?].self, forKey: .topAnomalousServices)
        var topAnomalousServicesDecoded0:[XRayClientTypes.AnomalousService]? = nil
        if let topAnomalousServicesContainer = topAnomalousServicesContainer {
            topAnomalousServicesDecoded0 = [XRayClientTypes.AnomalousService]()
            for structure0 in topAnomalousServicesContainer {
                if let structure0 = structure0 {
                    topAnomalousServicesDecoded0?.append(structure0)
                }
            }
        }
        topAnomalousServices = topAnomalousServicesDecoded0
    }
}

extension XRayClientTypes {
    /// When fault rates go outside of the expected range, X-Ray creates an insight. Insights tracks emergent issues within your applications.
    public struct Insight: Swift.Equatable {
        /// The categories that label and describe the type of insight.
        public var categories: [XRayClientTypes.InsightCategory]?
        /// The impact statistics of the client side service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public var clientRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight ended.
        public var endTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the group that the insight belongs to.
        public var groupARN: Swift.String?
        /// The name of the group that the insight belongs to.
        public var groupName: Swift.String?
        /// The insights unique identifier.
        public var insightId: Swift.String?
        ///
        public var rootCauseServiceId: XRayClientTypes.ServiceId?
        /// The impact statistics of the root cause service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public var rootCauseServiceRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight began.
        public var startTime: ClientRuntime.Date?
        /// The current state of the insight.
        public var state: XRayClientTypes.InsightState?
        /// A brief description of the insight.
        public var summary: Swift.String?
        /// The service within the insight that is most impacted by the incident.
        public var topAnomalousServices: [XRayClientTypes.AnomalousService]?

        public init(
            categories: [XRayClientTypes.InsightCategory]? = nil,
            clientRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics? = nil,
            endTime: ClientRuntime.Date? = nil,
            groupARN: Swift.String? = nil,
            groupName: Swift.String? = nil,
            insightId: Swift.String? = nil,
            rootCauseServiceId: XRayClientTypes.ServiceId? = nil,
            rootCauseServiceRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: XRayClientTypes.InsightState? = nil,
            summary: Swift.String? = nil,
            topAnomalousServices: [XRayClientTypes.AnomalousService]? = nil
        )
        {
            self.categories = categories
            self.clientRequestImpactStatistics = clientRequestImpactStatistics
            self.endTime = endTime
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightId = insightId
            self.rootCauseServiceId = rootCauseServiceId
            self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
            self.startTime = startTime
            self.state = state
            self.summary = summary
            self.topAnomalousServices = topAnomalousServices
        }
    }

}

extension XRayClientTypes {
    public enum InsightCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fault
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightCategory] {
            return [
                .fault,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fault: return "FAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InsightCategory(rawValue: rawValue) ?? InsightCategory.sdkUnknown(rawValue)
        }
    }
}

extension XRayClientTypes.InsightEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestImpactStatistics = "ClientRequestImpactStatistics"
        case eventTime = "EventTime"
        case rootCauseServiceRequestImpactStatistics = "RootCauseServiceRequestImpactStatistics"
        case summary = "Summary"
        case topAnomalousServices = "TopAnomalousServices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestImpactStatistics = self.clientRequestImpactStatistics {
            try encodeContainer.encode(clientRequestImpactStatistics, forKey: .clientRequestImpactStatistics)
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .epochSeconds, forKey: .eventTime)
        }
        if let rootCauseServiceRequestImpactStatistics = self.rootCauseServiceRequestImpactStatistics {
            try encodeContainer.encode(rootCauseServiceRequestImpactStatistics, forKey: .rootCauseServiceRequestImpactStatistics)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let topAnomalousServices = topAnomalousServices {
            var topAnomalousServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topAnomalousServices)
            for anomalousservice0 in topAnomalousServices {
                try topAnomalousServicesContainer.encode(anomalousservice0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .summary)
        summary = summaryDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let clientRequestImpactStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.RequestImpactStatistics.self, forKey: .clientRequestImpactStatistics)
        clientRequestImpactStatistics = clientRequestImpactStatisticsDecoded
        let rootCauseServiceRequestImpactStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.RequestImpactStatistics.self, forKey: .rootCauseServiceRequestImpactStatistics)
        rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatisticsDecoded
        let topAnomalousServicesContainer = try containerValues.decodeIfPresent([XRayClientTypes.AnomalousService?].self, forKey: .topAnomalousServices)
        var topAnomalousServicesDecoded0:[XRayClientTypes.AnomalousService]? = nil
        if let topAnomalousServicesContainer = topAnomalousServicesContainer {
            topAnomalousServicesDecoded0 = [XRayClientTypes.AnomalousService]()
            for structure0 in topAnomalousServicesContainer {
                if let structure0 = structure0 {
                    topAnomalousServicesDecoded0?.append(structure0)
                }
            }
        }
        topAnomalousServices = topAnomalousServicesDecoded0
    }
}

extension XRayClientTypes {
    /// X-Ray reevaluates insights periodically until they are resolved, and records each intermediate state in an event. You can review incident events in the Impact Timeline on the Inspect page in the X-Ray console.
    public struct InsightEvent: Swift.Equatable {
        /// The impact statistics of the client side service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public var clientRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics?
        /// The time, in Unix seconds, at which the event was recorded.
        public var eventTime: ClientRuntime.Date?
        /// The impact statistics of the root cause service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public var rootCauseServiceRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics?
        /// A brief description of the event.
        public var summary: Swift.String?
        /// The service during the event that is most impacted by the incident.
        public var topAnomalousServices: [XRayClientTypes.AnomalousService]?

        public init(
            clientRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics? = nil,
            eventTime: ClientRuntime.Date? = nil,
            rootCauseServiceRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics? = nil,
            summary: Swift.String? = nil,
            topAnomalousServices: [XRayClientTypes.AnomalousService]? = nil
        )
        {
            self.clientRequestImpactStatistics = clientRequestImpactStatistics
            self.eventTime = eventTime
            self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
            self.summary = summary
            self.topAnomalousServices = topAnomalousServices
        }
    }

}

extension XRayClientTypes.InsightImpactGraphEdge: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case referenceId = "ReferenceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
    }
}

extension XRayClientTypes {
    /// The connection between two service in an insight impact graph.
    public struct InsightImpactGraphEdge: Swift.Equatable {
        /// Identifier of the edge. Unique within a service map.
        public var referenceId: Swift.Int?

        public init(
            referenceId: Swift.Int? = nil
        )
        {
            self.referenceId = referenceId
        }
    }

}

extension XRayClientTypes.InsightImpactGraphService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case edges = "Edges"
        case name = "Name"
        case names = "Names"
        case referenceId = "ReferenceId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let edges = edges {
            var edgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edges)
            for insightimpactgraphedge0 in edges {
                try edgesContainer.encode(insightimpactgraphedge0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for string0 in names {
                try namesContainer.encode(string0)
            }
        }
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let edgesContainer = try containerValues.decodeIfPresent([XRayClientTypes.InsightImpactGraphEdge?].self, forKey: .edges)
        var edgesDecoded0:[XRayClientTypes.InsightImpactGraphEdge]? = nil
        if let edgesContainer = edgesContainer {
            edgesDecoded0 = [XRayClientTypes.InsightImpactGraphEdge]()
            for structure0 in edgesContainer {
                if let structure0 = structure0 {
                    edgesDecoded0?.append(structure0)
                }
            }
        }
        edges = edgesDecoded0
    }
}

extension XRayClientTypes {
    /// Information about an application that processed requests, users that made requests, or downstream services, resources, and applications that an application used.
    public struct InsightImpactGraphService: Swift.Equatable {
        /// Identifier of the Amazon Web Services account in which the service runs.
        public var accountId: Swift.String?
        /// Connections to downstream services.
        public var edges: [XRayClientTypes.InsightImpactGraphEdge]?
        /// The canonical name of the service.
        public var name: Swift.String?
        /// A list of names for the service, including the canonical name.
        public var names: [Swift.String]?
        /// Identifier for the service. Unique within the service map.
        public var referenceId: Swift.Int?
        /// Identifier for the service. Unique within the service map.
        ///
        /// * Amazon Web Services Resource - The type of an Amazon Web Services resource. For example, AWS::EC2::Instance for an application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.
        ///
        /// * Amazon Web Services Service - The type of an Amazon Web Services service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.
        ///
        /// * Amazon Web Services Service - The type of an Amazon Web Services service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.
        ///
        /// * remote - A downstream service of indeterminate type.
        public var type: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            edges: [XRayClientTypes.InsightImpactGraphEdge]? = nil,
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            referenceId: Swift.Int? = nil,
            type: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.edges = edges
            self.name = name
            self.names = names
            self.referenceId = referenceId
            self.type = type
        }
    }

}

extension XRayClientTypes {
    public enum InsightState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case closed
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightState] {
            return [
                .active,
                .closed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .closed: return "CLOSED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InsightState(rawValue: rawValue) ?? InsightState.sdkUnknown(rawValue)
        }
    }
}

extension XRayClientTypes.InsightSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categories = "Categories"
        case clientRequestImpactStatistics = "ClientRequestImpactStatistics"
        case endTime = "EndTime"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case insightId = "InsightId"
        case lastUpdateTime = "LastUpdateTime"
        case rootCauseServiceId = "RootCauseServiceId"
        case rootCauseServiceRequestImpactStatistics = "RootCauseServiceRequestImpactStatistics"
        case startTime = "StartTime"
        case state = "State"
        case summary = "Summary"
        case topAnomalousServices = "TopAnomalousServices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categories = categories {
            var categoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categories)
            for insightcategory0 in categories {
                try categoriesContainer.encode(insightcategory0.rawValue)
            }
        }
        if let clientRequestImpactStatistics = self.clientRequestImpactStatistics {
            try encodeContainer.encode(clientRequestImpactStatistics, forKey: .clientRequestImpactStatistics)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let groupARN = self.groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let insightId = self.insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let rootCauseServiceId = self.rootCauseServiceId {
            try encodeContainer.encode(rootCauseServiceId, forKey: .rootCauseServiceId)
        }
        if let rootCauseServiceRequestImpactStatistics = self.rootCauseServiceRequestImpactStatistics {
            try encodeContainer.encode(rootCauseServiceRequestImpactStatistics, forKey: .rootCauseServiceRequestImpactStatistics)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let topAnomalousServices = topAnomalousServices {
            var topAnomalousServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topAnomalousServices)
            for anomalousservice0 in topAnomalousServices {
                try topAnomalousServicesContainer.encode(anomalousservice0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let rootCauseServiceIdDecoded = try containerValues.decodeIfPresent(XRayClientTypes.ServiceId.self, forKey: .rootCauseServiceId)
        rootCauseServiceId = rootCauseServiceIdDecoded
        let categoriesContainer = try containerValues.decodeIfPresent([XRayClientTypes.InsightCategory?].self, forKey: .categories)
        var categoriesDecoded0:[XRayClientTypes.InsightCategory]? = nil
        if let categoriesContainer = categoriesContainer {
            categoriesDecoded0 = [XRayClientTypes.InsightCategory]()
            for enum0 in categoriesContainer {
                if let enum0 = enum0 {
                    categoriesDecoded0?.append(enum0)
                }
            }
        }
        categories = categoriesDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(XRayClientTypes.InsightState.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .summary)
        summary = summaryDecoded
        let clientRequestImpactStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.RequestImpactStatistics.self, forKey: .clientRequestImpactStatistics)
        clientRequestImpactStatistics = clientRequestImpactStatisticsDecoded
        let rootCauseServiceRequestImpactStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.RequestImpactStatistics.self, forKey: .rootCauseServiceRequestImpactStatistics)
        rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatisticsDecoded
        let topAnomalousServicesContainer = try containerValues.decodeIfPresent([XRayClientTypes.AnomalousService?].self, forKey: .topAnomalousServices)
        var topAnomalousServicesDecoded0:[XRayClientTypes.AnomalousService]? = nil
        if let topAnomalousServicesContainer = topAnomalousServicesContainer {
            topAnomalousServicesDecoded0 = [XRayClientTypes.AnomalousService]()
            for structure0 in topAnomalousServicesContainer {
                if let structure0 = structure0 {
                    topAnomalousServicesDecoded0?.append(structure0)
                }
            }
        }
        topAnomalousServices = topAnomalousServicesDecoded0
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension XRayClientTypes {
    /// Information that describes an insight.
    public struct InsightSummary: Swift.Equatable {
        /// Categories The categories that label and describe the type of insight.
        public var categories: [XRayClientTypes.InsightCategory]?
        /// The impact statistics of the client side service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public var clientRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight ended.
        public var endTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the group that the insight belongs to.
        public var groupARN: Swift.String?
        /// The name of the group that the insight belongs to.
        public var groupName: Swift.String?
        /// The insights unique identifier.
        public var insightId: Swift.String?
        /// The time, in Unix seconds, that the insight was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        ///
        public var rootCauseServiceId: XRayClientTypes.ServiceId?
        /// The impact statistics of the root cause service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public var rootCauseServiceRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight began.
        public var startTime: ClientRuntime.Date?
        /// The current state of the insight.
        public var state: XRayClientTypes.InsightState?
        /// A brief description of the insight.
        public var summary: Swift.String?
        /// The service within the insight that is most impacted by the incident.
        public var topAnomalousServices: [XRayClientTypes.AnomalousService]?

        public init(
            categories: [XRayClientTypes.InsightCategory]? = nil,
            clientRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics? = nil,
            endTime: ClientRuntime.Date? = nil,
            groupARN: Swift.String? = nil,
            groupName: Swift.String? = nil,
            insightId: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            rootCauseServiceId: XRayClientTypes.ServiceId? = nil,
            rootCauseServiceRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: XRayClientTypes.InsightState? = nil,
            summary: Swift.String? = nil,
            topAnomalousServices: [XRayClientTypes.AnomalousService]? = nil
        )
        {
            self.categories = categories
            self.clientRequestImpactStatistics = clientRequestImpactStatistics
            self.endTime = endTime
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightId = insightId
            self.lastUpdateTime = lastUpdateTime
            self.rootCauseServiceId = rootCauseServiceId
            self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
            self.startTime = startTime
            self.state = state
            self.summary = summary
            self.topAnomalousServices = topAnomalousServices
        }
    }

}

extension XRayClientTypes.InsightsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightsEnabled = "InsightsEnabled"
        case notificationsEnabled = "NotificationsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightsEnabled = self.insightsEnabled {
            try encodeContainer.encode(insightsEnabled, forKey: .insightsEnabled)
        }
        if let notificationsEnabled = self.notificationsEnabled {
            try encodeContainer.encode(notificationsEnabled, forKey: .notificationsEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .insightsEnabled)
        insightsEnabled = insightsEnabledDecoded
        let notificationsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notificationsEnabled)
        notificationsEnabled = notificationsEnabledDecoded
    }
}

extension XRayClientTypes {
    /// The structure containing configurations related to insights.
    public struct InsightsConfiguration: Swift.Equatable {
        /// Set the InsightsEnabled value to true to enable insights or false to disable insights.
        public var insightsEnabled: Swift.Bool?
        /// Set the NotificationsEnabled value to true to enable insights notifications. Notifications can only be enabled on a group with InsightsEnabled set to true.
        public var notificationsEnabled: Swift.Bool?

        public init(
            insightsEnabled: Swift.Bool? = nil,
            notificationsEnabled: Swift.Bool? = nil
        )
        {
            self.insightsEnabled = insightsEnabled
            self.notificationsEnabled = notificationsEnabled
        }
    }

}

extension XRayClientTypes.InstanceIdDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension XRayClientTypes {
    /// A list of EC2 instance IDs corresponding to the segments in a trace.
    public struct InstanceIdDetail: Swift.Equatable {
        /// The ID of a corresponding EC2 instance.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension InvalidPolicyRevisionIdException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPolicyRevisionIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A policy revision id was provided which does not match the latest policy revision. This exception is also if a policy revision id of 0 is provided via PutResourcePolicy and a policy with the same name already exists.
public struct InvalidPolicyRevisionIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPolicyRevisionIdException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPolicyRevisionIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPolicyRevisionIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is missing required parameters or has invalid parameters.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListResourcePoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResourcePoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListResourcePolicies"
    }
}

public struct ListResourcePoliciesInput: Swift.Equatable {
    /// Not currently supported.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListResourcePoliciesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListResourcePoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourcePoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourcePoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourcePolicies = output.resourcePolicies
        } else {
            self.nextToken = nil
            self.resourcePolicies = nil
        }
    }
}

public struct ListResourcePoliciesOutput: Swift.Equatable {
    /// Pagination token. Not currently supported.
    public var nextToken: Swift.String?
    /// The list of resource policies in the target Amazon Web Services account.
    public var resourcePolicies: [XRayClientTypes.ResourcePolicy]?

    public init(
        nextToken: Swift.String? = nil,
        resourcePolicies: [XRayClientTypes.ResourcePolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourcePolicies = resourcePolicies
    }
}

struct ListResourcePoliciesOutputBody: Swift.Equatable {
    let resourcePolicies: [XRayClientTypes.ResourcePolicy]?
    let nextToken: Swift.String?
}

extension ListResourcePoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourcePolicies = "ResourcePolicies"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcePoliciesContainer = try containerValues.decodeIfPresent([XRayClientTypes.ResourcePolicy?].self, forKey: .resourcePolicies)
        var resourcePoliciesDecoded0:[XRayClientTypes.ResourcePolicy]? = nil
        if let resourcePoliciesContainer = resourcePoliciesContainer {
            resourcePoliciesDecoded0 = [XRayClientTypes.ResourcePolicy]()
            for structure0 in resourcePoliciesContainer {
                if let structure0 = structure0 {
                    resourcePoliciesDecoded0?.append(structure0)
                }
            }
        }
        resourcePolicies = resourcePoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResourcePoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListTagsForResource"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// A pagination token. If multiple pages of results are returned, use the NextToken value returned with the current page of results as the value of this parameter to get the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A pagination token. If multiple pages of results are returned, use the NextToken value returned with the current page of results to get the next page of results.
    public var nextToken: Swift.String?
    /// A list of tags, as key and value pairs, that is associated with the specified X-Ray group or sampling rule.
    public var tags: [XRayClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [XRayClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [XRayClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([XRayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[XRayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [XRayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LockoutPreventionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LockoutPreventionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The provided resource policy would prevent the caller of this request from calling PutResourcePolicy in the future.
public struct LockoutPreventionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LockoutPreventionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LockoutPreventionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LockoutPreventionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MalformedPolicyDocumentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MalformedPolicyDocumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Invalid policy document provided in request.
public struct MalformedPolicyDocumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedPolicyDocumentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MalformedPolicyDocumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MalformedPolicyDocumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PolicyCountLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PolicyCountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exceeded the maximum number of resource policies for a target Amazon Web Services account.
public struct PolicyCountLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyCountLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PolicyCountLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PolicyCountLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PolicySizeLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PolicySizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exceeded the maximum size for a resource policy.
public struct PolicySizeLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicySizeLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PolicySizeLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PolicySizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutEncryptionConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyId = "KeyId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = self.keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension PutEncryptionConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutEncryptionConfig"
    }
}

public struct PutEncryptionConfigInput: Swift.Equatable {
    /// An Amazon Web Services KMS key in one of the following formats:
    ///
    /// * Alias - The name of the key. For example, alias/MyKey.
    ///
    /// * Key ID - The KMS key ID of the key. For example, ae4aa6d49-a4d8-9df9-a475-4ff6d7898456. Amazon Web Services X-Ray does not support asymmetric KMS keys.
    ///
    /// * ARN - The full Amazon Resource Name of the key ID or alias. For example, arn:aws:kms:us-east-2:123456789012:key/ae4aa6d49-a4d8-9df9-a475-4ff6d7898456. Use this format to specify a key in a different account.
    ///
    ///
    /// Omit this key if you set Type to NONE.
    public var keyId: Swift.String?
    /// The type of encryption. Set to KMS to use your own key for encryption. Set to NONE for default encryption.
    /// This member is required.
    public var type: XRayClientTypes.EncryptionType?

    public init(
        keyId: Swift.String? = nil,
        type: XRayClientTypes.EncryptionType? = nil
    )
    {
        self.keyId = keyId
        self.type = type
    }
}

struct PutEncryptionConfigInputBody: Swift.Equatable {
    let keyId: Swift.String?
    let type: XRayClientTypes.EncryptionType?
}

extension PutEncryptionConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyId = "KeyId"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(XRayClientTypes.EncryptionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension PutEncryptionConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutEncryptionConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.encryptionConfig = output.encryptionConfig
        } else {
            self.encryptionConfig = nil
        }
    }
}

public struct PutEncryptionConfigOutput: Swift.Equatable {
    /// The new encryption configuration.
    public var encryptionConfig: XRayClientTypes.EncryptionConfig?

    public init(
        encryptionConfig: XRayClientTypes.EncryptionConfig? = nil
    )
    {
        self.encryptionConfig = encryptionConfig
    }
}

struct PutEncryptionConfigOutputBody: Swift.Equatable {
    let encryptionConfig: XRayClientTypes.EncryptionConfig?
}

extension PutEncryptionConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfig = "EncryptionConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(XRayClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

enum PutEncryptionConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassPolicyLockoutCheck = "BypassPolicyLockoutCheck"
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case policyRevisionId = "PolicyRevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bypassPolicyLockoutCheck = self.bypassPolicyLockoutCheck {
            try encodeContainer.encode(bypassPolicyLockoutCheck, forKey: .bypassPolicyLockoutCheck)
        }
        if let policyDocument = self.policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyRevisionId = self.policyRevisionId {
            try encodeContainer.encode(policyRevisionId, forKey: .policyRevisionId)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutResourcePolicy"
    }
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// A flag to indicate whether to bypass the resource policy lockout safety check. Setting this value to true increases the risk that the policy becomes unmanageable. Do not set this value to true indiscriminately. Use this parameter only when you include a policy in the request and you intend to prevent the principal that is making the request from making a subsequent PutResourcePolicy request. The default value is false.
    public var bypassPolicyLockoutCheck: Swift.Bool?
    /// The resource policy document, which can be up to 5kb in size.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the resource policy. Must be unique within a specific Amazon Web Services account.
    /// This member is required.
    public var policyName: Swift.String?
    /// Specifies a specific policy revision, to ensure an atomic create operation. By default the resource policy is created if it does not exist, or updated with an incremented revision id. The revision id is unique to each policy in the account. If the policy revision id does not match the latest revision id, the operation will fail with an InvalidPolicyRevisionIdException exception. You can also provide a PolicyRevisionId of 0. In this case, the operation will fail with an InvalidPolicyRevisionIdException exception if a resource policy with the same name already exists.
    public var policyRevisionId: Swift.String?

    public init(
        bypassPolicyLockoutCheck: Swift.Bool? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        policyRevisionId: Swift.String? = nil
    )
    {
        self.bypassPolicyLockoutCheck = bypassPolicyLockoutCheck
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.policyRevisionId = policyRevisionId
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let policyName: Swift.String?
    let policyDocument: Swift.String?
    let policyRevisionId: Swift.String?
    let bypassPolicyLockoutCheck: Swift.Bool?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassPolicyLockoutCheck = "BypassPolicyLockoutCheck"
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case policyRevisionId = "PolicyRevisionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let policyRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyRevisionId)
        policyRevisionId = policyRevisionIdDecoded
        let bypassPolicyLockoutCheckDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bypassPolicyLockoutCheck)
        bypassPolicyLockoutCheck = bypassPolicyLockoutCheckDecoded
    }
}

extension PutResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourcePolicy = output.resourcePolicy
        } else {
            self.resourcePolicy = nil
        }
    }
}

public struct PutResourcePolicyOutput: Swift.Equatable {
    /// The resource policy document, as provided in the PutResourcePolicyRequest.
    public var resourcePolicy: XRayClientTypes.ResourcePolicy?

    public init(
        resourcePolicy: XRayClientTypes.ResourcePolicy? = nil
    )
    {
        self.resourcePolicy = resourcePolicy
    }
}

struct PutResourcePolicyOutputBody: Swift.Equatable {
    let resourcePolicy: XRayClientTypes.ResourcePolicy?
}

extension PutResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePolicy = "ResourcePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(XRayClientTypes.ResourcePolicy.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

enum PutResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidPolicyRevisionIdException": return try await InvalidPolicyRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LockoutPreventionException": return try await LockoutPreventionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MalformedPolicyDocumentException": return try await MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyCountLimitExceededException": return try await PolicyCountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicySizeLimitExceededException": return try await PolicySizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutTelemetryRecordsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceId = "EC2InstanceId"
        case hostname = "Hostname"
        case resourceARN = "ResourceARN"
        case telemetryRecords = "TelemetryRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceId = self.ec2InstanceId {
            try encodeContainer.encode(ec2InstanceId, forKey: .ec2InstanceId)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let telemetryRecords = telemetryRecords {
            var telemetryRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .telemetryRecords)
            for telemetryrecord0 in telemetryRecords {
                try telemetryRecordsContainer.encode(telemetryrecord0)
            }
        }
    }
}

extension PutTelemetryRecordsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TelemetryRecords"
    }
}

public struct PutTelemetryRecordsInput: Swift.Equatable {
    ///
    public var ec2InstanceId: Swift.String?
    ///
    public var hostname: Swift.String?
    ///
    public var resourceARN: Swift.String?
    ///
    /// This member is required.
    public var telemetryRecords: [XRayClientTypes.TelemetryRecord]?

    public init(
        ec2InstanceId: Swift.String? = nil,
        hostname: Swift.String? = nil,
        resourceARN: Swift.String? = nil,
        telemetryRecords: [XRayClientTypes.TelemetryRecord]? = nil
    )
    {
        self.ec2InstanceId = ec2InstanceId
        self.hostname = hostname
        self.resourceARN = resourceARN
        self.telemetryRecords = telemetryRecords
    }
}

struct PutTelemetryRecordsInputBody: Swift.Equatable {
    let telemetryRecords: [XRayClientTypes.TelemetryRecord]?
    let ec2InstanceId: Swift.String?
    let hostname: Swift.String?
    let resourceARN: Swift.String?
}

extension PutTelemetryRecordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceId = "EC2InstanceId"
        case hostname = "Hostname"
        case resourceARN = "ResourceARN"
        case telemetryRecords = "TelemetryRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryRecordsContainer = try containerValues.decodeIfPresent([XRayClientTypes.TelemetryRecord?].self, forKey: .telemetryRecords)
        var telemetryRecordsDecoded0:[XRayClientTypes.TelemetryRecord]? = nil
        if let telemetryRecordsContainer = telemetryRecordsContainer {
            telemetryRecordsDecoded0 = [XRayClientTypes.TelemetryRecord]()
            for structure0 in telemetryRecordsContainer {
                if let structure0 = structure0 {
                    telemetryRecordsDecoded0?.append(structure0)
                }
            }
        }
        telemetryRecords = telemetryRecordsDecoded0
        let ec2InstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceId)
        ec2InstanceId = ec2InstanceIdDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension PutTelemetryRecordsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutTelemetryRecordsOutput: Swift.Equatable {

    public init() { }
}

enum PutTelemetryRecordsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutTraceSegmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case traceSegmentDocuments = "TraceSegmentDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let traceSegmentDocuments = traceSegmentDocuments {
            var traceSegmentDocumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traceSegmentDocuments)
            for tracesegmentdocument0 in traceSegmentDocuments {
                try traceSegmentDocumentsContainer.encode(tracesegmentdocument0)
            }
        }
    }
}

extension PutTraceSegmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TraceSegments"
    }
}

public struct PutTraceSegmentsInput: Swift.Equatable {
    /// A string containing a JSON document defining one or more segments or subsegments.
    /// This member is required.
    public var traceSegmentDocuments: [Swift.String]?

    public init(
        traceSegmentDocuments: [Swift.String]? = nil
    )
    {
        self.traceSegmentDocuments = traceSegmentDocuments
    }
}

struct PutTraceSegmentsInputBody: Swift.Equatable {
    let traceSegmentDocuments: [Swift.String]?
}

extension PutTraceSegmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case traceSegmentDocuments = "TraceSegmentDocuments"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceSegmentDocumentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .traceSegmentDocuments)
        var traceSegmentDocumentsDecoded0:[Swift.String]? = nil
        if let traceSegmentDocumentsContainer = traceSegmentDocumentsContainer {
            traceSegmentDocumentsDecoded0 = [Swift.String]()
            for string0 in traceSegmentDocumentsContainer {
                if let string0 = string0 {
                    traceSegmentDocumentsDecoded0?.append(string0)
                }
            }
        }
        traceSegmentDocuments = traceSegmentDocumentsDecoded0
    }
}

extension PutTraceSegmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutTraceSegmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedTraceSegments = output.unprocessedTraceSegments
        } else {
            self.unprocessedTraceSegments = nil
        }
    }
}

public struct PutTraceSegmentsOutput: Swift.Equatable {
    /// Segments that failed processing.
    public var unprocessedTraceSegments: [XRayClientTypes.UnprocessedTraceSegment]?

    public init(
        unprocessedTraceSegments: [XRayClientTypes.UnprocessedTraceSegment]? = nil
    )
    {
        self.unprocessedTraceSegments = unprocessedTraceSegments
    }
}

struct PutTraceSegmentsOutputBody: Swift.Equatable {
    let unprocessedTraceSegments: [XRayClientTypes.UnprocessedTraceSegment]?
}

extension PutTraceSegmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedTraceSegments = "UnprocessedTraceSegments"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedTraceSegmentsContainer = try containerValues.decodeIfPresent([XRayClientTypes.UnprocessedTraceSegment?].self, forKey: .unprocessedTraceSegments)
        var unprocessedTraceSegmentsDecoded0:[XRayClientTypes.UnprocessedTraceSegment]? = nil
        if let unprocessedTraceSegmentsContainer = unprocessedTraceSegmentsContainer {
            unprocessedTraceSegmentsDecoded0 = [XRayClientTypes.UnprocessedTraceSegment]()
            for structure0 in unprocessedTraceSegmentsContainer {
                if let structure0 = structure0 {
                    unprocessedTraceSegmentsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedTraceSegments = unprocessedTraceSegmentsDecoded0
    }
}

enum PutTraceSegmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension XRayClientTypes.RequestImpactStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case faultCount = "FaultCount"
        case okCount = "OkCount"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let faultCount = self.faultCount {
            try encodeContainer.encode(faultCount, forKey: .faultCount)
        }
        if let okCount = self.okCount {
            try encodeContainer.encode(okCount, forKey: .okCount)
        }
        if let totalCount = self.totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let faultCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .faultCount)
        faultCount = faultCountDecoded
        let okCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .okCount)
        okCount = okCountDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension XRayClientTypes {
    /// Statistics that describe how the incident has impacted a service.
    public struct RequestImpactStatistics: Swift.Equatable {
        /// The number of requests that have resulted in a fault,
        public var faultCount: Swift.Int?
        /// The number of successful requests.
        public var okCount: Swift.Int?
        /// The total number of requests to the service.
        public var totalCount: Swift.Int?

        public init(
            faultCount: Swift.Int? = nil,
            okCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil
        )
        {
            self.faultCount = faultCount
            self.okCount = okCount
            self.totalCount = totalCount
        }
    }

}

extension XRayClientTypes.ResourceARNDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension XRayClientTypes {
    /// A list of resources ARNs corresponding to the segments in a trace.
    public struct ResourceARNDetail: Swift.Equatable {
        /// The ARN of a corresponding resource.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource was not found. Verify that the name or Amazon Resource Name (ARN) of the resource is correct.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension XRayClientTypes.ResourcePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUpdatedTime = "LastUpdatedTime"
        case policyDocument = "PolicyDocument"
        case policyName = "PolicyName"
        case policyRevisionId = "PolicyRevisionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let policyDocument = self.policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyRevisionId = self.policyRevisionId {
            try encodeContainer.encode(policyRevisionId, forKey: .policyRevisionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let policyRevisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyRevisionId)
        policyRevisionId = policyRevisionIdDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension XRayClientTypes {
    /// A resource policy grants one or more Amazon Web Services services and accounts permissions to access X-Ray. Each resource policy is associated with a specific Amazon Web Services account.
    public struct ResourcePolicy: Swift.Equatable {
        /// When the policy was last updated, in Unix time seconds.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The resource policy document, which can be up to 5kb in size.
        public var policyDocument: Swift.String?
        /// The name of the resource policy. Must be unique within a specific Amazon Web Services account.
        public var policyName: Swift.String?
        /// Returns the current policy revision id for this policy name.
        public var policyRevisionId: Swift.String?

        public init(
            lastUpdatedTime: ClientRuntime.Date? = nil,
            policyDocument: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyRevisionId: Swift.String? = nil
        )
        {
            self.lastUpdatedTime = lastUpdatedTime
            self.policyDocument = policyDocument
            self.policyName = policyName
            self.policyRevisionId = policyRevisionId
        }
    }

}

extension XRayClientTypes.ResponseTimeRootCause: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientImpacting = "ClientImpacting"
        case services = "Services"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientImpacting = self.clientImpacting {
            try encodeContainer.encode(clientImpacting, forKey: .clientImpacting)
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for responsetimerootcauseservice0 in services {
                try servicesContainer.encode(responsetimerootcauseservice0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([XRayClientTypes.ResponseTimeRootCauseService?].self, forKey: .services)
        var servicesDecoded0:[XRayClientTypes.ResponseTimeRootCauseService]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [XRayClientTypes.ResponseTimeRootCauseService]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let clientImpactingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clientImpacting)
        clientImpacting = clientImpactingDecoded
    }
}

extension XRayClientTypes {
    /// The root cause information for a response time warning.
    public struct ResponseTimeRootCause: Swift.Equatable {
        /// A flag that denotes that the root cause impacts the trace client.
        public var clientImpacting: Swift.Bool?
        /// A list of corresponding services. A service identifies a segment and contains a name, account ID, type, and inferred flag.
        public var services: [XRayClientTypes.ResponseTimeRootCauseService]?

        public init(
            clientImpacting: Swift.Bool? = nil,
            services: [XRayClientTypes.ResponseTimeRootCauseService]? = nil
        )
        {
            self.clientImpacting = clientImpacting
            self.services = services
        }
    }

}

extension XRayClientTypes.ResponseTimeRootCauseEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coverage = "Coverage"
        case name = "Name"
        case remote = "Remote"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coverage = self.coverage {
            try encodeContainer.encode(coverage, forKey: .coverage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let remote = self.remote {
            try encodeContainer.encode(remote, forKey: .remote)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let coverageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .coverage)
        coverage = coverageDecoded
        let remoteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .remote)
        remote = remoteDecoded
    }
}

extension XRayClientTypes {
    /// A collection of segments and corresponding subsegments associated to a response time warning.
    public struct ResponseTimeRootCauseEntity: Swift.Equatable {
        /// The type and messages of the exceptions.
        public var coverage: Swift.Double?
        /// The name of the entity.
        public var name: Swift.String?
        /// A flag that denotes a remote subsegment.
        public var remote: Swift.Bool?

        public init(
            coverage: Swift.Double? = nil,
            name: Swift.String? = nil,
            remote: Swift.Bool? = nil
        )
        {
            self.coverage = coverage
            self.name = name
            self.remote = remote
        }
    }

}

extension XRayClientTypes.ResponseTimeRootCauseService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case entityPath = "EntityPath"
        case inferred = "Inferred"
        case name = "Name"
        case names = "Names"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let entityPath = entityPath {
            var entityPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityPath)
            for responsetimerootcauseentity0 in entityPath {
                try entityPathContainer.encode(responsetimerootcauseentity0)
            }
        }
        if let inferred = self.inferred {
            try encodeContainer.encode(inferred, forKey: .inferred)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for string0 in names {
                try namesContainer.encode(string0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let entityPathContainer = try containerValues.decodeIfPresent([XRayClientTypes.ResponseTimeRootCauseEntity?].self, forKey: .entityPath)
        var entityPathDecoded0:[XRayClientTypes.ResponseTimeRootCauseEntity]? = nil
        if let entityPathContainer = entityPathContainer {
            entityPathDecoded0 = [XRayClientTypes.ResponseTimeRootCauseEntity]()
            for structure0 in entityPathContainer {
                if let structure0 = structure0 {
                    entityPathDecoded0?.append(structure0)
                }
            }
        }
        entityPath = entityPathDecoded0
        let inferredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inferred)
        inferred = inferredDecoded
    }
}

extension XRayClientTypes {
    /// A collection of fields identifying the service in a response time warning.
    public struct ResponseTimeRootCauseService: Swift.Equatable {
        /// The account ID associated to the service.
        public var accountId: Swift.String?
        /// The path of root cause entities found on the service.
        public var entityPath: [XRayClientTypes.ResponseTimeRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public var inferred: Swift.Bool?
        /// The service name.
        public var name: Swift.String?
        /// A collection of associated service names.
        public var names: [Swift.String]?
        /// The type associated to the service.
        public var type: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            entityPath: [XRayClientTypes.ResponseTimeRootCauseEntity]? = nil,
            inferred: Swift.Bool? = nil,
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.type = type
        }
    }

}

extension XRayClientTypes.RootCauseException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension XRayClientTypes {
    /// The exception associated with a root cause.
    public struct RootCauseException: Swift.Equatable {
        /// The message of the exception.
        public var message: Swift.String?
        /// The name of the exception.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension RuleLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RuleLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the maximum number of sampling rules.
public struct RuleLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RuleLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RuleLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RuleLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension XRayClientTypes.SamplingRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case fixedRate = "FixedRate"
        case httpMethod = "HTTPMethod"
        case host = "Host"
        case priority = "Priority"
        case reservoirSize = "ReservoirSize"
        case resourceARN = "ResourceARN"
        case ruleARN = "RuleARN"
        case ruleName = "RuleName"
        case serviceName = "ServiceName"
        case serviceType = "ServiceType"
        case urlPath = "URLPath"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributeMap0) in attributes {
                try attributesContainer.encode(attributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if fixedRate != 0.0 {
            try encodeContainer.encode(fixedRate, forKey: .fixedRate)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if reservoirSize != 0 {
            try encodeContainer.encode(reservoirSize, forKey: .reservoirSize)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let ruleARN = self.ruleARN {
            try encodeContainer.encode(ruleARN, forKey: .ruleARN)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType, forKey: .serviceType)
        }
        if let urlPath = self.urlPath {
            try encodeContainer.encode(urlPath, forKey: .urlPath)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let ruleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleARN)
        ruleARN = ruleARNDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
        let fixedRateDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .fixedRate) ?? 0.0
        fixedRate = fixedRateDecoded
        let reservoirSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservoirSize) ?? 0
        reservoirSize = reservoirSizeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let urlPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .urlPath)
        urlPath = urlPathDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension XRayClientTypes {
    /// A sampling rule that services use to decide whether to instrument a request. Rule fields can match properties of the service, or properties of a request. The service can ignore rules that don't match its properties.
    public struct SamplingRule: Swift.Equatable {
        /// Matches attributes derived from the request.
        public var attributes: [Swift.String:Swift.String]?
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        /// This member is required.
        public var fixedRate: Swift.Double
        /// Matches the hostname from a request URL.
        /// This member is required.
        public var host: Swift.String?
        /// Matches the HTTP method of a request.
        /// This member is required.
        public var httpMethod: Swift.String?
        /// The priority of the sampling rule.
        /// This member is required.
        public var priority: Swift.Int
        /// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        /// This member is required.
        public var reservoirSize: Swift.Int
        /// Matches the ARN of the Amazon Web Services resource on which the service runs.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public var ruleARN: Swift.String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public var ruleName: Swift.String?
        /// Matches the name that the service uses to identify itself in segments.
        /// This member is required.
        public var serviceName: Swift.String?
        /// Matches the origin that the service uses to identify its type in segments.
        /// This member is required.
        public var serviceType: Swift.String?
        /// Matches the path from a request URL.
        /// This member is required.
        public var urlPath: Swift.String?
        /// The version of the sampling rule format (1).
        /// This member is required.
        public var version: Swift.Int

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            fixedRate: Swift.Double = 0.0,
            host: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            priority: Swift.Int = 0,
            reservoirSize: Swift.Int = 0,
            resourceARN: Swift.String? = nil,
            ruleARN: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceType: Swift.String? = nil,
            urlPath: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.attributes = attributes
            self.fixedRate = fixedRate
            self.host = host
            self.httpMethod = httpMethod
            self.priority = priority
            self.reservoirSize = reservoirSize
            self.resourceARN = resourceARN
            self.ruleARN = ruleARN
            self.ruleName = ruleName
            self.serviceName = serviceName
            self.serviceType = serviceType
            self.urlPath = urlPath
            self.version = version
        }
    }

}

extension XRayClientTypes.SamplingRuleRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case modifiedAt = "ModifiedAt"
        case samplingRule = "SamplingRule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .epochSeconds, forKey: .modifiedAt)
        }
        if let samplingRule = self.samplingRule {
            try encodeContainer.encode(samplingRule, forKey: .samplingRule)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleDecoded = try containerValues.decodeIfPresent(XRayClientTypes.SamplingRule.self, forKey: .samplingRule)
        samplingRule = samplingRuleDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

extension XRayClientTypes {
    /// A [SamplingRule](https://docs.aws.amazon.com/xray/latest/api/API_SamplingRule.html) and its metadata.
    public struct SamplingRuleRecord: Swift.Equatable {
        /// When the rule was created.
        public var createdAt: ClientRuntime.Date?
        /// When the rule was last modified.
        public var modifiedAt: ClientRuntime.Date?
        /// The sampling rule.
        public var samplingRule: XRayClientTypes.SamplingRule?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            samplingRule: XRayClientTypes.SamplingRule? = nil
        )
        {
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.samplingRule = samplingRule
        }
    }

}

extension XRayClientTypes.SamplingRuleUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case fixedRate = "FixedRate"
        case httpMethod = "HTTPMethod"
        case host = "Host"
        case priority = "Priority"
        case reservoirSize = "ReservoirSize"
        case resourceARN = "ResourceARN"
        case ruleARN = "RuleARN"
        case ruleName = "RuleName"
        case serviceName = "ServiceName"
        case serviceType = "ServiceType"
        case urlPath = "URLPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributeMap0) in attributes {
                try attributesContainer.encode(attributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let fixedRate = self.fixedRate {
            try encodeContainer.encode(fixedRate, forKey: .fixedRate)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let reservoirSize = self.reservoirSize {
            try encodeContainer.encode(reservoirSize, forKey: .reservoirSize)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let ruleARN = self.ruleARN {
            try encodeContainer.encode(ruleARN, forKey: .ruleARN)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType, forKey: .serviceType)
        }
        if let urlPath = self.urlPath {
            try encodeContainer.encode(urlPath, forKey: .urlPath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let ruleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleARN)
        ruleARN = ruleARNDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let fixedRateDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .fixedRate)
        fixedRate = fixedRateDecoded
        let reservoirSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservoirSize)
        reservoirSize = reservoirSizeDecoded
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let urlPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .urlPath)
        urlPath = urlPathDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension XRayClientTypes {
    /// A document specifying changes to a sampling rule's configuration.
    public struct SamplingRuleUpdate: Swift.Equatable {
        /// Matches attributes derived from the request.
        public var attributes: [Swift.String:Swift.String]?
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public var fixedRate: Swift.Double?
        /// Matches the hostname from a request URL.
        public var host: Swift.String?
        /// Matches the HTTP method of a request.
        public var httpMethod: Swift.String?
        /// The priority of the sampling rule.
        public var priority: Swift.Int?
        /// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        public var reservoirSize: Swift.Int?
        /// Matches the ARN of the Amazon Web Services resource on which the service runs.
        public var resourceARN: Swift.String?
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public var ruleARN: Swift.String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public var ruleName: Swift.String?
        /// Matches the name that the service uses to identify itself in segments.
        public var serviceName: Swift.String?
        /// Matches the origin that the service uses to identify its type in segments.
        public var serviceType: Swift.String?
        /// Matches the path from a request URL.
        public var urlPath: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            fixedRate: Swift.Double? = nil,
            host: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            priority: Swift.Int? = nil,
            reservoirSize: Swift.Int? = nil,
            resourceARN: Swift.String? = nil,
            ruleARN: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceType: Swift.String? = nil,
            urlPath: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.fixedRate = fixedRate
            self.host = host
            self.httpMethod = httpMethod
            self.priority = priority
            self.reservoirSize = reservoirSize
            self.resourceARN = resourceARN
            self.ruleARN = ruleARN
            self.ruleName = ruleName
            self.serviceName = serviceName
            self.serviceType = serviceType
            self.urlPath = urlPath
        }
    }

}

extension XRayClientTypes.SamplingStatisticSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case borrowCount = "BorrowCount"
        case requestCount = "RequestCount"
        case ruleName = "RuleName"
        case sampledCount = "SampledCount"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if borrowCount != 0 {
            try encodeContainer.encode(borrowCount, forKey: .borrowCount)
        }
        if requestCount != 0 {
            try encodeContainer.encode(requestCount, forKey: .requestCount)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if sampledCount != 0 {
            try encodeContainer.encode(sampledCount, forKey: .sampledCount)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let requestCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestCount) ?? 0
        requestCount = requestCountDecoded
        let borrowCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .borrowCount) ?? 0
        borrowCount = borrowCountDecoded
        let sampledCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sampledCount) ?? 0
        sampledCount = sampledCountDecoded
    }
}

extension XRayClientTypes {
    /// Aggregated request sampling data for a sampling rule across all services for a 10-second window.
    public struct SamplingStatisticSummary: Swift.Equatable {
        /// The number of requests recorded with borrowed reservoir quota.
        public var borrowCount: Swift.Int
        /// The number of requests that matched the rule.
        public var requestCount: Swift.Int
        /// The name of the sampling rule.
        public var ruleName: Swift.String?
        /// The number of requests recorded.
        public var sampledCount: Swift.Int
        /// The start time of the reporting window.
        public var timestamp: ClientRuntime.Date?

        public init(
            borrowCount: Swift.Int = 0,
            requestCount: Swift.Int = 0,
            ruleName: Swift.String? = nil,
            sampledCount: Swift.Int = 0,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.borrowCount = borrowCount
            self.requestCount = requestCount
            self.ruleName = ruleName
            self.sampledCount = sampledCount
            self.timestamp = timestamp
        }
    }

}

extension XRayClientTypes.SamplingStatisticsDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case borrowCount = "BorrowCount"
        case clientID = "ClientID"
        case requestCount = "RequestCount"
        case ruleName = "RuleName"
        case sampledCount = "SampledCount"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if borrowCount != 0 {
            try encodeContainer.encode(borrowCount, forKey: .borrowCount)
        }
        if let clientID = self.clientID {
            try encodeContainer.encode(clientID, forKey: .clientID)
        }
        if requestCount != 0 {
            try encodeContainer.encode(requestCount, forKey: .requestCount)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if sampledCount != 0 {
            try encodeContainer.encode(sampledCount, forKey: .sampledCount)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let clientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientID)
        clientID = clientIDDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let requestCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestCount) ?? 0
        requestCount = requestCountDecoded
        let sampledCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sampledCount) ?? 0
        sampledCount = sampledCountDecoded
        let borrowCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .borrowCount) ?? 0
        borrowCount = borrowCountDecoded
    }
}

extension XRayClientTypes {
    /// Request sampling results for a single rule from a service. Results are for the last 10 seconds unless the service has been assigned a longer reporting interval after a previous call to [GetSamplingTargets](https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingTargets.html).
    public struct SamplingStatisticsDocument: Swift.Equatable {
        /// The number of requests recorded with borrowed reservoir quota.
        public var borrowCount: Swift.Int
        /// A unique identifier for the service in hexadecimal.
        /// This member is required.
        public var clientID: Swift.String?
        /// The number of requests that matched the rule.
        /// This member is required.
        public var requestCount: Swift.Int
        /// The name of the sampling rule.
        /// This member is required.
        public var ruleName: Swift.String?
        /// The number of requests recorded.
        /// This member is required.
        public var sampledCount: Swift.Int
        /// The current time.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?

        public init(
            borrowCount: Swift.Int = 0,
            clientID: Swift.String? = nil,
            requestCount: Swift.Int = 0,
            ruleName: Swift.String? = nil,
            sampledCount: Swift.Int = 0,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.borrowCount = borrowCount
            self.clientID = clientID
            self.requestCount = requestCount
            self.ruleName = ruleName
            self.sampledCount = sampledCount
            self.timestamp = timestamp
        }
    }

}

extension XRayClientTypes.SamplingStrategy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(XRayClientTypes.SamplingStrategyName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension XRayClientTypes {
    /// The name and value of a sampling rule to apply to a trace summary.
    public struct SamplingStrategy: Swift.Equatable {
        /// The name of a sampling rule.
        public var name: XRayClientTypes.SamplingStrategyName?
        /// The value of a sampling rule.
        public var value: Swift.Double?

        public init(
            name: XRayClientTypes.SamplingStrategyName? = nil,
            value: Swift.Double? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension XRayClientTypes {
    public enum SamplingStrategyName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fixedrate
        case partialscan
        case sdkUnknown(Swift.String)

        public static var allCases: [SamplingStrategyName] {
            return [
                .fixedrate,
                .partialscan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fixedrate: return "FixedRate"
            case .partialscan: return "PartialScan"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SamplingStrategyName(rawValue: rawValue) ?? SamplingStrategyName.sdkUnknown(rawValue)
        }
    }
}

extension XRayClientTypes.SamplingTargetDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fixedRate = "FixedRate"
        case interval = "Interval"
        case reservoirQuota = "ReservoirQuota"
        case reservoirQuotaTTL = "ReservoirQuotaTTL"
        case ruleName = "RuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if fixedRate != 0.0 {
            try encodeContainer.encode(fixedRate, forKey: .fixedRate)
        }
        if let interval = self.interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let reservoirQuota = self.reservoirQuota {
            try encodeContainer.encode(reservoirQuota, forKey: .reservoirQuota)
        }
        if let reservoirQuotaTTL = self.reservoirQuotaTTL {
            try encodeContainer.encodeTimestamp(reservoirQuotaTTL, format: .epochSeconds, forKey: .reservoirQuotaTTL)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let fixedRateDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .fixedRate) ?? 0.0
        fixedRate = fixedRateDecoded
        let reservoirQuotaDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservoirQuota)
        reservoirQuota = reservoirQuotaDecoded
        let reservoirQuotaTTLDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .reservoirQuotaTTL)
        reservoirQuotaTTL = reservoirQuotaTTLDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
    }
}

extension XRayClientTypes {
    /// Temporary changes to a sampling rule configuration. To meet the global sampling target for a rule, X-Ray calculates a new reservoir for each service based on the recent sampling results of all services that called [GetSamplingTargets](https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingTargets.html).
    public struct SamplingTargetDocument: Swift.Equatable {
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public var fixedRate: Swift.Double
        /// The number of seconds for the service to wait before getting sampling targets again.
        public var interval: Swift.Int?
        /// The number of requests per second that X-Ray allocated for this service.
        public var reservoirQuota: Swift.Int?
        /// When the reservoir quota expires.
        public var reservoirQuotaTTL: ClientRuntime.Date?
        /// The name of the sampling rule.
        public var ruleName: Swift.String?

        public init(
            fixedRate: Swift.Double = 0.0,
            interval: Swift.Int? = nil,
            reservoirQuota: Swift.Int? = nil,
            reservoirQuotaTTL: ClientRuntime.Date? = nil,
            ruleName: Swift.String? = nil
        )
        {
            self.fixedRate = fixedRate
            self.interval = interval
            self.reservoirQuota = reservoirQuota
            self.reservoirQuotaTTL = reservoirQuotaTTL
            self.ruleName = ruleName
        }
    }

}

extension XRayClientTypes.Segment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = self.document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
    }
}

extension XRayClientTypes {
    /// A segment from a trace that has been ingested by the X-Ray service. The segment can be compiled from documents uploaded with [PutTraceSegments](https://docs.aws.amazon.com/xray/latest/api/API_PutTraceSegments.html), or an inferred segment for a downstream service, generated from a subsegment sent by the service that called it. For the full segment document schema, see [Amazon Web Services X-Ray Segment Documents](https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html) in the Amazon Web Services X-Ray Developer Guide.
    public struct Segment: Swift.Equatable {
        /// The segment document.
        public var document: Swift.String?
        /// The segment's ID.
        public var id: Swift.String?

        public init(
            document: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.document = document
            self.id = id
        }
    }

}

extension XRayClientTypes.Service: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case durationHistogram = "DurationHistogram"
        case edges = "Edges"
        case endTime = "EndTime"
        case name = "Name"
        case names = "Names"
        case referenceId = "ReferenceId"
        case responseTimeHistogram = "ResponseTimeHistogram"
        case root = "Root"
        case startTime = "StartTime"
        case state = "State"
        case summaryStatistics = "SummaryStatistics"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let durationHistogram = durationHistogram {
            var durationHistogramContainer = encodeContainer.nestedUnkeyedContainer(forKey: .durationHistogram)
            for histogramentry0 in durationHistogram {
                try durationHistogramContainer.encode(histogramentry0)
            }
        }
        if let edges = edges {
            var edgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edges)
            for edge0 in edges {
                try edgesContainer.encode(edge0)
            }
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for string0 in names {
                try namesContainer.encode(string0)
            }
        }
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let responseTimeHistogram = responseTimeHistogram {
            var responseTimeHistogramContainer = encodeContainer.nestedUnkeyedContainer(forKey: .responseTimeHistogram)
            for histogramentry0 in responseTimeHistogram {
                try responseTimeHistogramContainer.encode(histogramentry0)
            }
        }
        if let root = self.root {
            try encodeContainer.encode(root, forKey: .root)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let summaryStatistics = self.summaryStatistics {
            try encodeContainer.encode(summaryStatistics, forKey: .summaryStatistics)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let rootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .root)
        root = rootDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let edgesContainer = try containerValues.decodeIfPresent([XRayClientTypes.Edge?].self, forKey: .edges)
        var edgesDecoded0:[XRayClientTypes.Edge]? = nil
        if let edgesContainer = edgesContainer {
            edgesDecoded0 = [XRayClientTypes.Edge]()
            for structure0 in edgesContainer {
                if let structure0 = structure0 {
                    edgesDecoded0?.append(structure0)
                }
            }
        }
        edges = edgesDecoded0
        let summaryStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.ServiceStatistics.self, forKey: .summaryStatistics)
        summaryStatistics = summaryStatisticsDecoded
        let durationHistogramContainer = try containerValues.decodeIfPresent([XRayClientTypes.HistogramEntry?].self, forKey: .durationHistogram)
        var durationHistogramDecoded0:[XRayClientTypes.HistogramEntry]? = nil
        if let durationHistogramContainer = durationHistogramContainer {
            durationHistogramDecoded0 = [XRayClientTypes.HistogramEntry]()
            for structure0 in durationHistogramContainer {
                if let structure0 = structure0 {
                    durationHistogramDecoded0?.append(structure0)
                }
            }
        }
        durationHistogram = durationHistogramDecoded0
        let responseTimeHistogramContainer = try containerValues.decodeIfPresent([XRayClientTypes.HistogramEntry?].self, forKey: .responseTimeHistogram)
        var responseTimeHistogramDecoded0:[XRayClientTypes.HistogramEntry]? = nil
        if let responseTimeHistogramContainer = responseTimeHistogramContainer {
            responseTimeHistogramDecoded0 = [XRayClientTypes.HistogramEntry]()
            for structure0 in responseTimeHistogramContainer {
                if let structure0 = structure0 {
                    responseTimeHistogramDecoded0?.append(structure0)
                }
            }
        }
        responseTimeHistogram = responseTimeHistogramDecoded0
    }
}

extension XRayClientTypes {
    /// Information about an application that processed requests, users that made requests, or downstream services, resources, and applications that an application used.
    public struct Service: Swift.Equatable {
        /// Identifier of the Amazon Web Services account in which the service runs.
        public var accountId: Swift.String?
        /// A histogram that maps the spread of service durations.
        public var durationHistogram: [XRayClientTypes.HistogramEntry]?
        /// Connections to downstream services.
        public var edges: [XRayClientTypes.Edge]?
        /// The end time of the last segment that the service generated.
        public var endTime: ClientRuntime.Date?
        /// The canonical name of the service.
        public var name: Swift.String?
        /// A list of names for the service, including the canonical name.
        public var names: [Swift.String]?
        /// Identifier for the service. Unique within the service map.
        public var referenceId: Swift.Int?
        /// A histogram that maps the spread of service response times.
        public var responseTimeHistogram: [XRayClientTypes.HistogramEntry]?
        /// Indicates that the service was the first service to process a request.
        public var root: Swift.Bool?
        /// The start time of the first segment that the service generated.
        public var startTime: ClientRuntime.Date?
        /// The service's state.
        public var state: Swift.String?
        /// Aggregated statistics for the service.
        public var summaryStatistics: XRayClientTypes.ServiceStatistics?
        /// The type of service.
        ///
        /// * Amazon Web Services Resource - The type of an Amazon Web Services resource. For example, AWS::EC2::Instance for an application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.
        ///
        /// * Amazon Web Services Service - The type of an Amazon Web Services service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.
        ///
        /// * client - Represents the clients that sent requests to a root service.
        ///
        /// * remote - A downstream service of indeterminate type.
        public var type: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            durationHistogram: [XRayClientTypes.HistogramEntry]? = nil,
            edges: [XRayClientTypes.Edge]? = nil,
            endTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            referenceId: Swift.Int? = nil,
            responseTimeHistogram: [XRayClientTypes.HistogramEntry]? = nil,
            root: Swift.Bool? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: Swift.String? = nil,
            summaryStatistics: XRayClientTypes.ServiceStatistics? = nil,
            type: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.durationHistogram = durationHistogram
            self.edges = edges
            self.endTime = endTime
            self.name = name
            self.names = names
            self.referenceId = referenceId
            self.responseTimeHistogram = responseTimeHistogram
            self.root = root
            self.startTime = startTime
            self.state = state
            self.summaryStatistics = summaryStatistics
            self.type = type
        }
    }

}

extension XRayClientTypes.ServiceId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case name = "Name"
        case names = "Names"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for string0 in names {
                try namesContainer.encode(string0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension XRayClientTypes {
    ///
    public struct ServiceId: Swift.Equatable {
        ///
        public var accountId: Swift.String?
        ///
        public var name: Swift.String?
        ///
        public var names: [Swift.String]?
        ///
        public var type: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.name = name
            self.names = names
            self.type = type
        }
    }

}

extension XRayClientTypes.ServiceStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorStatistics = "ErrorStatistics"
        case faultStatistics = "FaultStatistics"
        case okCount = "OkCount"
        case totalCount = "TotalCount"
        case totalResponseTime = "TotalResponseTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorStatistics = self.errorStatistics {
            try encodeContainer.encode(errorStatistics, forKey: .errorStatistics)
        }
        if let faultStatistics = self.faultStatistics {
            try encodeContainer.encode(faultStatistics, forKey: .faultStatistics)
        }
        if let okCount = self.okCount {
            try encodeContainer.encode(okCount, forKey: .okCount)
        }
        if let totalCount = self.totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
        if let totalResponseTime = self.totalResponseTime {
            try encodeContainer.encode(totalResponseTime, forKey: .totalResponseTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let okCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .okCount)
        okCount = okCountDecoded
        let errorStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.ErrorStatistics.self, forKey: .errorStatistics)
        errorStatistics = errorStatisticsDecoded
        let faultStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.FaultStatistics.self, forKey: .faultStatistics)
        faultStatistics = faultStatisticsDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let totalResponseTimeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .totalResponseTime)
        totalResponseTime = totalResponseTimeDecoded
    }
}

extension XRayClientTypes {
    /// Response statistics for a service.
    public struct ServiceStatistics: Swift.Equatable {
        /// Information about requests that failed with a 4xx Client Error status code.
        public var errorStatistics: XRayClientTypes.ErrorStatistics?
        /// Information about requests that failed with a 5xx Server Error status code.
        public var faultStatistics: XRayClientTypes.FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public var okCount: Swift.Int?
        /// The total number of completed requests.
        public var totalCount: Swift.Int?
        /// The aggregate response time of completed requests.
        public var totalResponseTime: Swift.Double?

        public init(
            errorStatistics: XRayClientTypes.ErrorStatistics? = nil,
            faultStatistics: XRayClientTypes.FaultStatistics? = nil,
            okCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil,
            totalResponseTime: Swift.Double? = nil
        )
        {
            self.errorStatistics = errorStatistics
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.totalCount = totalCount
            self.totalResponseTime = totalResponseTime
        }
    }

}

extension XRayClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension XRayClientTypes {
    /// A map that contains tag keys and tag values to attach to an Amazon Web Services X-Ray group or sampling rule. For more information about ways to use tags, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference. The following restrictions apply to tags:
    ///
    /// * Maximum number of user-applied tags per resource: 50
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Don't use aws: as a prefix for keys; it's reserved for Amazon Web Services use. You cannot edit or delete system tags.
    public struct Tag: Swift.Equatable {
        /// A tag key, such as Stage or Name. A tag key cannot be empty. The key can be a maximum of 128 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
        /// This member is required.
        public var key: Swift.String?
        /// An optional tag value, such as Production or test-only. The value can be a maximum of 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TagResource"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A map that contains one or more tag keys and tag values to attach to an X-Ray group or sampling rule. For more information about ways to use tags, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference. The following restrictions apply to tags:
    ///
    /// * Maximum number of user-applied tags per resource: 50
    ///
    /// * Maximum tag key length: 128 Unicode characters
    ///
    /// * Maximum tag value length: 256 Unicode characters
    ///
    /// * Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Don't use aws: as a prefix for keys; it's reserved for Amazon Web Services use. You cannot edit or delete system tags.
    /// This member is required.
    public var tags: [XRayClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [XRayClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [XRayClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([XRayClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[XRayClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [XRayClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension XRayClientTypes.TelemetryRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendConnectionErrors = "BackendConnectionErrors"
        case segmentsReceivedCount = "SegmentsReceivedCount"
        case segmentsRejectedCount = "SegmentsRejectedCount"
        case segmentsSentCount = "SegmentsSentCount"
        case segmentsSpilloverCount = "SegmentsSpilloverCount"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendConnectionErrors = self.backendConnectionErrors {
            try encodeContainer.encode(backendConnectionErrors, forKey: .backendConnectionErrors)
        }
        if let segmentsReceivedCount = self.segmentsReceivedCount {
            try encodeContainer.encode(segmentsReceivedCount, forKey: .segmentsReceivedCount)
        }
        if let segmentsRejectedCount = self.segmentsRejectedCount {
            try encodeContainer.encode(segmentsRejectedCount, forKey: .segmentsRejectedCount)
        }
        if let segmentsSentCount = self.segmentsSentCount {
            try encodeContainer.encode(segmentsSentCount, forKey: .segmentsSentCount)
        }
        if let segmentsSpilloverCount = self.segmentsSpilloverCount {
            try encodeContainer.encode(segmentsSpilloverCount, forKey: .segmentsSpilloverCount)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let segmentsReceivedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentsReceivedCount)
        segmentsReceivedCount = segmentsReceivedCountDecoded
        let segmentsSentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentsSentCount)
        segmentsSentCount = segmentsSentCountDecoded
        let segmentsSpilloverCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentsSpilloverCount)
        segmentsSpilloverCount = segmentsSpilloverCountDecoded
        let segmentsRejectedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentsRejectedCount)
        segmentsRejectedCount = segmentsRejectedCountDecoded
        let backendConnectionErrorsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.BackendConnectionErrors.self, forKey: .backendConnectionErrors)
        backendConnectionErrors = backendConnectionErrorsDecoded
    }
}

extension XRayClientTypes {
    ///
    public struct TelemetryRecord: Swift.Equatable {
        ///
        public var backendConnectionErrors: XRayClientTypes.BackendConnectionErrors?
        ///
        public var segmentsReceivedCount: Swift.Int?
        ///
        public var segmentsRejectedCount: Swift.Int?
        ///
        public var segmentsSentCount: Swift.Int?
        ///
        public var segmentsSpilloverCount: Swift.Int?
        ///
        /// This member is required.
        public var timestamp: ClientRuntime.Date?

        public init(
            backendConnectionErrors: XRayClientTypes.BackendConnectionErrors? = nil,
            segmentsReceivedCount: Swift.Int? = nil,
            segmentsRejectedCount: Swift.Int? = nil,
            segmentsSentCount: Swift.Int? = nil,
            segmentsSpilloverCount: Swift.Int? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.backendConnectionErrors = backendConnectionErrors
            self.segmentsReceivedCount = segmentsReceivedCount
            self.segmentsRejectedCount = segmentsRejectedCount
            self.segmentsSentCount = segmentsSentCount
            self.segmentsSpilloverCount = segmentsSpilloverCount
            self.timestamp = timestamp
        }
    }

}

extension ThrottledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeds the maximum number of requests per second.
public struct ThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension XRayClientTypes {
    public enum TimeRangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case event
        case traceid
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeRangeType] {
            return [
                .event,
                .traceid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .event: return "Event"
            case .traceid: return "TraceId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeRangeType(rawValue: rawValue) ?? TimeRangeType.sdkUnknown(rawValue)
        }
    }
}

extension XRayClientTypes.TimeSeriesServiceStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case edgeSummaryStatistics = "EdgeSummaryStatistics"
        case responseTimeHistogram = "ResponseTimeHistogram"
        case serviceForecastStatistics = "ServiceForecastStatistics"
        case serviceSummaryStatistics = "ServiceSummaryStatistics"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let edgeSummaryStatistics = self.edgeSummaryStatistics {
            try encodeContainer.encode(edgeSummaryStatistics, forKey: .edgeSummaryStatistics)
        }
        if let responseTimeHistogram = responseTimeHistogram {
            var responseTimeHistogramContainer = encodeContainer.nestedUnkeyedContainer(forKey: .responseTimeHistogram)
            for histogramentry0 in responseTimeHistogram {
                try responseTimeHistogramContainer.encode(histogramentry0)
            }
        }
        if let serviceForecastStatistics = self.serviceForecastStatistics {
            try encodeContainer.encode(serviceForecastStatistics, forKey: .serviceForecastStatistics)
        }
        if let serviceSummaryStatistics = self.serviceSummaryStatistics {
            try encodeContainer.encode(serviceSummaryStatistics, forKey: .serviceSummaryStatistics)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let edgeSummaryStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.EdgeStatistics.self, forKey: .edgeSummaryStatistics)
        edgeSummaryStatistics = edgeSummaryStatisticsDecoded
        let serviceSummaryStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.ServiceStatistics.self, forKey: .serviceSummaryStatistics)
        serviceSummaryStatistics = serviceSummaryStatisticsDecoded
        let serviceForecastStatisticsDecoded = try containerValues.decodeIfPresent(XRayClientTypes.ForecastStatistics.self, forKey: .serviceForecastStatistics)
        serviceForecastStatistics = serviceForecastStatisticsDecoded
        let responseTimeHistogramContainer = try containerValues.decodeIfPresent([XRayClientTypes.HistogramEntry?].self, forKey: .responseTimeHistogram)
        var responseTimeHistogramDecoded0:[XRayClientTypes.HistogramEntry]? = nil
        if let responseTimeHistogramContainer = responseTimeHistogramContainer {
            responseTimeHistogramDecoded0 = [XRayClientTypes.HistogramEntry]()
            for structure0 in responseTimeHistogramContainer {
                if let structure0 = structure0 {
                    responseTimeHistogramDecoded0?.append(structure0)
                }
            }
        }
        responseTimeHistogram = responseTimeHistogramDecoded0
    }
}

extension XRayClientTypes {
    /// A list of TimeSeriesStatistic structures.
    public struct TimeSeriesServiceStatistics: Swift.Equatable {
        /// Response statistics for an edge.
        public var edgeSummaryStatistics: XRayClientTypes.EdgeStatistics?
        /// The response time histogram for the selected entities.
        public var responseTimeHistogram: [XRayClientTypes.HistogramEntry]?
        /// The forecasted high and low fault count values.
        public var serviceForecastStatistics: XRayClientTypes.ForecastStatistics?
        /// Response statistics for a service.
        public var serviceSummaryStatistics: XRayClientTypes.ServiceStatistics?
        /// Timestamp of the window for which statistics are aggregated.
        public var timestamp: ClientRuntime.Date?

        public init(
            edgeSummaryStatistics: XRayClientTypes.EdgeStatistics? = nil,
            responseTimeHistogram: [XRayClientTypes.HistogramEntry]? = nil,
            serviceForecastStatistics: XRayClientTypes.ForecastStatistics? = nil,
            serviceSummaryStatistics: XRayClientTypes.ServiceStatistics? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.edgeSummaryStatistics = edgeSummaryStatistics
            self.responseTimeHistogram = responseTimeHistogram
            self.serviceForecastStatistics = serviceForecastStatistics
            self.serviceSummaryStatistics = serviceSummaryStatistics
            self.timestamp = timestamp
        }
    }

}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded the maximum number of tags you can apply to this resource.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension XRayClientTypes.Trace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case id = "Id"
        case limitExceeded = "LimitExceeded"
        case segments = "Segments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let limitExceeded = self.limitExceeded {
            try encodeContainer.encode(limitExceeded, forKey: .limitExceeded)
        }
        if let segments = segments {
            var segmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segments)
            for segment0 in segments {
                try segmentsContainer.encode(segment0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .duration)
        duration = durationDecoded
        let limitExceededDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .limitExceeded)
        limitExceeded = limitExceededDecoded
        let segmentsContainer = try containerValues.decodeIfPresent([XRayClientTypes.Segment?].self, forKey: .segments)
        var segmentsDecoded0:[XRayClientTypes.Segment]? = nil
        if let segmentsContainer = segmentsContainer {
            segmentsDecoded0 = [XRayClientTypes.Segment]()
            for structure0 in segmentsContainer {
                if let structure0 = structure0 {
                    segmentsDecoded0?.append(structure0)
                }
            }
        }
        segments = segmentsDecoded0
    }
}

extension XRayClientTypes {
    /// A collection of segment documents with matching trace IDs.
    public struct Trace: Swift.Equatable {
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public var duration: Swift.Double?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public var id: Swift.String?
        /// LimitExceeded is set to true when the trace has exceeded the Trace document size limit. For more information about this limit and other X-Ray limits and quotas, see [Amazon Web Services X-Ray endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/xray.html).
        public var limitExceeded: Swift.Bool?
        /// Segment documents for the segments and subsegments that comprise the trace.
        public var segments: [XRayClientTypes.Segment]?

        public init(
            duration: Swift.Double? = nil,
            id: Swift.String? = nil,
            limitExceeded: Swift.Bool? = nil,
            segments: [XRayClientTypes.Segment]? = nil
        )
        {
            self.duration = duration
            self.id = id
            self.limitExceeded = limitExceeded
            self.segments = segments
        }
    }

}

extension XRayClientTypes.TraceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotations = "Annotations"
        case availabilityZones = "AvailabilityZones"
        case duration = "Duration"
        case entryPoint = "EntryPoint"
        case errorRootCauses = "ErrorRootCauses"
        case faultRootCauses = "FaultRootCauses"
        case hasError = "HasError"
        case hasFault = "HasFault"
        case hasThrottle = "HasThrottle"
        case http = "Http"
        case id = "Id"
        case instanceIds = "InstanceIds"
        case isPartial = "IsPartial"
        case matchedEventTime = "MatchedEventTime"
        case resourceARNs = "ResourceARNs"
        case responseTime = "ResponseTime"
        case responseTimeRootCauses = "ResponseTimeRootCauses"
        case revision = "Revision"
        case serviceIds = "ServiceIds"
        case startTime = "StartTime"
        case users = "Users"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotations = annotations {
            var annotationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .annotations)
            for (dictKey0, annotations0) in annotations {
                var annotations0Container = annotationsContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for valuewithserviceids1 in annotations0 {
                    try annotations0Container.encode(valuewithserviceids1)
                }
            }
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzonedetail0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzonedetail0)
            }
        }
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let entryPoint = self.entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let errorRootCauses = errorRootCauses {
            var errorRootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorRootCauses)
            for errorrootcause0 in errorRootCauses {
                try errorRootCausesContainer.encode(errorrootcause0)
            }
        }
        if let faultRootCauses = faultRootCauses {
            var faultRootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .faultRootCauses)
            for faultrootcause0 in faultRootCauses {
                try faultRootCausesContainer.encode(faultrootcause0)
            }
        }
        if let hasError = self.hasError {
            try encodeContainer.encode(hasError, forKey: .hasError)
        }
        if let hasFault = self.hasFault {
            try encodeContainer.encode(hasFault, forKey: .hasFault)
        }
        if let hasThrottle = self.hasThrottle {
            try encodeContainer.encode(hasThrottle, forKey: .hasThrottle)
        }
        if let http = self.http {
            try encodeContainer.encode(http, forKey: .http)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceiddetail0 in instanceIds {
                try instanceIdsContainer.encode(instanceiddetail0)
            }
        }
        if let isPartial = self.isPartial {
            try encodeContainer.encode(isPartial, forKey: .isPartial)
        }
        if let matchedEventTime = self.matchedEventTime {
            try encodeContainer.encodeTimestamp(matchedEventTime, format: .epochSeconds, forKey: .matchedEventTime)
        }
        if let resourceARNs = resourceARNs {
            var resourceARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceARNs)
            for resourcearndetail0 in resourceARNs {
                try resourceARNsContainer.encode(resourcearndetail0)
            }
        }
        if let responseTime = self.responseTime {
            try encodeContainer.encode(responseTime, forKey: .responseTime)
        }
        if let responseTimeRootCauses = responseTimeRootCauses {
            var responseTimeRootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .responseTimeRootCauses)
            for responsetimerootcause0 in responseTimeRootCauses {
                try responseTimeRootCausesContainer.encode(responsetimerootcause0)
            }
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let serviceIds = serviceIds {
            var serviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceIds)
            for serviceid0 in serviceIds {
                try serviceIdsContainer.encode(serviceid0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for traceuser0 in users {
                try usersContainer.encode(traceuser0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .duration)
        duration = durationDecoded
        let responseTimeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .responseTime)
        responseTime = responseTimeDecoded
        let hasFaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasFault)
        hasFault = hasFaultDecoded
        let hasErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasError)
        hasError = hasErrorDecoded
        let hasThrottleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasThrottle)
        hasThrottle = hasThrottleDecoded
        let isPartialDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPartial)
        isPartial = isPartialDecoded
        let httpDecoded = try containerValues.decodeIfPresent(XRayClientTypes.Http.self, forKey: .http)
        http = httpDecoded
        let annotationsContainer = try containerValues.decodeIfPresent([Swift.String: [XRayClientTypes.ValueWithServiceIds?]?].self, forKey: .annotations)
        var annotationsDecoded0: [Swift.String:[XRayClientTypes.ValueWithServiceIds]]? = nil
        if let annotationsContainer = annotationsContainer {
            annotationsDecoded0 = [Swift.String:[XRayClientTypes.ValueWithServiceIds]]()
            for (key0, valueswithserviceids0) in annotationsContainer {
                var valueswithserviceids0Decoded0: [XRayClientTypes.ValueWithServiceIds]? = nil
                if let valueswithserviceids0 = valueswithserviceids0 {
                    valueswithserviceids0Decoded0 = [XRayClientTypes.ValueWithServiceIds]()
                    for structure1 in valueswithserviceids0 {
                        if let structure1 = structure1 {
                            valueswithserviceids0Decoded0?.append(structure1)
                        }
                    }
                }
                annotationsDecoded0?[key0] = valueswithserviceids0Decoded0
            }
        }
        annotations = annotationsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([XRayClientTypes.TraceUser?].self, forKey: .users)
        var usersDecoded0:[XRayClientTypes.TraceUser]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [XRayClientTypes.TraceUser]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let serviceIdsContainer = try containerValues.decodeIfPresent([XRayClientTypes.ServiceId?].self, forKey: .serviceIds)
        var serviceIdsDecoded0:[XRayClientTypes.ServiceId]? = nil
        if let serviceIdsContainer = serviceIdsContainer {
            serviceIdsDecoded0 = [XRayClientTypes.ServiceId]()
            for structure0 in serviceIdsContainer {
                if let structure0 = structure0 {
                    serviceIdsDecoded0?.append(structure0)
                }
            }
        }
        serviceIds = serviceIdsDecoded0
        let resourceARNsContainer = try containerValues.decodeIfPresent([XRayClientTypes.ResourceARNDetail?].self, forKey: .resourceARNs)
        var resourceARNsDecoded0:[XRayClientTypes.ResourceARNDetail]? = nil
        if let resourceARNsContainer = resourceARNsContainer {
            resourceARNsDecoded0 = [XRayClientTypes.ResourceARNDetail]()
            for structure0 in resourceARNsContainer {
                if let structure0 = structure0 {
                    resourceARNsDecoded0?.append(structure0)
                }
            }
        }
        resourceARNs = resourceARNsDecoded0
        let instanceIdsContainer = try containerValues.decodeIfPresent([XRayClientTypes.InstanceIdDetail?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[XRayClientTypes.InstanceIdDetail]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [XRayClientTypes.InstanceIdDetail]()
            for structure0 in instanceIdsContainer {
                if let structure0 = structure0 {
                    instanceIdsDecoded0?.append(structure0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let availabilityZonesContainer = try containerValues.decodeIfPresent([XRayClientTypes.AvailabilityZoneDetail?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[XRayClientTypes.AvailabilityZoneDetail]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [XRayClientTypes.AvailabilityZoneDetail]()
            for structure0 in availabilityZonesContainer {
                if let structure0 = structure0 {
                    availabilityZonesDecoded0?.append(structure0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let entryPointDecoded = try containerValues.decodeIfPresent(XRayClientTypes.ServiceId.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let faultRootCausesContainer = try containerValues.decodeIfPresent([XRayClientTypes.FaultRootCause?].self, forKey: .faultRootCauses)
        var faultRootCausesDecoded0:[XRayClientTypes.FaultRootCause]? = nil
        if let faultRootCausesContainer = faultRootCausesContainer {
            faultRootCausesDecoded0 = [XRayClientTypes.FaultRootCause]()
            for structure0 in faultRootCausesContainer {
                if let structure0 = structure0 {
                    faultRootCausesDecoded0?.append(structure0)
                }
            }
        }
        faultRootCauses = faultRootCausesDecoded0
        let errorRootCausesContainer = try containerValues.decodeIfPresent([XRayClientTypes.ErrorRootCause?].self, forKey: .errorRootCauses)
        var errorRootCausesDecoded0:[XRayClientTypes.ErrorRootCause]? = nil
        if let errorRootCausesContainer = errorRootCausesContainer {
            errorRootCausesDecoded0 = [XRayClientTypes.ErrorRootCause]()
            for structure0 in errorRootCausesContainer {
                if let structure0 = structure0 {
                    errorRootCausesDecoded0?.append(structure0)
                }
            }
        }
        errorRootCauses = errorRootCausesDecoded0
        let responseTimeRootCausesContainer = try containerValues.decodeIfPresent([XRayClientTypes.ResponseTimeRootCause?].self, forKey: .responseTimeRootCauses)
        var responseTimeRootCausesDecoded0:[XRayClientTypes.ResponseTimeRootCause]? = nil
        if let responseTimeRootCausesContainer = responseTimeRootCausesContainer {
            responseTimeRootCausesDecoded0 = [XRayClientTypes.ResponseTimeRootCause]()
            for structure0 in responseTimeRootCausesContainer {
                if let structure0 = structure0 {
                    responseTimeRootCausesDecoded0?.append(structure0)
                }
            }
        }
        responseTimeRootCauses = responseTimeRootCausesDecoded0
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision) ?? 0
        revision = revisionDecoded
        let matchedEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .matchedEventTime)
        matchedEventTime = matchedEventTimeDecoded
    }
}

extension XRayClientTypes {
    /// Metadata generated from the segment documents in a trace.
    public struct TraceSummary: Swift.Equatable {
        /// Annotations from the trace's segment documents.
        public var annotations: [Swift.String:[XRayClientTypes.ValueWithServiceIds]]?
        /// A list of Availability Zones for any zone corresponding to the trace segments.
        public var availabilityZones: [XRayClientTypes.AvailabilityZoneDetail]?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public var duration: Swift.Double?
        /// The root of a trace.
        public var entryPoint: XRayClientTypes.ServiceId?
        /// A collection of ErrorRootCause structures corresponding to the trace segments.
        public var errorRootCauses: [XRayClientTypes.ErrorRootCause]?
        /// A collection of FaultRootCause structures corresponding to the trace segments.
        public var faultRootCauses: [XRayClientTypes.FaultRootCause]?
        /// The root segment document has a 400 series error.
        public var hasError: Swift.Bool?
        /// The root segment document has a 500 series error.
        public var hasFault: Swift.Bool?
        /// One or more of the segment documents has a 429 throttling error.
        public var hasThrottle: Swift.Bool?
        /// Information about the HTTP request served by the trace.
        public var http: XRayClientTypes.Http?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public var id: Swift.String?
        /// A list of EC2 instance IDs for any instance corresponding to the trace segments.
        public var instanceIds: [XRayClientTypes.InstanceIdDetail]?
        /// One or more of the segment documents is in progress.
        public var isPartial: Swift.Bool?
        /// The matched time stamp of a defined event.
        public var matchedEventTime: ClientRuntime.Date?
        /// A list of resource ARNs for any resource corresponding to the trace segments.
        public var resourceARNs: [XRayClientTypes.ResourceARNDetail]?
        /// The length of time in seconds between the start and end times of the root segment. If the service performs work asynchronously, the response time measures the time before the response is sent to the user, while the duration measures the amount of time before the last traced activity completes.
        public var responseTime: Swift.Double?
        /// A collection of ResponseTimeRootCause structures corresponding to the trace segments.
        public var responseTimeRootCauses: [XRayClientTypes.ResponseTimeRootCause]?
        /// The revision number of a trace.
        public var revision: Swift.Int
        /// Service IDs from the trace's segment documents.
        public var serviceIds: [XRayClientTypes.ServiceId]?
        /// The start time of a trace, based on the earliest trace segment start time.
        public var startTime: ClientRuntime.Date?
        /// Users from the trace's segment documents.
        public var users: [XRayClientTypes.TraceUser]?

        public init(
            annotations: [Swift.String:[XRayClientTypes.ValueWithServiceIds]]? = nil,
            availabilityZones: [XRayClientTypes.AvailabilityZoneDetail]? = nil,
            duration: Swift.Double? = nil,
            entryPoint: XRayClientTypes.ServiceId? = nil,
            errorRootCauses: [XRayClientTypes.ErrorRootCause]? = nil,
            faultRootCauses: [XRayClientTypes.FaultRootCause]? = nil,
            hasError: Swift.Bool? = nil,
            hasFault: Swift.Bool? = nil,
            hasThrottle: Swift.Bool? = nil,
            http: XRayClientTypes.Http? = nil,
            id: Swift.String? = nil,
            instanceIds: [XRayClientTypes.InstanceIdDetail]? = nil,
            isPartial: Swift.Bool? = nil,
            matchedEventTime: ClientRuntime.Date? = nil,
            resourceARNs: [XRayClientTypes.ResourceARNDetail]? = nil,
            responseTime: Swift.Double? = nil,
            responseTimeRootCauses: [XRayClientTypes.ResponseTimeRootCause]? = nil,
            revision: Swift.Int = 0,
            serviceIds: [XRayClientTypes.ServiceId]? = nil,
            startTime: ClientRuntime.Date? = nil,
            users: [XRayClientTypes.TraceUser]? = nil
        )
        {
            self.annotations = annotations
            self.availabilityZones = availabilityZones
            self.duration = duration
            self.entryPoint = entryPoint
            self.errorRootCauses = errorRootCauses
            self.faultRootCauses = faultRootCauses
            self.hasError = hasError
            self.hasFault = hasFault
            self.hasThrottle = hasThrottle
            self.http = http
            self.id = id
            self.instanceIds = instanceIds
            self.isPartial = isPartial
            self.matchedEventTime = matchedEventTime
            self.resourceARNs = resourceARNs
            self.responseTime = responseTime
            self.responseTimeRootCauses = responseTimeRootCauses
            self.revision = revision
            self.serviceIds = serviceIds
            self.startTime = startTime
            self.users = users
        }
    }

}

extension XRayClientTypes.TraceUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceIds = "ServiceIds"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceIds = serviceIds {
            var serviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceIds)
            for serviceid0 in serviceIds {
                try serviceIdsContainer.encode(serviceid0)
            }
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let serviceIdsContainer = try containerValues.decodeIfPresent([XRayClientTypes.ServiceId?].self, forKey: .serviceIds)
        var serviceIdsDecoded0:[XRayClientTypes.ServiceId]? = nil
        if let serviceIdsContainer = serviceIdsContainer {
            serviceIdsDecoded0 = [XRayClientTypes.ServiceId]()
            for structure0 in serviceIdsContainer {
                if let structure0 = structure0 {
                    serviceIdsDecoded0?.append(structure0)
                }
            }
        }
        serviceIds = serviceIdsDecoded0
    }
}

extension XRayClientTypes {
    /// Information about a user recorded in segment documents.
    public struct TraceUser: Swift.Equatable {
        /// Services that the user's request hit.
        public var serviceIds: [XRayClientTypes.ServiceId]?
        /// The user's name.
        public var userName: Swift.String?

        public init(
            serviceIds: [XRayClientTypes.ServiceId]? = nil,
            userName: Swift.String? = nil
        )
        {
            self.serviceIds = serviceIds
            self.userName = userName
        }
    }

}

extension XRayClientTypes.UnprocessedStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
        case ruleName = "RuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension XRayClientTypes {
    /// Sampling statistics from a call to [GetSamplingTargets](https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingTargets.html) that X-Ray could not process.
    public struct UnprocessedStatistics: Swift.Equatable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?
        /// The name of the sampling rule.
        public var ruleName: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil,
            ruleName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
            self.ruleName = ruleName
        }
    }

}

extension XRayClientTypes.UnprocessedTraceSegment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case id = "Id"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension XRayClientTypes {
    /// Information about a segment that failed processing.
    public struct UnprocessedTraceSegment: Swift.Equatable {
        /// The error that caused processing to fail.
        public var errorCode: Swift.String?
        /// The segment's ID.
        public var id: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            id: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.id = id
            self.message = message
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UntagResource"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Keys for one or more tags that you want to remove from an X-Ray group or sampling rule.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpression = "FilterExpression"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case insightsConfiguration = "InsightsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterExpression = self.filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let groupARN = self.groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let insightsConfiguration = self.insightsConfiguration {
            try encodeContainer.encode(insightsConfiguration, forKey: .insightsConfiguration)
        }
    }
}

extension UpdateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateGroup"
    }
}

public struct UpdateGroupInput: Swift.Equatable {
    /// The updated filter expression defining criteria by which to group traces.
    public var filterExpression: Swift.String?
    /// The ARN that was generated upon creation.
    public var groupARN: Swift.String?
    /// The case-sensitive name of the group.
    public var groupName: Swift.String?
    /// The structure containing configurations related to insights.
    ///
    /// * The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.
    ///
    /// * The NotificationsEnabled boolean can be set to true to enable insights notifications for the group. Notifications can only be enabled on a group with InsightsEnabled set to true.
    public var insightsConfiguration: XRayClientTypes.InsightsConfiguration?

    public init(
        filterExpression: Swift.String? = nil,
        groupARN: Swift.String? = nil,
        groupName: Swift.String? = nil,
        insightsConfiguration: XRayClientTypes.InsightsConfiguration? = nil
    )
    {
        self.filterExpression = filterExpression
        self.groupARN = groupARN
        self.groupName = groupName
        self.insightsConfiguration = insightsConfiguration
    }
}

struct UpdateGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let groupARN: Swift.String?
    let filterExpression: Swift.String?
    let insightsConfiguration: XRayClientTypes.InsightsConfiguration?
}

extension UpdateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterExpression = "FilterExpression"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case insightsConfiguration = "InsightsConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let insightsConfigurationDecoded = try containerValues.decodeIfPresent(XRayClientTypes.InsightsConfiguration.self, forKey: .insightsConfiguration)
        insightsConfiguration = insightsConfigurationDecoded
    }
}

extension UpdateGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

public struct UpdateGroupOutput: Swift.Equatable {
    /// The group that was updated. Contains the name of the group that was updated, the ARN of the group that was updated, the updated filter expression, and the updated insight configuration assigned to the group.
    public var group: XRayClientTypes.Group?

    public init(
        group: XRayClientTypes.Group? = nil
    )
    {
        self.group = group
    }
}

struct UpdateGroupOutputBody: Swift.Equatable {
    let group: XRayClientTypes.Group?
}

extension UpdateGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group = "Group"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(XRayClientTypes.Group.self, forKey: .group)
        group = groupDecoded
    }
}

enum UpdateGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSamplingRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samplingRuleUpdate = "SamplingRuleUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let samplingRuleUpdate = self.samplingRuleUpdate {
            try encodeContainer.encode(samplingRuleUpdate, forKey: .samplingRuleUpdate)
        }
    }
}

extension UpdateSamplingRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateSamplingRule"
    }
}

public struct UpdateSamplingRuleInput: Swift.Equatable {
    /// The rule and fields to change.
    /// This member is required.
    public var samplingRuleUpdate: XRayClientTypes.SamplingRuleUpdate?

    public init(
        samplingRuleUpdate: XRayClientTypes.SamplingRuleUpdate? = nil
    )
    {
        self.samplingRuleUpdate = samplingRuleUpdate
    }
}

struct UpdateSamplingRuleInputBody: Swift.Equatable {
    let samplingRuleUpdate: XRayClientTypes.SamplingRuleUpdate?
}

extension UpdateSamplingRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samplingRuleUpdate = "SamplingRuleUpdate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleUpdateDecoded = try containerValues.decodeIfPresent(XRayClientTypes.SamplingRuleUpdate.self, forKey: .samplingRuleUpdate)
        samplingRuleUpdate = samplingRuleUpdateDecoded
    }
}

extension UpdateSamplingRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSamplingRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.samplingRuleRecord = output.samplingRuleRecord
        } else {
            self.samplingRuleRecord = nil
        }
    }
}

public struct UpdateSamplingRuleOutput: Swift.Equatable {
    /// The updated rule definition and metadata.
    public var samplingRuleRecord: XRayClientTypes.SamplingRuleRecord?

    public init(
        samplingRuleRecord: XRayClientTypes.SamplingRuleRecord? = nil
    )
    {
        self.samplingRuleRecord = samplingRuleRecord
    }
}

struct UpdateSamplingRuleOutputBody: Swift.Equatable {
    let samplingRuleRecord: XRayClientTypes.SamplingRuleRecord?
}

extension UpdateSamplingRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case samplingRuleRecord = "SamplingRuleRecord"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleRecordDecoded = try containerValues.decodeIfPresent(XRayClientTypes.SamplingRuleRecord.self, forKey: .samplingRuleRecord)
        samplingRuleRecord = samplingRuleRecordDecoded
    }
}

enum UpdateSamplingRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledException": return try await ThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension XRayClientTypes.ValueWithServiceIds: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationValue = "AnnotationValue"
        case serviceIds = "ServiceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotationValue = self.annotationValue {
            try encodeContainer.encode(annotationValue, forKey: .annotationValue)
        }
        if let serviceIds = serviceIds {
            var serviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceIds)
            for serviceid0 in serviceIds {
                try serviceIdsContainer.encode(serviceid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let annotationValueDecoded = try containerValues.decodeIfPresent(XRayClientTypes.AnnotationValue.self, forKey: .annotationValue)
        annotationValue = annotationValueDecoded
        let serviceIdsContainer = try containerValues.decodeIfPresent([XRayClientTypes.ServiceId?].self, forKey: .serviceIds)
        var serviceIdsDecoded0:[XRayClientTypes.ServiceId]? = nil
        if let serviceIdsContainer = serviceIdsContainer {
            serviceIdsDecoded0 = [XRayClientTypes.ServiceId]()
            for structure0 in serviceIdsContainer {
                if let structure0 = structure0 {
                    serviceIdsDecoded0?.append(structure0)
                }
            }
        }
        serviceIds = serviceIdsDecoded0
    }
}

extension XRayClientTypes {
    /// Information about a segment annotation.
    public struct ValueWithServiceIds: Swift.Equatable {
        /// Values of the annotation.
        public var annotationValue: XRayClientTypes.AnnotationValue?
        /// Services to which the annotation applies.
        public var serviceIds: [XRayClientTypes.ServiceId]?

        public init(
            annotationValue: XRayClientTypes.AnnotationValue? = nil,
            serviceIds: [XRayClientTypes.ServiceId]? = nil
        )
        {
            self.annotationValue = annotationValue
            self.serviceIds = serviceIds
        }
    }

}
