//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

extension XRayClientTypes {
    /// An alias for an edge.
    public struct Alias {
        /// The canonical name of the alias.
        public var name: Swift.String?
        /// A list of names for the alias, including the canonical name.
        public var names: [Swift.String]?
        /// The type of the alias.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.names = names
            self.type = type
        }
    }

}

extension XRayClientTypes {
    /// Value of a segment annotation. Has one of three value types: Number, Boolean, or String.
    public enum AnnotationValue {
        /// Value for a Number annotation.
        case numbervalue(Swift.Double)
        /// Value for a Boolean annotation.
        case booleanvalue(Swift.Bool)
        /// Value for a String annotation.
        case stringvalue(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension XRayClientTypes {
    ///
    public struct ServiceId {
        ///
        public var accountId: Swift.String?
        ///
        public var name: Swift.String?
        ///
        public var names: [Swift.String]?
        ///
        public var type: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.name = name
            self.names = names
            self.type = type
        }
    }

}

extension XRayClientTypes {
    /// Information about a segment annotation.
    public struct ValueWithServiceIds {
        /// Values of the annotation.
        public var annotationValue: XRayClientTypes.AnnotationValue?
        /// Services to which the annotation applies.
        public var serviceIds: [XRayClientTypes.ServiceId]?

        public init(
            annotationValue: XRayClientTypes.AnnotationValue? = nil,
            serviceIds: [XRayClientTypes.ServiceId]? = nil
        )
        {
            self.annotationValue = annotationValue
            self.serviceIds = serviceIds
        }
    }

}

extension XRayClientTypes {
    /// The service within the service graph that has anomalously high fault rates.
    public struct AnomalousService {
        ///
        public var serviceId: XRayClientTypes.ServiceId?

        public init(
            serviceId: XRayClientTypes.ServiceId? = nil
        )
        {
            self.serviceId = serviceId
        }
    }

}

extension XRayClientTypes {
    /// A list of Availability Zones corresponding to the segments in a trace.
    public struct AvailabilityZoneDetail {
        /// The name of a corresponding Availability Zone.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

/// The request is missing required parameters or has invalid parameters.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request exceeds the maximum number of requests per second.
public struct ThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchGetTracesInput {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// Specify the trace IDs of requests for which to retrieve segments.
    /// This member is required.
    public var traceIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        traceIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.traceIds = traceIds
    }
}

extension XRayClientTypes {
    /// A segment from a trace that has been ingested by the X-Ray service. The segment can be compiled from documents uploaded with [PutTraceSegments](https://docs.aws.amazon.com/xray/latest/api/API_PutTraceSegments.html), or an inferred segment for a downstream service, generated from a subsegment sent by the service that called it. For the full segment document schema, see [Amazon Web Services X-Ray Segment Documents](https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html) in the Amazon Web Services X-Ray Developer Guide.
    public struct Segment {
        /// The segment document.
        public var document: Swift.String?
        /// The segment's ID.
        public var id: Swift.String?

        public init(
            document: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.document = document
            self.id = id
        }
    }

}

extension XRayClientTypes {
    /// A collection of segment documents with matching trace IDs.
    public struct Trace {
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public var duration: Swift.Double?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public var id: Swift.String?
        /// LimitExceeded is set to true when the trace has exceeded the Trace document size limit. For more information about this limit and other X-Ray limits and quotas, see [Amazon Web Services X-Ray endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/xray.html).
        public var limitExceeded: Swift.Bool?
        /// Segment documents for the segments and subsegments that comprise the trace.
        public var segments: [XRayClientTypes.Segment]?

        public init(
            duration: Swift.Double? = nil,
            id: Swift.String? = nil,
            limitExceeded: Swift.Bool? = nil,
            segments: [XRayClientTypes.Segment]? = nil
        )
        {
            self.duration = duration
            self.id = id
            self.limitExceeded = limitExceeded
            self.segments = segments
        }
    }

}

public struct BatchGetTracesOutput {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// Full traces for the specified requests.
    public var traces: [XRayClientTypes.Trace]?
    /// Trace IDs of requests that haven't been processed.
    public var unprocessedTraceIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        traces: [XRayClientTypes.Trace]? = nil,
        unprocessedTraceIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.traces = traces
        self.unprocessedTraceIds = unprocessedTraceIds
    }
}

extension XRayClientTypes {
    /// The structure containing configurations related to insights.
    public struct InsightsConfiguration {
        /// Set the InsightsEnabled value to true to enable insights or false to disable insights.
        public var insightsEnabled: Swift.Bool?
        /// Set the NotificationsEnabled value to true to enable insights notifications. Notifications can only be enabled on a group with InsightsEnabled set to true.
        public var notificationsEnabled: Swift.Bool?

        public init(
            insightsEnabled: Swift.Bool? = nil,
            notificationsEnabled: Swift.Bool? = nil
        )
        {
            self.insightsEnabled = insightsEnabled
            self.notificationsEnabled = notificationsEnabled
        }
    }

}

extension XRayClientTypes {
    /// A map that contains tag keys and tag values to attach to an Amazon Web Services X-Ray group or sampling rule. For more information about ways to use tags, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference. The following restrictions apply to tags:
    ///
    /// * Maximum number of user-applied tags per resource: 50
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Don't use aws: as a prefix for keys; it's reserved for Amazon Web Services use. You cannot edit or delete system tags.
    public struct Tag {
        /// A tag key, such as Stage or Name. A tag key cannot be empty. The key can be a maximum of 128 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
        /// This member is required.
        public var key: Swift.String?
        /// An optional tag value, such as Production or test-only. The value can be a maximum of 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateGroupInput {
    /// The filter expression defining criteria by which to group traces.
    public var filterExpression: Swift.String?
    /// The case-sensitive name of the new group. Default is a reserved name and names must be unique.
    /// This member is required.
    public var groupName: Swift.String?
    /// The structure containing configurations related to insights.
    ///
    /// * The InsightsEnabled boolean can be set to true to enable insights for the new group or false to disable insights for the new group.
    ///
    /// * The NotificationsEnabled boolean can be set to true to enable insights notifications for the new group. Notifications may only be enabled on a group with InsightsEnabled set to true.
    public var insightsConfiguration: XRayClientTypes.InsightsConfiguration?
    /// A map that contains one or more tag keys and tag values to attach to an X-Ray group. For more information about ways to use tags, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference. The following restrictions apply to tags:
    ///
    /// * Maximum number of user-applied tags per resource: 50
    ///
    /// * Maximum tag key length: 128 Unicode characters
    ///
    /// * Maximum tag value length: 256 Unicode characters
    ///
    /// * Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Don't use aws: as a prefix for keys; it's reserved for Amazon Web Services use.
    public var tags: [XRayClientTypes.Tag]?

    public init(
        filterExpression: Swift.String? = nil,
        groupName: Swift.String? = nil,
        insightsConfiguration: XRayClientTypes.InsightsConfiguration? = nil,
        tags: [XRayClientTypes.Tag]? = nil
    )
    {
        self.filterExpression = filterExpression
        self.groupName = groupName
        self.insightsConfiguration = insightsConfiguration
        self.tags = tags
    }
}

extension XRayClientTypes {
    /// Details and metadata for a group.
    public struct Group {
        /// The filter expression defining the parameters to include traces.
        public var filterExpression: Swift.String?
        /// The Amazon Resource Name (ARN) of the group generated based on the GroupName.
        public var groupARN: Swift.String?
        /// The unique case-sensitive name of the group.
        public var groupName: Swift.String?
        /// The structure containing configurations related to insights.
        ///
        /// * The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.
        ///
        /// * The NotificationsEnabled boolean can be set to true to enable insights notifications through Amazon EventBridge for the group.
        public var insightsConfiguration: XRayClientTypes.InsightsConfiguration?

        public init(
            filterExpression: Swift.String? = nil,
            groupARN: Swift.String? = nil,
            groupName: Swift.String? = nil,
            insightsConfiguration: XRayClientTypes.InsightsConfiguration? = nil
        )
        {
            self.filterExpression = filterExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
        }
    }

}

public struct CreateGroupOutput {
    /// The group that was created. Contains the name of the group that was created, the Amazon Resource Name (ARN) of the group that was generated based on the group name, the filter expression, and the insight configuration that was assigned to the group.
    public var group: XRayClientTypes.Group?

    public init(
        group: XRayClientTypes.Group? = nil
    )
    {
        self.group = group
    }
}

/// You have reached the maximum number of sampling rules.
public struct RuleLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RuleLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension XRayClientTypes {
    /// A sampling rule that services use to decide whether to instrument a request. Rule fields can match properties of the service, or properties of a request. The service can ignore rules that don't match its properties.
    public struct SamplingRule {
        /// Matches attributes derived from the request.
        public var attributes: [Swift.String: Swift.String]?
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        /// This member is required.
        public var fixedRate: Swift.Double
        /// Matches the hostname from a request URL.
        /// This member is required.
        public var host: Swift.String?
        /// Matches the HTTP method of a request.
        /// This member is required.
        public var httpMethod: Swift.String?
        /// The priority of the sampling rule.
        /// This member is required.
        public var priority: Swift.Int?
        /// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        /// This member is required.
        public var reservoirSize: Swift.Int
        /// Matches the ARN of the Amazon Web Services resource on which the service runs.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public var ruleARN: Swift.String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public var ruleName: Swift.String?
        /// Matches the name that the service uses to identify itself in segments.
        /// This member is required.
        public var serviceName: Swift.String?
        /// Matches the origin that the service uses to identify its type in segments.
        /// This member is required.
        public var serviceType: Swift.String?
        /// Matches the path from a request URL.
        /// This member is required.
        public var urlPath: Swift.String?
        /// The version of the sampling rule format (1).
        /// This member is required.
        public var version: Swift.Int?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            fixedRate: Swift.Double = 0.0,
            host: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            priority: Swift.Int? = nil,
            reservoirSize: Swift.Int = 0,
            resourceARN: Swift.String? = nil,
            ruleARN: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceType: Swift.String? = nil,
            urlPath: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.attributes = attributes
            self.fixedRate = fixedRate
            self.host = host
            self.httpMethod = httpMethod
            self.priority = priority
            self.reservoirSize = reservoirSize
            self.resourceARN = resourceARN
            self.ruleARN = ruleARN
            self.ruleName = ruleName
            self.serviceName = serviceName
            self.serviceType = serviceType
            self.urlPath = urlPath
            self.version = version
        }
    }

}

public struct CreateSamplingRuleInput {
    /// The rule definition.
    /// This member is required.
    public var samplingRule: XRayClientTypes.SamplingRule?
    /// A map that contains one or more tag keys and tag values to attach to an X-Ray sampling rule. For more information about ways to use tags, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference. The following restrictions apply to tags:
    ///
    /// * Maximum number of user-applied tags per resource: 50
    ///
    /// * Maximum tag key length: 128 Unicode characters
    ///
    /// * Maximum tag value length: 256 Unicode characters
    ///
    /// * Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Don't use aws: as a prefix for keys; it's reserved for Amazon Web Services use.
    public var tags: [XRayClientTypes.Tag]?

    public init(
        samplingRule: XRayClientTypes.SamplingRule? = nil,
        tags: [XRayClientTypes.Tag]? = nil
    )
    {
        self.samplingRule = samplingRule
        self.tags = tags
    }
}

extension XRayClientTypes {
    /// A [SamplingRule](https://docs.aws.amazon.com/xray/latest/api/API_SamplingRule.html) and its metadata.
    public struct SamplingRuleRecord {
        /// When the rule was created.
        public var createdAt: Foundation.Date?
        /// When the rule was last modified.
        public var modifiedAt: Foundation.Date?
        /// The sampling rule.
        public var samplingRule: XRayClientTypes.SamplingRule?

        public init(
            createdAt: Foundation.Date? = nil,
            modifiedAt: Foundation.Date? = nil,
            samplingRule: XRayClientTypes.SamplingRule? = nil
        )
        {
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.samplingRule = samplingRule
        }
    }

}

public struct CreateSamplingRuleOutput {
    /// The saved rule definition and metadata.
    public var samplingRuleRecord: XRayClientTypes.SamplingRuleRecord?

    public init(
        samplingRuleRecord: XRayClientTypes.SamplingRuleRecord? = nil
    )
    {
        self.samplingRuleRecord = samplingRuleRecord
    }
}

public struct DeleteGroupInput {
    /// The ARN of the group that was generated on creation.
    public var groupARN: Swift.String?
    /// The case-sensitive name of the group.
    public var groupName: Swift.String?

    public init(
        groupARN: Swift.String? = nil,
        groupName: Swift.String? = nil
    )
    {
        self.groupARN = groupARN
        self.groupName = groupName
    }
}

public struct DeleteGroupOutput {

    public init() { }
}

/// A policy revision id was provided which does not match the latest policy revision. This exception is also if a policy revision id of 0 is provided via PutResourcePolicy and a policy with the same name already exists.
public struct InvalidPolicyRevisionIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPolicyRevisionIdException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteResourcePolicyInput {
    /// The name of the resource policy to delete.
    /// This member is required.
    public var policyName: Swift.String?
    /// Specifies a specific policy revision to delete. Provide a PolicyRevisionId to ensure an atomic delete operation. If the provided revision id does not match the latest policy revision id, an InvalidPolicyRevisionIdException exception is returned.
    public var policyRevisionId: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        policyRevisionId: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.policyRevisionId = policyRevisionId
    }
}

public struct DeleteResourcePolicyOutput {

    public init() { }
}

public struct DeleteSamplingRuleInput {
    /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
    public var ruleARN: Swift.String?
    /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
    public var ruleName: Swift.String?

    public init(
        ruleARN: Swift.String? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.ruleARN = ruleARN
        self.ruleName = ruleName
    }
}

public struct DeleteSamplingRuleOutput {
    /// The deleted rule definition and metadata.
    public var samplingRuleRecord: XRayClientTypes.SamplingRuleRecord?

    public init(
        samplingRuleRecord: XRayClientTypes.SamplingRuleRecord? = nil
    )
    {
        self.samplingRuleRecord = samplingRuleRecord
    }
}

public struct GetEncryptionConfigInput {

    public init() { }
}

extension XRayClientTypes {

    public enum EncryptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionStatus] {
            return [
                .active,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension XRayClientTypes {

    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kms
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kms,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kms: return "KMS"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension XRayClientTypes {
    /// A configuration document that specifies encryption configuration settings.
    public struct EncryptionConfig {
        /// The ID of the KMS key used for encryption, if applicable.
        public var keyId: Swift.String?
        /// The encryption status. While the status is UPDATING, X-Ray may encrypt data with a combination of the new and old settings.
        public var status: XRayClientTypes.EncryptionStatus?
        /// The type of encryption. Set to KMS for encryption with KMS keys. Set to NONE for default encryption.
        public var type: XRayClientTypes.EncryptionType?

        public init(
            keyId: Swift.String? = nil,
            status: XRayClientTypes.EncryptionStatus? = nil,
            type: XRayClientTypes.EncryptionType? = nil
        )
        {
            self.keyId = keyId
            self.status = status
            self.type = type
        }
    }

}

public struct GetEncryptionConfigOutput {
    /// The encryption configuration document.
    public var encryptionConfig: XRayClientTypes.EncryptionConfig?

    public init(
        encryptionConfig: XRayClientTypes.EncryptionConfig? = nil
    )
    {
        self.encryptionConfig = encryptionConfig
    }
}

public struct GetGroupInput {
    /// The ARN of the group that was generated on creation.
    public var groupARN: Swift.String?
    /// The case-sensitive name of the group.
    public var groupName: Swift.String?

    public init(
        groupARN: Swift.String? = nil,
        groupName: Swift.String? = nil
    )
    {
        self.groupARN = groupARN
        self.groupName = groupName
    }
}

public struct GetGroupOutput {
    /// The group that was requested. Contains the name of the group, the ARN of the group, the filter expression, and the insight configuration assigned to the group.
    public var group: XRayClientTypes.Group?

    public init(
        group: XRayClientTypes.Group? = nil
    )
    {
        self.group = group
    }
}

public struct GetGroupsInput {
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension XRayClientTypes {
    /// Details for a group without metadata.
    public struct GroupSummary {
        /// The filter expression defining the parameters to include traces.
        public var filterExpression: Swift.String?
        /// The ARN of the group generated based on the GroupName.
        public var groupARN: Swift.String?
        /// The unique case-sensitive name of the group.
        public var groupName: Swift.String?
        /// The structure containing configurations related to insights.
        ///
        /// * The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.
        ///
        /// * The NotificationsEnabled boolean can be set to true to enable insights notifications. Notifications can only be enabled on a group with InsightsEnabled set to true.
        public var insightsConfiguration: XRayClientTypes.InsightsConfiguration?

        public init(
            filterExpression: Swift.String? = nil,
            groupARN: Swift.String? = nil,
            groupName: Swift.String? = nil,
            insightsConfiguration: XRayClientTypes.InsightsConfiguration? = nil
        )
        {
            self.filterExpression = filterExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
        }
    }

}

public struct GetGroupsOutput {
    /// The collection of all active groups.
    public var groups: [XRayClientTypes.GroupSummary]?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        groups: [XRayClientTypes.GroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

public struct GetInsightInput {
    /// The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.
    /// This member is required.
    public var insightId: Swift.String?

    public init(
        insightId: Swift.String? = nil
    )
    {
        self.insightId = insightId
    }
}

extension XRayClientTypes {

    public enum InsightCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fault
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightCategory] {
            return [
                .fault
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fault: return "FAULT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension XRayClientTypes {
    /// Statistics that describe how the incident has impacted a service.
    public struct RequestImpactStatistics {
        /// The number of requests that have resulted in a fault,
        public var faultCount: Swift.Int?
        /// The number of successful requests.
        public var okCount: Swift.Int?
        /// The total number of requests to the service.
        public var totalCount: Swift.Int?

        public init(
            faultCount: Swift.Int? = nil,
            okCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil
        )
        {
            self.faultCount = faultCount
            self.okCount = okCount
            self.totalCount = totalCount
        }
    }

}

extension XRayClientTypes {

    public enum InsightState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case closed
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightState] {
            return [
                .active,
                .closed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .closed: return "CLOSED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension XRayClientTypes {
    /// When fault rates go outside of the expected range, X-Ray creates an insight. Insights tracks emergent issues within your applications.
    public struct Insight {
        /// The categories that label and describe the type of insight.
        public var categories: [XRayClientTypes.InsightCategory]?
        /// The impact statistics of the client side service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public var clientRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight ended.
        public var endTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the group that the insight belongs to.
        public var groupARN: Swift.String?
        /// The name of the group that the insight belongs to.
        public var groupName: Swift.String?
        /// The insights unique identifier.
        public var insightId: Swift.String?
        ///
        public var rootCauseServiceId: XRayClientTypes.ServiceId?
        /// The impact statistics of the root cause service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public var rootCauseServiceRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight began.
        public var startTime: Foundation.Date?
        /// The current state of the insight.
        public var state: XRayClientTypes.InsightState?
        /// A brief description of the insight.
        public var summary: Swift.String?
        /// The service within the insight that is most impacted by the incident.
        public var topAnomalousServices: [XRayClientTypes.AnomalousService]?

        public init(
            categories: [XRayClientTypes.InsightCategory]? = nil,
            clientRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics? = nil,
            endTime: Foundation.Date? = nil,
            groupARN: Swift.String? = nil,
            groupName: Swift.String? = nil,
            insightId: Swift.String? = nil,
            rootCauseServiceId: XRayClientTypes.ServiceId? = nil,
            rootCauseServiceRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics? = nil,
            startTime: Foundation.Date? = nil,
            state: XRayClientTypes.InsightState? = nil,
            summary: Swift.String? = nil,
            topAnomalousServices: [XRayClientTypes.AnomalousService]? = nil
        )
        {
            self.categories = categories
            self.clientRequestImpactStatistics = clientRequestImpactStatistics
            self.endTime = endTime
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightId = insightId
            self.rootCauseServiceId = rootCauseServiceId
            self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
            self.startTime = startTime
            self.state = state
            self.summary = summary
            self.topAnomalousServices = topAnomalousServices
        }
    }

}

public struct GetInsightOutput {
    /// The summary information of an insight.
    public var insight: XRayClientTypes.Insight?

    public init(
        insight: XRayClientTypes.Insight? = nil
    )
    {
        self.insight = insight
    }
}

public struct GetInsightEventsInput {
    /// The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.
    /// This member is required.
    public var insightId: Swift.String?
    /// Used to retrieve at most the specified value of events.
    public var maxResults: Swift.Int?
    /// Specify the pagination token returned by a previous request to retrieve the next page of events.
    public var nextToken: Swift.String?

    public init(
        insightId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.insightId = insightId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension XRayClientTypes {
    /// X-Ray reevaluates insights periodically until they are resolved, and records each intermediate state in an event. You can review incident events in the Impact Timeline on the Inspect page in the X-Ray console.
    public struct InsightEvent {
        /// The impact statistics of the client side service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public var clientRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics?
        /// The time, in Unix seconds, at which the event was recorded.
        public var eventTime: Foundation.Date?
        /// The impact statistics of the root cause service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public var rootCauseServiceRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics?
        /// A brief description of the event.
        public var summary: Swift.String?
        /// The service during the event that is most impacted by the incident.
        public var topAnomalousServices: [XRayClientTypes.AnomalousService]?

        public init(
            clientRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics? = nil,
            eventTime: Foundation.Date? = nil,
            rootCauseServiceRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics? = nil,
            summary: Swift.String? = nil,
            topAnomalousServices: [XRayClientTypes.AnomalousService]? = nil
        )
        {
            self.clientRequestImpactStatistics = clientRequestImpactStatistics
            self.eventTime = eventTime
            self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
            self.summary = summary
            self.topAnomalousServices = topAnomalousServices
        }
    }

}

public struct GetInsightEventsOutput {
    /// A detailed description of the event. This includes the time of the event, client and root cause impact statistics, and the top anomalous service at the time of the event.
    public var insightEvents: [XRayClientTypes.InsightEvent]?
    /// Use this token to retrieve the next page of insight events.
    public var nextToken: Swift.String?

    public init(
        insightEvents: [XRayClientTypes.InsightEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.insightEvents = insightEvents
        self.nextToken = nextToken
    }
}

public struct GetInsightImpactGraphInput {
    /// The estimated end time of the insight, in Unix time seconds. The EndTime is exclusive of the value provided. The time range between the start time and end time can't be more than six hours.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.
    /// This member is required.
    public var insightId: Swift.String?
    /// Specify the pagination token returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The estimated start time of the insight, in Unix time seconds. The StartTime is inclusive of the value provided and can't be more than 30 days old.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        insightId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.insightId = insightId
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

extension XRayClientTypes {
    /// The connection between two service in an insight impact graph.
    public struct InsightImpactGraphEdge {
        /// Identifier of the edge. Unique within a service map.
        public var referenceId: Swift.Int?

        public init(
            referenceId: Swift.Int? = nil
        )
        {
            self.referenceId = referenceId
        }
    }

}

extension XRayClientTypes {
    /// Information about an application that processed requests, users that made requests, or downstream services, resources, and applications that an application used.
    public struct InsightImpactGraphService {
        /// Identifier of the Amazon Web Services account in which the service runs.
        public var accountId: Swift.String?
        /// Connections to downstream services.
        public var edges: [XRayClientTypes.InsightImpactGraphEdge]?
        /// The canonical name of the service.
        public var name: Swift.String?
        /// A list of names for the service, including the canonical name.
        public var names: [Swift.String]?
        /// Identifier for the service. Unique within the service map.
        public var referenceId: Swift.Int?
        /// Identifier for the service. Unique within the service map.
        ///
        /// * Amazon Web Services Resource - The type of an Amazon Web Services resource. For example, AWS::EC2::Instance for an application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.
        ///
        /// * Amazon Web Services Service - The type of an Amazon Web Services service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.
        ///
        /// * Amazon Web Services Service - The type of an Amazon Web Services service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.
        ///
        /// * remote - A downstream service of indeterminate type.
        public var type: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            edges: [XRayClientTypes.InsightImpactGraphEdge]? = nil,
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            referenceId: Swift.Int? = nil,
            type: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.edges = edges
            self.name = name
            self.names = names
            self.referenceId = referenceId
            self.type = type
        }
    }

}

public struct GetInsightImpactGraphOutput {
    /// The provided end time.
    public var endTime: Foundation.Date?
    /// The insight's unique identifier.
    public var insightId: Swift.String?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The time, in Unix seconds, at which the service graph ended.
    public var serviceGraphEndTime: Foundation.Date?
    /// The time, in Unix seconds, at which the service graph started.
    public var serviceGraphStartTime: Foundation.Date?
    /// The Amazon Web Services instrumented services related to the insight.
    public var services: [XRayClientTypes.InsightImpactGraphService]?
    /// The provided start time.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        insightId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceGraphEndTime: Foundation.Date? = nil,
        serviceGraphStartTime: Foundation.Date? = nil,
        services: [XRayClientTypes.InsightImpactGraphService]? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.insightId = insightId
        self.nextToken = nextToken
        self.serviceGraphEndTime = serviceGraphEndTime
        self.serviceGraphStartTime = serviceGraphStartTime
        self.services = services
        self.startTime = startTime
    }
}

public struct GetInsightSummariesInput {
    /// The end of the time frame in which the insights ended. The end time can't be more than 30 days old.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the group. Required if the GroupName isn't provided.
    public var groupARN: Swift.String?
    /// The name of the group. Required if the GroupARN isn't provided.
    public var groupName: Swift.String?
    /// The maximum number of results to display.
    public var maxResults: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The beginning of the time frame in which the insights started. The start time can't be more than 30 days old.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// The list of insight states.
    public var states: [XRayClientTypes.InsightState]?

    public init(
        endTime: Foundation.Date? = nil,
        groupARN: Swift.String? = nil,
        groupName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        states: [XRayClientTypes.InsightState]? = nil
    )
    {
        self.endTime = endTime
        self.groupARN = groupARN
        self.groupName = groupName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.states = states
    }
}

extension XRayClientTypes {
    /// Information that describes an insight.
    public struct InsightSummary {
        /// Categories The categories that label and describe the type of insight.
        public var categories: [XRayClientTypes.InsightCategory]?
        /// The impact statistics of the client side service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public var clientRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight ended.
        public var endTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the group that the insight belongs to.
        public var groupARN: Swift.String?
        /// The name of the group that the insight belongs to.
        public var groupName: Swift.String?
        /// The insights unique identifier.
        public var insightId: Swift.String?
        /// The time, in Unix seconds, that the insight was last updated.
        public var lastUpdateTime: Foundation.Date?
        ///
        public var rootCauseServiceId: XRayClientTypes.ServiceId?
        /// The impact statistics of the root cause service. This includes the number of requests to the client service and whether the requests were faults or okay.
        public var rootCauseServiceRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics?
        /// The time, in Unix seconds, at which the insight began.
        public var startTime: Foundation.Date?
        /// The current state of the insight.
        public var state: XRayClientTypes.InsightState?
        /// A brief description of the insight.
        public var summary: Swift.String?
        /// The service within the insight that is most impacted by the incident.
        public var topAnomalousServices: [XRayClientTypes.AnomalousService]?

        public init(
            categories: [XRayClientTypes.InsightCategory]? = nil,
            clientRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics? = nil,
            endTime: Foundation.Date? = nil,
            groupARN: Swift.String? = nil,
            groupName: Swift.String? = nil,
            insightId: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            rootCauseServiceId: XRayClientTypes.ServiceId? = nil,
            rootCauseServiceRequestImpactStatistics: XRayClientTypes.RequestImpactStatistics? = nil,
            startTime: Foundation.Date? = nil,
            state: XRayClientTypes.InsightState? = nil,
            summary: Swift.String? = nil,
            topAnomalousServices: [XRayClientTypes.AnomalousService]? = nil
        )
        {
            self.categories = categories
            self.clientRequestImpactStatistics = clientRequestImpactStatistics
            self.endTime = endTime
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightId = insightId
            self.lastUpdateTime = lastUpdateTime
            self.rootCauseServiceId = rootCauseServiceId
            self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
            self.startTime = startTime
            self.state = state
            self.summary = summary
            self.topAnomalousServices = topAnomalousServices
        }
    }

}

public struct GetInsightSummariesOutput {
    /// The summary of each insight within the group matching the provided filters. The summary contains the InsightID, start and end time, the root cause service, the root cause and client impact statistics, the top anomalous services, and the status of the insight.
    public var insightSummaries: [XRayClientTypes.InsightSummary]?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        insightSummaries: [XRayClientTypes.InsightSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.insightSummaries = insightSummaries
        self.nextToken = nextToken
    }
}

public struct GetSamplingRulesInput {
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

public struct GetSamplingRulesOutput {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// Rule definitions and metadata.
    public var samplingRuleRecords: [XRayClientTypes.SamplingRuleRecord]?

    public init(
        nextToken: Swift.String? = nil,
        samplingRuleRecords: [XRayClientTypes.SamplingRuleRecord]? = nil
    )
    {
        self.nextToken = nextToken
        self.samplingRuleRecords = samplingRuleRecords
    }
}

public struct GetSamplingStatisticSummariesInput {
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension XRayClientTypes {
    /// Aggregated request sampling data for a sampling rule across all services for a 10-second window.
    public struct SamplingStatisticSummary {
        /// The number of requests recorded with borrowed reservoir quota.
        public var borrowCount: Swift.Int
        /// The number of requests that matched the rule.
        public var requestCount: Swift.Int
        /// The name of the sampling rule.
        public var ruleName: Swift.String?
        /// The number of requests recorded.
        public var sampledCount: Swift.Int
        /// The start time of the reporting window.
        public var timestamp: Foundation.Date?

        public init(
            borrowCount: Swift.Int = 0,
            requestCount: Swift.Int = 0,
            ruleName: Swift.String? = nil,
            sampledCount: Swift.Int = 0,
            timestamp: Foundation.Date? = nil
        )
        {
            self.borrowCount = borrowCount
            self.requestCount = requestCount
            self.ruleName = ruleName
            self.sampledCount = sampledCount
            self.timestamp = timestamp
        }
    }

}

public struct GetSamplingStatisticSummariesOutput {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// Information about the number of requests instrumented for each sampling rule.
    public var samplingStatisticSummaries: [XRayClientTypes.SamplingStatisticSummary]?

    public init(
        nextToken: Swift.String? = nil,
        samplingStatisticSummaries: [XRayClientTypes.SamplingStatisticSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.samplingStatisticSummaries = samplingStatisticSummaries
    }
}

extension XRayClientTypes {
    /// Request sampling results for a single rule from a service. Results are for the last 10 seconds unless the service has been assigned a longer reporting interval after a previous call to [GetSamplingTargets](https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingTargets.html).
    public struct SamplingStatisticsDocument {
        /// The number of requests recorded with borrowed reservoir quota.
        public var borrowCount: Swift.Int
        /// A unique identifier for the service in hexadecimal.
        /// This member is required.
        public var clientID: Swift.String?
        /// The number of requests that matched the rule.
        /// This member is required.
        public var requestCount: Swift.Int
        /// The name of the sampling rule.
        /// This member is required.
        public var ruleName: Swift.String?
        /// The number of requests recorded.
        /// This member is required.
        public var sampledCount: Swift.Int
        /// The current time.
        /// This member is required.
        public var timestamp: Foundation.Date?

        public init(
            borrowCount: Swift.Int = 0,
            clientID: Swift.String? = nil,
            requestCount: Swift.Int = 0,
            ruleName: Swift.String? = nil,
            sampledCount: Swift.Int = 0,
            timestamp: Foundation.Date? = nil
        )
        {
            self.borrowCount = borrowCount
            self.clientID = clientID
            self.requestCount = requestCount
            self.ruleName = ruleName
            self.sampledCount = sampledCount
            self.timestamp = timestamp
        }
    }

}

public struct GetSamplingTargetsInput {
    /// Information about rules that the service is using to sample requests.
    /// This member is required.
    public var samplingStatisticsDocuments: [XRayClientTypes.SamplingStatisticsDocument]?

    public init(
        samplingStatisticsDocuments: [XRayClientTypes.SamplingStatisticsDocument]? = nil
    )
    {
        self.samplingStatisticsDocuments = samplingStatisticsDocuments
    }
}

extension XRayClientTypes {
    /// Temporary changes to a sampling rule configuration. To meet the global sampling target for a rule, X-Ray calculates a new reservoir for each service based on the recent sampling results of all services that called [GetSamplingTargets](https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingTargets.html).
    public struct SamplingTargetDocument {
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public var fixedRate: Swift.Double
        /// The number of seconds for the service to wait before getting sampling targets again.
        public var interval: Swift.Int?
        /// The number of requests per second that X-Ray allocated for this service.
        public var reservoirQuota: Swift.Int?
        /// When the reservoir quota expires.
        public var reservoirQuotaTTL: Foundation.Date?
        /// The name of the sampling rule.
        public var ruleName: Swift.String?

        public init(
            fixedRate: Swift.Double = 0.0,
            interval: Swift.Int? = nil,
            reservoirQuota: Swift.Int? = nil,
            reservoirQuotaTTL: Foundation.Date? = nil,
            ruleName: Swift.String? = nil
        )
        {
            self.fixedRate = fixedRate
            self.interval = interval
            self.reservoirQuota = reservoirQuota
            self.reservoirQuotaTTL = reservoirQuotaTTL
            self.ruleName = ruleName
        }
    }

}

extension XRayClientTypes {
    /// Sampling statistics from a call to [GetSamplingTargets](https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingTargets.html) that X-Ray could not process.
    public struct UnprocessedStatistics {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?
        /// The name of the sampling rule.
        public var ruleName: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil,
            ruleName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
            self.ruleName = ruleName
        }
    }

}

public struct GetSamplingTargetsOutput {
    /// The last time a user changed the sampling rule configuration. If the sampling rule configuration changed since the service last retrieved it, the service should call [GetSamplingRules](https://docs.aws.amazon.com/xray/latest/api/API_GetSamplingRules.html) to get the latest version.
    public var lastRuleModification: Foundation.Date?
    /// Updated rules that the service should use to sample requests.
    public var samplingTargetDocuments: [XRayClientTypes.SamplingTargetDocument]?
    /// Information about [SamplingStatisticsDocument](https://docs.aws.amazon.com/xray/latest/api/API_SamplingStatisticsDocument.html) that X-Ray could not process.
    public var unprocessedStatistics: [XRayClientTypes.UnprocessedStatistics]?

    public init(
        lastRuleModification: Foundation.Date? = nil,
        samplingTargetDocuments: [XRayClientTypes.SamplingTargetDocument]? = nil,
        unprocessedStatistics: [XRayClientTypes.UnprocessedStatistics]? = nil
    )
    {
        self.lastRuleModification = lastRuleModification
        self.samplingTargetDocuments = samplingTargetDocuments
        self.unprocessedStatistics = unprocessedStatistics
    }
}

public struct GetServiceGraphInput {
    /// The end of the timeframe for which to generate a graph.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of a group based on which you want to generate a graph.
    public var groupARN: Swift.String?
    /// The name of a group based on which you want to generate a graph.
    public var groupName: Swift.String?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The start of the time frame for which to generate a graph.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        groupARN: Swift.String? = nil,
        groupName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.groupARN = groupARN
        self.groupName = groupName
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

extension XRayClientTypes {
    /// An entry in a histogram for a statistic. A histogram maps the range of observed values on the X axis, and the prevalence of each value on the Y axis.
    public struct HistogramEntry {
        /// The prevalence of the entry.
        public var count: Swift.Int
        /// The value of the entry.
        public var value: Swift.Double

        public init(
            count: Swift.Int = 0,
            value: Swift.Double = 0.0
        )
        {
            self.count = count
            self.value = value
        }
    }

}

extension XRayClientTypes {
    /// Information about requests that failed with a 4xx Client Error status code.
    public struct ErrorStatistics {
        /// The number of requests that failed with untracked 4xx Client Error status codes.
        public var otherCount: Swift.Int?
        /// The number of requests that failed with a 419 throttling status code.
        public var throttleCount: Swift.Int?
        /// The total number of requests that failed with a 4xx Client Error status code.
        public var totalCount: Swift.Int?

        public init(
            otherCount: Swift.Int? = nil,
            throttleCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil
        )
        {
            self.otherCount = otherCount
            self.throttleCount = throttleCount
            self.totalCount = totalCount
        }
    }

}

extension XRayClientTypes {
    /// Information about requests that failed with a 5xx Server Error status code.
    public struct FaultStatistics {
        /// The number of requests that failed with untracked 5xx Server Error status codes.
        public var otherCount: Swift.Int?
        /// The total number of requests that failed with a 5xx Server Error status code.
        public var totalCount: Swift.Int?

        public init(
            otherCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil
        )
        {
            self.otherCount = otherCount
            self.totalCount = totalCount
        }
    }

}

extension XRayClientTypes {
    /// Response statistics for an edge.
    public struct EdgeStatistics {
        /// Information about requests that failed with a 4xx Client Error status code.
        public var errorStatistics: XRayClientTypes.ErrorStatistics?
        /// Information about requests that failed with a 5xx Server Error status code.
        public var faultStatistics: XRayClientTypes.FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public var okCount: Swift.Int?
        /// The total number of completed requests.
        public var totalCount: Swift.Int?
        /// The aggregate response time of completed requests.
        public var totalResponseTime: Swift.Double?

        public init(
            errorStatistics: XRayClientTypes.ErrorStatistics? = nil,
            faultStatistics: XRayClientTypes.FaultStatistics? = nil,
            okCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil,
            totalResponseTime: Swift.Double? = nil
        )
        {
            self.errorStatistics = errorStatistics
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.totalCount = totalCount
            self.totalResponseTime = totalResponseTime
        }
    }

}

extension XRayClientTypes {
    /// Information about a connection between two services. An edge can be a synchronous connection, such as typical call between client and service, or an asynchronous link, such as a Lambda function which retrieves an event from an SNS queue.
    public struct Edge {
        /// Aliases for the edge.
        public var aliases: [XRayClientTypes.Alias]?
        /// Describes an asynchronous connection, with a value of link.
        public var edgeType: Swift.String?
        /// The end time of the last segment on the edge.
        public var endTime: Foundation.Date?
        /// A histogram that maps the spread of event age when received by consumers. Age is calculated each time an event is received. Only populated when EdgeType is link.
        public var receivedEventAgeHistogram: [XRayClientTypes.HistogramEntry]?
        /// Identifier of the edge. Unique within a service map.
        public var referenceId: Swift.Int?
        /// A histogram that maps the spread of client response times on an edge. Only populated for synchronous edges.
        public var responseTimeHistogram: [XRayClientTypes.HistogramEntry]?
        /// The start time of the first segment on the edge.
        public var startTime: Foundation.Date?
        /// Response statistics for segments on the edge.
        public var summaryStatistics: XRayClientTypes.EdgeStatistics?

        public init(
            aliases: [XRayClientTypes.Alias]? = nil,
            edgeType: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            receivedEventAgeHistogram: [XRayClientTypes.HistogramEntry]? = nil,
            referenceId: Swift.Int? = nil,
            responseTimeHistogram: [XRayClientTypes.HistogramEntry]? = nil,
            startTime: Foundation.Date? = nil,
            summaryStatistics: XRayClientTypes.EdgeStatistics? = nil
        )
        {
            self.aliases = aliases
            self.edgeType = edgeType
            self.endTime = endTime
            self.receivedEventAgeHistogram = receivedEventAgeHistogram
            self.referenceId = referenceId
            self.responseTimeHistogram = responseTimeHistogram
            self.startTime = startTime
            self.summaryStatistics = summaryStatistics
        }
    }

}

extension XRayClientTypes {
    /// Response statistics for a service.
    public struct ServiceStatistics {
        /// Information about requests that failed with a 4xx Client Error status code.
        public var errorStatistics: XRayClientTypes.ErrorStatistics?
        /// Information about requests that failed with a 5xx Server Error status code.
        public var faultStatistics: XRayClientTypes.FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public var okCount: Swift.Int?
        /// The total number of completed requests.
        public var totalCount: Swift.Int?
        /// The aggregate response time of completed requests.
        public var totalResponseTime: Swift.Double?

        public init(
            errorStatistics: XRayClientTypes.ErrorStatistics? = nil,
            faultStatistics: XRayClientTypes.FaultStatistics? = nil,
            okCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil,
            totalResponseTime: Swift.Double? = nil
        )
        {
            self.errorStatistics = errorStatistics
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.totalCount = totalCount
            self.totalResponseTime = totalResponseTime
        }
    }

}

extension XRayClientTypes {
    /// Information about an application that processed requests, users that made requests, or downstream services, resources, and applications that an application used.
    public struct Service {
        /// Identifier of the Amazon Web Services account in which the service runs.
        public var accountId: Swift.String?
        /// A histogram that maps the spread of service durations.
        public var durationHistogram: [XRayClientTypes.HistogramEntry]?
        /// Connections to downstream services.
        public var edges: [XRayClientTypes.Edge]?
        /// The end time of the last segment that the service generated.
        public var endTime: Foundation.Date?
        /// The canonical name of the service.
        public var name: Swift.String?
        /// A list of names for the service, including the canonical name.
        public var names: [Swift.String]?
        /// Identifier for the service. Unique within the service map.
        public var referenceId: Swift.Int?
        /// A histogram that maps the spread of service response times.
        public var responseTimeHistogram: [XRayClientTypes.HistogramEntry]?
        /// Indicates that the service was the first service to process a request.
        public var root: Swift.Bool?
        /// The start time of the first segment that the service generated.
        public var startTime: Foundation.Date?
        /// The service's state.
        public var state: Swift.String?
        /// Aggregated statistics for the service.
        public var summaryStatistics: XRayClientTypes.ServiceStatistics?
        /// The type of service.
        ///
        /// * Amazon Web Services Resource - The type of an Amazon Web Services resource. For example, AWS::EC2::Instance for an application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.
        ///
        /// * Amazon Web Services Service - The type of an Amazon Web Services service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.
        ///
        /// * client - Represents the clients that sent requests to a root service.
        ///
        /// * remote - A downstream service of indeterminate type.
        public var type: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            durationHistogram: [XRayClientTypes.HistogramEntry]? = nil,
            edges: [XRayClientTypes.Edge]? = nil,
            endTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            referenceId: Swift.Int? = nil,
            responseTimeHistogram: [XRayClientTypes.HistogramEntry]? = nil,
            root: Swift.Bool? = nil,
            startTime: Foundation.Date? = nil,
            state: Swift.String? = nil,
            summaryStatistics: XRayClientTypes.ServiceStatistics? = nil,
            type: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.durationHistogram = durationHistogram
            self.edges = edges
            self.endTime = endTime
            self.name = name
            self.names = names
            self.referenceId = referenceId
            self.responseTimeHistogram = responseTimeHistogram
            self.root = root
            self.startTime = startTime
            self.state = state
            self.summaryStatistics = summaryStatistics
            self.type = type
        }
    }

}

public struct GetServiceGraphOutput {
    /// A flag indicating whether the group's filter expression has been consistent, or if the returned service graph may show traces from an older version of the group's filter expression.
    public var containsOldGroupVersions: Swift.Bool
    /// The end of the time frame for which the graph was generated.
    public var endTime: Foundation.Date?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The services that have processed a traced request during the specified time frame.
    public var services: [XRayClientTypes.Service]?
    /// The start of the time frame for which the graph was generated.
    public var startTime: Foundation.Date?

    public init(
        containsOldGroupVersions: Swift.Bool = false,
        endTime: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        services: [XRayClientTypes.Service]? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.containsOldGroupVersions = containsOldGroupVersions
        self.endTime = endTime
        self.nextToken = nextToken
        self.services = services
        self.startTime = startTime
    }
}

public struct GetTimeSeriesServiceStatisticsInput {
    /// The end of the time frame for which to aggregate statistics.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// A filter expression defining entities that will be aggregated for statistics. Supports ID, service, and edge functions. If no selector expression is specified, edge statistics are returned.
    public var entitySelectorExpression: Swift.String?
    /// The forecasted high and low fault count values. Forecast enabled requests require the EntitySelectorExpression ID be provided.
    public var forecastStatistics: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the group for which to pull statistics from.
    public var groupARN: Swift.String?
    /// The case-sensitive name of the group for which to pull statistics from.
    public var groupName: Swift.String?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// Aggregation period in seconds.
    public var period: Swift.Int?
    /// The start of the time frame for which to aggregate statistics.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        entitySelectorExpression: Swift.String? = nil,
        forecastStatistics: Swift.Bool? = nil,
        groupARN: Swift.String? = nil,
        groupName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        period: Swift.Int? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.entitySelectorExpression = entitySelectorExpression
        self.forecastStatistics = forecastStatistics
        self.groupARN = groupARN
        self.groupName = groupName
        self.nextToken = nextToken
        self.period = period
        self.startTime = startTime
    }
}

extension XRayClientTypes {
    /// The predicted high and low fault count. This is used to determine if a service has become anomalous and if an insight should be created.
    public struct ForecastStatistics {
        /// The upper limit of fault counts for a service.
        public var faultCountHigh: Swift.Int?
        /// The lower limit of fault counts for a service.
        public var faultCountLow: Swift.Int?

        public init(
            faultCountHigh: Swift.Int? = nil,
            faultCountLow: Swift.Int? = nil
        )
        {
            self.faultCountHigh = faultCountHigh
            self.faultCountLow = faultCountLow
        }
    }

}

extension XRayClientTypes {
    /// A list of TimeSeriesStatistic structures.
    public struct TimeSeriesServiceStatistics {
        /// Response statistics for an edge.
        public var edgeSummaryStatistics: XRayClientTypes.EdgeStatistics?
        /// The response time histogram for the selected entities.
        public var responseTimeHistogram: [XRayClientTypes.HistogramEntry]?
        /// The forecasted high and low fault count values.
        public var serviceForecastStatistics: XRayClientTypes.ForecastStatistics?
        /// Response statistics for a service.
        public var serviceSummaryStatistics: XRayClientTypes.ServiceStatistics?
        /// Timestamp of the window for which statistics are aggregated.
        public var timestamp: Foundation.Date?

        public init(
            edgeSummaryStatistics: XRayClientTypes.EdgeStatistics? = nil,
            responseTimeHistogram: [XRayClientTypes.HistogramEntry]? = nil,
            serviceForecastStatistics: XRayClientTypes.ForecastStatistics? = nil,
            serviceSummaryStatistics: XRayClientTypes.ServiceStatistics? = nil,
            timestamp: Foundation.Date? = nil
        )
        {
            self.edgeSummaryStatistics = edgeSummaryStatistics
            self.responseTimeHistogram = responseTimeHistogram
            self.serviceForecastStatistics = serviceForecastStatistics
            self.serviceSummaryStatistics = serviceSummaryStatistics
            self.timestamp = timestamp
        }
    }

}

public struct GetTimeSeriesServiceStatisticsOutput {
    /// A flag indicating whether or not a group's filter expression has been consistent, or if a returned aggregation might show statistics from an older version of the group's filter expression.
    public var containsOldGroupVersions: Swift.Bool
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The collection of statistics.
    public var timeSeriesServiceStatistics: [XRayClientTypes.TimeSeriesServiceStatistics]?

    public init(
        containsOldGroupVersions: Swift.Bool = false,
        nextToken: Swift.String? = nil,
        timeSeriesServiceStatistics: [XRayClientTypes.TimeSeriesServiceStatistics]? = nil
    )
    {
        self.containsOldGroupVersions = containsOldGroupVersions
        self.nextToken = nextToken
        self.timeSeriesServiceStatistics = timeSeriesServiceStatistics
    }
}

public struct GetTraceGraphInput {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// Trace IDs of requests for which to generate a service graph.
    /// This member is required.
    public var traceIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        traceIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.traceIds = traceIds
    }
}

public struct GetTraceGraphOutput {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The services that have processed one of the specified requests.
    public var services: [XRayClientTypes.Service]?

    public init(
        nextToken: Swift.String? = nil,
        services: [XRayClientTypes.Service]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

extension XRayClientTypes {

    public enum SamplingStrategyName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fixedrate
        case partialscan
        case sdkUnknown(Swift.String)

        public static var allCases: [SamplingStrategyName] {
            return [
                .fixedrate,
                .partialscan
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fixedrate: return "FixedRate"
            case .partialscan: return "PartialScan"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension XRayClientTypes {
    /// The name and value of a sampling rule to apply to a trace summary.
    public struct SamplingStrategy {
        /// The name of a sampling rule.
        public var name: XRayClientTypes.SamplingStrategyName?
        /// The value of a sampling rule.
        public var value: Swift.Double?

        public init(
            name: XRayClientTypes.SamplingStrategyName? = nil,
            value: Swift.Double? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension XRayClientTypes {

    public enum TimeRangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case event
        case service
        case traceid
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeRangeType] {
            return [
                .event,
                .service,
                .traceid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .event: return "Event"
            case .service: return "Service"
            case .traceid: return "TraceId"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetTraceSummariesInput {
    /// The end of the time frame for which to retrieve traces.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// Specify a filter expression to retrieve trace summaries for services or requests that meet certain requirements.
    public var filterExpression: Swift.String?
    /// Specify the pagination token returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Set to true to get summaries for only a subset of available traces.
    public var sampling: Swift.Bool?
    /// A parameter to indicate whether to enable sampling on trace summaries. Input parameters are Name and Value.
    public var samplingStrategy: XRayClientTypes.SamplingStrategy?
    /// The start of the time frame for which to retrieve traces.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// A parameter to indicate whether to query trace summaries by TraceId, Event (trace update time), or Service (segment end time).
    public var timeRangeType: XRayClientTypes.TimeRangeType?

    public init(
        endTime: Foundation.Date? = nil,
        filterExpression: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sampling: Swift.Bool? = nil,
        samplingStrategy: XRayClientTypes.SamplingStrategy? = nil,
        startTime: Foundation.Date? = nil,
        timeRangeType: XRayClientTypes.TimeRangeType? = nil
    )
    {
        self.endTime = endTime
        self.filterExpression = filterExpression
        self.nextToken = nextToken
        self.sampling = sampling
        self.samplingStrategy = samplingStrategy
        self.startTime = startTime
        self.timeRangeType = timeRangeType
    }
}

extension XRayClientTypes {
    /// The exception associated with a root cause.
    public struct RootCauseException {
        /// The message of the exception.
        public var message: Swift.String?
        /// The name of the exception.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension XRayClientTypes {
    /// A collection of segments and corresponding subsegments associated to a trace summary error.
    public struct ErrorRootCauseEntity {
        /// The types and messages of the exceptions.
        public var exceptions: [XRayClientTypes.RootCauseException]?
        /// The name of the entity.
        public var name: Swift.String?
        /// A flag that denotes a remote subsegment.
        public var remote: Swift.Bool?

        public init(
            exceptions: [XRayClientTypes.RootCauseException]? = nil,
            name: Swift.String? = nil,
            remote: Swift.Bool? = nil
        )
        {
            self.exceptions = exceptions
            self.name = name
            self.remote = remote
        }
    }

}

extension XRayClientTypes {
    /// A collection of fields identifying the services in a trace summary error.
    public struct ErrorRootCauseService {
        /// The account ID associated to the service.
        public var accountId: Swift.String?
        /// The path of root cause entities found on the service.
        public var entityPath: [XRayClientTypes.ErrorRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public var inferred: Swift.Bool?
        /// The service name.
        public var name: Swift.String?
        /// A collection of associated service names.
        public var names: [Swift.String]?
        /// The type associated to the service.
        public var type: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            entityPath: [XRayClientTypes.ErrorRootCauseEntity]? = nil,
            inferred: Swift.Bool? = nil,
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.type = type
        }
    }

}

extension XRayClientTypes {
    /// The root cause of a trace summary error.
    public struct ErrorRootCause {
        /// A flag that denotes that the root cause impacts the trace client.
        public var clientImpacting: Swift.Bool?
        /// A list of services corresponding to an error. A service identifies a segment and it contains a name, account ID, type, and inferred flag.
        public var services: [XRayClientTypes.ErrorRootCauseService]?

        public init(
            clientImpacting: Swift.Bool? = nil,
            services: [XRayClientTypes.ErrorRootCauseService]? = nil
        )
        {
            self.clientImpacting = clientImpacting
            self.services = services
        }
    }

}

extension XRayClientTypes {
    /// A collection of segments and corresponding subsegments associated to a trace summary fault error.
    public struct FaultRootCauseEntity {
        /// The types and messages of the exceptions.
        public var exceptions: [XRayClientTypes.RootCauseException]?
        /// The name of the entity.
        public var name: Swift.String?
        /// A flag that denotes a remote subsegment.
        public var remote: Swift.Bool?

        public init(
            exceptions: [XRayClientTypes.RootCauseException]? = nil,
            name: Swift.String? = nil,
            remote: Swift.Bool? = nil
        )
        {
            self.exceptions = exceptions
            self.name = name
            self.remote = remote
        }
    }

}

extension XRayClientTypes {
    /// A collection of fields identifying the services in a trace summary fault.
    public struct FaultRootCauseService {
        /// The account ID associated to the service.
        public var accountId: Swift.String?
        /// The path of root cause entities found on the service.
        public var entityPath: [XRayClientTypes.FaultRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public var inferred: Swift.Bool?
        /// The service name.
        public var name: Swift.String?
        /// A collection of associated service names.
        public var names: [Swift.String]?
        /// The type associated to the service.
        public var type: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            entityPath: [XRayClientTypes.FaultRootCauseEntity]? = nil,
            inferred: Swift.Bool? = nil,
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.type = type
        }
    }

}

extension XRayClientTypes {
    /// The root cause information for a trace summary fault.
    public struct FaultRootCause {
        /// A flag that denotes that the root cause impacts the trace client.
        public var clientImpacting: Swift.Bool?
        /// A list of corresponding services. A service identifies a segment and it contains a name, account ID, type, and inferred flag.
        public var services: [XRayClientTypes.FaultRootCauseService]?

        public init(
            clientImpacting: Swift.Bool? = nil,
            services: [XRayClientTypes.FaultRootCauseService]? = nil
        )
        {
            self.clientImpacting = clientImpacting
            self.services = services
        }
    }

}

extension XRayClientTypes {
    /// Information about an HTTP request.
    public struct Http {
        /// The IP address of the requestor.
        public var clientIp: Swift.String?
        /// The request method.
        public var httpMethod: Swift.String?
        /// The response status.
        public var httpStatus: Swift.Int?
        /// The request URL.
        public var httpURL: Swift.String?
        /// The request's user agent string.
        public var userAgent: Swift.String?

        public init(
            clientIp: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            httpStatus: Swift.Int? = nil,
            httpURL: Swift.String? = nil,
            userAgent: Swift.String? = nil
        )
        {
            self.clientIp = clientIp
            self.httpMethod = httpMethod
            self.httpStatus = httpStatus
            self.httpURL = httpURL
            self.userAgent = userAgent
        }
    }

}

extension XRayClientTypes {
    /// A list of EC2 instance IDs corresponding to the segments in a trace.
    public struct InstanceIdDetail {
        /// The ID of a corresponding EC2 instance.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension XRayClientTypes {
    /// A list of resources ARNs corresponding to the segments in a trace.
    public struct ResourceARNDetail {
        /// The ARN of a corresponding resource.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension XRayClientTypes {
    /// A collection of segments and corresponding subsegments associated to a response time warning.
    public struct ResponseTimeRootCauseEntity {
        /// The type and messages of the exceptions.
        public var coverage: Swift.Double?
        /// The name of the entity.
        public var name: Swift.String?
        /// A flag that denotes a remote subsegment.
        public var remote: Swift.Bool?

        public init(
            coverage: Swift.Double? = nil,
            name: Swift.String? = nil,
            remote: Swift.Bool? = nil
        )
        {
            self.coverage = coverage
            self.name = name
            self.remote = remote
        }
    }

}

extension XRayClientTypes {
    /// A collection of fields identifying the service in a response time warning.
    public struct ResponseTimeRootCauseService {
        /// The account ID associated to the service.
        public var accountId: Swift.String?
        /// The path of root cause entities found on the service.
        public var entityPath: [XRayClientTypes.ResponseTimeRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public var inferred: Swift.Bool?
        /// The service name.
        public var name: Swift.String?
        /// A collection of associated service names.
        public var names: [Swift.String]?
        /// The type associated to the service.
        public var type: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            entityPath: [XRayClientTypes.ResponseTimeRootCauseEntity]? = nil,
            inferred: Swift.Bool? = nil,
            name: Swift.String? = nil,
            names: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.type = type
        }
    }

}

extension XRayClientTypes {
    /// The root cause information for a response time warning.
    public struct ResponseTimeRootCause {
        /// A flag that denotes that the root cause impacts the trace client.
        public var clientImpacting: Swift.Bool?
        /// A list of corresponding services. A service identifies a segment and contains a name, account ID, type, and inferred flag.
        public var services: [XRayClientTypes.ResponseTimeRootCauseService]?

        public init(
            clientImpacting: Swift.Bool? = nil,
            services: [XRayClientTypes.ResponseTimeRootCauseService]? = nil
        )
        {
            self.clientImpacting = clientImpacting
            self.services = services
        }
    }

}

extension XRayClientTypes {
    /// Information about a user recorded in segment documents.
    public struct TraceUser {
        /// Services that the user's request hit.
        public var serviceIds: [XRayClientTypes.ServiceId]?
        /// The user's name.
        public var userName: Swift.String?

        public init(
            serviceIds: [XRayClientTypes.ServiceId]? = nil,
            userName: Swift.String? = nil
        )
        {
            self.serviceIds = serviceIds
            self.userName = userName
        }
    }

}

extension XRayClientTypes {
    /// Metadata generated from the segment documents in a trace.
    public struct TraceSummary {
        /// Annotations from the trace's segment documents.
        public var annotations: [Swift.String: [XRayClientTypes.ValueWithServiceIds]]?
        /// A list of Availability Zones for any zone corresponding to the trace segments.
        public var availabilityZones: [XRayClientTypes.AvailabilityZoneDetail]?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public var duration: Swift.Double?
        /// The root of a trace.
        public var entryPoint: XRayClientTypes.ServiceId?
        /// A collection of ErrorRootCause structures corresponding to the trace segments.
        public var errorRootCauses: [XRayClientTypes.ErrorRootCause]?
        /// A collection of FaultRootCause structures corresponding to the trace segments.
        public var faultRootCauses: [XRayClientTypes.FaultRootCause]?
        /// The root segment document has a 400 series error.
        public var hasError: Swift.Bool?
        /// The root segment document has a 500 series error.
        public var hasFault: Swift.Bool?
        /// One or more of the segment documents has a 429 throttling error.
        public var hasThrottle: Swift.Bool?
        /// Information about the HTTP request served by the trace.
        public var http: XRayClientTypes.Http?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public var id: Swift.String?
        /// A list of EC2 instance IDs for any instance corresponding to the trace segments.
        public var instanceIds: [XRayClientTypes.InstanceIdDetail]?
        /// One or more of the segment documents is in progress.
        public var isPartial: Swift.Bool?
        /// The matched time stamp of a defined event.
        public var matchedEventTime: Foundation.Date?
        /// A list of resource ARNs for any resource corresponding to the trace segments.
        public var resourceARNs: [XRayClientTypes.ResourceARNDetail]?
        /// The length of time in seconds between the start and end times of the root segment. If the service performs work asynchronously, the response time measures the time before the response is sent to the user, while the duration measures the amount of time before the last traced activity completes.
        public var responseTime: Swift.Double?
        /// A collection of ResponseTimeRootCause structures corresponding to the trace segments.
        public var responseTimeRootCauses: [XRayClientTypes.ResponseTimeRootCause]?
        /// The revision number of a trace.
        public var revision: Swift.Int
        /// Service IDs from the trace's segment documents.
        public var serviceIds: [XRayClientTypes.ServiceId]?
        /// The start time of a trace, based on the earliest trace segment start time.
        public var startTime: Foundation.Date?
        /// Users from the trace's segment documents.
        public var users: [XRayClientTypes.TraceUser]?

        public init(
            annotations: [Swift.String: [XRayClientTypes.ValueWithServiceIds]]? = nil,
            availabilityZones: [XRayClientTypes.AvailabilityZoneDetail]? = nil,
            duration: Swift.Double? = nil,
            entryPoint: XRayClientTypes.ServiceId? = nil,
            errorRootCauses: [XRayClientTypes.ErrorRootCause]? = nil,
            faultRootCauses: [XRayClientTypes.FaultRootCause]? = nil,
            hasError: Swift.Bool? = nil,
            hasFault: Swift.Bool? = nil,
            hasThrottle: Swift.Bool? = nil,
            http: XRayClientTypes.Http? = nil,
            id: Swift.String? = nil,
            instanceIds: [XRayClientTypes.InstanceIdDetail]? = nil,
            isPartial: Swift.Bool? = nil,
            matchedEventTime: Foundation.Date? = nil,
            resourceARNs: [XRayClientTypes.ResourceARNDetail]? = nil,
            responseTime: Swift.Double? = nil,
            responseTimeRootCauses: [XRayClientTypes.ResponseTimeRootCause]? = nil,
            revision: Swift.Int = 0,
            serviceIds: [XRayClientTypes.ServiceId]? = nil,
            startTime: Foundation.Date? = nil,
            users: [XRayClientTypes.TraceUser]? = nil
        )
        {
            self.annotations = annotations
            self.availabilityZones = availabilityZones
            self.duration = duration
            self.entryPoint = entryPoint
            self.errorRootCauses = errorRootCauses
            self.faultRootCauses = faultRootCauses
            self.hasError = hasError
            self.hasFault = hasFault
            self.hasThrottle = hasThrottle
            self.http = http
            self.id = id
            self.instanceIds = instanceIds
            self.isPartial = isPartial
            self.matchedEventTime = matchedEventTime
            self.resourceARNs = resourceARNs
            self.responseTime = responseTime
            self.responseTimeRootCauses = responseTimeRootCauses
            self.revision = revision
            self.serviceIds = serviceIds
            self.startTime = startTime
            self.users = users
        }
    }

}

public struct GetTraceSummariesOutput {
    /// The start time of this page of results.
    public var approximateTime: Foundation.Date?
    /// If the requested time frame contained more than one page of results, you can use this token to retrieve the next page. The first page contains the most recent results, closest to the end of the time frame.
    public var nextToken: Swift.String?
    /// Trace IDs and annotations for traces that were found in the specified time frame.
    public var traceSummaries: [XRayClientTypes.TraceSummary]?
    /// The total number of traces processed, including traces that did not match the specified filter expression.
    public var tracesProcessedCount: Swift.Int?

    public init(
        approximateTime: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        traceSummaries: [XRayClientTypes.TraceSummary]? = nil,
        tracesProcessedCount: Swift.Int? = nil
    )
    {
        self.approximateTime = approximateTime
        self.nextToken = nextToken
        self.traceSummaries = traceSummaries
        self.tracesProcessedCount = tracesProcessedCount
    }
}

public struct ListResourcePoliciesInput {
    /// Not currently supported.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension XRayClientTypes {
    /// A resource policy grants one or more Amazon Web Services services and accounts permissions to access X-Ray. Each resource policy is associated with a specific Amazon Web Services account.
    public struct ResourcePolicy {
        /// When the policy was last updated, in Unix time seconds.
        public var lastUpdatedTime: Foundation.Date?
        /// The resource policy document, which can be up to 5kb in size.
        public var policyDocument: Swift.String?
        /// The name of the resource policy. Must be unique within a specific Amazon Web Services account.
        public var policyName: Swift.String?
        /// Returns the current policy revision id for this policy name.
        public var policyRevisionId: Swift.String?

        public init(
            lastUpdatedTime: Foundation.Date? = nil,
            policyDocument: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyRevisionId: Swift.String? = nil
        )
        {
            self.lastUpdatedTime = lastUpdatedTime
            self.policyDocument = policyDocument
            self.policyName = policyName
            self.policyRevisionId = policyRevisionId
        }
    }

}

public struct ListResourcePoliciesOutput {
    /// Pagination token. Not currently supported.
    public var nextToken: Swift.String?
    /// The list of resource policies in the target Amazon Web Services account.
    public var resourcePolicies: [XRayClientTypes.ResourcePolicy]?

    public init(
        nextToken: Swift.String? = nil,
        resourcePolicies: [XRayClientTypes.ResourcePolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourcePolicies = resourcePolicies
    }
}

/// The resource was not found. Verify that the name or Amazon Resource Name (ARN) of the resource is correct.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

public struct ListTagsForResourceInput {
    /// A pagination token. If multiple pages of results are returned, use the NextToken value returned with the current page of results as the value of this parameter to get the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// A pagination token. If multiple pages of results are returned, use the NextToken value returned with the current page of results to get the next page of results.
    public var nextToken: Swift.String?
    /// A list of tags, as key and value pairs, that is associated with the specified X-Ray group or sampling rule.
    public var tags: [XRayClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [XRayClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct PutEncryptionConfigInput {
    /// An Amazon Web Services KMS key in one of the following formats:
    ///
    /// * Alias - The name of the key. For example, alias/MyKey.
    ///
    /// * Key ID - The KMS key ID of the key. For example, ae4aa6d49-a4d8-9df9-a475-4ff6d7898456. Amazon Web Services X-Ray does not support asymmetric KMS keys.
    ///
    /// * ARN - The full Amazon Resource Name of the key ID or alias. For example, arn:aws:kms:us-east-2:123456789012:key/ae4aa6d49-a4d8-9df9-a475-4ff6d7898456. Use this format to specify a key in a different account.
    ///
    ///
    /// Omit this key if you set Type to NONE.
    public var keyId: Swift.String?
    /// The type of encryption. Set to KMS to use your own key for encryption. Set to NONE for default encryption.
    /// This member is required.
    public var type: XRayClientTypes.EncryptionType?

    public init(
        keyId: Swift.String? = nil,
        type: XRayClientTypes.EncryptionType? = nil
    )
    {
        self.keyId = keyId
        self.type = type
    }
}

public struct PutEncryptionConfigOutput {
    /// The new encryption configuration.
    public var encryptionConfig: XRayClientTypes.EncryptionConfig?

    public init(
        encryptionConfig: XRayClientTypes.EncryptionConfig? = nil
    )
    {
        self.encryptionConfig = encryptionConfig
    }
}

/// The provided resource policy would prevent the caller of this request from calling PutResourcePolicy in the future.
public struct LockoutPreventionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LockoutPreventionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Invalid policy document provided in request.
public struct MalformedPolicyDocumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedPolicyDocumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exceeded the maximum number of resource policies for a target Amazon Web Services account.
public struct PolicyCountLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyCountLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exceeded the maximum size for a resource policy.
public struct PolicySizeLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicySizeLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PutResourcePolicyInput {
    /// A flag to indicate whether to bypass the resource policy lockout safety check. Setting this value to true increases the risk that the policy becomes unmanageable. Do not set this value to true indiscriminately. Use this parameter only when you include a policy in the request and you intend to prevent the principal that is making the request from making a subsequent PutResourcePolicy request. The default value is false.
    public var bypassPolicyLockoutCheck: Swift.Bool?
    /// The resource policy document, which can be up to 5kb in size.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The name of the resource policy. Must be unique within a specific Amazon Web Services account.
    /// This member is required.
    public var policyName: Swift.String?
    /// Specifies a specific policy revision, to ensure an atomic create operation. By default the resource policy is created if it does not exist, or updated with an incremented revision id. The revision id is unique to each policy in the account. If the policy revision id does not match the latest revision id, the operation will fail with an InvalidPolicyRevisionIdException exception. You can also provide a PolicyRevisionId of 0. In this case, the operation will fail with an InvalidPolicyRevisionIdException exception if a resource policy with the same name already exists.
    public var policyRevisionId: Swift.String?

    public init(
        bypassPolicyLockoutCheck: Swift.Bool? = false,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        policyRevisionId: Swift.String? = nil
    )
    {
        self.bypassPolicyLockoutCheck = bypassPolicyLockoutCheck
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.policyRevisionId = policyRevisionId
    }
}

public struct PutResourcePolicyOutput {
    /// The resource policy document, as provided in the PutResourcePolicyRequest.
    public var resourcePolicy: XRayClientTypes.ResourcePolicy?

    public init(
        resourcePolicy: XRayClientTypes.ResourcePolicy? = nil
    )
    {
        self.resourcePolicy = resourcePolicy
    }
}

extension XRayClientTypes {
    ///
    public struct BackendConnectionErrors {
        ///
        public var connectionRefusedCount: Swift.Int?
        ///
        public var httpCode4XXCount: Swift.Int?
        ///
        public var httpCode5XXCount: Swift.Int?
        ///
        public var otherCount: Swift.Int?
        ///
        public var timeoutCount: Swift.Int?
        ///
        public var unknownHostCount: Swift.Int?

        public init(
            connectionRefusedCount: Swift.Int? = nil,
            httpCode4XXCount: Swift.Int? = nil,
            httpCode5XXCount: Swift.Int? = nil,
            otherCount: Swift.Int? = nil,
            timeoutCount: Swift.Int? = nil,
            unknownHostCount: Swift.Int? = nil
        )
        {
            self.connectionRefusedCount = connectionRefusedCount
            self.httpCode4XXCount = httpCode4XXCount
            self.httpCode5XXCount = httpCode5XXCount
            self.otherCount = otherCount
            self.timeoutCount = timeoutCount
            self.unknownHostCount = unknownHostCount
        }
    }

}

extension XRayClientTypes {
    ///
    public struct TelemetryRecord {
        ///
        public var backendConnectionErrors: XRayClientTypes.BackendConnectionErrors?
        ///
        public var segmentsReceivedCount: Swift.Int?
        ///
        public var segmentsRejectedCount: Swift.Int?
        ///
        public var segmentsSentCount: Swift.Int?
        ///
        public var segmentsSpilloverCount: Swift.Int?
        ///
        /// This member is required.
        public var timestamp: Foundation.Date?

        public init(
            backendConnectionErrors: XRayClientTypes.BackendConnectionErrors? = nil,
            segmentsReceivedCount: Swift.Int? = nil,
            segmentsRejectedCount: Swift.Int? = nil,
            segmentsSentCount: Swift.Int? = nil,
            segmentsSpilloverCount: Swift.Int? = nil,
            timestamp: Foundation.Date? = nil
        )
        {
            self.backendConnectionErrors = backendConnectionErrors
            self.segmentsReceivedCount = segmentsReceivedCount
            self.segmentsRejectedCount = segmentsRejectedCount
            self.segmentsSentCount = segmentsSentCount
            self.segmentsSpilloverCount = segmentsSpilloverCount
            self.timestamp = timestamp
        }
    }

}

public struct PutTelemetryRecordsInput {
    ///
    public var ec2InstanceId: Swift.String?
    ///
    public var hostname: Swift.String?
    ///
    public var resourceARN: Swift.String?
    ///
    /// This member is required.
    public var telemetryRecords: [XRayClientTypes.TelemetryRecord]?

    public init(
        ec2InstanceId: Swift.String? = nil,
        hostname: Swift.String? = nil,
        resourceARN: Swift.String? = nil,
        telemetryRecords: [XRayClientTypes.TelemetryRecord]? = nil
    )
    {
        self.ec2InstanceId = ec2InstanceId
        self.hostname = hostname
        self.resourceARN = resourceARN
        self.telemetryRecords = telemetryRecords
    }
}

public struct PutTelemetryRecordsOutput {

    public init() { }
}

public struct PutTraceSegmentsInput {
    /// A string containing a JSON document defining one or more segments or subsegments.
    /// This member is required.
    public var traceSegmentDocuments: [Swift.String]?

    public init(
        traceSegmentDocuments: [Swift.String]? = nil
    )
    {
        self.traceSegmentDocuments = traceSegmentDocuments
    }
}

extension XRayClientTypes {
    /// Information about a segment that failed processing.
    public struct UnprocessedTraceSegment {
        /// The error that caused processing to fail.
        public var errorCode: Swift.String?
        /// The segment's ID.
        public var id: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            id: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.id = id
            self.message = message
        }
    }

}

public struct PutTraceSegmentsOutput {
    /// Segments that failed processing.
    public var unprocessedTraceSegments: [XRayClientTypes.UnprocessedTraceSegment]?

    public init(
        unprocessedTraceSegments: [XRayClientTypes.UnprocessedTraceSegment]? = nil
    )
    {
        self.unprocessedTraceSegments = unprocessedTraceSegments
    }
}

/// You have exceeded the maximum number of tags you can apply to this resource.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A map that contains one or more tag keys and tag values to attach to an X-Ray group or sampling rule. For more information about ways to use tags, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference. The following restrictions apply to tags:
    ///
    /// * Maximum number of user-applied tags per resource: 50
    ///
    /// * Maximum tag key length: 128 Unicode characters
    ///
    /// * Maximum tag value length: 256 Unicode characters
    ///
    /// * Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @
    ///
    /// * Tag keys and values are case sensitive.
    ///
    /// * Don't use aws: as a prefix for keys; it's reserved for Amazon Web Services use. You cannot edit or delete system tags.
    /// This member is required.
    public var tags: [XRayClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [XRayClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Keys for one or more tags that you want to remove from an X-Ray group or sampling rule.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateGroupInput {
    /// The updated filter expression defining criteria by which to group traces.
    public var filterExpression: Swift.String?
    /// The ARN that was generated upon creation.
    public var groupARN: Swift.String?
    /// The case-sensitive name of the group.
    public var groupName: Swift.String?
    /// The structure containing configurations related to insights.
    ///
    /// * The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.
    ///
    /// * The NotificationsEnabled boolean can be set to true to enable insights notifications for the group. Notifications can only be enabled on a group with InsightsEnabled set to true.
    public var insightsConfiguration: XRayClientTypes.InsightsConfiguration?

    public init(
        filterExpression: Swift.String? = nil,
        groupARN: Swift.String? = nil,
        groupName: Swift.String? = nil,
        insightsConfiguration: XRayClientTypes.InsightsConfiguration? = nil
    )
    {
        self.filterExpression = filterExpression
        self.groupARN = groupARN
        self.groupName = groupName
        self.insightsConfiguration = insightsConfiguration
    }
}

public struct UpdateGroupOutput {
    /// The group that was updated. Contains the name of the group that was updated, the ARN of the group that was updated, the updated filter expression, and the updated insight configuration assigned to the group.
    public var group: XRayClientTypes.Group?

    public init(
        group: XRayClientTypes.Group? = nil
    )
    {
        self.group = group
    }
}

extension XRayClientTypes {
    /// A document specifying changes to a sampling rule's configuration.
    public struct SamplingRuleUpdate {
        /// Matches attributes derived from the request.
        public var attributes: [Swift.String: Swift.String]?
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public var fixedRate: Swift.Double?
        /// Matches the hostname from a request URL.
        public var host: Swift.String?
        /// Matches the HTTP method of a request.
        public var httpMethod: Swift.String?
        /// The priority of the sampling rule.
        public var priority: Swift.Int?
        /// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        public var reservoirSize: Swift.Int?
        /// Matches the ARN of the Amazon Web Services resource on which the service runs.
        public var resourceARN: Swift.String?
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public var ruleARN: Swift.String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public var ruleName: Swift.String?
        /// Matches the name that the service uses to identify itself in segments.
        public var serviceName: Swift.String?
        /// Matches the origin that the service uses to identify its type in segments.
        public var serviceType: Swift.String?
        /// Matches the path from a request URL.
        public var urlPath: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            fixedRate: Swift.Double? = nil,
            host: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            priority: Swift.Int? = nil,
            reservoirSize: Swift.Int? = nil,
            resourceARN: Swift.String? = nil,
            ruleARN: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceType: Swift.String? = nil,
            urlPath: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.fixedRate = fixedRate
            self.host = host
            self.httpMethod = httpMethod
            self.priority = priority
            self.reservoirSize = reservoirSize
            self.resourceARN = resourceARN
            self.ruleARN = ruleARN
            self.ruleName = ruleName
            self.serviceName = serviceName
            self.serviceType = serviceType
            self.urlPath = urlPath
        }
    }

}

public struct UpdateSamplingRuleInput {
    /// The rule and fields to change.
    /// This member is required.
    public var samplingRuleUpdate: XRayClientTypes.SamplingRuleUpdate?

    public init(
        samplingRuleUpdate: XRayClientTypes.SamplingRuleUpdate? = nil
    )
    {
        self.samplingRuleUpdate = samplingRuleUpdate
    }
}

public struct UpdateSamplingRuleOutput {
    /// The updated rule definition and metadata.
    public var samplingRuleRecord: XRayClientTypes.SamplingRuleRecord?

    public init(
        samplingRuleRecord: XRayClientTypes.SamplingRuleRecord? = nil
    )
    {
        self.samplingRuleRecord = samplingRuleRecord
    }
}

extension BatchGetTracesInput {

    static func urlPathProvider(_ value: BatchGetTracesInput) -> Swift.String? {
        return "/Traces"
    }
}

extension CreateGroupInput {

    static func urlPathProvider(_ value: CreateGroupInput) -> Swift.String? {
        return "/CreateGroup"
    }
}

extension CreateSamplingRuleInput {

    static func urlPathProvider(_ value: CreateSamplingRuleInput) -> Swift.String? {
        return "/CreateSamplingRule"
    }
}

extension DeleteGroupInput {

    static func urlPathProvider(_ value: DeleteGroupInput) -> Swift.String? {
        return "/DeleteGroup"
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        return "/DeleteResourcePolicy"
    }
}

extension DeleteSamplingRuleInput {

    static func urlPathProvider(_ value: DeleteSamplingRuleInput) -> Swift.String? {
        return "/DeleteSamplingRule"
    }
}

extension GetEncryptionConfigInput {

    static func urlPathProvider(_ value: GetEncryptionConfigInput) -> Swift.String? {
        return "/EncryptionConfig"
    }
}

extension GetGroupInput {

    static func urlPathProvider(_ value: GetGroupInput) -> Swift.String? {
        return "/GetGroup"
    }
}

extension GetGroupsInput {

    static func urlPathProvider(_ value: GetGroupsInput) -> Swift.String? {
        return "/Groups"
    }
}

extension GetInsightInput {

    static func urlPathProvider(_ value: GetInsightInput) -> Swift.String? {
        return "/Insight"
    }
}

extension GetInsightEventsInput {

    static func urlPathProvider(_ value: GetInsightEventsInput) -> Swift.String? {
        return "/InsightEvents"
    }
}

extension GetInsightImpactGraphInput {

    static func urlPathProvider(_ value: GetInsightImpactGraphInput) -> Swift.String? {
        return "/InsightImpactGraph"
    }
}

extension GetInsightSummariesInput {

    static func urlPathProvider(_ value: GetInsightSummariesInput) -> Swift.String? {
        return "/InsightSummaries"
    }
}

extension GetSamplingRulesInput {

    static func urlPathProvider(_ value: GetSamplingRulesInput) -> Swift.String? {
        return "/GetSamplingRules"
    }
}

extension GetSamplingStatisticSummariesInput {

    static func urlPathProvider(_ value: GetSamplingStatisticSummariesInput) -> Swift.String? {
        return "/SamplingStatisticSummaries"
    }
}

extension GetSamplingTargetsInput {

    static func urlPathProvider(_ value: GetSamplingTargetsInput) -> Swift.String? {
        return "/SamplingTargets"
    }
}

extension GetServiceGraphInput {

    static func urlPathProvider(_ value: GetServiceGraphInput) -> Swift.String? {
        return "/ServiceGraph"
    }
}

extension GetTimeSeriesServiceStatisticsInput {

    static func urlPathProvider(_ value: GetTimeSeriesServiceStatisticsInput) -> Swift.String? {
        return "/TimeSeriesServiceStatistics"
    }
}

extension GetTraceGraphInput {

    static func urlPathProvider(_ value: GetTraceGraphInput) -> Swift.String? {
        return "/TraceGraph"
    }
}

extension GetTraceSummariesInput {

    static func urlPathProvider(_ value: GetTraceSummariesInput) -> Swift.String? {
        return "/TraceSummaries"
    }
}

extension ListResourcePoliciesInput {

    static func urlPathProvider(_ value: ListResourcePoliciesInput) -> Swift.String? {
        return "/ListResourcePolicies"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/ListTagsForResource"
    }
}

extension PutEncryptionConfigInput {

    static func urlPathProvider(_ value: PutEncryptionConfigInput) -> Swift.String? {
        return "/PutEncryptionConfig"
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        return "/PutResourcePolicy"
    }
}

extension PutTelemetryRecordsInput {

    static func urlPathProvider(_ value: PutTelemetryRecordsInput) -> Swift.String? {
        return "/TelemetryRecords"
    }
}

extension PutTraceSegmentsInput {

    static func urlPathProvider(_ value: PutTraceSegmentsInput) -> Swift.String? {
        return "/TraceSegments"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/TagResource"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/UntagResource"
    }
}

extension UpdateGroupInput {

    static func urlPathProvider(_ value: UpdateGroupInput) -> Swift.String? {
        return "/UpdateGroup"
    }
}

extension UpdateSamplingRuleInput {

    static func urlPathProvider(_ value: UpdateSamplingRuleInput) -> Swift.String? {
        return "/UpdateSamplingRule"
    }
}

extension BatchGetTracesInput {

    static func write(value: BatchGetTracesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["TraceIds"].writeList(value.traceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateGroupInput {

    static func write(value: CreateGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilterExpression"].write(value.filterExpression)
        try writer["GroupName"].write(value.groupName)
        try writer["InsightsConfiguration"].write(value.insightsConfiguration, with: XRayClientTypes.InsightsConfiguration.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: XRayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSamplingRuleInput {

    static func write(value: CreateSamplingRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SamplingRule"].write(value.samplingRule, with: XRayClientTypes.SamplingRule.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: XRayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteGroupInput {

    static func write(value: DeleteGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupARN"].write(value.groupARN)
        try writer["GroupName"].write(value.groupName)
    }
}

extension DeleteResourcePolicyInput {

    static func write(value: DeleteResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PolicyName"].write(value.policyName)
        try writer["PolicyRevisionId"].write(value.policyRevisionId)
    }
}

extension DeleteSamplingRuleInput {

    static func write(value: DeleteSamplingRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuleARN"].write(value.ruleARN)
        try writer["RuleName"].write(value.ruleName)
    }
}

extension GetGroupInput {

    static func write(value: GetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupARN"].write(value.groupARN)
        try writer["GroupName"].write(value.groupName)
    }
}

extension GetGroupsInput {

    static func write(value: GetGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetInsightInput {

    static func write(value: GetInsightInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InsightId"].write(value.insightId)
    }
}

extension GetInsightEventsInput {

    static func write(value: GetInsightEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InsightId"].write(value.insightId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetInsightImpactGraphInput {

    static func write(value: GetInsightImpactGraphInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["InsightId"].write(value.insightId)
        try writer["NextToken"].write(value.nextToken)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension GetInsightSummariesInput {

    static func write(value: GetInsightSummariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["GroupARN"].write(value.groupARN)
        try writer["GroupName"].write(value.groupName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["States"].writeList(value.states, memberWritingClosure: SmithyReadWrite.WritingClosureBox<XRayClientTypes.InsightState>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetSamplingRulesInput {

    static func write(value: GetSamplingRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetSamplingStatisticSummariesInput {

    static func write(value: GetSamplingStatisticSummariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetSamplingTargetsInput {

    static func write(value: GetSamplingTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SamplingStatisticsDocuments"].writeList(value.samplingStatisticsDocuments, memberWritingClosure: XRayClientTypes.SamplingStatisticsDocument.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetServiceGraphInput {

    static func write(value: GetServiceGraphInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["GroupARN"].write(value.groupARN)
        try writer["GroupName"].write(value.groupName)
        try writer["NextToken"].write(value.nextToken)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension GetTimeSeriesServiceStatisticsInput {

    static func write(value: GetTimeSeriesServiceStatisticsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["EntitySelectorExpression"].write(value.entitySelectorExpression)
        try writer["ForecastStatistics"].write(value.forecastStatistics)
        try writer["GroupARN"].write(value.groupARN)
        try writer["GroupName"].write(value.groupName)
        try writer["NextToken"].write(value.nextToken)
        try writer["Period"].write(value.period)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension GetTraceGraphInput {

    static func write(value: GetTraceGraphInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["TraceIds"].writeList(value.traceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetTraceSummariesInput {

    static func write(value: GetTraceSummariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["FilterExpression"].write(value.filterExpression)
        try writer["NextToken"].write(value.nextToken)
        try writer["Sampling"].write(value.sampling)
        try writer["SamplingStrategy"].write(value.samplingStrategy, with: XRayClientTypes.SamplingStrategy.write(value:to:))
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["TimeRangeType"].write(value.timeRangeType)
    }
}

extension ListResourcePoliciesInput {

    static func write(value: ListResourcePoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension PutEncryptionConfigInput {

    static func write(value: PutEncryptionConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyId"].write(value.keyId)
        try writer["Type"].write(value.type)
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BypassPolicyLockoutCheck"].write(value.bypassPolicyLockoutCheck)
        try writer["PolicyDocument"].write(value.policyDocument)
        try writer["PolicyName"].write(value.policyName)
        try writer["PolicyRevisionId"].write(value.policyRevisionId)
    }
}

extension PutTelemetryRecordsInput {

    static func write(value: PutTelemetryRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EC2InstanceId"].write(value.ec2InstanceId)
        try writer["Hostname"].write(value.hostname)
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TelemetryRecords"].writeList(value.telemetryRecords, memberWritingClosure: XRayClientTypes.TelemetryRecord.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutTraceSegmentsInput {

    static func write(value: PutTraceSegmentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TraceSegmentDocuments"].writeList(value.traceSegmentDocuments, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: XRayClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateGroupInput {

    static func write(value: UpdateGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilterExpression"].write(value.filterExpression)
        try writer["GroupARN"].write(value.groupARN)
        try writer["GroupName"].write(value.groupName)
        try writer["InsightsConfiguration"].write(value.insightsConfiguration, with: XRayClientTypes.InsightsConfiguration.write(value:to:))
    }
}

extension UpdateSamplingRuleInput {

    static func write(value: UpdateSamplingRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SamplingRuleUpdate"].write(value.samplingRuleUpdate, with: XRayClientTypes.SamplingRuleUpdate.write(value:to:))
    }
}

extension BatchGetTracesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetTracesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetTracesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.traces = try reader["Traces"].readListIfPresent(memberReadingClosure: XRayClientTypes.Trace.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedTraceIds = try reader["UnprocessedTraceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGroupOutput()
        value.group = try reader["Group"].readIfPresent(with: XRayClientTypes.Group.read(from:))
        return value
    }
}

extension CreateSamplingRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSamplingRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSamplingRuleOutput()
        value.samplingRuleRecord = try reader["SamplingRuleRecord"].readIfPresent(with: XRayClientTypes.SamplingRuleRecord.read(from:))
        return value
    }
}

extension DeleteGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGroupOutput {
        return DeleteGroupOutput()
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePolicyOutput {
        return DeleteResourcePolicyOutput()
    }
}

extension DeleteSamplingRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSamplingRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSamplingRuleOutput()
        value.samplingRuleRecord = try reader["SamplingRuleRecord"].readIfPresent(with: XRayClientTypes.SamplingRuleRecord.read(from:))
        return value
    }
}

extension GetEncryptionConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEncryptionConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEncryptionConfigOutput()
        value.encryptionConfig = try reader["EncryptionConfig"].readIfPresent(with: XRayClientTypes.EncryptionConfig.read(from:))
        return value
    }
}

extension GetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGroupOutput()
        value.group = try reader["Group"].readIfPresent(with: XRayClientTypes.Group.read(from:))
        return value
    }
}

extension GetGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGroupsOutput()
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: XRayClientTypes.GroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetInsightOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInsightOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInsightOutput()
        value.insight = try reader["Insight"].readIfPresent(with: XRayClientTypes.Insight.read(from:))
        return value
    }
}

extension GetInsightEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInsightEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInsightEventsOutput()
        value.insightEvents = try reader["InsightEvents"].readListIfPresent(memberReadingClosure: XRayClientTypes.InsightEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetInsightImpactGraphOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInsightImpactGraphOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInsightImpactGraphOutput()
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.insightId = try reader["InsightId"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceGraphEndTime = try reader["ServiceGraphEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.serviceGraphStartTime = try reader["ServiceGraphStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.services = try reader["Services"].readListIfPresent(memberReadingClosure: XRayClientTypes.InsightImpactGraphService.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetInsightSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInsightSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInsightSummariesOutput()
        value.insightSummaries = try reader["InsightSummaries"].readListIfPresent(memberReadingClosure: XRayClientTypes.InsightSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetSamplingRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSamplingRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSamplingRulesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.samplingRuleRecords = try reader["SamplingRuleRecords"].readListIfPresent(memberReadingClosure: XRayClientTypes.SamplingRuleRecord.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetSamplingStatisticSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSamplingStatisticSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSamplingStatisticSummariesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.samplingStatisticSummaries = try reader["SamplingStatisticSummaries"].readListIfPresent(memberReadingClosure: XRayClientTypes.SamplingStatisticSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetSamplingTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSamplingTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSamplingTargetsOutput()
        value.lastRuleModification = try reader["LastRuleModification"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.samplingTargetDocuments = try reader["SamplingTargetDocuments"].readListIfPresent(memberReadingClosure: XRayClientTypes.SamplingTargetDocument.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedStatistics = try reader["UnprocessedStatistics"].readListIfPresent(memberReadingClosure: XRayClientTypes.UnprocessedStatistics.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetServiceGraphOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceGraphOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceGraphOutput()
        value.containsOldGroupVersions = try reader["ContainsOldGroupVersions"].readIfPresent() ?? false
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.services = try reader["Services"].readListIfPresent(memberReadingClosure: XRayClientTypes.Service.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetTimeSeriesServiceStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTimeSeriesServiceStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTimeSeriesServiceStatisticsOutput()
        value.containsOldGroupVersions = try reader["ContainsOldGroupVersions"].readIfPresent() ?? false
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.timeSeriesServiceStatistics = try reader["TimeSeriesServiceStatistics"].readListIfPresent(memberReadingClosure: XRayClientTypes.TimeSeriesServiceStatistics.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetTraceGraphOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTraceGraphOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTraceGraphOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.services = try reader["Services"].readListIfPresent(memberReadingClosure: XRayClientTypes.Service.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetTraceSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTraceSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTraceSummariesOutput()
        value.approximateTime = try reader["ApproximateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.traceSummaries = try reader["TraceSummaries"].readListIfPresent(memberReadingClosure: XRayClientTypes.TraceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tracesProcessedCount = try reader["TracesProcessedCount"].readIfPresent()
        return value
    }
}

extension ListResourcePoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourcePoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourcePoliciesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourcePolicies = try reader["ResourcePolicies"].readListIfPresent(memberReadingClosure: XRayClientTypes.ResourcePolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: XRayClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutEncryptionConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutEncryptionConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutEncryptionConfigOutput()
        value.encryptionConfig = try reader["EncryptionConfig"].readIfPresent(with: XRayClientTypes.EncryptionConfig.read(from:))
        return value
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResourcePolicyOutput()
        value.resourcePolicy = try reader["ResourcePolicy"].readIfPresent(with: XRayClientTypes.ResourcePolicy.read(from:))
        return value
    }
}

extension PutTelemetryRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTelemetryRecordsOutput {
        return PutTelemetryRecordsOutput()
    }
}

extension PutTraceSegmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTraceSegmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutTraceSegmentsOutput()
        value.unprocessedTraceSegments = try reader["UnprocessedTraceSegments"].readListIfPresent(memberReadingClosure: XRayClientTypes.UnprocessedTraceSegment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGroupOutput()
        value.group = try reader["Group"].readIfPresent(with: XRayClientTypes.Group.read(from:))
        return value
    }
}

extension UpdateSamplingRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSamplingRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSamplingRuleOutput()
        value.samplingRuleRecord = try reader["SamplingRuleRecord"].readIfPresent(with: XRayClientTypes.SamplingRuleRecord.read(from:))
        return value
    }
}

enum BatchGetTracesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSamplingRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "RuleLimitExceededException": return try RuleLimitExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidPolicyRevisionIdException": return try InvalidPolicyRevisionIdException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSamplingRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEncryptionConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInsightOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInsightEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInsightImpactGraphOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInsightSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSamplingRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSamplingStatisticSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSamplingTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceGraphOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTimeSeriesServiceStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTraceGraphOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTraceSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourcePoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutEncryptionConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidPolicyRevisionIdException": return try InvalidPolicyRevisionIdException.makeError(baseError: baseError)
            case "LockoutPreventionException": return try LockoutPreventionException.makeError(baseError: baseError)
            case "MalformedPolicyDocumentException": return try MalformedPolicyDocumentException.makeError(baseError: baseError)
            case "PolicyCountLimitExceededException": return try PolicyCountLimitExceededException.makeError(baseError: baseError)
            case "PolicySizeLimitExceededException": return try PolicySizeLimitExceededException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTelemetryRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTraceSegmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSamplingRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottledException {
        let reader = baseError.errorBodyReader
        var value = ThrottledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RuleLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RuleLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = RuleLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPolicyRevisionIdException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidPolicyRevisionIdException {
        let reader = baseError.errorBodyReader
        var value = InvalidPolicyRevisionIdException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LockoutPreventionException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LockoutPreventionException {
        let reader = baseError.errorBodyReader
        var value = LockoutPreventionException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PolicySizeLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PolicySizeLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = PolicySizeLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MalformedPolicyDocumentException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MalformedPolicyDocumentException {
        let reader = baseError.errorBodyReader
        var value = MalformedPolicyDocumentException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PolicyCountLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PolicyCountLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = PolicyCountLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension XRayClientTypes.Trace {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.Trace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.Trace()
        value.id = try reader["Id"].readIfPresent()
        value.duration = try reader["Duration"].readIfPresent()
        value.limitExceeded = try reader["LimitExceeded"].readIfPresent()
        value.segments = try reader["Segments"].readListIfPresent(memberReadingClosure: XRayClientTypes.Segment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension XRayClientTypes.Segment {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.Segment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.Segment()
        value.id = try reader["Id"].readIfPresent()
        value.document = try reader["Document"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.Group {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.Group {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.Group()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.groupARN = try reader["GroupARN"].readIfPresent()
        value.filterExpression = try reader["FilterExpression"].readIfPresent()
        value.insightsConfiguration = try reader["InsightsConfiguration"].readIfPresent(with: XRayClientTypes.InsightsConfiguration.read(from:))
        return value
    }
}

extension XRayClientTypes.InsightsConfiguration {

    static func write(value: XRayClientTypes.InsightsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InsightsEnabled"].write(value.insightsEnabled)
        try writer["NotificationsEnabled"].write(value.notificationsEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.InsightsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.InsightsConfiguration()
        value.insightsEnabled = try reader["InsightsEnabled"].readIfPresent()
        value.notificationsEnabled = try reader["NotificationsEnabled"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.SamplingRuleRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.SamplingRuleRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.SamplingRuleRecord()
        value.samplingRule = try reader["SamplingRule"].readIfPresent(with: XRayClientTypes.SamplingRule.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedAt = try reader["ModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension XRayClientTypes.SamplingRule {

    static func write(value: XRayClientTypes.SamplingRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["FixedRate"].write(value.fixedRate)
        try writer["HTTPMethod"].write(value.httpMethod)
        try writer["Host"].write(value.host)
        try writer["Priority"].write(value.priority)
        try writer["ReservoirSize"].write(value.reservoirSize)
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["RuleARN"].write(value.ruleARN)
        try writer["RuleName"].write(value.ruleName)
        try writer["ServiceName"].write(value.serviceName)
        try writer["ServiceType"].write(value.serviceType)
        try writer["URLPath"].write(value.urlPath)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.SamplingRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.SamplingRule()
        value.ruleName = try reader["RuleName"].readIfPresent()
        value.ruleARN = try reader["RuleARN"].readIfPresent()
        value.resourceARN = try reader["ResourceARN"].readIfPresent() ?? ""
        value.priority = try reader["Priority"].readIfPresent() ?? 0
        value.fixedRate = try reader["FixedRate"].readIfPresent() ?? 0
        value.reservoirSize = try reader["ReservoirSize"].readIfPresent() ?? 0
        value.serviceName = try reader["ServiceName"].readIfPresent() ?? ""
        value.serviceType = try reader["ServiceType"].readIfPresent() ?? ""
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.httpMethod = try reader["HTTPMethod"].readIfPresent() ?? ""
        value.urlPath = try reader["URLPath"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension XRayClientTypes.EncryptionConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.EncryptionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.EncryptionConfig()
        value.keyId = try reader["KeyId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.GroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.GroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.GroupSummary()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.groupARN = try reader["GroupARN"].readIfPresent()
        value.filterExpression = try reader["FilterExpression"].readIfPresent()
        value.insightsConfiguration = try reader["InsightsConfiguration"].readIfPresent(with: XRayClientTypes.InsightsConfiguration.read(from:))
        return value
    }
}

extension XRayClientTypes.Insight {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.Insight {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.Insight()
        value.insightId = try reader["InsightId"].readIfPresent()
        value.groupARN = try reader["GroupARN"].readIfPresent()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.rootCauseServiceId = try reader["RootCauseServiceId"].readIfPresent(with: XRayClientTypes.ServiceId.read(from:))
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<XRayClientTypes.InsightCategory>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["State"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.summary = try reader["Summary"].readIfPresent()
        value.clientRequestImpactStatistics = try reader["ClientRequestImpactStatistics"].readIfPresent(with: XRayClientTypes.RequestImpactStatistics.read(from:))
        value.rootCauseServiceRequestImpactStatistics = try reader["RootCauseServiceRequestImpactStatistics"].readIfPresent(with: XRayClientTypes.RequestImpactStatistics.read(from:))
        value.topAnomalousServices = try reader["TopAnomalousServices"].readListIfPresent(memberReadingClosure: XRayClientTypes.AnomalousService.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension XRayClientTypes.AnomalousService {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.AnomalousService {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.AnomalousService()
        value.serviceId = try reader["ServiceId"].readIfPresent(with: XRayClientTypes.ServiceId.read(from:))
        return value
    }
}

extension XRayClientTypes.ServiceId {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.ServiceId {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.ServiceId()
        value.name = try reader["Name"].readIfPresent()
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.accountId = try reader["AccountId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.RequestImpactStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.RequestImpactStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.RequestImpactStatistics()
        value.faultCount = try reader["FaultCount"].readIfPresent()
        value.okCount = try reader["OkCount"].readIfPresent()
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.InsightEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.InsightEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.InsightEvent()
        value.summary = try reader["Summary"].readIfPresent()
        value.eventTime = try reader["EventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.clientRequestImpactStatistics = try reader["ClientRequestImpactStatistics"].readIfPresent(with: XRayClientTypes.RequestImpactStatistics.read(from:))
        value.rootCauseServiceRequestImpactStatistics = try reader["RootCauseServiceRequestImpactStatistics"].readIfPresent(with: XRayClientTypes.RequestImpactStatistics.read(from:))
        value.topAnomalousServices = try reader["TopAnomalousServices"].readListIfPresent(memberReadingClosure: XRayClientTypes.AnomalousService.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension XRayClientTypes.InsightImpactGraphService {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.InsightImpactGraphService {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.InsightImpactGraphService()
        value.referenceId = try reader["ReferenceId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.accountId = try reader["AccountId"].readIfPresent()
        value.edges = try reader["Edges"].readListIfPresent(memberReadingClosure: XRayClientTypes.InsightImpactGraphEdge.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension XRayClientTypes.InsightImpactGraphEdge {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.InsightImpactGraphEdge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.InsightImpactGraphEdge()
        value.referenceId = try reader["ReferenceId"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.InsightSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.InsightSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.InsightSummary()
        value.insightId = try reader["InsightId"].readIfPresent()
        value.groupARN = try reader["GroupARN"].readIfPresent()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.rootCauseServiceId = try reader["RootCauseServiceId"].readIfPresent(with: XRayClientTypes.ServiceId.read(from:))
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<XRayClientTypes.InsightCategory>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["State"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.summary = try reader["Summary"].readIfPresent()
        value.clientRequestImpactStatistics = try reader["ClientRequestImpactStatistics"].readIfPresent(with: XRayClientTypes.RequestImpactStatistics.read(from:))
        value.rootCauseServiceRequestImpactStatistics = try reader["RootCauseServiceRequestImpactStatistics"].readIfPresent(with: XRayClientTypes.RequestImpactStatistics.read(from:))
        value.topAnomalousServices = try reader["TopAnomalousServices"].readListIfPresent(memberReadingClosure: XRayClientTypes.AnomalousService.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension XRayClientTypes.SamplingStatisticSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.SamplingStatisticSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.SamplingStatisticSummary()
        value.ruleName = try reader["RuleName"].readIfPresent()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.requestCount = try reader["RequestCount"].readIfPresent() ?? 0
        value.borrowCount = try reader["BorrowCount"].readIfPresent() ?? 0
        value.sampledCount = try reader["SampledCount"].readIfPresent() ?? 0
        return value
    }
}

extension XRayClientTypes.SamplingTargetDocument {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.SamplingTargetDocument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.SamplingTargetDocument()
        value.ruleName = try reader["RuleName"].readIfPresent()
        value.fixedRate = try reader["FixedRate"].readIfPresent() ?? 0
        value.reservoirQuota = try reader["ReservoirQuota"].readIfPresent()
        value.reservoirQuotaTTL = try reader["ReservoirQuotaTTL"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.interval = try reader["Interval"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.UnprocessedStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.UnprocessedStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.UnprocessedStatistics()
        value.ruleName = try reader["RuleName"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.Service {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.Service {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.Service()
        value.referenceId = try reader["ReferenceId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.root = try reader["Root"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.edges = try reader["Edges"].readListIfPresent(memberReadingClosure: XRayClientTypes.Edge.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.summaryStatistics = try reader["SummaryStatistics"].readIfPresent(with: XRayClientTypes.ServiceStatistics.read(from:))
        value.durationHistogram = try reader["DurationHistogram"].readListIfPresent(memberReadingClosure: XRayClientTypes.HistogramEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.responseTimeHistogram = try reader["ResponseTimeHistogram"].readListIfPresent(memberReadingClosure: XRayClientTypes.HistogramEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension XRayClientTypes.HistogramEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.HistogramEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.HistogramEntry()
        value.value = try reader["Value"].readIfPresent() ?? 0
        value.count = try reader["Count"].readIfPresent() ?? 0
        return value
    }
}

extension XRayClientTypes.ServiceStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.ServiceStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.ServiceStatistics()
        value.okCount = try reader["OkCount"].readIfPresent()
        value.errorStatistics = try reader["ErrorStatistics"].readIfPresent(with: XRayClientTypes.ErrorStatistics.read(from:))
        value.faultStatistics = try reader["FaultStatistics"].readIfPresent(with: XRayClientTypes.FaultStatistics.read(from:))
        value.totalCount = try reader["TotalCount"].readIfPresent()
        value.totalResponseTime = try reader["TotalResponseTime"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.FaultStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.FaultStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.FaultStatistics()
        value.otherCount = try reader["OtherCount"].readIfPresent()
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.ErrorStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.ErrorStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.ErrorStatistics()
        value.throttleCount = try reader["ThrottleCount"].readIfPresent()
        value.otherCount = try reader["OtherCount"].readIfPresent()
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.Edge {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.Edge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.Edge()
        value.referenceId = try reader["ReferenceId"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.summaryStatistics = try reader["SummaryStatistics"].readIfPresent(with: XRayClientTypes.EdgeStatistics.read(from:))
        value.responseTimeHistogram = try reader["ResponseTimeHistogram"].readListIfPresent(memberReadingClosure: XRayClientTypes.HistogramEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.aliases = try reader["Aliases"].readListIfPresent(memberReadingClosure: XRayClientTypes.Alias.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.edgeType = try reader["EdgeType"].readIfPresent()
        value.receivedEventAgeHistogram = try reader["ReceivedEventAgeHistogram"].readListIfPresent(memberReadingClosure: XRayClientTypes.HistogramEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension XRayClientTypes.Alias {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.Alias {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.Alias()
        value.name = try reader["Name"].readIfPresent()
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.EdgeStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.EdgeStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.EdgeStatistics()
        value.okCount = try reader["OkCount"].readIfPresent()
        value.errorStatistics = try reader["ErrorStatistics"].readIfPresent(with: XRayClientTypes.ErrorStatistics.read(from:))
        value.faultStatistics = try reader["FaultStatistics"].readIfPresent(with: XRayClientTypes.FaultStatistics.read(from:))
        value.totalCount = try reader["TotalCount"].readIfPresent()
        value.totalResponseTime = try reader["TotalResponseTime"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.TimeSeriesServiceStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.TimeSeriesServiceStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.TimeSeriesServiceStatistics()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.edgeSummaryStatistics = try reader["EdgeSummaryStatistics"].readIfPresent(with: XRayClientTypes.EdgeStatistics.read(from:))
        value.serviceSummaryStatistics = try reader["ServiceSummaryStatistics"].readIfPresent(with: XRayClientTypes.ServiceStatistics.read(from:))
        value.serviceForecastStatistics = try reader["ServiceForecastStatistics"].readIfPresent(with: XRayClientTypes.ForecastStatistics.read(from:))
        value.responseTimeHistogram = try reader["ResponseTimeHistogram"].readListIfPresent(memberReadingClosure: XRayClientTypes.HistogramEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension XRayClientTypes.ForecastStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.ForecastStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.ForecastStatistics()
        value.faultCountHigh = try reader["FaultCountHigh"].readIfPresent()
        value.faultCountLow = try reader["FaultCountLow"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.TraceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.TraceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.TraceSummary()
        value.id = try reader["Id"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.duration = try reader["Duration"].readIfPresent()
        value.responseTime = try reader["ResponseTime"].readIfPresent()
        value.hasFault = try reader["HasFault"].readIfPresent()
        value.hasError = try reader["HasError"].readIfPresent()
        value.hasThrottle = try reader["HasThrottle"].readIfPresent()
        value.isPartial = try reader["IsPartial"].readIfPresent()
        value.http = try reader["Http"].readIfPresent(with: XRayClientTypes.Http.read(from:))
        value.annotations = try reader["Annotations"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: XRayClientTypes.ValueWithServiceIds.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: XRayClientTypes.TraceUser.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.serviceIds = try reader["ServiceIds"].readListIfPresent(memberReadingClosure: XRayClientTypes.ServiceId.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceARNs = try reader["ResourceARNs"].readListIfPresent(memberReadingClosure: XRayClientTypes.ResourceARNDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceIds = try reader["InstanceIds"].readListIfPresent(memberReadingClosure: XRayClientTypes.InstanceIdDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: XRayClientTypes.AvailabilityZoneDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.entryPoint = try reader["EntryPoint"].readIfPresent(with: XRayClientTypes.ServiceId.read(from:))
        value.faultRootCauses = try reader["FaultRootCauses"].readListIfPresent(memberReadingClosure: XRayClientTypes.FaultRootCause.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorRootCauses = try reader["ErrorRootCauses"].readListIfPresent(memberReadingClosure: XRayClientTypes.ErrorRootCause.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.responseTimeRootCauses = try reader["ResponseTimeRootCauses"].readListIfPresent(memberReadingClosure: XRayClientTypes.ResponseTimeRootCause.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.revision = try reader["Revision"].readIfPresent() ?? 0
        value.matchedEventTime = try reader["MatchedEventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension XRayClientTypes.ResponseTimeRootCause {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.ResponseTimeRootCause {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.ResponseTimeRootCause()
        value.services = try reader["Services"].readListIfPresent(memberReadingClosure: XRayClientTypes.ResponseTimeRootCauseService.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.clientImpacting = try reader["ClientImpacting"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.ResponseTimeRootCauseService {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.ResponseTimeRootCauseService {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.ResponseTimeRootCauseService()
        value.name = try reader["Name"].readIfPresent()
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.entityPath = try reader["EntityPath"].readListIfPresent(memberReadingClosure: XRayClientTypes.ResponseTimeRootCauseEntity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferred = try reader["Inferred"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.ResponseTimeRootCauseEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.ResponseTimeRootCauseEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.ResponseTimeRootCauseEntity()
        value.name = try reader["Name"].readIfPresent()
        value.coverage = try reader["Coverage"].readIfPresent()
        value.remote = try reader["Remote"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.ErrorRootCause {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.ErrorRootCause {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.ErrorRootCause()
        value.services = try reader["Services"].readListIfPresent(memberReadingClosure: XRayClientTypes.ErrorRootCauseService.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.clientImpacting = try reader["ClientImpacting"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.ErrorRootCauseService {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.ErrorRootCauseService {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.ErrorRootCauseService()
        value.name = try reader["Name"].readIfPresent()
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.entityPath = try reader["EntityPath"].readListIfPresent(memberReadingClosure: XRayClientTypes.ErrorRootCauseEntity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferred = try reader["Inferred"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.ErrorRootCauseEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.ErrorRootCauseEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.ErrorRootCauseEntity()
        value.name = try reader["Name"].readIfPresent()
        value.exceptions = try reader["Exceptions"].readListIfPresent(memberReadingClosure: XRayClientTypes.RootCauseException.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.remote = try reader["Remote"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.RootCauseException {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.RootCauseException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.RootCauseException()
        value.name = try reader["Name"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.FaultRootCause {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.FaultRootCause {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.FaultRootCause()
        value.services = try reader["Services"].readListIfPresent(memberReadingClosure: XRayClientTypes.FaultRootCauseService.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.clientImpacting = try reader["ClientImpacting"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.FaultRootCauseService {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.FaultRootCauseService {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.FaultRootCauseService()
        value.name = try reader["Name"].readIfPresent()
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.entityPath = try reader["EntityPath"].readListIfPresent(memberReadingClosure: XRayClientTypes.FaultRootCauseEntity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferred = try reader["Inferred"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.FaultRootCauseEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.FaultRootCauseEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.FaultRootCauseEntity()
        value.name = try reader["Name"].readIfPresent()
        value.exceptions = try reader["Exceptions"].readListIfPresent(memberReadingClosure: XRayClientTypes.RootCauseException.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.remote = try reader["Remote"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.AvailabilityZoneDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.AvailabilityZoneDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.AvailabilityZoneDetail()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.InstanceIdDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.InstanceIdDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.InstanceIdDetail()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.ResourceARNDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.ResourceARNDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.ResourceARNDetail()
        value.arn = try reader["ARN"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.TraceUser {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.TraceUser {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.TraceUser()
        value.userName = try reader["UserName"].readIfPresent()
        value.serviceIds = try reader["ServiceIds"].readListIfPresent(memberReadingClosure: XRayClientTypes.ServiceId.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension XRayClientTypes.ValueWithServiceIds {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.ValueWithServiceIds {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.ValueWithServiceIds()
        value.annotationValue = try reader["AnnotationValue"].readIfPresent(with: XRayClientTypes.AnnotationValue.read(from:))
        value.serviceIds = try reader["ServiceIds"].readListIfPresent(memberReadingClosure: XRayClientTypes.ServiceId.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension XRayClientTypes.AnnotationValue {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.AnnotationValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "NumberValue":
                return .numbervalue(try reader["NumberValue"].read())
            case "BooleanValue":
                return .booleanvalue(try reader["BooleanValue"].read())
            case "StringValue":
                return .stringvalue(try reader["StringValue"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension XRayClientTypes.Http {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.Http {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.Http()
        value.httpURL = try reader["HttpURL"].readIfPresent()
        value.httpStatus = try reader["HttpStatus"].readIfPresent()
        value.httpMethod = try reader["HttpMethod"].readIfPresent()
        value.userAgent = try reader["UserAgent"].readIfPresent()
        value.clientIp = try reader["ClientIp"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.ResourcePolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.ResourcePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.ResourcePolicy()
        value.policyName = try reader["PolicyName"].readIfPresent()
        value.policyDocument = try reader["PolicyDocument"].readIfPresent()
        value.policyRevisionId = try reader["PolicyRevisionId"].readIfPresent()
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension XRayClientTypes.Tag {

    static func write(value: XRayClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension XRayClientTypes.UnprocessedTraceSegment {

    static func read(from reader: SmithyJSON.Reader) throws -> XRayClientTypes.UnprocessedTraceSegment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = XRayClientTypes.UnprocessedTraceSegment()
        value.id = try reader["Id"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension XRayClientTypes.SamplingStatisticsDocument {

    static func write(value: XRayClientTypes.SamplingStatisticsDocument?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BorrowCount"].write(value.borrowCount)
        try writer["ClientID"].write(value.clientID)
        try writer["RequestCount"].write(value.requestCount)
        try writer["RuleName"].write(value.ruleName)
        try writer["SampledCount"].write(value.sampledCount)
        try writer["Timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension XRayClientTypes.SamplingStrategy {

    static func write(value: XRayClientTypes.SamplingStrategy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }
}

extension XRayClientTypes.TelemetryRecord {

    static func write(value: XRayClientTypes.TelemetryRecord?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackendConnectionErrors"].write(value.backendConnectionErrors, with: XRayClientTypes.BackendConnectionErrors.write(value:to:))
        try writer["SegmentsReceivedCount"].write(value.segmentsReceivedCount)
        try writer["SegmentsRejectedCount"].write(value.segmentsRejectedCount)
        try writer["SegmentsSentCount"].write(value.segmentsSentCount)
        try writer["SegmentsSpilloverCount"].write(value.segmentsSpilloverCount)
        try writer["Timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension XRayClientTypes.BackendConnectionErrors {

    static func write(value: XRayClientTypes.BackendConnectionErrors?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionRefusedCount"].write(value.connectionRefusedCount)
        try writer["HTTPCode4XXCount"].write(value.httpCode4XXCount)
        try writer["HTTPCode5XXCount"].write(value.httpCode5XXCount)
        try writer["OtherCount"].write(value.otherCount)
        try writer["TimeoutCount"].write(value.timeoutCount)
        try writer["UnknownHostCount"].write(value.unknownHostCount)
    }
}

extension XRayClientTypes.SamplingRuleUpdate {

    static func write(value: XRayClientTypes.SamplingRuleUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["FixedRate"].write(value.fixedRate)
        try writer["HTTPMethod"].write(value.httpMethod)
        try writer["Host"].write(value.host)
        try writer["Priority"].write(value.priority)
        try writer["ReservoirSize"].write(value.reservoirSize)
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["RuleARN"].write(value.ruleARN)
        try writer["RuleName"].write(value.ruleName)
        try writer["ServiceName"].write(value.serviceName)
        try writer["ServiceType"].write(value.serviceType)
        try writer["URLPath"].write(value.urlPath)
    }
}

public enum XRayClientTypes {}
