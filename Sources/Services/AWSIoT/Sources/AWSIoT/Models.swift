//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

public struct AcceptCertificateTransferOutput {

    public init() { }
}

public struct AttachPolicyOutput {

    public init() { }
}

public struct AttachPrincipalPolicyOutput {

    public init() { }
}

public struct CancelCertificateTransferOutput {

    public init() { }
}

public struct CancelJobExecutionOutput {

    public init() { }
}

public struct CreateTopicRuleOutput {

    public init() { }
}

public struct DeleteCertificateOutput {

    public init() { }
}

public struct DeleteFleetMetricOutput {

    public init() { }
}

public struct DeleteJobExecutionOutput {

    public init() { }
}

public struct DeleteJobOutput {

    public init() { }
}

public struct DeleteJobTemplateOutput {

    public init() { }
}

public struct DeletePolicyOutput {

    public init() { }
}

public struct DeletePolicyVersionOutput {

    public init() { }
}

public struct DeleteTopicRuleOutput {

    public init() { }
}

public struct DeleteV2LoggingLevelOutput {

    public init() { }
}

public struct DetachPolicyOutput {

    public init() { }
}

public struct DetachPrincipalPolicyOutput {

    public init() { }
}

public struct DisableTopicRuleOutput {

    public init() { }
}

public struct EnableTopicRuleOutput {

    public init() { }
}

public struct RejectCertificateTransferOutput {

    public init() { }
}

public struct ReplaceTopicRuleOutput {

    public init() { }
}

public struct SetDefaultPolicyVersionOutput {

    public init() { }
}

public struct SetLoggingOptionsOutput {

    public init() { }
}

public struct SetV2LoggingLevelOutput {

    public init() { }
}

public struct SetV2LoggingOptionsOutput {

    public init() { }
}

public struct UpdateCACertificateOutput {

    public init() { }
}

public struct UpdateCertificateOutput {

    public init() { }
}

public struct UpdateFleetMetricOutput {

    public init() { }
}

public struct UpdateJobOutput {

    public init() { }
}

extension IoTClientTypes {

    public enum AbortAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancel
        case sdkUnknown(Swift.String)

        public static var allCases: [AbortAction] {
            return [
                .cancel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {

    public enum JobExecutionFailureType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case failed
        case rejected
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [JobExecutionFailureType] {
            return [
                .all,
                .failed,
                .rejected,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .rejected: return "REJECTED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The criteria that determine when and how a job abort takes place.
    public struct AbortCriteria {
        /// The type of job action to take to initiate the job abort.
        /// This member is required.
        public var action: IoTClientTypes.AbortAction?
        /// The type of job execution failures that can initiate a job abort.
        /// This member is required.
        public var failureType: IoTClientTypes.JobExecutionFailureType?
        /// The minimum number of things which must receive job execution notifications before the job can be aborted.
        /// This member is required.
        public var minNumberOfExecutedThings: Swift.Int?
        /// The minimum percentage of job execution failures that must occur to initiate the job abort. Amazon Web Services IoT Core supports up to two digits after the decimal (for example, 10.9 and 10.99, but not 10.999).
        /// This member is required.
        public var thresholdPercentage: Swift.Double?

        public init(
            action: IoTClientTypes.AbortAction? = nil,
            failureType: IoTClientTypes.JobExecutionFailureType? = nil,
            minNumberOfExecutedThings: Swift.Int? = nil,
            thresholdPercentage: Swift.Double? = nil
        )
        {
            self.action = action
            self.failureType = failureType
            self.minNumberOfExecutedThings = minNumberOfExecutedThings
            self.thresholdPercentage = thresholdPercentage
        }
    }

}

extension IoTClientTypes {
    /// The criteria that determine when and how a job abort takes place.
    public struct AbortConfig {
        /// The list of criteria that determine when and how to abort the job.
        /// This member is required.
        public var criteriaList: [IoTClientTypes.AbortCriteria]?

        public init(
            criteriaList: [IoTClientTypes.AbortCriteria]? = nil
        )
        {
            self.criteriaList = criteriaList
        }
    }

}

/// An unexpected error has occurred.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request is not valid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service is temporarily unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You can't revert the certificate transfer because the transfer is already complete.
public struct TransferAlreadyCompletedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TransferAlreadyCompletedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You are not authorized to perform this operation.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input for the AcceptCertificateTransfer operation.
public struct AcceptCertificateTransferInput {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?
    /// Specifies whether the certificate is active.
    public var setAsActive: Swift.Bool?

    public init(
        certificateId: Swift.String? = nil,
        setAsActive: Swift.Bool? = false
    )
    {
        self.certificateId = certificateId
        self.setAsActive = setAsActive
    }
}

extension IoTClientTypes {
    /// Describes an action that updates a CloudWatch alarm.
    public struct CloudwatchAlarmAction {
        /// The CloudWatch alarm name.
        /// This member is required.
        public var alarmName: Swift.String?
        /// The IAM role that allows access to the CloudWatch alarm.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The reason for the alarm change.
        /// This member is required.
        public var stateReason: Swift.String?
        /// The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        /// This member is required.
        public var stateValue: Swift.String?

        public init(
            alarmName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            stateReason: Swift.String? = nil,
            stateValue: Swift.String? = nil
        )
        {
            self.alarmName = alarmName
            self.roleArn = roleArn
            self.stateReason = stateReason
            self.stateValue = stateValue
        }
    }

}

extension IoTClientTypes {
    /// Describes an action that sends data to CloudWatch Logs.
    public struct CloudwatchLogsAction {
        /// Indicates whether batches of log records will be extracted and uploaded into CloudWatch. Values include true or false (default).
        public var batchMode: Swift.Bool?
        /// The CloudWatch log group to which the action sends data.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The IAM role that allows access to the CloudWatch log.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            batchMode: Swift.Bool? = nil,
            logGroupName: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.batchMode = batchMode
            self.logGroupName = logGroupName
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes {
    /// Describes an action that captures a CloudWatch metric.
    public struct CloudwatchMetricAction {
        /// The CloudWatch metric name.
        /// This member is required.
        public var metricName: Swift.String?
        /// The CloudWatch metric namespace name.
        /// This member is required.
        public var metricNamespace: Swift.String?
        /// An optional [Unix timestamp](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
        public var metricTimestamp: Swift.String?
        /// The [metric unit](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit) supported by CloudWatch.
        /// This member is required.
        public var metricUnit: Swift.String?
        /// The CloudWatch metric value.
        /// This member is required.
        public var metricValue: Swift.String?
        /// The IAM role that allows access to the CloudWatch metric.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            metricName: Swift.String? = nil,
            metricNamespace: Swift.String? = nil,
            metricTimestamp: Swift.String? = nil,
            metricUnit: Swift.String? = nil,
            metricValue: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.metricNamespace = metricNamespace
            self.metricTimestamp = metricTimestamp
            self.metricUnit = metricUnit
            self.metricValue = metricValue
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes {

    public enum DynamoKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [DynamoKeyType] {
            return [
                .number,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .number: return "NUMBER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Describes an action to write to a DynamoDB table. The tableName, hashKeyField, and rangeKeyField values must match the values used when you created the table. The hashKeyValue and rangeKeyvalue fields use a substitution template syntax. These templates provide data at runtime. The syntax is as follows: ${sql-expression}. You can specify any valid expression in a WHERE or SELECT clause, including JSON properties, comparisons, calculations, and functions. For example, the following field uses the third level of the topic: "hashKeyValue": "${topic(3)}" The following field uses the timestamp: "rangeKeyValue": "${timestamp()}"
    public struct DynamoDBAction {
        /// The hash key name.
        /// This member is required.
        public var hashKeyField: Swift.String?
        /// The hash key type. Valid values are "STRING" or "NUMBER"
        public var hashKeyType: IoTClientTypes.DynamoKeyType?
        /// The hash key value.
        /// This member is required.
        public var hashKeyValue: Swift.String?
        /// The type of operation to be performed. This follows the substitution template, so it can be ${operation}, but the substitution must result in one of the following: INSERT, UPDATE, or DELETE.
        public var operation: Swift.String?
        /// The action payload. This name can be customized.
        public var payloadField: Swift.String?
        /// The range key name.
        public var rangeKeyField: Swift.String?
        /// The range key type. Valid values are "STRING" or "NUMBER"
        public var rangeKeyType: IoTClientTypes.DynamoKeyType?
        /// The range key value.
        public var rangeKeyValue: Swift.String?
        /// The ARN of the IAM role that grants access to the DynamoDB table.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The name of the DynamoDB table.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            hashKeyField: Swift.String? = nil,
            hashKeyType: IoTClientTypes.DynamoKeyType? = nil,
            hashKeyValue: Swift.String? = nil,
            operation: Swift.String? = nil,
            payloadField: Swift.String? = nil,
            rangeKeyField: Swift.String? = nil,
            rangeKeyType: IoTClientTypes.DynamoKeyType? = nil,
            rangeKeyValue: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.hashKeyField = hashKeyField
            self.hashKeyType = hashKeyType
            self.hashKeyValue = hashKeyValue
            self.operation = operation
            self.payloadField = payloadField
            self.rangeKeyField = rangeKeyField
            self.rangeKeyType = rangeKeyType
            self.rangeKeyValue = rangeKeyValue
            self.roleArn = roleArn
            self.tableName = tableName
        }
    }

}

extension IoTClientTypes {
    /// The input for the DynamoActionVS action that specifies the DynamoDB table to which the message data will be written.
    public struct PutItemInput {
        /// The table where the message data will be written.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            tableName: Swift.String? = nil
        )
        {
            self.tableName = tableName
        }
    }

}

extension IoTClientTypes {
    /// Describes an action to write to a DynamoDB table. This DynamoDB action writes each attribute in the message payload into it's own column in the DynamoDB table.
    public struct DynamoDBv2Action {
        /// Specifies the DynamoDB table to which the message data will be written. For example: { "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } } Each attribute in the message payload will be written to a separate column in the DynamoDB database.
        /// This member is required.
        public var putItem: IoTClientTypes.PutItemInput?
        /// The ARN of the IAM role that grants access to the DynamoDB table.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            putItem: IoTClientTypes.PutItemInput? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.putItem = putItem
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes {
    /// Describes an action that writes data to an Amazon OpenSearch Service domain. The Elasticsearch action can only be used by existing rule actions. To create a new rule action or to update an existing rule action, use the OpenSearch rule action instead. For more information, see [OpenSearchAction](https://docs.aws.amazon.com/iot/latest/apireference/API_OpenSearchAction.html).
    public struct ElasticsearchAction {
        /// The endpoint of your OpenSearch domain.
        /// This member is required.
        public var endpoint: Swift.String?
        /// The unique identifier for the document you are storing.
        /// This member is required.
        public var id: Swift.String?
        /// The index where you want to store your data.
        /// This member is required.
        public var index: Swift.String?
        /// The IAM role ARN that has access to OpenSearch.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The type of document you are storing.
        /// This member is required.
        public var type: Swift.String?

        public init(
            endpoint: Swift.String? = nil,
            id: Swift.String? = nil,
            index: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.id = id
            self.index = index
            self.roleArn = roleArn
            self.type = type
        }
    }

}

extension IoTClientTypes {
    /// Describes an action that writes data to an Amazon Kinesis Firehose stream.
    public struct FirehoseAction {
        /// Whether to deliver the Kinesis Data Firehose stream as a batch by using [PutRecordBatch](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html). The default value is false. When batchMode is true and the rule's SQL statement evaluates to an Array, each Array element forms one record in the [PutRecordBatch](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html) request. The resulting array can't have more than 500 records.
        public var batchMode: Swift.Bool?
        /// The delivery stream name.
        /// This member is required.
        public var deliveryStreamName: Swift.String?
        /// The IAM role that grants access to the Amazon Kinesis Firehose stream.
        /// This member is required.
        public var roleArn: Swift.String?
        /// A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
        public var separator: Swift.String?

        public init(
            batchMode: Swift.Bool? = nil,
            deliveryStreamName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            separator: Swift.String? = nil
        )
        {
            self.batchMode = batchMode
            self.deliveryStreamName = deliveryStreamName
            self.roleArn = roleArn
            self.separator = separator
        }
    }

}

extension IoTClientTypes {
    /// For more information, see [Signature Version 4 signing process](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html).
    public struct SigV4Authorization {
        /// The ARN of the signing role.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The service name to use while signing with Sig V4.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The signing region.
        /// This member is required.
        public var signingRegion: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            signingRegion: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.serviceName = serviceName
            self.signingRegion = signingRegion
        }
    }

}

extension IoTClientTypes {
    /// The authorization method used to send messages.
    public struct HttpAuthorization {
        /// Use Sig V4 authorization. For more information, see [Signature Version 4 Signing Process](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html).
        public var sigv4: IoTClientTypes.SigV4Authorization?

        public init(
            sigv4: IoTClientTypes.SigV4Authorization? = nil
        )
        {
            self.sigv4 = sigv4
        }
    }

}

extension IoTClientTypes {
    /// The HTTP action header.
    public struct HttpActionHeader {
        /// The HTTP header key.
        /// This member is required.
        public var key: Swift.String?
        /// The HTTP header value. Substitution templates are supported.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension IoTClientTypes {
    /// Send data to an HTTPS endpoint.
    public struct HttpAction {
        /// The authentication method to use when sending data to an HTTPS endpoint.
        public var auth: IoTClientTypes.HttpAuthorization?
        /// The URL to which IoT sends a confirmation message. The value of the confirmation URL must be a prefix of the endpoint URL. If you do not specify a confirmation URL IoT uses the endpoint URL as the confirmation URL. If you use substitution templates in the confirmationUrl, you must create and enable topic rule destinations that match each possible value of the substitution template before traffic is allowed to your endpoint URL.
        public var confirmationUrl: Swift.String?
        /// The HTTP headers to send with the message data.
        public var headers: [IoTClientTypes.HttpActionHeader]?
        /// The endpoint URL. If substitution templates are used in the URL, you must also specify a confirmationUrl. If this is a new destination, a new TopicRuleDestination is created if possible.
        /// This member is required.
        public var url: Swift.String?

        public init(
            auth: IoTClientTypes.HttpAuthorization? = nil,
            confirmationUrl: Swift.String? = nil,
            headers: [IoTClientTypes.HttpActionHeader]? = nil,
            url: Swift.String? = nil
        )
        {
            self.auth = auth
            self.confirmationUrl = confirmationUrl
            self.headers = headers
            self.url = url
        }
    }

}

extension IoTClientTypes {
    /// Sends message data to an IoT Analytics channel.
    public struct IotAnalyticsAction {
        /// Whether to process the action as a batch. The default value is false. When batchMode is true and the rule SQL statement evaluates to an Array, each Array element is delivered as a separate message when passed by [BatchPutMessage](https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_BatchPutMessage.html) to the IoT Analytics channel. The resulting array can't have more than 100 messages.
        public var batchMode: Swift.Bool?
        /// (deprecated) The ARN of the IoT Analytics channel to which message data will be sent.
        public var channelArn: Swift.String?
        /// The name of the IoT Analytics channel to which message data will be sent.
        public var channelName: Swift.String?
        /// The ARN of the role which has a policy that grants IoT Analytics permission to send message data via IoT Analytics (iotanalytics:BatchPutMessage).
        public var roleArn: Swift.String?

        public init(
            batchMode: Swift.Bool? = nil,
            channelArn: Swift.String? = nil,
            channelName: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.batchMode = batchMode
            self.channelArn = channelArn
            self.channelName = channelName
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes {
    /// Sends an input to an IoT Events detector.
    public struct IotEventsAction {
        /// Whether to process the event actions as a batch. The default value is false. When batchMode is true, you can't specify a messageId. When batchMode is true and the rule SQL statement evaluates to an Array, each Array element is treated as a separate message when it's sent to IoT Events by calling [BatchPutMessage](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchPutMessage.html). The resulting array can't have more than 10 messages.
        public var batchMode: Swift.Bool?
        /// The name of the IoT Events input.
        /// This member is required.
        public var inputName: Swift.String?
        /// The ID of the message. The default messageId is a new UUID value. When batchMode is true, you can't specify a messageId--a new UUID value will be assigned. Assign a value to this property to ensure that only one input (message) with a given messageId will be processed by an IoT Events detector.
        public var messageId: Swift.String?
        /// The ARN of the role that grants IoT permission to send an input to an IoT Events detector. ("Action":"iotevents:BatchPutMessage").
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            batchMode: Swift.Bool? = nil,
            inputName: Swift.String? = nil,
            messageId: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.batchMode = batchMode
            self.inputName = inputName
            self.messageId = messageId
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes {
    /// An asset property timestamp entry containing the following information.
    public struct AssetPropertyTimestamp {
        /// Optional. A string that contains the nanosecond time offset. Accepts substitution templates.
        public var offsetInNanos: Swift.String?
        /// A string that contains the time in seconds since epoch. Accepts substitution templates.
        /// This member is required.
        public var timeInSeconds: Swift.String?

        public init(
            offsetInNanos: Swift.String? = nil,
            timeInSeconds: Swift.String? = nil
        )
        {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }
    }

}

extension IoTClientTypes {
    /// Contains an asset property value (of a single type).
    public enum AssetPropertyVariant {
        /// Optional. The string value of the value entry. Accepts substitution templates.
        case stringvalue(Swift.String)
        /// Optional. A string that contains the integer value of the value entry. Accepts substitution templates.
        case integervalue(Swift.String)
        /// Optional. A string that contains the double value of the value entry. Accepts substitution templates.
        case doublevalue(Swift.String)
        /// Optional. A string that contains the boolean value (true or false) of the value entry. Accepts substitution templates.
        case booleanvalue(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension IoTClientTypes {
    /// An asset property value entry containing the following information.
    public struct AssetPropertyValue {
        /// Optional. A string that describes the quality of the value. Accepts substitution templates. Must be GOOD, BAD, or UNCERTAIN.
        public var quality: Swift.String?
        /// The asset property value timestamp.
        /// This member is required.
        public var timestamp: IoTClientTypes.AssetPropertyTimestamp?
        /// The value of the asset property.
        /// This member is required.
        public var value: IoTClientTypes.AssetPropertyVariant?

        public init(
            quality: Swift.String? = nil,
            timestamp: IoTClientTypes.AssetPropertyTimestamp? = nil,
            value: IoTClientTypes.AssetPropertyVariant? = nil
        )
        {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTClientTypes {
    /// An asset property value entry containing the following information.
    public struct PutAssetPropertyValueEntry {
        /// The ID of the IoT SiteWise asset. You must specify either a propertyAlias or both an aliasId and a propertyId. Accepts substitution templates.
        public var assetId: Swift.String?
        /// Optional. A unique identifier for this entry that you can define to better track which message caused an error in case of failure. Accepts substitution templates. Defaults to a new UUID.
        public var entryId: Swift.String?
        /// The name of the property alias associated with your asset property. You must specify either a propertyAlias or both an aliasId and a propertyId. Accepts substitution templates.
        public var propertyAlias: Swift.String?
        /// The ID of the asset's property. You must specify either a propertyAlias or both an aliasId and a propertyId. Accepts substitution templates.
        public var propertyId: Swift.String?
        /// A list of property values to insert that each contain timestamp, quality, and value (TQV) information.
        /// This member is required.
        public var propertyValues: [IoTClientTypes.AssetPropertyValue]?

        public init(
            assetId: Swift.String? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            propertyValues: [IoTClientTypes.AssetPropertyValue]? = nil
        )
        {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValues = propertyValues
        }
    }

}

extension IoTClientTypes {
    /// Describes an action to send data from an MQTT message that triggered the rule to IoT SiteWise asset properties.
    public struct IotSiteWiseAction {
        /// A list of asset property value entries.
        /// This member is required.
        public var putAssetPropertyValueEntries: [IoTClientTypes.PutAssetPropertyValueEntry]?
        /// The ARN of the role that grants IoT permission to send an asset property value to IoT SiteWise. ("Action": "iotsitewise:BatchPutAssetPropertyValue"). The trust policy can restrict access to specific asset hierarchy paths.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            putAssetPropertyValueEntries: [IoTClientTypes.PutAssetPropertyValueEntry]? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.putAssetPropertyValueEntries = putAssetPropertyValueEntries
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes {
    /// Specifies a Kafka header using key-value pairs when you create a Rule’s Kafka Action. You can use these headers to route data from IoT clients to downstream Kafka clusters without modifying your message payload. For more information about Rule's Kafka action, see [Apache Kafka](https://docs.aws.amazon.com/iot/latest/developerguide/apache-kafka-rule-action.html).
    public struct KafkaActionHeader {
        /// The key of the Kafka header.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the Kafka header.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension IoTClientTypes {
    /// Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.
    public struct KafkaAction {
        /// Properties of the Apache Kafka producer client.
        /// This member is required.
        public var clientProperties: [Swift.String: Swift.String]?
        /// The ARN of Kafka action's VPC TopicRuleDestination.
        /// This member is required.
        public var destinationArn: Swift.String?
        /// The list of Kafka headers that you specify.
        public var headers: [IoTClientTypes.KafkaActionHeader]?
        /// The Kafka message key.
        public var key: Swift.String?
        /// The Kafka message partition.
        public var partition: Swift.String?
        /// The Kafka topic for messages to be sent to the Kafka broker.
        /// This member is required.
        public var topic: Swift.String?

        public init(
            clientProperties: [Swift.String: Swift.String]? = nil,
            destinationArn: Swift.String? = nil,
            headers: [IoTClientTypes.KafkaActionHeader]? = nil,
            key: Swift.String? = nil,
            partition: Swift.String? = nil,
            topic: Swift.String? = nil
        )
        {
            self.clientProperties = clientProperties
            self.destinationArn = destinationArn
            self.headers = headers
            self.key = key
            self.partition = partition
            self.topic = topic
        }
    }

}

extension IoTClientTypes {
    /// Describes an action to write data to an Amazon Kinesis stream.
    public struct KinesisAction {
        /// The partition key.
        public var partitionKey: Swift.String?
        /// The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The name of the Amazon Kinesis stream.
        /// This member is required.
        public var streamName: Swift.String?

        public init(
            partitionKey: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            streamName: Swift.String? = nil
        )
        {
            self.partitionKey = partitionKey
            self.roleArn = roleArn
            self.streamName = streamName
        }
    }

}

extension IoTClientTypes {
    /// Describes an action to invoke a Lambda function.
    public struct LambdaAction {
        /// The ARN of the Lambda function.
        /// This member is required.
        public var functionArn: Swift.String?

        public init(
            functionArn: Swift.String? = nil
        )
        {
            self.functionArn = functionArn
        }
    }

}

extension IoTClientTypes {
    /// Describes how to interpret an application-defined timestamp value from an MQTT message payload and the precision of that value.
    public struct LocationTimestamp {
        /// The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS | MILLISECONDS | MICROSECONDS | NANOSECONDS. The default is MILLISECONDS.
        public var unit: Swift.String?
        /// An expression that returns a long epoch time value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            unit: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension IoTClientTypes {
    /// The Amazon Location rule action sends device location updates from an MQTT message to an Amazon Location tracker resource.
    public struct LocationAction {
        /// The unique ID of the device providing the location data.
        /// This member is required.
        public var deviceId: Swift.String?
        /// A string that evaluates to a double value that represents the latitude of the device's location.
        /// This member is required.
        public var latitude: Swift.String?
        /// A string that evaluates to a double value that represents the longitude of the device's location.
        /// This member is required.
        public var longitude: Swift.String?
        /// The IAM role that grants permission to write to the Amazon Location resource.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The time that the location data was sampled. The default value is the time the MQTT message was processed.
        public var timestamp: IoTClientTypes.LocationTimestamp?
        /// The name of the tracker resource in Amazon Location in which the location is updated.
        /// This member is required.
        public var trackerName: Swift.String?

        public init(
            deviceId: Swift.String? = nil,
            latitude: Swift.String? = nil,
            longitude: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            timestamp: IoTClientTypes.LocationTimestamp? = nil,
            trackerName: Swift.String? = nil
        )
        {
            self.deviceId = deviceId
            self.latitude = latitude
            self.longitude = longitude
            self.roleArn = roleArn
            self.timestamp = timestamp
            self.trackerName = trackerName
        }
    }

}

extension IoTClientTypes {
    /// Describes an action that writes data to an Amazon OpenSearch Service domain.
    public struct OpenSearchAction {
        /// The endpoint of your OpenSearch domain.
        /// This member is required.
        public var endpoint: Swift.String?
        /// The unique identifier for the document you are storing.
        /// This member is required.
        public var id: Swift.String?
        /// The OpenSearch index where you want to store your data.
        /// This member is required.
        public var index: Swift.String?
        /// The IAM role ARN that has access to OpenSearch.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The type of document you are storing.
        /// This member is required.
        public var type: Swift.String?

        public init(
            endpoint: Swift.String? = nil,
            id: Swift.String? = nil,
            index: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.id = id
            self.index = index
            self.roleArn = roleArn
            self.type = type
        }
    }

}

extension IoTClientTypes {
    /// A key-value pair that you define in the header. Both the key and the value are either literal strings or valid [substitution templates](https://docs.aws.amazon.com/iot/latest/developerguide/iot-substitution-templates.html).
    public struct UserProperty {
        /// A key to be specified in UserProperty.
        /// This member is required.
        public var key: Swift.String?
        /// A value to be specified in UserProperty.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension IoTClientTypes {
    /// Specifies MQTT Version 5.0 headers information. For more information, see [ MQTT](https://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html) from Amazon Web Services IoT Core Developer Guide.
    public struct MqttHeaders {
        /// A UTF-8 encoded string that describes the content of the publishing message. For more information, see [ Content Type](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901118) from the MQTT Version 5.0 specification. Supports [substitution templates](https://docs.aws.amazon.com/iot/latest/developerguide/iot-substitution-templates.html).
        public var contentType: Swift.String?
        /// The base64-encoded binary data used by the sender of the request message to identify which request the response message is for when it's received. For more information, see [ Correlation Data](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901115) from the MQTT Version 5.0 specification. This binary data must be based64-encoded. Supports [substitution templates](https://docs.aws.amazon.com/iot/latest/developerguide/iot-substitution-templates.html).
        public var correlationData: Swift.String?
        /// A user-defined integer value that will persist a message at the message broker for a specified amount of time to ensure that the message will expire if it's no longer relevant to the subscriber. The value of messageExpiry represents the number of seconds before it expires. For more information about the limits of messageExpiry, see [Amazon Web Services IoT Core message broker and protocol limits and quotas ](https://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html) from the Amazon Web Services Reference Guide. Supports [substitution templates](https://docs.aws.amazon.com/iot/latest/developerguide/iot-substitution-templates.html).
        public var messageExpiry: Swift.String?
        /// An Enum string value that indicates whether the payload is formatted as UTF-8. Valid values are UNSPECIFIED_BYTES and UTF8_DATA. For more information, see [ Payload Format Indicator](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901111) from the MQTT Version 5.0 specification. Supports [substitution templates](https://docs.aws.amazon.com/iot/latest/developerguide/iot-substitution-templates.html).
        public var payloadFormatIndicator: Swift.String?
        /// A UTF-8 encoded string that's used as the topic name for a response message. The response topic is used to describe the topic which the receiver should publish to as part of the request-response flow. The topic must not contain wildcard characters. For more information, see [ Response Topic](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901114) from the MQTT Version 5.0 specification. Supports [substitution templates](https://docs.aws.amazon.com/iot/latest/developerguide/iot-substitution-templates.html).
        public var responseTopic: Swift.String?
        /// An array of key-value pairs that you define in the MQTT5 header.
        public var userProperties: [IoTClientTypes.UserProperty]?

        public init(
            contentType: Swift.String? = nil,
            correlationData: Swift.String? = nil,
            messageExpiry: Swift.String? = nil,
            payloadFormatIndicator: Swift.String? = nil,
            responseTopic: Swift.String? = nil,
            userProperties: [IoTClientTypes.UserProperty]? = nil
        )
        {
            self.contentType = contentType
            self.correlationData = correlationData
            self.messageExpiry = messageExpiry
            self.payloadFormatIndicator = payloadFormatIndicator
            self.responseTopic = responseTopic
            self.userProperties = userProperties
        }
    }

}

extension IoTClientTypes {
    /// Describes an action to republish to another topic.
    public struct RepublishAction {
        /// MQTT Version 5.0 headers information. For more information, see [ MQTT](https://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html) from the Amazon Web Services IoT Core Developer Guide.
        public var headers: IoTClientTypes.MqttHeaders?
        /// The Quality of Service (QoS) level to use when republishing messages. The default value is 0.
        public var qos: Swift.Int?
        /// The ARN of the IAM role that grants access.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The name of the MQTT topic.
        /// This member is required.
        public var topic: Swift.String?

        public init(
            headers: IoTClientTypes.MqttHeaders? = nil,
            qos: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            topic: Swift.String? = nil
        )
        {
            self.headers = headers
            self.qos = qos
            self.roleArn = roleArn
            self.topic = topic
        }
    }

}

extension IoTClientTypes {

    public enum CannedAccessControlList: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authenticatedread
        case awsexecread
        case bucketownerfullcontrol
        case bucketownerread
        case logdeliverywrite
        case `private`
        case publicread
        case publicreadwrite
        case sdkUnknown(Swift.String)

        public static var allCases: [CannedAccessControlList] {
            return [
                .authenticatedread,
                .awsexecread,
                .bucketownerfullcontrol,
                .bucketownerread,
                .logdeliverywrite,
                .private,
                .publicread,
                .publicreadwrite
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authenticatedread: return "authenticated-read"
            case .awsexecread: return "aws-exec-read"
            case .bucketownerfullcontrol: return "bucket-owner-full-control"
            case .bucketownerread: return "bucket-owner-read"
            case .logdeliverywrite: return "log-delivery-write"
            case .private: return "private"
            case .publicread: return "public-read"
            case .publicreadwrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Describes an action to write data to an Amazon S3 bucket.
    public struct S3Action {
        /// The Amazon S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see [S3 canned ACLs](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl).
        public var cannedAcl: IoTClientTypes.CannedAccessControlList?
        /// The object key. For more information, see [Actions, resources, and condition keys for Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/dev/list_amazons3.html).
        /// This member is required.
        public var key: Swift.String?
        /// The ARN of the IAM role that grants access.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            cannedAcl: IoTClientTypes.CannedAccessControlList? = nil,
            key: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.cannedAcl = cannedAcl
            self.key = key
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes {
    /// Describes an action to write a message to a Salesforce IoT Cloud Input Stream.
    public struct SalesforceAction {
        /// The token used to authenticate access to the Salesforce IoT Cloud Input Stream. The token is available from the Salesforce IoT Cloud platform after creation of the Input Stream.
        /// This member is required.
        public var token: Swift.String?
        /// The URL exposed by the Salesforce IoT Cloud Input Stream. The URL is available from the Salesforce IoT Cloud platform after creation of the Input Stream.
        /// This member is required.
        public var url: Swift.String?

        public init(
            token: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.token = token
            self.url = url
        }
    }

}

extension IoTClientTypes {

    public enum MessageFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case raw
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageFormat] {
            return [
                .json,
                .raw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .raw: return "RAW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Describes an action to publish to an Amazon SNS topic.
    public struct SnsAction {
        /// (Optional) The message format of the message to publish. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. To read more about SNS message formats, see [https://docs.aws.amazon.com/sns/latest/dg/json-formats.html](https://docs.aws.amazon.com/sns/latest/dg/json-formats.html) refer to their official documentation.
        public var messageFormat: IoTClientTypes.MessageFormat?
        /// The ARN of the IAM role that grants access.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ARN of the SNS topic.
        /// This member is required.
        public var targetArn: Swift.String?

        public init(
            messageFormat: IoTClientTypes.MessageFormat? = nil,
            roleArn: Swift.String? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.messageFormat = messageFormat
            self.roleArn = roleArn
            self.targetArn = targetArn
        }
    }

}

extension IoTClientTypes {
    /// Describes an action to publish data to an Amazon SQS queue.
    public struct SqsAction {
        /// The URL of the Amazon SQS queue.
        /// This member is required.
        public var queueUrl: Swift.String?
        /// The ARN of the IAM role that grants access.
        /// This member is required.
        public var roleArn: Swift.String?
        /// Specifies whether to use Base64 encoding.
        public var useBase64: Swift.Bool?

        public init(
            queueUrl: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            useBase64: Swift.Bool? = nil
        )
        {
            self.queueUrl = queueUrl
            self.roleArn = roleArn
            self.useBase64 = useBase64
        }
    }

}

extension IoTClientTypes {
    /// Starts execution of a Step Functions state machine.
    public struct StepFunctionsAction {
        /// (Optional) A name will be given to the state machine execution consisting of this prefix followed by a UUID. Step Functions automatically creates a unique name for each state machine execution if one is not provided.
        public var executionNamePrefix: Swift.String?
        /// The ARN of the role that grants IoT permission to start execution of a state machine ("Action":"states:StartExecution").
        /// This member is required.
        public var roleArn: Swift.String?
        /// The name of the Step Functions state machine whose execution will be started.
        /// This member is required.
        public var stateMachineName: Swift.String?

        public init(
            executionNamePrefix: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            stateMachineName: Swift.String? = nil
        )
        {
            self.executionNamePrefix = executionNamePrefix
            self.roleArn = roleArn
            self.stateMachineName = stateMachineName
        }
    }

}

extension IoTClientTypes {
    /// Metadata attributes of the time series that are written in each measure record.
    public struct TimestreamDimension {
        /// The metadata dimension name. This is the name of the column in the Amazon Timestream database table record. Dimensions cannot be named: measure_name, measure_value, or time. These names are reserved. Dimension names cannot start with ts_ or measure_value and they cannot contain the colon (:) character.
        /// This member is required.
        public var name: Swift.String?
        /// The value to write in this column of the database record.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTClientTypes {
    /// Describes how to interpret an application-defined timestamp value from an MQTT message payload and the precision of that value.
    public struct TimestreamTimestamp {
        /// The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS | MILLISECONDS | MICROSECONDS | NANOSECONDS. The default is MILLISECONDS.
        /// This member is required.
        public var unit: Swift.String?
        /// An expression that returns a long epoch time value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            unit: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension IoTClientTypes {
    /// The Timestream rule action writes attributes (measures) from an MQTT message into an Amazon Timestream table. For more information, see the [Timestream](https://docs.aws.amazon.com/iot/latest/developerguide/timestream-rule-action.html) topic rule action documentation.
    public struct TimestreamAction {
        /// The name of an Amazon Timestream database.
        /// This member is required.
        public var databaseName: Swift.String?
        /// Metadata attributes of the time series that are written in each measure record.
        /// This member is required.
        public var dimensions: [IoTClientTypes.TimestreamDimension]?
        /// The ARN of the role that grants permission to write to the Amazon Timestream database table.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The name of the database table into which to write the measure records.
        /// This member is required.
        public var tableName: Swift.String?
        /// Specifies an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. You can use this property to specify the value and the precision of the Timestream record's timestamp. You can specify a value from the message payload or a value computed by a substitution template. If omitted, the topic rule action assigns the timestamp, in milliseconds, at the time it processed the rule.
        public var timestamp: IoTClientTypes.TimestreamTimestamp?

        public init(
            databaseName: Swift.String? = nil,
            dimensions: [IoTClientTypes.TimestreamDimension]? = nil,
            roleArn: Swift.String? = nil,
            tableName: Swift.String? = nil,
            timestamp: IoTClientTypes.TimestreamTimestamp? = nil
        )
        {
            self.databaseName = databaseName
            self.dimensions = dimensions
            self.roleArn = roleArn
            self.tableName = tableName
            self.timestamp = timestamp
        }
    }

}

extension IoTClientTypes {
    /// Describes the actions associated with a rule.
    public struct Action {
        /// Change the state of a CloudWatch alarm.
        public var cloudwatchAlarm: IoTClientTypes.CloudwatchAlarmAction?
        /// Send data to CloudWatch Logs.
        public var cloudwatchLogs: IoTClientTypes.CloudwatchLogsAction?
        /// Capture a CloudWatch metric.
        public var cloudwatchMetric: IoTClientTypes.CloudwatchMetricAction?
        /// Write to a DynamoDB table.
        public var dynamoDB: IoTClientTypes.DynamoDBAction?
        /// Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.
        public var dynamoDBv2: IoTClientTypes.DynamoDBv2Action?
        /// Write data to an Amazon OpenSearch Service domain. The Elasticsearch action can only be used by existing rule actions. To create a new rule action or to update an existing rule action, use the OpenSearch rule action instead. For more information, see [OpenSearchAction](https://docs.aws.amazon.com/iot/latest/apireference/API_OpenSearchAction.html).
        public var elasticsearch: IoTClientTypes.ElasticsearchAction?
        /// Write to an Amazon Kinesis Firehose stream.
        public var firehose: IoTClientTypes.FirehoseAction?
        /// Send data to an HTTPS endpoint.
        public var http: IoTClientTypes.HttpAction?
        /// Sends message data to an IoT Analytics channel.
        public var iotAnalytics: IoTClientTypes.IotAnalyticsAction?
        /// Sends an input to an IoT Events detector.
        public var iotEvents: IoTClientTypes.IotEventsAction?
        /// Sends data from the MQTT message that triggered the rule to IoT SiteWise asset properties.
        public var iotSiteWise: IoTClientTypes.IotSiteWiseAction?
        /// Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.
        public var kafka: IoTClientTypes.KafkaAction?
        /// Write data to an Amazon Kinesis stream.
        public var kinesis: IoTClientTypes.KinesisAction?
        /// Invoke a Lambda function.
        public var lambda: IoTClientTypes.LambdaAction?
        /// The Amazon Location Service rule action sends device location updates from an MQTT message to an Amazon Location tracker resource.
        public var location: IoTClientTypes.LocationAction?
        /// Write data to an Amazon OpenSearch Service domain.
        public var openSearch: IoTClientTypes.OpenSearchAction?
        /// Publish to another MQTT topic.
        public var republish: IoTClientTypes.RepublishAction?
        /// Write to an Amazon S3 bucket.
        public var s3: IoTClientTypes.S3Action?
        /// Send a message to a Salesforce IoT Cloud Input Stream.
        public var salesforce: IoTClientTypes.SalesforceAction?
        /// Publish to an Amazon SNS topic.
        public var sns: IoTClientTypes.SnsAction?
        /// Publish to an Amazon SQS queue.
        public var sqs: IoTClientTypes.SqsAction?
        /// Starts execution of a Step Functions state machine.
        public var stepFunctions: IoTClientTypes.StepFunctionsAction?
        /// The Timestream rule action writes attributes (measures) from an MQTT message into an Amazon Timestream table. For more information, see the [Timestream](https://docs.aws.amazon.com/iot/latest/developerguide/timestream-rule-action.html) topic rule action documentation.
        public var timestream: IoTClientTypes.TimestreamAction?

        public init(
            cloudwatchAlarm: IoTClientTypes.CloudwatchAlarmAction? = nil,
            cloudwatchLogs: IoTClientTypes.CloudwatchLogsAction? = nil,
            cloudwatchMetric: IoTClientTypes.CloudwatchMetricAction? = nil,
            dynamoDB: IoTClientTypes.DynamoDBAction? = nil,
            dynamoDBv2: IoTClientTypes.DynamoDBv2Action? = nil,
            elasticsearch: IoTClientTypes.ElasticsearchAction? = nil,
            firehose: IoTClientTypes.FirehoseAction? = nil,
            http: IoTClientTypes.HttpAction? = nil,
            iotAnalytics: IoTClientTypes.IotAnalyticsAction? = nil,
            iotEvents: IoTClientTypes.IotEventsAction? = nil,
            iotSiteWise: IoTClientTypes.IotSiteWiseAction? = nil,
            kafka: IoTClientTypes.KafkaAction? = nil,
            kinesis: IoTClientTypes.KinesisAction? = nil,
            lambda: IoTClientTypes.LambdaAction? = nil,
            location: IoTClientTypes.LocationAction? = nil,
            openSearch: IoTClientTypes.OpenSearchAction? = nil,
            republish: IoTClientTypes.RepublishAction? = nil,
            s3: IoTClientTypes.S3Action? = nil,
            salesforce: IoTClientTypes.SalesforceAction? = nil,
            sns: IoTClientTypes.SnsAction? = nil,
            sqs: IoTClientTypes.SqsAction? = nil,
            stepFunctions: IoTClientTypes.StepFunctionsAction? = nil,
            timestream: IoTClientTypes.TimestreamAction? = nil
        )
        {
            self.cloudwatchAlarm = cloudwatchAlarm
            self.cloudwatchLogs = cloudwatchLogs
            self.cloudwatchMetric = cloudwatchMetric
            self.dynamoDB = dynamoDB
            self.dynamoDBv2 = dynamoDBv2
            self.elasticsearch = elasticsearch
            self.firehose = firehose
            self.http = http
            self.iotAnalytics = iotAnalytics
            self.iotEvents = iotEvents
            self.iotSiteWise = iotSiteWise
            self.kafka = kafka
            self.kinesis = kinesis
            self.lambda = lambda
            self.location = location
            self.openSearch = openSearch
            self.republish = republish
            self.s3 = s3
            self.salesforce = salesforce
            self.sns = sns
            self.sqs = sqs
            self.stepFunctions = stepFunctions
            self.timestream = timestream
        }
    }

}

extension IoTClientTypes {

    public enum ActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connect
        case publish
        case receive
        case subscribe
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionType] {
            return [
                .connect,
                .publish,
                .receive,
                .subscribe
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connect: return "CONNECT"
            case .publish: return "PUBLISH"
            case .receive: return "RECEIVE"
            case .subscribe: return "SUBSCRIBE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {

    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case greaterThan
        case greaterThanEquals
        case inCidrSet
        case inPortSet
        case inSet
        case lessThan
        case lessThanEquals
        case notInCidrSet
        case notInPortSet
        case notInSet
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .greaterThan,
                .greaterThanEquals,
                .inCidrSet,
                .inPortSet,
                .inSet,
                .lessThan,
                .lessThanEquals,
                .notInCidrSet,
                .notInPortSet,
                .notInSet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .greaterThan: return "greater-than"
            case .greaterThanEquals: return "greater-than-equals"
            case .inCidrSet: return "in-cidr-set"
            case .inPortSet: return "in-port-set"
            case .inSet: return "in-set"
            case .lessThan: return "less-than"
            case .lessThanEquals: return "less-than-equals"
            case .notInCidrSet: return "not-in-cidr-set"
            case .notInPortSet: return "not-in-port-set"
            case .notInSet: return "not-in-set"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {

    public enum ConfidenceLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfidenceLevel] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The configuration of an ML Detect Security Profile.
    public struct MachineLearningDetectionConfig {
        /// The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
        /// This member is required.
        public var confidenceLevel: IoTClientTypes.ConfidenceLevel?

        public init(
            confidenceLevel: IoTClientTypes.ConfidenceLevel? = nil
        )
        {
            self.confidenceLevel = confidenceLevel
        }
    }

}

extension IoTClientTypes {
    /// A statistical ranking (percentile) that indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
    public struct StatisticalThreshold {
        /// The percentile that resolves to a threshold value by which compliance with a behavior is determined. Metrics are collected over the specified period (durationSeconds) from all reporting devices in your account and statistical ranks are calculated. Then, the measurements from a device are collected over the same period. If the accumulated measurements from the device fall above or below (comparisonOperator) the value associated with the percentile specified, then the device is considered to be in compliance with the behavior, otherwise a violation occurs.
        public var statistic: Swift.String?

        public init(
            statistic: Swift.String? = nil
        )
        {
            self.statistic = statistic
        }
    }

}

extension IoTClientTypes {
    /// The value to be compared with the metric.
    public struct MetricValue {
        /// If the comparisonOperator calls for a set of CIDRs, use this to specify that set to be compared with the metric.
        public var cidrs: [Swift.String]?
        /// If the comparisonOperator calls for a numeric value, use this to specify that numeric value to be compared with the metric.
        public var count: Swift.Int?
        /// The numeral value of a metric.
        public var number: Swift.Double?
        /// The numeral values of a metric.
        public var numbers: [Swift.Double]?
        /// If the comparisonOperator calls for a set of ports, use this to specify that set to be compared with the metric.
        public var ports: [Swift.Int]?
        /// The string values of a metric.
        public var strings: [Swift.String]?

        public init(
            cidrs: [Swift.String]? = nil,
            count: Swift.Int? = nil,
            number: Swift.Double? = nil,
            numbers: [Swift.Double]? = nil,
            ports: [Swift.Int]? = nil,
            strings: [Swift.String]? = nil
        )
        {
            self.cidrs = cidrs
            self.count = count
            self.number = number
            self.numbers = numbers
            self.ports = ports
            self.strings = strings
        }
    }

}

extension IoTClientTypes {
    /// The criteria by which the behavior is determined to be normal.
    public struct BehaviorCriteria {
        /// The operator that relates the thing measured (metric) to the criteria (containing a value or statisticalThreshold). Valid operators include:
        ///
        /// * string-list: in-set and not-in-set
        ///
        /// * number-list: in-set and not-in-set
        ///
        /// * ip-address-list: in-cidr-set and not-in-cidr-set
        ///
        /// * number: less-than, less-than-equals, greater-than, and greater-than-equals
        public var comparisonOperator: IoTClientTypes.ComparisonOperator?
        /// If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
        public var consecutiveDatapointsToAlarm: Swift.Int?
        /// If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
        public var consecutiveDatapointsToClear: Swift.Int?
        /// Use this to specify the time duration over which the behavior is evaluated, for those criteria that have a time dimension (for example, NUM_MESSAGES_SENT). For a statisticalThreshhold metric comparison, measurements from all devices are accumulated over this time duration before being used to calculate percentiles, and later, measurements from an individual device are also accumulated over this time duration before being given a percentile rank. Cannot be used with list-based metric datatypes.
        public var durationSeconds: Swift.Int?
        /// The configuration of an ML Detect
        public var mlDetectionConfig: IoTClientTypes.MachineLearningDetectionConfig?
        /// A statistical ranking (percentile)that indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
        public var statisticalThreshold: IoTClientTypes.StatisticalThreshold?
        /// The value to be compared with the metric.
        public var value: IoTClientTypes.MetricValue?

        public init(
            comparisonOperator: IoTClientTypes.ComparisonOperator? = nil,
            consecutiveDatapointsToAlarm: Swift.Int? = nil,
            consecutiveDatapointsToClear: Swift.Int? = nil,
            durationSeconds: Swift.Int? = nil,
            mlDetectionConfig: IoTClientTypes.MachineLearningDetectionConfig? = nil,
            statisticalThreshold: IoTClientTypes.StatisticalThreshold? = nil,
            value: IoTClientTypes.MetricValue? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.consecutiveDatapointsToAlarm = consecutiveDatapointsToAlarm
            self.consecutiveDatapointsToClear = consecutiveDatapointsToClear
            self.durationSeconds = durationSeconds
            self.mlDetectionConfig = mlDetectionConfig
            self.statisticalThreshold = statisticalThreshold
            self.value = value
        }
    }

}

extension IoTClientTypes {

    public enum DimensionValueOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `in`
        case notIn
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionValueOperator] {
            return [
                .in,
                .notIn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .in: return "IN"
            case .notIn: return "NOT_IN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The dimension of a metric.
    public struct MetricDimension {
        /// A unique identifier for the dimension.
        /// This member is required.
        public var dimensionName: Swift.String?
        /// Defines how the dimensionValues of a dimension are interpreted. For example, for dimension type TOPIC_FILTER, the IN operator, a message will be counted only if its topic matches one of the topic filters. With NOT_IN operator, a message will be counted only if it doesn't match any of the topic filters. The operator is optional: if it's not provided (is null), it will be interpreted as IN.
        public var `operator`: IoTClientTypes.DimensionValueOperator?

        public init(
            dimensionName: Swift.String? = nil,
            `operator`: IoTClientTypes.DimensionValueOperator? = nil
        )
        {
            self.dimensionName = dimensionName
            self.`operator` = `operator`
        }
    }

}

extension IoTClientTypes {
    /// A Device Defender security profile behavior.
    public struct Behavior {
        /// The criteria that determine if a device is behaving normally in regard to the metric. In the IoT console, you can choose to be sent an alert through Amazon SNS when IoT Device Defender detects that a device is behaving anomalously.
        public var criteria: IoTClientTypes.BehaviorCriteria?
        /// Value indicates exporting metrics related to the behavior when it is true.
        public var exportMetric: Swift.Bool?
        /// What is measured by the behavior.
        public var metric: Swift.String?
        /// The dimension for a metric in your behavior. For example, using a TOPIC_FILTER dimension, you can narrow down the scope of the metric to only MQTT topics where the name matches the pattern specified in the dimension. This can't be used with custom metrics.
        public var metricDimension: IoTClientTypes.MetricDimension?
        /// The name you've given to the behavior.
        /// This member is required.
        public var name: Swift.String?
        /// Suppresses alerts.
        public var suppressAlerts: Swift.Bool?

        public init(
            criteria: IoTClientTypes.BehaviorCriteria? = nil,
            exportMetric: Swift.Bool? = nil,
            metric: Swift.String? = nil,
            metricDimension: IoTClientTypes.MetricDimension? = nil,
            name: Swift.String? = nil,
            suppressAlerts: Swift.Bool? = nil
        )
        {
            self.criteria = criteria
            self.exportMetric = exportMetric
            self.metric = metric
            self.metricDimension = metricDimension
            self.name = name
            self.suppressAlerts = suppressAlerts
        }
    }

}

extension IoTClientTypes {

    public enum VerificationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case benignPositive
        case falsePositive
        case truePositive
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [VerificationState] {
            return [
                .benignPositive,
                .falsePositive,
                .truePositive,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .benignPositive: return "BENIGN_POSITIVE"
            case .falsePositive: return "FALSE_POSITIVE"
            case .truePositive: return "TRUE_POSITIVE"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The details of a violation event.
    public struct ViolationEventAdditionalInfo {
        /// The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
        public var confidenceLevel: IoTClientTypes.ConfidenceLevel?

        public init(
            confidenceLevel: IoTClientTypes.ConfidenceLevel? = nil
        )
        {
            self.confidenceLevel = confidenceLevel
        }
    }

}

extension IoTClientTypes {
    /// Information about an active Device Defender security profile behavior violation.
    public struct ActiveViolation {
        /// The behavior that is being violated.
        public var behavior: IoTClientTypes.Behavior?
        /// The time the most recent violation occurred.
        public var lastViolationTime: Foundation.Date?
        /// The value of the metric (the measurement) that caused the most recent violation.
        public var lastViolationValue: IoTClientTypes.MetricValue?
        /// The security profile with the behavior is in violation.
        public var securityProfileName: Swift.String?
        /// The name of the thing responsible for the active violation.
        public var thingName: Swift.String?
        /// The verification state of the violation (detect alarm).
        public var verificationState: IoTClientTypes.VerificationState?
        /// The description of the verification state of the violation.
        public var verificationStateDescription: Swift.String?
        /// The details of a violation event.
        public var violationEventAdditionalInfo: IoTClientTypes.ViolationEventAdditionalInfo?
        /// The ID of the active violation.
        public var violationId: Swift.String?
        /// The time the violation started.
        public var violationStartTime: Foundation.Date?

        public init(
            behavior: IoTClientTypes.Behavior? = nil,
            lastViolationTime: Foundation.Date? = nil,
            lastViolationValue: IoTClientTypes.MetricValue? = nil,
            securityProfileName: Swift.String? = nil,
            thingName: Swift.String? = nil,
            verificationState: IoTClientTypes.VerificationState? = nil,
            verificationStateDescription: Swift.String? = nil,
            violationEventAdditionalInfo: IoTClientTypes.ViolationEventAdditionalInfo? = nil,
            violationId: Swift.String? = nil,
            violationStartTime: Foundation.Date? = nil
        )
        {
            self.behavior = behavior
            self.lastViolationTime = lastViolationTime
            self.lastViolationValue = lastViolationValue
            self.securityProfileName = securityProfileName
            self.thingName = thingName
            self.verificationState = verificationState
            self.verificationStateDescription = verificationStateDescription
            self.violationEventAdditionalInfo = violationEventAdditionalInfo
            self.violationId = violationId
            self.violationStartTime = violationStartTime
        }
    }

}

extension IoTClientTypes {
    /// The metric you want to retain. Dimensions are optional.
    public struct MetricToRetain {
        /// The value indicates exporting metrics related to the MetricToRetain  when it's true.
        public var exportMetric: Swift.Bool?
        /// What is measured by the behavior.
        /// This member is required.
        public var metric: Swift.String?
        /// The dimension of a metric. This can't be used with custom metrics.
        public var metricDimension: IoTClientTypes.MetricDimension?

        public init(
            exportMetric: Swift.Bool? = nil,
            metric: Swift.String? = nil,
            metricDimension: IoTClientTypes.MetricDimension? = nil
        )
        {
            self.exportMetric = exportMetric
            self.metric = metric
            self.metricDimension = metricDimension
        }
    }

}

extension IoTClientTypes {
    /// Parameters used when defining a mitigation action that move a set of things to a thing group.
    public struct AddThingsToThingGroupParams {
        /// Specifies if this mitigation action can move the things that triggered the mitigation action even if they are part of one or more dynamic thing groups.
        public var overrideDynamicGroups: Swift.Bool?
        /// The list of groups to which you want to add the things that triggered the mitigation action. You can add a thing to a maximum of 10 groups, but you can't add a thing to more than one group in the same hierarchy.
        /// This member is required.
        public var thingGroupNames: [Swift.String]?

        public init(
            overrideDynamicGroups: Swift.Bool? = nil,
            thingGroupNames: [Swift.String]? = nil
        )
        {
            self.overrideDynamicGroups = overrideDynamicGroups
            self.thingGroupNames = thingGroupNames
        }
    }

}

public struct AddThingToBillingGroupInput {
    /// The ARN of the billing group.
    public var billingGroupArn: Swift.String?
    /// The name of the billing group. This call is asynchronous. It might take several seconds for the detachment to propagate.
    public var billingGroupName: Swift.String?
    /// The ARN of the thing to be added to the billing group.
    public var thingArn: Swift.String?
    /// The name of the thing to be added to the billing group.
    public var thingName: Swift.String?

    public init(
        billingGroupArn: Swift.String? = nil,
        billingGroupName: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingGroupName = billingGroupName
        self.thingArn = thingArn
        self.thingName = thingName
    }
}

public struct AddThingToBillingGroupOutput {

    public init() { }
}

public struct AddThingToThingGroupInput {
    /// Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.
    public var overrideDynamicGroups: Swift.Bool?
    /// The ARN of the thing to add to a group.
    public var thingArn: Swift.String?
    /// The ARN of the group to which you are adding a thing.
    public var thingGroupArn: Swift.String?
    /// The name of the group to which you are adding a thing.
    public var thingGroupName: Swift.String?
    /// The name of the thing to add to a group.
    public var thingName: Swift.String?

    public init(
        overrideDynamicGroups: Swift.Bool? = false,
        thingArn: Swift.String? = nil,
        thingGroupArn: Swift.String? = nil,
        thingGroupName: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.overrideDynamicGroups = overrideDynamicGroups
        self.thingArn = thingArn
        self.thingGroupArn = thingGroupArn
        self.thingGroupName = thingGroupName
        self.thingName = thingName
    }
}

public struct AddThingToThingGroupOutput {

    public init() { }
}

extension IoTClientTypes {

    public enum AggregationTypeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cardinality
        case percentiles
        case statistics
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationTypeName] {
            return [
                .cardinality,
                .percentiles,
                .statistics
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cardinality: return "Cardinality"
            case .percentiles: return "Percentiles"
            case .statistics: return "Statistics"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The type of aggregation queries.
    public struct AggregationType {
        /// The name of the aggregation type.
        /// This member is required.
        public var name: IoTClientTypes.AggregationTypeName?
        /// A list of the values of aggregation types.
        public var values: [Swift.String]?

        public init(
            name: IoTClientTypes.AggregationTypeName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension IoTClientTypes {
    /// A structure containing the alert target ARN and the role ARN.
    public struct AlertTarget {
        /// The Amazon Resource Name (ARN) of the notification target to which alerts are sent.
        /// This member is required.
        public var alertTargetArn: Swift.String?
        /// The ARN of the role that grants permission to send alerts to the notification target.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            alertTargetArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.alertTargetArn = alertTargetArn
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes {

    /// The type of alert target: one of "SNS".
    public enum AlertTargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [AlertTargetType] {
            return [
                .sns
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Describes an IoT policy.
    public struct Policy {
        /// The policy ARN.
        public var policyArn: Swift.String?
        /// The policy name.
        public var policyName: Swift.String?

        public init(
            policyArn: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyArn = policyArn
            self.policyName = policyName
        }
    }

}

extension IoTClientTypes {
    /// Contains information that allowed the authorization.
    public struct Allowed {
        /// A list of policies that allowed the authentication.
        public var policies: [IoTClientTypes.Policy]?

        public init(
            policies: [IoTClientTypes.Policy]? = nil
        )
        {
            self.policies = policies
        }
    }

}

/// A resource with the same name already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// A resource with the same name already exists.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

/// Internal error from the service that indicates an unexpected error or that the service is unavailable.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A limit has been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTClientTypes {
    /// The S3 location.
    public struct S3Location {
        /// The S3 bucket.
        public var bucket: Swift.String?
        /// The S3 key.
        public var key: Swift.String?
        /// The S3 bucket version.
        public var version: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.version = version
        }
    }

}

extension IoTClientTypes {
    /// The Amazon S3 location for the software bill of materials associated with a software package version.
    public struct Sbom {
        /// The S3 location.
        public var s3Location: IoTClientTypes.S3Location?

        public init(
            s3Location: IoTClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

public struct AssociateSbomWithPackageVersionInput {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The name of the new software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The Amazon S3 location for the software bill of materials associated with a software package version.
    /// This member is required.
    public var sbom: IoTClientTypes.Sbom?
    /// The name of the new package version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        packageName: Swift.String? = nil,
        sbom: IoTClientTypes.Sbom? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.packageName = packageName
        self.sbom = sbom
        self.versionName = versionName
    }
}

extension IoTClientTypes {

    public enum SbomValidationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [SbomValidationStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AssociateSbomWithPackageVersionOutput {
    /// The name of the new software package.
    public var packageName: Swift.String?
    /// The Amazon S3 location for the software bill of materials associated with a software package version.
    public var sbom: IoTClientTypes.Sbom?
    /// The status of the initial validation for the SBOM against the Software Package Data Exchange (SPDX) and CycloneDX industry standard format.
    public var sbomValidationStatus: IoTClientTypes.SbomValidationStatus?
    /// The name of the new package version.
    public var versionName: Swift.String?

    public init(
        packageName: Swift.String? = nil,
        sbom: IoTClientTypes.Sbom? = nil,
        sbomValidationStatus: IoTClientTypes.SbomValidationStatus? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.packageName = packageName
        self.sbom = sbom
        self.sbomValidationStatus = sbomValidationStatus
        self.versionName = versionName
    }
}

/// A limit has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateTargetsWithJobInput {
    /// An optional comment string describing why the job was associated with the targets.
    public var comment: Swift.String?
    /// The unique identifier you assigned to this job when it was created.
    /// This member is required.
    public var jobId: Swift.String?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see [Setting up IoT Greengrass core devices.](https://docs.aws.amazon.com/greengrass/v2/developerguide/setting-up.html)
    public var namespaceId: Swift.String?
    /// A list of thing group ARNs that define the targets of the job.
    /// This member is required.
    public var targets: [Swift.String]?

    public init(
        comment: Swift.String? = nil,
        jobId: Swift.String? = nil,
        namespaceId: Swift.String? = nil,
        targets: [Swift.String]? = nil
    )
    {
        self.comment = comment
        self.jobId = jobId
        self.namespaceId = namespaceId
        self.targets = targets
    }
}

public struct AssociateTargetsWithJobOutput {
    /// A short text description of the job.
    public var description: Swift.String?
    /// An ARN identifying the job.
    public var jobArn: Swift.String?
    /// The unique identifier you assigned to this job when it was created.
    public var jobId: Swift.String?

    public init(
        description: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.description = description
        self.jobArn = jobArn
        self.jobId = jobId
    }
}

public struct AttachPolicyInput {
    /// The name of the policy to attach.
    /// This member is required.
    public var policyName: Swift.String?
    /// The [identity](https://docs.aws.amazon.com/iot/latest/developerguide/security-iam.html) to which the policy is attached. For example, a thing group or a certificate.
    /// This member is required.
    public var target: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.target = target
    }
}

/// The input for the AttachPrincipalPolicy operation.
public struct AttachPrincipalPolicyInput {
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?
    /// The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
    /// This member is required.
    public var principal: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        principal: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.principal = principal
    }
}

/// An exception thrown when the version of an entity specified with the expectedVersion parameter does not match the latest version in the system.
public struct VersionConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "VersionConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AttachSecurityProfileInput {
    /// The security profile that is attached.
    /// This member is required.
    public var securityProfileName: Swift.String?
    /// The ARN of the target (thing group) to which the security profile is attached.
    /// This member is required.
    public var securityProfileTargetArn: Swift.String?

    public init(
        securityProfileName: Swift.String? = nil,
        securityProfileTargetArn: Swift.String? = nil
    )
    {
        self.securityProfileName = securityProfileName
        self.securityProfileTargetArn = securityProfileTargetArn
    }
}

public struct AttachSecurityProfileOutput {

    public init() { }
}

/// The input for the AttachThingPrincipal operation.
public struct AttachThingPrincipalInput {
    /// The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
    /// This member is required.
    public var principal: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        principal: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.principal = principal
        self.thingName = thingName
    }
}

/// The output from the AttachThingPrincipal operation.
public struct AttachThingPrincipalOutput {

    public init() { }
}

extension IoTClientTypes {
    /// The attribute payload.
    public struct AttributePayload {
        /// A JSON string containing up to three key-value pair in JSON format. For example: {\"attributes\":{\"string1\":\"string2\"}}
        public var attributes: [Swift.String: Swift.String]?
        /// Specifies whether the list of attributes provided in the AttributePayload is merged with the attributes stored in the registry, instead of overwriting them. To remove an attribute, call UpdateThing with an empty attribute value. The merge attribute is only valid when calling UpdateThing or UpdateThingGroup.
        public var merge: Swift.Bool

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            merge: Swift.Bool = false
        )
        {
            self.attributes = attributes
            self.merge = merge
        }
    }

}

extension IoTClientTypes {
    /// Which audit checks are enabled and disabled for this account.
    public struct AuditCheckConfiguration {
        /// True if this audit check is enabled for this account.
        public var enabled: Swift.Bool

        public init(
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension IoTClientTypes {

    public enum AuditCheckRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case completedCompliant
        case completedNonCompliant
        case failed
        case inProgress
        case waitingForDataCollection
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditCheckRunStatus] {
            return [
                .canceled,
                .completedCompliant,
                .completedNonCompliant,
                .failed,
                .inProgress,
                .waitingForDataCollection
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completedCompliant: return "COMPLETED_COMPLIANT"
            case .completedNonCompliant: return "COMPLETED_NON_COMPLIANT"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .waitingForDataCollection: return "WAITING_FOR_DATA_COLLECTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Information about the audit check.
    public struct AuditCheckDetails {
        /// True if the check is complete and found all resources compliant.
        public var checkCompliant: Swift.Bool?
        /// The completion status of this check. One of "IN_PROGRESS", "WAITING_FOR_DATA_COLLECTION", "CANCELED", "COMPLETED_COMPLIANT", "COMPLETED_NON_COMPLIANT", or "FAILED".
        public var checkRunStatus: IoTClientTypes.AuditCheckRunStatus?
        /// The code of any error encountered when this check is performed during this audit. One of "INSUFFICIENT_PERMISSIONS" or "AUDIT_CHECK_DISABLED".
        public var errorCode: Swift.String?
        /// The message associated with any error encountered when this check is performed during this audit.
        public var message: Swift.String?
        /// The number of resources that were found noncompliant during the check.
        public var nonCompliantResourcesCount: Swift.Int?
        /// Describes how many of the non-compliant resources created during the evaluation of an audit check were marked as suppressed.
        public var suppressedNonCompliantResourcesCount: Swift.Int?
        /// The number of resources on which the check was performed.
        public var totalResourcesCount: Swift.Int?

        public init(
            checkCompliant: Swift.Bool? = nil,
            checkRunStatus: IoTClientTypes.AuditCheckRunStatus? = nil,
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil,
            nonCompliantResourcesCount: Swift.Int? = nil,
            suppressedNonCompliantResourcesCount: Swift.Int? = nil,
            totalResourcesCount: Swift.Int? = nil
        )
        {
            self.checkCompliant = checkCompliant
            self.checkRunStatus = checkRunStatus
            self.errorCode = errorCode
            self.message = message
            self.nonCompliantResourcesCount = nonCompliantResourcesCount
            self.suppressedNonCompliantResourcesCount = suppressedNonCompliantResourcesCount
            self.totalResourcesCount = totalResourcesCount
        }
    }

}

extension IoTClientTypes {
    /// The certificate issuer indentifier.
    public struct IssuerCertificateIdentifier {
        /// The issuer certificate serial number.
        public var issuerCertificateSerialNumber: Swift.String?
        /// The subject of the issuer certificate.
        public var issuerCertificateSubject: Swift.String?
        /// The issuer ID.
        public var issuerId: Swift.String?

        public init(
            issuerCertificateSerialNumber: Swift.String? = nil,
            issuerCertificateSubject: Swift.String? = nil,
            issuerId: Swift.String? = nil
        )
        {
            self.issuerCertificateSerialNumber = issuerCertificateSerialNumber
            self.issuerCertificateSubject = issuerCertificateSubject
            self.issuerId = issuerId
        }
    }

}

extension IoTClientTypes {
    /// Information about the version of the policy associated with the resource.
    public struct PolicyVersionIdentifier {
        /// The name of the policy.
        public var policyName: Swift.String?
        /// The ID of the version of the policy associated with the resource.
        public var policyVersionId: Swift.String?

        public init(
            policyName: Swift.String? = nil,
            policyVersionId: Swift.String? = nil
        )
        {
            self.policyName = policyName
            self.policyVersionId = policyVersionId
        }
    }

}

extension IoTClientTypes {
    /// Information that identifies the noncompliant resource.
    public struct ResourceIdentifier {
        /// The account with which the resource is associated.
        public var account: Swift.String?
        /// The ID of the CA certificate used to authorize the certificate.
        public var caCertificateId: Swift.String?
        /// The client ID.
        public var clientId: Swift.String?
        /// The ID of the Amazon Cognito identity pool.
        public var cognitoIdentityPoolId: Swift.String?
        /// The ARN of the identified device certificate.
        public var deviceCertificateArn: Swift.String?
        /// The ID of the certificate attached to the resource.
        public var deviceCertificateId: Swift.String?
        /// The ARN of the IAM role that has overly permissive actions.
        public var iamRoleArn: Swift.String?
        /// The issuer certificate identifier.
        public var issuerCertificateIdentifier: IoTClientTypes.IssuerCertificateIdentifier?
        /// The version of the policy associated with the resource.
        public var policyVersionIdentifier: IoTClientTypes.PolicyVersionIdentifier?
        /// The ARN of the role alias that has overly permissive actions.
        public var roleAliasArn: Swift.String?

        public init(
            account: Swift.String? = nil,
            caCertificateId: Swift.String? = nil,
            clientId: Swift.String? = nil,
            cognitoIdentityPoolId: Swift.String? = nil,
            deviceCertificateArn: Swift.String? = nil,
            deviceCertificateId: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            issuerCertificateIdentifier: IoTClientTypes.IssuerCertificateIdentifier? = nil,
            policyVersionIdentifier: IoTClientTypes.PolicyVersionIdentifier? = nil,
            roleAliasArn: Swift.String? = nil
        )
        {
            self.account = account
            self.caCertificateId = caCertificateId
            self.clientId = clientId
            self.cognitoIdentityPoolId = cognitoIdentityPoolId
            self.deviceCertificateArn = deviceCertificateArn
            self.deviceCertificateId = deviceCertificateId
            self.iamRoleArn = iamRoleArn
            self.issuerCertificateIdentifier = issuerCertificateIdentifier
            self.policyVersionIdentifier = policyVersionIdentifier
            self.roleAliasArn = roleAliasArn
        }
    }

}

extension IoTClientTypes {

    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountSettings
        case caCertificate
        case clientId
        case cognitoIdentityPool
        case deviceCertificate
        case iamRole
        case iotPolicy
        case issuerCertificate
        case roleAlias
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .accountSettings,
                .caCertificate,
                .clientId,
                .cognitoIdentityPool,
                .deviceCertificate,
                .iamRole,
                .iotPolicy,
                .issuerCertificate,
                .roleAlias
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountSettings: return "ACCOUNT_SETTINGS"
            case .caCertificate: return "CA_CERTIFICATE"
            case .clientId: return "CLIENT_ID"
            case .cognitoIdentityPool: return "COGNITO_IDENTITY_POOL"
            case .deviceCertificate: return "DEVICE_CERTIFICATE"
            case .iamRole: return "IAM_ROLE"
            case .iotPolicy: return "IOT_POLICY"
            case .issuerCertificate: return "ISSUER_CERTIFICATE"
            case .roleAlias: return "ROLE_ALIAS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Information about the resource that was noncompliant with the audit check.
    public struct NonCompliantResource {
        /// Other information about the noncompliant resource.
        public var additionalInfo: [Swift.String: Swift.String]?
        /// Information that identifies the noncompliant resource.
        public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
        /// The type of the noncompliant resource.
        public var resourceType: IoTClientTypes.ResourceType?

        public init(
            additionalInfo: [Swift.String: Swift.String]? = nil,
            resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
            resourceType: IoTClientTypes.ResourceType? = nil
        )
        {
            self.additionalInfo = additionalInfo
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }
    }

}

extension IoTClientTypes {
    /// Information about a related resource.
    public struct RelatedResource {
        /// Other information about the resource.
        public var additionalInfo: [Swift.String: Swift.String]?
        /// Information that identifies the resource.
        public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
        /// The type of resource.
        public var resourceType: IoTClientTypes.ResourceType?

        public init(
            additionalInfo: [Swift.String: Swift.String]? = nil,
            resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
            resourceType: IoTClientTypes.ResourceType? = nil
        )
        {
            self.additionalInfo = additionalInfo
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }
    }

}

extension IoTClientTypes {

    public enum AuditFindingSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case critical
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditFindingSeverity] {
            return [
                .critical,
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The findings (results) of the audit.
    public struct AuditFinding {
        /// The audit check that generated this result.
        public var checkName: Swift.String?
        /// A unique identifier for this set of audit findings. This identifier is used to apply mitigation tasks to one or more sets of findings.
        public var findingId: Swift.String?
        /// The time the result (finding) was discovered.
        public var findingTime: Foundation.Date?
        /// Indicates whether the audit finding was suppressed or not during reporting.
        public var isSuppressed: Swift.Bool?
        /// The resource that was found to be noncompliant with the audit check.
        public var nonCompliantResource: IoTClientTypes.NonCompliantResource?
        /// The reason the resource was noncompliant.
        public var reasonForNonCompliance: Swift.String?
        /// A code that indicates the reason that the resource was noncompliant.
        public var reasonForNonComplianceCode: Swift.String?
        /// The list of related resources.
        public var relatedResources: [IoTClientTypes.RelatedResource]?
        /// The severity of the result (finding).
        public var severity: IoTClientTypes.AuditFindingSeverity?
        /// The ID of the audit that generated this result (finding).
        public var taskId: Swift.String?
        /// The time the audit started.
        public var taskStartTime: Foundation.Date?

        public init(
            checkName: Swift.String? = nil,
            findingId: Swift.String? = nil,
            findingTime: Foundation.Date? = nil,
            isSuppressed: Swift.Bool? = nil,
            nonCompliantResource: IoTClientTypes.NonCompliantResource? = nil,
            reasonForNonCompliance: Swift.String? = nil,
            reasonForNonComplianceCode: Swift.String? = nil,
            relatedResources: [IoTClientTypes.RelatedResource]? = nil,
            severity: IoTClientTypes.AuditFindingSeverity? = nil,
            taskId: Swift.String? = nil,
            taskStartTime: Foundation.Date? = nil
        )
        {
            self.checkName = checkName
            self.findingId = findingId
            self.findingTime = findingTime
            self.isSuppressed = isSuppressed
            self.nonCompliantResource = nonCompliantResource
            self.reasonForNonCompliance = reasonForNonCompliance
            self.reasonForNonComplianceCode = reasonForNonComplianceCode
            self.relatedResources = relatedResources
            self.severity = severity
            self.taskId = taskId
            self.taskStartTime = taskStartTime
        }
    }

}

extension IoTClientTypes {

    public enum AuditFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case biweekly
        case daily
        case monthly
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditFrequency] {
            return [
                .biweekly,
                .daily,
                .monthly,
                .weekly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .biweekly: return "BIWEEKLY"
            case .daily: return "DAILY"
            case .monthly: return "MONTHLY"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {

    public enum AuditMitigationActionsExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case inProgress
        case pending
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditMitigationActionsExecutionStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .inProgress,
                .pending,
                .skipped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Returned by ListAuditMitigationActionsTask, this object contains information that describes a mitigation action that has been started.
    public struct AuditMitigationActionExecutionMetadata {
        /// The unique identifier for the mitigation action being applied by the task.
        public var actionId: Swift.String?
        /// The friendly name of the mitigation action being applied by the task.
        public var actionName: Swift.String?
        /// The date and time when the task was completed or canceled. Blank if the task is still running.
        public var endTime: Foundation.Date?
        /// If an error occurred, the code that indicates which type of error occurred.
        public var errorCode: Swift.String?
        /// The unique identifier for the findings to which the task and associated mitigation action are applied.
        public var findingId: Swift.String?
        /// If an error occurred, a message that describes the error.
        public var message: Swift.String?
        /// The date and time when the task was started.
        public var startTime: Foundation.Date?
        /// The current status of the task being executed.
        public var status: IoTClientTypes.AuditMitigationActionsExecutionStatus?
        /// The unique identifier for the task that applies the mitigation action.
        public var taskId: Swift.String?

        public init(
            actionId: Swift.String? = nil,
            actionName: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            errorCode: Swift.String? = nil,
            findingId: Swift.String? = nil,
            message: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            status: IoTClientTypes.AuditMitigationActionsExecutionStatus? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.actionId = actionId
            self.actionName = actionName
            self.endTime = endTime
            self.errorCode = errorCode
            self.findingId = findingId
            self.message = message
            self.startTime = startTime
            self.status = status
            self.taskId = taskId
        }
    }

}

extension IoTClientTypes {

    public enum AuditMitigationActionsTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditMitigationActionsTaskStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Information about an audit mitigation actions task that is returned by ListAuditMitigationActionsTasks.
    public struct AuditMitigationActionsTaskMetadata {
        /// The time at which the audit mitigation actions task was started.
        public var startTime: Foundation.Date?
        /// The unique identifier for the task.
        public var taskId: Swift.String?
        /// The current state of the audit mitigation actions task.
        public var taskStatus: IoTClientTypes.AuditMitigationActionsTaskStatus?

        public init(
            startTime: Foundation.Date? = nil,
            taskId: Swift.String? = nil,
            taskStatus: IoTClientTypes.AuditMitigationActionsTaskStatus? = nil
        )
        {
            self.startTime = startTime
            self.taskId = taskId
            self.taskStatus = taskStatus
        }
    }

}

extension IoTClientTypes {
    /// Provides summary counts of how many tasks for findings are in a particular state. This information is included in the response from DescribeAuditMitigationActionsTask.
    public struct TaskStatisticsForAuditCheck {
        /// The number of findings to which the mitigation action task was canceled when applied.
        public var canceledFindingsCount: Swift.Int?
        /// The number of findings for which at least one of the actions failed when applied.
        public var failedFindingsCount: Swift.Int?
        /// The number of findings skipped because of filter conditions provided in the parameters to the command.
        public var skippedFindingsCount: Swift.Int?
        /// The number of findings for which all mitigation actions succeeded when applied.
        public var succeededFindingsCount: Swift.Int?
        /// The total number of findings to which a task is being applied.
        public var totalFindingsCount: Swift.Int?

        public init(
            canceledFindingsCount: Swift.Int? = nil,
            failedFindingsCount: Swift.Int? = nil,
            skippedFindingsCount: Swift.Int? = nil,
            succeededFindingsCount: Swift.Int? = nil,
            totalFindingsCount: Swift.Int? = nil
        )
        {
            self.canceledFindingsCount = canceledFindingsCount
            self.failedFindingsCount = failedFindingsCount
            self.skippedFindingsCount = skippedFindingsCount
            self.succeededFindingsCount = succeededFindingsCount
            self.totalFindingsCount = totalFindingsCount
        }
    }

}

extension IoTClientTypes {
    /// Used in MitigationActionParams, this information identifies the target findings to which the mitigation actions are applied. Only one entry appears.
    public struct AuditMitigationActionsTaskTarget {
        /// Specifies a filter in the form of an audit check and set of reason codes that identify the findings from the audit to which the audit mitigation actions task apply.
        public var auditCheckToReasonCodeFilter: [Swift.String: [Swift.String]]?
        /// If the task will apply a mitigation action to findings from a specific audit, this value uniquely identifies the audit.
        public var auditTaskId: Swift.String?
        /// If the task will apply a mitigation action to one or more listed findings, this value uniquely identifies those findings.
        public var findingIds: [Swift.String]?

        public init(
            auditCheckToReasonCodeFilter: [Swift.String: [Swift.String]]? = nil,
            auditTaskId: Swift.String? = nil,
            findingIds: [Swift.String]? = nil
        )
        {
            self.auditCheckToReasonCodeFilter = auditCheckToReasonCodeFilter
            self.auditTaskId = auditTaskId
            self.findingIds = findingIds
        }
    }

}

extension IoTClientTypes {
    /// Information about the targets to which audit notifications are sent.
    public struct AuditNotificationTarget {
        /// True if notifications to the target are enabled.
        public var enabled: Swift.Bool
        /// The ARN of the role that grants permission to send notifications to the target.
        public var roleArn: Swift.String?
        /// The ARN of the target (SNS topic) to which audit notifications are sent.
        public var targetArn: Swift.String?

        public init(
            enabled: Swift.Bool = false,
            roleArn: Swift.String? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.roleArn = roleArn
            self.targetArn = targetArn
        }
    }

}

extension IoTClientTypes {

    public enum AuditNotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditNotificationType] {
            return [
                .sns
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Filters out specific findings of a Device Defender audit.
    public struct AuditSuppression {
        /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
        /// This member is required.
        public var checkName: Swift.String?
        /// The description of the audit suppression.
        public var description: Swift.String?
        /// The expiration date (epoch timestamp in seconds) that you want the suppression to adhere to.
        public var expirationDate: Foundation.Date?
        /// Information that identifies the noncompliant resource.
        /// This member is required.
        public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
        /// Indicates whether a suppression should exist indefinitely or not.
        public var suppressIndefinitely: Swift.Bool?

        public init(
            checkName: Swift.String? = nil,
            description: Swift.String? = nil,
            expirationDate: Foundation.Date? = nil,
            resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
            suppressIndefinitely: Swift.Bool? = nil
        )
        {
            self.checkName = checkName
            self.description = description
            self.expirationDate = expirationDate
            self.resourceIdentifier = resourceIdentifier
            self.suppressIndefinitely = suppressIndefinitely
        }
    }

}

extension IoTClientTypes {

    public enum AuditTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditTaskStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {

    public enum AuditTaskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case onDemandAuditTask
        case scheduledAuditTask
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditTaskType] {
            return [
                .onDemandAuditTask,
                .scheduledAuditTask
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .onDemandAuditTask: return "ON_DEMAND_AUDIT_TASK"
            case .scheduledAuditTask: return "SCHEDULED_AUDIT_TASK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The audits that were performed.
    public struct AuditTaskMetadata {
        /// The ID of this audit.
        public var taskId: Swift.String?
        /// The status of this audit. One of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
        public var taskStatus: IoTClientTypes.AuditTaskStatus?
        /// The type of this audit. One of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED_AUDIT_TASK".
        public var taskType: IoTClientTypes.AuditTaskType?

        public init(
            taskId: Swift.String? = nil,
            taskStatus: IoTClientTypes.AuditTaskStatus? = nil,
            taskType: IoTClientTypes.AuditTaskType? = nil
        )
        {
            self.taskId = taskId
            self.taskStatus = taskStatus
            self.taskType = taskType
        }
    }

}

extension IoTClientTypes {

    public enum AuthDecision: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowed
        case explicitDeny
        case implicitDeny
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthDecision] {
            return [
                .allowed,
                .explicitDeny,
                .implicitDeny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "ALLOWED"
            case .explicitDeny: return "EXPLICIT_DENY"
            case .implicitDeny: return "IMPLICIT_DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// A collection of authorization information.
    public struct AuthInfo {
        /// The type of action for which the principal is being authorized.
        public var actionType: IoTClientTypes.ActionType?
        /// The resources for which the principal is being authorized to perform the specified action.
        /// This member is required.
        public var resources: [Swift.String]?

        public init(
            actionType: IoTClientTypes.ActionType? = nil,
            resources: [Swift.String]? = nil
        )
        {
            self.actionType = actionType
            self.resources = resources
        }
    }

}

extension IoTClientTypes {
    /// An object that specifies the authorization service for a domain.
    public struct AuthorizerConfig {
        /// A Boolean that specifies whether the domain configuration's authorization service can be overridden.
        public var allowAuthorizerOverride: Swift.Bool?
        /// The name of the authorization service for a domain configuration.
        public var defaultAuthorizerName: Swift.String?

        public init(
            allowAuthorizerOverride: Swift.Bool? = false,
            defaultAuthorizerName: Swift.String? = nil
        )
        {
            self.allowAuthorizerOverride = allowAuthorizerOverride
            self.defaultAuthorizerName = defaultAuthorizerName
        }
    }

}

extension IoTClientTypes {

    public enum AuthorizerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizerStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The authorizer description.
    public struct AuthorizerDescription {
        /// The authorizer ARN.
        public var authorizerArn: Swift.String?
        /// The authorizer's Lambda function ARN.
        public var authorizerFunctionArn: Swift.String?
        /// The authorizer name.
        public var authorizerName: Swift.String?
        /// The UNIX timestamp of when the authorizer was created.
        public var creationDate: Foundation.Date?
        /// When true, the result from the authorizer’s Lambda function is cached for the time specified in refreshAfterInSeconds. The cached result is used while the device reuses the same HTTP connection.
        public var enableCachingForHttp: Swift.Bool?
        /// The UNIX timestamp of when the authorizer was last updated.
        public var lastModifiedDate: Foundation.Date?
        /// Specifies whether IoT validates the token signature in an authorization request.
        public var signingDisabled: Swift.Bool?
        /// The status of the authorizer.
        public var status: IoTClientTypes.AuthorizerStatus?
        /// The key used to extract the token from the HTTP headers.
        public var tokenKeyName: Swift.String?
        /// The public keys used to validate the token signature returned by your custom authentication service.
        public var tokenSigningPublicKeys: [Swift.String: Swift.String]?

        public init(
            authorizerArn: Swift.String? = nil,
            authorizerFunctionArn: Swift.String? = nil,
            authorizerName: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            enableCachingForHttp: Swift.Bool? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            signingDisabled: Swift.Bool? = nil,
            status: IoTClientTypes.AuthorizerStatus? = nil,
            tokenKeyName: Swift.String? = nil,
            tokenSigningPublicKeys: [Swift.String: Swift.String]? = nil
        )
        {
            self.authorizerArn = authorizerArn
            self.authorizerFunctionArn = authorizerFunctionArn
            self.authorizerName = authorizerName
            self.creationDate = creationDate
            self.enableCachingForHttp = enableCachingForHttp
            self.lastModifiedDate = lastModifiedDate
            self.signingDisabled = signingDisabled
            self.status = status
            self.tokenKeyName = tokenKeyName
            self.tokenSigningPublicKeys = tokenSigningPublicKeys
        }
    }

}

extension IoTClientTypes {
    /// The authorizer summary.
    public struct AuthorizerSummary {
        /// The authorizer ARN.
        public var authorizerArn: Swift.String?
        /// The authorizer name.
        public var authorizerName: Swift.String?

        public init(
            authorizerArn: Swift.String? = nil,
            authorizerName: Swift.String? = nil
        )
        {
            self.authorizerArn = authorizerArn
            self.authorizerName = authorizerName
        }
    }

}

extension IoTClientTypes {
    /// Information that explicitly denies authorization.
    public struct ExplicitDeny {
        /// The policies that denied the authorization.
        public var policies: [IoTClientTypes.Policy]?

        public init(
            policies: [IoTClientTypes.Policy]? = nil
        )
        {
            self.policies = policies
        }
    }

}

extension IoTClientTypes {
    /// Information that implicitly denies authorization. When policy doesn't explicitly deny or allow an action on a resource it is considered an implicit deny.
    public struct ImplicitDeny {
        /// Policies that don't contain a matching allow or deny statement for the specified action on the specified resource.
        public var policies: [IoTClientTypes.Policy]?

        public init(
            policies: [IoTClientTypes.Policy]? = nil
        )
        {
            self.policies = policies
        }
    }

}

extension IoTClientTypes {
    /// Contains information that denied the authorization.
    public struct Denied {
        /// Information that explicitly denies the authorization.
        public var explicitDeny: IoTClientTypes.ExplicitDeny?
        /// Information that implicitly denies the authorization. When a policy doesn't explicitly deny or allow an action on a resource it is considered an implicit deny.
        public var implicitDeny: IoTClientTypes.ImplicitDeny?

        public init(
            explicitDeny: IoTClientTypes.ExplicitDeny? = nil,
            implicitDeny: IoTClientTypes.ImplicitDeny? = nil
        )
        {
            self.explicitDeny = explicitDeny
            self.implicitDeny = implicitDeny
        }
    }

}

extension IoTClientTypes {
    /// The authorizer result.
    public struct AuthResult {
        /// The policies and statements that allowed the specified action.
        public var allowed: IoTClientTypes.Allowed?
        /// The final authorization decision of this scenario. Multiple statements are taken into account when determining the authorization decision. An explicit deny statement can override multiple allow statements.
        public var authDecision: IoTClientTypes.AuthDecision?
        /// Authorization information.
        public var authInfo: IoTClientTypes.AuthInfo?
        /// The policies and statements that denied the specified action.
        public var denied: IoTClientTypes.Denied?
        /// Contains any missing context values found while evaluating policy.
        public var missingContextValues: [Swift.String]?

        public init(
            allowed: IoTClientTypes.Allowed? = nil,
            authDecision: IoTClientTypes.AuthDecision? = nil,
            authInfo: IoTClientTypes.AuthInfo? = nil,
            denied: IoTClientTypes.Denied? = nil,
            missingContextValues: [Swift.String]? = nil
        )
        {
            self.allowed = allowed
            self.authDecision = authDecision
            self.authInfo = authInfo
            self.denied = denied
            self.missingContextValues = missingContextValues
        }
    }

}

extension IoTClientTypes {

    public enum AutoRegistrationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disable
        case enable
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoRegistrationStatus] {
            return [
                .disable,
                .enable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CancelAuditMitigationActionsTaskInput {
    /// The unique identifier for the task that you want to cancel.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

public struct CancelAuditMitigationActionsTaskOutput {

    public init() { }
}

public struct CancelAuditTaskInput {
    /// The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

public struct CancelAuditTaskOutput {

    public init() { }
}

/// The input for the CancelCertificateTransfer operation.
public struct CancelCertificateTransferInput {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

public struct CancelDetectMitigationActionsTaskInput {
    /// The unique identifier of the task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

public struct CancelDetectMitigationActionsTaskOutput {

    public init() { }
}

public struct CancelJobInput {
    /// An optional comment string describing why the job was canceled.
    public var comment: Swift.String?
    /// (Optional) If true job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is false. Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.
    public var force: Swift.Bool?
    /// The unique identifier you assigned to this job when it was created.
    /// This member is required.
    public var jobId: Swift.String?
    /// (Optional)A reason code string that explains why the job was canceled.
    public var reasonCode: Swift.String?

    public init(
        comment: Swift.String? = nil,
        force: Swift.Bool? = false,
        jobId: Swift.String? = nil,
        reasonCode: Swift.String? = nil
    )
    {
        self.comment = comment
        self.force = force
        self.jobId = jobId
        self.reasonCode = reasonCode
    }
}

public struct CancelJobOutput {
    /// A short text description of the job.
    public var description: Swift.String?
    /// The job ARN.
    public var jobArn: Swift.String?
    /// The unique identifier you assigned to this job when it was created.
    public var jobId: Swift.String?

    public init(
        description: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.description = description
        self.jobArn = jobArn
        self.jobId = jobId
    }
}

/// An attempt was made to change to an invalid state, for example by deleting a job or a job execution which is "IN_PROGRESS" without setting the force parameter.
public struct InvalidStateTransitionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidStateTransitionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelJobExecutionInput {
    /// (Optional) The expected current version of the job execution. Each time you update the job execution, its version is incremented. If the version of the job execution stored in Jobs does not match, the update is rejected with a VersionMismatch error, and an ErrorResponse that contains the current job execution status data is returned. (This makes it unnecessary to perform a separate DescribeJobExecution request in order to obtain the job execution status data.)
    public var expectedVersion: Swift.Int?
    /// (Optional) If true the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set force to true, then an InvalidStateTransitionException will be thrown. The default is false. Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.
    public var force: Swift.Bool?
    /// The ID of the job to be canceled.
    /// This member is required.
    public var jobId: Swift.String?
    /// A collection of name/value pairs that describe the status of the job execution. If not specified, the statusDetails are unchanged. You can specify at most 10 name/value pairs.
    public var statusDetails: [Swift.String: Swift.String]?
    /// The name of the thing whose execution of the job will be canceled.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        expectedVersion: Swift.Int? = nil,
        force: Swift.Bool? = false,
        jobId: Swift.String? = nil,
        statusDetails: [Swift.String: Swift.String]? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.force = force
        self.jobId = jobId
        self.statusDetails = statusDetails
        self.thingName = thingName
    }
}

public struct ClearDefaultAuthorizerInput {

    public init() { }
}

public struct ClearDefaultAuthorizerOutput {

    public init() { }
}

/// A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.
public struct ConflictingResourceUpdateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictingResourceUpdateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An unexpected error has occurred.
public struct InternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ConfirmTopicRuleDestinationInput {
    /// The token used to confirm ownership or access to the topic rule confirmation URL.
    /// This member is required.
    public var confirmationToken: Swift.String?

    public init(
        confirmationToken: Swift.String? = nil
    )
    {
        self.confirmationToken = confirmationToken
    }
}

public struct ConfirmTopicRuleDestinationOutput {

    public init() { }
}

/// The resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The ARN of the resource that caused the exception.
        public internal(set) var resourceArn: Swift.String? = nil
        /// The ID of the resource that caused the exception.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceArn = resourceArn
        self.properties.resourceId = resourceId
    }
}

public struct CreateAuditSuppressionInput {
    /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    /// This member is required.
    public var checkName: Swift.String?
    /// Each audit supression must have a unique client request token. If you try to create a new audit suppression with the same token as one that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The description of the audit suppression.
    public var description: Swift.String?
    /// The epoch timestamp in seconds at which this suppression expires.
    public var expirationDate: Foundation.Date?
    /// Information that identifies the noncompliant resource.
    /// This member is required.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
    /// Indicates whether a suppression should exist indefinitely or not.
    public var suppressIndefinitely: Swift.Bool?

    public init(
        checkName: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        expirationDate: Foundation.Date? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
        suppressIndefinitely: Swift.Bool? = nil
    )
    {
        self.checkName = checkName
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.expirationDate = expirationDate
        self.resourceIdentifier = resourceIdentifier
        self.suppressIndefinitely = suppressIndefinitely
    }
}

public struct CreateAuditSuppressionOutput {

    public init() { }
}

extension IoTClientTypes {
    /// A set of key/value pairs that are used to manage the resource.
    public struct Tag {
        /// The tag's key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateAuthorizerInput {
    /// The ARN of the authorizer's Lambda function.
    /// This member is required.
    public var authorizerFunctionArn: Swift.String?
    /// The authorizer name.
    /// This member is required.
    public var authorizerName: Swift.String?
    /// When true, the result from the authorizer’s Lambda function is cached for clients that use persistent HTTP connections. The results are cached for the time specified by the Lambda function in refreshAfterInSeconds. This value does not affect authorization of clients that use MQTT connections. The default value is false.
    public var enableCachingForHttp: Swift.Bool?
    /// Specifies whether IoT validates the token signature in an authorization request.
    public var signingDisabled: Swift.Bool?
    /// The status of the create authorizer request.
    public var status: IoTClientTypes.AuthorizerStatus?
    /// Metadata which can be used to manage the custom authorizer. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: [IoTClientTypes.Tag]?
    /// The name of the token key used to extract the token from the HTTP headers.
    public var tokenKeyName: Swift.String?
    /// The public keys used to verify the digital signature returned by your custom authentication service.
    public var tokenSigningPublicKeys: [Swift.String: Swift.String]?

    public init(
        authorizerFunctionArn: Swift.String? = nil,
        authorizerName: Swift.String? = nil,
        enableCachingForHttp: Swift.Bool? = nil,
        signingDisabled: Swift.Bool? = nil,
        status: IoTClientTypes.AuthorizerStatus? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        tokenKeyName: Swift.String? = nil,
        tokenSigningPublicKeys: [Swift.String: Swift.String]? = nil
    )
    {
        self.authorizerFunctionArn = authorizerFunctionArn
        self.authorizerName = authorizerName
        self.enableCachingForHttp = enableCachingForHttp
        self.signingDisabled = signingDisabled
        self.status = status
        self.tags = tags
        self.tokenKeyName = tokenKeyName
        self.tokenSigningPublicKeys = tokenSigningPublicKeys
    }
}

public struct CreateAuthorizerOutput {
    /// The authorizer ARN.
    public var authorizerArn: Swift.String?
    /// The authorizer's name.
    public var authorizerName: Swift.String?

    public init(
        authorizerArn: Swift.String? = nil,
        authorizerName: Swift.String? = nil
    )
    {
        self.authorizerArn = authorizerArn
        self.authorizerName = authorizerName
    }
}

extension IoTClientTypes {
    /// The properties of a billing group.
    public struct BillingGroupProperties {
        /// The description of the billing group.
        public var billingGroupDescription: Swift.String?

        public init(
            billingGroupDescription: Swift.String? = nil
        )
        {
            self.billingGroupDescription = billingGroupDescription
        }
    }

}

public struct CreateBillingGroupInput {
    /// The name you wish to give to the billing group.
    /// This member is required.
    public var billingGroupName: Swift.String?
    /// The properties of the billing group.
    public var billingGroupProperties: IoTClientTypes.BillingGroupProperties?
    /// Metadata which can be used to manage the billing group.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        billingGroupName: Swift.String? = nil,
        billingGroupProperties: IoTClientTypes.BillingGroupProperties? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.billingGroupName = billingGroupName
        self.billingGroupProperties = billingGroupProperties
        self.tags = tags
    }
}

public struct CreateBillingGroupOutput {
    /// The ARN of the billing group.
    public var billingGroupArn: Swift.String?
    /// The ID of the billing group.
    public var billingGroupId: Swift.String?
    /// The name you gave to the billing group.
    public var billingGroupName: Swift.String?

    public init(
        billingGroupArn: Swift.String? = nil,
        billingGroupId: Swift.String? = nil,
        billingGroupName: Swift.String? = nil
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingGroupId = billingGroupId
        self.billingGroupName = billingGroupName
    }
}

/// The input for the CreateCertificateFromCsr operation.
public struct CreateCertificateFromCsrInput {
    /// The certificate signing request (CSR).
    /// This member is required.
    public var certificateSigningRequest: Swift.String?
    /// Specifies whether the certificate is active.
    public var setAsActive: Swift.Bool?

    public init(
        certificateSigningRequest: Swift.String? = nil,
        setAsActive: Swift.Bool? = false
    )
    {
        self.certificateSigningRequest = certificateSigningRequest
        self.setAsActive = setAsActive
    }
}

/// The output from the CreateCertificateFromCsr operation.
public struct CreateCertificateFromCsrOutput {
    /// The Amazon Resource Name (ARN) of the certificate. You can use the ARN as a principal for policy operations.
    public var certificateArn: Swift.String?
    /// The ID of the certificate. Certificate management operations only take a certificateId.
    public var certificateId: Swift.String?
    /// The certificate data, in PEM format.
    public var certificatePem: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        certificateId: Swift.String? = nil,
        certificatePem: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
        self.certificatePem = certificatePem
    }
}

extension IoTClientTypes {

    public enum CertificateProviderOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createcertificatefromcsr
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateProviderOperation] {
            return [
                .createcertificatefromcsr
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createcertificatefromcsr: return "CreateCertificateFromCsr"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateCertificateProviderInput {
    /// A list of the operations that the certificate provider will use to generate certificates. Valid value: CreateCertificateFromCsr.
    /// This member is required.
    public var accountDefaultForOperations: [IoTClientTypes.CertificateProviderOperation]?
    /// The name of the certificate provider.
    /// This member is required.
    public var certificateProviderName: Swift.String?
    /// A string that you can optionally pass in the CreateCertificateProvider request to make sure the request is idempotent.
    public var clientToken: Swift.String?
    /// The ARN of the Lambda function that defines the authentication logic.
    /// This member is required.
    public var lambdaFunctionArn: Swift.String?
    /// Metadata which can be used to manage the certificate provider.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        accountDefaultForOperations: [IoTClientTypes.CertificateProviderOperation]? = nil,
        certificateProviderName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        lambdaFunctionArn: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.accountDefaultForOperations = accountDefaultForOperations
        self.certificateProviderName = certificateProviderName
        self.clientToken = clientToken
        self.lambdaFunctionArn = lambdaFunctionArn
        self.tags = tags
    }
}

public struct CreateCertificateProviderOutput {
    /// The ARN of the certificate provider.
    public var certificateProviderArn: Swift.String?
    /// The name of the certificate provider.
    public var certificateProviderName: Swift.String?

    public init(
        certificateProviderArn: Swift.String? = nil,
        certificateProviderName: Swift.String? = nil
    )
    {
        self.certificateProviderArn = certificateProviderArn
        self.certificateProviderName = certificateProviderName
    }
}

extension IoTClientTypes {

    public enum CustomMetricType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ipAddressList
        case number
        case numberList
        case stringList
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomMetricType] {
            return [
                .ipAddressList,
                .number,
                .numberList,
                .stringList
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipAddressList: return "ip-address-list"
            case .number: return "number"
            case .numberList: return "number-list"
            case .stringList: return "string-list"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateCustomMetricInput {
    /// Each custom metric must have a unique client request token. If you try to create a new custom metric that already exists with a different token, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The friendly name in the console for the custom metric. This name doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. You can update the friendly name after you define it.
    public var displayName: Swift.String?
    /// The name of the custom metric. This will be used in the metric report submitted from the device/thing. The name can't begin with aws:. You can't change the name after you define it.
    /// This member is required.
    public var metricName: Swift.String?
    /// The type of the custom metric. The type number only takes a single metric value as an input, but when you submit the metrics value in the DeviceMetrics report, you must pass it as an array with a single value.
    /// This member is required.
    public var metricType: IoTClientTypes.CustomMetricType?
    /// Metadata that can be used to manage the custom metric.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        metricName: Swift.String? = nil,
        metricType: IoTClientTypes.CustomMetricType? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.displayName = displayName
        self.metricName = metricName
        self.metricType = metricType
        self.tags = tags
    }
}

public struct CreateCustomMetricOutput {
    /// The Amazon Resource Number (ARN) of the custom metric. For example, arn:aws-partition:iot:region:accountId:custommetric/metricName
    public var metricArn: Swift.String?
    /// The name of the custom metric to be used in the metric report.
    public var metricName: Swift.String?

    public init(
        metricArn: Swift.String? = nil,
        metricName: Swift.String? = nil
    )
    {
        self.metricArn = metricArn
        self.metricName = metricName
    }
}

extension IoTClientTypes {

    public enum DimensionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case topicFilter
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionType] {
            return [
                .topicFilter
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .topicFilter: return "TOPIC_FILTER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDimensionInput {
    /// Each dimension must have a unique client request token. If you try to create a new dimension with the same token as a dimension that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the value or list of values for the dimension. For TOPIC_FILTER dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").
    /// This member is required.
    public var stringValues: [Swift.String]?
    /// Metadata that can be used to manage the dimension.
    public var tags: [IoTClientTypes.Tag]?
    /// Specifies the type of dimension. Supported types: TOPIC_FILTER.
    /// This member is required.
    public var type: IoTClientTypes.DimensionType?

    public init(
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        stringValues: [Swift.String]? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        type: IoTClientTypes.DimensionType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.stringValues = stringValues
        self.tags = tags
        self.type = type
    }
}

public struct CreateDimensionOutput {
    /// The Amazon Resource Name (ARN) of the created dimension.
    public var arn: Swift.String?
    /// A unique identifier for the dimension.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

/// The certificate is invalid.
public struct CertificateValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Additional information about the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CertificateValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTClientTypes {
    /// The server certificate configuration.
    public struct ServerCertificateConfig {
        /// A Boolean value that indicates whether Online Certificate Status Protocol (OCSP) server certificate check is enabled or not. For more information, see [Configuring OCSP server-certificate stapling in domain configuration](https://docs.aws.amazon.com/iot/latest/developerguide/iot-custom-endpoints-cert-config.html) from Amazon Web Services IoT Core Developer Guide.
        public var enableOCSPCheck: Swift.Bool?

        public init(
            enableOCSPCheck: Swift.Bool? = nil
        )
        {
            self.enableOCSPCheck = enableOCSPCheck
        }
    }

}

extension IoTClientTypes {

    public enum ServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case credentialProvider
        case data
        case jobs
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .credentialProvider,
                .data,
                .jobs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .credentialProvider: return "CREDENTIAL_PROVIDER"
            case .data: return "DATA"
            case .jobs: return "JOBS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// An object that specifies the TLS configuration for a domain.
    public struct TlsConfig {
        /// The security policy for a domain configuration. For more information, see [Security policies ](https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html#tls-policy-table) in the Amazon Web Services IoT Core developer guide.
        public var securityPolicy: Swift.String?

        public init(
            securityPolicy: Swift.String? = nil
        )
        {
            self.securityPolicy = securityPolicy
        }
    }

}

public struct CreateDomainConfigurationInput {
    /// An object that specifies the authorization service for a domain.
    public var authorizerConfig: IoTClientTypes.AuthorizerConfig?
    /// The name of the domain configuration. This value must be unique to a region.
    /// This member is required.
    public var domainConfigurationName: Swift.String?
    /// The name of the domain.
    public var domainName: Swift.String?
    /// The ARNs of the certificates that IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for Amazon Web Services-managed domains.
    public var serverCertificateArns: [Swift.String]?
    /// The server certificate configuration.
    public var serverCertificateConfig: IoTClientTypes.ServerCertificateConfig?
    /// The type of service delivered by the endpoint. Amazon Web Services IoT Core currently supports only the DATA service type.
    public var serviceType: IoTClientTypes.ServiceType?
    /// Metadata which can be used to manage the domain configuration. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: [IoTClientTypes.Tag]?
    /// An object that specifies the TLS configuration for a domain.
    public var tlsConfig: IoTClientTypes.TlsConfig?
    /// The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for Amazon Web Services-managed domains.
    public var validationCertificateArn: Swift.String?

    public init(
        authorizerConfig: IoTClientTypes.AuthorizerConfig? = nil,
        domainConfigurationName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        serverCertificateArns: [Swift.String]? = nil,
        serverCertificateConfig: IoTClientTypes.ServerCertificateConfig? = nil,
        serviceType: IoTClientTypes.ServiceType? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        tlsConfig: IoTClientTypes.TlsConfig? = nil,
        validationCertificateArn: Swift.String? = nil
    )
    {
        self.authorizerConfig = authorizerConfig
        self.domainConfigurationName = domainConfigurationName
        self.domainName = domainName
        self.serverCertificateArns = serverCertificateArns
        self.serverCertificateConfig = serverCertificateConfig
        self.serviceType = serviceType
        self.tags = tags
        self.tlsConfig = tlsConfig
        self.validationCertificateArn = validationCertificateArn
    }
}

public struct CreateDomainConfigurationOutput {
    /// The ARN of the domain configuration.
    public var domainConfigurationArn: Swift.String?
    /// The name of the domain configuration.
    public var domainConfigurationName: Swift.String?

    public init(
        domainConfigurationArn: Swift.String? = nil,
        domainConfigurationName: Swift.String? = nil
    )
    {
        self.domainConfigurationArn = domainConfigurationArn
        self.domainConfigurationName = domainConfigurationName
    }
}

/// The query is invalid.
public struct InvalidQueryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidQueryException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTClientTypes {
    /// Thing group properties.
    public struct ThingGroupProperties {
        /// The thing group attributes in JSON format.
        public var attributePayload: IoTClientTypes.AttributePayload?
        /// The thing group description.
        public var thingGroupDescription: Swift.String?

        public init(
            attributePayload: IoTClientTypes.AttributePayload? = nil,
            thingGroupDescription: Swift.String? = nil
        )
        {
            self.attributePayload = attributePayload
            self.thingGroupDescription = thingGroupDescription
        }
    }

}

public struct CreateDynamicThingGroupInput {
    /// The dynamic thing group index name. Currently one index is supported: AWS_Things.
    public var indexName: Swift.String?
    /// The dynamic thing group search query string. See [Query Syntax](https://docs.aws.amazon.com/iot/latest/developerguide/query-syntax.html) for information about query string syntax.
    /// This member is required.
    public var queryString: Swift.String?
    /// The dynamic thing group query version. Currently one query version is supported: "2017-09-30". If not specified, the query version defaults to this value.
    public var queryVersion: Swift.String?
    /// Metadata which can be used to manage the dynamic thing group.
    public var tags: [IoTClientTypes.Tag]?
    /// The dynamic thing group name to create.
    /// This member is required.
    public var thingGroupName: Swift.String?
    /// The dynamic thing group properties.
    public var thingGroupProperties: IoTClientTypes.ThingGroupProperties?

    public init(
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        thingGroupName: Swift.String? = nil,
        thingGroupProperties: IoTClientTypes.ThingGroupProperties? = nil
    )
    {
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.tags = tags
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
    }
}

public struct CreateDynamicThingGroupOutput {
    /// The dynamic thing group index name.
    public var indexName: Swift.String?
    /// The dynamic thing group search query string.
    public var queryString: Swift.String?
    /// The dynamic thing group query version.
    public var queryVersion: Swift.String?
    /// The dynamic thing group ARN.
    public var thingGroupArn: Swift.String?
    /// The dynamic thing group ID.
    public var thingGroupId: Swift.String?
    /// The dynamic thing group name.
    public var thingGroupName: Swift.String?

    public init(
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        thingGroupArn: Swift.String? = nil,
        thingGroupId: Swift.String? = nil,
        thingGroupName: Swift.String? = nil
    )
    {
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.thingGroupArn = thingGroupArn
        self.thingGroupId = thingGroupId
        self.thingGroupName = thingGroupName
    }
}

/// The index is not ready.
public struct IndexNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IndexNotReadyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The aggregation is invalid.
public struct InvalidAggregationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAggregationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTClientTypes {

    public enum FleetMetricUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bits
        case bitssecond
        case bytes
        case bytessecond
        case count
        case countsecond
        case gigabits
        case gigabitssecond
        case gigabytes
        case gigabytessecond
        case kilobits
        case kilobitssecond
        case kilobytes
        case kilobytessecond
        case megabits
        case megabitssecond
        case megabytes
        case megabytessecond
        case microseconds
        case milliseconds
        case `none`
        case percent
        case seconds
        case terabits
        case terabitssecond
        case terabytes
        case terabytessecond
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetMetricUnit] {
            return [
                .bits,
                .bitssecond,
                .bytes,
                .bytessecond,
                .count,
                .countsecond,
                .gigabits,
                .gigabitssecond,
                .gigabytes,
                .gigabytessecond,
                .kilobits,
                .kilobitssecond,
                .kilobytes,
                .kilobytessecond,
                .megabits,
                .megabitssecond,
                .megabytes,
                .megabytessecond,
                .microseconds,
                .milliseconds,
                .none,
                .percent,
                .seconds,
                .terabits,
                .terabitssecond,
                .terabytes,
                .terabytessecond
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bits: return "Bits"
            case .bitssecond: return "Bits/Second"
            case .bytes: return "Bytes"
            case .bytessecond: return "Bytes/Second"
            case .count: return "Count"
            case .countsecond: return "Count/Second"
            case .gigabits: return "Gigabits"
            case .gigabitssecond: return "Gigabits/Second"
            case .gigabytes: return "Gigabytes"
            case .gigabytessecond: return "Gigabytes/Second"
            case .kilobits: return "Kilobits"
            case .kilobitssecond: return "Kilobits/Second"
            case .kilobytes: return "Kilobytes"
            case .kilobytessecond: return "Kilobytes/Second"
            case .megabits: return "Megabits"
            case .megabitssecond: return "Megabits/Second"
            case .megabytes: return "Megabytes"
            case .megabytessecond: return "Megabytes/Second"
            case .microseconds: return "Microseconds"
            case .milliseconds: return "Milliseconds"
            case .none: return "None"
            case .percent: return "Percent"
            case .seconds: return "Seconds"
            case .terabits: return "Terabits"
            case .terabitssecond: return "Terabits/Second"
            case .terabytes: return "Terabytes"
            case .terabytessecond: return "Terabytes/Second"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFleetMetricInput {
    /// The field to aggregate.
    /// This member is required.
    public var aggregationField: Swift.String?
    /// The type of the aggregation query.
    /// This member is required.
    public var aggregationType: IoTClientTypes.AggregationType?
    /// The fleet metric description.
    public var description: Swift.String?
    /// The name of the index to search.
    public var indexName: Swift.String?
    /// The name of the fleet metric to create.
    /// This member is required.
    public var metricName: Swift.String?
    /// The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.
    /// This member is required.
    public var period: Swift.Int?
    /// The search query string.
    /// This member is required.
    public var queryString: Swift.String?
    /// The query version.
    public var queryVersion: Swift.String?
    /// Metadata, which can be used to manage the fleet metric.
    public var tags: [IoTClientTypes.Tag]?
    /// Used to support unit transformation such as milliseconds to seconds. The unit must be supported by [CW metric](https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html). Default to null.
    public var unit: IoTClientTypes.FleetMetricUnit?

    public init(
        aggregationField: Swift.String? = nil,
        aggregationType: IoTClientTypes.AggregationType? = nil,
        description: Swift.String? = nil,
        indexName: Swift.String? = nil,
        metricName: Swift.String? = nil,
        period: Swift.Int? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        unit: IoTClientTypes.FleetMetricUnit? = nil
    )
    {
        self.aggregationField = aggregationField
        self.aggregationType = aggregationType
        self.description = description
        self.indexName = indexName
        self.metricName = metricName
        self.period = period
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.tags = tags
        self.unit = unit
    }
}

public struct CreateFleetMetricOutput {
    /// The Amazon Resource Name (ARN) of the new fleet metric.
    public var metricArn: Swift.String?
    /// The name of the fleet metric to create.
    public var metricName: Swift.String?

    public init(
        metricArn: Swift.String? = nil,
        metricName: Swift.String? = nil
    )
    {
        self.metricArn = metricArn
        self.metricName = metricName
    }
}

extension IoTClientTypes {

    public enum RetryableFailureType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case failed
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [RetryableFailureType] {
            return [
                .all,
                .failed,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The criteria that determines how many retries are allowed for each failure type for a job.
    public struct RetryCriteria {
        /// The type of job execution failures that can initiate a job retry.
        /// This member is required.
        public var failureType: IoTClientTypes.RetryableFailureType?
        /// The number of retries allowed for a failure type for the job.
        /// This member is required.
        public var numberOfRetries: Swift.Int?

        public init(
            failureType: IoTClientTypes.RetryableFailureType? = nil,
            numberOfRetries: Swift.Int? = nil
        )
        {
            self.failureType = failureType
            self.numberOfRetries = numberOfRetries
        }
    }

}

extension IoTClientTypes {
    /// The configuration that determines how many retries are allowed for each failure type for a job.
    public struct JobExecutionsRetryConfig {
        /// The list of criteria that determines how many retries are allowed for each failure type for a job.
        /// This member is required.
        public var criteriaList: [IoTClientTypes.RetryCriteria]?

        public init(
            criteriaList: [IoTClientTypes.RetryCriteria]? = nil
        )
        {
            self.criteriaList = criteriaList
        }
    }

}

extension IoTClientTypes {
    /// Allows you to define a criteria to initiate the increase in rate of rollout for a job.
    public struct RateIncreaseCriteria {
        /// The threshold for number of notified things that will initiate the increase in rate of rollout.
        public var numberOfNotifiedThings: Swift.Int?
        /// The threshold for number of succeeded things that will initiate the increase in rate of rollout.
        public var numberOfSucceededThings: Swift.Int?

        public init(
            numberOfNotifiedThings: Swift.Int? = nil,
            numberOfSucceededThings: Swift.Int? = nil
        )
        {
            self.numberOfNotifiedThings = numberOfNotifiedThings
            self.numberOfSucceededThings = numberOfSucceededThings
        }
    }

}

extension IoTClientTypes {
    /// Allows you to create an exponential rate of rollout for a job.
    public struct ExponentialRolloutRate {
        /// The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.
        /// This member is required.
        public var baseRatePerMinute: Swift.Int?
        /// The exponential factor to increase the rate of rollout for a job. Amazon Web Services IoT Core supports up to one digit after the decimal (for example, 1.5, but not 1.55).
        /// This member is required.
        public var incrementFactor: Swift.Double?
        /// The criteria to initiate the increase in rate of rollout for a job.
        /// This member is required.
        public var rateIncreaseCriteria: IoTClientTypes.RateIncreaseCriteria?

        public init(
            baseRatePerMinute: Swift.Int? = nil,
            incrementFactor: Swift.Double? = nil,
            rateIncreaseCriteria: IoTClientTypes.RateIncreaseCriteria? = nil
        )
        {
            self.baseRatePerMinute = baseRatePerMinute
            self.incrementFactor = incrementFactor
            self.rateIncreaseCriteria = rateIncreaseCriteria
        }
    }

}

extension IoTClientTypes {
    /// Allows you to create a staged rollout of a job.
    public struct JobExecutionsRolloutConfig {
        /// The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.
        public var exponentialRate: IoTClientTypes.ExponentialRolloutRate?
        /// The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.
        public var maximumPerMinute: Swift.Int?

        public init(
            exponentialRate: IoTClientTypes.ExponentialRolloutRate? = nil,
            maximumPerMinute: Swift.Int? = nil
        )
        {
            self.exponentialRate = exponentialRate
            self.maximumPerMinute = maximumPerMinute
        }
    }

}

extension IoTClientTypes {
    /// Configuration for pre-signed S3 URLs.
    public struct PresignedUrlConfig {
        /// How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 3600 seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.
        public var expiresInSec: Swift.Int?
        /// The ARN of an IAM role that grants permission to download files from the S3 bucket where the job data/updates are stored. The role must also grant permission for IoT to download the files. For information about addressing the confused deputy problem, see [cross-service confused deputy prevention](https://docs.aws.amazon.com/iot/latest/developerguide/cross-service-confused-deputy-prevention.html) in the Amazon Web Services IoT Core developer guide.
        public var roleArn: Swift.String?

        public init(
            expiresInSec: Swift.Int? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.expiresInSec = expiresInSec
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes {

    public enum JobEndBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancel
        case forceCancel
        case stopRollout
        case sdkUnknown(Swift.String)

        public static var allCases: [JobEndBehavior] {
            return [
                .cancel,
                .forceCancel,
                .stopRollout
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case .forceCancel: return "FORCE_CANCEL"
            case .stopRollout: return "STOP_ROLLOUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// An optional configuration within the SchedulingConfig to setup a recurring maintenance window with a predetermined start time and duration for the rollout of a job document to all devices in a target group for a job.
    public struct MaintenanceWindow {
        /// Displays the duration of the next maintenance window.
        /// This member is required.
        public var durationInMinutes: Swift.Int?
        /// Displays the start time of the next maintenance window.
        /// This member is required.
        public var startTime: Swift.String?

        public init(
            durationInMinutes: Swift.Int? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.startTime = startTime
        }
    }

}

extension IoTClientTypes {
    /// Specifies the date and time that a job will begin the rollout of the job document to all devices in the target group. Additionally, you can specify the end behavior for each job execution when it reaches the scheduled end time.
    public struct SchedulingConfig {
        /// Specifies the end behavior for all job executions after a job reaches the selected endTime. If endTime is not selected when creating the job, then endBehavior does not apply.
        public var endBehavior: IoTClientTypes.JobEndBehavior?
        /// The time a job will stop rollout of the job document to all devices in the target group for a job. The endTime must take place no later than two years from the current time and be scheduled a minimum of thirty minutes from the current time. The minimum duration between startTime and endTime is thirty minutes. The maximum duration between startTime and endTime is two years. The date and time format for the endTime is YYYY-MM-DD for the date and HH:MM for the time. For more information on the syntax for endTime when using an API command or the Command Line Interface, see [Timestamp](https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters-types.html#parameter-type-timestamp).
        public var endTime: Swift.String?
        /// An optional configuration within the SchedulingConfig to setup a recurring maintenance window with a predetermined start time and duration for the rollout of a job document to all devices in a target group for a job.
        public var maintenanceWindows: [IoTClientTypes.MaintenanceWindow]?
        /// The time a job will begin rollout of the job document to all devices in the target group for a job. The startTime can be scheduled up to a year in advance and must be scheduled a minimum of thirty minutes from the current time. The date and time format for the startTime is YYYY-MM-DD for the date and HH:MM for the time. For more information on the syntax for startTime when using an API command or the Command Line Interface, see [Timestamp](https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters-types.html#parameter-type-timestamp).
        public var startTime: Swift.String?

        public init(
            endBehavior: IoTClientTypes.JobEndBehavior? = nil,
            endTime: Swift.String? = nil,
            maintenanceWindows: [IoTClientTypes.MaintenanceWindow]? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.endBehavior = endBehavior
            self.endTime = endTime
            self.maintenanceWindows = maintenanceWindows
            self.startTime = startTime
        }
    }

}

extension IoTClientTypes {

    public enum TargetSelection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuous
        case snapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetSelection] {
            return [
                .continuous,
                .snapshot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuous: return "CONTINUOUS"
            case .snapshot: return "SNAPSHOT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to TIMED_OUT.
    public struct TimeoutConfig {
        /// Specifies the amount of time, in minutes, this device has to finish execution of this job. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress timer can't be updated and will apply to all job executions for the job. Whenever a job execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and switch to the terminal TIMED_OUT status.
        public var inProgressTimeoutInMinutes: Swift.Int?

        public init(
            inProgressTimeoutInMinutes: Swift.Int? = nil
        )
        {
            self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
        }
    }

}

public struct CreateJobInput {
    /// Allows you to create the criteria to abort a job.
    public var abortConfig: IoTClientTypes.AbortConfig?
    /// A short text description of the job.
    public var description: Swift.String?
    /// The package version Amazon Resource Names (ARNs) that are installed on the device when the job successfully completes. The package version must be in either the Published or Deprecated state when the job deploys. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle). Note:The following Length Constraints relates to a single ARN. Up to 25 package version ARNs are allowed.
    public var destinationPackageVersions: [Swift.String]?
    /// The job document. Required if you don't specify a value for documentSource.
    public var document: Swift.String?
    /// Parameters of an Amazon Web Services managed template that you can specify to create the job document. documentParameters can only be used when creating jobs from Amazon Web Services managed templates. This parameter can't be used with custom job templates or to create jobs from them.
    public var documentParameters: [Swift.String: Swift.String]?
    /// An S3 link, or S3 object URL, to the job document. The link is an Amazon S3 object URL and is required if you don't specify a value for document. For example, --document-source https://s3.region-code.amazonaws.com/example-firmware/device-firmware.1.0 For more information, see [Methods for accessing a bucket](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-bucket-intro.html).
    public var documentSource: Swift.String?
    /// Allows you to create the criteria to retry a job.
    public var jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
    /// Allows you to create a staged rollout of the job.
    public var jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
    /// A job identifier which must be unique for your Amazon Web Services account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
    /// This member is required.
    public var jobId: Swift.String?
    /// The ARN of the job template used to create the job.
    public var jobTemplateArn: Swift.String?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see [Setting up IoT Greengrass core devices.](https://docs.aws.amazon.com/greengrass/v2/developerguide/setting-up.html)
    public var namespaceId: Swift.String?
    /// Configuration information for pre-signed S3 URLs.
    public var presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
    /// The configuration that allows you to schedule a job for a future date and time in addition to specifying the end behavior for each job execution.
    public var schedulingConfig: IoTClientTypes.SchedulingConfig?
    /// Metadata which can be used to manage the job.
    public var tags: [IoTClientTypes.Tag]?
    /// Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.
    public var targetSelection: IoTClientTypes.TargetSelection?
    /// A list of things and thing groups to which the job should be sent.
    /// This member is required.
    public var targets: [Swift.String]?
    /// Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to TIMED_OUT.
    public var timeoutConfig: IoTClientTypes.TimeoutConfig?

    public init(
        abortConfig: IoTClientTypes.AbortConfig? = nil,
        description: Swift.String? = nil,
        destinationPackageVersions: [Swift.String]? = nil,
        document: Swift.String? = nil,
        documentParameters: [Swift.String: Swift.String]? = nil,
        documentSource: Swift.String? = nil,
        jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig? = nil,
        jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig? = nil,
        jobId: Swift.String? = nil,
        jobTemplateArn: Swift.String? = nil,
        namespaceId: Swift.String? = nil,
        presignedUrlConfig: IoTClientTypes.PresignedUrlConfig? = nil,
        schedulingConfig: IoTClientTypes.SchedulingConfig? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        targetSelection: IoTClientTypes.TargetSelection? = nil,
        targets: [Swift.String]? = nil,
        timeoutConfig: IoTClientTypes.TimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.description = description
        self.destinationPackageVersions = destinationPackageVersions
        self.document = document
        self.documentParameters = documentParameters
        self.documentSource = documentSource
        self.jobExecutionsRetryConfig = jobExecutionsRetryConfig
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.jobId = jobId
        self.jobTemplateArn = jobTemplateArn
        self.namespaceId = namespaceId
        self.presignedUrlConfig = presignedUrlConfig
        self.schedulingConfig = schedulingConfig
        self.tags = tags
        self.targetSelection = targetSelection
        self.targets = targets
        self.timeoutConfig = timeoutConfig
    }
}

public struct CreateJobOutput {
    /// The job description.
    public var description: Swift.String?
    /// The job ARN.
    public var jobArn: Swift.String?
    /// The unique identifier you assigned to this job.
    public var jobId: Swift.String?

    public init(
        description: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.description = description
        self.jobArn = jobArn
        self.jobId = jobId
    }
}

public struct CreateJobTemplateInput {
    /// The criteria that determine when and how a job abort takes place.
    public var abortConfig: IoTClientTypes.AbortConfig?
    /// A description of the job document.
    /// This member is required.
    public var description: Swift.String?
    /// The package version Amazon Resource Names (ARNs) that are installed on the device when the job successfully completes. The package version must be in either the Published or Deprecated state when the job deploys. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle). Note:The following Length Constraints relates to a single ARN. Up to 25 package version ARNs are allowed.
    public var destinationPackageVersions: [Swift.String]?
    /// The job document. Required if you don't specify a value for documentSource.
    public var document: Swift.String?
    /// An S3 link, or S3 object URL, to the job document. The link is an Amazon S3 object URL and is required if you don't specify a value for document. For example, --document-source https://s3.region-code.amazonaws.com/example-firmware/device-firmware.1.0 For more information, see [Methods for accessing a bucket](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-bucket-intro.html).
    public var documentSource: Swift.String?
    /// The ARN of the job to use as the basis for the job template.
    public var jobArn: Swift.String?
    /// Allows you to create the criteria to retry a job.
    public var jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
    /// Allows you to create a staged rollout of a job.
    public var jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
    /// A unique identifier for the job template. We recommend using a UUID. Alpha-numeric characters, "-", and "_" are valid for use here.
    /// This member is required.
    public var jobTemplateId: Swift.String?
    /// Allows you to configure an optional maintenance window for the rollout of a job document to all devices in the target group for a job.
    public var maintenanceWindows: [IoTClientTypes.MaintenanceWindow]?
    /// Configuration for pre-signed S3 URLs.
    public var presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
    /// Metadata that can be used to manage the job template.
    public var tags: [IoTClientTypes.Tag]?
    /// Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to TIMED_OUT.
    public var timeoutConfig: IoTClientTypes.TimeoutConfig?

    public init(
        abortConfig: IoTClientTypes.AbortConfig? = nil,
        description: Swift.String? = nil,
        destinationPackageVersions: [Swift.String]? = nil,
        document: Swift.String? = nil,
        documentSource: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig? = nil,
        jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig? = nil,
        jobTemplateId: Swift.String? = nil,
        maintenanceWindows: [IoTClientTypes.MaintenanceWindow]? = nil,
        presignedUrlConfig: IoTClientTypes.PresignedUrlConfig? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        timeoutConfig: IoTClientTypes.TimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.description = description
        self.destinationPackageVersions = destinationPackageVersions
        self.document = document
        self.documentSource = documentSource
        self.jobArn = jobArn
        self.jobExecutionsRetryConfig = jobExecutionsRetryConfig
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.jobTemplateId = jobTemplateId
        self.maintenanceWindows = maintenanceWindows
        self.presignedUrlConfig = presignedUrlConfig
        self.tags = tags
        self.timeoutConfig = timeoutConfig
    }
}

public struct CreateJobTemplateOutput {
    /// The ARN of the job template.
    public var jobTemplateArn: Swift.String?
    /// The unique identifier of the job template.
    public var jobTemplateId: Swift.String?

    public init(
        jobTemplateArn: Swift.String? = nil,
        jobTemplateId: Swift.String? = nil
    )
    {
        self.jobTemplateArn = jobTemplateArn
        self.jobTemplateId = jobTemplateId
    }
}

/// The input for the CreateKeysAndCertificate operation. Requires permission to access the [CreateKeysAndCertificateRequest](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions) action.
public struct CreateKeysAndCertificateInput {
    /// Specifies whether the certificate is active.
    public var setAsActive: Swift.Bool?

    public init(
        setAsActive: Swift.Bool? = false
    )
    {
        self.setAsActive = setAsActive
    }
}

extension IoTClientTypes {
    /// Describes a key pair.
    public struct KeyPair {
        /// The private key.
        public var privateKey: Swift.String?
        /// The public key.
        public var publicKey: Swift.String?

        public init(
            privateKey: Swift.String? = nil,
            publicKey: Swift.String? = nil
        )
        {
            self.privateKey = privateKey
            self.publicKey = publicKey
        }
    }

}

extension IoTClientTypes.KeyPair: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyPair(publicKey: \(Swift.String(describing: publicKey)), privateKey: \"CONTENT_REDACTED\")"}
}

/// The output of the CreateKeysAndCertificate operation.
public struct CreateKeysAndCertificateOutput {
    /// The ARN of the certificate.
    public var certificateArn: Swift.String?
    /// The ID of the certificate. IoT issues a default subject name for the certificate (for example, IoT Certificate).
    public var certificateId: Swift.String?
    /// The certificate data, in PEM format.
    public var certificatePem: Swift.String?
    /// The generated key pair.
    public var keyPair: IoTClientTypes.KeyPair?

    public init(
        certificateArn: Swift.String? = nil,
        certificateId: Swift.String? = nil,
        certificatePem: Swift.String? = nil,
        keyPair: IoTClientTypes.KeyPair? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
        self.certificatePem = certificatePem
        self.keyPair = keyPair
    }
}

extension IoTClientTypes {

    public enum LogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case disabled
        case error
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .debug,
                .disabled,
                .error,
                .info,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .disabled: return "DISABLED"
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Parameters used when defining a mitigation action that enable Amazon Web Services IoT Core logging.
    public struct EnableIoTLoggingParams {
        /// Specifies the type of information to be logged.
        /// This member is required.
        public var logLevel: IoTClientTypes.LogLevel?
        /// The Amazon Resource Name (ARN) of the IAM role used for logging.
        /// This member is required.
        public var roleArnForLogging: Swift.String?

        public init(
            logLevel: IoTClientTypes.LogLevel? = nil,
            roleArnForLogging: Swift.String? = nil
        )
        {
            self.logLevel = logLevel
            self.roleArnForLogging = roleArnForLogging
        }
    }

}

extension IoTClientTypes {
    /// Parameters to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
    public struct PublishFindingToSnsParams {
        /// The ARN of the topic to which you want to publish the findings.
        /// This member is required.
        public var topicArn: Swift.String?

        public init(
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension IoTClientTypes {

    public enum PolicyTemplateName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blankPolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyTemplateName] {
            return [
                .blankPolicy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blankPolicy: return "BLANK_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Parameters to define a mitigation action that adds a blank policy to restrict permissions.
    public struct ReplaceDefaultPolicyVersionParams {
        /// The name of the template to be applied. The only supported value is BLANK_POLICY.
        /// This member is required.
        public var templateName: IoTClientTypes.PolicyTemplateName?

        public init(
            templateName: IoTClientTypes.PolicyTemplateName? = nil
        )
        {
            self.templateName = templateName
        }
    }

}

extension IoTClientTypes {

    public enum CACertificateUpdateAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deactivate
        case sdkUnknown(Swift.String)

        public static var allCases: [CACertificateUpdateAction] {
            return [
                .deactivate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deactivate: return "DEACTIVATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
    public struct UpdateCACertificateParams {
        /// The action that you want to apply to the CA certificate. The only supported value is DEACTIVATE.
        /// This member is required.
        public var action: IoTClientTypes.CACertificateUpdateAction?

        public init(
            action: IoTClientTypes.CACertificateUpdateAction? = nil
        )
        {
            self.action = action
        }
    }

}

extension IoTClientTypes {

    public enum DeviceCertificateUpdateAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deactivate
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceCertificateUpdateAction] {
            return [
                .deactivate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deactivate: return "DEACTIVATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Parameters to define a mitigation action that changes the state of the device certificate to inactive.
    public struct UpdateDeviceCertificateParams {
        /// The action that you want to apply to the device certificate. The only supported value is DEACTIVATE.
        /// This member is required.
        public var action: IoTClientTypes.DeviceCertificateUpdateAction?

        public init(
            action: IoTClientTypes.DeviceCertificateUpdateAction? = nil
        )
        {
            self.action = action
        }
    }

}

extension IoTClientTypes {
    /// The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).
    public struct MitigationActionParams {
        /// Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.
        public var addThingsToThingGroupParams: IoTClientTypes.AddThingsToThingGroupParams?
        /// Parameters to define a mitigation action that enables Amazon Web Services IoT Core logging at a specified level of detail.
        public var enableIoTLoggingParams: IoTClientTypes.EnableIoTLoggingParams?
        /// Parameters to define a mitigation action that publishes findings to Amazon Simple Notification Service (Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
        public var publishFindingToSnsParams: IoTClientTypes.PublishFindingToSnsParams?
        /// Parameters to define a mitigation action that adds a blank policy to restrict permissions.
        public var replaceDefaultPolicyVersionParams: IoTClientTypes.ReplaceDefaultPolicyVersionParams?
        /// Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
        public var updateCACertificateParams: IoTClientTypes.UpdateCACertificateParams?
        /// Parameters to define a mitigation action that changes the state of the device certificate to inactive.
        public var updateDeviceCertificateParams: IoTClientTypes.UpdateDeviceCertificateParams?

        public init(
            addThingsToThingGroupParams: IoTClientTypes.AddThingsToThingGroupParams? = nil,
            enableIoTLoggingParams: IoTClientTypes.EnableIoTLoggingParams? = nil,
            publishFindingToSnsParams: IoTClientTypes.PublishFindingToSnsParams? = nil,
            replaceDefaultPolicyVersionParams: IoTClientTypes.ReplaceDefaultPolicyVersionParams? = nil,
            updateCACertificateParams: IoTClientTypes.UpdateCACertificateParams? = nil,
            updateDeviceCertificateParams: IoTClientTypes.UpdateDeviceCertificateParams? = nil
        )
        {
            self.addThingsToThingGroupParams = addThingsToThingGroupParams
            self.enableIoTLoggingParams = enableIoTLoggingParams
            self.publishFindingToSnsParams = publishFindingToSnsParams
            self.replaceDefaultPolicyVersionParams = replaceDefaultPolicyVersionParams
            self.updateCACertificateParams = updateCACertificateParams
            self.updateDeviceCertificateParams = updateDeviceCertificateParams
        }
    }

}

public struct CreateMitigationActionInput {
    /// A friendly name for the action. Choose a friendly name that accurately describes the action (for example, EnableLoggingAction).
    /// This member is required.
    public var actionName: Swift.String?
    /// Defines the type of action and the parameters for that action.
    /// This member is required.
    public var actionParams: IoTClientTypes.MitigationActionParams?
    /// The ARN of the IAM role that is used to apply the mitigation action.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Metadata that can be used to manage the mitigation action.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        actionName: Swift.String? = nil,
        actionParams: IoTClientTypes.MitigationActionParams? = nil,
        roleArn: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.actionName = actionName
        self.actionParams = actionParams
        self.roleArn = roleArn
        self.tags = tags
    }
}

public struct CreateMitigationActionOutput {
    /// The ARN for the new mitigation action.
    public var actionArn: Swift.String?
    /// A unique identifier for the new mitigation action.
    public var actionId: Swift.String?

    public init(
        actionArn: Swift.String? = nil,
        actionId: Swift.String? = nil
    )
    {
        self.actionArn = actionArn
        self.actionId = actionId
    }
}

extension IoTClientTypes {

    public enum AwsJobAbortCriteriaAbortAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancel
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsJobAbortCriteriaAbortAction] {
            return [
                .cancel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {

    public enum AwsJobAbortCriteriaFailureType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case failed
        case rejected
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsJobAbortCriteriaFailureType] {
            return [
                .all,
                .failed,
                .rejected,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .rejected: return "REJECTED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The criteria that determine when and how a job abort takes place.
    public struct AwsJobAbortCriteria {
        /// The type of job action to take to initiate the job abort.
        /// This member is required.
        public var action: IoTClientTypes.AwsJobAbortCriteriaAbortAction?
        /// The type of job execution failures that can initiate a job abort.
        /// This member is required.
        public var failureType: IoTClientTypes.AwsJobAbortCriteriaFailureType?
        /// The minimum number of things which must receive job execution notifications before the job can be aborted.
        /// This member is required.
        public var minNumberOfExecutedThings: Swift.Int?
        /// The minimum percentage of job execution failures that must occur to initiate the job abort. Amazon Web Services IoT Core supports up to two digits after the decimal (for example, 10.9 and 10.99, but not 10.999).
        /// This member is required.
        public var thresholdPercentage: Swift.Double?

        public init(
            action: IoTClientTypes.AwsJobAbortCriteriaAbortAction? = nil,
            failureType: IoTClientTypes.AwsJobAbortCriteriaFailureType? = nil,
            minNumberOfExecutedThings: Swift.Int? = nil,
            thresholdPercentage: Swift.Double? = nil
        )
        {
            self.action = action
            self.failureType = failureType
            self.minNumberOfExecutedThings = minNumberOfExecutedThings
            self.thresholdPercentage = thresholdPercentage
        }
    }

}

extension IoTClientTypes {
    /// The criteria that determine when and how a job abort takes place.
    public struct AwsJobAbortConfig {
        /// The list of criteria that determine when and how to abort the job.
        /// This member is required.
        public var abortCriteriaList: [IoTClientTypes.AwsJobAbortCriteria]?

        public init(
            abortCriteriaList: [IoTClientTypes.AwsJobAbortCriteria]? = nil
        )
        {
            self.abortCriteriaList = abortCriteriaList
        }
    }

}

extension IoTClientTypes {
    /// The criteria to initiate the increase in rate of rollout for a job.
    public struct AwsJobRateIncreaseCriteria {
        /// When this number of things have been notified, it will initiate an increase in the rollout rate.
        public var numberOfNotifiedThings: Swift.Int?
        /// When this number of things have succeeded in their job execution, it will initiate an increase in the rollout rate.
        public var numberOfSucceededThings: Swift.Int?

        public init(
            numberOfNotifiedThings: Swift.Int? = nil,
            numberOfSucceededThings: Swift.Int? = nil
        )
        {
            self.numberOfNotifiedThings = numberOfNotifiedThings
            self.numberOfSucceededThings = numberOfSucceededThings
        }
    }

}

extension IoTClientTypes {
    /// The rate of increase for a job rollout. This parameter allows you to define an exponential rate increase for a job rollout.
    public struct AwsJobExponentialRolloutRate {
        /// The minimum number of things that will be notified of a pending job, per minute, at the start of the job rollout. This is the initial rate of the rollout.
        /// This member is required.
        public var baseRatePerMinute: Swift.Int?
        /// The rate of increase for a job rollout. The number of things notified is multiplied by this factor.
        /// This member is required.
        public var incrementFactor: Swift.Double
        /// The criteria to initiate the increase in rate of rollout for a job. Amazon Web Services IoT Core supports up to one digit after the decimal (for example, 1.5, but not 1.55).
        /// This member is required.
        public var rateIncreaseCriteria: IoTClientTypes.AwsJobRateIncreaseCriteria?

        public init(
            baseRatePerMinute: Swift.Int? = nil,
            incrementFactor: Swift.Double = 0.0,
            rateIncreaseCriteria: IoTClientTypes.AwsJobRateIncreaseCriteria? = nil
        )
        {
            self.baseRatePerMinute = baseRatePerMinute
            self.incrementFactor = incrementFactor
            self.rateIncreaseCriteria = rateIncreaseCriteria
        }
    }

}

extension IoTClientTypes {
    /// Configuration for the rollout of OTA updates.
    public struct AwsJobExecutionsRolloutConfig {
        /// The rate of increase for a job rollout. This parameter allows you to define an exponential rate increase for a job rollout.
        public var exponentialRate: IoTClientTypes.AwsJobExponentialRolloutRate?
        /// The maximum number of OTA update job executions started per minute.
        public var maximumPerMinute: Swift.Int?

        public init(
            exponentialRate: IoTClientTypes.AwsJobExponentialRolloutRate? = nil,
            maximumPerMinute: Swift.Int? = nil
        )
        {
            self.exponentialRate = exponentialRate
            self.maximumPerMinute = maximumPerMinute
        }
    }

}

extension IoTClientTypes {
    /// Configuration information for pre-signed URLs. Valid when protocols contains HTTP.
    public struct AwsJobPresignedUrlConfig {
        /// How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 1800 seconds. Pre-signed URLs are generated when a request for the job document is received.
        public var expiresInSec: Swift.Int?

        public init(
            expiresInSec: Swift.Int? = nil
        )
        {
            self.expiresInSec = expiresInSec
        }
    }

}

extension IoTClientTypes {
    /// Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to TIMED_OUT.
    public struct AwsJobTimeoutConfig {
        /// Specifies the amount of time, in minutes, this device has to finish execution of this job. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress timer can't be updated and will apply to all job executions for the job. Whenever a job execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and switch to the terminal TIMED_OUT status.
        public var inProgressTimeoutInMinutes: Swift.Int?

        public init(
            inProgressTimeoutInMinutes: Swift.Int? = nil
        )
        {
            self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
        }
    }

}

extension IoTClientTypes {
    /// Describes the certificate chain being used when code signing a file.
    public struct CodeSigningCertificateChain {
        /// The name of the certificate.
        public var certificateName: Swift.String?
        /// A base64 encoded binary representation of the code signing certificate chain.
        public var inlineDocument: Swift.String?

        public init(
            certificateName: Swift.String? = nil,
            inlineDocument: Swift.String? = nil
        )
        {
            self.certificateName = certificateName
            self.inlineDocument = inlineDocument
        }
    }

}

extension IoTClientTypes {
    /// Describes the signature for a file.
    public struct CodeSigningSignature {
        /// A base64 encoded binary representation of the code signing signature.
        public var inlineDocument: Foundation.Data?

        public init(
            inlineDocument: Foundation.Data? = nil
        )
        {
            self.inlineDocument = inlineDocument
        }
    }

}

extension IoTClientTypes {
    /// Describes a custom method used to code sign a file.
    public struct CustomCodeSigning {
        /// The certificate chain.
        public var certificateChain: IoTClientTypes.CodeSigningCertificateChain?
        /// The hash algorithm used to code sign the file. You can use a string as the algorithm name if the target over-the-air (OTA) update devices are able to verify the signature that was generated using the same signature algorithm. For example, FreeRTOS uses SHA256 or SHA1, so you can pass either of them based on which was used for generating the signature.
        public var hashAlgorithm: Swift.String?
        /// The signature for the file.
        public var signature: IoTClientTypes.CodeSigningSignature?
        /// The signature algorithm used to code sign the file. You can use a string as the algorithm name if the target over-the-air (OTA) update devices are able to verify the signature that was generated using the same signature algorithm. For example, FreeRTOS uses ECDSA or RSA, so you can pass either of them based on which was used for generating the signature.
        public var signatureAlgorithm: Swift.String?

        public init(
            certificateChain: IoTClientTypes.CodeSigningCertificateChain? = nil,
            hashAlgorithm: Swift.String? = nil,
            signature: IoTClientTypes.CodeSigningSignature? = nil,
            signatureAlgorithm: Swift.String? = nil
        )
        {
            self.certificateChain = certificateChain
            self.hashAlgorithm = hashAlgorithm
            self.signature = signature
            self.signatureAlgorithm = signatureAlgorithm
        }
    }

}

extension IoTClientTypes {
    /// Describes the location of updated firmware in S3.
    public struct S3Destination {
        /// The S3 bucket that contains the updated firmware.
        public var bucket: Swift.String?
        /// The S3 prefix.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }

}

extension IoTClientTypes {
    /// Describes the location of the updated firmware.
    public struct Destination {
        /// Describes the location in S3 of the updated firmware.
        public var s3Destination: IoTClientTypes.S3Destination?

        public init(
            s3Destination: IoTClientTypes.S3Destination? = nil
        )
        {
            self.s3Destination = s3Destination
        }
    }

}

extension IoTClientTypes {
    /// Describes the code-signing profile.
    public struct SigningProfileParameter {
        /// Certificate ARN.
        public var certificateArn: Swift.String?
        /// The location of the code-signing certificate on your device.
        public var certificatePathOnDevice: Swift.String?
        /// The hardware platform of your device.
        public var platform: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            certificatePathOnDevice: Swift.String? = nil,
            platform: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificatePathOnDevice = certificatePathOnDevice
            self.platform = platform
        }
    }

}

extension IoTClientTypes {
    /// Information required to start a signing job.
    public struct StartSigningJobParameter {
        /// The location to write the code-signed file.
        public var destination: IoTClientTypes.Destination?
        /// The code-signing profile name.
        public var signingProfileName: Swift.String?
        /// Describes the code-signing profile.
        public var signingProfileParameter: IoTClientTypes.SigningProfileParameter?

        public init(
            destination: IoTClientTypes.Destination? = nil,
            signingProfileName: Swift.String? = nil,
            signingProfileParameter: IoTClientTypes.SigningProfileParameter? = nil
        )
        {
            self.destination = destination
            self.signingProfileName = signingProfileName
            self.signingProfileParameter = signingProfileParameter
        }
    }

}

extension IoTClientTypes {
    /// Describes the method to use when code signing a file.
    public struct CodeSigning {
        /// The ID of the AWSSignerJob which was created to sign the file.
        public var awsSignerJobId: Swift.String?
        /// A custom method for code signing a file.
        public var customCodeSigning: IoTClientTypes.CustomCodeSigning?
        /// Describes the code-signing job.
        public var startSigningJobParameter: IoTClientTypes.StartSigningJobParameter?

        public init(
            awsSignerJobId: Swift.String? = nil,
            customCodeSigning: IoTClientTypes.CustomCodeSigning? = nil,
            startSigningJobParameter: IoTClientTypes.StartSigningJobParameter? = nil
        )
        {
            self.awsSignerJobId = awsSignerJobId
            self.customCodeSigning = customCodeSigning
            self.startSigningJobParameter = startSigningJobParameter
        }
    }

}

extension IoTClientTypes {
    /// Describes a group of files that can be streamed.
    public struct Stream {
        /// The ID of a file associated with a stream.
        public var fileId: Swift.Int?
        /// The stream ID.
        public var streamId: Swift.String?

        public init(
            fileId: Swift.Int? = nil,
            streamId: Swift.String? = nil
        )
        {
            self.fileId = fileId
            self.streamId = streamId
        }
    }

}

extension IoTClientTypes {
    /// The location of the OTA update.
    public struct FileLocation {
        /// The location of the updated firmware in S3.
        public var s3Location: IoTClientTypes.S3Location?
        /// The stream that contains the OTA update.
        public var stream: IoTClientTypes.Stream?

        public init(
            s3Location: IoTClientTypes.S3Location? = nil,
            stream: IoTClientTypes.Stream? = nil
        )
        {
            self.s3Location = s3Location
            self.stream = stream
        }
    }

}

extension IoTClientTypes {
    /// Describes a file to be associated with an OTA update.
    public struct OTAUpdateFile {
        /// A list of name-attribute pairs. They won't be sent to devices as a part of the Job document.
        public var attributes: [Swift.String: Swift.String]?
        /// The code signing method of the file.
        public var codeSigning: IoTClientTypes.CodeSigning?
        /// The location of the updated firmware.
        public var fileLocation: IoTClientTypes.FileLocation?
        /// The name of the file.
        public var fileName: Swift.String?
        /// An integer value you can include in the job document to allow your devices to identify the type of file received from the cloud.
        public var fileType: Swift.Int?
        /// The file version.
        public var fileVersion: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            codeSigning: IoTClientTypes.CodeSigning? = nil,
            fileLocation: IoTClientTypes.FileLocation? = nil,
            fileName: Swift.String? = nil,
            fileType: Swift.Int? = nil,
            fileVersion: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.codeSigning = codeSigning
            self.fileLocation = fileLocation
            self.fileName = fileName
            self.fileType = fileType
            self.fileVersion = fileVersion
        }
    }

}

extension IoTClientTypes {

    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http
        case mqtt
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .http,
                .mqtt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .mqtt: return "MQTT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateOTAUpdateInput {
    /// A list of additional OTA update parameters, which are name-value pairs. They won't be sent to devices as a part of the Job document.
    public var additionalParameters: [Swift.String: Swift.String]?
    /// The criteria that determine when and how a job abort takes place.
    public var awsJobAbortConfig: IoTClientTypes.AwsJobAbortConfig?
    /// Configuration for the rollout of OTA updates.
    public var awsJobExecutionsRolloutConfig: IoTClientTypes.AwsJobExecutionsRolloutConfig?
    /// Configuration information for pre-signed URLs.
    public var awsJobPresignedUrlConfig: IoTClientTypes.AwsJobPresignedUrlConfig?
    /// Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to TIMED_OUT.
    public var awsJobTimeoutConfig: IoTClientTypes.AwsJobTimeoutConfig?
    /// The description of the OTA update.
    public var description: Swift.String?
    /// The files to be streamed by the OTA update.
    /// This member is required.
    public var files: [IoTClientTypes.OTAUpdateFile]?
    /// The ID of the OTA update to be created.
    /// This member is required.
    public var otaUpdateId: Swift.String?
    /// The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.
    public var protocols: [IoTClientTypes.ModelProtocol]?
    /// The IAM role that grants Amazon Web Services IoT Core access to the Amazon S3, IoT jobs and Amazon Web Services Code Signing resources to create an OTA update job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Metadata which can be used to manage updates.
    public var tags: [IoTClientTypes.Tag]?
    /// Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.
    public var targetSelection: IoTClientTypes.TargetSelection?
    /// The devices targeted to receive OTA updates.
    /// This member is required.
    public var targets: [Swift.String]?

    public init(
        additionalParameters: [Swift.String: Swift.String]? = nil,
        awsJobAbortConfig: IoTClientTypes.AwsJobAbortConfig? = nil,
        awsJobExecutionsRolloutConfig: IoTClientTypes.AwsJobExecutionsRolloutConfig? = nil,
        awsJobPresignedUrlConfig: IoTClientTypes.AwsJobPresignedUrlConfig? = nil,
        awsJobTimeoutConfig: IoTClientTypes.AwsJobTimeoutConfig? = nil,
        description: Swift.String? = nil,
        files: [IoTClientTypes.OTAUpdateFile]? = nil,
        otaUpdateId: Swift.String? = nil,
        protocols: [IoTClientTypes.ModelProtocol]? = nil,
        roleArn: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        targetSelection: IoTClientTypes.TargetSelection? = nil,
        targets: [Swift.String]? = nil
    )
    {
        self.additionalParameters = additionalParameters
        self.awsJobAbortConfig = awsJobAbortConfig
        self.awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfig
        self.awsJobPresignedUrlConfig = awsJobPresignedUrlConfig
        self.awsJobTimeoutConfig = awsJobTimeoutConfig
        self.description = description
        self.files = files
        self.otaUpdateId = otaUpdateId
        self.protocols = protocols
        self.roleArn = roleArn
        self.tags = tags
        self.targetSelection = targetSelection
        self.targets = targets
    }
}

extension IoTClientTypes {

    public enum OTAUpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createComplete
        case createFailed
        case createInProgress
        case createPending
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [OTAUpdateStatus] {
            return [
                .createComplete,
                .createFailed,
                .createInProgress,
                .createPending,
                .deleteFailed,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createPending: return "CREATE_PENDING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateOTAUpdateOutput {
    /// The IoT job ARN associated with the OTA update.
    public var awsIotJobArn: Swift.String?
    /// The IoT job ID associated with the OTA update.
    public var awsIotJobId: Swift.String?
    /// The OTA update ARN.
    public var otaUpdateArn: Swift.String?
    /// The OTA update ID.
    public var otaUpdateId: Swift.String?
    /// The OTA update status.
    public var otaUpdateStatus: IoTClientTypes.OTAUpdateStatus?

    public init(
        awsIotJobArn: Swift.String? = nil,
        awsIotJobId: Swift.String? = nil,
        otaUpdateArn: Swift.String? = nil,
        otaUpdateId: Swift.String? = nil,
        otaUpdateStatus: IoTClientTypes.OTAUpdateStatus? = nil
    )
    {
        self.awsIotJobArn = awsIotJobArn
        self.awsIotJobId = awsIotJobId
        self.otaUpdateArn = otaUpdateArn
        self.otaUpdateId = otaUpdateId
        self.otaUpdateStatus = otaUpdateStatus
    }
}

public struct CreatePackageInput {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A summary of the package being created. This can be used to outline the package's contents or purpose.
    public var description: Swift.String?
    /// The name of the new software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// Metadata that can be used to manage the package.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        packageName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.packageName = packageName
        self.tags = tags
    }
}

extension CreatePackageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePackageInput(clientToken: \(Swift.String(describing: clientToken)), packageName: \(Swift.String(describing: packageName)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

public struct CreatePackageOutput {
    /// The package description.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) for the package.
    public var packageArn: Swift.String?
    /// The name of the software package.
    public var packageName: Swift.String?

    public init(
        description: Swift.String? = nil,
        packageArn: Swift.String? = nil,
        packageName: Swift.String? = nil
    )
    {
        self.description = description
        self.packageArn = packageArn
        self.packageName = packageName
    }
}

extension CreatePackageOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePackageOutput(packageArn: \(Swift.String(describing: packageArn)), packageName: \(Swift.String(describing: packageName)), description: \"CONTENT_REDACTED\")"}
}

extension IoTClientTypes {
    /// The Amazon S3 location for the artifacts associated with a software package version.
    public struct PackageVersionArtifact {
        /// The S3 location.
        public var s3Location: IoTClientTypes.S3Location?

        public init(
            s3Location: IoTClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

public struct CreatePackageVersionInput {
    /// The various build components created during the build process such as libraries and configuration files that make up a software package version.
    public var artifact: IoTClientTypes.PackageVersionArtifact?
    /// Metadata that can be used to define a package version’s configuration. For example, the S3 file location, configuration options that are being sent to the device or fleet. The combined size of all the attributes on a package version is limited to 3KB.
    public var attributes: [Swift.String: Swift.String]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A summary of the package version being created. This can be used to outline the package's contents or purpose.
    public var description: Swift.String?
    /// The name of the associated software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The inline job document associated with a software package version used for a quick job deployment via IoT Jobs.
    public var recipe: Swift.String?
    /// Metadata that can be used to manage the package version.
    public var tags: [Swift.String: Swift.String]?
    /// The name of the new package version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        artifact: IoTClientTypes.PackageVersionArtifact? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        packageName: Swift.String? = nil,
        recipe: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.artifact = artifact
        self.attributes = attributes
        self.clientToken = clientToken
        self.description = description
        self.packageName = packageName
        self.recipe = recipe
        self.tags = tags
        self.versionName = versionName
    }
}

extension CreatePackageVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePackageVersionInput(artifact: \(Swift.String(describing: artifact)), clientToken: \(Swift.String(describing: clientToken)), packageName: \(Swift.String(describing: packageName)), tags: \(Swift.String(describing: tags)), versionName: \(Swift.String(describing: versionName)), attributes: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", recipe: \"CONTENT_REDACTED\")"}
}

extension IoTClientTypes {

    public enum PackageVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deprecated
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionStatus] {
            return [
                .deprecated,
                .draft,
                .published
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deprecated: return "DEPRECATED"
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreatePackageVersionOutput {
    /// Metadata that were added to the package version that can be used to define a package version’s configuration.
    public var attributes: [Swift.String: Swift.String]?
    /// The package version description.
    public var description: Swift.String?
    /// Error reason for a package version failure during creation or update.
    public var errorReason: Swift.String?
    /// The name of the associated software package.
    public var packageName: Swift.String?
    /// The Amazon Resource Name (ARN) for the package.
    public var packageVersionArn: Swift.String?
    /// The status of the package version. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle).
    public var status: IoTClientTypes.PackageVersionStatus?
    /// The name of the new package version.
    public var versionName: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        description: Swift.String? = nil,
        errorReason: Swift.String? = nil,
        packageName: Swift.String? = nil,
        packageVersionArn: Swift.String? = nil,
        status: IoTClientTypes.PackageVersionStatus? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.description = description
        self.errorReason = errorReason
        self.packageName = packageName
        self.packageVersionArn = packageVersionArn
        self.status = status
        self.versionName = versionName
    }
}

extension CreatePackageVersionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePackageVersionOutput(errorReason: \(Swift.String(describing: errorReason)), packageName: \(Swift.String(describing: packageName)), packageVersionArn: \(Swift.String(describing: packageVersionArn)), status: \(Swift.String(describing: status)), versionName: \(Swift.String(describing: versionName)), attributes: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

/// The policy documentation is not valid.
public struct MalformedPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedPolicyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input for the CreatePolicy operation.
public struct CreatePolicyInput {
    /// The JSON document that describes the policy. policyDocument must have a minimum length of 1, with a maximum length of 2048, excluding whitespace.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?
    /// Metadata which can be used to manage the policy. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: [IoTClientTypes.Tag]?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.tags = tags
    }
}

/// The output from the CreatePolicy operation.
public struct CreatePolicyOutput {
    /// The policy ARN.
    public var policyArn: Swift.String?
    /// The JSON document that describes the policy.
    public var policyDocument: Swift.String?
    /// The policy name.
    public var policyName: Swift.String?
    /// The policy version ID.
    public var policyVersionId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        policyVersionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

/// The number of policy versions exceeds the limit.
public struct VersionsLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "VersionsLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input for the CreatePolicyVersion operation.
public struct CreatePolicyVersionInput {
    /// The JSON document that describes the policy. Minimum length of 1. Maximum length of 2048, excluding whitespace.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?
    /// Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
    public var setAsDefault: Swift.Bool?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        setAsDefault: Swift.Bool? = false
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.setAsDefault = setAsDefault
    }
}

/// The output of the CreatePolicyVersion operation.
public struct CreatePolicyVersionOutput {
    /// Specifies whether the policy version is the default.
    public var isDefaultVersion: Swift.Bool
    /// The policy ARN.
    public var policyArn: Swift.String?
    /// The JSON document that describes the policy.
    public var policyDocument: Swift.String?
    /// The policy version ID.
    public var policyVersionId: Swift.String?

    public init(
        isDefaultVersion: Swift.Bool = false,
        policyArn: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyVersionId: Swift.String? = nil
    )
    {
        self.isDefaultVersion = isDefaultVersion
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.policyVersionId = policyVersionId
    }
}

public struct CreateProvisioningClaimInput {
    /// The name of the provisioning template to use.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        templateName: Swift.String? = nil
    )
    {
        self.templateName = templateName
    }
}

public struct CreateProvisioningClaimOutput {
    /// The ID of the certificate.
    public var certificateId: Swift.String?
    /// The provisioning claim certificate.
    public var certificatePem: Swift.String?
    /// The provisioning claim expiration time.
    public var expiration: Foundation.Date?
    /// The provisioning claim key pair.
    public var keyPair: IoTClientTypes.KeyPair?

    public init(
        certificateId: Swift.String? = nil,
        certificatePem: Swift.String? = nil,
        expiration: Foundation.Date? = nil,
        keyPair: IoTClientTypes.KeyPair? = nil
    )
    {
        self.certificateId = certificateId
        self.certificatePem = certificatePem
        self.expiration = expiration
        self.keyPair = keyPair
    }
}

extension IoTClientTypes {
    /// Structure that contains payloadVersion and targetArn.
    public struct ProvisioningHook {
        /// The payload that was sent to the target function. Note: Only Lambda functions are currently supported.
        public var payloadVersion: Swift.String?
        /// The ARN of the target function. Note: Only Lambda functions are currently supported.
        /// This member is required.
        public var targetArn: Swift.String?

        public init(
            payloadVersion: Swift.String? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.payloadVersion = payloadVersion
            self.targetArn = targetArn
        }
    }

}

extension IoTClientTypes {

    public enum TemplateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fleetProvisioning
        case jitp
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateType] {
            return [
                .fleetProvisioning,
                .jitp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fleetProvisioning: return "FLEET_PROVISIONING"
            case .jitp: return "JITP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProvisioningTemplateInput {
    /// The description of the provisioning template.
    public var description: Swift.String?
    /// True to enable the provisioning template, otherwise false.
    public var enabled: Swift.Bool?
    /// Creates a pre-provisioning hook template. Only supports template of type FLEET_PROVISIONING. For more information about provisioning template types, see [type](https://docs.aws.amazon.com/iot/latest/apireference/API_CreateProvisioningTemplate.html#iot-CreateProvisioningTemplate-request-type).
    public var preProvisioningHook: IoTClientTypes.ProvisioningHook?
    /// The role ARN for the role associated with the provisioning template. This IoT role grants permission to provision a device.
    /// This member is required.
    public var provisioningRoleArn: Swift.String?
    /// Metadata which can be used to manage the provisioning template. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: [IoTClientTypes.Tag]?
    /// The JSON formatted contents of the provisioning template.
    /// This member is required.
    public var templateBody: Swift.String?
    /// The name of the provisioning template.
    /// This member is required.
    public var templateName: Swift.String?
    /// The type you define in a provisioning template. You can create a template with only one type. You can't change the template type after its creation. The default value is FLEET_PROVISIONING. For more information about provisioning template, see: [Provisioning template](https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html).
    public var type: IoTClientTypes.TemplateType?

    public init(
        description: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        preProvisioningHook: IoTClientTypes.ProvisioningHook? = nil,
        provisioningRoleArn: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        templateBody: Swift.String? = nil,
        templateName: Swift.String? = nil,
        type: IoTClientTypes.TemplateType? = nil
    )
    {
        self.description = description
        self.enabled = enabled
        self.preProvisioningHook = preProvisioningHook
        self.provisioningRoleArn = provisioningRoleArn
        self.tags = tags
        self.templateBody = templateBody
        self.templateName = templateName
        self.type = type
    }
}

public struct CreateProvisioningTemplateOutput {
    /// The default version of the provisioning template.
    public var defaultVersionId: Swift.Int?
    /// The ARN that identifies the provisioning template.
    public var templateArn: Swift.String?
    /// The name of the provisioning template.
    public var templateName: Swift.String?

    public init(
        defaultVersionId: Swift.Int? = nil,
        templateArn: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.defaultVersionId = defaultVersionId
        self.templateArn = templateArn
        self.templateName = templateName
    }
}

public struct CreateProvisioningTemplateVersionInput {
    /// Sets a fleet provision template version as the default version.
    public var setAsDefault: Swift.Bool?
    /// The JSON formatted contents of the provisioning template.
    /// This member is required.
    public var templateBody: Swift.String?
    /// The name of the provisioning template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        setAsDefault: Swift.Bool? = false,
        templateBody: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.setAsDefault = setAsDefault
        self.templateBody = templateBody
        self.templateName = templateName
    }
}

public struct CreateProvisioningTemplateVersionOutput {
    /// True if the provisioning template version is the default version, otherwise false.
    public var isDefaultVersion: Swift.Bool
    /// The ARN that identifies the provisioning template.
    public var templateArn: Swift.String?
    /// The name of the provisioning template.
    public var templateName: Swift.String?
    /// The version of the provisioning template.
    public var versionId: Swift.Int?

    public init(
        isDefaultVersion: Swift.Bool = false,
        templateArn: Swift.String? = nil,
        templateName: Swift.String? = nil,
        versionId: Swift.Int? = nil
    )
    {
        self.isDefaultVersion = isDefaultVersion
        self.templateArn = templateArn
        self.templateName = templateName
        self.versionId = versionId
    }
}

public struct CreateRoleAliasInput {
    /// How long (in seconds) the credentials will be valid. The default value is 3,600 seconds. This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.
    public var credentialDurationSeconds: Swift.Int?
    /// The role alias that points to a role ARN. This allows you to change the role without having to update the device.
    /// This member is required.
    public var roleAlias: Swift.String?
    /// The role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Metadata which can be used to manage the role alias. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: [IoTClientTypes.Tag]?

    public init(
        credentialDurationSeconds: Swift.Int? = nil,
        roleAlias: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.credentialDurationSeconds = credentialDurationSeconds
        self.roleAlias = roleAlias
        self.roleArn = roleArn
        self.tags = tags
    }
}

public struct CreateRoleAliasOutput {
    /// The role alias.
    public var roleAlias: Swift.String?
    /// The role alias ARN.
    public var roleAliasArn: Swift.String?

    public init(
        roleAlias: Swift.String? = nil,
        roleAliasArn: Swift.String? = nil
    )
    {
        self.roleAlias = roleAlias
        self.roleAliasArn = roleAliasArn
    }
}

extension IoTClientTypes {

    public enum DayOfWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fri
        case mon
        case sat
        case sun
        case thu
        case tue
        case wed
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .fri,
                .mon,
                .sat,
                .sun,
                .thu,
                .tue,
                .wed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fri: return "FRI"
            case .mon: return "MON"
            case .sat: return "SAT"
            case .sun: return "SUN"
            case .thu: return "THU"
            case .tue: return "TUE"
            case .wed: return "WED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateScheduledAuditInput {
    /// The day of the month on which the scheduled audit takes place. This can be "1" through "31" or "LAST". This field is required if the "frequency" parameter is set to MONTHLY. If days 29 to 31 are specified, and the month doesn't have that many days, the audit takes place on the LAST day of the month.
    public var dayOfMonth: Swift.String?
    /// The day of the week on which the scheduled audit takes place, either SUN, MON, TUE, WED, THU, FRI, or SAT. This field is required if the frequency parameter is set to WEEKLY or BIWEEKLY.
    public var dayOfWeek: IoTClientTypes.DayOfWeek?
    /// How often the scheduled audit takes place, either DAILY, WEEKLY, BIWEEKLY or MONTHLY. The start time of each audit is determined by the system.
    /// This member is required.
    public var frequency: IoTClientTypes.AuditFrequency?
    /// The name you want to give to the scheduled audit. (Max. 128 chars)
    /// This member is required.
    public var scheduledAuditName: Swift.String?
    /// Metadata that can be used to manage the scheduled audit.
    public var tags: [IoTClientTypes.Tag]?
    /// Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    /// This member is required.
    public var targetCheckNames: [Swift.String]?

    public init(
        dayOfMonth: Swift.String? = nil,
        dayOfWeek: IoTClientTypes.DayOfWeek? = nil,
        frequency: IoTClientTypes.AuditFrequency? = nil,
        scheduledAuditName: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        targetCheckNames: [Swift.String]? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.frequency = frequency
        self.scheduledAuditName = scheduledAuditName
        self.tags = tags
        self.targetCheckNames = targetCheckNames
    }
}

public struct CreateScheduledAuditOutput {
    /// The ARN of the scheduled audit.
    public var scheduledAuditArn: Swift.String?

    public init(
        scheduledAuditArn: Swift.String? = nil
    )
    {
        self.scheduledAuditArn = scheduledAuditArn
    }
}

extension IoTClientTypes {
    /// Set configurations for metrics export.
    public struct MetricsExportConfig {
        /// The MQTT topic that Device Defender Detect should publish messages to for metrics export.
        /// This member is required.
        public var mqttTopic: Swift.String?
        /// This role ARN has permission to publish MQTT messages, after which Device Defender Detect can assume the role and publish messages on your behalf.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            mqttTopic: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.mqttTopic = mqttTopic
            self.roleArn = roleArn
        }
    }

}

public struct CreateSecurityProfileInput {
    /// Please use [CreateSecurityProfileRequest$additionalMetricsToRetainV2] instead. A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.
    @available(*, deprecated, message: "Use additionalMetricsToRetainV2.")
    public var additionalMetricsToRetain: [Swift.String]?
    /// A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.
    public var additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]?
    /// Specifies the destinations to which alerts are sent. (Alerts are always sent to the console.) Alerts are generated when a device (thing) violates a behavior.
    public var alertTargets: [Swift.String: IoTClientTypes.AlertTarget]?
    /// Specifies the behaviors that, when violated by a device (thing), cause an alert.
    public var behaviors: [IoTClientTypes.Behavior]?
    /// Specifies the MQTT topic and role ARN required for metric export.
    public var metricsExportConfig: IoTClientTypes.MetricsExportConfig?
    /// A description of the security profile.
    public var securityProfileDescription: Swift.String?
    /// The name you are giving to the security profile.
    /// This member is required.
    public var securityProfileName: Swift.String?
    /// Metadata that can be used to manage the security profile.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        additionalMetricsToRetain: [Swift.String]? = nil,
        additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]? = nil,
        alertTargets: [Swift.String: IoTClientTypes.AlertTarget]? = nil,
        behaviors: [IoTClientTypes.Behavior]? = nil,
        metricsExportConfig: IoTClientTypes.MetricsExportConfig? = nil,
        securityProfileDescription: Swift.String? = nil,
        securityProfileName: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.additionalMetricsToRetain = additionalMetricsToRetain
        self.additionalMetricsToRetainV2 = additionalMetricsToRetainV2
        self.alertTargets = alertTargets
        self.behaviors = behaviors
        self.metricsExportConfig = metricsExportConfig
        self.securityProfileDescription = securityProfileDescription
        self.securityProfileName = securityProfileName
        self.tags = tags
    }
}

public struct CreateSecurityProfileOutput {
    /// The ARN of the security profile.
    public var securityProfileArn: Swift.String?
    /// The name you gave to the security profile.
    public var securityProfileName: Swift.String?

    public init(
        securityProfileArn: Swift.String? = nil,
        securityProfileName: Swift.String? = nil
    )
    {
        self.securityProfileArn = securityProfileArn
        self.securityProfileName = securityProfileName
    }
}

extension IoTClientTypes {
    /// Represents a file to stream.
    public struct StreamFile {
        /// The file ID.
        public var fileId: Swift.Int?
        /// The location of the file in S3.
        public var s3Location: IoTClientTypes.S3Location?

        public init(
            fileId: Swift.Int? = nil,
            s3Location: IoTClientTypes.S3Location? = nil
        )
        {
            self.fileId = fileId
            self.s3Location = s3Location
        }
    }

}

public struct CreateStreamInput {
    /// A description of the stream.
    public var description: Swift.String?
    /// The files to stream.
    /// This member is required.
    public var files: [IoTClientTypes.StreamFile]?
    /// An IAM role that allows the IoT service principal to access your S3 files.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The stream ID.
    /// This member is required.
    public var streamId: Swift.String?
    /// Metadata which can be used to manage streams.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        files: [IoTClientTypes.StreamFile]? = nil,
        roleArn: Swift.String? = nil,
        streamId: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.files = files
        self.roleArn = roleArn
        self.streamId = streamId
        self.tags = tags
    }
}

public struct CreateStreamOutput {
    /// A description of the stream.
    public var description: Swift.String?
    /// The stream ARN.
    public var streamArn: Swift.String?
    /// The stream ID.
    public var streamId: Swift.String?
    /// The version of the stream.
    public var streamVersion: Swift.Int?

    public init(
        description: Swift.String? = nil,
        streamArn: Swift.String? = nil,
        streamId: Swift.String? = nil,
        streamVersion: Swift.Int? = nil
    )
    {
        self.description = description
        self.streamArn = streamArn
        self.streamId = streamId
        self.streamVersion = streamVersion
    }
}

/// The input for the CreateThing operation.
public struct CreateThingInput {
    /// The attribute payload, which consists of up to three name/value pairs in a JSON document. For example: {\"attributes\":{\"string1\":\"string2\"}}
    public var attributePayload: IoTClientTypes.AttributePayload?
    /// The name of the billing group the thing will be added to.
    public var billingGroupName: Swift.String?
    /// The name of the thing to create. You can't change a thing's name after you create it. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.
    /// This member is required.
    public var thingName: Swift.String?
    /// The name of the thing type associated with the new thing.
    public var thingTypeName: Swift.String?

    public init(
        attributePayload: IoTClientTypes.AttributePayload? = nil,
        billingGroupName: Swift.String? = nil,
        thingName: Swift.String? = nil,
        thingTypeName: Swift.String? = nil
    )
    {
        self.attributePayload = attributePayload
        self.billingGroupName = billingGroupName
        self.thingName = thingName
        self.thingTypeName = thingTypeName
    }
}

/// The output of the CreateThing operation.
public struct CreateThingOutput {
    /// The ARN of the new thing.
    public var thingArn: Swift.String?
    /// The thing ID.
    public var thingId: Swift.String?
    /// The name of the new thing.
    public var thingName: Swift.String?

    public init(
        thingArn: Swift.String? = nil,
        thingId: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.thingArn = thingArn
        self.thingId = thingId
        self.thingName = thingName
    }
}

public struct CreateThingGroupInput {
    /// The name of the parent thing group.
    public var parentGroupName: Swift.String?
    /// Metadata which can be used to manage the thing group.
    public var tags: [IoTClientTypes.Tag]?
    /// The thing group name to create.
    /// This member is required.
    public var thingGroupName: Swift.String?
    /// The thing group properties.
    public var thingGroupProperties: IoTClientTypes.ThingGroupProperties?

    public init(
        parentGroupName: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        thingGroupName: Swift.String? = nil,
        thingGroupProperties: IoTClientTypes.ThingGroupProperties? = nil
    )
    {
        self.parentGroupName = parentGroupName
        self.tags = tags
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
    }
}

public struct CreateThingGroupOutput {
    /// The thing group ARN.
    public var thingGroupArn: Swift.String?
    /// The thing group ID.
    public var thingGroupId: Swift.String?
    /// The thing group name.
    public var thingGroupName: Swift.String?

    public init(
        thingGroupArn: Swift.String? = nil,
        thingGroupId: Swift.String? = nil,
        thingGroupName: Swift.String? = nil
    )
    {
        self.thingGroupArn = thingGroupArn
        self.thingGroupId = thingGroupId
        self.thingGroupName = thingGroupName
    }
}

extension IoTClientTypes {
    /// The ThingTypeProperties contains information about the thing type including: a thing type description, and a list of searchable thing attribute names.
    public struct ThingTypeProperties {
        /// A list of searchable thing attribute names.
        public var searchableAttributes: [Swift.String]?
        /// The description of the thing type.
        public var thingTypeDescription: Swift.String?

        public init(
            searchableAttributes: [Swift.String]? = nil,
            thingTypeDescription: Swift.String? = nil
        )
        {
            self.searchableAttributes = searchableAttributes
            self.thingTypeDescription = thingTypeDescription
        }
    }

}

/// The input for the CreateThingType operation.
public struct CreateThingTypeInput {
    /// Metadata which can be used to manage the thing type.
    public var tags: [IoTClientTypes.Tag]?
    /// The name of the thing type.
    /// This member is required.
    public var thingTypeName: Swift.String?
    /// The ThingTypeProperties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names.
    public var thingTypeProperties: IoTClientTypes.ThingTypeProperties?

    public init(
        tags: [IoTClientTypes.Tag]? = nil,
        thingTypeName: Swift.String? = nil,
        thingTypeProperties: IoTClientTypes.ThingTypeProperties? = nil
    )
    {
        self.tags = tags
        self.thingTypeName = thingTypeName
        self.thingTypeProperties = thingTypeProperties
    }
}

/// The output of the CreateThingType operation.
public struct CreateThingTypeOutput {
    /// The Amazon Resource Name (ARN) of the thing type.
    public var thingTypeArn: Swift.String?
    /// The thing type ID.
    public var thingTypeId: Swift.String?
    /// The name of the thing type.
    public var thingTypeName: Swift.String?

    public init(
        thingTypeArn: Swift.String? = nil,
        thingTypeId: Swift.String? = nil,
        thingTypeName: Swift.String? = nil
    )
    {
        self.thingTypeArn = thingTypeArn
        self.thingTypeId = thingTypeId
        self.thingTypeName = thingTypeName
    }
}

/// The Rule-SQL expression can't be parsed correctly.
public struct SqlParseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SqlParseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTClientTypes {
    /// Describes a rule.
    public struct TopicRulePayload {
        /// The actions associated with the rule.
        /// This member is required.
        public var actions: [IoTClientTypes.Action]?
        /// The version of the SQL rules engine to use when evaluating the rule.
        public var awsIotSqlVersion: Swift.String?
        /// The description of the rule.
        public var description: Swift.String?
        /// The action to take when an error occurs.
        public var errorAction: IoTClientTypes.Action?
        /// Specifies whether the rule is disabled.
        public var ruleDisabled: Swift.Bool?
        /// The SQL statement used to query the topic. For more information, see [IoT SQL Reference](https://docs.aws.amazon.com/iot/latest/developerguide/iot-sql-reference.html) in the IoT Developer Guide.
        /// This member is required.
        public var sql: Swift.String?

        public init(
            actions: [IoTClientTypes.Action]? = nil,
            awsIotSqlVersion: Swift.String? = nil,
            description: Swift.String? = nil,
            errorAction: IoTClientTypes.Action? = nil,
            ruleDisabled: Swift.Bool? = nil,
            sql: Swift.String? = nil
        )
        {
            self.actions = actions
            self.awsIotSqlVersion = awsIotSqlVersion
            self.description = description
            self.errorAction = errorAction
            self.ruleDisabled = ruleDisabled
            self.sql = sql
        }
    }

}

/// The input for the CreateTopicRule operation.
public struct CreateTopicRuleInput {
    /// The name of the rule.
    /// This member is required.
    public var ruleName: Swift.String?
    /// Metadata which can be used to manage the topic rule. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: --tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: Swift.String?
    /// The rule payload.
    /// This member is required.
    public var topicRulePayload: IoTClientTypes.TopicRulePayload?

    public init(
        ruleName: Swift.String? = nil,
        tags: Swift.String? = nil,
        topicRulePayload: IoTClientTypes.TopicRulePayload? = nil
    )
    {
        self.ruleName = ruleName
        self.tags = tags
        self.topicRulePayload = topicRulePayload
    }
}

extension IoTClientTypes {
    /// HTTP URL destination configuration used by the topic rule's HTTP action.
    public struct HttpUrlDestinationConfiguration {
        /// The URL IoT uses to confirm ownership of or access to the topic rule destination URL.
        /// This member is required.
        public var confirmationUrl: Swift.String?

        public init(
            confirmationUrl: Swift.String? = nil
        )
        {
            self.confirmationUrl = confirmationUrl
        }
    }

}

extension IoTClientTypes {
    /// The configuration information for a virtual private cloud (VPC) destination.
    public struct VpcDestinationConfiguration {
        /// The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The security groups of the VPC destination.
        public var securityGroups: [Swift.String]?
        /// The subnet IDs of the VPC destination.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.securityGroups = securityGroups
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension IoTClientTypes {
    /// Configuration of the topic rule destination.
    public struct TopicRuleDestinationConfiguration {
        /// Configuration of the HTTP URL.
        public var httpUrlConfiguration: IoTClientTypes.HttpUrlDestinationConfiguration?
        /// Configuration of the virtual private cloud (VPC) connection.
        public var vpcConfiguration: IoTClientTypes.VpcDestinationConfiguration?

        public init(
            httpUrlConfiguration: IoTClientTypes.HttpUrlDestinationConfiguration? = nil,
            vpcConfiguration: IoTClientTypes.VpcDestinationConfiguration? = nil
        )
        {
            self.httpUrlConfiguration = httpUrlConfiguration
            self.vpcConfiguration = vpcConfiguration
        }
    }

}

public struct CreateTopicRuleDestinationInput {
    /// The topic rule destination configuration.
    /// This member is required.
    public var destinationConfiguration: IoTClientTypes.TopicRuleDestinationConfiguration?

    public init(
        destinationConfiguration: IoTClientTypes.TopicRuleDestinationConfiguration? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
    }
}

extension IoTClientTypes {
    /// HTTP URL destination properties.
    public struct HttpUrlDestinationProperties {
        /// The URL used to confirm the HTTP topic rule destination URL.
        public var confirmationUrl: Swift.String?

        public init(
            confirmationUrl: Swift.String? = nil
        )
        {
            self.confirmationUrl = confirmationUrl
        }
    }

}

extension IoTClientTypes {

    public enum TopicRuleDestinationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case disabled
        case enabled
        case error
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TopicRuleDestinationStatus] {
            return [
                .deleting,
                .disabled,
                .enabled,
                .error,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The properties of a virtual private cloud (VPC) destination.
    public struct VpcDestinationProperties {
        /// The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
        public var roleArn: Swift.String?
        /// The security groups of the VPC destination.
        public var securityGroups: [Swift.String]?
        /// The subnet IDs of the VPC destination.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.securityGroups = securityGroups
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension IoTClientTypes {
    /// A topic rule destination.
    public struct TopicRuleDestination {
        /// The topic rule destination URL.
        public var arn: Swift.String?
        /// The date and time when the topic rule destination was created.
        public var createdAt: Foundation.Date?
        /// Properties of the HTTP URL.
        public var httpUrlProperties: IoTClientTypes.HttpUrlDestinationProperties?
        /// The date and time when the topic rule destination was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The status of the topic rule destination. Valid values are: IN_PROGRESS A topic rule destination was created but has not been confirmed. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint. ENABLED Confirmation was completed, and traffic to this destination is allowed. You can set status to DISABLED by calling UpdateTopicRuleDestination. DISABLED Confirmation was completed, and traffic to this destination is not allowed. You can set status to ENABLED by calling UpdateTopicRuleDestination. ERROR Confirmation could not be completed, for example if the confirmation timed out. You can call GetTopicRuleDestination for details about the error. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint.
        public var status: IoTClientTypes.TopicRuleDestinationStatus?
        /// Additional details or reason why the topic rule destination is in the current status.
        public var statusReason: Swift.String?
        /// Properties of the virtual private cloud (VPC) connection.
        public var vpcProperties: IoTClientTypes.VpcDestinationProperties?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            httpUrlProperties: IoTClientTypes.HttpUrlDestinationProperties? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            status: IoTClientTypes.TopicRuleDestinationStatus? = nil,
            statusReason: Swift.String? = nil,
            vpcProperties: IoTClientTypes.VpcDestinationProperties? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.httpUrlProperties = httpUrlProperties
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.statusReason = statusReason
            self.vpcProperties = vpcProperties
        }
    }

}

public struct CreateTopicRuleDestinationOutput {
    /// The topic rule destination.
    public var topicRuleDestination: IoTClientTypes.TopicRuleDestination?

    public init(
        topicRuleDestination: IoTClientTypes.TopicRuleDestination? = nil
    )
    {
        self.topicRuleDestination = topicRuleDestination
    }
}

public struct DeleteAccountAuditConfigurationInput {
    /// If true, all scheduled audits are deleted.
    public var deleteScheduledAudits: Swift.Bool?

    public init(
        deleteScheduledAudits: Swift.Bool? = false
    )
    {
        self.deleteScheduledAudits = deleteScheduledAudits
    }
}

public struct DeleteAccountAuditConfigurationOutput {

    public init() { }
}

public struct DeleteAuditSuppressionInput {
    /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    /// This member is required.
    public var checkName: Swift.String?
    /// Information that identifies the noncompliant resource.
    /// This member is required.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?

    public init(
        checkName: Swift.String? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil
    )
    {
        self.checkName = checkName
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct DeleteAuditSuppressionOutput {

    public init() { }
}

/// You can't delete the resource because it is attached to one or more resources.
public struct DeleteConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeleteConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteAuthorizerInput {
    /// The name of the authorizer to delete.
    /// This member is required.
    public var authorizerName: Swift.String?

    public init(
        authorizerName: Swift.String? = nil
    )
    {
        self.authorizerName = authorizerName
    }
}

public struct DeleteAuthorizerOutput {

    public init() { }
}

public struct DeleteBillingGroupInput {
    /// The name of the billing group.
    /// This member is required.
    public var billingGroupName: Swift.String?
    /// The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the DeleteBillingGroup request is rejected with a VersionConflictException.
    public var expectedVersion: Swift.Int?

    public init(
        billingGroupName: Swift.String? = nil,
        expectedVersion: Swift.Int? = nil
    )
    {
        self.billingGroupName = billingGroupName
        self.expectedVersion = expectedVersion
    }
}

public struct DeleteBillingGroupOutput {

    public init() { }
}

/// The certificate operation is not allowed.
public struct CertificateStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CertificateStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Input for the DeleteCACertificate operation.
public struct DeleteCACertificateInput {
    /// The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

/// The output for the DeleteCACertificate operation.
public struct DeleteCACertificateOutput {

    public init() { }
}

/// The input for the DeleteCertificate operation.
public struct DeleteCertificateInput {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?
    /// Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
    public var forceDelete: Swift.Bool?

    public init(
        certificateId: Swift.String? = nil,
        forceDelete: Swift.Bool? = false
    )
    {
        self.certificateId = certificateId
        self.forceDelete = forceDelete
    }
}

public struct DeleteCertificateProviderInput {
    /// The name of the certificate provider.
    /// This member is required.
    public var certificateProviderName: Swift.String?

    public init(
        certificateProviderName: Swift.String? = nil
    )
    {
        self.certificateProviderName = certificateProviderName
    }
}

public struct DeleteCertificateProviderOutput {

    public init() { }
}

public struct DeleteCustomMetricInput {
    /// The name of the custom metric.
    /// This member is required.
    public var metricName: Swift.String?

    public init(
        metricName: Swift.String? = nil
    )
    {
        self.metricName = metricName
    }
}

public struct DeleteCustomMetricOutput {

    public init() { }
}

public struct DeleteDimensionInput {
    /// The unique identifier for the dimension that you want to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteDimensionOutput {

    public init() { }
}

public struct DeleteDomainConfigurationInput {
    /// The name of the domain configuration to be deleted.
    /// This member is required.
    public var domainConfigurationName: Swift.String?

    public init(
        domainConfigurationName: Swift.String? = nil
    )
    {
        self.domainConfigurationName = domainConfigurationName
    }
}

public struct DeleteDomainConfigurationOutput {

    public init() { }
}

public struct DeleteDynamicThingGroupInput {
    /// The expected version of the dynamic thing group to delete.
    public var expectedVersion: Swift.Int?
    /// The name of the dynamic thing group to delete.
    /// This member is required.
    public var thingGroupName: Swift.String?

    public init(
        expectedVersion: Swift.Int? = nil,
        thingGroupName: Swift.String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.thingGroupName = thingGroupName
    }
}

public struct DeleteDynamicThingGroupOutput {

    public init() { }
}

public struct DeleteFleetMetricInput {
    /// The expected version of the fleet metric to delete.
    public var expectedVersion: Swift.Int?
    /// The name of the fleet metric to delete.
    /// This member is required.
    public var metricName: Swift.String?

    public init(
        expectedVersion: Swift.Int? = nil,
        metricName: Swift.String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.metricName = metricName
    }
}

public struct DeleteJobInput {
    /// (Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false. Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.
    public var force: Swift.Bool?
    /// The ID of the job to be deleted. After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see [Setting up IoT Greengrass core devices.](https://docs.aws.amazon.com/greengrass/v2/developerguide/setting-up.html)
    public var namespaceId: Swift.String?

    public init(
        force: Swift.Bool? = false,
        jobId: Swift.String? = nil,
        namespaceId: Swift.String? = nil
    )
    {
        self.force = force
        self.jobId = jobId
        self.namespaceId = namespaceId
    }
}

public struct DeleteJobExecutionInput {
    /// The ID of the job execution to be deleted. The executionNumber refers to the execution of a particular job on a particular device. Note that once a job execution is deleted, the executionNumber may be reused by IoT, so be sure you get and use the correct value here.
    /// This member is required.
    public var executionNumber: Swift.Int?
    /// (Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false. Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.
    public var force: Swift.Bool?
    /// The ID of the job whose execution on a particular device will be deleted.
    /// This member is required.
    public var jobId: Swift.String?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see [Setting up IoT Greengrass core devices.](https://docs.aws.amazon.com/greengrass/v2/developerguide/setting-up.html)
    public var namespaceId: Swift.String?
    /// The name of the thing whose job execution will be deleted.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        executionNumber: Swift.Int? = nil,
        force: Swift.Bool? = false,
        jobId: Swift.String? = nil,
        namespaceId: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.executionNumber = executionNumber
        self.force = force
        self.jobId = jobId
        self.namespaceId = namespaceId
        self.thingName = thingName
    }
}

public struct DeleteJobTemplateInput {
    /// The unique identifier of the job template to delete.
    /// This member is required.
    public var jobTemplateId: Swift.String?

    public init(
        jobTemplateId: Swift.String? = nil
    )
    {
        self.jobTemplateId = jobTemplateId
    }
}

public struct DeleteMitigationActionInput {
    /// The name of the mitigation action that you want to delete.
    /// This member is required.
    public var actionName: Swift.String?

    public init(
        actionName: Swift.String? = nil
    )
    {
        self.actionName = actionName
    }
}

public struct DeleteMitigationActionOutput {

    public init() { }
}

public struct DeleteOTAUpdateInput {
    /// When true, the stream created by the OTAUpdate process is deleted when the OTA update is deleted. Ignored if the stream specified in the OTAUpdate is supplied by the user.
    public var deleteStream: Swift.Bool?
    /// When true, deletes the IoT job created by the OTAUpdate process even if it is "IN_PROGRESS". Otherwise, if the job is not in a terminal state ("COMPLETED" or "CANCELED") an exception will occur. The default is false.
    public var forceDeleteAWSJob: Swift.Bool?
    /// The ID of the OTA update to delete.
    /// This member is required.
    public var otaUpdateId: Swift.String?

    public init(
        deleteStream: Swift.Bool? = false,
        forceDeleteAWSJob: Swift.Bool? = false,
        otaUpdateId: Swift.String? = nil
    )
    {
        self.deleteStream = deleteStream
        self.forceDeleteAWSJob = forceDeleteAWSJob
        self.otaUpdateId = otaUpdateId
    }
}

public struct DeleteOTAUpdateOutput {

    public init() { }
}

public struct DeletePackageInput {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The name of the target software package.
    /// This member is required.
    public var packageName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        packageName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.packageName = packageName
    }
}

public struct DeletePackageOutput {

    public init() { }
}

public struct DeletePackageVersionInput {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The name of the associated software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The name of the target package version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        packageName: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.packageName = packageName
        self.versionName = versionName
    }
}

public struct DeletePackageVersionOutput {

    public init() { }
}

/// The input for the DeletePolicy operation.
public struct DeletePolicyInput {
    /// The name of the policy to delete.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        policyName: Swift.String? = nil
    )
    {
        self.policyName = policyName
    }
}

/// The input for the DeletePolicyVersion operation.
public struct DeletePolicyVersionInput {
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The policy version ID.
    /// This member is required.
    public var policyVersionId: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        policyVersionId: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

public struct DeleteProvisioningTemplateInput {
    /// The name of the fleet provision template to delete.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        templateName: Swift.String? = nil
    )
    {
        self.templateName = templateName
    }
}

public struct DeleteProvisioningTemplateOutput {

    public init() { }
}

public struct DeleteProvisioningTemplateVersionInput {
    /// The name of the provisioning template version to delete.
    /// This member is required.
    public var templateName: Swift.String?
    /// The provisioning template version ID to delete.
    /// This member is required.
    public var versionId: Swift.Int?

    public init(
        templateName: Swift.String? = nil,
        versionId: Swift.Int? = nil
    )
    {
        self.templateName = templateName
        self.versionId = versionId
    }
}

public struct DeleteProvisioningTemplateVersionOutput {

    public init() { }
}

/// The input for the DeleteRegistrationCode operation.
public struct DeleteRegistrationCodeInput {

    public init() { }
}

/// The output for the DeleteRegistrationCode operation.
public struct DeleteRegistrationCodeOutput {

    public init() { }
}

public struct DeleteRoleAliasInput {
    /// The role alias to delete.
    /// This member is required.
    public var roleAlias: Swift.String?

    public init(
        roleAlias: Swift.String? = nil
    )
    {
        self.roleAlias = roleAlias
    }
}

public struct DeleteRoleAliasOutput {

    public init() { }
}

public struct DeleteScheduledAuditInput {
    /// The name of the scheduled audit you want to delete.
    /// This member is required.
    public var scheduledAuditName: Swift.String?

    public init(
        scheduledAuditName: Swift.String? = nil
    )
    {
        self.scheduledAuditName = scheduledAuditName
    }
}

public struct DeleteScheduledAuditOutput {

    public init() { }
}

public struct DeleteSecurityProfileInput {
    /// The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a VersionConflictException is thrown.
    public var expectedVersion: Swift.Int?
    /// The name of the security profile to be deleted.
    /// This member is required.
    public var securityProfileName: Swift.String?

    public init(
        expectedVersion: Swift.Int? = nil,
        securityProfileName: Swift.String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.securityProfileName = securityProfileName
    }
}

public struct DeleteSecurityProfileOutput {

    public init() { }
}

public struct DeleteStreamInput {
    /// The stream ID.
    /// This member is required.
    public var streamId: Swift.String?

    public init(
        streamId: Swift.String? = nil
    )
    {
        self.streamId = streamId
    }
}

public struct DeleteStreamOutput {

    public init() { }
}

/// The input for the DeleteThing operation.
public struct DeleteThingInput {
    /// The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the DeleteThing request is rejected with a VersionConflictException.
    public var expectedVersion: Swift.Int?
    /// The name of the thing to delete.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        expectedVersion: Swift.Int? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.thingName = thingName
    }
}

/// The output of the DeleteThing operation.
public struct DeleteThingOutput {

    public init() { }
}

public struct DeleteThingGroupInput {
    /// The expected version of the thing group to delete.
    public var expectedVersion: Swift.Int?
    /// The name of the thing group to delete.
    /// This member is required.
    public var thingGroupName: Swift.String?

    public init(
        expectedVersion: Swift.Int? = nil,
        thingGroupName: Swift.String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.thingGroupName = thingGroupName
    }
}

public struct DeleteThingGroupOutput {

    public init() { }
}

/// The input for the DeleteThingType operation.
public struct DeleteThingTypeInput {
    /// The name of the thing type.
    /// This member is required.
    public var thingTypeName: Swift.String?

    public init(
        thingTypeName: Swift.String? = nil
    )
    {
        self.thingTypeName = thingTypeName
    }
}

/// The output for the DeleteThingType operation.
public struct DeleteThingTypeOutput {

    public init() { }
}

/// The input for the DeleteTopicRule operation.
public struct DeleteTopicRuleInput {
    /// The name of the rule.
    /// This member is required.
    public var ruleName: Swift.String?

    public init(
        ruleName: Swift.String? = nil
    )
    {
        self.ruleName = ruleName
    }
}

public struct DeleteTopicRuleDestinationInput {
    /// The ARN of the topic rule destination to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteTopicRuleDestinationOutput {

    public init() { }
}

extension IoTClientTypes {

    public enum LogTargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case clientId
        case `default`
        case principalId
        case sourceIp
        case thingGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [LogTargetType] {
            return [
                .clientId,
                .default,
                .principalId,
                .sourceIp,
                .thingGroup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .clientId: return "CLIENT_ID"
            case .default: return "DEFAULT"
            case .principalId: return "PRINCIPAL_ID"
            case .sourceIp: return "SOURCE_IP"
            case .thingGroup: return "THING_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteV2LoggingLevelInput {
    /// The name of the resource for which you are configuring logging.
    /// This member is required.
    public var targetName: Swift.String?
    /// The type of resource for which you are configuring logging. Must be THING_Group.
    /// This member is required.
    public var targetType: IoTClientTypes.LogTargetType?

    public init(
        targetName: Swift.String? = nil,
        targetType: IoTClientTypes.LogTargetType? = nil
    )
    {
        self.targetName = targetName
        self.targetType = targetType
    }
}

/// The input for the DeprecateThingType operation.
public struct DeprecateThingTypeInput {
    /// The name of the thing type to deprecate.
    /// This member is required.
    public var thingTypeName: Swift.String?
    /// Whether to undeprecate a deprecated thing type. If true, the thing type will not be deprecated anymore and you can associate it with things.
    public var undoDeprecate: Swift.Bool?

    public init(
        thingTypeName: Swift.String? = nil,
        undoDeprecate: Swift.Bool? = false
    )
    {
        self.thingTypeName = thingTypeName
        self.undoDeprecate = undoDeprecate
    }
}

/// The output for the DeprecateThingType operation.
public struct DeprecateThingTypeOutput {

    public init() { }
}

public struct DescribeAccountAuditConfigurationInput {

    public init() { }
}

public struct DescribeAccountAuditConfigurationOutput {
    /// Which audit checks are enabled and disabled for this account.
    public var auditCheckConfigurations: [Swift.String: IoTClientTypes.AuditCheckConfiguration]?
    /// Information about the targets to which audit notifications are sent for this account.
    public var auditNotificationTargetConfigurations: [Swift.String: IoTClientTypes.AuditNotificationTarget]?
    /// The ARN of the role that grants permission to IoT to access information about your devices, policies, certificates, and other items as required when performing an audit. On the first call to UpdateAccountAuditConfiguration, this parameter is required.
    public var roleArn: Swift.String?

    public init(
        auditCheckConfigurations: [Swift.String: IoTClientTypes.AuditCheckConfiguration]? = nil,
        auditNotificationTargetConfigurations: [Swift.String: IoTClientTypes.AuditNotificationTarget]? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.auditCheckConfigurations = auditCheckConfigurations
        self.auditNotificationTargetConfigurations = auditNotificationTargetConfigurations
        self.roleArn = roleArn
    }
}

public struct DescribeAuditFindingInput {
    /// A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
    /// This member is required.
    public var findingId: Swift.String?

    public init(
        findingId: Swift.String? = nil
    )
    {
        self.findingId = findingId
    }
}

public struct DescribeAuditFindingOutput {
    /// The findings (results) of the audit.
    public var finding: IoTClientTypes.AuditFinding?

    public init(
        finding: IoTClientTypes.AuditFinding? = nil
    )
    {
        self.finding = finding
    }
}

public struct DescribeAuditMitigationActionsTaskInput {
    /// The unique identifier for the audit mitigation task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

extension IoTClientTypes {
    /// Describes which changes should be applied as part of a mitigation action.
    public struct MitigationAction {
        /// The set of parameters for this mitigation action. The parameters vary, depending on the kind of action you apply.
        public var actionParams: IoTClientTypes.MitigationActionParams?
        /// A unique identifier for the mitigation action.
        public var id: Swift.String?
        /// A user-friendly name for the mitigation action.
        public var name: Swift.String?
        /// The IAM role ARN used to apply this mitigation action.
        public var roleArn: Swift.String?

        public init(
            actionParams: IoTClientTypes.MitigationActionParams? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.actionParams = actionParams
            self.id = id
            self.name = name
            self.roleArn = roleArn
        }
    }

}

public struct DescribeAuditMitigationActionsTaskOutput {
    /// Specifies the mitigation actions and their parameters that are applied as part of this task.
    public var actionsDefinition: [IoTClientTypes.MitigationAction]?
    /// Specifies the mitigation actions that should be applied to specific audit checks.
    public var auditCheckToActionsMapping: [Swift.String: [Swift.String]]?
    /// The date and time when the task was completed or canceled.
    public var endTime: Foundation.Date?
    /// The date and time when the task was started.
    public var startTime: Foundation.Date?
    /// Identifies the findings to which the mitigation actions are applied. This can be by audit checks, by audit task, or a set of findings.
    public var target: IoTClientTypes.AuditMitigationActionsTaskTarget?
    /// Aggregate counts of the results when the mitigation tasks were applied to the findings for this audit mitigation actions task.
    public var taskStatistics: [Swift.String: IoTClientTypes.TaskStatisticsForAuditCheck]?
    /// The current status of the task.
    public var taskStatus: IoTClientTypes.AuditMitigationActionsTaskStatus?

    public init(
        actionsDefinition: [IoTClientTypes.MitigationAction]? = nil,
        auditCheckToActionsMapping: [Swift.String: [Swift.String]]? = nil,
        endTime: Foundation.Date? = nil,
        startTime: Foundation.Date? = nil,
        target: IoTClientTypes.AuditMitigationActionsTaskTarget? = nil,
        taskStatistics: [Swift.String: IoTClientTypes.TaskStatisticsForAuditCheck]? = nil,
        taskStatus: IoTClientTypes.AuditMitigationActionsTaskStatus? = nil
    )
    {
        self.actionsDefinition = actionsDefinition
        self.auditCheckToActionsMapping = auditCheckToActionsMapping
        self.endTime = endTime
        self.startTime = startTime
        self.target = target
        self.taskStatistics = taskStatistics
        self.taskStatus = taskStatus
    }
}

public struct DescribeAuditSuppressionInput {
    /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    /// This member is required.
    public var checkName: Swift.String?
    /// Information that identifies the noncompliant resource.
    /// This member is required.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?

    public init(
        checkName: Swift.String? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil
    )
    {
        self.checkName = checkName
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct DescribeAuditSuppressionOutput {
    /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    public var checkName: Swift.String?
    /// The description of the audit suppression.
    public var description: Swift.String?
    /// The epoch timestamp in seconds at which this suppression expires.
    public var expirationDate: Foundation.Date?
    /// Information that identifies the noncompliant resource.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
    /// Indicates whether a suppression should exist indefinitely or not.
    public var suppressIndefinitely: Swift.Bool?

    public init(
        checkName: Swift.String? = nil,
        description: Swift.String? = nil,
        expirationDate: Foundation.Date? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
        suppressIndefinitely: Swift.Bool? = nil
    )
    {
        self.checkName = checkName
        self.description = description
        self.expirationDate = expirationDate
        self.resourceIdentifier = resourceIdentifier
        self.suppressIndefinitely = suppressIndefinitely
    }
}

public struct DescribeAuditTaskInput {
    /// The ID of the audit whose information you want to get.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

extension IoTClientTypes {
    /// Statistics for the checks performed during the audit.
    public struct TaskStatistics {
        /// The number of checks that did not run because the audit was canceled.
        public var canceledChecks: Swift.Int?
        /// The number of checks that found compliant resources.
        public var compliantChecks: Swift.Int?
        /// The number of checks.
        public var failedChecks: Swift.Int?
        /// The number of checks in progress.
        public var inProgressChecks: Swift.Int?
        /// The number of checks that found noncompliant resources.
        public var nonCompliantChecks: Swift.Int?
        /// The number of checks in this audit.
        public var totalChecks: Swift.Int?
        /// The number of checks waiting for data collection.
        public var waitingForDataCollectionChecks: Swift.Int?

        public init(
            canceledChecks: Swift.Int? = nil,
            compliantChecks: Swift.Int? = nil,
            failedChecks: Swift.Int? = nil,
            inProgressChecks: Swift.Int? = nil,
            nonCompliantChecks: Swift.Int? = nil,
            totalChecks: Swift.Int? = nil,
            waitingForDataCollectionChecks: Swift.Int? = nil
        )
        {
            self.canceledChecks = canceledChecks
            self.compliantChecks = compliantChecks
            self.failedChecks = failedChecks
            self.inProgressChecks = inProgressChecks
            self.nonCompliantChecks = nonCompliantChecks
            self.totalChecks = totalChecks
            self.waitingForDataCollectionChecks = waitingForDataCollectionChecks
        }
    }

}

public struct DescribeAuditTaskOutput {
    /// Detailed information about each check performed during this audit.
    public var auditDetails: [Swift.String: IoTClientTypes.AuditCheckDetails]?
    /// The name of the scheduled audit (only if the audit was a scheduled audit).
    public var scheduledAuditName: Swift.String?
    /// The time the audit started.
    public var taskStartTime: Foundation.Date?
    /// Statistical information about the audit.
    public var taskStatistics: IoTClientTypes.TaskStatistics?
    /// The status of the audit: one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
    public var taskStatus: IoTClientTypes.AuditTaskStatus?
    /// The type of audit: "ON_DEMAND_AUDIT_TASK" or "SCHEDULED_AUDIT_TASK".
    public var taskType: IoTClientTypes.AuditTaskType?

    public init(
        auditDetails: [Swift.String: IoTClientTypes.AuditCheckDetails]? = nil,
        scheduledAuditName: Swift.String? = nil,
        taskStartTime: Foundation.Date? = nil,
        taskStatistics: IoTClientTypes.TaskStatistics? = nil,
        taskStatus: IoTClientTypes.AuditTaskStatus? = nil,
        taskType: IoTClientTypes.AuditTaskType? = nil
    )
    {
        self.auditDetails = auditDetails
        self.scheduledAuditName = scheduledAuditName
        self.taskStartTime = taskStartTime
        self.taskStatistics = taskStatistics
        self.taskStatus = taskStatus
        self.taskType = taskType
    }
}

public struct DescribeAuthorizerInput {
    /// The name of the authorizer to describe.
    /// This member is required.
    public var authorizerName: Swift.String?

    public init(
        authorizerName: Swift.String? = nil
    )
    {
        self.authorizerName = authorizerName
    }
}

public struct DescribeAuthorizerOutput {
    /// The authorizer description.
    public var authorizerDescription: IoTClientTypes.AuthorizerDescription?

    public init(
        authorizerDescription: IoTClientTypes.AuthorizerDescription? = nil
    )
    {
        self.authorizerDescription = authorizerDescription
    }
}

public struct DescribeBillingGroupInput {
    /// The name of the billing group.
    /// This member is required.
    public var billingGroupName: Swift.String?

    public init(
        billingGroupName: Swift.String? = nil
    )
    {
        self.billingGroupName = billingGroupName
    }
}

extension IoTClientTypes {
    /// Additional information about the billing group.
    public struct BillingGroupMetadata {
        /// The date the billing group was created.
        public var creationDate: Foundation.Date?

        public init(
            creationDate: Foundation.Date? = nil
        )
        {
            self.creationDate = creationDate
        }
    }

}

public struct DescribeBillingGroupOutput {
    /// The ARN of the billing group.
    public var billingGroupArn: Swift.String?
    /// The ID of the billing group.
    public var billingGroupId: Swift.String?
    /// Additional information about the billing group.
    public var billingGroupMetadata: IoTClientTypes.BillingGroupMetadata?
    /// The name of the billing group.
    public var billingGroupName: Swift.String?
    /// The properties of the billing group.
    public var billingGroupProperties: IoTClientTypes.BillingGroupProperties?
    /// The version of the billing group.
    public var version: Swift.Int

    public init(
        billingGroupArn: Swift.String? = nil,
        billingGroupId: Swift.String? = nil,
        billingGroupMetadata: IoTClientTypes.BillingGroupMetadata? = nil,
        billingGroupName: Swift.String? = nil,
        billingGroupProperties: IoTClientTypes.BillingGroupProperties? = nil,
        version: Swift.Int = 0
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingGroupId = billingGroupId
        self.billingGroupMetadata = billingGroupMetadata
        self.billingGroupName = billingGroupName
        self.billingGroupProperties = billingGroupProperties
        self.version = version
    }
}

/// The input for the DescribeCACertificate operation.
public struct DescribeCACertificateInput {
    /// The CA certificate identifier.
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

extension IoTClientTypes {

    public enum CertificateMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case sniOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateMode] {
            return [
                .default,
                .sniOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .sniOnly: return "SNI_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {

    public enum CACertificateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [CACertificateStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// When the certificate is valid.
    public struct CertificateValidity {
        /// The certificate is not valid after this date.
        public var notAfter: Foundation.Date?
        /// The certificate is not valid before this date.
        public var notBefore: Foundation.Date?

        public init(
            notAfter: Foundation.Date? = nil,
            notBefore: Foundation.Date? = nil
        )
        {
            self.notAfter = notAfter
            self.notBefore = notBefore
        }
    }

}

extension IoTClientTypes {
    /// Describes a CA certificate.
    public struct CACertificateDescription {
        /// Whether the CA certificate configured for auto registration of device certificates. Valid values are "ENABLE" and "DISABLE"
        public var autoRegistrationStatus: IoTClientTypes.AutoRegistrationStatus?
        /// The CA certificate ARN.
        public var certificateArn: Swift.String?
        /// The CA certificate ID.
        public var certificateId: Swift.String?
        /// The mode of the CA. All the device certificates that are registered using this CA will be registered in the same mode as the CA. For more information about certificate mode for device certificates, see [certificate mode](https://docs.aws.amazon.com/iot/latest/apireference/API_CertificateDescription.html#iot-Type-CertificateDescription-certificateMode).
        public var certificateMode: IoTClientTypes.CertificateMode?
        /// The CA certificate data, in PEM format.
        public var certificatePem: Swift.String?
        /// The date the CA certificate was created.
        public var creationDate: Foundation.Date?
        /// The customer version of the CA certificate.
        public var customerVersion: Swift.Int?
        /// The generation ID of the CA certificate.
        public var generationId: Swift.String?
        /// The date the CA certificate was last modified.
        public var lastModifiedDate: Foundation.Date?
        /// The owner of the CA certificate.
        public var ownedBy: Swift.String?
        /// The status of a CA certificate.
        public var status: IoTClientTypes.CACertificateStatus?
        /// When the CA certificate is valid.
        public var validity: IoTClientTypes.CertificateValidity?

        public init(
            autoRegistrationStatus: IoTClientTypes.AutoRegistrationStatus? = nil,
            certificateArn: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            certificateMode: IoTClientTypes.CertificateMode? = nil,
            certificatePem: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            customerVersion: Swift.Int? = nil,
            generationId: Swift.String? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            ownedBy: Swift.String? = nil,
            status: IoTClientTypes.CACertificateStatus? = nil,
            validity: IoTClientTypes.CertificateValidity? = nil
        )
        {
            self.autoRegistrationStatus = autoRegistrationStatus
            self.certificateArn = certificateArn
            self.certificateId = certificateId
            self.certificateMode = certificateMode
            self.certificatePem = certificatePem
            self.creationDate = creationDate
            self.customerVersion = customerVersion
            self.generationId = generationId
            self.lastModifiedDate = lastModifiedDate
            self.ownedBy = ownedBy
            self.status = status
            self.validity = validity
        }
    }

}

extension IoTClientTypes {
    /// The registration configuration.
    public struct RegistrationConfig {
        /// The ARN of the role.
        public var roleArn: Swift.String?
        /// The template body.
        public var templateBody: Swift.String?
        /// The name of the provisioning template.
        public var templateName: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            templateBody: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.templateBody = templateBody
            self.templateName = templateName
        }
    }

}

/// The output from the DescribeCACertificate operation.
public struct DescribeCACertificateOutput {
    /// The CA certificate description.
    public var certificateDescription: IoTClientTypes.CACertificateDescription?
    /// Information about the registration configuration.
    public var registrationConfig: IoTClientTypes.RegistrationConfig?

    public init(
        certificateDescription: IoTClientTypes.CACertificateDescription? = nil,
        registrationConfig: IoTClientTypes.RegistrationConfig? = nil
    )
    {
        self.certificateDescription = certificateDescription
        self.registrationConfig = registrationConfig
    }
}

/// The input for the DescribeCertificate operation.
public struct DescribeCertificateInput {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

extension IoTClientTypes {

    public enum CertificateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case pendingActivation
        case pendingTransfer
        case registerInactive
        case revoked
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateStatus] {
            return [
                .active,
                .inactive,
                .pendingActivation,
                .pendingTransfer,
                .registerInactive,
                .revoked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .pendingActivation: return "PENDING_ACTIVATION"
            case .pendingTransfer: return "PENDING_TRANSFER"
            case .registerInactive: return "REGISTER_INACTIVE"
            case .revoked: return "REVOKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Data used to transfer a certificate to an Amazon Web Services account.
    public struct TransferData {
        /// The date the transfer was accepted.
        public var acceptDate: Foundation.Date?
        /// The date the transfer was rejected.
        public var rejectDate: Foundation.Date?
        /// The reason why the transfer was rejected.
        public var rejectReason: Swift.String?
        /// The date the transfer took place.
        public var transferDate: Foundation.Date?
        /// The transfer message.
        public var transferMessage: Swift.String?

        public init(
            acceptDate: Foundation.Date? = nil,
            rejectDate: Foundation.Date? = nil,
            rejectReason: Swift.String? = nil,
            transferDate: Foundation.Date? = nil,
            transferMessage: Swift.String? = nil
        )
        {
            self.acceptDate = acceptDate
            self.rejectDate = rejectDate
            self.rejectReason = rejectReason
            self.transferDate = transferDate
            self.transferMessage = transferMessage
        }
    }

}

extension IoTClientTypes {
    /// Describes a certificate.
    public struct CertificateDescription {
        /// The certificate ID of the CA certificate used to sign this certificate.
        public var caCertificateId: Swift.String?
        /// The ARN of the certificate.
        public var certificateArn: Swift.String?
        /// The ID of the certificate.
        public var certificateId: Swift.String?
        /// The mode of the certificate. DEFAULT: A certificate in DEFAULT mode is either generated by Amazon Web Services IoT Core or registered with an issuer certificate authority (CA) in DEFAULT mode. Devices with certificates in DEFAULT mode aren't required to send the Server Name Indication (SNI) extension when connecting to Amazon Web Services IoT Core. However, to use features such as custom domains and VPC endpoints, we recommend that you use the SNI extension when connecting to Amazon Web Services IoT Core. SNI_ONLY: A certificate in SNI_ONLY mode is registered without an issuer CA. Devices with certificates in SNI_ONLY mode must send the SNI extension when connecting to Amazon Web Services IoT Core. For more information about the value for SNI extension, see [Transport security in IoT](https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html).
        public var certificateMode: IoTClientTypes.CertificateMode?
        /// The certificate data, in PEM format.
        public var certificatePem: Swift.String?
        /// The date and time the certificate was created.
        public var creationDate: Foundation.Date?
        /// The customer version of the certificate.
        public var customerVersion: Swift.Int?
        /// The generation ID of the certificate.
        public var generationId: Swift.String?
        /// The date and time the certificate was last modified.
        public var lastModifiedDate: Foundation.Date?
        /// The ID of the Amazon Web Services account that owns the certificate.
        public var ownedBy: Swift.String?
        /// The ID of the Amazon Web Services account of the previous owner of the certificate.
        public var previousOwnedBy: Swift.String?
        /// The status of the certificate.
        public var status: IoTClientTypes.CertificateStatus?
        /// The transfer data.
        public var transferData: IoTClientTypes.TransferData?
        /// When the certificate is valid.
        public var validity: IoTClientTypes.CertificateValidity?

        public init(
            caCertificateId: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            certificateMode: IoTClientTypes.CertificateMode? = nil,
            certificatePem: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            customerVersion: Swift.Int? = nil,
            generationId: Swift.String? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            ownedBy: Swift.String? = nil,
            previousOwnedBy: Swift.String? = nil,
            status: IoTClientTypes.CertificateStatus? = nil,
            transferData: IoTClientTypes.TransferData? = nil,
            validity: IoTClientTypes.CertificateValidity? = nil
        )
        {
            self.caCertificateId = caCertificateId
            self.certificateArn = certificateArn
            self.certificateId = certificateId
            self.certificateMode = certificateMode
            self.certificatePem = certificatePem
            self.creationDate = creationDate
            self.customerVersion = customerVersion
            self.generationId = generationId
            self.lastModifiedDate = lastModifiedDate
            self.ownedBy = ownedBy
            self.previousOwnedBy = previousOwnedBy
            self.status = status
            self.transferData = transferData
            self.validity = validity
        }
    }

}

/// The output of the DescribeCertificate operation.
public struct DescribeCertificateOutput {
    /// The description of the certificate.
    public var certificateDescription: IoTClientTypes.CertificateDescription?

    public init(
        certificateDescription: IoTClientTypes.CertificateDescription? = nil
    )
    {
        self.certificateDescription = certificateDescription
    }
}

public struct DescribeCertificateProviderInput {
    /// The name of the certificate provider.
    /// This member is required.
    public var certificateProviderName: Swift.String?

    public init(
        certificateProviderName: Swift.String? = nil
    )
    {
        self.certificateProviderName = certificateProviderName
    }
}

public struct DescribeCertificateProviderOutput {
    /// A list of the operations that the certificate provider will use to generate certificates. Valid value: CreateCertificateFromCsr.
    public var accountDefaultForOperations: [IoTClientTypes.CertificateProviderOperation]?
    /// The ARN of the certificate provider.
    public var certificateProviderArn: Swift.String?
    /// The name of the certificate provider.
    public var certificateProviderName: Swift.String?
    /// The date-time string that indicates when the certificate provider was created.
    public var creationDate: Foundation.Date?
    /// The Lambda function ARN that's associated with the certificate provider.
    public var lambdaFunctionArn: Swift.String?
    /// The date-time string that indicates when the certificate provider was last updated.
    public var lastModifiedDate: Foundation.Date?

    public init(
        accountDefaultForOperations: [IoTClientTypes.CertificateProviderOperation]? = nil,
        certificateProviderArn: Swift.String? = nil,
        certificateProviderName: Swift.String? = nil,
        creationDate: Foundation.Date? = nil,
        lambdaFunctionArn: Swift.String? = nil,
        lastModifiedDate: Foundation.Date? = nil
    )
    {
        self.accountDefaultForOperations = accountDefaultForOperations
        self.certificateProviderArn = certificateProviderArn
        self.certificateProviderName = certificateProviderName
        self.creationDate = creationDate
        self.lambdaFunctionArn = lambdaFunctionArn
        self.lastModifiedDate = lastModifiedDate
    }
}

public struct DescribeCustomMetricInput {
    /// The name of the custom metric.
    /// This member is required.
    public var metricName: Swift.String?

    public init(
        metricName: Swift.String? = nil
    )
    {
        self.metricName = metricName
    }
}

public struct DescribeCustomMetricOutput {
    /// The creation date of the custom metric in milliseconds since epoch.
    public var creationDate: Foundation.Date?
    /// Field represents a friendly name in the console for the custom metric; doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. Can be updated.
    public var displayName: Swift.String?
    /// The time the custom metric was last modified in milliseconds since epoch.
    public var lastModifiedDate: Foundation.Date?
    /// The Amazon Resource Number (ARN) of the custom metric.
    public var metricArn: Swift.String?
    /// The name of the custom metric.
    public var metricName: Swift.String?
    /// The type of the custom metric. The type number only takes a single metric value as an input, but while submitting the metrics value in the DeviceMetrics report, it must be passed as an array with a single value.
    public var metricType: IoTClientTypes.CustomMetricType?

    public init(
        creationDate: Foundation.Date? = nil,
        displayName: Swift.String? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        metricArn: Swift.String? = nil,
        metricName: Swift.String? = nil,
        metricType: IoTClientTypes.CustomMetricType? = nil
    )
    {
        self.creationDate = creationDate
        self.displayName = displayName
        self.lastModifiedDate = lastModifiedDate
        self.metricArn = metricArn
        self.metricName = metricName
        self.metricType = metricType
    }
}

public struct DescribeDefaultAuthorizerInput {

    public init() { }
}

public struct DescribeDefaultAuthorizerOutput {
    /// The default authorizer's description.
    public var authorizerDescription: IoTClientTypes.AuthorizerDescription?

    public init(
        authorizerDescription: IoTClientTypes.AuthorizerDescription? = nil
    )
    {
        self.authorizerDescription = authorizerDescription
    }
}

public struct DescribeDetectMitigationActionsTaskInput {
    /// The unique identifier of the task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

extension IoTClientTypes {
    /// The target of a mitigation action task.
    public struct DetectMitigationActionsTaskTarget {
        /// The name of the behavior.
        public var behaviorName: Swift.String?
        /// The name of the security profile.
        public var securityProfileName: Swift.String?
        /// The unique identifiers of the violations.
        public var violationIds: [Swift.String]?

        public init(
            behaviorName: Swift.String? = nil,
            securityProfileName: Swift.String? = nil,
            violationIds: [Swift.String]? = nil
        )
        {
            self.behaviorName = behaviorName
            self.securityProfileName = securityProfileName
            self.violationIds = violationIds
        }
    }

}

extension IoTClientTypes {
    /// The statistics of a mitigation action task.
    public struct DetectMitigationActionsTaskStatistics {
        /// The actions that were performed.
        public var actionsExecuted: Swift.Int?
        /// The actions that failed.
        public var actionsFailed: Swift.Int?
        /// The actions that were skipped.
        public var actionsSkipped: Swift.Int?

        public init(
            actionsExecuted: Swift.Int? = nil,
            actionsFailed: Swift.Int? = nil,
            actionsSkipped: Swift.Int? = nil
        )
        {
            self.actionsExecuted = actionsExecuted
            self.actionsFailed = actionsFailed
            self.actionsSkipped = actionsSkipped
        }
    }

}

extension IoTClientTypes {

    public enum DetectMitigationActionsTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectMitigationActionsTaskStatus] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .successful: return "SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Specifies the time period of which violation events occurred between.
    public struct ViolationEventOccurrenceRange {
        /// The end date and time of a time period in which violation events occurred.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// The start date and time of a time period in which violation events occurred.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension IoTClientTypes {
    /// The summary of the mitigation action tasks.
    public struct DetectMitigationActionsTaskSummary {
        /// The definition of the actions.
        public var actionsDefinition: [IoTClientTypes.MitigationAction]?
        /// Includes only active violations.
        public var onlyActiveViolationsIncluded: Swift.Bool
        /// Includes suppressed alerts.
        public var suppressedAlertsIncluded: Swift.Bool
        /// Specifies the ML Detect findings to which the mitigation actions are applied.
        public var target: IoTClientTypes.DetectMitigationActionsTaskTarget?
        /// The date the task ended.
        public var taskEndTime: Foundation.Date?
        /// The unique identifier of the task.
        public var taskId: Swift.String?
        /// The date the task started.
        public var taskStartTime: Foundation.Date?
        /// The statistics of a mitigation action task.
        public var taskStatistics: IoTClientTypes.DetectMitigationActionsTaskStatistics?
        /// The status of the task.
        public var taskStatus: IoTClientTypes.DetectMitigationActionsTaskStatus?
        /// Specifies the time period of which violation events occurred between.
        public var violationEventOccurrenceRange: IoTClientTypes.ViolationEventOccurrenceRange?

        public init(
            actionsDefinition: [IoTClientTypes.MitigationAction]? = nil,
            onlyActiveViolationsIncluded: Swift.Bool = false,
            suppressedAlertsIncluded: Swift.Bool = false,
            target: IoTClientTypes.DetectMitigationActionsTaskTarget? = nil,
            taskEndTime: Foundation.Date? = nil,
            taskId: Swift.String? = nil,
            taskStartTime: Foundation.Date? = nil,
            taskStatistics: IoTClientTypes.DetectMitigationActionsTaskStatistics? = nil,
            taskStatus: IoTClientTypes.DetectMitigationActionsTaskStatus? = nil,
            violationEventOccurrenceRange: IoTClientTypes.ViolationEventOccurrenceRange? = nil
        )
        {
            self.actionsDefinition = actionsDefinition
            self.onlyActiveViolationsIncluded = onlyActiveViolationsIncluded
            self.suppressedAlertsIncluded = suppressedAlertsIncluded
            self.target = target
            self.taskEndTime = taskEndTime
            self.taskId = taskId
            self.taskStartTime = taskStartTime
            self.taskStatistics = taskStatistics
            self.taskStatus = taskStatus
            self.violationEventOccurrenceRange = violationEventOccurrenceRange
        }
    }

}

public struct DescribeDetectMitigationActionsTaskOutput {
    /// The description of a task.
    public var taskSummary: IoTClientTypes.DetectMitigationActionsTaskSummary?

    public init(
        taskSummary: IoTClientTypes.DetectMitigationActionsTaskSummary? = nil
    )
    {
        self.taskSummary = taskSummary
    }
}

public struct DescribeDimensionInput {
    /// The unique identifier for the dimension.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DescribeDimensionOutput {
    /// The Amazon Resource Name (ARN) for the dimension.
    public var arn: Swift.String?
    /// The date the dimension was created.
    public var creationDate: Foundation.Date?
    /// The date the dimension was last modified.
    public var lastModifiedDate: Foundation.Date?
    /// The unique identifier for the dimension.
    public var name: Swift.String?
    /// The value or list of values used to scope the dimension. For example, for topic filters, this is the pattern used to match the MQTT topic name.
    public var stringValues: [Swift.String]?
    /// The type of the dimension.
    public var type: IoTClientTypes.DimensionType?

    public init(
        arn: Swift.String? = nil,
        creationDate: Foundation.Date? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        stringValues: [Swift.String]? = nil,
        type: IoTClientTypes.DimensionType? = nil
    )
    {
        self.arn = arn
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.stringValues = stringValues
        self.type = type
    }
}

public struct DescribeDomainConfigurationInput {
    /// The name of the domain configuration.
    /// This member is required.
    public var domainConfigurationName: Swift.String?

    public init(
        domainConfigurationName: Swift.String? = nil
    )
    {
        self.domainConfigurationName = domainConfigurationName
    }
}

extension IoTClientTypes {

    public enum DomainConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainConfigurationStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {

    public enum DomainType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsManaged
        case customerManaged
        case endpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainType] {
            return [
                .awsManaged,
                .customerManaged,
                .endpoint
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "AWS_MANAGED"
            case .customerManaged: return "CUSTOMER_MANAGED"
            case .endpoint: return "ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {

    public enum ServerCertificateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invalid
        case valid
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerCertificateStatus] {
            return [
                .invalid,
                .valid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invalid: return "INVALID"
            case .valid: return "VALID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// An object that contains information about a server certificate.
    public struct ServerCertificateSummary {
        /// The ARN of the server certificate.
        public var serverCertificateArn: Swift.String?
        /// The status of the server certificate.
        public var serverCertificateStatus: IoTClientTypes.ServerCertificateStatus?
        /// Details that explain the status of the server certificate.
        public var serverCertificateStatusDetail: Swift.String?

        public init(
            serverCertificateArn: Swift.String? = nil,
            serverCertificateStatus: IoTClientTypes.ServerCertificateStatus? = nil,
            serverCertificateStatusDetail: Swift.String? = nil
        )
        {
            self.serverCertificateArn = serverCertificateArn
            self.serverCertificateStatus = serverCertificateStatus
            self.serverCertificateStatusDetail = serverCertificateStatusDetail
        }
    }

}

public struct DescribeDomainConfigurationOutput {
    /// An object that specifies the authorization service for a domain.
    public var authorizerConfig: IoTClientTypes.AuthorizerConfig?
    /// The ARN of the domain configuration.
    public var domainConfigurationArn: Swift.String?
    /// The name of the domain configuration.
    public var domainConfigurationName: Swift.String?
    /// A Boolean value that specifies the current state of the domain configuration.
    public var domainConfigurationStatus: IoTClientTypes.DomainConfigurationStatus?
    /// The name of the domain.
    public var domainName: Swift.String?
    /// The type of the domain.
    public var domainType: IoTClientTypes.DomainType?
    /// The date and time the domain configuration's status was last changed.
    public var lastStatusChangeDate: Foundation.Date?
    /// The server certificate configuration.
    public var serverCertificateConfig: IoTClientTypes.ServerCertificateConfig?
    /// A list containing summary information about the server certificate included in the domain configuration.
    public var serverCertificates: [IoTClientTypes.ServerCertificateSummary]?
    /// The type of service delivered by the endpoint.
    public var serviceType: IoTClientTypes.ServiceType?
    /// An object that specifies the TLS configuration for a domain.
    public var tlsConfig: IoTClientTypes.TlsConfig?

    public init(
        authorizerConfig: IoTClientTypes.AuthorizerConfig? = nil,
        domainConfigurationArn: Swift.String? = nil,
        domainConfigurationName: Swift.String? = nil,
        domainConfigurationStatus: IoTClientTypes.DomainConfigurationStatus? = nil,
        domainName: Swift.String? = nil,
        domainType: IoTClientTypes.DomainType? = nil,
        lastStatusChangeDate: Foundation.Date? = nil,
        serverCertificateConfig: IoTClientTypes.ServerCertificateConfig? = nil,
        serverCertificates: [IoTClientTypes.ServerCertificateSummary]? = nil,
        serviceType: IoTClientTypes.ServiceType? = nil,
        tlsConfig: IoTClientTypes.TlsConfig? = nil
    )
    {
        self.authorizerConfig = authorizerConfig
        self.domainConfigurationArn = domainConfigurationArn
        self.domainConfigurationName = domainConfigurationName
        self.domainConfigurationStatus = domainConfigurationStatus
        self.domainName = domainName
        self.domainType = domainType
        self.lastStatusChangeDate = lastStatusChangeDate
        self.serverCertificateConfig = serverCertificateConfig
        self.serverCertificates = serverCertificates
        self.serviceType = serviceType
        self.tlsConfig = tlsConfig
    }
}

/// The input for the DescribeEndpoint operation.
public struct DescribeEndpointInput {
    /// The endpoint type. Valid endpoint types include:
    ///
    /// * iot:Data - Returns a VeriSign signed data endpoint.
    ///
    ///
    ///
    ///
    /// * iot:Data-ATS - Returns an ATS signed data endpoint.
    ///
    ///
    ///
    ///
    /// * iot:CredentialProvider - Returns an IoT credentials provider API endpoint.
    ///
    ///
    ///
    ///
    /// * iot:Jobs - Returns an IoT device management Jobs API endpoint.
    ///
    ///
    /// We strongly recommend that customers use the newer iot:Data-ATS endpoint type to avoid issues related to the widespread distrust of Symantec certificate authorities. ATS Signed Certificates are more secure and are trusted by most popular browsers.
    public var endpointType: Swift.String?

    public init(
        endpointType: Swift.String? = nil
    )
    {
        self.endpointType = endpointType
    }
}

/// The output from the DescribeEndpoint operation.
public struct DescribeEndpointOutput {
    /// The endpoint. The format of the endpoint is as follows: identifier.iot.region.amazonaws.com.
    public var endpointAddress: Swift.String?

    public init(
        endpointAddress: Swift.String? = nil
    )
    {
        self.endpointAddress = endpointAddress
    }
}

public struct DescribeEventConfigurationsInput {

    public init() { }
}

extension IoTClientTypes {

    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case caCertificate
        case certificate
        case job
        case jobExecution
        case policy
        case thing
        case thingGroup
        case thingGroupHierarchy
        case thingGroupMembership
        case thingType
        case thingTypeAssociation
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .caCertificate,
                .certificate,
                .job,
                .jobExecution,
                .policy,
                .thing,
                .thingGroup,
                .thingGroupHierarchy,
                .thingGroupMembership,
                .thingType,
                .thingTypeAssociation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .caCertificate: return "CA_CERTIFICATE"
            case .certificate: return "CERTIFICATE"
            case .job: return "JOB"
            case .jobExecution: return "JOB_EXECUTION"
            case .policy: return "POLICY"
            case .thing: return "THING"
            case .thingGroup: return "THING_GROUP"
            case .thingGroupHierarchy: return "THING_GROUP_HIERARCHY"
            case .thingGroupMembership: return "THING_GROUP_MEMBERSHIP"
            case .thingType: return "THING_TYPE"
            case .thingTypeAssociation: return "THING_TYPE_ASSOCIATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Configuration.
    public struct Configuration {
        /// True to enable the configuration.
        public var enabled: Swift.Bool

        public init(
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

public struct DescribeEventConfigurationsOutput {
    /// The creation date of the event configuration.
    public var creationDate: Foundation.Date?
    /// The event configurations.
    public var eventConfigurations: [Swift.String: IoTClientTypes.Configuration]?
    /// The date the event configurations were last modified.
    public var lastModifiedDate: Foundation.Date?

    public init(
        creationDate: Foundation.Date? = nil,
        eventConfigurations: [Swift.String: IoTClientTypes.Configuration]? = nil,
        lastModifiedDate: Foundation.Date? = nil
    )
    {
        self.creationDate = creationDate
        self.eventConfigurations = eventConfigurations
        self.lastModifiedDate = lastModifiedDate
    }
}

public struct DescribeFleetMetricInput {
    /// The name of the fleet metric to describe.
    /// This member is required.
    public var metricName: Swift.String?

    public init(
        metricName: Swift.String? = nil
    )
    {
        self.metricName = metricName
    }
}

public struct DescribeFleetMetricOutput {
    /// The field to aggregate.
    public var aggregationField: Swift.String?
    /// The type of the aggregation query.
    public var aggregationType: IoTClientTypes.AggregationType?
    /// The date when the fleet metric is created.
    public var creationDate: Foundation.Date?
    /// The fleet metric description.
    public var description: Swift.String?
    /// The name of the index to search.
    public var indexName: Swift.String?
    /// The date when the fleet metric is last modified.
    public var lastModifiedDate: Foundation.Date?
    /// The ARN of the fleet metric to describe.
    public var metricArn: Swift.String?
    /// The name of the fleet metric to describe.
    public var metricName: Swift.String?
    /// The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.
    public var period: Swift.Int?
    /// The search query string.
    public var queryString: Swift.String?
    /// The query version.
    public var queryVersion: Swift.String?
    /// Used to support unit transformation such as milliseconds to seconds. The unit must be supported by [CW metric](https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html).
    public var unit: IoTClientTypes.FleetMetricUnit?
    /// The version of the fleet metric.
    public var version: Swift.Int

    public init(
        aggregationField: Swift.String? = nil,
        aggregationType: IoTClientTypes.AggregationType? = nil,
        creationDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        indexName: Swift.String? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        metricArn: Swift.String? = nil,
        metricName: Swift.String? = nil,
        period: Swift.Int? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        unit: IoTClientTypes.FleetMetricUnit? = nil,
        version: Swift.Int = 0
    )
    {
        self.aggregationField = aggregationField
        self.aggregationType = aggregationType
        self.creationDate = creationDate
        self.description = description
        self.indexName = indexName
        self.lastModifiedDate = lastModifiedDate
        self.metricArn = metricArn
        self.metricName = metricName
        self.period = period
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.unit = unit
        self.version = version
    }
}

public struct DescribeIndexInput {
    /// The index name.
    /// This member is required.
    public var indexName: Swift.String?

    public init(
        indexName: Swift.String? = nil
    )
    {
        self.indexName = indexName
    }
}

extension IoTClientTypes {

    public enum IndexStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case building
        case rebuilding
        case sdkUnknown(Swift.String)

        public static var allCases: [IndexStatus] {
            return [
                .active,
                .building,
                .rebuilding
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .building: return "BUILDING"
            case .rebuilding: return "REBUILDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeIndexOutput {
    /// The index name.
    public var indexName: Swift.String?
    /// The index status.
    public var indexStatus: IoTClientTypes.IndexStatus?
    /// Contains a value that specifies the type of indexing performed. Valid values are:
    ///
    /// * REGISTRY – Your thing index contains only registry data.
    ///
    /// * REGISTRY_AND_SHADOW - Your thing index contains registry data and shadow data.
    ///
    /// * REGISTRY_AND_CONNECTIVITY_STATUS - Your thing index contains registry data and thing connectivity status data.
    ///
    /// * REGISTRY_AND_SHADOW_AND_CONNECTIVITY_STATUS - Your thing index contains registry data, shadow data, and thing connectivity status data.
    ///
    /// * MULTI_INDEXING_MODE - Your thing index contains multiple data sources. For more information, see [GetIndexingConfiguration](https://docs.aws.amazon.com/iot/latest/apireference/API_GetIndexingConfiguration.html).
    public var schema: Swift.String?

    public init(
        indexName: Swift.String? = nil,
        indexStatus: IoTClientTypes.IndexStatus? = nil,
        schema: Swift.String? = nil
    )
    {
        self.indexName = indexName
        self.indexStatus = indexStatus
        self.schema = schema
    }
}

public struct DescribeJobInput {
    /// A flag that provides a view of the job document before and after the substitution parameters have been resolved with their exact values.
    public var beforeSubstitution: Swift.Bool?
    /// The unique identifier you assigned to this job when it was created.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        beforeSubstitution: Swift.Bool? = false,
        jobId: Swift.String? = nil
    )
    {
        self.beforeSubstitution = beforeSubstitution
        self.jobId = jobId
    }
}

extension IoTClientTypes {
    /// The job process details.
    public struct JobProcessDetails {
        /// The number of things that cancelled the job.
        public var numberOfCanceledThings: Swift.Int?
        /// The number of things that failed executing the job.
        public var numberOfFailedThings: Swift.Int?
        /// The number of things currently executing the job.
        public var numberOfInProgressThings: Swift.Int?
        /// The number of things that are awaiting execution of the job.
        public var numberOfQueuedThings: Swift.Int?
        /// The number of things that rejected the job.
        public var numberOfRejectedThings: Swift.Int?
        /// The number of things that are no longer scheduled to execute the job because they have been deleted or have been removed from the group that was a target of the job.
        public var numberOfRemovedThings: Swift.Int?
        /// The number of things which successfully completed the job.
        public var numberOfSucceededThings: Swift.Int?
        /// The number of things whose job execution status is TIMED_OUT.
        public var numberOfTimedOutThings: Swift.Int?
        /// The target devices to which the job execution is being rolled out. This value will be null after the job execution has finished rolling out to all the target devices.
        public var processingTargets: [Swift.String]?

        public init(
            numberOfCanceledThings: Swift.Int? = nil,
            numberOfFailedThings: Swift.Int? = nil,
            numberOfInProgressThings: Swift.Int? = nil,
            numberOfQueuedThings: Swift.Int? = nil,
            numberOfRejectedThings: Swift.Int? = nil,
            numberOfRemovedThings: Swift.Int? = nil,
            numberOfSucceededThings: Swift.Int? = nil,
            numberOfTimedOutThings: Swift.Int? = nil,
            processingTargets: [Swift.String]? = nil
        )
        {
            self.numberOfCanceledThings = numberOfCanceledThings
            self.numberOfFailedThings = numberOfFailedThings
            self.numberOfInProgressThings = numberOfInProgressThings
            self.numberOfQueuedThings = numberOfQueuedThings
            self.numberOfRejectedThings = numberOfRejectedThings
            self.numberOfRemovedThings = numberOfRemovedThings
            self.numberOfSucceededThings = numberOfSucceededThings
            self.numberOfTimedOutThings = numberOfTimedOutThings
            self.processingTargets = processingTargets
        }
    }

}

extension IoTClientTypes {
    /// Displays the next seven maintenance window occurrences and their start times.
    public struct ScheduledJobRollout {
        /// Displays the start times of the next seven maintenance window occurrences.
        public var startTime: Swift.String?

        public init(
            startTime: Swift.String? = nil
        )
        {
            self.startTime = startTime
        }
    }

}

extension IoTClientTypes {

    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case completed
        case deletionInProgress
        case inProgress
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .canceled,
                .completed,
                .deletionInProgress,
                .inProgress,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .deletionInProgress: return "DELETION_IN_PROGRESS"
            case .inProgress: return "IN_PROGRESS"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The Job object contains details about a job.
    public struct Job {
        /// Configuration for criteria to abort the job.
        public var abortConfig: IoTClientTypes.AbortConfig?
        /// If the job was updated, describes the reason for the update.
        public var comment: Swift.String?
        /// The time, in seconds since the epoch, when the job was completed.
        public var completedAt: Foundation.Date?
        /// The time, in seconds since the epoch, when the job was created.
        public var createdAt: Foundation.Date?
        /// A short text description of the job.
        public var description: Swift.String?
        /// The package version Amazon Resource Names (ARNs) that are installed on the device when the job successfully completes. The package version must be in either the Published or Deprecated state when the job deploys. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle).The package version must be in either the Published or Deprecated state when the job deploys. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle). Note:The following Length Constraints relates to a single ARN. Up to 25 package version ARNs are allowed.
        public var destinationPackageVersions: [Swift.String]?
        /// A key-value map that pairs the patterns that need to be replaced in a managed template job document schema. You can use the description of each key as a guidance to specify the inputs during runtime when creating a job. documentParameters can only be used when creating jobs from Amazon Web Services managed templates. This parameter can't be used with custom job templates or to create jobs from them.
        public var documentParameters: [Swift.String: Swift.String]?
        /// Will be true if the job was canceled with the optional force parameter set to true.
        public var forceCanceled: Swift.Bool?
        /// Indicates whether a job is concurrent. Will be true when a job is rolling out new job executions or canceling previously created executions, otherwise false.
        public var isConcurrent: Swift.Bool?
        /// An ARN identifying the job with format "arn:aws:iot:region:account:job/jobId".
        public var jobArn: Swift.String?
        /// The configuration for the criteria to retry the job.
        public var jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
        /// Allows you to create a staged rollout of a job.
        public var jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
        /// The unique identifier you assigned to this job when it was created.
        public var jobId: Swift.String?
        /// Details about the job process.
        public var jobProcessDetails: IoTClientTypes.JobProcessDetails?
        /// The ARN of the job template used to create the job.
        public var jobTemplateArn: Swift.String?
        /// The time, in seconds since the epoch, when the job was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see [Setting up IoT Greengrass core devices.](https://docs.aws.amazon.com/greengrass/v2/developerguide/setting-up.html)
        public var namespaceId: Swift.String?
        /// Configuration for pre-signed S3 URLs.
        public var presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
        /// If the job was updated, provides the reason code for the update.
        public var reasonCode: Swift.String?
        /// Displays the next seven maintenance window occurrences and their start times.
        public var scheduledJobRollouts: [IoTClientTypes.ScheduledJobRollout]?
        /// The configuration that allows you to schedule a job for a future date and time in addition to specifying the end behavior for each job execution.
        public var schedulingConfig: IoTClientTypes.SchedulingConfig?
        /// The status of the job, one of IN_PROGRESS, CANCELED, DELETION_IN_PROGRESS or COMPLETED.
        public var status: IoTClientTypes.JobStatus?
        /// Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a device when the thing representing the device is added to a target group, even after the job was completed by all things originally in the group. We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.
        public var targetSelection: IoTClientTypes.TargetSelection?
        /// A list of IoT things and thing groups to which the job should be sent.
        public var targets: [Swift.String]?
        /// Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to TIMED_OUT.
        public var timeoutConfig: IoTClientTypes.TimeoutConfig?

        public init(
            abortConfig: IoTClientTypes.AbortConfig? = nil,
            comment: Swift.String? = nil,
            completedAt: Foundation.Date? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            destinationPackageVersions: [Swift.String]? = nil,
            documentParameters: [Swift.String: Swift.String]? = nil,
            forceCanceled: Swift.Bool? = nil,
            isConcurrent: Swift.Bool? = nil,
            jobArn: Swift.String? = nil,
            jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig? = nil,
            jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig? = nil,
            jobId: Swift.String? = nil,
            jobProcessDetails: IoTClientTypes.JobProcessDetails? = nil,
            jobTemplateArn: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            namespaceId: Swift.String? = nil,
            presignedUrlConfig: IoTClientTypes.PresignedUrlConfig? = nil,
            reasonCode: Swift.String? = nil,
            scheduledJobRollouts: [IoTClientTypes.ScheduledJobRollout]? = nil,
            schedulingConfig: IoTClientTypes.SchedulingConfig? = nil,
            status: IoTClientTypes.JobStatus? = nil,
            targetSelection: IoTClientTypes.TargetSelection? = nil,
            targets: [Swift.String]? = nil,
            timeoutConfig: IoTClientTypes.TimeoutConfig? = nil
        )
        {
            self.abortConfig = abortConfig
            self.comment = comment
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.description = description
            self.destinationPackageVersions = destinationPackageVersions
            self.documentParameters = documentParameters
            self.forceCanceled = forceCanceled
            self.isConcurrent = isConcurrent
            self.jobArn = jobArn
            self.jobExecutionsRetryConfig = jobExecutionsRetryConfig
            self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
            self.jobId = jobId
            self.jobProcessDetails = jobProcessDetails
            self.jobTemplateArn = jobTemplateArn
            self.lastUpdatedAt = lastUpdatedAt
            self.namespaceId = namespaceId
            self.presignedUrlConfig = presignedUrlConfig
            self.reasonCode = reasonCode
            self.scheduledJobRollouts = scheduledJobRollouts
            self.schedulingConfig = schedulingConfig
            self.status = status
            self.targetSelection = targetSelection
            self.targets = targets
            self.timeoutConfig = timeoutConfig
        }
    }

}

public struct DescribeJobOutput {
    /// An S3 link to the job document.
    public var documentSource: Swift.String?
    /// Information about the job.
    public var job: IoTClientTypes.Job?

    public init(
        documentSource: Swift.String? = nil,
        job: IoTClientTypes.Job? = nil
    )
    {
        self.documentSource = documentSource
        self.job = job
    }
}

public struct DescribeJobExecutionInput {
    /// A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
    public var executionNumber: Swift.Int?
    /// The unique identifier you assigned to this job when it was created.
    /// This member is required.
    public var jobId: Swift.String?
    /// The name of the thing on which the job execution is running.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        executionNumber: Swift.Int? = nil,
        jobId: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.executionNumber = executionNumber
        self.jobId = jobId
        self.thingName = thingName
    }
}

extension IoTClientTypes {

    public enum JobExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case queued
        case rejected
        case removed
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [JobExecutionStatus] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .queued,
                .rejected,
                .removed,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .rejected: return "REJECTED"
            case .removed: return "REMOVED"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Details of the job execution status.
    public struct JobExecutionStatusDetails {
        /// The job execution status.
        public var detailsMap: [Swift.String: Swift.String]?

        public init(
            detailsMap: [Swift.String: Swift.String]? = nil
        )
        {
            self.detailsMap = detailsMap
        }
    }

}

extension IoTClientTypes {
    /// The job execution object represents the execution of a job on a particular device.
    public struct JobExecution {
        /// The estimated number of seconds that remain before the job execution status will be changed to TIMED_OUT. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The actual job execution timeout can occur up to 60 seconds later than the estimated duration. This value will not be included if the job execution has reached a terminal status.
        public var approximateSecondsBeforeTimedOut: Swift.Int?
        /// A string (consisting of the digits "0" through "9") which identifies this particular job execution on this particular device. It can be used in commands which return or update job execution information.
        public var executionNumber: Swift.Int?
        /// Will be true if the job execution was canceled with the optional force parameter set to true.
        public var forceCanceled: Swift.Bool?
        /// The unique identifier you assigned to the job when it was created.
        public var jobId: Swift.String?
        /// The time, in seconds since the epoch, when the job execution was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The time, in seconds since the epoch, when the job execution was queued.
        public var queuedAt: Foundation.Date?
        /// The time, in seconds since the epoch, when the job execution started.
        public var startedAt: Foundation.Date?
        /// The status of the job execution (IN_PROGRESS, QUEUED, FAILED, SUCCEEDED, TIMED_OUT, CANCELED, or REJECTED).
        public var status: IoTClientTypes.JobExecutionStatus?
        /// A collection of name/value pairs that describe the status of the job execution.
        public var statusDetails: IoTClientTypes.JobExecutionStatusDetails?
        /// The ARN of the thing on which the job execution is running.
        public var thingArn: Swift.String?
        /// The version of the job execution. Job execution versions are incremented each time they are updated by a device.
        public var versionNumber: Swift.Int

        public init(
            approximateSecondsBeforeTimedOut: Swift.Int? = nil,
            executionNumber: Swift.Int? = nil,
            forceCanceled: Swift.Bool? = nil,
            jobId: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            queuedAt: Foundation.Date? = nil,
            startedAt: Foundation.Date? = nil,
            status: IoTClientTypes.JobExecutionStatus? = nil,
            statusDetails: IoTClientTypes.JobExecutionStatusDetails? = nil,
            thingArn: Swift.String? = nil,
            versionNumber: Swift.Int = 0
        )
        {
            self.approximateSecondsBeforeTimedOut = approximateSecondsBeforeTimedOut
            self.executionNumber = executionNumber
            self.forceCanceled = forceCanceled
            self.jobId = jobId
            self.lastUpdatedAt = lastUpdatedAt
            self.queuedAt = queuedAt
            self.startedAt = startedAt
            self.status = status
            self.statusDetails = statusDetails
            self.thingArn = thingArn
            self.versionNumber = versionNumber
        }
    }

}

public struct DescribeJobExecutionOutput {
    /// Information about the job execution.
    public var execution: IoTClientTypes.JobExecution?

    public init(
        execution: IoTClientTypes.JobExecution? = nil
    )
    {
        self.execution = execution
    }
}

public struct DescribeJobTemplateInput {
    /// The unique identifier of the job template.
    /// This member is required.
    public var jobTemplateId: Swift.String?

    public init(
        jobTemplateId: Swift.String? = nil
    )
    {
        self.jobTemplateId = jobTemplateId
    }
}

public struct DescribeJobTemplateOutput {
    /// The criteria that determine when and how a job abort takes place.
    public var abortConfig: IoTClientTypes.AbortConfig?
    /// The time, in seconds since the epoch, when the job template was created.
    public var createdAt: Foundation.Date?
    /// A description of the job template.
    public var description: Swift.String?
    /// The package version Amazon Resource Names (ARNs) that are installed on the device when the job successfully completes. The package version must be in either the Published or Deprecated state when the job deploys. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle). Note:The following Length Constraints relates to a single ARN. Up to 25 package version ARNs are allowed.
    public var destinationPackageVersions: [Swift.String]?
    /// The job document.
    public var document: Swift.String?
    /// An S3 link to the job document.
    public var documentSource: Swift.String?
    /// The configuration that determines how many retries are allowed for each failure type for a job.
    public var jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
    /// Allows you to create a staged rollout of a job.
    public var jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
    /// The ARN of the job template.
    public var jobTemplateArn: Swift.String?
    /// The unique identifier of the job template.
    public var jobTemplateId: Swift.String?
    /// Allows you to configure an optional maintenance window for the rollout of a job document to all devices in the target group for a job.
    public var maintenanceWindows: [IoTClientTypes.MaintenanceWindow]?
    /// Configuration for pre-signed S3 URLs.
    public var presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
    /// Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to TIMED_OUT.
    public var timeoutConfig: IoTClientTypes.TimeoutConfig?

    public init(
        abortConfig: IoTClientTypes.AbortConfig? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        destinationPackageVersions: [Swift.String]? = nil,
        document: Swift.String? = nil,
        documentSource: Swift.String? = nil,
        jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig? = nil,
        jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig? = nil,
        jobTemplateArn: Swift.String? = nil,
        jobTemplateId: Swift.String? = nil,
        maintenanceWindows: [IoTClientTypes.MaintenanceWindow]? = nil,
        presignedUrlConfig: IoTClientTypes.PresignedUrlConfig? = nil,
        timeoutConfig: IoTClientTypes.TimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.createdAt = createdAt
        self.description = description
        self.destinationPackageVersions = destinationPackageVersions
        self.document = document
        self.documentSource = documentSource
        self.jobExecutionsRetryConfig = jobExecutionsRetryConfig
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.jobTemplateArn = jobTemplateArn
        self.jobTemplateId = jobTemplateId
        self.maintenanceWindows = maintenanceWindows
        self.presignedUrlConfig = presignedUrlConfig
        self.timeoutConfig = timeoutConfig
    }
}

public struct DescribeManagedJobTemplateInput {
    /// The unique name of a managed job template, which is required.
    /// This member is required.
    public var templateName: Swift.String?
    /// An optional parameter to specify version of a managed template. If not specified, the pre-defined default version is returned.
    public var templateVersion: Swift.String?

    public init(
        templateName: Swift.String? = nil,
        templateVersion: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.templateVersion = templateVersion
    }
}

extension IoTClientTypes {
    /// A map of key-value pairs containing the patterns that need to be replaced in a managed template job document schema. You can use the description of each key as a guidance to specify the inputs during runtime when creating a job. documentParameters can only be used when creating jobs from Amazon Web Services managed templates. This parameter can't be used with custom job templates or to create jobs from them.
    public struct DocumentParameter {
        /// Description of the map field containing the patterns that need to be replaced in a managed template job document schema.
        public var description: Swift.String?
        /// An example illustrating a pattern that need to be replaced in a managed template job document schema.
        public var example: Swift.String?
        /// Key of the map field containing the patterns that need to be replaced in a managed template job document schema.
        public var key: Swift.String?
        /// Specifies whether a pattern that needs to be replaced in a managed template job document schema is optional or required.
        public var `optional`: Swift.Bool
        /// A regular expression of the patterns that need to be replaced in a managed template job document schema.
        public var regex: Swift.String?

        public init(
            description: Swift.String? = nil,
            example: Swift.String? = nil,
            key: Swift.String? = nil,
            `optional`: Swift.Bool = false,
            regex: Swift.String? = nil
        )
        {
            self.description = description
            self.example = example
            self.key = key
            self.`optional` = `optional`
            self.regex = regex
        }
    }

}

public struct DescribeManagedJobTemplateOutput {
    /// The unique description of a managed template.
    public var description: Swift.String?
    /// The document schema for a managed job template.
    public var document: Swift.String?
    /// A map of key-value pairs that you can use as guidance to specify the inputs for creating a job from a managed template. documentParameters can only be used when creating jobs from Amazon Web Services managed templates. This parameter can't be used with custom job templates or to create jobs from them.
    public var documentParameters: [IoTClientTypes.DocumentParameter]?
    /// A list of environments that are supported with the managed job template.
    public var environments: [Swift.String]?
    /// The unique Amazon Resource Name (ARN) of the managed template.
    public var templateArn: Swift.String?
    /// The unique name of a managed template, such as AWS-Reboot.
    public var templateName: Swift.String?
    /// The version for a managed template.
    public var templateVersion: Swift.String?

    public init(
        description: Swift.String? = nil,
        document: Swift.String? = nil,
        documentParameters: [IoTClientTypes.DocumentParameter]? = nil,
        environments: [Swift.String]? = nil,
        templateArn: Swift.String? = nil,
        templateName: Swift.String? = nil,
        templateVersion: Swift.String? = nil
    )
    {
        self.description = description
        self.document = document
        self.documentParameters = documentParameters
        self.environments = environments
        self.templateArn = templateArn
        self.templateName = templateName
        self.templateVersion = templateVersion
    }
}

public struct DescribeMitigationActionInput {
    /// The friendly name that uniquely identifies the mitigation action.
    /// This member is required.
    public var actionName: Swift.String?

    public init(
        actionName: Swift.String? = nil
    )
    {
        self.actionName = actionName
    }
}

extension IoTClientTypes {

    public enum MitigationActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addThingsToThingGroup
        case enableIotLogging
        case publishFindingToSns
        case replaceDefaultPolicyVersion
        case updateCaCertificate
        case updateDeviceCertificate
        case sdkUnknown(Swift.String)

        public static var allCases: [MitigationActionType] {
            return [
                .addThingsToThingGroup,
                .enableIotLogging,
                .publishFindingToSns,
                .replaceDefaultPolicyVersion,
                .updateCaCertificate,
                .updateDeviceCertificate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addThingsToThingGroup: return "ADD_THINGS_TO_THING_GROUP"
            case .enableIotLogging: return "ENABLE_IOT_LOGGING"
            case .publishFindingToSns: return "PUBLISH_FINDING_TO_SNS"
            case .replaceDefaultPolicyVersion: return "REPLACE_DEFAULT_POLICY_VERSION"
            case .updateCaCertificate: return "UPDATE_CA_CERTIFICATE"
            case .updateDeviceCertificate: return "UPDATE_DEVICE_CERTIFICATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeMitigationActionOutput {
    /// The ARN that identifies this migration action.
    public var actionArn: Swift.String?
    /// A unique identifier for this action.
    public var actionId: Swift.String?
    /// The friendly name that uniquely identifies the mitigation action.
    public var actionName: Swift.String?
    /// Parameters that control how the mitigation action is applied, specific to the type of mitigation action.
    public var actionParams: IoTClientTypes.MitigationActionParams?
    /// The type of mitigation action.
    public var actionType: IoTClientTypes.MitigationActionType?
    /// The date and time when the mitigation action was added to your Amazon Web Services accounts.
    public var creationDate: Foundation.Date?
    /// The date and time when the mitigation action was last changed.
    public var lastModifiedDate: Foundation.Date?
    /// The ARN of the IAM role used to apply this action.
    public var roleArn: Swift.String?

    public init(
        actionArn: Swift.String? = nil,
        actionId: Swift.String? = nil,
        actionName: Swift.String? = nil,
        actionParams: IoTClientTypes.MitigationActionParams? = nil,
        actionType: IoTClientTypes.MitigationActionType? = nil,
        creationDate: Foundation.Date? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.actionArn = actionArn
        self.actionId = actionId
        self.actionName = actionName
        self.actionParams = actionParams
        self.actionType = actionType
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.roleArn = roleArn
    }
}

public struct DescribeProvisioningTemplateInput {
    /// The name of the provisioning template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        templateName: Swift.String? = nil
    )
    {
        self.templateName = templateName
    }
}

public struct DescribeProvisioningTemplateOutput {
    /// The date when the provisioning template was created.
    public var creationDate: Foundation.Date?
    /// The default fleet template version ID.
    public var defaultVersionId: Swift.Int?
    /// The description of the provisioning template.
    public var description: Swift.String?
    /// True if the provisioning template is enabled, otherwise false.
    public var enabled: Swift.Bool?
    /// The date when the provisioning template was last modified.
    public var lastModifiedDate: Foundation.Date?
    /// Gets information about a pre-provisioned hook.
    public var preProvisioningHook: IoTClientTypes.ProvisioningHook?
    /// The ARN of the role associated with the provisioning template. This IoT role grants permission to provision a device.
    public var provisioningRoleArn: Swift.String?
    /// The ARN of the provisioning template.
    public var templateArn: Swift.String?
    /// The JSON formatted contents of the provisioning template.
    public var templateBody: Swift.String?
    /// The name of the provisioning template.
    public var templateName: Swift.String?
    /// The type you define in a provisioning template. You can create a template with only one type. You can't change the template type after its creation. The default value is FLEET_PROVISIONING. For more information about provisioning template, see: [Provisioning template](https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html).
    public var type: IoTClientTypes.TemplateType?

    public init(
        creationDate: Foundation.Date? = nil,
        defaultVersionId: Swift.Int? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        preProvisioningHook: IoTClientTypes.ProvisioningHook? = nil,
        provisioningRoleArn: Swift.String? = nil,
        templateArn: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateName: Swift.String? = nil,
        type: IoTClientTypes.TemplateType? = nil
    )
    {
        self.creationDate = creationDate
        self.defaultVersionId = defaultVersionId
        self.description = description
        self.enabled = enabled
        self.lastModifiedDate = lastModifiedDate
        self.preProvisioningHook = preProvisioningHook
        self.provisioningRoleArn = provisioningRoleArn
        self.templateArn = templateArn
        self.templateBody = templateBody
        self.templateName = templateName
        self.type = type
    }
}

public struct DescribeProvisioningTemplateVersionInput {
    /// The template name.
    /// This member is required.
    public var templateName: Swift.String?
    /// The provisioning template version ID.
    /// This member is required.
    public var versionId: Swift.Int?

    public init(
        templateName: Swift.String? = nil,
        versionId: Swift.Int? = nil
    )
    {
        self.templateName = templateName
        self.versionId = versionId
    }
}

public struct DescribeProvisioningTemplateVersionOutput {
    /// The date when the provisioning template version was created.
    public var creationDate: Foundation.Date?
    /// True if the provisioning template version is the default version.
    public var isDefaultVersion: Swift.Bool
    /// The JSON formatted contents of the provisioning template version.
    public var templateBody: Swift.String?
    /// The provisioning template version ID.
    public var versionId: Swift.Int?

    public init(
        creationDate: Foundation.Date? = nil,
        isDefaultVersion: Swift.Bool = false,
        templateBody: Swift.String? = nil,
        versionId: Swift.Int? = nil
    )
    {
        self.creationDate = creationDate
        self.isDefaultVersion = isDefaultVersion
        self.templateBody = templateBody
        self.versionId = versionId
    }
}

public struct DescribeRoleAliasInput {
    /// The role alias to describe.
    /// This member is required.
    public var roleAlias: Swift.String?

    public init(
        roleAlias: Swift.String? = nil
    )
    {
        self.roleAlias = roleAlias
    }
}

extension IoTClientTypes {
    /// Role alias description.
    public struct RoleAliasDescription {
        /// The UNIX timestamp of when the role alias was created.
        public var creationDate: Foundation.Date?
        /// The number of seconds for which the credential is valid.
        public var credentialDurationSeconds: Swift.Int?
        /// The UNIX timestamp of when the role alias was last modified.
        public var lastModifiedDate: Foundation.Date?
        /// The role alias owner.
        public var owner: Swift.String?
        /// The role alias.
        public var roleAlias: Swift.String?
        /// The ARN of the role alias.
        public var roleAliasArn: Swift.String?
        /// The role ARN.
        public var roleArn: Swift.String?

        public init(
            creationDate: Foundation.Date? = nil,
            credentialDurationSeconds: Swift.Int? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            owner: Swift.String? = nil,
            roleAlias: Swift.String? = nil,
            roleAliasArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.credentialDurationSeconds = credentialDurationSeconds
            self.lastModifiedDate = lastModifiedDate
            self.owner = owner
            self.roleAlias = roleAlias
            self.roleAliasArn = roleAliasArn
            self.roleArn = roleArn
        }
    }

}

public struct DescribeRoleAliasOutput {
    /// The role alias description.
    public var roleAliasDescription: IoTClientTypes.RoleAliasDescription?

    public init(
        roleAliasDescription: IoTClientTypes.RoleAliasDescription? = nil
    )
    {
        self.roleAliasDescription = roleAliasDescription
    }
}

public struct DescribeScheduledAuditInput {
    /// The name of the scheduled audit whose information you want to get.
    /// This member is required.
    public var scheduledAuditName: Swift.String?

    public init(
        scheduledAuditName: Swift.String? = nil
    )
    {
        self.scheduledAuditName = scheduledAuditName
    }
}

public struct DescribeScheduledAuditOutput {
    /// The day of the month on which the scheduled audit takes place. This is will be 1 through 31 or LAST. If days 29-31 are specified, and the month does not have that many days, the audit takes place on the LAST day of the month.
    public var dayOfMonth: Swift.String?
    /// The day of the week on which the scheduled audit takes place, either one of SUN, MON, TUE, WED, THU, FRI, or SAT.
    public var dayOfWeek: IoTClientTypes.DayOfWeek?
    /// How often the scheduled audit takes place, either one of DAILY, WEEKLY, BIWEEKLY, or MONTHLY. The start time of each audit is determined by the system.
    public var frequency: IoTClientTypes.AuditFrequency?
    /// The ARN of the scheduled audit.
    public var scheduledAuditArn: Swift.String?
    /// The name of the scheduled audit.
    public var scheduledAuditName: Swift.String?
    /// Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    public var targetCheckNames: [Swift.String]?

    public init(
        dayOfMonth: Swift.String? = nil,
        dayOfWeek: IoTClientTypes.DayOfWeek? = nil,
        frequency: IoTClientTypes.AuditFrequency? = nil,
        scheduledAuditArn: Swift.String? = nil,
        scheduledAuditName: Swift.String? = nil,
        targetCheckNames: [Swift.String]? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.frequency = frequency
        self.scheduledAuditArn = scheduledAuditArn
        self.scheduledAuditName = scheduledAuditName
        self.targetCheckNames = targetCheckNames
    }
}

public struct DescribeSecurityProfileInput {
    /// The name of the security profile whose information you want to get.
    /// This member is required.
    public var securityProfileName: Swift.String?

    public init(
        securityProfileName: Swift.String? = nil
    )
    {
        self.securityProfileName = securityProfileName
    }
}

public struct DescribeSecurityProfileOutput {
    /// Please use [DescribeSecurityProfileResponse$additionalMetricsToRetainV2] instead. A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here.
    @available(*, deprecated, message: "Use additionalMetricsToRetainV2.")
    public var additionalMetricsToRetain: [Swift.String]?
    /// A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here.
    public var additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]?
    /// Where the alerts are sent. (Alerts are always sent to the console.)
    public var alertTargets: [Swift.String: IoTClientTypes.AlertTarget]?
    /// Specifies the behaviors that, when violated by a device (thing), cause an alert.
    public var behaviors: [IoTClientTypes.Behavior]?
    /// The time the security profile was created.
    public var creationDate: Foundation.Date?
    /// The time the security profile was last modified.
    public var lastModifiedDate: Foundation.Date?
    /// Specifies the MQTT topic and role ARN required for metric export.
    public var metricsExportConfig: IoTClientTypes.MetricsExportConfig?
    /// The ARN of the security profile.
    public var securityProfileArn: Swift.String?
    /// A description of the security profile (associated with the security profile when it was created or updated).
    public var securityProfileDescription: Swift.String?
    /// The name of the security profile.
    public var securityProfileName: Swift.String?
    /// The version of the security profile. A new version is generated whenever the security profile is updated.
    public var version: Swift.Int

    public init(
        additionalMetricsToRetain: [Swift.String]? = nil,
        additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]? = nil,
        alertTargets: [Swift.String: IoTClientTypes.AlertTarget]? = nil,
        behaviors: [IoTClientTypes.Behavior]? = nil,
        creationDate: Foundation.Date? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        metricsExportConfig: IoTClientTypes.MetricsExportConfig? = nil,
        securityProfileArn: Swift.String? = nil,
        securityProfileDescription: Swift.String? = nil,
        securityProfileName: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.additionalMetricsToRetain = additionalMetricsToRetain
        self.additionalMetricsToRetainV2 = additionalMetricsToRetainV2
        self.alertTargets = alertTargets
        self.behaviors = behaviors
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.metricsExportConfig = metricsExportConfig
        self.securityProfileArn = securityProfileArn
        self.securityProfileDescription = securityProfileDescription
        self.securityProfileName = securityProfileName
        self.version = version
    }
}

public struct DescribeStreamInput {
    /// The stream ID.
    /// This member is required.
    public var streamId: Swift.String?

    public init(
        streamId: Swift.String? = nil
    )
    {
        self.streamId = streamId
    }
}

extension IoTClientTypes {
    /// Information about a stream.
    public struct StreamInfo {
        /// The date when the stream was created.
        public var createdAt: Foundation.Date?
        /// The description of the stream.
        public var description: Swift.String?
        /// The files to stream.
        public var files: [IoTClientTypes.StreamFile]?
        /// The date when the stream was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// An IAM role IoT assumes to access your S3 files.
        public var roleArn: Swift.String?
        /// The stream ARN.
        public var streamArn: Swift.String?
        /// The stream ID.
        public var streamId: Swift.String?
        /// The stream version.
        public var streamVersion: Swift.Int?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            files: [IoTClientTypes.StreamFile]? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            roleArn: Swift.String? = nil,
            streamArn: Swift.String? = nil,
            streamId: Swift.String? = nil,
            streamVersion: Swift.Int? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.files = files
            self.lastUpdatedAt = lastUpdatedAt
            self.roleArn = roleArn
            self.streamArn = streamArn
            self.streamId = streamId
            self.streamVersion = streamVersion
        }
    }

}

public struct DescribeStreamOutput {
    /// Information about the stream.
    public var streamInfo: IoTClientTypes.StreamInfo?

    public init(
        streamInfo: IoTClientTypes.StreamInfo? = nil
    )
    {
        self.streamInfo = streamInfo
    }
}

/// The input for the DescribeThing operation.
public struct DescribeThingInput {
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        thingName: Swift.String? = nil
    )
    {
        self.thingName = thingName
    }
}

/// The output from the DescribeThing operation.
public struct DescribeThingOutput {
    /// The thing attributes.
    public var attributes: [Swift.String: Swift.String]?
    /// The name of the billing group the thing belongs to.
    public var billingGroupName: Swift.String?
    /// The default MQTT client ID. For a typical device, the thing name is also used as the default MQTT client ID. Although we don’t require a mapping between a thing's registry name and its use of MQTT client IDs, certificates, or shadow state, we recommend that you choose a thing name and use it as the MQTT client ID for the registry and the Device Shadow service. This lets you better organize your IoT fleet without removing the flexibility of the underlying device certificate model or shadows.
    public var defaultClientId: Swift.String?
    /// The ARN of the thing to describe.
    public var thingArn: Swift.String?
    /// The ID of the thing to describe.
    public var thingId: Swift.String?
    /// The name of the thing.
    public var thingName: Swift.String?
    /// The thing type name.
    public var thingTypeName: Swift.String?
    /// The current version of the thing record in the registry. To avoid unintentional changes to the information in the registry, you can pass the version information in the expectedVersion parameter of the UpdateThing and DeleteThing calls.
    public var version: Swift.Int

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        billingGroupName: Swift.String? = nil,
        defaultClientId: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        thingId: Swift.String? = nil,
        thingName: Swift.String? = nil,
        thingTypeName: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.attributes = attributes
        self.billingGroupName = billingGroupName
        self.defaultClientId = defaultClientId
        self.thingArn = thingArn
        self.thingId = thingId
        self.thingName = thingName
        self.thingTypeName = thingTypeName
        self.version = version
    }
}

public struct DescribeThingGroupInput {
    /// The name of the thing group.
    /// This member is required.
    public var thingGroupName: Swift.String?

    public init(
        thingGroupName: Swift.String? = nil
    )
    {
        self.thingGroupName = thingGroupName
    }
}

extension IoTClientTypes {

    public enum DynamicGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case building
        case rebuilding
        case sdkUnknown(Swift.String)

        public static var allCases: [DynamicGroupStatus] {
            return [
                .active,
                .building,
                .rebuilding
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .building: return "BUILDING"
            case .rebuilding: return "REBUILDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The name and ARN of a group.
    public struct GroupNameAndArn {
        /// The group ARN.
        public var groupArn: Swift.String?
        /// The group name.
        public var groupName: Swift.String?

        public init(
            groupArn: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupArn = groupArn
            self.groupName = groupName
        }
    }

}

extension IoTClientTypes {
    /// Thing group metadata.
    public struct ThingGroupMetadata {
        /// The UNIX timestamp of when the thing group was created.
        public var creationDate: Foundation.Date?
        /// The parent thing group name.
        public var parentGroupName: Swift.String?
        /// The root parent thing group.
        public var rootToParentThingGroups: [IoTClientTypes.GroupNameAndArn]?

        public init(
            creationDate: Foundation.Date? = nil,
            parentGroupName: Swift.String? = nil,
            rootToParentThingGroups: [IoTClientTypes.GroupNameAndArn]? = nil
        )
        {
            self.creationDate = creationDate
            self.parentGroupName = parentGroupName
            self.rootToParentThingGroups = rootToParentThingGroups
        }
    }

}

public struct DescribeThingGroupOutput {
    /// The dynamic thing group index name.
    public var indexName: Swift.String?
    /// The dynamic thing group search query string.
    public var queryString: Swift.String?
    /// The dynamic thing group query version.
    public var queryVersion: Swift.String?
    /// The dynamic thing group status.
    public var status: IoTClientTypes.DynamicGroupStatus?
    /// The thing group ARN.
    public var thingGroupArn: Swift.String?
    /// The thing group ID.
    public var thingGroupId: Swift.String?
    /// Thing group metadata.
    public var thingGroupMetadata: IoTClientTypes.ThingGroupMetadata?
    /// The name of the thing group.
    public var thingGroupName: Swift.String?
    /// The thing group properties.
    public var thingGroupProperties: IoTClientTypes.ThingGroupProperties?
    /// The version of the thing group.
    public var version: Swift.Int

    public init(
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        status: IoTClientTypes.DynamicGroupStatus? = nil,
        thingGroupArn: Swift.String? = nil,
        thingGroupId: Swift.String? = nil,
        thingGroupMetadata: IoTClientTypes.ThingGroupMetadata? = nil,
        thingGroupName: Swift.String? = nil,
        thingGroupProperties: IoTClientTypes.ThingGroupProperties? = nil,
        version: Swift.Int = 0
    )
    {
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.status = status
        self.thingGroupArn = thingGroupArn
        self.thingGroupId = thingGroupId
        self.thingGroupMetadata = thingGroupMetadata
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
        self.version = version
    }
}

public struct DescribeThingRegistrationTaskInput {
    /// The task ID.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

extension IoTClientTypes {

    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case failed
        case inprogress
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .inprogress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeThingRegistrationTaskOutput {
    /// The task creation date.
    public var creationDate: Foundation.Date?
    /// The number of things that failed to be provisioned.
    public var failureCount: Swift.Int
    /// The S3 bucket that contains the input file.
    public var inputFileBucket: Swift.String?
    /// The input file key.
    public var inputFileKey: Swift.String?
    /// The date when the task was last modified.
    public var lastModifiedDate: Foundation.Date?
    /// The message.
    public var message: Swift.String?
    /// The progress of the bulk provisioning task expressed as a percentage.
    public var percentageProgress: Swift.Int
    /// The role ARN that grants access to the input file bucket.
    public var roleArn: Swift.String?
    /// The status of the bulk thing provisioning task.
    public var status: IoTClientTypes.Status?
    /// The number of things successfully provisioned.
    public var successCount: Swift.Int
    /// The task ID.
    public var taskId: Swift.String?
    /// The task's template.
    public var templateBody: Swift.String?

    public init(
        creationDate: Foundation.Date? = nil,
        failureCount: Swift.Int = 0,
        inputFileBucket: Swift.String? = nil,
        inputFileKey: Swift.String? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        message: Swift.String? = nil,
        percentageProgress: Swift.Int = 0,
        roleArn: Swift.String? = nil,
        status: IoTClientTypes.Status? = nil,
        successCount: Swift.Int = 0,
        taskId: Swift.String? = nil,
        templateBody: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.failureCount = failureCount
        self.inputFileBucket = inputFileBucket
        self.inputFileKey = inputFileKey
        self.lastModifiedDate = lastModifiedDate
        self.message = message
        self.percentageProgress = percentageProgress
        self.roleArn = roleArn
        self.status = status
        self.successCount = successCount
        self.taskId = taskId
        self.templateBody = templateBody
    }
}

/// The input for the DescribeThingType operation.
public struct DescribeThingTypeInput {
    /// The name of the thing type.
    /// This member is required.
    public var thingTypeName: Swift.String?

    public init(
        thingTypeName: Swift.String? = nil
    )
    {
        self.thingTypeName = thingTypeName
    }
}

extension IoTClientTypes {
    /// The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when time was deprecated.
    public struct ThingTypeMetadata {
        /// The date and time when the thing type was created.
        public var creationDate: Foundation.Date?
        /// Whether the thing type is deprecated. If true, no new things could be associated with this type.
        public var deprecated: Swift.Bool
        /// The date and time when the thing type was deprecated.
        public var deprecationDate: Foundation.Date?

        public init(
            creationDate: Foundation.Date? = nil,
            deprecated: Swift.Bool = false,
            deprecationDate: Foundation.Date? = nil
        )
        {
            self.creationDate = creationDate
            self.deprecated = deprecated
            self.deprecationDate = deprecationDate
        }
    }

}

/// The output for the DescribeThingType operation.
public struct DescribeThingTypeOutput {
    /// The thing type ARN.
    public var thingTypeArn: Swift.String?
    /// The thing type ID.
    public var thingTypeId: Swift.String?
    /// The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when it was deprecated.
    public var thingTypeMetadata: IoTClientTypes.ThingTypeMetadata?
    /// The name of the thing type.
    public var thingTypeName: Swift.String?
    /// The ThingTypeProperties contains information about the thing type including description, and a list of searchable thing attribute names.
    public var thingTypeProperties: IoTClientTypes.ThingTypeProperties?

    public init(
        thingTypeArn: Swift.String? = nil,
        thingTypeId: Swift.String? = nil,
        thingTypeMetadata: IoTClientTypes.ThingTypeMetadata? = nil,
        thingTypeName: Swift.String? = nil,
        thingTypeProperties: IoTClientTypes.ThingTypeProperties? = nil
    )
    {
        self.thingTypeArn = thingTypeArn
        self.thingTypeId = thingTypeId
        self.thingTypeMetadata = thingTypeMetadata
        self.thingTypeName = thingTypeName
        self.thingTypeProperties = thingTypeProperties
    }
}

public struct DetachPolicyInput {
    /// The policy to detach.
    /// This member is required.
    public var policyName: Swift.String?
    /// The target from which the policy will be detached.
    /// This member is required.
    public var target: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.target = target
    }
}

/// The input for the DetachPrincipalPolicy operation.
public struct DetachPrincipalPolicyInput {
    /// The name of the policy to detach.
    /// This member is required.
    public var policyName: Swift.String?
    /// The principal. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    /// This member is required.
    public var principal: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        principal: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.principal = principal
    }
}

public struct DetachSecurityProfileInput {
    /// The security profile that is detached.
    /// This member is required.
    public var securityProfileName: Swift.String?
    /// The ARN of the thing group from which the security profile is detached.
    /// This member is required.
    public var securityProfileTargetArn: Swift.String?

    public init(
        securityProfileName: Swift.String? = nil,
        securityProfileTargetArn: Swift.String? = nil
    )
    {
        self.securityProfileName = securityProfileName
        self.securityProfileTargetArn = securityProfileTargetArn
    }
}

public struct DetachSecurityProfileOutput {

    public init() { }
}

/// The input for the DetachThingPrincipal operation.
public struct DetachThingPrincipalInput {
    /// If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.
    /// This member is required.
    public var principal: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        principal: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.principal = principal
        self.thingName = thingName
    }
}

/// The output from the DetachThingPrincipal operation.
public struct DetachThingPrincipalOutput {

    public init() { }
}

/// The input for the DisableTopicRuleRequest operation.
public struct DisableTopicRuleInput {
    /// The name of the rule to disable.
    /// This member is required.
    public var ruleName: Swift.String?

    public init(
        ruleName: Swift.String? = nil
    )
    {
        self.ruleName = ruleName
    }
}

public struct DisassociateSbomFromPackageVersionInput {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The name of the new software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The name of the new package version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        packageName: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.packageName = packageName
        self.versionName = versionName
    }
}

public struct DisassociateSbomFromPackageVersionOutput {

    public init() { }
}

/// The input for the EnableTopicRuleRequest operation.
public struct EnableTopicRuleInput {
    /// The name of the topic rule to enable.
    /// This member is required.
    public var ruleName: Swift.String?

    public init(
        ruleName: Swift.String? = nil
    )
    {
        self.ruleName = ruleName
    }
}

public struct GetBehaviorModelTrainingSummariesInput {
    /// The maximum number of results to return at one time. The default is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The name of the security profile.
    public var securityProfileName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfileName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileName = securityProfileName
    }
}

extension IoTClientTypes {

    public enum ModelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case expired
        case pendingBuild
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelStatus] {
            return [
                .active,
                .expired,
                .pendingBuild
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .expired: return "EXPIRED"
            case .pendingBuild: return "PENDING_BUILD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The summary of an ML Detect behavior model.
    public struct BehaviorModelTrainingSummary {
        /// The name of the behavior.
        public var behaviorName: Swift.String?
        /// The percentage of datapoints collected.
        public var datapointsCollectionPercentage: Swift.Double?
        /// The date the model was last refreshed.
        public var lastModelRefreshDate: Foundation.Date?
        /// The status of the behavior model.
        public var modelStatus: IoTClientTypes.ModelStatus?
        /// The name of the security profile.
        public var securityProfileName: Swift.String?
        /// The date a training model started collecting data.
        public var trainingDataCollectionStartDate: Foundation.Date?

        public init(
            behaviorName: Swift.String? = nil,
            datapointsCollectionPercentage: Swift.Double? = nil,
            lastModelRefreshDate: Foundation.Date? = nil,
            modelStatus: IoTClientTypes.ModelStatus? = nil,
            securityProfileName: Swift.String? = nil,
            trainingDataCollectionStartDate: Foundation.Date? = nil
        )
        {
            self.behaviorName = behaviorName
            self.datapointsCollectionPercentage = datapointsCollectionPercentage
            self.lastModelRefreshDate = lastModelRefreshDate
            self.modelStatus = modelStatus
            self.securityProfileName = securityProfileName
            self.trainingDataCollectionStartDate = trainingDataCollectionStartDate
        }
    }

}

public struct GetBehaviorModelTrainingSummariesOutput {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of all ML Detect behaviors and their model status for a given Security Profile.
    public var summaries: [IoTClientTypes.BehaviorModelTrainingSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTClientTypes.BehaviorModelTrainingSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

extension IoTClientTypes {
    /// Performs an aggregation that will return a list of buckets. The list of buckets is a ranked list of the number of occurrences of an aggregation field value.
    public struct TermsAggregation {
        /// The number of buckets to return in the response. Default to 10.
        public var maxBuckets: Swift.Int?

        public init(
            maxBuckets: Swift.Int? = nil
        )
        {
            self.maxBuckets = maxBuckets
        }
    }

}

extension IoTClientTypes {
    /// The type of bucketed aggregation performed.
    public struct BucketsAggregationType {
        /// Performs an aggregation that will return a list of buckets. The list of buckets is a ranked list of the number of occurrences of an aggregation field value.
        public var termsAggregation: IoTClientTypes.TermsAggregation?

        public init(
            termsAggregation: IoTClientTypes.TermsAggregation? = nil
        )
        {
            self.termsAggregation = termsAggregation
        }
    }

}

public struct GetBucketsAggregationInput {
    /// The aggregation field.
    /// This member is required.
    public var aggregationField: Swift.String?
    /// The basic control of the response shape and the bucket aggregation type to perform.
    /// This member is required.
    public var bucketsAggregationType: IoTClientTypes.BucketsAggregationType?
    /// The name of the index to search.
    public var indexName: Swift.String?
    /// The search query string.
    /// This member is required.
    public var queryString: Swift.String?
    /// The version of the query.
    public var queryVersion: Swift.String?

    public init(
        aggregationField: Swift.String? = nil,
        bucketsAggregationType: IoTClientTypes.BucketsAggregationType? = nil,
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil
    )
    {
        self.aggregationField = aggregationField
        self.bucketsAggregationType = bucketsAggregationType
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

extension IoTClientTypes {
    /// A count of documents that meets a specific aggregation criteria.
    public struct Bucket {
        /// The number of documents that have the value counted for the particular bucket.
        public var count: Swift.Int
        /// The value counted for the particular bucket.
        public var keyValue: Swift.String?

        public init(
            count: Swift.Int = 0,
            keyValue: Swift.String? = nil
        )
        {
            self.count = count
            self.keyValue = keyValue
        }
    }

}

public struct GetBucketsAggregationOutput {
    /// The main part of the response with a list of buckets. Each bucket contains a keyValue and a count. keyValue: The aggregation field value counted for the particular bucket. count: The number of documents that have that value.
    public var buckets: [IoTClientTypes.Bucket]?
    /// The total number of things that fit the query string criteria.
    public var totalCount: Swift.Int

    public init(
        buckets: [IoTClientTypes.Bucket]? = nil,
        totalCount: Swift.Int = 0
    )
    {
        self.buckets = buckets
        self.totalCount = totalCount
    }
}

public struct GetCardinalityInput {
    /// The field to aggregate.
    public var aggregationField: Swift.String?
    /// The name of the index to search.
    public var indexName: Swift.String?
    /// The search query string.
    /// This member is required.
    public var queryString: Swift.String?
    /// The query version.
    public var queryVersion: Swift.String?

    public init(
        aggregationField: Swift.String? = nil,
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil
    )
    {
        self.aggregationField = aggregationField
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

public struct GetCardinalityOutput {
    /// The approximate count of unique values that match the query.
    public var cardinality: Swift.Int

    public init(
        cardinality: Swift.Int = 0
    )
    {
        self.cardinality = cardinality
    }
}

public struct GetEffectivePoliciesInput {
    /// The Cognito identity pool ID.
    public var cognitoIdentityPoolId: Swift.String?
    /// The principal. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    public var principal: Swift.String?
    /// The thing name.
    public var thingName: Swift.String?

    public init(
        cognitoIdentityPoolId: Swift.String? = nil,
        principal: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.cognitoIdentityPoolId = cognitoIdentityPoolId
        self.principal = principal
        self.thingName = thingName
    }
}

extension IoTClientTypes {
    /// The policy that has the effect on the authorization results.
    public struct EffectivePolicy {
        /// The policy ARN.
        public var policyArn: Swift.String?
        /// The IAM policy document.
        public var policyDocument: Swift.String?
        /// The policy name.
        public var policyName: Swift.String?

        public init(
            policyArn: Swift.String? = nil,
            policyDocument: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyArn = policyArn
            self.policyDocument = policyDocument
            self.policyName = policyName
        }
    }

}

public struct GetEffectivePoliciesOutput {
    /// The effective policies.
    public var effectivePolicies: [IoTClientTypes.EffectivePolicy]?

    public init(
        effectivePolicies: [IoTClientTypes.EffectivePolicy]? = nil
    )
    {
        self.effectivePolicies = effectivePolicies
    }
}

public struct GetIndexingConfigurationInput {

    public init() { }
}

extension IoTClientTypes {

    public enum FieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case boolean
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldType] {
            return [
                .boolean,
                .number,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "Boolean"
            case .number: return "Number"
            case .string: return "String"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Describes the name and data type at a field.
    public struct Field {
        /// The name of the field.
        public var name: Swift.String?
        /// The data type of the field.
        public var type: IoTClientTypes.FieldType?

        public init(
            name: Swift.String? = nil,
            type: IoTClientTypes.FieldType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension IoTClientTypes {

    public enum ThingGroupIndexingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [ThingGroupIndexingMode] {
            return [
                .off,
                .on
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .on: return "ON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Thing group indexing configuration.
    public struct ThingGroupIndexingConfiguration {
        /// A list of thing group fields to index. This list cannot contain any managed fields. Use the GetIndexingConfiguration API to get a list of managed fields. Contains custom field names and their data type.
        public var customFields: [IoTClientTypes.Field]?
        /// Contains fields that are indexed and whose types are already known by the Fleet Indexing service. This is an optional field. For more information, see [Managed fields](https://docs.aws.amazon.com/iot/latest/developerguide/managing-fleet-index.html#managed-field) in the Amazon Web Services IoT Core Developer Guide. You can't modify managed fields by updating fleet indexing configuration.
        public var managedFields: [IoTClientTypes.Field]?
        /// Thing group indexing mode.
        /// This member is required.
        public var thingGroupIndexingMode: IoTClientTypes.ThingGroupIndexingMode?

        public init(
            customFields: [IoTClientTypes.Field]? = nil,
            managedFields: [IoTClientTypes.Field]? = nil,
            thingGroupIndexingMode: IoTClientTypes.ThingGroupIndexingMode? = nil
        )
        {
            self.customFields = customFields
            self.managedFields = managedFields
            self.thingGroupIndexingMode = thingGroupIndexingMode
        }
    }

}

extension IoTClientTypes {

    public enum DeviceDefenderIndexingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case violations
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceDefenderIndexingMode] {
            return [
                .off,
                .violations
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .violations: return "VIOLATIONS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {

    public enum TargetFieldOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case latlon
        case lonlat
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetFieldOrder] {
            return [
                .latlon,
                .lonlat
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .latlon: return "LatLon"
            case .lonlat: return "LonLat"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// A geolocation target that you select to index. Each geolocation target contains a name and order key-value pair that specifies the geolocation target fields.
    public struct GeoLocationTarget {
        /// The name of the geolocation target field. If the target field is part of a named shadow, you must select the named shadow using the namedShadow filter.
        public var name: Swift.String?
        /// The order of the geolocation target field. This field is optional. The default value is LatLon.
        public var order: IoTClientTypes.TargetFieldOrder?

        public init(
            name: Swift.String? = nil,
            order: IoTClientTypes.TargetFieldOrder? = nil
        )
        {
            self.name = name
            self.order = order
        }
    }

}

extension IoTClientTypes {
    /// Provides additional selections for named shadows and geolocation data. To add named shadows to your fleet indexing configuration, set namedShadowIndexingMode to be ON and specify your shadow names in namedShadowNames filter. To add geolocation data to your fleet indexing configuration:
    ///
    /// * If you store geolocation data in a class/unnamed shadow, set thingIndexingMode to be REGISTRY_AND_SHADOW and specify your geolocation data in geoLocations filter.
    ///
    /// * If you store geolocation data in a named shadow, set namedShadowIndexingMode to be ON, add the shadow name in namedShadowNames filter, and specify your geolocation data in geoLocations filter. For more information, see [Managing fleet indexing](https://docs.aws.amazon.com/iot/latest/developerguide/managing-fleet-index.html).
    public struct IndexingFilter {
        /// The list of geolocation targets that you select to index. The default maximum number of geolocation targets for indexing is 1. To increase the limit, see [Amazon Web Services IoT Device Management Quotas](https://docs.aws.amazon.com/general/latest/gr/iot_device_management.html#fleet-indexing-limits) in the Amazon Web Services General Reference.
        public var geoLocations: [IoTClientTypes.GeoLocationTarget]?
        /// The shadow names that you select to index. The default maximum number of shadow names for indexing is 10. To increase the limit, see [Amazon Web Services IoT Device Management Quotas](https://docs.aws.amazon.com/general/latest/gr/iot_device_management.html#fleet-indexing-limits) in the Amazon Web Services General Reference.
        public var namedShadowNames: [Swift.String]?

        public init(
            geoLocations: [IoTClientTypes.GeoLocationTarget]? = nil,
            namedShadowNames: [Swift.String]? = nil
        )
        {
            self.geoLocations = geoLocations
            self.namedShadowNames = namedShadowNames
        }
    }

}

extension IoTClientTypes {

    public enum NamedShadowIndexingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [NamedShadowIndexingMode] {
            return [
                .off,
                .on
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .on: return "ON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {

    public enum ThingConnectivityIndexingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [ThingConnectivityIndexingMode] {
            return [
                .off,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {

    public enum ThingIndexingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case registry
        case registryAndShadow
        case sdkUnknown(Swift.String)

        public static var allCases: [ThingIndexingMode] {
            return [
                .off,
                .registry,
                .registryAndShadow
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .registry: return "REGISTRY"
            case .registryAndShadow: return "REGISTRY_AND_SHADOW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// The thing indexing configuration. For more information, see [Managing Thing Indexing](https://docs.aws.amazon.com/iot/latest/developerguide/managing-index.html).
    public struct ThingIndexingConfiguration {
        /// Contains custom field names and their data type.
        public var customFields: [IoTClientTypes.Field]?
        /// Device Defender indexing mode. Valid values are:
        ///
        /// * VIOLATIONS – Your thing index contains Device Defender violations. To enable Device Defender indexing, deviceDefenderIndexingMode must not be set to OFF.
        ///
        /// * OFF - Device Defender indexing is disabled.
        ///
        ///
        /// For more information about Device Defender violations, see [Device Defender Detect.](https://docs.aws.amazon.com/iot/latest/developerguide/device-defender-detect.html)
        public var deviceDefenderIndexingMode: IoTClientTypes.DeviceDefenderIndexingMode?
        /// Provides additional selections for named shadows and geolocation data. To add named shadows to your fleet indexing configuration, set namedShadowIndexingMode to be ON and specify your shadow names in namedShadowNames filter. To add geolocation data to your fleet indexing configuration:
        ///
        /// * If you store geolocation data in a class/unnamed shadow, set thingIndexingMode to be REGISTRY_AND_SHADOW and specify your geolocation data in geoLocations filter.
        ///
        /// * If you store geolocation data in a named shadow, set namedShadowIndexingMode to be ON, add the shadow name in namedShadowNames filter, and specify your geolocation data in geoLocations filter. For more information, see [Managing fleet indexing](https://docs.aws.amazon.com/iot/latest/developerguide/managing-fleet-index.html).
        public var filter: IoTClientTypes.IndexingFilter?
        /// Contains fields that are indexed and whose types are already known by the Fleet Indexing service. This is an optional field. For more information, see [Managed fields](https://docs.aws.amazon.com/iot/latest/developerguide/managing-fleet-index.html#managed-field) in the Amazon Web Services IoT Core Developer Guide. You can't modify managed fields by updating fleet indexing configuration.
        public var managedFields: [IoTClientTypes.Field]?
        /// Named shadow indexing mode. Valid values are:
        ///
        /// * ON – Your thing index contains named shadow. To enable thing named shadow indexing, namedShadowIndexingMode must not be set to OFF.
        ///
        /// * OFF - Named shadow indexing is disabled.
        ///
        ///
        /// For more information about Shadows, see [IoT Device Shadow service.](https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html)
        public var namedShadowIndexingMode: IoTClientTypes.NamedShadowIndexingMode?
        /// Thing connectivity indexing mode. Valid values are:
        ///
        /// * STATUS – Your thing index contains connectivity status. To enable thing connectivity indexing, thingIndexMode must not be set to OFF.
        ///
        /// * OFF - Thing connectivity status indexing is disabled.
        public var thingConnectivityIndexingMode: IoTClientTypes.ThingConnectivityIndexingMode?
        /// Thing indexing mode. Valid values are:
        ///
        /// * REGISTRY – Your thing index contains registry data only.
        ///
        /// * REGISTRY_AND_SHADOW - Your thing index contains registry and shadow data.
        ///
        /// * OFF - Thing indexing is disabled.
        /// This member is required.
        public var thingIndexingMode: IoTClientTypes.ThingIndexingMode?

        public init(
            customFields: [IoTClientTypes.Field]? = nil,
            deviceDefenderIndexingMode: IoTClientTypes.DeviceDefenderIndexingMode? = nil,
            filter: IoTClientTypes.IndexingFilter? = nil,
            managedFields: [IoTClientTypes.Field]? = nil,
            namedShadowIndexingMode: IoTClientTypes.NamedShadowIndexingMode? = nil,
            thingConnectivityIndexingMode: IoTClientTypes.ThingConnectivityIndexingMode? = nil,
            thingIndexingMode: IoTClientTypes.ThingIndexingMode? = nil
        )
        {
            self.customFields = customFields
            self.deviceDefenderIndexingMode = deviceDefenderIndexingMode
            self.filter = filter
            self.managedFields = managedFields
            self.namedShadowIndexingMode = namedShadowIndexingMode
            self.thingConnectivityIndexingMode = thingConnectivityIndexingMode
            self.thingIndexingMode = thingIndexingMode
        }
    }

}

public struct GetIndexingConfigurationOutput {
    /// The index configuration.
    public var thingGroupIndexingConfiguration: IoTClientTypes.ThingGroupIndexingConfiguration?
    /// Thing indexing configuration.
    public var thingIndexingConfiguration: IoTClientTypes.ThingIndexingConfiguration?

    public init(
        thingGroupIndexingConfiguration: IoTClientTypes.ThingGroupIndexingConfiguration? = nil,
        thingIndexingConfiguration: IoTClientTypes.ThingIndexingConfiguration? = nil
    )
    {
        self.thingGroupIndexingConfiguration = thingGroupIndexingConfiguration
        self.thingIndexingConfiguration = thingIndexingConfiguration
    }
}

public struct GetJobDocumentInput {
    /// A flag that provides a view of the job document before and after the substitution parameters have been resolved with their exact values.
    public var beforeSubstitution: Swift.Bool?
    /// The unique identifier you assigned to this job when it was created.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        beforeSubstitution: Swift.Bool? = false,
        jobId: Swift.String? = nil
    )
    {
        self.beforeSubstitution = beforeSubstitution
        self.jobId = jobId
    }
}

public struct GetJobDocumentOutput {
    /// The job document content.
    public var document: Swift.String?

    public init(
        document: Swift.String? = nil
    )
    {
        self.document = document
    }
}

/// The input for the GetLoggingOptions operation.
public struct GetLoggingOptionsInput {

    public init() { }
}

/// The output from the GetLoggingOptions operation.
public struct GetLoggingOptionsOutput {
    /// The logging level.
    public var logLevel: IoTClientTypes.LogLevel?
    /// The ARN of the IAM role that grants access.
    public var roleArn: Swift.String?

    public init(
        logLevel: IoTClientTypes.LogLevel? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.logLevel = logLevel
        self.roleArn = roleArn
    }
}

public struct GetOTAUpdateInput {
    /// The OTA update ID.
    /// This member is required.
    public var otaUpdateId: Swift.String?

    public init(
        otaUpdateId: Swift.String? = nil
    )
    {
        self.otaUpdateId = otaUpdateId
    }
}

extension IoTClientTypes {
    /// Error information.
    public struct ErrorInfo {
        /// The error code.
        public var code: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IoTClientTypes {
    /// Information about an OTA update.
    public struct OTAUpdateInfo {
        /// A collection of name/value pairs
        public var additionalParameters: [Swift.String: Swift.String]?
        /// The IoT job ARN associated with the OTA update.
        public var awsIotJobArn: Swift.String?
        /// The IoT job ID associated with the OTA update.
        public var awsIotJobId: Swift.String?
        /// Configuration for the rollout of OTA updates.
        public var awsJobExecutionsRolloutConfig: IoTClientTypes.AwsJobExecutionsRolloutConfig?
        /// Configuration information for pre-signed URLs. Valid when protocols contains HTTP.
        public var awsJobPresignedUrlConfig: IoTClientTypes.AwsJobPresignedUrlConfig?
        /// The date when the OTA update was created.
        public var creationDate: Foundation.Date?
        /// A description of the OTA update.
        public var description: Swift.String?
        /// Error information associated with the OTA update.
        public var errorInfo: IoTClientTypes.ErrorInfo?
        /// The date when the OTA update was last updated.
        public var lastModifiedDate: Foundation.Date?
        /// The OTA update ARN.
        public var otaUpdateArn: Swift.String?
        /// A list of files associated with the OTA update.
        public var otaUpdateFiles: [IoTClientTypes.OTAUpdateFile]?
        /// The OTA update ID.
        public var otaUpdateId: Swift.String?
        /// The status of the OTA update.
        public var otaUpdateStatus: IoTClientTypes.OTAUpdateStatus?
        /// The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.
        public var protocols: [IoTClientTypes.ModelProtocol]?
        /// Specifies whether the OTA update will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the OTA update (SNAPSHOT). If continuous, the OTA update may also be run on a thing when a change is detected in a target. For example, an OTA update will run on a thing when the thing is added to a target group, even after the OTA update was completed by all things originally in the group.
        public var targetSelection: IoTClientTypes.TargetSelection?
        /// The targets of the OTA update.
        public var targets: [Swift.String]?

        public init(
            additionalParameters: [Swift.String: Swift.String]? = nil,
            awsIotJobArn: Swift.String? = nil,
            awsIotJobId: Swift.String? = nil,
            awsJobExecutionsRolloutConfig: IoTClientTypes.AwsJobExecutionsRolloutConfig? = nil,
            awsJobPresignedUrlConfig: IoTClientTypes.AwsJobPresignedUrlConfig? = nil,
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            errorInfo: IoTClientTypes.ErrorInfo? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            otaUpdateArn: Swift.String? = nil,
            otaUpdateFiles: [IoTClientTypes.OTAUpdateFile]? = nil,
            otaUpdateId: Swift.String? = nil,
            otaUpdateStatus: IoTClientTypes.OTAUpdateStatus? = nil,
            protocols: [IoTClientTypes.ModelProtocol]? = nil,
            targetSelection: IoTClientTypes.TargetSelection? = nil,
            targets: [Swift.String]? = nil
        )
        {
            self.additionalParameters = additionalParameters
            self.awsIotJobArn = awsIotJobArn
            self.awsIotJobId = awsIotJobId
            self.awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfig
            self.awsJobPresignedUrlConfig = awsJobPresignedUrlConfig
            self.creationDate = creationDate
            self.description = description
            self.errorInfo = errorInfo
            self.lastModifiedDate = lastModifiedDate
            self.otaUpdateArn = otaUpdateArn
            self.otaUpdateFiles = otaUpdateFiles
            self.otaUpdateId = otaUpdateId
            self.otaUpdateStatus = otaUpdateStatus
            self.protocols = protocols
            self.targetSelection = targetSelection
            self.targets = targets
        }
    }

}

public struct GetOTAUpdateOutput {
    /// The OTA update info.
    public var otaUpdateInfo: IoTClientTypes.OTAUpdateInfo?

    public init(
        otaUpdateInfo: IoTClientTypes.OTAUpdateInfo? = nil
    )
    {
        self.otaUpdateInfo = otaUpdateInfo
    }
}

public struct GetPackageInput {
    /// The name of the target software package.
    /// This member is required.
    public var packageName: Swift.String?

    public init(
        packageName: Swift.String? = nil
    )
    {
        self.packageName = packageName
    }
}

public struct GetPackageOutput {
    /// The date the package was created.
    public var creationDate: Foundation.Date?
    /// The name of the default package version.
    public var defaultVersionName: Swift.String?
    /// The package description.
    public var description: Swift.String?
    /// The date when the package was last updated.
    public var lastModifiedDate: Foundation.Date?
    /// The ARN for the package.
    public var packageArn: Swift.String?
    /// The name of the software package.
    public var packageName: Swift.String?

    public init(
        creationDate: Foundation.Date? = nil,
        defaultVersionName: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        packageArn: Swift.String? = nil,
        packageName: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.defaultVersionName = defaultVersionName
        self.description = description
        self.lastModifiedDate = lastModifiedDate
        self.packageArn = packageArn
        self.packageName = packageName
    }
}

extension GetPackageOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPackageOutput(creationDate: \(Swift.String(describing: creationDate)), defaultVersionName: \(Swift.String(describing: defaultVersionName)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), packageArn: \(Swift.String(describing: packageArn)), packageName: \(Swift.String(describing: packageName)), description: \"CONTENT_REDACTED\")"}
}

public struct GetPackageConfigurationInput {

    public init() { }
}

extension IoTClientTypes {
    /// Configuration to manage IoT Job's package version reporting. If configured, Jobs updates the thing's reserved named shadow with the package version information up on successful job completion. Note: For each job, the destinationPackageVersions attribute has to be set with the correct data for Jobs to report to the thing shadow.
    public struct VersionUpdateByJobsConfig {
        /// Indicates whether the Job is enabled or not.
        public var enabled: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the role that grants permission to the IoT jobs service to update the reserved named shadow when the job successfully completes.
        public var roleArn: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.roleArn = roleArn
        }
    }

}

public struct GetPackageConfigurationOutput {
    /// The version that is associated to a specific job.
    public var versionUpdateByJobsConfig: IoTClientTypes.VersionUpdateByJobsConfig?

    public init(
        versionUpdateByJobsConfig: IoTClientTypes.VersionUpdateByJobsConfig? = nil
    )
    {
        self.versionUpdateByJobsConfig = versionUpdateByJobsConfig
    }
}

public struct GetPackageVersionInput {
    /// The name of the associated package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The name of the target package version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        packageName: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.packageName = packageName
        self.versionName = versionName
    }
}

public struct GetPackageVersionOutput {
    /// The various components that make up a software package version.
    public var artifact: IoTClientTypes.PackageVersionArtifact?
    /// Metadata that were added to the package version that can be used to define a package version’s configuration.
    public var attributes: [Swift.String: Swift.String]?
    /// The date when the package version was created.
    public var creationDate: Foundation.Date?
    /// The package version description.
    public var description: Swift.String?
    /// Error reason for a package version failure during creation or update.
    public var errorReason: Swift.String?
    /// The date when the package version was last updated.
    public var lastModifiedDate: Foundation.Date?
    /// The name of the software package.
    public var packageName: Swift.String?
    /// The ARN for the package version.
    public var packageVersionArn: Swift.String?
    /// The inline job document associated with a software package version used for a quick job deployment via IoT Jobs.
    public var recipe: Swift.String?
    /// The software bill of materials for a software package version.
    public var sbom: IoTClientTypes.Sbom?
    /// The status of the validation for a new software bill of materials added to a software package version.
    public var sbomValidationStatus: IoTClientTypes.SbomValidationStatus?
    /// The status associated to the package version. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle).
    public var status: IoTClientTypes.PackageVersionStatus?
    /// The name of the package version.
    public var versionName: Swift.String?

    public init(
        artifact: IoTClientTypes.PackageVersionArtifact? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        creationDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        errorReason: Swift.String? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        packageName: Swift.String? = nil,
        packageVersionArn: Swift.String? = nil,
        recipe: Swift.String? = nil,
        sbom: IoTClientTypes.Sbom? = nil,
        sbomValidationStatus: IoTClientTypes.SbomValidationStatus? = nil,
        status: IoTClientTypes.PackageVersionStatus? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.artifact = artifact
        self.attributes = attributes
        self.creationDate = creationDate
        self.description = description
        self.errorReason = errorReason
        self.lastModifiedDate = lastModifiedDate
        self.packageName = packageName
        self.packageVersionArn = packageVersionArn
        self.recipe = recipe
        self.sbom = sbom
        self.sbomValidationStatus = sbomValidationStatus
        self.status = status
        self.versionName = versionName
    }
}

extension GetPackageVersionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPackageVersionOutput(artifact: \(Swift.String(describing: artifact)), creationDate: \(Swift.String(describing: creationDate)), errorReason: \(Swift.String(describing: errorReason)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), packageName: \(Swift.String(describing: packageName)), packageVersionArn: \(Swift.String(describing: packageVersionArn)), sbom: \(Swift.String(describing: sbom)), sbomValidationStatus: \(Swift.String(describing: sbomValidationStatus)), status: \(Swift.String(describing: status)), versionName: \(Swift.String(describing: versionName)), attributes: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", recipe: \"CONTENT_REDACTED\")"}
}

public struct GetPercentilesInput {
    /// The field to aggregate.
    public var aggregationField: Swift.String?
    /// The name of the index to search.
    public var indexName: Swift.String?
    /// The percentile groups returned.
    public var percents: [Swift.Double]?
    /// The search query string.
    /// This member is required.
    public var queryString: Swift.String?
    /// The query version.
    public var queryVersion: Swift.String?

    public init(
        aggregationField: Swift.String? = nil,
        indexName: Swift.String? = nil,
        percents: [Swift.Double]? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil
    )
    {
        self.aggregationField = aggregationField
        self.indexName = indexName
        self.percents = percents
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

extension IoTClientTypes {
    /// Describes the percentile and percentile value.
    public struct PercentPair {
        /// The percentile.
        public var percent: Swift.Double
        /// The value of the percentile.
        public var value: Swift.Double

        public init(
            percent: Swift.Double = 0.0,
            value: Swift.Double = 0.0
        )
        {
            self.percent = percent
            self.value = value
        }
    }

}

public struct GetPercentilesOutput {
    /// The percentile values of the aggregated fields.
    public var percentiles: [IoTClientTypes.PercentPair]?

    public init(
        percentiles: [IoTClientTypes.PercentPair]? = nil
    )
    {
        self.percentiles = percentiles
    }
}

/// The input for the GetPolicy operation.
public struct GetPolicyInput {
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        policyName: Swift.String? = nil
    )
    {
        self.policyName = policyName
    }
}

/// The output from the GetPolicy operation.
public struct GetPolicyOutput {
    /// The date the policy was created.
    public var creationDate: Foundation.Date?
    /// The default policy version ID.
    public var defaultVersionId: Swift.String?
    /// The generation ID of the policy.
    public var generationId: Swift.String?
    /// The date the policy was last modified.
    public var lastModifiedDate: Foundation.Date?
    /// The policy ARN.
    public var policyArn: Swift.String?
    /// The JSON document that describes the policy.
    public var policyDocument: Swift.String?
    /// The policy name.
    public var policyName: Swift.String?

    public init(
        creationDate: Foundation.Date? = nil,
        defaultVersionId: Swift.String? = nil,
        generationId: Swift.String? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        policyArn: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.defaultVersionId = defaultVersionId
        self.generationId = generationId
        self.lastModifiedDate = lastModifiedDate
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

/// The input for the GetPolicyVersion operation.
public struct GetPolicyVersionInput {
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The policy version ID.
    /// This member is required.
    public var policyVersionId: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        policyVersionId: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

/// The output from the GetPolicyVersion operation.
public struct GetPolicyVersionOutput {
    /// The date the policy was created.
    public var creationDate: Foundation.Date?
    /// The generation ID of the policy version.
    public var generationId: Swift.String?
    /// Specifies whether the policy version is the default.
    public var isDefaultVersion: Swift.Bool
    /// The date the policy was last modified.
    public var lastModifiedDate: Foundation.Date?
    /// The policy ARN.
    public var policyArn: Swift.String?
    /// The JSON document that describes the policy.
    public var policyDocument: Swift.String?
    /// The policy name.
    public var policyName: Swift.String?
    /// The policy version ID.
    public var policyVersionId: Swift.String?

    public init(
        creationDate: Foundation.Date? = nil,
        generationId: Swift.String? = nil,
        isDefaultVersion: Swift.Bool = false,
        lastModifiedDate: Foundation.Date? = nil,
        policyArn: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        policyVersionId: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.generationId = generationId
        self.isDefaultVersion = isDefaultVersion
        self.lastModifiedDate = lastModifiedDate
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

/// The input to the GetRegistrationCode operation.
public struct GetRegistrationCodeInput {

    public init() { }
}

/// The output from the GetRegistrationCode operation.
public struct GetRegistrationCodeOutput {
    /// The CA certificate registration code.
    public var registrationCode: Swift.String?

    public init(
        registrationCode: Swift.String? = nil
    )
    {
        self.registrationCode = registrationCode
    }
}

public struct GetStatisticsInput {
    /// The aggregation field name.
    public var aggregationField: Swift.String?
    /// The name of the index to search. The default value is AWS_Things.
    public var indexName: Swift.String?
    /// The query used to search. You can specify "*" for the query string to get the count of all indexed things in your Amazon Web Services account.
    /// This member is required.
    public var queryString: Swift.String?
    /// The version of the query used to search.
    public var queryVersion: Swift.String?

    public init(
        aggregationField: Swift.String? = nil,
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil
    )
    {
        self.aggregationField = aggregationField
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

extension IoTClientTypes {
    /// A map of key-value pairs for all supported statistics. For issues with missing or unexpected values for this API, consult [ Fleet indexing troubleshooting guide](https://docs.aws.amazon.com/iot/latest/developerguide/fleet-indexing-troubleshooting.html).
    public struct Statistics {
        /// The average of the aggregated field values.
        public var average: Swift.Double?
        /// The count of things that match the query string criteria and contain a valid aggregation field value.
        public var count: Swift.Int
        /// The maximum aggregated field value.
        public var maximum: Swift.Double?
        /// The minimum aggregated field value.
        public var minimum: Swift.Double?
        /// The standard deviation of the aggregated field values.
        public var stdDeviation: Swift.Double?
        /// The sum of the aggregated field values.
        public var sum: Swift.Double?
        /// The sum of the squares of the aggregated field values.
        public var sumOfSquares: Swift.Double?
        /// The variance of the aggregated field values.
        public var variance: Swift.Double?

        public init(
            average: Swift.Double? = 0.0,
            count: Swift.Int = 0,
            maximum: Swift.Double? = 0.0,
            minimum: Swift.Double? = 0.0,
            stdDeviation: Swift.Double? = 0.0,
            sum: Swift.Double? = 0.0,
            sumOfSquares: Swift.Double? = 0.0,
            variance: Swift.Double? = 0.0
        )
        {
            self.average = average
            self.count = count
            self.maximum = maximum
            self.minimum = minimum
            self.stdDeviation = stdDeviation
            self.sum = sum
            self.sumOfSquares = sumOfSquares
            self.variance = variance
        }
    }

}

public struct GetStatisticsOutput {
    /// The statistics returned by the Fleet Indexing service based on the query and aggregation field.
    public var statistics: IoTClientTypes.Statistics?

    public init(
        statistics: IoTClientTypes.Statistics? = nil
    )
    {
        self.statistics = statistics
    }
}

/// The input for the GetTopicRule operation.
public struct GetTopicRuleInput {
    /// The name of the rule.
    /// This member is required.
    public var ruleName: Swift.String?

    public init(
        ruleName: Swift.String? = nil
    )
    {
        self.ruleName = ruleName
    }
}

extension IoTClientTypes {
    /// Describes a rule.
    public struct TopicRule {
        /// The actions associated with the rule.
        public var actions: [IoTClientTypes.Action]?
        /// The version of the SQL rules engine to use when evaluating the rule.
        public var awsIotSqlVersion: Swift.String?
        /// The date and time the rule was created.
        public var createdAt: Foundation.Date?
        /// The description of the rule.
        public var description: Swift.String?
        /// The action to perform when an error occurs.
        public var errorAction: IoTClientTypes.Action?
        /// Specifies whether the rule is disabled.
        public var ruleDisabled: Swift.Bool?
        /// The name of the rule.
        public var ruleName: Swift.String?
        /// The SQL statement used to query the topic. When using a SQL query with multiple lines, be sure to escape the newline characters.
        public var sql: Swift.String?

        public init(
            actions: [IoTClientTypes.Action]? = nil,
            awsIotSqlVersion: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            errorAction: IoTClientTypes.Action? = nil,
            ruleDisabled: Swift.Bool? = nil,
            ruleName: Swift.String? = nil,
            sql: Swift.String? = nil
        )
        {
            self.actions = actions
            self.awsIotSqlVersion = awsIotSqlVersion
            self.createdAt = createdAt
            self.description = description
            self.errorAction = errorAction
            self.ruleDisabled = ruleDisabled
            self.ruleName = ruleName
            self.sql = sql
        }
    }

}

/// The output from the GetTopicRule operation.
public struct GetTopicRuleOutput {
    /// The rule.
    public var rule: IoTClientTypes.TopicRule?
    /// The rule ARN.
    public var ruleArn: Swift.String?

    public init(
        rule: IoTClientTypes.TopicRule? = nil,
        ruleArn: Swift.String? = nil
    )
    {
        self.rule = rule
        self.ruleArn = ruleArn
    }
}

public struct GetTopicRuleDestinationInput {
    /// The ARN of the topic rule destination.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetTopicRuleDestinationOutput {
    /// The topic rule destination.
    public var topicRuleDestination: IoTClientTypes.TopicRuleDestination?

    public init(
        topicRuleDestination: IoTClientTypes.TopicRuleDestination? = nil
    )
    {
        self.topicRuleDestination = topicRuleDestination
    }
}

/// The resource is not configured.
public struct NotConfiguredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotConfiguredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetV2LoggingOptionsInput {

    public init() { }
}

public struct GetV2LoggingOptionsOutput {
    /// The default log level.
    public var defaultLogLevel: IoTClientTypes.LogLevel?
    /// Disables all logs.
    public var disableAllLogs: Swift.Bool
    /// The IAM role ARN IoT uses to write to your CloudWatch logs.
    public var roleArn: Swift.String?

    public init(
        defaultLogLevel: IoTClientTypes.LogLevel? = nil,
        disableAllLogs: Swift.Bool = false,
        roleArn: Swift.String? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.disableAllLogs = disableAllLogs
        self.roleArn = roleArn
    }
}

extension IoTClientTypes {

    public enum BehaviorCriteriaType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case machineLearning
        case `static`
        case statistical
        case sdkUnknown(Swift.String)

        public static var allCases: [BehaviorCriteriaType] {
            return [
                .machineLearning,
                .static,
                .statistical
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .machineLearning: return "MACHINE_LEARNING"
            case .static: return "STATIC"
            case .statistical: return "STATISTICAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListActiveViolationsInput {
    /// The criteria for a behavior.
    public var behaviorCriteriaType: IoTClientTypes.BehaviorCriteriaType?
    /// A list of all suppressed alerts.
    public var listSuppressedAlerts: Swift.Bool?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The name of the Device Defender security profile for which violations are listed.
    public var securityProfileName: Swift.String?
    /// The name of the thing whose active violations are listed.
    public var thingName: Swift.String?
    /// The verification state of the violation (detect alarm).
    public var verificationState: IoTClientTypes.VerificationState?

    public init(
        behaviorCriteriaType: IoTClientTypes.BehaviorCriteriaType? = nil,
        listSuppressedAlerts: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfileName: Swift.String? = nil,
        thingName: Swift.String? = nil,
        verificationState: IoTClientTypes.VerificationState? = nil
    )
    {
        self.behaviorCriteriaType = behaviorCriteriaType
        self.listSuppressedAlerts = listSuppressedAlerts
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileName = securityProfileName
        self.thingName = thingName
        self.verificationState = verificationState
    }
}

public struct ListActiveViolationsOutput {
    /// The list of active violations.
    public var activeViolations: [IoTClientTypes.ActiveViolation]?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        activeViolations: [IoTClientTypes.ActiveViolation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.activeViolations = activeViolations
        self.nextToken = nextToken
    }
}

public struct ListAttachedPoliciesInput {
    /// The token to retrieve the next set of results.
    public var marker: Swift.String?
    /// The maximum number of results to be returned per request.
    public var pageSize: Swift.Int?
    /// When true, recursively list attached policies.
    public var recursive: Swift.Bool?
    /// The group or principal for which the policies will be listed. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    /// This member is required.
    public var target: Swift.String?

    public init(
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        recursive: Swift.Bool? = false,
        target: Swift.String? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
        self.recursive = recursive
        self.target = target
    }
}

public struct ListAttachedPoliciesOutput {
    /// The token to retrieve the next set of results, or ``null`` if there are no more results.
    public var nextMarker: Swift.String?
    /// The policies.
    public var policies: [IoTClientTypes.Policy]?

    public init(
        nextMarker: Swift.String? = nil,
        policies: [IoTClientTypes.Policy]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.policies = policies
    }
}

public struct ListAuditFindingsInput {
    /// A filter to limit results to the findings for the specified audit check.
    public var checkName: Swift.String?
    /// A filter to limit results to those found before the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    public var endTime: Foundation.Date?
    /// Boolean flag indicating whether only the suppressed findings or the unsuppressed findings should be listed. If this parameter isn't provided, the response will list both suppressed and unsuppressed findings.
    public var listSuppressedFindings: Swift.Bool?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Information identifying the noncompliant resource.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
    /// A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    public var startTime: Foundation.Date?
    /// A filter to limit results to the audit with the specified ID. You must specify either the taskId or the startTime and endTime, but not both.
    public var taskId: Swift.String?

    public init(
        checkName: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        listSuppressedFindings: Swift.Bool? = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
        startTime: Foundation.Date? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.checkName = checkName
        self.endTime = endTime
        self.listSuppressedFindings = listSuppressedFindings
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
        self.startTime = startTime
        self.taskId = taskId
    }
}

public struct ListAuditFindingsOutput {
    /// The findings (results) of the audit.
    public var findings: [IoTClientTypes.AuditFinding]?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        findings: [IoTClientTypes.AuditFinding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

public struct ListAuditMitigationActionsExecutionsInput {
    /// Specify this filter to limit results to those with a specific status.
    public var actionStatus: IoTClientTypes.AuditMitigationActionsExecutionStatus?
    /// Specify this filter to limit results to those that were applied to a specific audit finding.
    /// This member is required.
    public var findingId: Swift.String?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Specify this filter to limit results to actions for a specific audit mitigation actions task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        actionStatus: IoTClientTypes.AuditMitigationActionsExecutionStatus? = nil,
        findingId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.actionStatus = actionStatus
        self.findingId = findingId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskId = taskId
    }
}

public struct ListAuditMitigationActionsExecutionsOutput {
    /// A set of task execution results based on the input parameters. Details include the mitigation action applied, start time, and task status.
    public var actionsExecutions: [IoTClientTypes.AuditMitigationActionExecutionMetadata]?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        actionsExecutions: [IoTClientTypes.AuditMitigationActionExecutionMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionsExecutions = actionsExecutions
        self.nextToken = nextToken
    }
}

public struct ListAuditMitigationActionsTasksInput {
    /// Specify this filter to limit results to tasks that were applied to results for a specific audit.
    public var auditTaskId: Swift.String?
    /// Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// Specify this filter to limit results to tasks that were applied to a specific audit finding.
    public var findingId: Swift.String?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Specify this filter to limit results to tasks that began on or after a specific date and time.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// Specify this filter to limit results to tasks that are in a specific state.
    public var taskStatus: IoTClientTypes.AuditMitigationActionsTaskStatus?

    public init(
        auditTaskId: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        findingId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        taskStatus: IoTClientTypes.AuditMitigationActionsTaskStatus? = nil
    )
    {
        self.auditTaskId = auditTaskId
        self.endTime = endTime
        self.findingId = findingId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.taskStatus = taskStatus
    }
}

public struct ListAuditMitigationActionsTasksOutput {
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The collection of audit mitigation tasks that matched the filter criteria.
    public var tasks: [IoTClientTypes.AuditMitigationActionsTaskMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [IoTClientTypes.AuditMitigationActionsTaskMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

public struct ListAuditSuppressionsInput {
    /// Determines whether suppressions are listed in ascending order by expiration date or not. If parameter isn't provided, ascendingOrder=true.
    public var ascendingOrder: Swift.Bool?
    /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    public var checkName: Swift.String?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Information that identifies the noncompliant resource.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?

    public init(
        ascendingOrder: Swift.Bool? = false,
        checkName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.checkName = checkName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct ListAuditSuppressionsOutput {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// List of audit suppressions.
    public var suppressions: [IoTClientTypes.AuditSuppression]?

    public init(
        nextToken: Swift.String? = nil,
        suppressions: [IoTClientTypes.AuditSuppression]? = nil
    )
    {
        self.nextToken = nextToken
        self.suppressions = suppressions
    }
}

public struct ListAuditTasksInput {
    /// The end of the time period.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The beginning of the time period. Audit information is retained for a limited time (90 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
    /// This member is required.
    public var startTime: Foundation.Date?
    /// A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
    public var taskStatus: IoTClientTypes.AuditTaskStatus?
    /// A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
    public var taskType: IoTClientTypes.AuditTaskType?

    public init(
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        taskStatus: IoTClientTypes.AuditTaskStatus? = nil,
        taskType: IoTClientTypes.AuditTaskType? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.taskStatus = taskStatus
        self.taskType = taskType
    }
}

public struct ListAuditTasksOutput {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The audits that were performed during the specified time period.
    public var tasks: [IoTClientTypes.AuditTaskMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [IoTClientTypes.AuditTaskMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

public struct ListAuthorizersInput {
    /// Return the list of authorizers in ascending alphabetical order.
    public var ascendingOrder: Swift.Bool?
    /// A marker used to get the next set of results.
    public var marker: Swift.String?
    /// The maximum number of results to return at one time.
    public var pageSize: Swift.Int?
    /// The status of the list authorizers request.
    public var status: IoTClientTypes.AuthorizerStatus?

    public init(
        ascendingOrder: Swift.Bool? = false,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        status: IoTClientTypes.AuthorizerStatus? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
        self.status = status
    }
}

public struct ListAuthorizersOutput {
    /// The authorizers.
    public var authorizers: [IoTClientTypes.AuthorizerSummary]?
    /// A marker used to get the next set of results.
    public var nextMarker: Swift.String?

    public init(
        authorizers: [IoTClientTypes.AuthorizerSummary]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.authorizers = authorizers
        self.nextMarker = nextMarker
    }
}

public struct ListBillingGroupsInput {
    /// The maximum number of results to return per request.
    public var maxResults: Swift.Int?
    /// Limit the results to billing groups whose names have the given prefix.
    public var namePrefixFilter: Swift.String?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        namePrefixFilter: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namePrefixFilter = namePrefixFilter
        self.nextToken = nextToken
    }
}

public struct ListBillingGroupsOutput {
    /// The list of billing groups.
    public var billingGroups: [IoTClientTypes.GroupNameAndArn]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        billingGroups: [IoTClientTypes.GroupNameAndArn]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingGroups = billingGroups
        self.nextToken = nextToken
    }
}

/// Input for the ListCACertificates operation.
public struct ListCACertificatesInput {
    /// Determines the order of the results.
    public var ascendingOrder: Swift.Bool?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?
    /// The name of the provisioning template.
    public var templateName: Swift.String?

    public init(
        ascendingOrder: Swift.Bool? = false,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
        self.templateName = templateName
    }
}

extension IoTClientTypes {
    /// A CA certificate.
    public struct CACertificate {
        /// The ARN of the CA certificate.
        public var certificateArn: Swift.String?
        /// The ID of the CA certificate.
        public var certificateId: Swift.String?
        /// The date the CA certificate was created.
        public var creationDate: Foundation.Date?
        /// The status of the CA certificate. The status value REGISTER_INACTIVE is deprecated and should not be used.
        public var status: IoTClientTypes.CACertificateStatus?

        public init(
            certificateArn: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            status: IoTClientTypes.CACertificateStatus? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateId = certificateId
            self.creationDate = creationDate
            self.status = status
        }
    }

}

/// The output from the ListCACertificates operation.
public struct ListCACertificatesOutput {
    /// The CA certificates registered in your Amazon Web Services account.
    public var certificates: [IoTClientTypes.CACertificate]?
    /// The current position within the list of CA certificates.
    public var nextMarker: Swift.String?

    public init(
        certificates: [IoTClientTypes.CACertificate]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.nextMarker = nextMarker
    }
}

public struct ListCertificateProvidersInput {
    /// Returns the list of certificate providers in ascending alphabetical order.
    public var ascendingOrder: Swift.Bool?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        ascendingOrder: Swift.Bool? = false,
        nextToken: Swift.String? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.nextToken = nextToken
    }
}

extension IoTClientTypes {
    /// The certificate provider summary.
    public struct CertificateProviderSummary {
        /// The ARN of the certificate provider.
        public var certificateProviderArn: Swift.String?
        /// The name of the certificate provider.
        public var certificateProviderName: Swift.String?

        public init(
            certificateProviderArn: Swift.String? = nil,
            certificateProviderName: Swift.String? = nil
        )
        {
            self.certificateProviderArn = certificateProviderArn
            self.certificateProviderName = certificateProviderName
        }
    }

}

public struct ListCertificateProvidersOutput {
    /// The list of certificate providers in your Amazon Web Services account.
    public var certificateProviders: [IoTClientTypes.CertificateProviderSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        certificateProviders: [IoTClientTypes.CertificateProviderSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.certificateProviders = certificateProviders
        self.nextToken = nextToken
    }
}

/// The input for the ListCertificates operation.
public struct ListCertificatesInput {
    /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
    public var ascendingOrder: Swift.Bool?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?

    public init(
        ascendingOrder: Swift.Bool? = false,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
    }
}

extension IoTClientTypes {
    /// Information about a certificate.
    public struct Certificate {
        /// The ARN of the certificate.
        public var certificateArn: Swift.String?
        /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
        public var certificateId: Swift.String?
        /// The mode of the certificate. DEFAULT: A certificate in DEFAULT mode is either generated by Amazon Web Services IoT Core or registered with an issuer certificate authority (CA) in DEFAULT mode. Devices with certificates in DEFAULT mode aren't required to send the Server Name Indication (SNI) extension when connecting to Amazon Web Services IoT Core. However, to use features such as custom domains and VPC endpoints, we recommend that you use the SNI extension when connecting to Amazon Web Services IoT Core. SNI_ONLY: A certificate in SNI_ONLY mode is registered without an issuer CA. Devices with certificates in SNI_ONLY mode must send the SNI extension when connecting to Amazon Web Services IoT Core.
        public var certificateMode: IoTClientTypes.CertificateMode?
        /// The date and time the certificate was created.
        public var creationDate: Foundation.Date?
        /// The status of the certificate. The status value REGISTER_INACTIVE is deprecated and should not be used.
        public var status: IoTClientTypes.CertificateStatus?

        public init(
            certificateArn: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            certificateMode: IoTClientTypes.CertificateMode? = nil,
            creationDate: Foundation.Date? = nil,
            status: IoTClientTypes.CertificateStatus? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateId = certificateId
            self.certificateMode = certificateMode
            self.creationDate = creationDate
            self.status = status
        }
    }

}

/// The output of the ListCertificates operation.
public struct ListCertificatesOutput {
    /// The descriptions of the certificates.
    public var certificates: [IoTClientTypes.Certificate]?
    /// The marker for the next set of results, or null if there are no additional results.
    public var nextMarker: Swift.String?

    public init(
        certificates: [IoTClientTypes.Certificate]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.nextMarker = nextMarker
    }
}

/// The input to the ListCertificatesByCA operation.
public struct ListCertificatesByCAInput {
    /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
    public var ascendingOrder: Swift.Bool?
    /// The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
    /// This member is required.
    public var caCertificateId: Swift.String?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?

    public init(
        ascendingOrder: Swift.Bool? = false,
        caCertificateId: Swift.String? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.caCertificateId = caCertificateId
        self.marker = marker
        self.pageSize = pageSize
    }
}

/// The output of the ListCertificatesByCA operation.
public struct ListCertificatesByCAOutput {
    /// The device certificates signed by the specified CA certificate.
    public var certificates: [IoTClientTypes.Certificate]?
    /// The marker for the next set of results, or null if there are no additional results.
    public var nextMarker: Swift.String?

    public init(
        certificates: [IoTClientTypes.Certificate]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.nextMarker = nextMarker
    }
}

public struct ListCustomMetricsInput {
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCustomMetricsOutput {
    /// The name of the custom metric.
    public var metricNames: [Swift.String]?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        metricNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricNames = metricNames
        self.nextToken = nextToken
    }
}

public struct ListDetectMitigationActionsExecutionsInput {
    /// The end of the time period for which ML Detect mitigation actions executions are returned.
    public var endTime: Foundation.Date?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    public var startTime: Foundation.Date?
    /// The unique identifier of the task.
    public var taskId: Swift.String?
    /// The name of the thing whose mitigation actions are listed.
    public var thingName: Swift.String?
    /// The unique identifier of the violation.
    public var violationId: Swift.String?

    public init(
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        taskId: Swift.String? = nil,
        thingName: Swift.String? = nil,
        violationId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.taskId = taskId
        self.thingName = thingName
        self.violationId = violationId
    }
}

extension IoTClientTypes {

    public enum DetectMitigationActionExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case skipped
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectMitigationActionExecutionStatus] {
            return [
                .failed,
                .inProgress,
                .skipped,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .skipped: return "SKIPPED"
            case .successful: return "SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Describes which mitigation actions should be executed.
    public struct DetectMitigationActionExecution {
        /// The friendly name that uniquely identifies the mitigation action.
        public var actionName: Swift.String?
        /// The error code of a mitigation action.
        public var errorCode: Swift.String?
        /// The date a mitigation action ended.
        public var executionEndDate: Foundation.Date?
        /// The date a mitigation action was started.
        public var executionStartDate: Foundation.Date?
        /// The message of a mitigation action.
        public var message: Swift.String?
        /// The status of a mitigation action.
        public var status: IoTClientTypes.DetectMitigationActionExecutionStatus?
        /// The unique identifier of the task.
        public var taskId: Swift.String?
        /// The name of the thing.
        public var thingName: Swift.String?
        /// The unique identifier of the violation.
        public var violationId: Swift.String?

        public init(
            actionName: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            executionEndDate: Foundation.Date? = nil,
            executionStartDate: Foundation.Date? = nil,
            message: Swift.String? = nil,
            status: IoTClientTypes.DetectMitigationActionExecutionStatus? = nil,
            taskId: Swift.String? = nil,
            thingName: Swift.String? = nil,
            violationId: Swift.String? = nil
        )
        {
            self.actionName = actionName
            self.errorCode = errorCode
            self.executionEndDate = executionEndDate
            self.executionStartDate = executionStartDate
            self.message = message
            self.status = status
            self.taskId = taskId
            self.thingName = thingName
            self.violationId = violationId
        }
    }

}

public struct ListDetectMitigationActionsExecutionsOutput {
    /// List of actions executions.
    public var actionsExecutions: [IoTClientTypes.DetectMitigationActionExecution]?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        actionsExecutions: [IoTClientTypes.DetectMitigationActionExecution]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionsExecutions = actionsExecutions
        self.nextToken = nextToken
    }
}

public struct ListDetectMitigationActionsTasksInput {
    /// The end of the time period for which ML Detect mitigation actions tasks are returned.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

public struct ListDetectMitigationActionsTasksOutput {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The collection of ML Detect mitigation tasks that matched the filter criteria.
    public var tasks: [IoTClientTypes.DetectMitigationActionsTaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [IoTClientTypes.DetectMitigationActionsTaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

public struct ListDimensionsInput {
    /// The maximum number of results to retrieve at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDimensionsOutput {
    /// A list of the names of the defined dimensions. Use DescribeDimension to get details for a dimension.
    public var dimensionNames: [Swift.String]?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        dimensionNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dimensionNames = dimensionNames
        self.nextToken = nextToken
    }
}

public struct ListDomainConfigurationsInput {
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?
    /// The type of service delivered by the endpoint.
    public var serviceType: IoTClientTypes.ServiceType?

    public init(
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        serviceType: IoTClientTypes.ServiceType? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
        self.serviceType = serviceType
    }
}

extension IoTClientTypes {
    /// The summary of a domain configuration. A domain configuration specifies custom IoT-specific information about a domain. A domain configuration can be associated with an Amazon Web Services-managed domain (for example, dbc123defghijk.iot.us-west-2.amazonaws.com), a customer managed domain, or a default endpoint.
    ///
    /// * Data
    ///
    /// * Jobs
    ///
    /// * CredentialProvider
    public struct DomainConfigurationSummary {
        /// The ARN of the domain configuration.
        public var domainConfigurationArn: Swift.String?
        /// The name of the domain configuration. This value must be unique to a region.
        public var domainConfigurationName: Swift.String?
        /// The type of service delivered by the endpoint.
        public var serviceType: IoTClientTypes.ServiceType?

        public init(
            domainConfigurationArn: Swift.String? = nil,
            domainConfigurationName: Swift.String? = nil,
            serviceType: IoTClientTypes.ServiceType? = nil
        )
        {
            self.domainConfigurationArn = domainConfigurationArn
            self.domainConfigurationName = domainConfigurationName
            self.serviceType = serviceType
        }
    }

}

public struct ListDomainConfigurationsOutput {
    /// A list of objects that contain summary information about the user's domain configurations.
    public var domainConfigurations: [IoTClientTypes.DomainConfigurationSummary]?
    /// The marker for the next set of results.
    public var nextMarker: Swift.String?

    public init(
        domainConfigurations: [IoTClientTypes.DomainConfigurationSummary]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.domainConfigurations = domainConfigurations
        self.nextMarker = nextMarker
    }
}

public struct ListFleetMetricsInput {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTClientTypes {
    /// The name and ARN of a fleet metric.
    public struct FleetMetricNameAndArn {
        /// The fleet metric ARN.
        public var metricArn: Swift.String?
        /// The fleet metric name.
        public var metricName: Swift.String?

        public init(
            metricArn: Swift.String? = nil,
            metricName: Swift.String? = nil
        )
        {
            self.metricArn = metricArn
            self.metricName = metricName
        }
    }

}

public struct ListFleetMetricsOutput {
    /// The list of fleet metrics objects.
    public var fleetMetrics: [IoTClientTypes.FleetMetricNameAndArn]?
    /// The token for the next set of results. Will not be returned if the operation has returned all results.
    public var nextToken: Swift.String?

    public init(
        fleetMetrics: [IoTClientTypes.FleetMetricNameAndArn]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetMetrics = fleetMetrics
        self.nextToken = nextToken
    }
}

public struct ListIndicesInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The token used to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListIndicesOutput {
    /// The index names.
    public var indexNames: [Swift.String]?
    /// The token used to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        indexNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexNames = indexNames
        self.nextToken = nextToken
    }
}

public struct ListJobExecutionsForJobInput {
    /// The unique identifier you assigned to this job when it was created.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The status of the job.
    public var status: IoTClientTypes.JobExecutionStatus?

    public init(
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: IoTClientTypes.JobExecutionStatus? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension IoTClientTypes {
    /// The job execution summary.
    public struct JobExecutionSummary {
        /// A string (consisting of the digits "0" through "9") which identifies this particular job execution on this particular device. It can be used later in commands which return or update job execution information.
        public var executionNumber: Swift.Int?
        /// The time, in seconds since the epoch, when the job execution was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The time, in seconds since the epoch, when the job execution was queued.
        public var queuedAt: Foundation.Date?
        /// The number that indicates how many retry attempts have been completed for this job on this device.
        public var retryAttempt: Swift.Int?
        /// The time, in seconds since the epoch, when the job execution started.
        public var startedAt: Foundation.Date?
        /// The status of the job execution.
        public var status: IoTClientTypes.JobExecutionStatus?

        public init(
            executionNumber: Swift.Int? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            queuedAt: Foundation.Date? = nil,
            retryAttempt: Swift.Int? = nil,
            startedAt: Foundation.Date? = nil,
            status: IoTClientTypes.JobExecutionStatus? = nil
        )
        {
            self.executionNumber = executionNumber
            self.lastUpdatedAt = lastUpdatedAt
            self.queuedAt = queuedAt
            self.retryAttempt = retryAttempt
            self.startedAt = startedAt
            self.status = status
        }
    }

}

extension IoTClientTypes {
    /// Contains a summary of information about job executions for a specific job.
    public struct JobExecutionSummaryForJob {
        /// Contains a subset of information about a job execution.
        public var jobExecutionSummary: IoTClientTypes.JobExecutionSummary?
        /// The ARN of the thing on which the job execution is running.
        public var thingArn: Swift.String?

        public init(
            jobExecutionSummary: IoTClientTypes.JobExecutionSummary? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.jobExecutionSummary = jobExecutionSummary
            self.thingArn = thingArn
        }
    }

}

public struct ListJobExecutionsForJobOutput {
    /// A list of job execution summaries.
    public var executionSummaries: [IoTClientTypes.JobExecutionSummaryForJob]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        executionSummaries: [IoTClientTypes.JobExecutionSummaryForJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.executionSummaries = executionSummaries
        self.nextToken = nextToken
    }
}

public struct ListJobExecutionsForThingInput {
    /// The unique identifier you assigned to this job when it was created.
    public var jobId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see [Setting up IoT Greengrass core devices.](https://docs.aws.amazon.com/greengrass/v2/developerguide/setting-up.html)
    public var namespaceId: Swift.String?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional filter that lets you search for jobs that have the specified status.
    public var status: IoTClientTypes.JobExecutionStatus?
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespaceId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        status: IoTClientTypes.JobExecutionStatus? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.namespaceId = namespaceId
        self.nextToken = nextToken
        self.status = status
        self.thingName = thingName
    }
}

extension IoTClientTypes {
    /// The job execution summary for a thing.
    public struct JobExecutionSummaryForThing {
        /// Contains a subset of information about a job execution.
        public var jobExecutionSummary: IoTClientTypes.JobExecutionSummary?
        /// The unique identifier you assigned to this job when it was created.
        public var jobId: Swift.String?

        public init(
            jobExecutionSummary: IoTClientTypes.JobExecutionSummary? = nil,
            jobId: Swift.String? = nil
        )
        {
            self.jobExecutionSummary = jobExecutionSummary
            self.jobId = jobId
        }
    }

}

public struct ListJobExecutionsForThingOutput {
    /// A list of job execution summaries.
    public var executionSummaries: [IoTClientTypes.JobExecutionSummaryForThing]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        executionSummaries: [IoTClientTypes.JobExecutionSummaryForThing]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.executionSummaries = executionSummaries
        self.nextToken = nextToken
    }
}

public struct ListJobsInput {
    /// The maximum number of results to return per request.
    public var maxResults: Swift.Int?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see [Setting up IoT Greengrass core devices.](https://docs.aws.amazon.com/greengrass/v2/developerguide/setting-up.html)
    public var namespaceId: Swift.String?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional filter that lets you search for jobs that have the specified status.
    public var status: IoTClientTypes.JobStatus?
    /// Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.
    public var targetSelection: IoTClientTypes.TargetSelection?
    /// A filter that limits the returned jobs to those for the specified group.
    public var thingGroupId: Swift.String?
    /// A filter that limits the returned jobs to those for the specified group.
    public var thingGroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        namespaceId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        status: IoTClientTypes.JobStatus? = nil,
        targetSelection: IoTClientTypes.TargetSelection? = nil,
        thingGroupId: Swift.String? = nil,
        thingGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namespaceId = namespaceId
        self.nextToken = nextToken
        self.status = status
        self.targetSelection = targetSelection
        self.thingGroupId = thingGroupId
        self.thingGroupName = thingGroupName
    }
}

extension IoTClientTypes {
    /// The job summary.
    public struct JobSummary {
        /// The time, in seconds since the epoch, when the job completed.
        public var completedAt: Foundation.Date?
        /// The time, in seconds since the epoch, when the job was created.
        public var createdAt: Foundation.Date?
        /// Indicates whether a job is concurrent. Will be true when a job is rolling out new job executions or canceling previously created executions, otherwise false.
        public var isConcurrent: Swift.Bool?
        /// The job ARN.
        public var jobArn: Swift.String?
        /// The unique identifier you assigned to this job when it was created.
        public var jobId: Swift.String?
        /// The time, in seconds since the epoch, when the job was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The job summary status.
        public var status: IoTClientTypes.JobStatus?
        /// Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.
        public var targetSelection: IoTClientTypes.TargetSelection?
        /// The ID of the thing group.
        public var thingGroupId: Swift.String?

        public init(
            completedAt: Foundation.Date? = nil,
            createdAt: Foundation.Date? = nil,
            isConcurrent: Swift.Bool? = nil,
            jobArn: Swift.String? = nil,
            jobId: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            status: IoTClientTypes.JobStatus? = nil,
            targetSelection: IoTClientTypes.TargetSelection? = nil,
            thingGroupId: Swift.String? = nil
        )
        {
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.isConcurrent = isConcurrent
            self.jobArn = jobArn
            self.jobId = jobId
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.targetSelection = targetSelection
            self.thingGroupId = thingGroupId
        }
    }

}

public struct ListJobsOutput {
    /// A list of jobs.
    public var jobs: [IoTClientTypes.JobSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        jobs: [IoTClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

public struct ListJobTemplatesInput {
    /// The maximum number of results to return in the list.
    public var maxResults: Swift.Int?
    /// The token to use to return the next set of results in the list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTClientTypes {
    /// An object that contains information about the job template.
    public struct JobTemplateSummary {
        /// The time, in seconds since the epoch, when the job template was created.
        public var createdAt: Foundation.Date?
        /// A description of the job template.
        public var description: Swift.String?
        /// The ARN of the job template.
        public var jobTemplateArn: Swift.String?
        /// The unique identifier of the job template.
        public var jobTemplateId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            jobTemplateArn: Swift.String? = nil,
            jobTemplateId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.jobTemplateArn = jobTemplateArn
            self.jobTemplateId = jobTemplateId
        }
    }

}

public struct ListJobTemplatesOutput {
    /// A list of objects that contain information about the job templates.
    public var jobTemplates: [IoTClientTypes.JobTemplateSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        jobTemplates: [IoTClientTypes.JobTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobTemplates = jobTemplates
        self.nextToken = nextToken
    }
}

public struct ListManagedJobTemplatesInput {
    /// Maximum number of entries that can be returned.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional parameter for template name. If specified, only the versions of the managed job templates that have the specified template name will be returned.
    public var templateName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateName = templateName
    }
}

extension IoTClientTypes {
    /// An object that contains information about the managed template.
    public struct ManagedJobTemplateSummary {
        /// The description for a managed template.
        public var description: Swift.String?
        /// A list of environments that are supported with the managed job template.
        public var environments: [Swift.String]?
        /// The Amazon Resource Name (ARN) for a managed template.
        public var templateArn: Swift.String?
        /// The unique Name for a managed template.
        public var templateName: Swift.String?
        /// The version for a managed template.
        public var templateVersion: Swift.String?

        public init(
            description: Swift.String? = nil,
            environments: [Swift.String]? = nil,
            templateArn: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateVersion: Swift.String? = nil
        )
        {
            self.description = description
            self.environments = environments
            self.templateArn = templateArn
            self.templateName = templateName
            self.templateVersion = templateVersion
        }
    }

}

public struct ListManagedJobTemplatesOutput {
    /// A list of managed job templates that are returned.
    public var managedJobTemplates: [IoTClientTypes.ManagedJobTemplateSummary]?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        managedJobTemplates: [IoTClientTypes.ManagedJobTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.managedJobTemplates = managedJobTemplates
        self.nextToken = nextToken
    }
}

public struct ListMetricValuesInput {
    /// The dimension name.
    public var dimensionName: Swift.String?
    /// The dimension value operator.
    public var dimensionValueOperator: IoTClientTypes.DimensionValueOperator?
    /// The end of the time period for which metric values are returned.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The name of the security profile metric for which values are returned.
    /// This member is required.
    public var metricName: Swift.String?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The start of the time period for which metric values are returned.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// The name of the thing for which security profile metric values are returned.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        dimensionName: Swift.String? = nil,
        dimensionValueOperator: IoTClientTypes.DimensionValueOperator? = nil,
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        metricName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.dimensionName = dimensionName
        self.dimensionValueOperator = dimensionValueOperator
        self.endTime = endTime
        self.maxResults = maxResults
        self.metricName = metricName
        self.nextToken = nextToken
        self.startTime = startTime
        self.thingName = thingName
    }
}

extension IoTClientTypes {
    /// A metric.
    public struct MetricDatum {
        /// The time the metric value was reported.
        public var timestamp: Foundation.Date?
        /// The value reported for the metric.
        public var value: IoTClientTypes.MetricValue?

        public init(
            timestamp: Foundation.Date? = nil,
            value: IoTClientTypes.MetricValue? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
        }
    }

}

public struct ListMetricValuesOutput {
    /// The data the thing reports for the metric during the specified time period.
    public var metricDatumList: [IoTClientTypes.MetricDatum]?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        metricDatumList: [IoTClientTypes.MetricDatum]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricDatumList = metricDatumList
        self.nextToken = nextToken
    }
}

public struct ListMitigationActionsInput {
    /// Specify a value to limit the result to mitigation actions with a specific action type.
    public var actionType: IoTClientTypes.MitigationActionType?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        actionType: IoTClientTypes.MitigationActionType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionType = actionType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTClientTypes {
    /// Information that identifies a mitigation action. This information is returned by ListMitigationActions.
    public struct MitigationActionIdentifier {
        /// The IAM role ARN used to apply this mitigation action.
        public var actionArn: Swift.String?
        /// The friendly name of the mitigation action.
        public var actionName: Swift.String?
        /// The date when this mitigation action was created.
        public var creationDate: Foundation.Date?

        public init(
            actionArn: Swift.String? = nil,
            actionName: Swift.String? = nil,
            creationDate: Foundation.Date? = nil
        )
        {
            self.actionArn = actionArn
            self.actionName = actionName
            self.creationDate = creationDate
        }
    }

}

public struct ListMitigationActionsOutput {
    /// A set of actions that matched the specified filter criteria.
    public var actionIdentifiers: [IoTClientTypes.MitigationActionIdentifier]?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        actionIdentifiers: [IoTClientTypes.MitigationActionIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionIdentifiers = actionIdentifiers
        self.nextToken = nextToken
    }
}

public struct ListOTAUpdatesInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token used to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The OTA update job status.
    public var otaUpdateStatus: IoTClientTypes.OTAUpdateStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        otaUpdateStatus: IoTClientTypes.OTAUpdateStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.otaUpdateStatus = otaUpdateStatus
    }
}

extension IoTClientTypes {
    /// An OTA update summary.
    public struct OTAUpdateSummary {
        /// The date when the OTA update was created.
        public var creationDate: Foundation.Date?
        /// The OTA update ARN.
        public var otaUpdateArn: Swift.String?
        /// The OTA update ID.
        public var otaUpdateId: Swift.String?

        public init(
            creationDate: Foundation.Date? = nil,
            otaUpdateArn: Swift.String? = nil,
            otaUpdateId: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.otaUpdateArn = otaUpdateArn
            self.otaUpdateId = otaUpdateId
        }
    }

}

public struct ListOTAUpdatesOutput {
    /// A token to use to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of OTA update jobs.
    public var otaUpdates: [IoTClientTypes.OTAUpdateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        otaUpdates: [IoTClientTypes.OTAUpdateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.otaUpdates = otaUpdates
    }
}

/// The input to the ListOutgoingCertificates operation.
public struct ListOutgoingCertificatesInput {
    /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
    public var ascendingOrder: Swift.Bool?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?

    public init(
        ascendingOrder: Swift.Bool? = false,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
    }
}

extension IoTClientTypes {
    /// A certificate that has been transferred but not yet accepted.
    public struct OutgoingCertificate {
        /// The certificate ARN.
        public var certificateArn: Swift.String?
        /// The certificate ID.
        public var certificateId: Swift.String?
        /// The certificate creation date.
        public var creationDate: Foundation.Date?
        /// The date the transfer was initiated.
        public var transferDate: Foundation.Date?
        /// The transfer message.
        public var transferMessage: Swift.String?
        /// The Amazon Web Services account to which the transfer was made.
        public var transferredTo: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            transferDate: Foundation.Date? = nil,
            transferMessage: Swift.String? = nil,
            transferredTo: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateId = certificateId
            self.creationDate = creationDate
            self.transferDate = transferDate
            self.transferMessage = transferMessage
            self.transferredTo = transferredTo
        }
    }

}

/// The output from the ListOutgoingCertificates operation.
public struct ListOutgoingCertificatesOutput {
    /// The marker for the next set of results.
    public var nextMarker: Swift.String?
    /// The certificates that are being transferred but not yet accepted.
    public var outgoingCertificates: [IoTClientTypes.OutgoingCertificate]?

    public init(
        nextMarker: Swift.String? = nil,
        outgoingCertificates: [IoTClientTypes.OutgoingCertificate]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.outgoingCertificates = outgoingCertificates
    }
}

public struct ListPackagesInput {
    /// The maximum number of results returned at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTClientTypes {
    /// A summary of information about a software package.
    public struct PackageSummary {
        /// The date that the package was created.
        public var creationDate: Foundation.Date?
        /// The name of the default package version.
        public var defaultVersionName: Swift.String?
        /// The date that the package was last updated.
        public var lastModifiedDate: Foundation.Date?
        /// The name for the target software package.
        public var packageName: Swift.String?

        public init(
            creationDate: Foundation.Date? = nil,
            defaultVersionName: Swift.String? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            packageName: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.defaultVersionName = defaultVersionName
            self.lastModifiedDate = lastModifiedDate
            self.packageName = packageName
        }
    }

}

public struct ListPackagesOutput {
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The software package summary.
    public var packageSummaries: [IoTClientTypes.PackageSummary]?

    public init(
        nextToken: Swift.String? = nil,
        packageSummaries: [IoTClientTypes.PackageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageSummaries = packageSummaries
    }
}

public struct ListPackageVersionsInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The name of the target software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The status of the package version. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle).
    public var status: IoTClientTypes.PackageVersionStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        packageName: Swift.String? = nil,
        status: IoTClientTypes.PackageVersionStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.packageName = packageName
        self.status = status
    }
}

extension IoTClientTypes {
    /// A summary of information about a package version.
    public struct PackageVersionSummary {
        /// The date that the package version was created.
        public var creationDate: Foundation.Date?
        /// The date that the package version was last updated.
        public var lastModifiedDate: Foundation.Date?
        /// The name of the associated software package.
        public var packageName: Swift.String?
        /// The status of the package version. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle).
        public var status: IoTClientTypes.PackageVersionStatus?
        /// The name of the target package version.
        public var versionName: Swift.String?

        public init(
            creationDate: Foundation.Date? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            packageName: Swift.String? = nil,
            status: IoTClientTypes.PackageVersionStatus? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.packageName = packageName
            self.status = status
            self.versionName = versionName
        }
    }

}

public struct ListPackageVersionsOutput {
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Lists the package versions associated to the package.
    public var packageVersionSummaries: [IoTClientTypes.PackageVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        packageVersionSummaries: [IoTClientTypes.PackageVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageVersionSummaries = packageVersionSummaries
    }
}

/// The input for the ListPolicies operation.
public struct ListPoliciesInput {
    /// Specifies the order for results. If true, the results are returned in ascending creation order.
    public var ascendingOrder: Swift.Bool?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?

    public init(
        ascendingOrder: Swift.Bool? = false,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
    }
}

/// The output from the ListPolicies operation.
public struct ListPoliciesOutput {
    /// The marker for the next set of results, or null if there are no additional results.
    public var nextMarker: Swift.String?
    /// The descriptions of the policies.
    public var policies: [IoTClientTypes.Policy]?

    public init(
        nextMarker: Swift.String? = nil,
        policies: [IoTClientTypes.Policy]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.policies = policies
    }
}

/// The input for the ListPolicyPrincipals operation.
public struct ListPolicyPrincipalsInput {
    /// Specifies the order for results. If true, the results are returned in ascending creation order.
    public var ascendingOrder: Swift.Bool?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        ascendingOrder: Swift.Bool? = false,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
        self.policyName = policyName
    }
}

/// The output from the ListPolicyPrincipals operation.
public struct ListPolicyPrincipalsOutput {
    /// The marker for the next set of results, or null if there are no additional results.
    public var nextMarker: Swift.String?
    /// The descriptions of the principals.
    public var principals: [Swift.String]?

    public init(
        nextMarker: Swift.String? = nil,
        principals: [Swift.String]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.principals = principals
    }
}

/// The input for the ListPolicyVersions operation.
public struct ListPolicyVersionsInput {
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        policyName: Swift.String? = nil
    )
    {
        self.policyName = policyName
    }
}

extension IoTClientTypes {
    /// Describes a policy version.
    public struct PolicyVersion {
        /// The date and time the policy was created.
        public var createDate: Foundation.Date?
        /// Specifies whether the policy version is the default.
        public var isDefaultVersion: Swift.Bool
        /// The policy version ID.
        public var versionId: Swift.String?

        public init(
            createDate: Foundation.Date? = nil,
            isDefaultVersion: Swift.Bool = false,
            versionId: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.isDefaultVersion = isDefaultVersion
            self.versionId = versionId
        }
    }

}

/// The output from the ListPolicyVersions operation.
public struct ListPolicyVersionsOutput {
    /// The policy versions.
    public var policyVersions: [IoTClientTypes.PolicyVersion]?

    public init(
        policyVersions: [IoTClientTypes.PolicyVersion]? = nil
    )
    {
        self.policyVersions = policyVersions
    }
}

/// The input for the ListPrincipalPolicies operation.
public struct ListPrincipalPoliciesInput {
    /// Specifies the order for results. If true, results are returned in ascending creation order.
    public var ascendingOrder: Swift.Bool?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?
    /// The principal. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    /// This member is required.
    public var principal: Swift.String?

    public init(
        ascendingOrder: Swift.Bool? = false,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        principal: Swift.String? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
        self.principal = principal
    }
}

/// The output from the ListPrincipalPolicies operation.
public struct ListPrincipalPoliciesOutput {
    /// The marker for the next set of results, or null if there are no additional results.
    public var nextMarker: Swift.String?
    /// The policies.
    public var policies: [IoTClientTypes.Policy]?

    public init(
        nextMarker: Swift.String? = nil,
        policies: [IoTClientTypes.Policy]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.policies = policies
    }
}

/// The input for the ListPrincipalThings operation.
public struct ListPrincipalThingsInput {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The principal.
    /// This member is required.
    public var principal: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
    }
}

/// The output from the ListPrincipalThings operation.
public struct ListPrincipalThingsOutput {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The things.
    public var things: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        things: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

public struct ListProvisioningTemplatesInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTClientTypes {
    /// A summary of information about a provisioning template.
    public struct ProvisioningTemplateSummary {
        /// The date when the provisioning template summary was created.
        public var creationDate: Foundation.Date?
        /// The description of the provisioning template.
        public var description: Swift.String?
        /// True if the fleet provision template is enabled, otherwise false.
        public var enabled: Swift.Bool?
        /// The date when the provisioning template summary was last modified.
        public var lastModifiedDate: Foundation.Date?
        /// The ARN of the provisioning template.
        public var templateArn: Swift.String?
        /// The name of the provisioning template.
        public var templateName: Swift.String?
        /// The type you define in a provisioning template. You can create a template with only one type. You can't change the template type after its creation. The default value is FLEET_PROVISIONING. For more information about provisioning template, see: [Provisioning template](https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html).
        public var type: IoTClientTypes.TemplateType?

        public init(
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            templateArn: Swift.String? = nil,
            templateName: Swift.String? = nil,
            type: IoTClientTypes.TemplateType? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.enabled = enabled
            self.lastModifiedDate = lastModifiedDate
            self.templateArn = templateArn
            self.templateName = templateName
            self.type = type
        }
    }

}

public struct ListProvisioningTemplatesOutput {
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of provisioning templates
    public var templates: [IoTClientTypes.ProvisioningTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templates: [IoTClientTypes.ProvisioningTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templates = templates
    }
}

public struct ListProvisioningTemplateVersionsInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The name of the provisioning template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateName = templateName
    }
}

extension IoTClientTypes {
    /// A summary of information about a fleet provision template version.
    public struct ProvisioningTemplateVersionSummary {
        /// The date when the provisioning template version was created
        public var creationDate: Foundation.Date?
        /// True if the provisioning template version is the default version, otherwise false.
        public var isDefaultVersion: Swift.Bool
        /// The ID of the fleet provisioning template version.
        public var versionId: Swift.Int?

        public init(
            creationDate: Foundation.Date? = nil,
            isDefaultVersion: Swift.Bool = false,
            versionId: Swift.Int? = nil
        )
        {
            self.creationDate = creationDate
            self.isDefaultVersion = isDefaultVersion
            self.versionId = versionId
        }
    }

}

public struct ListProvisioningTemplateVersionsOutput {
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of provisioning template versions.
    public var versions: [IoTClientTypes.ProvisioningTemplateVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [IoTClientTypes.ProvisioningTemplateVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

public struct ListRelatedResourcesForAuditFindingInput {
    /// The finding Id.
    /// This member is required.
    public var findingId: Swift.String?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        findingId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingId = findingId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListRelatedResourcesForAuditFindingOutput {
    /// A token that can be used to retrieve the next set of results, or null for the first API call.
    public var nextToken: Swift.String?
    /// The related resources.
    public var relatedResources: [IoTClientTypes.RelatedResource]?

    public init(
        nextToken: Swift.String? = nil,
        relatedResources: [IoTClientTypes.RelatedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.relatedResources = relatedResources
    }
}

public struct ListRoleAliasesInput {
    /// Return the list of role aliases in ascending alphabetical order.
    public var ascendingOrder: Swift.Bool?
    /// A marker used to get the next set of results.
    public var marker: Swift.String?
    /// The maximum number of results to return at one time.
    public var pageSize: Swift.Int?

    public init(
        ascendingOrder: Swift.Bool? = false,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
    }
}

public struct ListRoleAliasesOutput {
    /// A marker used to get the next set of results.
    public var nextMarker: Swift.String?
    /// The role aliases.
    public var roleAliases: [Swift.String]?

    public init(
        nextMarker: Swift.String? = nil,
        roleAliases: [Swift.String]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.roleAliases = roleAliases
    }
}

extension IoTClientTypes {

    public enum SbomValidationResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [SbomValidationResult] {
            return [
                .failed,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListSbomValidationResultsInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The name of the new software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The end result of the
    public var validationResult: IoTClientTypes.SbomValidationResult?
    /// The name of the new package version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        packageName: Swift.String? = nil,
        validationResult: IoTClientTypes.SbomValidationResult? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.packageName = packageName
        self.validationResult = validationResult
        self.versionName = versionName
    }
}

extension IoTClientTypes {

    public enum SbomValidationErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fileSizeLimitExceeded
        case incompatibleFormat
        case sdkUnknown(Swift.String)

        public static var allCases: [SbomValidationErrorCode] {
            return [
                .fileSizeLimitExceeded,
                .incompatibleFormat
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fileSizeLimitExceeded: return "FILE_SIZE_LIMIT_EXCEEDED"
            case .incompatibleFormat: return "INCOMPATIBLE_FORMAT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// A summary of the validation results for a specific software bill of materials (SBOM) attached to a software package version.
    public struct SbomValidationResultSummary {
        /// The errorCode representing the validation failure error if the SBOM validation failed.
        public var errorCode: IoTClientTypes.SbomValidationErrorCode?
        /// The errorMessage representing the validation failure error if the SBOM validation failed.
        public var errorMessage: Swift.String?
        /// The name of the SBOM file.
        public var fileName: Swift.String?
        /// The end result of the SBOM validation.
        public var validationResult: IoTClientTypes.SbomValidationResult?

        public init(
            errorCode: IoTClientTypes.SbomValidationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            fileName: Swift.String? = nil,
            validationResult: IoTClientTypes.SbomValidationResult? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.fileName = fileName
            self.validationResult = validationResult
        }
    }

}

public struct ListSbomValidationResultsOutput {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A summary of the validation results for each software bill of materials attached to a software package version.
    public var validationResultSummaries: [IoTClientTypes.SbomValidationResultSummary]?

    public init(
        nextToken: Swift.String? = nil,
        validationResultSummaries: [IoTClientTypes.SbomValidationResultSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.validationResultSummaries = validationResultSummaries
    }
}

public struct ListScheduledAuditsInput {
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTClientTypes {
    /// Information about the scheduled audit.
    public struct ScheduledAuditMetadata {
        /// The day of the month on which the scheduled audit is run (if the frequency is "MONTHLY"). If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.
        public var dayOfMonth: Swift.String?
        /// The day of the week on which the scheduled audit is run (if the frequency is "WEEKLY" or "BIWEEKLY").
        public var dayOfWeek: IoTClientTypes.DayOfWeek?
        /// How often the scheduled audit occurs.
        public var frequency: IoTClientTypes.AuditFrequency?
        /// The ARN of the scheduled audit.
        public var scheduledAuditArn: Swift.String?
        /// The name of the scheduled audit.
        public var scheduledAuditName: Swift.String?

        public init(
            dayOfMonth: Swift.String? = nil,
            dayOfWeek: IoTClientTypes.DayOfWeek? = nil,
            frequency: IoTClientTypes.AuditFrequency? = nil,
            scheduledAuditArn: Swift.String? = nil,
            scheduledAuditName: Swift.String? = nil
        )
        {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
            self.frequency = frequency
            self.scheduledAuditArn = scheduledAuditArn
            self.scheduledAuditName = scheduledAuditName
        }
    }

}

public struct ListScheduledAuditsOutput {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of scheduled audits.
    public var scheduledAudits: [IoTClientTypes.ScheduledAuditMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        scheduledAudits: [IoTClientTypes.ScheduledAuditMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.scheduledAudits = scheduledAudits
    }
}

public struct ListSecurityProfilesInput {
    /// A filter to limit results to the security profiles that use the defined dimension. Cannot be used with metricName
    public var dimensionName: Swift.String?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The name of the custom metric. Cannot be used with dimensionName.
    public var metricName: Swift.String?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        dimensionName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metricName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dimensionName = dimensionName
        self.maxResults = maxResults
        self.metricName = metricName
        self.nextToken = nextToken
    }
}

extension IoTClientTypes {
    /// Identifying information for a Device Defender security profile.
    public struct SecurityProfileIdentifier {
        /// The ARN of the security profile.
        /// This member is required.
        public var arn: Swift.String?
        /// The name you've given to the security profile.
        /// This member is required.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

public struct ListSecurityProfilesOutput {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of security profile identifiers (names and ARNs).
    public var securityProfileIdentifiers: [IoTClientTypes.SecurityProfileIdentifier]?

    public init(
        nextToken: Swift.String? = nil,
        securityProfileIdentifiers: [IoTClientTypes.SecurityProfileIdentifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityProfileIdentifiers = securityProfileIdentifiers
    }
}

public struct ListSecurityProfilesForTargetInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// If true, return child groups too.
    public var recursive: Swift.Bool?
    /// The ARN of the target (thing group) whose attached security profiles you want to get.
    /// This member is required.
    public var securityProfileTargetArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recursive: Swift.Bool? = false,
        securityProfileTargetArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recursive = recursive
        self.securityProfileTargetArn = securityProfileTargetArn
    }
}

extension IoTClientTypes {
    /// A target to which an alert is sent when a security profile behavior is violated.
    public struct SecurityProfileTarget {
        /// The ARN of the security profile.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IoTClientTypes {
    /// Information about a security profile and the target associated with it.
    public struct SecurityProfileTargetMapping {
        /// Information that identifies the security profile.
        public var securityProfileIdentifier: IoTClientTypes.SecurityProfileIdentifier?
        /// Information about the target (thing group) associated with the security profile.
        public var target: IoTClientTypes.SecurityProfileTarget?

        public init(
            securityProfileIdentifier: IoTClientTypes.SecurityProfileIdentifier? = nil,
            target: IoTClientTypes.SecurityProfileTarget? = nil
        )
        {
            self.securityProfileIdentifier = securityProfileIdentifier
            self.target = target
        }
    }

}

public struct ListSecurityProfilesForTargetOutput {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of security profiles and their associated targets.
    public var securityProfileTargetMappings: [IoTClientTypes.SecurityProfileTargetMapping]?

    public init(
        nextToken: Swift.String? = nil,
        securityProfileTargetMappings: [IoTClientTypes.SecurityProfileTargetMapping]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityProfileTargetMappings = securityProfileTargetMappings
    }
}

public struct ListStreamsInput {
    /// Set to true to return the list of streams in ascending order.
    public var ascendingOrder: Swift.Bool?
    /// The maximum number of results to return at a time.
    public var maxResults: Swift.Int?
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        ascendingOrder: Swift.Bool? = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTClientTypes {
    /// A summary of a stream.
    public struct StreamSummary {
        /// A description of the stream.
        public var description: Swift.String?
        /// The stream ARN.
        public var streamArn: Swift.String?
        /// The stream ID.
        public var streamId: Swift.String?
        /// The stream version.
        public var streamVersion: Swift.Int?

        public init(
            description: Swift.String? = nil,
            streamArn: Swift.String? = nil,
            streamId: Swift.String? = nil,
            streamVersion: Swift.Int? = nil
        )
        {
            self.description = description
            self.streamArn = streamArn
            self.streamId = streamId
            self.streamVersion = streamVersion
        }
    }

}

public struct ListStreamsOutput {
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of streams.
    public var streams: [IoTClientTypes.StreamSummary]?

    public init(
        nextToken: Swift.String? = nil,
        streams: [IoTClientTypes.StreamSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streams = streams
    }
}

public struct ListTagsForResourceInput {
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of tags assigned to the resource.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct ListTargetsForPolicyInput {
    /// A marker used to get the next set of results.
    public var marker: Swift.String?
    /// The maximum number of results to return at one time.
    public var pageSize: Swift.Int?
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
        self.policyName = policyName
    }
}

public struct ListTargetsForPolicyOutput {
    /// A marker used to get the next set of results.
    public var nextMarker: Swift.String?
    /// The policy targets.
    public var targets: [Swift.String]?

    public init(
        nextMarker: Swift.String? = nil,
        targets: [Swift.String]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.targets = targets
    }
}

public struct ListTargetsForSecurityProfileInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The security profile.
    /// This member is required.
    public var securityProfileName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfileName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileName = securityProfileName
    }
}

public struct ListTargetsForSecurityProfileOutput {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The thing groups to which the security profile is attached.
    public var securityProfileTargets: [IoTClientTypes.SecurityProfileTarget]?

    public init(
        nextToken: Swift.String? = nil,
        securityProfileTargets: [IoTClientTypes.SecurityProfileTarget]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityProfileTargets = securityProfileTargets
    }
}

public struct ListThingGroupsInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A filter that limits the results to those with the specified name prefix.
    public var namePrefixFilter: Swift.String?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// A filter that limits the results to those with the specified parent group.
    public var parentGroup: Swift.String?
    /// If true, return child groups as well.
    public var recursive: Swift.Bool?

    public init(
        maxResults: Swift.Int? = nil,
        namePrefixFilter: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        parentGroup: Swift.String? = nil,
        recursive: Swift.Bool? = nil
    )
    {
        self.maxResults = maxResults
        self.namePrefixFilter = namePrefixFilter
        self.nextToken = nextToken
        self.parentGroup = parentGroup
        self.recursive = recursive
    }
}

public struct ListThingGroupsOutput {
    /// The token to use to get the next set of results. Will not be returned if operation has returned all results.
    public var nextToken: Swift.String?
    /// The thing groups.
    public var thingGroups: [IoTClientTypes.GroupNameAndArn]?

    public init(
        nextToken: Swift.String? = nil,
        thingGroups: [IoTClientTypes.GroupNameAndArn]? = nil
    )
    {
        self.nextToken = nextToken
        self.thingGroups = thingGroups
    }
}

public struct ListThingGroupsForThingInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingName = thingName
    }
}

public struct ListThingGroupsForThingOutput {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The thing groups.
    public var thingGroups: [IoTClientTypes.GroupNameAndArn]?

    public init(
        nextToken: Swift.String? = nil,
        thingGroups: [IoTClientTypes.GroupNameAndArn]? = nil
    )
    {
        self.nextToken = nextToken
        self.thingGroups = thingGroups
    }
}

/// The input for the ListThingPrincipal operation.
public struct ListThingPrincipalsInput {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingName = thingName
    }
}

/// The output from the ListThingPrincipals operation.
public struct ListThingPrincipalsOutput {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The principals associated with the thing.
    public var principals: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        principals: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.principals = principals
    }
}

extension IoTClientTypes {

    public enum ReportType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case errors
        case results
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportType] {
            return [
                .errors,
                .results
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .errors: return "ERRORS"
            case .results: return "RESULTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListThingRegistrationTaskReportsInput {
    /// The maximum number of results to return per request.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The type of task report.
    /// This member is required.
    public var reportType: IoTClientTypes.ReportType?
    /// The id of the task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        reportType: IoTClientTypes.ReportType? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reportType = reportType
        self.taskId = taskId
    }
}

public struct ListThingRegistrationTaskReportsOutput {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The type of task report.
    public var reportType: IoTClientTypes.ReportType?
    /// Links to the task resources.
    public var resourceLinks: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        reportType: IoTClientTypes.ReportType? = nil,
        resourceLinks: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportType = reportType
        self.resourceLinks = resourceLinks
    }
}

public struct ListThingRegistrationTasksInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The status of the bulk thing provisioning task.
    public var status: IoTClientTypes.Status?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: IoTClientTypes.Status? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

public struct ListThingRegistrationTasksOutput {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of bulk thing provisioning task IDs.
    public var taskIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        taskIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskIds = taskIds
    }
}

/// The input for the ListThings operation.
public struct ListThingsInput {
    /// The attribute name used to search for things.
    public var attributeName: Swift.String?
    /// The attribute value used to search for things.
    public var attributeValue: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The name of the thing type used to search for things.
    public var thingTypeName: Swift.String?
    /// When true, the action returns the thing resources with attribute values that start with the attributeValue provided. When false, or not present, the action returns only the thing resources with attribute values that match the entire attributeValue provided.
    public var usePrefixAttributeValue: Swift.Bool?

    public init(
        attributeName: Swift.String? = nil,
        attributeValue: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        thingTypeName: Swift.String? = nil,
        usePrefixAttributeValue: Swift.Bool? = false
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingTypeName = thingTypeName
        self.usePrefixAttributeValue = usePrefixAttributeValue
    }
}

extension IoTClientTypes {
    /// The properties of the thing, including thing name, thing type name, and a list of thing attributes.
    public struct ThingAttribute {
        /// A list of thing attributes which are name-value pairs.
        public var attributes: [Swift.String: Swift.String]?
        /// The thing ARN.
        public var thingArn: Swift.String?
        /// The name of the thing.
        public var thingName: Swift.String?
        /// The name of the thing type, if the thing has been associated with a type.
        public var thingTypeName: Swift.String?
        /// The version of the thing record in the registry.
        public var version: Swift.Int

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            thingArn: Swift.String? = nil,
            thingName: Swift.String? = nil,
            thingTypeName: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.attributes = attributes
            self.thingArn = thingArn
            self.thingName = thingName
            self.thingTypeName = thingTypeName
            self.version = version
        }
    }

}

/// The output from the ListThings operation.
public struct ListThingsOutput {
    /// The token to use to get the next set of results. Will not be returned if operation has returned all results.
    public var nextToken: Swift.String?
    /// The things.
    public var things: [IoTClientTypes.ThingAttribute]?

    public init(
        nextToken: Swift.String? = nil,
        things: [IoTClientTypes.ThingAttribute]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

public struct ListThingsInBillingGroupInput {
    /// The name of the billing group.
    /// This member is required.
    public var billingGroupName: Swift.String?
    /// The maximum number of results to return per request.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        billingGroupName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingGroupName = billingGroupName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListThingsInBillingGroupOutput {
    /// The token to use to get the next set of results. Will not be returned if operation has returned all results.
    public var nextToken: Swift.String?
    /// A list of things in the billing group.
    public var things: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        things: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

public struct ListThingsInThingGroupInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// When true, list things in this thing group and in all child groups as well.
    public var recursive: Swift.Bool?
    /// The thing group name.
    /// This member is required.
    public var thingGroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recursive: Swift.Bool? = false,
        thingGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recursive = recursive
        self.thingGroupName = thingGroupName
    }
}

public struct ListThingsInThingGroupOutput {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The things in the specified thing group.
    public var things: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        things: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

/// The input for the ListThingTypes operation.
public struct ListThingTypesInput {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The name of the thing type.
    public var thingTypeName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        thingTypeName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingTypeName = thingTypeName
    }
}

extension IoTClientTypes {
    /// The definition of the thing type, including thing type name and description.
    public struct ThingTypeDefinition {
        /// The thing type ARN.
        public var thingTypeArn: Swift.String?
        /// The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when it was deprecated.
        public var thingTypeMetadata: IoTClientTypes.ThingTypeMetadata?
        /// The name of the thing type.
        public var thingTypeName: Swift.String?
        /// The ThingTypeProperties for the thing type.
        public var thingTypeProperties: IoTClientTypes.ThingTypeProperties?

        public init(
            thingTypeArn: Swift.String? = nil,
            thingTypeMetadata: IoTClientTypes.ThingTypeMetadata? = nil,
            thingTypeName: Swift.String? = nil,
            thingTypeProperties: IoTClientTypes.ThingTypeProperties? = nil
        )
        {
            self.thingTypeArn = thingTypeArn
            self.thingTypeMetadata = thingTypeMetadata
            self.thingTypeName = thingTypeName
            self.thingTypeProperties = thingTypeProperties
        }
    }

}

/// The output for the ListThingTypes operation.
public struct ListThingTypesOutput {
    /// The token for the next set of results. Will not be returned if operation has returned all results.
    public var nextToken: Swift.String?
    /// The thing types.
    public var thingTypes: [IoTClientTypes.ThingTypeDefinition]?

    public init(
        nextToken: Swift.String? = nil,
        thingTypes: [IoTClientTypes.ThingTypeDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.thingTypes = thingTypes
    }
}

public struct ListTopicRuleDestinationsInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTClientTypes {
    /// Information about an HTTP URL destination.
    public struct HttpUrlDestinationSummary {
        /// The URL used to confirm ownership of or access to the HTTP topic rule destination URL.
        public var confirmationUrl: Swift.String?

        public init(
            confirmationUrl: Swift.String? = nil
        )
        {
            self.confirmationUrl = confirmationUrl
        }
    }

}

extension IoTClientTypes {
    /// The summary of a virtual private cloud (VPC) destination.
    public struct VpcDestinationSummary {
        /// The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
        public var roleArn: Swift.String?
        /// The security groups of the VPC destination.
        public var securityGroups: [Swift.String]?
        /// The subnet IDs of the VPC destination.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.securityGroups = securityGroups
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension IoTClientTypes {
    /// Information about the topic rule destination.
    public struct TopicRuleDestinationSummary {
        /// The topic rule destination ARN.
        public var arn: Swift.String?
        /// The date and time when the topic rule destination was created.
        public var createdAt: Foundation.Date?
        /// Information about the HTTP URL.
        public var httpUrlSummary: IoTClientTypes.HttpUrlDestinationSummary?
        /// The date and time when the topic rule destination was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The status of the topic rule destination. Valid values are: IN_PROGRESS A topic rule destination was created but has not been confirmed. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint. ENABLED Confirmation was completed, and traffic to this destination is allowed. You can set status to DISABLED by calling UpdateTopicRuleDestination. DISABLED Confirmation was completed, and traffic to this destination is not allowed. You can set status to ENABLED by calling UpdateTopicRuleDestination. ERROR Confirmation could not be completed, for example if the confirmation timed out. You can call GetTopicRuleDestination for details about the error. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint.
        public var status: IoTClientTypes.TopicRuleDestinationStatus?
        /// The reason the topic rule destination is in the current status.
        public var statusReason: Swift.String?
        /// Information about the virtual private cloud (VPC) connection.
        public var vpcDestinationSummary: IoTClientTypes.VpcDestinationSummary?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            httpUrlSummary: IoTClientTypes.HttpUrlDestinationSummary? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            status: IoTClientTypes.TopicRuleDestinationStatus? = nil,
            statusReason: Swift.String? = nil,
            vpcDestinationSummary: IoTClientTypes.VpcDestinationSummary? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.httpUrlSummary = httpUrlSummary
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.statusReason = statusReason
            self.vpcDestinationSummary = vpcDestinationSummary
        }
    }

}

public struct ListTopicRuleDestinationsOutput {
    /// Information about a topic rule destination.
    public var destinationSummaries: [IoTClientTypes.TopicRuleDestinationSummary]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        destinationSummaries: [IoTClientTypes.TopicRuleDestinationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationSummaries = destinationSummaries
        self.nextToken = nextToken
    }
}

/// The input for the ListTopicRules operation.
public struct ListTopicRulesInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// Specifies whether the rule is disabled.
    public var ruleDisabled: Swift.Bool?
    /// The topic.
    public var topic: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ruleDisabled: Swift.Bool? = nil,
        topic: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ruleDisabled = ruleDisabled
        self.topic = topic
    }
}

extension IoTClientTypes {
    /// Describes a rule.
    public struct TopicRuleListItem {
        /// The date and time the rule was created.
        public var createdAt: Foundation.Date?
        /// The rule ARN.
        public var ruleArn: Swift.String?
        /// Specifies whether the rule is disabled.
        public var ruleDisabled: Swift.Bool?
        /// The name of the rule.
        public var ruleName: Swift.String?
        /// The pattern for the topic names that apply.
        public var topicPattern: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            ruleArn: Swift.String? = nil,
            ruleDisabled: Swift.Bool? = nil,
            ruleName: Swift.String? = nil,
            topicPattern: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.ruleArn = ruleArn
            self.ruleDisabled = ruleDisabled
            self.ruleName = ruleName
            self.topicPattern = topicPattern
        }
    }

}

/// The output from the ListTopicRules operation.
public struct ListTopicRulesOutput {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The rules.
    public var rules: [IoTClientTypes.TopicRuleListItem]?

    public init(
        nextToken: Swift.String? = nil,
        rules: [IoTClientTypes.TopicRuleListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.rules = rules
    }
}

public struct ListV2LoggingLevelsInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The type of resource for which you are configuring logging. Must be THING_Group.
    public var targetType: IoTClientTypes.LogTargetType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetType: IoTClientTypes.LogTargetType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetType = targetType
    }
}

extension IoTClientTypes {
    /// A log target.
    public struct LogTarget {
        /// The target name.
        public var targetName: Swift.String?
        /// The target type.
        /// This member is required.
        public var targetType: IoTClientTypes.LogTargetType?

        public init(
            targetName: Swift.String? = nil,
            targetType: IoTClientTypes.LogTargetType? = nil
        )
        {
            self.targetName = targetName
            self.targetType = targetType
        }
    }

}

extension IoTClientTypes {
    /// The target configuration.
    public struct LogTargetConfiguration {
        /// The logging level.
        public var logLevel: IoTClientTypes.LogLevel?
        /// A log target
        public var logTarget: IoTClientTypes.LogTarget?

        public init(
            logLevel: IoTClientTypes.LogLevel? = nil,
            logTarget: IoTClientTypes.LogTarget? = nil
        )
        {
            self.logLevel = logLevel
            self.logTarget = logTarget
        }
    }

}

public struct ListV2LoggingLevelsOutput {
    /// The logging configuration for a target.
    public var logTargetConfigurations: [IoTClientTypes.LogTargetConfiguration]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        logTargetConfigurations: [IoTClientTypes.LogTargetConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.logTargetConfigurations = logTargetConfigurations
        self.nextToken = nextToken
    }
}

public struct ListViolationEventsInput {
    /// The criteria for a behavior.
    public var behaviorCriteriaType: IoTClientTypes.BehaviorCriteriaType?
    /// The end time for the alerts to be listed.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// A list of all suppressed alerts.
    public var listSuppressedAlerts: Swift.Bool?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// A filter to limit results to those alerts generated by the specified security profile.
    public var securityProfileName: Swift.String?
    /// The start time for the alerts to be listed.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// A filter to limit results to those alerts caused by the specified thing.
    public var thingName: Swift.String?
    /// The verification state of the violation (detect alarm).
    public var verificationState: IoTClientTypes.VerificationState?

    public init(
        behaviorCriteriaType: IoTClientTypes.BehaviorCriteriaType? = nil,
        endTime: Foundation.Date? = nil,
        listSuppressedAlerts: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfileName: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        thingName: Swift.String? = nil,
        verificationState: IoTClientTypes.VerificationState? = nil
    )
    {
        self.behaviorCriteriaType = behaviorCriteriaType
        self.endTime = endTime
        self.listSuppressedAlerts = listSuppressedAlerts
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileName = securityProfileName
        self.startTime = startTime
        self.thingName = thingName
        self.verificationState = verificationState
    }
}

extension IoTClientTypes {

    public enum ViolationEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alarmCleared
        case alarmInvalidated
        case inAlarm
        case sdkUnknown(Swift.String)

        public static var allCases: [ViolationEventType] {
            return [
                .alarmCleared,
                .alarmInvalidated,
                .inAlarm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alarmCleared: return "alarm-cleared"
            case .alarmInvalidated: return "alarm-invalidated"
            case .inAlarm: return "in-alarm"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTClientTypes {
    /// Information about a Device Defender security profile behavior violation.
    public struct ViolationEvent {
        /// The behavior that was violated.
        public var behavior: IoTClientTypes.Behavior?
        /// The value of the metric (the measurement).
        public var metricValue: IoTClientTypes.MetricValue?
        /// The name of the security profile whose behavior was violated.
        public var securityProfileName: Swift.String?
        /// The name of the thing responsible for the violation event.
        public var thingName: Swift.String?
        /// The verification state of the violation (detect alarm).
        public var verificationState: IoTClientTypes.VerificationState?
        /// The description of the verification state of the violation.
        public var verificationStateDescription: Swift.String?
        /// The details of a violation event.
        public var violationEventAdditionalInfo: IoTClientTypes.ViolationEventAdditionalInfo?
        /// The time the violation event occurred.
        public var violationEventTime: Foundation.Date?
        /// The type of violation event.
        public var violationEventType: IoTClientTypes.ViolationEventType?
        /// The ID of the violation event.
        public var violationId: Swift.String?

        public init(
            behavior: IoTClientTypes.Behavior? = nil,
            metricValue: IoTClientTypes.MetricValue? = nil,
            securityProfileName: Swift.String? = nil,
            thingName: Swift.String? = nil,
            verificationState: IoTClientTypes.VerificationState? = nil,
            verificationStateDescription: Swift.String? = nil,
            violationEventAdditionalInfo: IoTClientTypes.ViolationEventAdditionalInfo? = nil,
            violationEventTime: Foundation.Date? = nil,
            violationEventType: IoTClientTypes.ViolationEventType? = nil,
            violationId: Swift.String? = nil
        )
        {
            self.behavior = behavior
            self.metricValue = metricValue
            self.securityProfileName = securityProfileName
            self.thingName = thingName
            self.verificationState = verificationState
            self.verificationStateDescription = verificationStateDescription
            self.violationEventAdditionalInfo = violationEventAdditionalInfo
            self.violationEventTime = violationEventTime
            self.violationEventType = violationEventType
            self.violationId = violationId
        }
    }

}

public struct ListViolationEventsOutput {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The security profile violation alerts issued for this account during the given time period, potentially filtered by security profile, behavior violated, or thing (device) violating.
    public var violationEvents: [IoTClientTypes.ViolationEvent]?

    public init(
        nextToken: Swift.String? = nil,
        violationEvents: [IoTClientTypes.ViolationEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.violationEvents = violationEvents
    }
}

public struct PutVerificationStateOnViolationInput {
    /// The verification state of the violation.
    /// This member is required.
    public var verificationState: IoTClientTypes.VerificationState?
    /// The description of the verification state of the violation (detect alarm).
    public var verificationStateDescription: Swift.String?
    /// The violation ID.
    /// This member is required.
    public var violationId: Swift.String?

    public init(
        verificationState: IoTClientTypes.VerificationState? = nil,
        verificationStateDescription: Swift.String? = nil,
        violationId: Swift.String? = nil
    )
    {
        self.verificationState = verificationState
        self.verificationStateDescription = verificationStateDescription
        self.violationId = violationId
    }
}

public struct PutVerificationStateOnViolationOutput {

    public init() { }
}

/// The registration code is invalid.
public struct RegistrationCodeValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Additional information about the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RegistrationCodeValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input to the RegisterCACertificate operation.
public struct RegisterCACertificateInput {
    /// Allows this CA certificate to be used for auto registration of device certificates.
    public var allowAutoRegistration: Swift.Bool?
    /// The CA certificate.
    /// This member is required.
    public var caCertificate: Swift.String?
    /// Describes the certificate mode in which the Certificate Authority (CA) will be registered. If the verificationCertificate field is not provided, set certificateMode to be SNI_ONLY. If the verificationCertificate field is provided, set certificateMode to be DEFAULT. When certificateMode is not provided, it defaults to DEFAULT. All the device certificates that are registered using this CA will be registered in the same certificate mode as the CA. For more information about certificate mode for device certificates, see [ certificate mode](https://docs.aws.amazon.com/iot/latest/apireference/API_CertificateDescription.html#iot-Type-CertificateDescription-certificateMode).
    public var certificateMode: IoTClientTypes.CertificateMode?
    /// Information about the registration configuration.
    public var registrationConfig: IoTClientTypes.RegistrationConfig?
    /// A boolean value that specifies if the CA certificate is set to active. Valid values: ACTIVE | INACTIVE
    public var setAsActive: Swift.Bool?
    /// Metadata which can be used to manage the CA certificate. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: [IoTClientTypes.Tag]?
    /// The private key verification certificate. If certificateMode is SNI_ONLY, the verificationCertificate field must be empty. If certificateMode is DEFAULT or not provided, the verificationCertificate field must not be empty.
    public var verificationCertificate: Swift.String?

    public init(
        allowAutoRegistration: Swift.Bool? = false,
        caCertificate: Swift.String? = nil,
        certificateMode: IoTClientTypes.CertificateMode? = nil,
        registrationConfig: IoTClientTypes.RegistrationConfig? = nil,
        setAsActive: Swift.Bool? = false,
        tags: [IoTClientTypes.Tag]? = nil,
        verificationCertificate: Swift.String? = nil
    )
    {
        self.allowAutoRegistration = allowAutoRegistration
        self.caCertificate = caCertificate
        self.certificateMode = certificateMode
        self.registrationConfig = registrationConfig
        self.setAsActive = setAsActive
        self.tags = tags
        self.verificationCertificate = verificationCertificate
    }
}

/// The output from the RegisterCACertificateResponse operation.
public struct RegisterCACertificateOutput {
    /// The CA certificate ARN.
    public var certificateArn: Swift.String?
    /// The CA certificate identifier.
    public var certificateId: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        certificateId: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
    }
}

/// Unable to verify the CA certificate used to sign the device certificate you are attempting to register. This is happens when you have registered more than one CA certificate that has the same subject field and public key.
public struct CertificateConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CertificateConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input to the RegisterCertificate operation.
public struct RegisterCertificateInput {
    /// The CA certificate used to sign the device certificate being registered.
    public var caCertificatePem: Swift.String?
    /// The certificate data, in PEM format.
    /// This member is required.
    public var certificatePem: Swift.String?
    /// A boolean value that specifies if the certificate is set to active. Valid values: ACTIVE | INACTIVE
    @available(*, deprecated)
    public var setAsActive: Swift.Bool?
    /// The status of the register certificate request. Valid values that you can use include ACTIVE, INACTIVE, and REVOKED.
    public var status: IoTClientTypes.CertificateStatus?

    public init(
        caCertificatePem: Swift.String? = nil,
        certificatePem: Swift.String? = nil,
        setAsActive: Swift.Bool? = nil,
        status: IoTClientTypes.CertificateStatus? = nil
    )
    {
        self.caCertificatePem = caCertificatePem
        self.certificatePem = certificatePem
        self.setAsActive = setAsActive
        self.status = status
    }
}

/// The output from the RegisterCertificate operation.
public struct RegisterCertificateOutput {
    /// The certificate ARN.
    public var certificateArn: Swift.String?
    /// The certificate identifier.
    public var certificateId: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        certificateId: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
    }
}

public struct RegisterCertificateWithoutCAInput {
    /// The certificate data, in PEM format.
    /// This member is required.
    public var certificatePem: Swift.String?
    /// The status of the register certificate request.
    public var status: IoTClientTypes.CertificateStatus?

    public init(
        certificatePem: Swift.String? = nil,
        status: IoTClientTypes.CertificateStatus? = nil
    )
    {
        self.certificatePem = certificatePem
        self.status = status
    }
}

public struct RegisterCertificateWithoutCAOutput {
    /// The Amazon Resource Name (ARN) of the registered certificate.
    public var certificateArn: Swift.String?
    /// The ID of the registered certificate. (The last part of the certificate ARN contains the certificate ID.
    public var certificateId: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        certificateId: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
    }
}

/// The resource registration failed.
public struct ResourceRegistrationFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceRegistrationFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct RegisterThingInput {
    /// The parameters for provisioning a thing. See [Provisioning Templates](https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html) for more information.
    public var parameters: [Swift.String: Swift.String]?
    /// The provisioning template. See [Provisioning Devices That Have Device Certificates](https://docs.aws.amazon.com/iot/latest/developerguide/provision-w-cert.html) for more information.
    /// This member is required.
    public var templateBody: Swift.String?

    public init(
        parameters: [Swift.String: Swift.String]? = nil,
        templateBody: Swift.String? = nil
    )
    {
        self.parameters = parameters
        self.templateBody = templateBody
    }
}

public struct RegisterThingOutput {
    /// The certificate data, in PEM format.
    public var certificatePem: Swift.String?
    /// ARNs for the generated resources.
    public var resourceArns: [Swift.String: Swift.String]?

    public init(
        certificatePem: Swift.String? = nil,
        resourceArns: [Swift.String: Swift.String]? = nil
    )
    {
        self.certificatePem = certificatePem
        self.resourceArns = resourceArns
    }
}

/// The input for the RejectCertificateTransfer operation.
public struct RejectCertificateTransferInput {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?
    /// The reason the certificate transfer was rejected.
    public var rejectReason: Swift.String?

    public init(
        certificateId: Swift.String? = nil,
        rejectReason: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.rejectReason = rejectReason
    }
}

public struct RemoveThingFromBillingGroupInput {
    /// The ARN of the billing group.
    public var billingGroupArn: Swift.String?
    /// The name of the billing group.
    public var billingGroupName: Swift.String?
    /// The ARN of the thing to be removed from the billing group.
    public var thingArn: Swift.String?
    /// The name of the thing to be removed from the billing group.
    public var thingName: Swift.String?

    public init(
        billingGroupArn: Swift.String? = nil,
        billingGroupName: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingGroupName = billingGroupName
        self.thingArn = thingArn
        self.thingName = thingName
    }
}

public struct RemoveThingFromBillingGroupOutput {

    public init() { }
}

public struct RemoveThingFromThingGroupInput {
    /// The ARN of the thing to remove from the group.
    public var thingArn: Swift.String?
    /// The group ARN.
    public var thingGroupArn: Swift.String?
    /// The group name.
    public var thingGroupName: Swift.String?
    /// The name of the thing to remove from the group.
    public var thingName: Swift.String?

    public init(
        thingArn: Swift.String? = nil,
        thingGroupArn: Swift.String? = nil,
        thingGroupName: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.thingArn = thingArn
        self.thingGroupArn = thingGroupArn
        self.thingGroupName = thingGroupName
        self.thingName = thingName
    }
}

public struct RemoveThingFromThingGroupOutput {

    public init() { }
}

/// The input for the ReplaceTopicRule operation.
public struct ReplaceTopicRuleInput {
    /// The name of the rule.
    /// This member is required.
    public var ruleName: Swift.String?
    /// The rule payload.
    /// This member is required.
    public var topicRulePayload: IoTClientTypes.TopicRulePayload?

    public init(
        ruleName: Swift.String? = nil,
        topicRulePayload: IoTClientTypes.TopicRulePayload? = nil
    )
    {
        self.ruleName = ruleName
        self.topicRulePayload = topicRulePayload
    }
}

public struct SearchIndexInput {
    /// The search index name.
    public var indexName: Swift.String?
    /// The maximum number of results to return per page at one time. This maximum number cannot exceed 100. The response might contain fewer results but will never contain more. You can use [nextToken](https://docs.aws.amazon.com/iot/latest/apireference/API_SearchIndex.html#iot-SearchIndex-request-nextToken) to retrieve the next set of results until nextToken returns NULL.
    public var maxResults: Swift.Int?
    /// The token used to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The search query string. For more information about the search query syntax, see [Query syntax](https://docs.aws.amazon.com/iot/latest/developerguide/query-syntax.html).
    /// This member is required.
    public var queryString: Swift.String?
    /// The query version.
    public var queryVersion: Swift.String?

    public init(
        indexName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil
    )
    {
        self.indexName = indexName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

extension IoTClientTypes {
    /// The thing group search index document.
    public struct ThingGroupDocument {
        /// The thing group attributes.
        public var attributes: [Swift.String: Swift.String]?
        /// Parent group names.
        public var parentGroupNames: [Swift.String]?
        /// The thing group description.
        public var thingGroupDescription: Swift.String?
        /// The thing group ID.
        public var thingGroupId: Swift.String?
        /// The thing group name.
        public var thingGroupName: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            parentGroupNames: [Swift.String]? = nil,
            thingGroupDescription: Swift.String? = nil,
            thingGroupId: Swift.String? = nil,
            thingGroupName: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.parentGroupNames = parentGroupNames
            self.thingGroupDescription = thingGroupDescription
            self.thingGroupId = thingGroupId
            self.thingGroupName = thingGroupName
        }
    }

}

extension IoTClientTypes {
    /// The connectivity status of the thing.
    public struct ThingConnectivity {
        /// True if the thing is connected to the Amazon Web Services IoT Core service; false if it is not connected.
        public var connected: Swift.Bool?
        /// The reason why the client is disconnected. If the thing has been disconnected for approximately an hour, the disconnectReason value might be missing.
        public var disconnectReason: Swift.String?
        /// The epoch time (in milliseconds) when the thing last connected or disconnected. If the thing has been disconnected for approximately an hour, the time value might be missing.
        public var timestamp: Swift.Int?

        public init(
            connected: Swift.Bool? = nil,
            disconnectReason: Swift.String? = nil,
            timestamp: Swift.Int? = nil
        )
        {
            self.connected = connected
            self.disconnectReason = disconnectReason
            self.timestamp = timestamp
        }
    }

}

extension IoTClientTypes {
    /// The thing search index document.
    public struct ThingDocument {
        /// The attributes.
        public var attributes: [Swift.String: Swift.String]?
        /// Indicates whether the thing is connected to the Amazon Web Services IoT Core service.
        public var connectivity: IoTClientTypes.ThingConnectivity?
        /// Contains Device Defender data. For more information about Device Defender, see [Device Defender](https://docs.aws.amazon.com/iot/latest/developerguide/device-defender.html).
        public var deviceDefender: Swift.String?
        /// The unnamed shadow and named shadow. For more information about shadows, see [IoT Device Shadow service.](https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html)
        public var shadow: Swift.String?
        /// Thing group names.
        public var thingGroupNames: [Swift.String]?
        /// The thing ID.
        public var thingId: Swift.String?
        /// The thing name.
        public var thingName: Swift.String?
        /// The thing type name.
        public var thingTypeName: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            connectivity: IoTClientTypes.ThingConnectivity? = nil,
            deviceDefender: Swift.String? = nil,
            shadow: Swift.String? = nil,
            thingGroupNames: [Swift.String]? = nil,
            thingId: Swift.String? = nil,
            thingName: Swift.String? = nil,
            thingTypeName: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.connectivity = connectivity
            self.deviceDefender = deviceDefender
            self.shadow = shadow
            self.thingGroupNames = thingGroupNames
            self.thingId = thingId
            self.thingName = thingName
            self.thingTypeName = thingTypeName
        }
    }

}

public struct SearchIndexOutput {
    /// The token used to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The thing groups that match the search query.
    public var thingGroups: [IoTClientTypes.ThingGroupDocument]?
    /// The things that match the search query.
    public var things: [IoTClientTypes.ThingDocument]?

    public init(
        nextToken: Swift.String? = nil,
        thingGroups: [IoTClientTypes.ThingGroupDocument]? = nil,
        things: [IoTClientTypes.ThingDocument]? = nil
    )
    {
        self.nextToken = nextToken
        self.thingGroups = thingGroups
        self.things = things
    }
}

public struct SetDefaultAuthorizerInput {
    /// The authorizer name.
    /// This member is required.
    public var authorizerName: Swift.String?

    public init(
        authorizerName: Swift.String? = nil
    )
    {
        self.authorizerName = authorizerName
    }
}

public struct SetDefaultAuthorizerOutput {
    /// The authorizer ARN.
    public var authorizerArn: Swift.String?
    /// The authorizer name.
    public var authorizerName: Swift.String?

    public init(
        authorizerArn: Swift.String? = nil,
        authorizerName: Swift.String? = nil
    )
    {
        self.authorizerArn = authorizerArn
        self.authorizerName = authorizerName
    }
}

/// The input for the SetDefaultPolicyVersion operation.
public struct SetDefaultPolicyVersionInput {
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?
    /// The policy version ID.
    /// This member is required.
    public var policyVersionId: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        policyVersionId: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

extension IoTClientTypes {
    /// Describes the logging options payload.
    public struct LoggingOptionsPayload {
        /// The log level.
        public var logLevel: IoTClientTypes.LogLevel?
        /// The ARN of the IAM role that grants access.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            logLevel: IoTClientTypes.LogLevel? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.logLevel = logLevel
            self.roleArn = roleArn
        }
    }

}

/// The input for the SetLoggingOptions operation.
public struct SetLoggingOptionsInput {
    /// The logging options payload.
    /// This member is required.
    public var loggingOptionsPayload: IoTClientTypes.LoggingOptionsPayload?

    public init(
        loggingOptionsPayload: IoTClientTypes.LoggingOptionsPayload? = nil
    )
    {
        self.loggingOptionsPayload = loggingOptionsPayload
    }
}

public struct SetV2LoggingLevelInput {
    /// The log level.
    /// This member is required.
    public var logLevel: IoTClientTypes.LogLevel?
    /// The log target.
    /// This member is required.
    public var logTarget: IoTClientTypes.LogTarget?

    public init(
        logLevel: IoTClientTypes.LogLevel? = nil,
        logTarget: IoTClientTypes.LogTarget? = nil
    )
    {
        self.logLevel = logLevel
        self.logTarget = logTarget
    }
}

public struct SetV2LoggingOptionsInput {
    /// The default logging level.
    public var defaultLogLevel: IoTClientTypes.LogLevel?
    /// If true all logs are disabled. The default is false.
    public var disableAllLogs: Swift.Bool?
    /// The ARN of the role that allows IoT to write to Cloudwatch logs.
    public var roleArn: Swift.String?

    public init(
        defaultLogLevel: IoTClientTypes.LogLevel? = nil,
        disableAllLogs: Swift.Bool? = false,
        roleArn: Swift.String? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.disableAllLogs = disableAllLogs
        self.roleArn = roleArn
    }
}

/// This exception occurs if you attempt to start a task with the same task-id as an existing task but with a different clientRequestToken.
public struct TaskAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TaskAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartAuditMitigationActionsTaskInput {
    /// For an audit check, specifies which mitigation actions to apply. Those actions must be defined in your Amazon Web Services accounts.
    /// This member is required.
    public var auditCheckToActionsMapping: [Swift.String: [Swift.String]]?
    /// Each audit mitigation task must have a unique client request token. If you try to start a new task with the same token as a task that already exists, an exception occurs. If you omit this value, a unique client request token is generated automatically.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Specifies the audit findings to which the mitigation actions are applied. You can apply them to a type of audit check, to all findings from an audit, or to a specific set of findings.
    /// This member is required.
    public var target: IoTClientTypes.AuditMitigationActionsTaskTarget?
    /// A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        auditCheckToActionsMapping: [Swift.String: [Swift.String]]? = nil,
        clientRequestToken: Swift.String? = nil,
        target: IoTClientTypes.AuditMitigationActionsTaskTarget? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.auditCheckToActionsMapping = auditCheckToActionsMapping
        self.clientRequestToken = clientRequestToken
        self.target = target
        self.taskId = taskId
    }
}

public struct StartAuditMitigationActionsTaskOutput {
    /// The unique identifier for the audit mitigation task. This matches the taskId that you specified in the request.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

public struct StartDetectMitigationActionsTaskInput {
    /// The actions to be performed when a device has unexpected behavior.
    /// This member is required.
    public var actions: [Swift.String]?
    /// Each mitigation action task must have a unique client request token. If you try to create a new task with the same token as a task that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Specifies to list only active violations.
    public var includeOnlyActiveViolations: Swift.Bool?
    /// Specifies to include suppressed alerts.
    public var includeSuppressedAlerts: Swift.Bool?
    /// Specifies the ML Detect findings to which the mitigation actions are applied.
    /// This member is required.
    public var target: IoTClientTypes.DetectMitigationActionsTaskTarget?
    /// The unique identifier of the task.
    /// This member is required.
    public var taskId: Swift.String?
    /// Specifies the time period of which violation events occurred between.
    public var violationEventOccurrenceRange: IoTClientTypes.ViolationEventOccurrenceRange?

    public init(
        actions: [Swift.String]? = nil,
        clientRequestToken: Swift.String? = nil,
        includeOnlyActiveViolations: Swift.Bool? = nil,
        includeSuppressedAlerts: Swift.Bool? = nil,
        target: IoTClientTypes.DetectMitigationActionsTaskTarget? = nil,
        taskId: Swift.String? = nil,
        violationEventOccurrenceRange: IoTClientTypes.ViolationEventOccurrenceRange? = nil
    )
    {
        self.actions = actions
        self.clientRequestToken = clientRequestToken
        self.includeOnlyActiveViolations = includeOnlyActiveViolations
        self.includeSuppressedAlerts = includeSuppressedAlerts
        self.target = target
        self.taskId = taskId
        self.violationEventOccurrenceRange = violationEventOccurrenceRange
    }
}

public struct StartDetectMitigationActionsTaskOutput {
    /// The unique identifier of the task.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

public struct StartOnDemandAuditTaskInput {
    /// Which checks are performed during the audit. The checks you specify must be enabled for your account or an exception occurs. Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or UpdateAccountAuditConfiguration to select which checks are enabled.
    /// This member is required.
    public var targetCheckNames: [Swift.String]?

    public init(
        targetCheckNames: [Swift.String]? = nil
    )
    {
        self.targetCheckNames = targetCheckNames
    }
}

public struct StartOnDemandAuditTaskOutput {
    /// The ID of the on-demand audit you started.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

public struct StartThingRegistrationTaskInput {
    /// The S3 bucket that contains the input file.
    /// This member is required.
    public var inputFileBucket: Swift.String?
    /// The name of input file within the S3 bucket. This file contains a newline delimited JSON file. Each line contains the parameter values to provision one device (thing).
    /// This member is required.
    public var inputFileKey: Swift.String?
    /// The IAM role ARN that grants permission the input file.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The provisioning template.
    /// This member is required.
    public var templateBody: Swift.String?

    public init(
        inputFileBucket: Swift.String? = nil,
        inputFileKey: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        templateBody: Swift.String? = nil
    )
    {
        self.inputFileBucket = inputFileBucket
        self.inputFileKey = inputFileKey
        self.roleArn = roleArn
        self.templateBody = templateBody
    }
}

public struct StartThingRegistrationTaskOutput {
    /// The bulk thing provisioning task ID.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

public struct StopThingRegistrationTaskInput {
    /// The bulk thing provisioning task ID.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

public struct StopThingRegistrationTaskOutput {

    public init() { }
}

public struct TagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new or modified tags for the resource.
    /// This member is required.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct TestAuthorizationInput {
    /// A list of authorization info objects. Simulating authorization will create a response for each authInfo object in the list.
    /// This member is required.
    public var authInfos: [IoTClientTypes.AuthInfo]?
    /// The MQTT client ID.
    public var clientId: Swift.String?
    /// The Cognito identity pool ID.
    public var cognitoIdentityPoolId: Swift.String?
    /// When testing custom authorization, the policies specified here are treated as if they are attached to the principal being authorized.
    public var policyNamesToAdd: [Swift.String]?
    /// When testing custom authorization, the policies specified here are treated as if they are not attached to the principal being authorized.
    public var policyNamesToSkip: [Swift.String]?
    /// The principal. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    public var principal: Swift.String?

    public init(
        authInfos: [IoTClientTypes.AuthInfo]? = nil,
        clientId: Swift.String? = nil,
        cognitoIdentityPoolId: Swift.String? = nil,
        policyNamesToAdd: [Swift.String]? = nil,
        policyNamesToSkip: [Swift.String]? = nil,
        principal: Swift.String? = nil
    )
    {
        self.authInfos = authInfos
        self.clientId = clientId
        self.cognitoIdentityPoolId = cognitoIdentityPoolId
        self.policyNamesToAdd = policyNamesToAdd
        self.policyNamesToSkip = policyNamesToSkip
        self.principal = principal
    }
}

public struct TestAuthorizationOutput {
    /// The authentication results.
    public var authResults: [IoTClientTypes.AuthResult]?

    public init(
        authResults: [IoTClientTypes.AuthResult]? = nil
    )
    {
        self.authResults = authResults
    }
}

/// The response is invalid.
public struct InvalidResponseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResponseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTClientTypes {
    /// Specifies the HTTP context to use for the test authorizer request.
    public struct HttpContext {
        /// The header keys and values in an HTTP authorization request.
        public var headers: [Swift.String: Swift.String]?
        /// The query string keys and values in an HTTP authorization request.
        public var queryString: Swift.String?

        public init(
            headers: [Swift.String: Swift.String]? = nil,
            queryString: Swift.String? = nil
        )
        {
            self.headers = headers
            self.queryString = queryString
        }
    }

}

extension IoTClientTypes {
    /// Specifies the MQTT context to use for the test authorizer request
    public struct MqttContext {
        /// The value of the clientId key in an MQTT authorization request.
        public var clientId: Swift.String?
        /// The value of the password key in an MQTT authorization request.
        public var password: Foundation.Data?
        /// The value of the username key in an MQTT authorization request.
        public var username: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            password: Foundation.Data? = nil,
            username: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.password = password
            self.username = username
        }
    }

}

extension IoTClientTypes {
    /// Specifies the TLS context to use for the test authorizer request.
    public struct TlsContext {
        /// The value of the serverName key in a TLS authorization request.
        public var serverName: Swift.String?

        public init(
            serverName: Swift.String? = nil
        )
        {
            self.serverName = serverName
        }
    }

}

public struct TestInvokeAuthorizerInput {
    /// The custom authorizer name.
    /// This member is required.
    public var authorizerName: Swift.String?
    /// Specifies a test HTTP authorization request.
    public var httpContext: IoTClientTypes.HttpContext?
    /// Specifies a test MQTT authorization request.
    public var mqttContext: IoTClientTypes.MqttContext?
    /// Specifies a test TLS authorization request.
    public var tlsContext: IoTClientTypes.TlsContext?
    /// The token returned by your custom authentication service.
    public var token: Swift.String?
    /// The signature made with the token and your custom authentication service's private key. This value must be Base-64-encoded.
    public var tokenSignature: Swift.String?

    public init(
        authorizerName: Swift.String? = nil,
        httpContext: IoTClientTypes.HttpContext? = nil,
        mqttContext: IoTClientTypes.MqttContext? = nil,
        tlsContext: IoTClientTypes.TlsContext? = nil,
        token: Swift.String? = nil,
        tokenSignature: Swift.String? = nil
    )
    {
        self.authorizerName = authorizerName
        self.httpContext = httpContext
        self.mqttContext = mqttContext
        self.tlsContext = tlsContext
        self.token = token
        self.tokenSignature = tokenSignature
    }
}

public struct TestInvokeAuthorizerOutput {
    /// The number of seconds after which the connection is terminated.
    public var disconnectAfterInSeconds: Swift.Int?
    /// True if the token is authenticated, otherwise false.
    public var isAuthenticated: Swift.Bool?
    /// IAM policy documents.
    public var policyDocuments: [Swift.String]?
    /// The principal ID.
    public var principalId: Swift.String?
    /// The number of seconds after which the temporary credentials are refreshed.
    public var refreshAfterInSeconds: Swift.Int?

    public init(
        disconnectAfterInSeconds: Swift.Int? = nil,
        isAuthenticated: Swift.Bool? = nil,
        policyDocuments: [Swift.String]? = nil,
        principalId: Swift.String? = nil,
        refreshAfterInSeconds: Swift.Int? = nil
    )
    {
        self.disconnectAfterInSeconds = disconnectAfterInSeconds
        self.isAuthenticated = isAuthenticated
        self.policyDocuments = policyDocuments
        self.principalId = principalId
        self.refreshAfterInSeconds = refreshAfterInSeconds
    }
}

/// You can't transfer the certificate because authorization policies are still attached.
public struct TransferConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TransferConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input for the TransferCertificate operation.
public struct TransferCertificateInput {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?
    /// The Amazon Web Services account.
    /// This member is required.
    public var targetAwsAccount: Swift.String?
    /// The transfer message.
    public var transferMessage: Swift.String?

    public init(
        certificateId: Swift.String? = nil,
        targetAwsAccount: Swift.String? = nil,
        transferMessage: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.targetAwsAccount = targetAwsAccount
        self.transferMessage = transferMessage
    }
}

/// The output from the TransferCertificate operation.
public struct TransferCertificateOutput {
    /// The ARN of the certificate.
    public var transferredCertificateArn: Swift.String?

    public init(
        transferredCertificateArn: Swift.String? = nil
    )
    {
        self.transferredCertificateArn = transferredCertificateArn
    }
}

public struct UntagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of the tags to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateAccountAuditConfigurationInput {
    /// Specifies which audit checks are enabled and disabled for this account. Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are currently enabled. Some data collection might start immediately when certain checks are enabled. When a check is disabled, any data collected so far in relation to the check is deleted. You cannot disable a check if it's used by any scheduled audit. You must first delete the check from the scheduled audit or delete the scheduled audit itself. On the first call to UpdateAccountAuditConfiguration, this parameter is required and must specify at least one enabled check.
    public var auditCheckConfigurations: [Swift.String: IoTClientTypes.AuditCheckConfiguration]?
    /// Information about the targets to which audit notifications are sent.
    public var auditNotificationTargetConfigurations: [Swift.String: IoTClientTypes.AuditNotificationTarget]?
    /// The Amazon Resource Name (ARN) of the role that grants permission to IoT to access information about your devices, policies, certificates, and other items as required when performing an audit.
    public var roleArn: Swift.String?

    public init(
        auditCheckConfigurations: [Swift.String: IoTClientTypes.AuditCheckConfiguration]? = nil,
        auditNotificationTargetConfigurations: [Swift.String: IoTClientTypes.AuditNotificationTarget]? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.auditCheckConfigurations = auditCheckConfigurations
        self.auditNotificationTargetConfigurations = auditNotificationTargetConfigurations
        self.roleArn = roleArn
    }
}

public struct UpdateAccountAuditConfigurationOutput {

    public init() { }
}

public struct UpdateAuditSuppressionInput {
    /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    /// This member is required.
    public var checkName: Swift.String?
    /// The description of the audit suppression.
    public var description: Swift.String?
    /// The expiration date (epoch timestamp in seconds) that you want the suppression to adhere to.
    public var expirationDate: Foundation.Date?
    /// Information that identifies the noncompliant resource.
    /// This member is required.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
    /// Indicates whether a suppression should exist indefinitely or not.
    public var suppressIndefinitely: Swift.Bool?

    public init(
        checkName: Swift.String? = nil,
        description: Swift.String? = nil,
        expirationDate: Foundation.Date? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
        suppressIndefinitely: Swift.Bool? = nil
    )
    {
        self.checkName = checkName
        self.description = description
        self.expirationDate = expirationDate
        self.resourceIdentifier = resourceIdentifier
        self.suppressIndefinitely = suppressIndefinitely
    }
}

public struct UpdateAuditSuppressionOutput {

    public init() { }
}

public struct UpdateAuthorizerInput {
    /// The ARN of the authorizer's Lambda function.
    public var authorizerFunctionArn: Swift.String?
    /// The authorizer name.
    /// This member is required.
    public var authorizerName: Swift.String?
    /// When true, the result from the authorizer’s Lambda function is cached for the time specified in refreshAfterInSeconds. The cached result is used while the device reuses the same HTTP connection.
    public var enableCachingForHttp: Swift.Bool?
    /// The status of the update authorizer request.
    public var status: IoTClientTypes.AuthorizerStatus?
    /// The key used to extract the token from the HTTP headers.
    public var tokenKeyName: Swift.String?
    /// The public keys used to verify the token signature.
    public var tokenSigningPublicKeys: [Swift.String: Swift.String]?

    public init(
        authorizerFunctionArn: Swift.String? = nil,
        authorizerName: Swift.String? = nil,
        enableCachingForHttp: Swift.Bool? = nil,
        status: IoTClientTypes.AuthorizerStatus? = nil,
        tokenKeyName: Swift.String? = nil,
        tokenSigningPublicKeys: [Swift.String: Swift.String]? = nil
    )
    {
        self.authorizerFunctionArn = authorizerFunctionArn
        self.authorizerName = authorizerName
        self.enableCachingForHttp = enableCachingForHttp
        self.status = status
        self.tokenKeyName = tokenKeyName
        self.tokenSigningPublicKeys = tokenSigningPublicKeys
    }
}

public struct UpdateAuthorizerOutput {
    /// The authorizer ARN.
    public var authorizerArn: Swift.String?
    /// The authorizer name.
    public var authorizerName: Swift.String?

    public init(
        authorizerArn: Swift.String? = nil,
        authorizerName: Swift.String? = nil
    )
    {
        self.authorizerArn = authorizerArn
        self.authorizerName = authorizerName
    }
}

public struct UpdateBillingGroupInput {
    /// The name of the billing group.
    /// This member is required.
    public var billingGroupName: Swift.String?
    /// The properties of the billing group.
    /// This member is required.
    public var billingGroupProperties: IoTClientTypes.BillingGroupProperties?
    /// The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the UpdateBillingGroup request is rejected with a VersionConflictException.
    public var expectedVersion: Swift.Int?

    public init(
        billingGroupName: Swift.String? = nil,
        billingGroupProperties: IoTClientTypes.BillingGroupProperties? = nil,
        expectedVersion: Swift.Int? = nil
    )
    {
        self.billingGroupName = billingGroupName
        self.billingGroupProperties = billingGroupProperties
        self.expectedVersion = expectedVersion
    }
}

public struct UpdateBillingGroupOutput {
    /// The latest version of the billing group.
    public var version: Swift.Int

    public init(
        version: Swift.Int = 0
    )
    {
        self.version = version
    }
}

/// The input to the UpdateCACertificate operation.
public struct UpdateCACertificateInput {
    /// The CA certificate identifier.
    /// This member is required.
    public var certificateId: Swift.String?
    /// The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
    public var newAutoRegistrationStatus: IoTClientTypes.AutoRegistrationStatus?
    /// The updated status of the CA certificate. Note: The status value REGISTER_INACTIVE is deprecated and should not be used.
    public var newStatus: IoTClientTypes.CACertificateStatus?
    /// Information about the registration configuration.
    public var registrationConfig: IoTClientTypes.RegistrationConfig?
    /// If true, removes auto registration.
    public var removeAutoRegistration: Swift.Bool?

    public init(
        certificateId: Swift.String? = nil,
        newAutoRegistrationStatus: IoTClientTypes.AutoRegistrationStatus? = nil,
        newStatus: IoTClientTypes.CACertificateStatus? = nil,
        registrationConfig: IoTClientTypes.RegistrationConfig? = nil,
        removeAutoRegistration: Swift.Bool? = false
    )
    {
        self.certificateId = certificateId
        self.newAutoRegistrationStatus = newAutoRegistrationStatus
        self.newStatus = newStatus
        self.registrationConfig = registrationConfig
        self.removeAutoRegistration = removeAutoRegistration
    }
}

/// The input for the UpdateCertificate operation.
public struct UpdateCertificateInput {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?
    /// The new status. Note: Setting the status to PENDING_TRANSFER or PENDING_ACTIVATION will result in an exception being thrown. PENDING_TRANSFER and PENDING_ACTIVATION are statuses used internally by IoT. They are not intended for developer use. Note: The status value REGISTER_INACTIVE is deprecated and should not be used.
    /// This member is required.
    public var newStatus: IoTClientTypes.CertificateStatus?

    public init(
        certificateId: Swift.String? = nil,
        newStatus: IoTClientTypes.CertificateStatus? = nil
    )
    {
        self.certificateId = certificateId
        self.newStatus = newStatus
    }
}

public struct UpdateCertificateProviderInput {
    /// A list of the operations that the certificate provider will use to generate certificates. Valid value: CreateCertificateFromCsr.
    public var accountDefaultForOperations: [IoTClientTypes.CertificateProviderOperation]?
    /// The name of the certificate provider.
    /// This member is required.
    public var certificateProviderName: Swift.String?
    /// The Lambda function ARN that's associated with the certificate provider.
    public var lambdaFunctionArn: Swift.String?

    public init(
        accountDefaultForOperations: [IoTClientTypes.CertificateProviderOperation]? = nil,
        certificateProviderName: Swift.String? = nil,
        lambdaFunctionArn: Swift.String? = nil
    )
    {
        self.accountDefaultForOperations = accountDefaultForOperations
        self.certificateProviderName = certificateProviderName
        self.lambdaFunctionArn = lambdaFunctionArn
    }
}

public struct UpdateCertificateProviderOutput {
    /// The ARN of the certificate provider.
    public var certificateProviderArn: Swift.String?
    /// The name of the certificate provider.
    public var certificateProviderName: Swift.String?

    public init(
        certificateProviderArn: Swift.String? = nil,
        certificateProviderName: Swift.String? = nil
    )
    {
        self.certificateProviderArn = certificateProviderArn
        self.certificateProviderName = certificateProviderName
    }
}

public struct UpdateCustomMetricInput {
    /// Field represents a friendly name in the console for the custom metric, it doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. Can be updated.
    /// This member is required.
    public var displayName: Swift.String?
    /// The name of the custom metric. Cannot be updated.
    /// This member is required.
    public var metricName: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        metricName: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.metricName = metricName
    }
}

public struct UpdateCustomMetricOutput {
    /// The creation date of the custom metric in milliseconds since epoch.
    public var creationDate: Foundation.Date?
    /// A friendly name in the console for the custom metric
    public var displayName: Swift.String?
    /// The time the custom metric was last modified in milliseconds since epoch.
    public var lastModifiedDate: Foundation.Date?
    /// The Amazon Resource Number (ARN) of the custom metric.
    public var metricArn: Swift.String?
    /// The name of the custom metric.
    public var metricName: Swift.String?
    /// The type of the custom metric. The type number only takes a single metric value as an input, but while submitting the metrics value in the DeviceMetrics report, it must be passed as an array with a single value.
    public var metricType: IoTClientTypes.CustomMetricType?

    public init(
        creationDate: Foundation.Date? = nil,
        displayName: Swift.String? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        metricArn: Swift.String? = nil,
        metricName: Swift.String? = nil,
        metricType: IoTClientTypes.CustomMetricType? = nil
    )
    {
        self.creationDate = creationDate
        self.displayName = displayName
        self.lastModifiedDate = lastModifiedDate
        self.metricArn = metricArn
        self.metricName = metricName
        self.metricType = metricType
    }
}

public struct UpdateDimensionInput {
    /// A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the value or list of values for the dimension. For TOPIC_FILTER dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").
    /// This member is required.
    public var stringValues: [Swift.String]?

    public init(
        name: Swift.String? = nil,
        stringValues: [Swift.String]? = nil
    )
    {
        self.name = name
        self.stringValues = stringValues
    }
}

public struct UpdateDimensionOutput {
    /// The Amazon Resource Name (ARN)of the created dimension.
    public var arn: Swift.String?
    /// The date and time, in milliseconds since epoch, when the dimension was initially created.
    public var creationDate: Foundation.Date?
    /// The date and time, in milliseconds since epoch, when the dimension was most recently updated.
    public var lastModifiedDate: Foundation.Date?
    /// A unique identifier for the dimension.
    public var name: Swift.String?
    /// The value or list of values used to scope the dimension. For example, for topic filters, this is the pattern used to match the MQTT topic name.
    public var stringValues: [Swift.String]?
    /// The type of the dimension.
    public var type: IoTClientTypes.DimensionType?

    public init(
        arn: Swift.String? = nil,
        creationDate: Foundation.Date? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        stringValues: [Swift.String]? = nil,
        type: IoTClientTypes.DimensionType? = nil
    )
    {
        self.arn = arn
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.stringValues = stringValues
        self.type = type
    }
}

public struct UpdateDomainConfigurationInput {
    /// An object that specifies the authorization service for a domain.
    public var authorizerConfig: IoTClientTypes.AuthorizerConfig?
    /// The name of the domain configuration to be updated.
    /// This member is required.
    public var domainConfigurationName: Swift.String?
    /// The status to which the domain configuration should be updated.
    public var domainConfigurationStatus: IoTClientTypes.DomainConfigurationStatus?
    /// Removes the authorization configuration from a domain.
    public var removeAuthorizerConfig: Swift.Bool?
    /// The server certificate configuration.
    public var serverCertificateConfig: IoTClientTypes.ServerCertificateConfig?
    /// An object that specifies the TLS configuration for a domain.
    public var tlsConfig: IoTClientTypes.TlsConfig?

    public init(
        authorizerConfig: IoTClientTypes.AuthorizerConfig? = nil,
        domainConfigurationName: Swift.String? = nil,
        domainConfigurationStatus: IoTClientTypes.DomainConfigurationStatus? = nil,
        removeAuthorizerConfig: Swift.Bool? = false,
        serverCertificateConfig: IoTClientTypes.ServerCertificateConfig? = nil,
        tlsConfig: IoTClientTypes.TlsConfig? = nil
    )
    {
        self.authorizerConfig = authorizerConfig
        self.domainConfigurationName = domainConfigurationName
        self.domainConfigurationStatus = domainConfigurationStatus
        self.removeAuthorizerConfig = removeAuthorizerConfig
        self.serverCertificateConfig = serverCertificateConfig
        self.tlsConfig = tlsConfig
    }
}

public struct UpdateDomainConfigurationOutput {
    /// The ARN of the domain configuration that was updated.
    public var domainConfigurationArn: Swift.String?
    /// The name of the domain configuration that was updated.
    public var domainConfigurationName: Swift.String?

    public init(
        domainConfigurationArn: Swift.String? = nil,
        domainConfigurationName: Swift.String? = nil
    )
    {
        self.domainConfigurationArn = domainConfigurationArn
        self.domainConfigurationName = domainConfigurationName
    }
}

public struct UpdateDynamicThingGroupInput {
    /// The expected version of the dynamic thing group to update.
    public var expectedVersion: Swift.Int?
    /// The dynamic thing group index to update. Currently one index is supported: AWS_Things.
    public var indexName: Swift.String?
    /// The dynamic thing group search query string to update.
    public var queryString: Swift.String?
    /// The dynamic thing group query version to update. Currently one query version is supported: "2017-09-30". If not specified, the query version defaults to this value.
    public var queryVersion: Swift.String?
    /// The name of the dynamic thing group to update.
    /// This member is required.
    public var thingGroupName: Swift.String?
    /// The dynamic thing group properties to update.
    /// This member is required.
    public var thingGroupProperties: IoTClientTypes.ThingGroupProperties?

    public init(
        expectedVersion: Swift.Int? = nil,
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        thingGroupName: Swift.String? = nil,
        thingGroupProperties: IoTClientTypes.ThingGroupProperties? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
    }
}

public struct UpdateDynamicThingGroupOutput {
    /// The dynamic thing group version.
    public var version: Swift.Int

    public init(
        version: Swift.Int = 0
    )
    {
        self.version = version
    }
}

public struct UpdateEventConfigurationsInput {
    /// The new event configuration values.
    public var eventConfigurations: [Swift.String: IoTClientTypes.Configuration]?

    public init(
        eventConfigurations: [Swift.String: IoTClientTypes.Configuration]? = nil
    )
    {
        self.eventConfigurations = eventConfigurations
    }
}

public struct UpdateEventConfigurationsOutput {

    public init() { }
}

public struct UpdateFleetMetricInput {
    /// The field to aggregate.
    public var aggregationField: Swift.String?
    /// The type of the aggregation query.
    public var aggregationType: IoTClientTypes.AggregationType?
    /// The description of the fleet metric.
    public var description: Swift.String?
    /// The expected version of the fleet metric record in the registry.
    public var expectedVersion: Swift.Int?
    /// The name of the index to search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The name of the fleet metric to update.
    /// This member is required.
    public var metricName: Swift.String?
    /// The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.
    public var period: Swift.Int?
    /// The search query string.
    public var queryString: Swift.String?
    /// The version of the query.
    public var queryVersion: Swift.String?
    /// Used to support unit transformation such as milliseconds to seconds. The unit must be supported by [CW metric](https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html).
    public var unit: IoTClientTypes.FleetMetricUnit?

    public init(
        aggregationField: Swift.String? = nil,
        aggregationType: IoTClientTypes.AggregationType? = nil,
        description: Swift.String? = nil,
        expectedVersion: Swift.Int? = nil,
        indexName: Swift.String? = nil,
        metricName: Swift.String? = nil,
        period: Swift.Int? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        unit: IoTClientTypes.FleetMetricUnit? = nil
    )
    {
        self.aggregationField = aggregationField
        self.aggregationType = aggregationType
        self.description = description
        self.expectedVersion = expectedVersion
        self.indexName = indexName
        self.metricName = metricName
        self.period = period
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.unit = unit
    }
}

public struct UpdateIndexingConfigurationInput {
    /// Thing group indexing configuration.
    public var thingGroupIndexingConfiguration: IoTClientTypes.ThingGroupIndexingConfiguration?
    /// Thing indexing configuration.
    public var thingIndexingConfiguration: IoTClientTypes.ThingIndexingConfiguration?

    public init(
        thingGroupIndexingConfiguration: IoTClientTypes.ThingGroupIndexingConfiguration? = nil,
        thingIndexingConfiguration: IoTClientTypes.ThingIndexingConfiguration? = nil
    )
    {
        self.thingGroupIndexingConfiguration = thingGroupIndexingConfiguration
        self.thingIndexingConfiguration = thingIndexingConfiguration
    }
}

public struct UpdateIndexingConfigurationOutput {

    public init() { }
}

public struct UpdateJobInput {
    /// Allows you to create criteria to abort a job.
    public var abortConfig: IoTClientTypes.AbortConfig?
    /// A short text description of the job.
    public var description: Swift.String?
    /// Allows you to create the criteria to retry a job.
    public var jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
    /// Allows you to create a staged rollout of the job.
    public var jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
    /// The ID of the job to be updated.
    /// This member is required.
    public var jobId: Swift.String?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is only supported by IoT Greengrass at this time. For more information, see [Setting up IoT Greengrass core devices.](https://docs.aws.amazon.com/greengrass/v2/developerguide/setting-up.html)
    public var namespaceId: Swift.String?
    /// Configuration information for pre-signed S3 URLs.
    public var presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
    /// Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to TIMED_OUT.
    public var timeoutConfig: IoTClientTypes.TimeoutConfig?

    public init(
        abortConfig: IoTClientTypes.AbortConfig? = nil,
        description: Swift.String? = nil,
        jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig? = nil,
        jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig? = nil,
        jobId: Swift.String? = nil,
        namespaceId: Swift.String? = nil,
        presignedUrlConfig: IoTClientTypes.PresignedUrlConfig? = nil,
        timeoutConfig: IoTClientTypes.TimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.description = description
        self.jobExecutionsRetryConfig = jobExecutionsRetryConfig
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.jobId = jobId
        self.namespaceId = namespaceId
        self.presignedUrlConfig = presignedUrlConfig
        self.timeoutConfig = timeoutConfig
    }
}

public struct UpdateMitigationActionInput {
    /// The friendly name for the mitigation action. You cannot change the name by using UpdateMitigationAction. Instead, you must delete and recreate the mitigation action with the new name.
    /// This member is required.
    public var actionName: Swift.String?
    /// Defines the type of action and the parameters for that action.
    public var actionParams: IoTClientTypes.MitigationActionParams?
    /// The ARN of the IAM role that is used to apply the mitigation action.
    public var roleArn: Swift.String?

    public init(
        actionName: Swift.String? = nil,
        actionParams: IoTClientTypes.MitigationActionParams? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.actionName = actionName
        self.actionParams = actionParams
        self.roleArn = roleArn
    }
}

public struct UpdateMitigationActionOutput {
    /// The ARN for the new mitigation action.
    public var actionArn: Swift.String?
    /// A unique identifier for the mitigation action.
    public var actionId: Swift.String?

    public init(
        actionArn: Swift.String? = nil,
        actionId: Swift.String? = nil
    )
    {
        self.actionArn = actionArn
        self.actionId = actionId
    }
}

public struct UpdatePackageInput {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The name of the default package version. Note: You cannot name a defaultVersion and set unsetDefaultVersion equal to true at the same time.
    public var defaultVersionName: Swift.String?
    /// The package description.
    public var description: Swift.String?
    /// The name of the target software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// Indicates whether you want to remove the named default package version from the software package. Set as true to remove the default package version. Note: You cannot name a defaultVersion and set unsetDefaultVersion equal to true at the same time.
    public var unsetDefaultVersion: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        defaultVersionName: Swift.String? = nil,
        description: Swift.String? = nil,
        packageName: Swift.String? = nil,
        unsetDefaultVersion: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.defaultVersionName = defaultVersionName
        self.description = description
        self.packageName = packageName
        self.unsetDefaultVersion = unsetDefaultVersion
    }
}

extension UpdatePackageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePackageInput(clientToken: \(Swift.String(describing: clientToken)), defaultVersionName: \(Swift.String(describing: defaultVersionName)), packageName: \(Swift.String(describing: packageName)), unsetDefaultVersion: \(Swift.String(describing: unsetDefaultVersion)), description: \"CONTENT_REDACTED\")"}
}

public struct UpdatePackageOutput {

    public init() { }
}

public struct UpdatePackageConfigurationInput {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// Configuration to manage job's package version reporting. This updates the thing's reserved named shadow that the job targets.
    public var versionUpdateByJobsConfig: IoTClientTypes.VersionUpdateByJobsConfig?

    public init(
        clientToken: Swift.String? = nil,
        versionUpdateByJobsConfig: IoTClientTypes.VersionUpdateByJobsConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.versionUpdateByJobsConfig = versionUpdateByJobsConfig
    }
}

public struct UpdatePackageConfigurationOutput {

    public init() { }
}

extension IoTClientTypes {

    public enum PackageVersionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deprecate
        case publish
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionAction] {
            return [
                .deprecate,
                .publish
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deprecate: return "DEPRECATE"
            case .publish: return "PUBLISH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdatePackageVersionInput {
    /// The status that the package version should be assigned. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle).
    public var action: IoTClientTypes.PackageVersionAction?
    /// The various components that make up a software package version.
    public var artifact: IoTClientTypes.PackageVersionArtifact?
    /// Metadata that can be used to define a package version’s configuration. For example, the Amazon S3 file location, configuration options that are being sent to the device or fleet. Note: Attributes can be updated only when the package version is in a draft state. The combined size of all the attributes on a package version is limited to 3KB.
    public var attributes: [Swift.String: Swift.String]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The package version description.
    public var description: Swift.String?
    /// The name of the associated software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The inline job document associated with a software package version used for a quick job deployment via IoT Jobs.
    public var recipe: Swift.String?
    /// The name of the target package version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        action: IoTClientTypes.PackageVersionAction? = nil,
        artifact: IoTClientTypes.PackageVersionArtifact? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        packageName: Swift.String? = nil,
        recipe: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.action = action
        self.artifact = artifact
        self.attributes = attributes
        self.clientToken = clientToken
        self.description = description
        self.packageName = packageName
        self.recipe = recipe
        self.versionName = versionName
    }
}

extension UpdatePackageVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePackageVersionInput(action: \(Swift.String(describing: action)), artifact: \(Swift.String(describing: artifact)), clientToken: \(Swift.String(describing: clientToken)), packageName: \(Swift.String(describing: packageName)), versionName: \(Swift.String(describing: versionName)), attributes: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", recipe: \"CONTENT_REDACTED\")"}
}

public struct UpdatePackageVersionOutput {

    public init() { }
}

public struct UpdateProvisioningTemplateInput {
    /// The ID of the default provisioning template version.
    public var defaultVersionId: Swift.Int?
    /// The description of the provisioning template.
    public var description: Swift.String?
    /// True to enable the provisioning template, otherwise false.
    public var enabled: Swift.Bool?
    /// Updates the pre-provisioning hook template. Only supports template of type FLEET_PROVISIONING. For more information about provisioning template types, see [type](https://docs.aws.amazon.com/iot/latest/apireference/API_CreateProvisioningTemplate.html#iot-CreateProvisioningTemplate-request-type).
    public var preProvisioningHook: IoTClientTypes.ProvisioningHook?
    /// The ARN of the role associated with the provisioning template. This IoT role grants permission to provision a device.
    public var provisioningRoleArn: Swift.String?
    /// Removes pre-provisioning hook template.
    public var removePreProvisioningHook: Swift.Bool?
    /// The name of the provisioning template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        defaultVersionId: Swift.Int? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        preProvisioningHook: IoTClientTypes.ProvisioningHook? = nil,
        provisioningRoleArn: Swift.String? = nil,
        removePreProvisioningHook: Swift.Bool? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.defaultVersionId = defaultVersionId
        self.description = description
        self.enabled = enabled
        self.preProvisioningHook = preProvisioningHook
        self.provisioningRoleArn = provisioningRoleArn
        self.removePreProvisioningHook = removePreProvisioningHook
        self.templateName = templateName
    }
}

public struct UpdateProvisioningTemplateOutput {

    public init() { }
}

public struct UpdateRoleAliasInput {
    /// The number of seconds the credential will be valid. This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.
    public var credentialDurationSeconds: Swift.Int?
    /// The role alias to update.
    /// This member is required.
    public var roleAlias: Swift.String?
    /// The role ARN.
    public var roleArn: Swift.String?

    public init(
        credentialDurationSeconds: Swift.Int? = nil,
        roleAlias: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.credentialDurationSeconds = credentialDurationSeconds
        self.roleAlias = roleAlias
        self.roleArn = roleArn
    }
}

public struct UpdateRoleAliasOutput {
    /// The role alias.
    public var roleAlias: Swift.String?
    /// The role alias ARN.
    public var roleAliasArn: Swift.String?

    public init(
        roleAlias: Swift.String? = nil,
        roleAliasArn: Swift.String? = nil
    )
    {
        self.roleAlias = roleAlias
        self.roleAliasArn = roleAliasArn
    }
}

public struct UpdateScheduledAuditInput {
    /// The day of the month on which the scheduled audit takes place. This can be 1 through 31 or LAST. This field is required if the frequency parameter is set to MONTHLY. If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.
    public var dayOfMonth: Swift.String?
    /// The day of the week on which the scheduled audit takes place. This can be one of SUN, MON, TUE, WED, THU, FRI, or SAT. This field is required if the "frequency" parameter is set to WEEKLY or BIWEEKLY.
    public var dayOfWeek: IoTClientTypes.DayOfWeek?
    /// How often the scheduled audit takes place, either DAILY, WEEKLY, BIWEEKLY, or MONTHLY. The start time of each audit is determined by the system.
    public var frequency: IoTClientTypes.AuditFrequency?
    /// The name of the scheduled audit. (Max. 128 chars)
    /// This member is required.
    public var scheduledAuditName: Swift.String?
    /// Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    public var targetCheckNames: [Swift.String]?

    public init(
        dayOfMonth: Swift.String? = nil,
        dayOfWeek: IoTClientTypes.DayOfWeek? = nil,
        frequency: IoTClientTypes.AuditFrequency? = nil,
        scheduledAuditName: Swift.String? = nil,
        targetCheckNames: [Swift.String]? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.frequency = frequency
        self.scheduledAuditName = scheduledAuditName
        self.targetCheckNames = targetCheckNames
    }
}

public struct UpdateScheduledAuditOutput {
    /// The ARN of the scheduled audit.
    public var scheduledAuditArn: Swift.String?

    public init(
        scheduledAuditArn: Swift.String? = nil
    )
    {
        self.scheduledAuditArn = scheduledAuditArn
    }
}

public struct UpdateSecurityProfileInput {
    /// Please use [UpdateSecurityProfileRequest$additionalMetricsToRetainV2] instead. A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.
    @available(*, deprecated, message: "Use additionalMetricsToRetainV2.")
    public var additionalMetricsToRetain: [Swift.String]?
    /// A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.
    public var additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]?
    /// Where the alerts are sent. (Alerts are always sent to the console.)
    public var alertTargets: [Swift.String: IoTClientTypes.AlertTarget]?
    /// Specifies the behaviors that, when violated by a device (thing), cause an alert.
    public var behaviors: [IoTClientTypes.Behavior]?
    /// If true, delete all additionalMetricsToRetain defined for this security profile. If any additionalMetricsToRetain are defined in the current invocation, an exception occurs.
    public var deleteAdditionalMetricsToRetain: Swift.Bool?
    /// If true, delete all alertTargets defined for this security profile. If any alertTargets are defined in the current invocation, an exception occurs.
    public var deleteAlertTargets: Swift.Bool?
    /// If true, delete all behaviors defined for this security profile. If any behaviors are defined in the current invocation, an exception occurs.
    public var deleteBehaviors: Swift.Bool?
    /// Set the value as true to delete metrics export related configurations.
    public var deleteMetricsExportConfig: Swift.Bool?
    /// The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a VersionConflictException is thrown.
    public var expectedVersion: Swift.Int?
    /// Specifies the MQTT topic and role ARN required for metric export.
    public var metricsExportConfig: IoTClientTypes.MetricsExportConfig?
    /// A description of the security profile.
    public var securityProfileDescription: Swift.String?
    /// The name of the security profile you want to update.
    /// This member is required.
    public var securityProfileName: Swift.String?

    public init(
        additionalMetricsToRetain: [Swift.String]? = nil,
        additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]? = nil,
        alertTargets: [Swift.String: IoTClientTypes.AlertTarget]? = nil,
        behaviors: [IoTClientTypes.Behavior]? = nil,
        deleteAdditionalMetricsToRetain: Swift.Bool? = false,
        deleteAlertTargets: Swift.Bool? = false,
        deleteBehaviors: Swift.Bool? = false,
        deleteMetricsExportConfig: Swift.Bool? = false,
        expectedVersion: Swift.Int? = nil,
        metricsExportConfig: IoTClientTypes.MetricsExportConfig? = nil,
        securityProfileDescription: Swift.String? = nil,
        securityProfileName: Swift.String? = nil
    )
    {
        self.additionalMetricsToRetain = additionalMetricsToRetain
        self.additionalMetricsToRetainV2 = additionalMetricsToRetainV2
        self.alertTargets = alertTargets
        self.behaviors = behaviors
        self.deleteAdditionalMetricsToRetain = deleteAdditionalMetricsToRetain
        self.deleteAlertTargets = deleteAlertTargets
        self.deleteBehaviors = deleteBehaviors
        self.deleteMetricsExportConfig = deleteMetricsExportConfig
        self.expectedVersion = expectedVersion
        self.metricsExportConfig = metricsExportConfig
        self.securityProfileDescription = securityProfileDescription
        self.securityProfileName = securityProfileName
    }
}

public struct UpdateSecurityProfileOutput {
    /// Please use [UpdateSecurityProfileResponse$additionalMetricsToRetainV2] instead. A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the security profile's behaviors, but it is also retained for any metric specified here.
    @available(*, deprecated, message: "Use additionalMetricsToRetainV2.")
    public var additionalMetricsToRetain: [Swift.String]?
    /// A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.
    public var additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]?
    /// Where the alerts are sent. (Alerts are always sent to the console.)
    public var alertTargets: [Swift.String: IoTClientTypes.AlertTarget]?
    /// Specifies the behaviors that, when violated by a device (thing), cause an alert.
    public var behaviors: [IoTClientTypes.Behavior]?
    /// The time the security profile was created.
    public var creationDate: Foundation.Date?
    /// The time the security profile was last modified.
    public var lastModifiedDate: Foundation.Date?
    /// Specifies the MQTT topic and role ARN required for metric export.
    public var metricsExportConfig: IoTClientTypes.MetricsExportConfig?
    /// The ARN of the security profile that was updated.
    public var securityProfileArn: Swift.String?
    /// The description of the security profile.
    public var securityProfileDescription: Swift.String?
    /// The name of the security profile that was updated.
    public var securityProfileName: Swift.String?
    /// The updated version of the security profile.
    public var version: Swift.Int

    public init(
        additionalMetricsToRetain: [Swift.String]? = nil,
        additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]? = nil,
        alertTargets: [Swift.String: IoTClientTypes.AlertTarget]? = nil,
        behaviors: [IoTClientTypes.Behavior]? = nil,
        creationDate: Foundation.Date? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        metricsExportConfig: IoTClientTypes.MetricsExportConfig? = nil,
        securityProfileArn: Swift.String? = nil,
        securityProfileDescription: Swift.String? = nil,
        securityProfileName: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.additionalMetricsToRetain = additionalMetricsToRetain
        self.additionalMetricsToRetainV2 = additionalMetricsToRetainV2
        self.alertTargets = alertTargets
        self.behaviors = behaviors
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.metricsExportConfig = metricsExportConfig
        self.securityProfileArn = securityProfileArn
        self.securityProfileDescription = securityProfileDescription
        self.securityProfileName = securityProfileName
        self.version = version
    }
}

public struct UpdateStreamInput {
    /// The description of the stream.
    public var description: Swift.String?
    /// The files associated with the stream.
    public var files: [IoTClientTypes.StreamFile]?
    /// An IAM role that allows the IoT service principal assumes to access your S3 files.
    public var roleArn: Swift.String?
    /// The stream ID.
    /// This member is required.
    public var streamId: Swift.String?

    public init(
        description: Swift.String? = nil,
        files: [IoTClientTypes.StreamFile]? = nil,
        roleArn: Swift.String? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.description = description
        self.files = files
        self.roleArn = roleArn
        self.streamId = streamId
    }
}

public struct UpdateStreamOutput {
    /// A description of the stream.
    public var description: Swift.String?
    /// The stream ARN.
    public var streamArn: Swift.String?
    /// The stream ID.
    public var streamId: Swift.String?
    /// The stream version.
    public var streamVersion: Swift.Int?

    public init(
        description: Swift.String? = nil,
        streamArn: Swift.String? = nil,
        streamId: Swift.String? = nil,
        streamVersion: Swift.Int? = nil
    )
    {
        self.description = description
        self.streamArn = streamArn
        self.streamId = streamId
        self.streamVersion = streamVersion
    }
}

/// The input for the UpdateThing operation.
public struct UpdateThingInput {
    /// A list of thing attributes, a JSON string containing name-value pairs. For example: {\"attributes\":{\"name1\":\"value2\"}} This data is used to add new attributes or update existing attributes.
    public var attributePayload: IoTClientTypes.AttributePayload?
    /// The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the UpdateThing request is rejected with a VersionConflictException.
    public var expectedVersion: Swift.Int?
    /// Remove a thing type association. If true, the association is removed.
    public var removeThingType: Swift.Bool?
    /// The name of the thing to update. You can't change a thing's name. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.
    /// This member is required.
    public var thingName: Swift.String?
    /// The name of the thing type.
    public var thingTypeName: Swift.String?

    public init(
        attributePayload: IoTClientTypes.AttributePayload? = nil,
        expectedVersion: Swift.Int? = nil,
        removeThingType: Swift.Bool? = false,
        thingName: Swift.String? = nil,
        thingTypeName: Swift.String? = nil
    )
    {
        self.attributePayload = attributePayload
        self.expectedVersion = expectedVersion
        self.removeThingType = removeThingType
        self.thingName = thingName
        self.thingTypeName = thingTypeName
    }
}

/// The output from the UpdateThing operation.
public struct UpdateThingOutput {

    public init() { }
}

public struct UpdateThingGroupInput {
    /// The expected version of the thing group. If this does not match the version of the thing group being updated, the update will fail.
    public var expectedVersion: Swift.Int?
    /// The thing group to update.
    /// This member is required.
    public var thingGroupName: Swift.String?
    /// The thing group properties.
    /// This member is required.
    public var thingGroupProperties: IoTClientTypes.ThingGroupProperties?

    public init(
        expectedVersion: Swift.Int? = nil,
        thingGroupName: Swift.String? = nil,
        thingGroupProperties: IoTClientTypes.ThingGroupProperties? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
    }
}

public struct UpdateThingGroupOutput {
    /// The version of the updated thing group.
    public var version: Swift.Int

    public init(
        version: Swift.Int = 0
    )
    {
        self.version = version
    }
}

public struct UpdateThingGroupsForThingInput {
    /// Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.
    public var overrideDynamicGroups: Swift.Bool?
    /// The groups to which the thing will be added.
    public var thingGroupsToAdd: [Swift.String]?
    /// The groups from which the thing will be removed.
    public var thingGroupsToRemove: [Swift.String]?
    /// The thing whose group memberships will be updated.
    public var thingName: Swift.String?

    public init(
        overrideDynamicGroups: Swift.Bool? = false,
        thingGroupsToAdd: [Swift.String]? = nil,
        thingGroupsToRemove: [Swift.String]? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.overrideDynamicGroups = overrideDynamicGroups
        self.thingGroupsToAdd = thingGroupsToAdd
        self.thingGroupsToRemove = thingGroupsToRemove
        self.thingName = thingName
    }
}

public struct UpdateThingGroupsForThingOutput {

    public init() { }
}

public struct UpdateTopicRuleDestinationInput {
    /// The ARN of the topic rule destination.
    /// This member is required.
    public var arn: Swift.String?
    /// The status of the topic rule destination. Valid values are: IN_PROGRESS A topic rule destination was created but has not been confirmed. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint. ENABLED Confirmation was completed, and traffic to this destination is allowed. You can set status to DISABLED by calling UpdateTopicRuleDestination. DISABLED Confirmation was completed, and traffic to this destination is not allowed. You can set status to ENABLED by calling UpdateTopicRuleDestination. ERROR Confirmation could not be completed, for example if the confirmation timed out. You can call GetTopicRuleDestination for details about the error. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint.
    /// This member is required.
    public var status: IoTClientTypes.TopicRuleDestinationStatus?

    public init(
        arn: Swift.String? = nil,
        status: IoTClientTypes.TopicRuleDestinationStatus? = nil
    )
    {
        self.arn = arn
        self.status = status
    }
}

public struct UpdateTopicRuleDestinationOutput {

    public init() { }
}

public struct ValidateSecurityProfileBehaviorsInput {
    /// Specifies the behaviors that, when violated by a device (thing), cause an alert.
    /// This member is required.
    public var behaviors: [IoTClientTypes.Behavior]?

    public init(
        behaviors: [IoTClientTypes.Behavior]? = nil
    )
    {
        self.behaviors = behaviors
    }
}

extension IoTClientTypes {
    /// Information about an error found in a behavior specification.
    public struct ValidationError {
        /// The description of an error found in the behaviors.
        public var errorMessage: Swift.String?

        public init(
            errorMessage: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
        }
    }

}

public struct ValidateSecurityProfileBehaviorsOutput {
    /// True if the behaviors were valid.
    public var valid: Swift.Bool
    /// The list of any errors found in the behaviors.
    public var validationErrors: [IoTClientTypes.ValidationError]?

    public init(
        valid: Swift.Bool = false,
        validationErrors: [IoTClientTypes.ValidationError]? = nil
    )
    {
        self.valid = valid
        self.validationErrors = validationErrors
    }
}

extension AcceptCertificateTransferInput {

    static func urlPathProvider(_ value: AcceptCertificateTransferInput) -> Swift.String? {
        guard let certificateId = value.certificateId else {
            return nil
        }
        return "/accept-certificate-transfer/\(certificateId.urlPercentEncoding())"
    }
}

extension AcceptCertificateTransferInput {

    static func queryItemProvider(_ value: AcceptCertificateTransferInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let setAsActive = value.setAsActive {
            let setAsActiveQueryItem = Smithy.URIQueryItem(name: "setAsActive".urlPercentEncoding(), value: Swift.String(setAsActive).urlPercentEncoding())
            items.append(setAsActiveQueryItem)
        }
        return items
    }
}

extension AddThingToBillingGroupInput {

    static func urlPathProvider(_ value: AddThingToBillingGroupInput) -> Swift.String? {
        return "/billing-groups/addThingToBillingGroup"
    }
}

extension AddThingToThingGroupInput {

    static func urlPathProvider(_ value: AddThingToThingGroupInput) -> Swift.String? {
        return "/thing-groups/addThingToThingGroup"
    }
}

extension AssociateSbomWithPackageVersionInput {

    static func urlPathProvider(_ value: AssociateSbomWithPackageVersionInput) -> Swift.String? {
        guard let packageName = value.packageName else {
            return nil
        }
        guard let versionName = value.versionName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())/versions/\(versionName.urlPercentEncoding())/sbom"
    }
}

extension AssociateSbomWithPackageVersionInput {

    static func queryItemProvider(_ value: AssociateSbomWithPackageVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension AssociateTargetsWithJobInput {

    static func urlPathProvider(_ value: AssociateTargetsWithJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())/targets"
    }
}

extension AssociateTargetsWithJobInput {

    static func queryItemProvider(_ value: AssociateTargetsWithJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let namespaceId = value.namespaceId {
            let namespaceIdQueryItem = Smithy.URIQueryItem(name: "namespaceId".urlPercentEncoding(), value: Swift.String(namespaceId).urlPercentEncoding())
            items.append(namespaceIdQueryItem)
        }
        return items
    }
}

extension AttachPolicyInput {

    static func urlPathProvider(_ value: AttachPolicyInput) -> Swift.String? {
        guard let policyName = value.policyName else {
            return nil
        }
        return "/target-policies/\(policyName.urlPercentEncoding())"
    }
}

extension AttachPrincipalPolicyInput {

    static func urlPathProvider(_ value: AttachPrincipalPolicyInput) -> Swift.String? {
        guard let policyName = value.policyName else {
            return nil
        }
        return "/principal-policies/\(policyName.urlPercentEncoding())"
    }
}

extension AttachPrincipalPolicyInput {

    static func headerProvider(_ value: AttachPrincipalPolicyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let principal = value.principal {
            items.add(SmithyHTTPAPI.Header(name: "x-amzn-iot-principal", value: Swift.String(principal)))
        }
        return items
    }
}

extension AttachSecurityProfileInput {

    static func urlPathProvider(_ value: AttachSecurityProfileInput) -> Swift.String? {
        guard let securityProfileName = value.securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())/targets"
    }
}

extension AttachSecurityProfileInput {

    static func queryItemProvider(_ value: AttachSecurityProfileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let securityProfileTargetArn = value.securityProfileTargetArn else {
            let message = "Creating a URL Query Item failed. securityProfileTargetArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let securityProfileTargetArnQueryItem = Smithy.URIQueryItem(name: "securityProfileTargetArn".urlPercentEncoding(), value: Swift.String(securityProfileTargetArn).urlPercentEncoding())
        items.append(securityProfileTargetArnQueryItem)
        return items
    }
}

extension AttachThingPrincipalInput {

    static func urlPathProvider(_ value: AttachThingPrincipalInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/principals"
    }
}

extension AttachThingPrincipalInput {

    static func headerProvider(_ value: AttachThingPrincipalInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let principal = value.principal {
            items.add(SmithyHTTPAPI.Header(name: "x-amzn-principal", value: Swift.String(principal)))
        }
        return items
    }
}

extension CancelAuditMitigationActionsTaskInput {

    static func urlPathProvider(_ value: CancelAuditMitigationActionsTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/audit/mitigationactions/tasks/\(taskId.urlPercentEncoding())/cancel"
    }
}

extension CancelAuditTaskInput {

    static func urlPathProvider(_ value: CancelAuditTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/audit/tasks/\(taskId.urlPercentEncoding())/cancel"
    }
}

extension CancelCertificateTransferInput {

    static func urlPathProvider(_ value: CancelCertificateTransferInput) -> Swift.String? {
        guard let certificateId = value.certificateId else {
            return nil
        }
        return "/cancel-certificate-transfer/\(certificateId.urlPercentEncoding())"
    }
}

extension CancelDetectMitigationActionsTaskInput {

    static func urlPathProvider(_ value: CancelDetectMitigationActionsTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/detect/mitigationactions/tasks/\(taskId.urlPercentEncoding())/cancel"
    }
}

extension CancelJobInput {

    static func urlPathProvider(_ value: CancelJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())/cancel"
    }
}

extension CancelJobInput {

    static func queryItemProvider(_ value: CancelJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let force = value.force {
            let forceQueryItem = Smithy.URIQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
            items.append(forceQueryItem)
        }
        return items
    }
}

extension CancelJobExecutionInput {

    static func urlPathProvider(_ value: CancelJobExecutionInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/cancel"
    }
}

extension CancelJobExecutionInput {

    static func queryItemProvider(_ value: CancelJobExecutionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let force = value.force {
            let forceQueryItem = Smithy.URIQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
            items.append(forceQueryItem)
        }
        return items
    }
}

extension ClearDefaultAuthorizerInput {

    static func urlPathProvider(_ value: ClearDefaultAuthorizerInput) -> Swift.String? {
        return "/default-authorizer"
    }
}

extension ConfirmTopicRuleDestinationInput {

    static func urlPathProvider(_ value: ConfirmTopicRuleDestinationInput) -> Swift.String? {
        guard let confirmationToken = value.confirmationToken else {
            return nil
        }
        return "/confirmdestination/\(confirmationToken.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension CreateAuditSuppressionInput {

    static func urlPathProvider(_ value: CreateAuditSuppressionInput) -> Swift.String? {
        return "/audit/suppressions/create"
    }
}

extension CreateAuthorizerInput {

    static func urlPathProvider(_ value: CreateAuthorizerInput) -> Swift.String? {
        guard let authorizerName = value.authorizerName else {
            return nil
        }
        return "/authorizer/\(authorizerName.urlPercentEncoding())"
    }
}

extension CreateBillingGroupInput {

    static func urlPathProvider(_ value: CreateBillingGroupInput) -> Swift.String? {
        guard let billingGroupName = value.billingGroupName else {
            return nil
        }
        return "/billing-groups/\(billingGroupName.urlPercentEncoding())"
    }
}

extension CreateCertificateFromCsrInput {

    static func urlPathProvider(_ value: CreateCertificateFromCsrInput) -> Swift.String? {
        return "/certificates"
    }
}

extension CreateCertificateFromCsrInput {

    static func queryItemProvider(_ value: CreateCertificateFromCsrInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let setAsActive = value.setAsActive {
            let setAsActiveQueryItem = Smithy.URIQueryItem(name: "setAsActive".urlPercentEncoding(), value: Swift.String(setAsActive).urlPercentEncoding())
            items.append(setAsActiveQueryItem)
        }
        return items
    }
}

extension CreateCertificateProviderInput {

    static func urlPathProvider(_ value: CreateCertificateProviderInput) -> Swift.String? {
        guard let certificateProviderName = value.certificateProviderName else {
            return nil
        }
        return "/certificate-providers/\(certificateProviderName.urlPercentEncoding())"
    }
}

extension CreateCustomMetricInput {

    static func urlPathProvider(_ value: CreateCustomMetricInput) -> Swift.String? {
        guard let metricName = value.metricName else {
            return nil
        }
        return "/custom-metric/\(metricName.urlPercentEncoding())"
    }
}

extension CreateDimensionInput {

    static func urlPathProvider(_ value: CreateDimensionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/dimensions/\(name.urlPercentEncoding())"
    }
}

extension CreateDomainConfigurationInput {

    static func urlPathProvider(_ value: CreateDomainConfigurationInput) -> Swift.String? {
        guard let domainConfigurationName = value.domainConfigurationName else {
            return nil
        }
        return "/domainConfigurations/\(domainConfigurationName.urlPercentEncoding())"
    }
}

extension CreateDynamicThingGroupInput {

    static func urlPathProvider(_ value: CreateDynamicThingGroupInput) -> Swift.String? {
        guard let thingGroupName = value.thingGroupName else {
            return nil
        }
        return "/dynamic-thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

extension CreateFleetMetricInput {

    static func urlPathProvider(_ value: CreateFleetMetricInput) -> Swift.String? {
        guard let metricName = value.metricName else {
            return nil
        }
        return "/fleet-metric/\(metricName.urlPercentEncoding())"
    }
}

extension CreateJobInput {

    static func urlPathProvider(_ value: CreateJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

extension CreateJobTemplateInput {

    static func urlPathProvider(_ value: CreateJobTemplateInput) -> Swift.String? {
        guard let jobTemplateId = value.jobTemplateId else {
            return nil
        }
        return "/job-templates/\(jobTemplateId.urlPercentEncoding())"
    }
}

extension CreateKeysAndCertificateInput {

    static func urlPathProvider(_ value: CreateKeysAndCertificateInput) -> Swift.String? {
        return "/keys-and-certificate"
    }
}

extension CreateKeysAndCertificateInput {

    static func queryItemProvider(_ value: CreateKeysAndCertificateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let setAsActive = value.setAsActive {
            let setAsActiveQueryItem = Smithy.URIQueryItem(name: "setAsActive".urlPercentEncoding(), value: Swift.String(setAsActive).urlPercentEncoding())
            items.append(setAsActiveQueryItem)
        }
        return items
    }
}

extension CreateMitigationActionInput {

    static func urlPathProvider(_ value: CreateMitigationActionInput) -> Swift.String? {
        guard let actionName = value.actionName else {
            return nil
        }
        return "/mitigationactions/actions/\(actionName.urlPercentEncoding())"
    }
}

extension CreateOTAUpdateInput {

    static func urlPathProvider(_ value: CreateOTAUpdateInput) -> Swift.String? {
        guard let otaUpdateId = value.otaUpdateId else {
            return nil
        }
        return "/otaUpdates/\(otaUpdateId.urlPercentEncoding())"
    }
}

extension CreatePackageInput {

    static func urlPathProvider(_ value: CreatePackageInput) -> Swift.String? {
        guard let packageName = value.packageName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())"
    }
}

extension CreatePackageInput {

    static func queryItemProvider(_ value: CreatePackageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension CreatePackageVersionInput {

    static func urlPathProvider(_ value: CreatePackageVersionInput) -> Swift.String? {
        guard let packageName = value.packageName else {
            return nil
        }
        guard let versionName = value.versionName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())/versions/\(versionName.urlPercentEncoding())"
    }
}

extension CreatePackageVersionInput {

    static func queryItemProvider(_ value: CreatePackageVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension CreatePolicyInput {

    static func urlPathProvider(_ value: CreatePolicyInput) -> Swift.String? {
        guard let policyName = value.policyName else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())"
    }
}

extension CreatePolicyVersionInput {

    static func urlPathProvider(_ value: CreatePolicyVersionInput) -> Swift.String? {
        guard let policyName = value.policyName else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())/version"
    }
}

extension CreatePolicyVersionInput {

    static func queryItemProvider(_ value: CreatePolicyVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let setAsDefault = value.setAsDefault {
            let setAsDefaultQueryItem = Smithy.URIQueryItem(name: "setAsDefault".urlPercentEncoding(), value: Swift.String(setAsDefault).urlPercentEncoding())
            items.append(setAsDefaultQueryItem)
        }
        return items
    }
}

extension CreateProvisioningClaimInput {

    static func urlPathProvider(_ value: CreateProvisioningClaimInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())/provisioning-claim"
    }
}

extension CreateProvisioningTemplateInput {

    static func urlPathProvider(_ value: CreateProvisioningTemplateInput) -> Swift.String? {
        return "/provisioning-templates"
    }
}

extension CreateProvisioningTemplateVersionInput {

    static func urlPathProvider(_ value: CreateProvisioningTemplateVersionInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())/versions"
    }
}

extension CreateProvisioningTemplateVersionInput {

    static func queryItemProvider(_ value: CreateProvisioningTemplateVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let setAsDefault = value.setAsDefault {
            let setAsDefaultQueryItem = Smithy.URIQueryItem(name: "setAsDefault".urlPercentEncoding(), value: Swift.String(setAsDefault).urlPercentEncoding())
            items.append(setAsDefaultQueryItem)
        }
        return items
    }
}

extension CreateRoleAliasInput {

    static func urlPathProvider(_ value: CreateRoleAliasInput) -> Swift.String? {
        guard let roleAlias = value.roleAlias else {
            return nil
        }
        return "/role-aliases/\(roleAlias.urlPercentEncoding())"
    }
}

extension CreateScheduledAuditInput {

    static func urlPathProvider(_ value: CreateScheduledAuditInput) -> Swift.String? {
        guard let scheduledAuditName = value.scheduledAuditName else {
            return nil
        }
        return "/audit/scheduledaudits/\(scheduledAuditName.urlPercentEncoding())"
    }
}

extension CreateSecurityProfileInput {

    static func urlPathProvider(_ value: CreateSecurityProfileInput) -> Swift.String? {
        guard let securityProfileName = value.securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())"
    }
}

extension CreateStreamInput {

    static func urlPathProvider(_ value: CreateStreamInput) -> Swift.String? {
        guard let streamId = value.streamId else {
            return nil
        }
        return "/streams/\(streamId.urlPercentEncoding())"
    }
}

extension CreateThingInput {

    static func urlPathProvider(_ value: CreateThingInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())"
    }
}

extension CreateThingGroupInput {

    static func urlPathProvider(_ value: CreateThingGroupInput) -> Swift.String? {
        guard let thingGroupName = value.thingGroupName else {
            return nil
        }
        return "/thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

extension CreateThingTypeInput {

    static func urlPathProvider(_ value: CreateThingTypeInput) -> Swift.String? {
        guard let thingTypeName = value.thingTypeName else {
            return nil
        }
        return "/thing-types/\(thingTypeName.urlPercentEncoding())"
    }
}

extension CreateTopicRuleInput {

    static func urlPathProvider(_ value: CreateTopicRuleInput) -> Swift.String? {
        guard let ruleName = value.ruleName else {
            return nil
        }
        return "/rules/\(ruleName.urlPercentEncoding())"
    }
}

extension CreateTopicRuleInput {

    static func headerProvider(_ value: CreateTopicRuleInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let tags = value.tags {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-tagging", value: Swift.String(tags)))
        }
        return items
    }
}

extension CreateTopicRuleDestinationInput {

    static func urlPathProvider(_ value: CreateTopicRuleDestinationInput) -> Swift.String? {
        return "/destinations"
    }
}

extension DeleteAccountAuditConfigurationInput {

    static func urlPathProvider(_ value: DeleteAccountAuditConfigurationInput) -> Swift.String? {
        return "/audit/configuration"
    }
}

extension DeleteAccountAuditConfigurationInput {

    static func queryItemProvider(_ value: DeleteAccountAuditConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let deleteScheduledAudits = value.deleteScheduledAudits {
            let deleteScheduledAuditsQueryItem = Smithy.URIQueryItem(name: "deleteScheduledAudits".urlPercentEncoding(), value: Swift.String(deleteScheduledAudits).urlPercentEncoding())
            items.append(deleteScheduledAuditsQueryItem)
        }
        return items
    }
}

extension DeleteAuditSuppressionInput {

    static func urlPathProvider(_ value: DeleteAuditSuppressionInput) -> Swift.String? {
        return "/audit/suppressions/delete"
    }
}

extension DeleteAuthorizerInput {

    static func urlPathProvider(_ value: DeleteAuthorizerInput) -> Swift.String? {
        guard let authorizerName = value.authorizerName else {
            return nil
        }
        return "/authorizer/\(authorizerName.urlPercentEncoding())"
    }
}

extension DeleteBillingGroupInput {

    static func urlPathProvider(_ value: DeleteBillingGroupInput) -> Swift.String? {
        guard let billingGroupName = value.billingGroupName else {
            return nil
        }
        return "/billing-groups/\(billingGroupName.urlPercentEncoding())"
    }
}

extension DeleteBillingGroupInput {

    static func queryItemProvider(_ value: DeleteBillingGroupInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let expectedVersion = value.expectedVersion {
            let expectedVersionQueryItem = Smithy.URIQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
            items.append(expectedVersionQueryItem)
        }
        return items
    }
}

extension DeleteCACertificateInput {

    static func urlPathProvider(_ value: DeleteCACertificateInput) -> Swift.String? {
        guard let certificateId = value.certificateId else {
            return nil
        }
        return "/cacertificate/\(certificateId.urlPercentEncoding())"
    }
}

extension DeleteCertificateInput {

    static func urlPathProvider(_ value: DeleteCertificateInput) -> Swift.String? {
        guard let certificateId = value.certificateId else {
            return nil
        }
        return "/certificates/\(certificateId.urlPercentEncoding())"
    }
}

extension DeleteCertificateInput {

    static func queryItemProvider(_ value: DeleteCertificateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let forceDelete = value.forceDelete {
            let forceDeleteQueryItem = Smithy.URIQueryItem(name: "forceDelete".urlPercentEncoding(), value: Swift.String(forceDelete).urlPercentEncoding())
            items.append(forceDeleteQueryItem)
        }
        return items
    }
}

extension DeleteCertificateProviderInput {

    static func urlPathProvider(_ value: DeleteCertificateProviderInput) -> Swift.String? {
        guard let certificateProviderName = value.certificateProviderName else {
            return nil
        }
        return "/certificate-providers/\(certificateProviderName.urlPercentEncoding())"
    }
}

extension DeleteCustomMetricInput {

    static func urlPathProvider(_ value: DeleteCustomMetricInput) -> Swift.String? {
        guard let metricName = value.metricName else {
            return nil
        }
        return "/custom-metric/\(metricName.urlPercentEncoding())"
    }
}

extension DeleteDimensionInput {

    static func urlPathProvider(_ value: DeleteDimensionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/dimensions/\(name.urlPercentEncoding())"
    }
}

extension DeleteDomainConfigurationInput {

    static func urlPathProvider(_ value: DeleteDomainConfigurationInput) -> Swift.String? {
        guard let domainConfigurationName = value.domainConfigurationName else {
            return nil
        }
        return "/domainConfigurations/\(domainConfigurationName.urlPercentEncoding())"
    }
}

extension DeleteDynamicThingGroupInput {

    static func urlPathProvider(_ value: DeleteDynamicThingGroupInput) -> Swift.String? {
        guard let thingGroupName = value.thingGroupName else {
            return nil
        }
        return "/dynamic-thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

extension DeleteDynamicThingGroupInput {

    static func queryItemProvider(_ value: DeleteDynamicThingGroupInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let expectedVersion = value.expectedVersion {
            let expectedVersionQueryItem = Smithy.URIQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
            items.append(expectedVersionQueryItem)
        }
        return items
    }
}

extension DeleteFleetMetricInput {

    static func urlPathProvider(_ value: DeleteFleetMetricInput) -> Swift.String? {
        guard let metricName = value.metricName else {
            return nil
        }
        return "/fleet-metric/\(metricName.urlPercentEncoding())"
    }
}

extension DeleteFleetMetricInput {

    static func queryItemProvider(_ value: DeleteFleetMetricInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let expectedVersion = value.expectedVersion {
            let expectedVersionQueryItem = Smithy.URIQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
            items.append(expectedVersionQueryItem)
        }
        return items
    }
}

extension DeleteJobInput {

    static func urlPathProvider(_ value: DeleteJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

extension DeleteJobInput {

    static func queryItemProvider(_ value: DeleteJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let namespaceId = value.namespaceId {
            let namespaceIdQueryItem = Smithy.URIQueryItem(name: "namespaceId".urlPercentEncoding(), value: Swift.String(namespaceId).urlPercentEncoding())
            items.append(namespaceIdQueryItem)
        }
        if let force = value.force {
            let forceQueryItem = Smithy.URIQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
            items.append(forceQueryItem)
        }
        return items
    }
}

extension DeleteJobExecutionInput {

    static func urlPathProvider(_ value: DeleteJobExecutionInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let executionNumber = value.executionNumber else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/executionNumber/\(executionNumber)"
    }
}

extension DeleteJobExecutionInput {

    static func queryItemProvider(_ value: DeleteJobExecutionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let namespaceId = value.namespaceId {
            let namespaceIdQueryItem = Smithy.URIQueryItem(name: "namespaceId".urlPercentEncoding(), value: Swift.String(namespaceId).urlPercentEncoding())
            items.append(namespaceIdQueryItem)
        }
        if let force = value.force {
            let forceQueryItem = Smithy.URIQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
            items.append(forceQueryItem)
        }
        return items
    }
}

extension DeleteJobTemplateInput {

    static func urlPathProvider(_ value: DeleteJobTemplateInput) -> Swift.String? {
        guard let jobTemplateId = value.jobTemplateId else {
            return nil
        }
        return "/job-templates/\(jobTemplateId.urlPercentEncoding())"
    }
}

extension DeleteMitigationActionInput {

    static func urlPathProvider(_ value: DeleteMitigationActionInput) -> Swift.String? {
        guard let actionName = value.actionName else {
            return nil
        }
        return "/mitigationactions/actions/\(actionName.urlPercentEncoding())"
    }
}

extension DeleteOTAUpdateInput {

    static func urlPathProvider(_ value: DeleteOTAUpdateInput) -> Swift.String? {
        guard let otaUpdateId = value.otaUpdateId else {
            return nil
        }
        return "/otaUpdates/\(otaUpdateId.urlPercentEncoding())"
    }
}

extension DeleteOTAUpdateInput {

    static func queryItemProvider(_ value: DeleteOTAUpdateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let deleteStream = value.deleteStream {
            let deleteStreamQueryItem = Smithy.URIQueryItem(name: "deleteStream".urlPercentEncoding(), value: Swift.String(deleteStream).urlPercentEncoding())
            items.append(deleteStreamQueryItem)
        }
        if let forceDeleteAWSJob = value.forceDeleteAWSJob {
            let forceDeleteAWSJobQueryItem = Smithy.URIQueryItem(name: "forceDeleteAWSJob".urlPercentEncoding(), value: Swift.String(forceDeleteAWSJob).urlPercentEncoding())
            items.append(forceDeleteAWSJobQueryItem)
        }
        return items
    }
}

extension DeletePackageInput {

    static func urlPathProvider(_ value: DeletePackageInput) -> Swift.String? {
        guard let packageName = value.packageName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())"
    }
}

extension DeletePackageInput {

    static func queryItemProvider(_ value: DeletePackageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeletePackageVersionInput {

    static func urlPathProvider(_ value: DeletePackageVersionInput) -> Swift.String? {
        guard let packageName = value.packageName else {
            return nil
        }
        guard let versionName = value.versionName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())/versions/\(versionName.urlPercentEncoding())"
    }
}

extension DeletePackageVersionInput {

    static func queryItemProvider(_ value: DeletePackageVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeletePolicyInput {

    static func urlPathProvider(_ value: DeletePolicyInput) -> Swift.String? {
        guard let policyName = value.policyName else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())"
    }
}

extension DeletePolicyVersionInput {

    static func urlPathProvider(_ value: DeletePolicyVersionInput) -> Swift.String? {
        guard let policyName = value.policyName else {
            return nil
        }
        guard let policyVersionId = value.policyVersionId else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())/version/\(policyVersionId.urlPercentEncoding())"
    }
}

extension DeleteProvisioningTemplateInput {

    static func urlPathProvider(_ value: DeleteProvisioningTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())"
    }
}

extension DeleteProvisioningTemplateVersionInput {

    static func urlPathProvider(_ value: DeleteProvisioningTemplateVersionInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        guard let versionId = value.versionId else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())/versions/\(versionId)"
    }
}

extension DeleteRegistrationCodeInput {

    static func urlPathProvider(_ value: DeleteRegistrationCodeInput) -> Swift.String? {
        return "/registrationcode"
    }
}

extension DeleteRoleAliasInput {

    static func urlPathProvider(_ value: DeleteRoleAliasInput) -> Swift.String? {
        guard let roleAlias = value.roleAlias else {
            return nil
        }
        return "/role-aliases/\(roleAlias.urlPercentEncoding())"
    }
}

extension DeleteScheduledAuditInput {

    static func urlPathProvider(_ value: DeleteScheduledAuditInput) -> Swift.String? {
        guard let scheduledAuditName = value.scheduledAuditName else {
            return nil
        }
        return "/audit/scheduledaudits/\(scheduledAuditName.urlPercentEncoding())"
    }
}

extension DeleteSecurityProfileInput {

    static func urlPathProvider(_ value: DeleteSecurityProfileInput) -> Swift.String? {
        guard let securityProfileName = value.securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())"
    }
}

extension DeleteSecurityProfileInput {

    static func queryItemProvider(_ value: DeleteSecurityProfileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let expectedVersion = value.expectedVersion {
            let expectedVersionQueryItem = Smithy.URIQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
            items.append(expectedVersionQueryItem)
        }
        return items
    }
}

extension DeleteStreamInput {

    static func urlPathProvider(_ value: DeleteStreamInput) -> Swift.String? {
        guard let streamId = value.streamId else {
            return nil
        }
        return "/streams/\(streamId.urlPercentEncoding())"
    }
}

extension DeleteThingInput {

    static func urlPathProvider(_ value: DeleteThingInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())"
    }
}

extension DeleteThingInput {

    static func queryItemProvider(_ value: DeleteThingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let expectedVersion = value.expectedVersion {
            let expectedVersionQueryItem = Smithy.URIQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
            items.append(expectedVersionQueryItem)
        }
        return items
    }
}

extension DeleteThingGroupInput {

    static func urlPathProvider(_ value: DeleteThingGroupInput) -> Swift.String? {
        guard let thingGroupName = value.thingGroupName else {
            return nil
        }
        return "/thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

extension DeleteThingGroupInput {

    static func queryItemProvider(_ value: DeleteThingGroupInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let expectedVersion = value.expectedVersion {
            let expectedVersionQueryItem = Smithy.URIQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
            items.append(expectedVersionQueryItem)
        }
        return items
    }
}

extension DeleteThingTypeInput {

    static func urlPathProvider(_ value: DeleteThingTypeInput) -> Swift.String? {
        guard let thingTypeName = value.thingTypeName else {
            return nil
        }
        return "/thing-types/\(thingTypeName.urlPercentEncoding())"
    }
}

extension DeleteTopicRuleInput {

    static func urlPathProvider(_ value: DeleteTopicRuleInput) -> Swift.String? {
        guard let ruleName = value.ruleName else {
            return nil
        }
        return "/rules/\(ruleName.urlPercentEncoding())"
    }
}

extension DeleteTopicRuleDestinationInput {

    static func urlPathProvider(_ value: DeleteTopicRuleDestinationInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/destinations/\(arn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DeleteV2LoggingLevelInput {

    static func urlPathProvider(_ value: DeleteV2LoggingLevelInput) -> Swift.String? {
        return "/v2LoggingLevel"
    }
}

extension DeleteV2LoggingLevelInput {

    static func queryItemProvider(_ value: DeleteV2LoggingLevelInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let targetName = value.targetName else {
            let message = "Creating a URL Query Item failed. targetName is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let targetNameQueryItem = Smithy.URIQueryItem(name: "targetName".urlPercentEncoding(), value: Swift.String(targetName).urlPercentEncoding())
        items.append(targetNameQueryItem)
        guard let targetType = value.targetType else {
            let message = "Creating a URL Query Item failed. targetType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let targetTypeQueryItem = Smithy.URIQueryItem(name: "targetType".urlPercentEncoding(), value: Swift.String(targetType.rawValue).urlPercentEncoding())
        items.append(targetTypeQueryItem)
        return items
    }
}

extension DeprecateThingTypeInput {

    static func urlPathProvider(_ value: DeprecateThingTypeInput) -> Swift.String? {
        guard let thingTypeName = value.thingTypeName else {
            return nil
        }
        return "/thing-types/\(thingTypeName.urlPercentEncoding())/deprecate"
    }
}

extension DescribeAccountAuditConfigurationInput {

    static func urlPathProvider(_ value: DescribeAccountAuditConfigurationInput) -> Swift.String? {
        return "/audit/configuration"
    }
}

extension DescribeAuditFindingInput {

    static func urlPathProvider(_ value: DescribeAuditFindingInput) -> Swift.String? {
        guard let findingId = value.findingId else {
            return nil
        }
        return "/audit/findings/\(findingId.urlPercentEncoding())"
    }
}

extension DescribeAuditMitigationActionsTaskInput {

    static func urlPathProvider(_ value: DescribeAuditMitigationActionsTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/audit/mitigationactions/tasks/\(taskId.urlPercentEncoding())"
    }
}

extension DescribeAuditSuppressionInput {

    static func urlPathProvider(_ value: DescribeAuditSuppressionInput) -> Swift.String? {
        return "/audit/suppressions/describe"
    }
}

extension DescribeAuditTaskInput {

    static func urlPathProvider(_ value: DescribeAuditTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/audit/tasks/\(taskId.urlPercentEncoding())"
    }
}

extension DescribeAuthorizerInput {

    static func urlPathProvider(_ value: DescribeAuthorizerInput) -> Swift.String? {
        guard let authorizerName = value.authorizerName else {
            return nil
        }
        return "/authorizer/\(authorizerName.urlPercentEncoding())"
    }
}

extension DescribeBillingGroupInput {

    static func urlPathProvider(_ value: DescribeBillingGroupInput) -> Swift.String? {
        guard let billingGroupName = value.billingGroupName else {
            return nil
        }
        return "/billing-groups/\(billingGroupName.urlPercentEncoding())"
    }
}

extension DescribeCACertificateInput {

    static func urlPathProvider(_ value: DescribeCACertificateInput) -> Swift.String? {
        guard let certificateId = value.certificateId else {
            return nil
        }
        return "/cacertificate/\(certificateId.urlPercentEncoding())"
    }
}

extension DescribeCertificateInput {

    static func urlPathProvider(_ value: DescribeCertificateInput) -> Swift.String? {
        guard let certificateId = value.certificateId else {
            return nil
        }
        return "/certificates/\(certificateId.urlPercentEncoding())"
    }
}

extension DescribeCertificateProviderInput {

    static func urlPathProvider(_ value: DescribeCertificateProviderInput) -> Swift.String? {
        guard let certificateProviderName = value.certificateProviderName else {
            return nil
        }
        return "/certificate-providers/\(certificateProviderName.urlPercentEncoding())"
    }
}

extension DescribeCustomMetricInput {

    static func urlPathProvider(_ value: DescribeCustomMetricInput) -> Swift.String? {
        guard let metricName = value.metricName else {
            return nil
        }
        return "/custom-metric/\(metricName.urlPercentEncoding())"
    }
}

extension DescribeDefaultAuthorizerInput {

    static func urlPathProvider(_ value: DescribeDefaultAuthorizerInput) -> Swift.String? {
        return "/default-authorizer"
    }
}

extension DescribeDetectMitigationActionsTaskInput {

    static func urlPathProvider(_ value: DescribeDetectMitigationActionsTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/detect/mitigationactions/tasks/\(taskId.urlPercentEncoding())"
    }
}

extension DescribeDimensionInput {

    static func urlPathProvider(_ value: DescribeDimensionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/dimensions/\(name.urlPercentEncoding())"
    }
}

extension DescribeDomainConfigurationInput {

    static func urlPathProvider(_ value: DescribeDomainConfigurationInput) -> Swift.String? {
        guard let domainConfigurationName = value.domainConfigurationName else {
            return nil
        }
        return "/domainConfigurations/\(domainConfigurationName.urlPercentEncoding())"
    }
}

extension DescribeEndpointInput {

    static func urlPathProvider(_ value: DescribeEndpointInput) -> Swift.String? {
        return "/endpoint"
    }
}

extension DescribeEndpointInput {

    static func queryItemProvider(_ value: DescribeEndpointInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let endpointType = value.endpointType {
            let endpointTypeQueryItem = Smithy.URIQueryItem(name: "endpointType".urlPercentEncoding(), value: Swift.String(endpointType).urlPercentEncoding())
            items.append(endpointTypeQueryItem)
        }
        return items
    }
}

extension DescribeEventConfigurationsInput {

    static func urlPathProvider(_ value: DescribeEventConfigurationsInput) -> Swift.String? {
        return "/event-configurations"
    }
}

extension DescribeFleetMetricInput {

    static func urlPathProvider(_ value: DescribeFleetMetricInput) -> Swift.String? {
        guard let metricName = value.metricName else {
            return nil
        }
        return "/fleet-metric/\(metricName.urlPercentEncoding())"
    }
}

extension DescribeIndexInput {

    static func urlPathProvider(_ value: DescribeIndexInput) -> Swift.String? {
        guard let indexName = value.indexName else {
            return nil
        }
        return "/indices/\(indexName.urlPercentEncoding())"
    }
}

extension DescribeJobInput {

    static func urlPathProvider(_ value: DescribeJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

extension DescribeJobInput {

    static func queryItemProvider(_ value: DescribeJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let beforeSubstitution = value.beforeSubstitution {
            let beforeSubstitutionQueryItem = Smithy.URIQueryItem(name: "beforeSubstitution".urlPercentEncoding(), value: Swift.String(beforeSubstitution).urlPercentEncoding())
            items.append(beforeSubstitutionQueryItem)
        }
        return items
    }
}

extension DescribeJobExecutionInput {

    static func urlPathProvider(_ value: DescribeJobExecutionInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

extension DescribeJobExecutionInput {

    static func queryItemProvider(_ value: DescribeJobExecutionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let executionNumber = value.executionNumber {
            let executionNumberQueryItem = Smithy.URIQueryItem(name: "executionNumber".urlPercentEncoding(), value: Swift.String(executionNumber).urlPercentEncoding())
            items.append(executionNumberQueryItem)
        }
        return items
    }
}

extension DescribeJobTemplateInput {

    static func urlPathProvider(_ value: DescribeJobTemplateInput) -> Swift.String? {
        guard let jobTemplateId = value.jobTemplateId else {
            return nil
        }
        return "/job-templates/\(jobTemplateId.urlPercentEncoding())"
    }
}

extension DescribeManagedJobTemplateInput {

    static func urlPathProvider(_ value: DescribeManagedJobTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/managed-job-templates/\(templateName.urlPercentEncoding())"
    }
}

extension DescribeManagedJobTemplateInput {

    static func queryItemProvider(_ value: DescribeManagedJobTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let templateVersion = value.templateVersion {
            let templateVersionQueryItem = Smithy.URIQueryItem(name: "templateVersion".urlPercentEncoding(), value: Swift.String(templateVersion).urlPercentEncoding())
            items.append(templateVersionQueryItem)
        }
        return items
    }
}

extension DescribeMitigationActionInput {

    static func urlPathProvider(_ value: DescribeMitigationActionInput) -> Swift.String? {
        guard let actionName = value.actionName else {
            return nil
        }
        return "/mitigationactions/actions/\(actionName.urlPercentEncoding())"
    }
}

extension DescribeProvisioningTemplateInput {

    static func urlPathProvider(_ value: DescribeProvisioningTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())"
    }
}

extension DescribeProvisioningTemplateVersionInput {

    static func urlPathProvider(_ value: DescribeProvisioningTemplateVersionInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        guard let versionId = value.versionId else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())/versions/\(versionId)"
    }
}

extension DescribeRoleAliasInput {

    static func urlPathProvider(_ value: DescribeRoleAliasInput) -> Swift.String? {
        guard let roleAlias = value.roleAlias else {
            return nil
        }
        return "/role-aliases/\(roleAlias.urlPercentEncoding())"
    }
}

extension DescribeScheduledAuditInput {

    static func urlPathProvider(_ value: DescribeScheduledAuditInput) -> Swift.String? {
        guard let scheduledAuditName = value.scheduledAuditName else {
            return nil
        }
        return "/audit/scheduledaudits/\(scheduledAuditName.urlPercentEncoding())"
    }
}

extension DescribeSecurityProfileInput {

    static func urlPathProvider(_ value: DescribeSecurityProfileInput) -> Swift.String? {
        guard let securityProfileName = value.securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())"
    }
}

extension DescribeStreamInput {

    static func urlPathProvider(_ value: DescribeStreamInput) -> Swift.String? {
        guard let streamId = value.streamId else {
            return nil
        }
        return "/streams/\(streamId.urlPercentEncoding())"
    }
}

extension DescribeThingInput {

    static func urlPathProvider(_ value: DescribeThingInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())"
    }
}

extension DescribeThingGroupInput {

    static func urlPathProvider(_ value: DescribeThingGroupInput) -> Swift.String? {
        guard let thingGroupName = value.thingGroupName else {
            return nil
        }
        return "/thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

extension DescribeThingRegistrationTaskInput {

    static func urlPathProvider(_ value: DescribeThingRegistrationTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/thing-registration-tasks/\(taskId.urlPercentEncoding())"
    }
}

extension DescribeThingTypeInput {

    static func urlPathProvider(_ value: DescribeThingTypeInput) -> Swift.String? {
        guard let thingTypeName = value.thingTypeName else {
            return nil
        }
        return "/thing-types/\(thingTypeName.urlPercentEncoding())"
    }
}

extension DetachPolicyInput {

    static func urlPathProvider(_ value: DetachPolicyInput) -> Swift.String? {
        guard let policyName = value.policyName else {
            return nil
        }
        return "/target-policies/\(policyName.urlPercentEncoding())"
    }
}

extension DetachPrincipalPolicyInput {

    static func urlPathProvider(_ value: DetachPrincipalPolicyInput) -> Swift.String? {
        guard let policyName = value.policyName else {
            return nil
        }
        return "/principal-policies/\(policyName.urlPercentEncoding())"
    }
}

extension DetachPrincipalPolicyInput {

    static func headerProvider(_ value: DetachPrincipalPolicyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let principal = value.principal {
            items.add(SmithyHTTPAPI.Header(name: "x-amzn-iot-principal", value: Swift.String(principal)))
        }
        return items
    }
}

extension DetachSecurityProfileInput {

    static func urlPathProvider(_ value: DetachSecurityProfileInput) -> Swift.String? {
        guard let securityProfileName = value.securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())/targets"
    }
}

extension DetachSecurityProfileInput {

    static func queryItemProvider(_ value: DetachSecurityProfileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let securityProfileTargetArn = value.securityProfileTargetArn else {
            let message = "Creating a URL Query Item failed. securityProfileTargetArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let securityProfileTargetArnQueryItem = Smithy.URIQueryItem(name: "securityProfileTargetArn".urlPercentEncoding(), value: Swift.String(securityProfileTargetArn).urlPercentEncoding())
        items.append(securityProfileTargetArnQueryItem)
        return items
    }
}

extension DetachThingPrincipalInput {

    static func urlPathProvider(_ value: DetachThingPrincipalInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/principals"
    }
}

extension DetachThingPrincipalInput {

    static func headerProvider(_ value: DetachThingPrincipalInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let principal = value.principal {
            items.add(SmithyHTTPAPI.Header(name: "x-amzn-principal", value: Swift.String(principal)))
        }
        return items
    }
}

extension DisableTopicRuleInput {

    static func urlPathProvider(_ value: DisableTopicRuleInput) -> Swift.String? {
        guard let ruleName = value.ruleName else {
            return nil
        }
        return "/rules/\(ruleName.urlPercentEncoding())/disable"
    }
}

extension DisassociateSbomFromPackageVersionInput {

    static func urlPathProvider(_ value: DisassociateSbomFromPackageVersionInput) -> Swift.String? {
        guard let packageName = value.packageName else {
            return nil
        }
        guard let versionName = value.versionName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())/versions/\(versionName.urlPercentEncoding())/sbom"
    }
}

extension DisassociateSbomFromPackageVersionInput {

    static func queryItemProvider(_ value: DisassociateSbomFromPackageVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension EnableTopicRuleInput {

    static func urlPathProvider(_ value: EnableTopicRuleInput) -> Swift.String? {
        guard let ruleName = value.ruleName else {
            return nil
        }
        return "/rules/\(ruleName.urlPercentEncoding())/enable"
    }
}

extension GetBehaviorModelTrainingSummariesInput {

    static func urlPathProvider(_ value: GetBehaviorModelTrainingSummariesInput) -> Swift.String? {
        return "/behavior-model-training/summaries"
    }
}

extension GetBehaviorModelTrainingSummariesInput {

    static func queryItemProvider(_ value: GetBehaviorModelTrainingSummariesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let securityProfileName = value.securityProfileName {
            let securityProfileNameQueryItem = Smithy.URIQueryItem(name: "securityProfileName".urlPercentEncoding(), value: Swift.String(securityProfileName).urlPercentEncoding())
            items.append(securityProfileNameQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetBucketsAggregationInput {

    static func urlPathProvider(_ value: GetBucketsAggregationInput) -> Swift.String? {
        return "/indices/buckets"
    }
}

extension GetCardinalityInput {

    static func urlPathProvider(_ value: GetCardinalityInput) -> Swift.String? {
        return "/indices/cardinality"
    }
}

extension GetEffectivePoliciesInput {

    static func urlPathProvider(_ value: GetEffectivePoliciesInput) -> Swift.String? {
        return "/effective-policies"
    }
}

extension GetEffectivePoliciesInput {

    static func queryItemProvider(_ value: GetEffectivePoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let thingName = value.thingName {
            let thingNameQueryItem = Smithy.URIQueryItem(name: "thingName".urlPercentEncoding(), value: Swift.String(thingName).urlPercentEncoding())
            items.append(thingNameQueryItem)
        }
        return items
    }
}

extension GetIndexingConfigurationInput {

    static func urlPathProvider(_ value: GetIndexingConfigurationInput) -> Swift.String? {
        return "/indexing/config"
    }
}

extension GetJobDocumentInput {

    static func urlPathProvider(_ value: GetJobDocumentInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())/job-document"
    }
}

extension GetJobDocumentInput {

    static func queryItemProvider(_ value: GetJobDocumentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let beforeSubstitution = value.beforeSubstitution {
            let beforeSubstitutionQueryItem = Smithy.URIQueryItem(name: "beforeSubstitution".urlPercentEncoding(), value: Swift.String(beforeSubstitution).urlPercentEncoding())
            items.append(beforeSubstitutionQueryItem)
        }
        return items
    }
}

extension GetLoggingOptionsInput {

    static func urlPathProvider(_ value: GetLoggingOptionsInput) -> Swift.String? {
        return "/loggingOptions"
    }
}

extension GetOTAUpdateInput {

    static func urlPathProvider(_ value: GetOTAUpdateInput) -> Swift.String? {
        guard let otaUpdateId = value.otaUpdateId else {
            return nil
        }
        return "/otaUpdates/\(otaUpdateId.urlPercentEncoding())"
    }
}

extension GetPackageInput {

    static func urlPathProvider(_ value: GetPackageInput) -> Swift.String? {
        guard let packageName = value.packageName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())"
    }
}

extension GetPackageConfigurationInput {

    static func urlPathProvider(_ value: GetPackageConfigurationInput) -> Swift.String? {
        return "/package-configuration"
    }
}

extension GetPackageVersionInput {

    static func urlPathProvider(_ value: GetPackageVersionInput) -> Swift.String? {
        guard let packageName = value.packageName else {
            return nil
        }
        guard let versionName = value.versionName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())/versions/\(versionName.urlPercentEncoding())"
    }
}

extension GetPercentilesInput {

    static func urlPathProvider(_ value: GetPercentilesInput) -> Swift.String? {
        return "/indices/percentiles"
    }
}

extension GetPolicyInput {

    static func urlPathProvider(_ value: GetPolicyInput) -> Swift.String? {
        guard let policyName = value.policyName else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())"
    }
}

extension GetPolicyVersionInput {

    static func urlPathProvider(_ value: GetPolicyVersionInput) -> Swift.String? {
        guard let policyName = value.policyName else {
            return nil
        }
        guard let policyVersionId = value.policyVersionId else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())/version/\(policyVersionId.urlPercentEncoding())"
    }
}

extension GetRegistrationCodeInput {

    static func urlPathProvider(_ value: GetRegistrationCodeInput) -> Swift.String? {
        return "/registrationcode"
    }
}

extension GetStatisticsInput {

    static func urlPathProvider(_ value: GetStatisticsInput) -> Swift.String? {
        return "/indices/statistics"
    }
}

extension GetTopicRuleInput {

    static func urlPathProvider(_ value: GetTopicRuleInput) -> Swift.String? {
        guard let ruleName = value.ruleName else {
            return nil
        }
        return "/rules/\(ruleName.urlPercentEncoding())"
    }
}

extension GetTopicRuleDestinationInput {

    static func urlPathProvider(_ value: GetTopicRuleDestinationInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/destinations/\(arn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension GetV2LoggingOptionsInput {

    static func urlPathProvider(_ value: GetV2LoggingOptionsInput) -> Swift.String? {
        return "/v2LoggingOptions"
    }
}

extension ListActiveViolationsInput {

    static func urlPathProvider(_ value: ListActiveViolationsInput) -> Swift.String? {
        return "/active-violations"
    }
}

extension ListActiveViolationsInput {

    static func queryItemProvider(_ value: ListActiveViolationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let securityProfileName = value.securityProfileName {
            let securityProfileNameQueryItem = Smithy.URIQueryItem(name: "securityProfileName".urlPercentEncoding(), value: Swift.String(securityProfileName).urlPercentEncoding())
            items.append(securityProfileNameQueryItem)
        }
        if let listSuppressedAlerts = value.listSuppressedAlerts {
            let listSuppressedAlertsQueryItem = Smithy.URIQueryItem(name: "listSuppressedAlerts".urlPercentEncoding(), value: Swift.String(listSuppressedAlerts).urlPercentEncoding())
            items.append(listSuppressedAlertsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let behaviorCriteriaType = value.behaviorCriteriaType {
            let behaviorCriteriaTypeQueryItem = Smithy.URIQueryItem(name: "behaviorCriteriaType".urlPercentEncoding(), value: Swift.String(behaviorCriteriaType.rawValue).urlPercentEncoding())
            items.append(behaviorCriteriaTypeQueryItem)
        }
        if let thingName = value.thingName {
            let thingNameQueryItem = Smithy.URIQueryItem(name: "thingName".urlPercentEncoding(), value: Swift.String(thingName).urlPercentEncoding())
            items.append(thingNameQueryItem)
        }
        if let verificationState = value.verificationState {
            let verificationStateQueryItem = Smithy.URIQueryItem(name: "verificationState".urlPercentEncoding(), value: Swift.String(verificationState.rawValue).urlPercentEncoding())
            items.append(verificationStateQueryItem)
        }
        return items
    }
}

extension ListAttachedPoliciesInput {

    static func urlPathProvider(_ value: ListAttachedPoliciesInput) -> Swift.String? {
        guard let target = value.target else {
            return nil
        }
        return "/attached-policies/\(target.urlPercentEncoding())"
    }
}

extension ListAttachedPoliciesInput {

    static func queryItemProvider(_ value: ListAttachedPoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let recursive = value.recursive {
            let recursiveQueryItem = Smithy.URIQueryItem(name: "recursive".urlPercentEncoding(), value: Swift.String(recursive).urlPercentEncoding())
            items.append(recursiveQueryItem)
        }
        return items
    }
}

extension ListAuditFindingsInput {

    static func urlPathProvider(_ value: ListAuditFindingsInput) -> Swift.String? {
        return "/audit/findings"
    }
}

extension ListAuditMitigationActionsExecutionsInput {

    static func urlPathProvider(_ value: ListAuditMitigationActionsExecutionsInput) -> Swift.String? {
        return "/audit/mitigationactions/executions"
    }
}

extension ListAuditMitigationActionsExecutionsInput {

    static func queryItemProvider(_ value: ListAuditMitigationActionsExecutionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let actionStatus = value.actionStatus {
            let actionStatusQueryItem = Smithy.URIQueryItem(name: "actionStatus".urlPercentEncoding(), value: Swift.String(actionStatus.rawValue).urlPercentEncoding())
            items.append(actionStatusQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let findingId = value.findingId else {
            let message = "Creating a URL Query Item failed. findingId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let findingIdQueryItem = Smithy.URIQueryItem(name: "findingId".urlPercentEncoding(), value: Swift.String(findingId).urlPercentEncoding())
        items.append(findingIdQueryItem)
        guard let taskId = value.taskId else {
            let message = "Creating a URL Query Item failed. taskId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let taskIdQueryItem = Smithy.URIQueryItem(name: "taskId".urlPercentEncoding(), value: Swift.String(taskId).urlPercentEncoding())
        items.append(taskIdQueryItem)
        return items
    }
}

extension ListAuditMitigationActionsTasksInput {

    static func urlPathProvider(_ value: ListAuditMitigationActionsTasksInput) -> Swift.String? {
        return "/audit/mitigationactions/tasks"
    }
}

extension ListAuditMitigationActionsTasksInput {

    static func queryItemProvider(_ value: ListAuditMitigationActionsTasksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let findingId = value.findingId {
            let findingIdQueryItem = Smithy.URIQueryItem(name: "findingId".urlPercentEncoding(), value: Swift.String(findingId).urlPercentEncoding())
            items.append(findingIdQueryItem)
        }
        guard let startTime = value.startTime else {
            let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startTimeQueryItem = Smithy.URIQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
        items.append(startTimeQueryItem)
        guard let endTime = value.endTime else {
            let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endTimeQueryItem = Smithy.URIQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
        items.append(endTimeQueryItem)
        if let auditTaskId = value.auditTaskId {
            let auditTaskIdQueryItem = Smithy.URIQueryItem(name: "auditTaskId".urlPercentEncoding(), value: Swift.String(auditTaskId).urlPercentEncoding())
            items.append(auditTaskIdQueryItem)
        }
        if let taskStatus = value.taskStatus {
            let taskStatusQueryItem = Smithy.URIQueryItem(name: "taskStatus".urlPercentEncoding(), value: Swift.String(taskStatus.rawValue).urlPercentEncoding())
            items.append(taskStatusQueryItem)
        }
        return items
    }
}

extension ListAuditSuppressionsInput {

    static func urlPathProvider(_ value: ListAuditSuppressionsInput) -> Swift.String? {
        return "/audit/suppressions/list"
    }
}

extension ListAuditTasksInput {

    static func urlPathProvider(_ value: ListAuditTasksInput) -> Swift.String? {
        return "/audit/tasks"
    }
}

extension ListAuditTasksInput {

    static func queryItemProvider(_ value: ListAuditTasksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let taskType = value.taskType {
            let taskTypeQueryItem = Smithy.URIQueryItem(name: "taskType".urlPercentEncoding(), value: Swift.String(taskType.rawValue).urlPercentEncoding())
            items.append(taskTypeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let startTime = value.startTime else {
            let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startTimeQueryItem = Smithy.URIQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
        items.append(startTimeQueryItem)
        guard let endTime = value.endTime else {
            let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endTimeQueryItem = Smithy.URIQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
        items.append(endTimeQueryItem)
        if let taskStatus = value.taskStatus {
            let taskStatusQueryItem = Smithy.URIQueryItem(name: "taskStatus".urlPercentEncoding(), value: Swift.String(taskStatus.rawValue).urlPercentEncoding())
            items.append(taskStatusQueryItem)
        }
        return items
    }
}

extension ListAuthorizersInput {

    static func urlPathProvider(_ value: ListAuthorizersInput) -> Swift.String? {
        return "/authorizers"
    }
}

extension ListAuthorizersInput {

    static func queryItemProvider(_ value: ListAuthorizersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let ascendingOrder = value.ascendingOrder {
            let ascendingOrderQueryItem = Smithy.URIQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
            items.append(ascendingOrderQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListBillingGroupsInput {

    static func urlPathProvider(_ value: ListBillingGroupsInput) -> Swift.String? {
        return "/billing-groups"
    }
}

extension ListBillingGroupsInput {

    static func queryItemProvider(_ value: ListBillingGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let namePrefixFilter = value.namePrefixFilter {
            let namePrefixFilterQueryItem = Smithy.URIQueryItem(name: "namePrefixFilter".urlPercentEncoding(), value: Swift.String(namePrefixFilter).urlPercentEncoding())
            items.append(namePrefixFilterQueryItem)
        }
        return items
    }
}

extension ListCACertificatesInput {

    static func urlPathProvider(_ value: ListCACertificatesInput) -> Swift.String? {
        return "/cacertificates"
    }
}

extension ListCACertificatesInput {

    static func queryItemProvider(_ value: ListCACertificatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let ascendingOrder = value.ascendingOrder {
            let ascendingOrderQueryItem = Smithy.URIQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
            items.append(ascendingOrderQueryItem)
        }
        if let templateName = value.templateName {
            let templateNameQueryItem = Smithy.URIQueryItem(name: "templateName".urlPercentEncoding(), value: Swift.String(templateName).urlPercentEncoding())
            items.append(templateNameQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListCertificateProvidersInput {

    static func urlPathProvider(_ value: ListCertificateProvidersInput) -> Swift.String? {
        return "/certificate-providers"
    }
}

extension ListCertificateProvidersInput {

    static func queryItemProvider(_ value: ListCertificateProvidersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let ascendingOrder = value.ascendingOrder {
            let ascendingOrderQueryItem = Smithy.URIQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
            items.append(ascendingOrderQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListCertificatesInput {

    static func urlPathProvider(_ value: ListCertificatesInput) -> Swift.String? {
        return "/certificates"
    }
}

extension ListCertificatesInput {

    static func queryItemProvider(_ value: ListCertificatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let ascendingOrder = value.ascendingOrder {
            let ascendingOrderQueryItem = Smithy.URIQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
            items.append(ascendingOrderQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListCertificatesByCAInput {

    static func urlPathProvider(_ value: ListCertificatesByCAInput) -> Swift.String? {
        guard let caCertificateId = value.caCertificateId else {
            return nil
        }
        return "/certificates-by-ca/\(caCertificateId.urlPercentEncoding())"
    }
}

extension ListCertificatesByCAInput {

    static func queryItemProvider(_ value: ListCertificatesByCAInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let ascendingOrder = value.ascendingOrder {
            let ascendingOrderQueryItem = Smithy.URIQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
            items.append(ascendingOrderQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListCustomMetricsInput {

    static func urlPathProvider(_ value: ListCustomMetricsInput) -> Swift.String? {
        return "/custom-metrics"
    }
}

extension ListCustomMetricsInput {

    static func queryItemProvider(_ value: ListCustomMetricsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDetectMitigationActionsExecutionsInput {

    static func urlPathProvider(_ value: ListDetectMitigationActionsExecutionsInput) -> Swift.String? {
        return "/detect/mitigationactions/executions"
    }
}

extension ListDetectMitigationActionsExecutionsInput {

    static func queryItemProvider(_ value: ListDetectMitigationActionsExecutionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let thingName = value.thingName {
            let thingNameQueryItem = Smithy.URIQueryItem(name: "thingName".urlPercentEncoding(), value: Swift.String(thingName).urlPercentEncoding())
            items.append(thingNameQueryItem)
        }
        if let startTime = value.startTime {
            let startTimeQueryItem = Smithy.URIQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
        }
        if let endTime = value.endTime {
            let endTimeQueryItem = Smithy.URIQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
        }
        if let taskId = value.taskId {
            let taskIdQueryItem = Smithy.URIQueryItem(name: "taskId".urlPercentEncoding(), value: Swift.String(taskId).urlPercentEncoding())
            items.append(taskIdQueryItem)
        }
        if let violationId = value.violationId {
            let violationIdQueryItem = Smithy.URIQueryItem(name: "violationId".urlPercentEncoding(), value: Swift.String(violationId).urlPercentEncoding())
            items.append(violationIdQueryItem)
        }
        return items
    }
}

extension ListDetectMitigationActionsTasksInput {

    static func urlPathProvider(_ value: ListDetectMitigationActionsTasksInput) -> Swift.String? {
        return "/detect/mitigationactions/tasks"
    }
}

extension ListDetectMitigationActionsTasksInput {

    static func queryItemProvider(_ value: ListDetectMitigationActionsTasksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let startTime = value.startTime else {
            let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startTimeQueryItem = Smithy.URIQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
        items.append(startTimeQueryItem)
        guard let endTime = value.endTime else {
            let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endTimeQueryItem = Smithy.URIQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
        items.append(endTimeQueryItem)
        return items
    }
}

extension ListDimensionsInput {

    static func urlPathProvider(_ value: ListDimensionsInput) -> Swift.String? {
        return "/dimensions"
    }
}

extension ListDimensionsInput {

    static func queryItemProvider(_ value: ListDimensionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDomainConfigurationsInput {

    static func urlPathProvider(_ value: ListDomainConfigurationsInput) -> Swift.String? {
        return "/domainConfigurations"
    }
}

extension ListDomainConfigurationsInput {

    static func queryItemProvider(_ value: ListDomainConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let serviceType = value.serviceType {
            let serviceTypeQueryItem = Smithy.URIQueryItem(name: "serviceType".urlPercentEncoding(), value: Swift.String(serviceType.rawValue).urlPercentEncoding())
            items.append(serviceTypeQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListFleetMetricsInput {

    static func urlPathProvider(_ value: ListFleetMetricsInput) -> Swift.String? {
        return "/fleet-metrics"
    }
}

extension ListFleetMetricsInput {

    static func queryItemProvider(_ value: ListFleetMetricsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIndicesInput {

    static func urlPathProvider(_ value: ListIndicesInput) -> Swift.String? {
        return "/indices"
    }
}

extension ListIndicesInput {

    static func queryItemProvider(_ value: ListIndicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListJobExecutionsForJobInput {

    static func urlPathProvider(_ value: ListJobExecutionsForJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())/things"
    }
}

extension ListJobExecutionsForJobInput {

    static func queryItemProvider(_ value: ListJobExecutionsForJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListJobExecutionsForThingInput {

    static func urlPathProvider(_ value: ListJobExecutionsForThingInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/jobs"
    }
}

extension ListJobExecutionsForThingInput {

    static func queryItemProvider(_ value: ListJobExecutionsForThingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let jobId = value.jobId {
            let jobIdQueryItem = Smithy.URIQueryItem(name: "jobId".urlPercentEncoding(), value: Swift.String(jobId).urlPercentEncoding())
            items.append(jobIdQueryItem)
        }
        if let namespaceId = value.namespaceId {
            let namespaceIdQueryItem = Smithy.URIQueryItem(name: "namespaceId".urlPercentEncoding(), value: Swift.String(namespaceId).urlPercentEncoding())
            items.append(namespaceIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListJobsInput {

    static func urlPathProvider(_ value: ListJobsInput) -> Swift.String? {
        return "/jobs"
    }
}

extension ListJobsInput {

    static func queryItemProvider(_ value: ListJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let thingGroupId = value.thingGroupId {
            let thingGroupIdQueryItem = Smithy.URIQueryItem(name: "thingGroupId".urlPercentEncoding(), value: Swift.String(thingGroupId).urlPercentEncoding())
            items.append(thingGroupIdQueryItem)
        }
        if let namespaceId = value.namespaceId {
            let namespaceIdQueryItem = Smithy.URIQueryItem(name: "namespaceId".urlPercentEncoding(), value: Swift.String(namespaceId).urlPercentEncoding())
            items.append(namespaceIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let thingGroupName = value.thingGroupName {
            let thingGroupNameQueryItem = Smithy.URIQueryItem(name: "thingGroupName".urlPercentEncoding(), value: Swift.String(thingGroupName).urlPercentEncoding())
            items.append(thingGroupNameQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let targetSelection = value.targetSelection {
            let targetSelectionQueryItem = Smithy.URIQueryItem(name: "targetSelection".urlPercentEncoding(), value: Swift.String(targetSelection.rawValue).urlPercentEncoding())
            items.append(targetSelectionQueryItem)
        }
        return items
    }
}

extension ListJobTemplatesInput {

    static func urlPathProvider(_ value: ListJobTemplatesInput) -> Swift.String? {
        return "/job-templates"
    }
}

extension ListJobTemplatesInput {

    static func queryItemProvider(_ value: ListJobTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListManagedJobTemplatesInput {

    static func urlPathProvider(_ value: ListManagedJobTemplatesInput) -> Swift.String? {
        return "/managed-job-templates"
    }
}

extension ListManagedJobTemplatesInput {

    static func queryItemProvider(_ value: ListManagedJobTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let templateName = value.templateName {
            let templateNameQueryItem = Smithy.URIQueryItem(name: "templateName".urlPercentEncoding(), value: Swift.String(templateName).urlPercentEncoding())
            items.append(templateNameQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListMetricValuesInput {

    static func urlPathProvider(_ value: ListMetricValuesInput) -> Swift.String? {
        return "/metric-values"
    }
}

extension ListMetricValuesInput {

    static func queryItemProvider(_ value: ListMetricValuesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let metricName = value.metricName else {
            let message = "Creating a URL Query Item failed. metricName is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let metricNameQueryItem = Smithy.URIQueryItem(name: "metricName".urlPercentEncoding(), value: Swift.String(metricName).urlPercentEncoding())
        items.append(metricNameQueryItem)
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let thingName = value.thingName else {
            let message = "Creating a URL Query Item failed. thingName is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let thingNameQueryItem = Smithy.URIQueryItem(name: "thingName".urlPercentEncoding(), value: Swift.String(thingName).urlPercentEncoding())
        items.append(thingNameQueryItem)
        guard let startTime = value.startTime else {
            let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startTimeQueryItem = Smithy.URIQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
        items.append(startTimeQueryItem)
        guard let endTime = value.endTime else {
            let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endTimeQueryItem = Smithy.URIQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
        items.append(endTimeQueryItem)
        if let dimensionName = value.dimensionName {
            let dimensionNameQueryItem = Smithy.URIQueryItem(name: "dimensionName".urlPercentEncoding(), value: Swift.String(dimensionName).urlPercentEncoding())
            items.append(dimensionNameQueryItem)
        }
        if let dimensionValueOperator = value.dimensionValueOperator {
            let dimensionValueOperatorQueryItem = Smithy.URIQueryItem(name: "dimensionValueOperator".urlPercentEncoding(), value: Swift.String(dimensionValueOperator.rawValue).urlPercentEncoding())
            items.append(dimensionValueOperatorQueryItem)
        }
        return items
    }
}

extension ListMitigationActionsInput {

    static func urlPathProvider(_ value: ListMitigationActionsInput) -> Swift.String? {
        return "/mitigationactions/actions"
    }
}

extension ListMitigationActionsInput {

    static func queryItemProvider(_ value: ListMitigationActionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let actionType = value.actionType {
            let actionTypeQueryItem = Smithy.URIQueryItem(name: "actionType".urlPercentEncoding(), value: Swift.String(actionType.rawValue).urlPercentEncoding())
            items.append(actionTypeQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListOTAUpdatesInput {

    static func urlPathProvider(_ value: ListOTAUpdatesInput) -> Swift.String? {
        return "/otaUpdates"
    }
}

extension ListOTAUpdatesInput {

    static func queryItemProvider(_ value: ListOTAUpdatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let otaUpdateStatus = value.otaUpdateStatus {
            let otaUpdateStatusQueryItem = Smithy.URIQueryItem(name: "otaUpdateStatus".urlPercentEncoding(), value: Swift.String(otaUpdateStatus.rawValue).urlPercentEncoding())
            items.append(otaUpdateStatusQueryItem)
        }
        return items
    }
}

extension ListOutgoingCertificatesInput {

    static func urlPathProvider(_ value: ListOutgoingCertificatesInput) -> Swift.String? {
        return "/certificates-out-going"
    }
}

extension ListOutgoingCertificatesInput {

    static func queryItemProvider(_ value: ListOutgoingCertificatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let ascendingOrder = value.ascendingOrder {
            let ascendingOrderQueryItem = Smithy.URIQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
            items.append(ascendingOrderQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListPackagesInput {

    static func urlPathProvider(_ value: ListPackagesInput) -> Swift.String? {
        return "/packages"
    }
}

extension ListPackagesInput {

    static func queryItemProvider(_ value: ListPackagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListPackageVersionsInput {

    static func urlPathProvider(_ value: ListPackageVersionsInput) -> Swift.String? {
        guard let packageName = value.packageName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())/versions"
    }
}

extension ListPackageVersionsInput {

    static func queryItemProvider(_ value: ListPackageVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListPoliciesInput {

    static func urlPathProvider(_ value: ListPoliciesInput) -> Swift.String? {
        return "/policies"
    }
}

extension ListPoliciesInput {

    static func queryItemProvider(_ value: ListPoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let ascendingOrder = value.ascendingOrder {
            let ascendingOrderQueryItem = Smithy.URIQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
            items.append(ascendingOrderQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListPolicyPrincipalsInput {

    static func urlPathProvider(_ value: ListPolicyPrincipalsInput) -> Swift.String? {
        return "/policy-principals"
    }
}

extension ListPolicyPrincipalsInput {

    static func headerProvider(_ value: ListPolicyPrincipalsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let policyName = value.policyName {
            items.add(SmithyHTTPAPI.Header(name: "x-amzn-iot-policy", value: Swift.String(policyName)))
        }
        return items
    }
}

extension ListPolicyPrincipalsInput {

    static func queryItemProvider(_ value: ListPolicyPrincipalsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let ascendingOrder = value.ascendingOrder {
            let ascendingOrderQueryItem = Smithy.URIQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
            items.append(ascendingOrderQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListPolicyVersionsInput {

    static func urlPathProvider(_ value: ListPolicyVersionsInput) -> Swift.String? {
        guard let policyName = value.policyName else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())/version"
    }
}

extension ListPrincipalPoliciesInput {

    static func urlPathProvider(_ value: ListPrincipalPoliciesInput) -> Swift.String? {
        return "/principal-policies"
    }
}

extension ListPrincipalPoliciesInput {

    static func headerProvider(_ value: ListPrincipalPoliciesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let principal = value.principal {
            items.add(SmithyHTTPAPI.Header(name: "x-amzn-iot-principal", value: Swift.String(principal)))
        }
        return items
    }
}

extension ListPrincipalPoliciesInput {

    static func queryItemProvider(_ value: ListPrincipalPoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let ascendingOrder = value.ascendingOrder {
            let ascendingOrderQueryItem = Smithy.URIQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
            items.append(ascendingOrderQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListPrincipalThingsInput {

    static func urlPathProvider(_ value: ListPrincipalThingsInput) -> Swift.String? {
        return "/principals/things"
    }
}

extension ListPrincipalThingsInput {

    static func headerProvider(_ value: ListPrincipalThingsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let principal = value.principal {
            items.add(SmithyHTTPAPI.Header(name: "x-amzn-principal", value: Swift.String(principal)))
        }
        return items
    }
}

extension ListPrincipalThingsInput {

    static func queryItemProvider(_ value: ListPrincipalThingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProvisioningTemplatesInput {

    static func urlPathProvider(_ value: ListProvisioningTemplatesInput) -> Swift.String? {
        return "/provisioning-templates"
    }
}

extension ListProvisioningTemplatesInput {

    static func queryItemProvider(_ value: ListProvisioningTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListProvisioningTemplateVersionsInput {

    static func urlPathProvider(_ value: ListProvisioningTemplateVersionsInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())/versions"
    }
}

extension ListProvisioningTemplateVersionsInput {

    static func queryItemProvider(_ value: ListProvisioningTemplateVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListRelatedResourcesForAuditFindingInput {

    static func urlPathProvider(_ value: ListRelatedResourcesForAuditFindingInput) -> Swift.String? {
        return "/audit/relatedResources"
    }
}

extension ListRelatedResourcesForAuditFindingInput {

    static func queryItemProvider(_ value: ListRelatedResourcesForAuditFindingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let findingId = value.findingId else {
            let message = "Creating a URL Query Item failed. findingId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let findingIdQueryItem = Smithy.URIQueryItem(name: "findingId".urlPercentEncoding(), value: Swift.String(findingId).urlPercentEncoding())
        items.append(findingIdQueryItem)
        return items
    }
}

extension ListRoleAliasesInput {

    static func urlPathProvider(_ value: ListRoleAliasesInput) -> Swift.String? {
        return "/role-aliases"
    }
}

extension ListRoleAliasesInput {

    static func queryItemProvider(_ value: ListRoleAliasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let ascendingOrder = value.ascendingOrder {
            let ascendingOrderQueryItem = Smithy.URIQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
            items.append(ascendingOrderQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListSbomValidationResultsInput {

    static func urlPathProvider(_ value: ListSbomValidationResultsInput) -> Swift.String? {
        guard let packageName = value.packageName else {
            return nil
        }
        guard let versionName = value.versionName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())/versions/\(versionName.urlPercentEncoding())/sbom-validation-results"
    }
}

extension ListSbomValidationResultsInput {

    static func queryItemProvider(_ value: ListSbomValidationResultsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let validationResult = value.validationResult {
            let validationResultQueryItem = Smithy.URIQueryItem(name: "validationResult".urlPercentEncoding(), value: Swift.String(validationResult.rawValue).urlPercentEncoding())
            items.append(validationResultQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListScheduledAuditsInput {

    static func urlPathProvider(_ value: ListScheduledAuditsInput) -> Swift.String? {
        return "/audit/scheduledaudits"
    }
}

extension ListScheduledAuditsInput {

    static func queryItemProvider(_ value: ListScheduledAuditsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSecurityProfilesInput {

    static func urlPathProvider(_ value: ListSecurityProfilesInput) -> Swift.String? {
        return "/security-profiles"
    }
}

extension ListSecurityProfilesInput {

    static func queryItemProvider(_ value: ListSecurityProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let metricName = value.metricName {
            let metricNameQueryItem = Smithy.URIQueryItem(name: "metricName".urlPercentEncoding(), value: Swift.String(metricName).urlPercentEncoding())
            items.append(metricNameQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let dimensionName = value.dimensionName {
            let dimensionNameQueryItem = Smithy.URIQueryItem(name: "dimensionName".urlPercentEncoding(), value: Swift.String(dimensionName).urlPercentEncoding())
            items.append(dimensionNameQueryItem)
        }
        return items
    }
}

extension ListSecurityProfilesForTargetInput {

    static func urlPathProvider(_ value: ListSecurityProfilesForTargetInput) -> Swift.String? {
        return "/security-profiles-for-target"
    }
}

extension ListSecurityProfilesForTargetInput {

    static func queryItemProvider(_ value: ListSecurityProfilesForTargetInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let recursive = value.recursive {
            let recursiveQueryItem = Smithy.URIQueryItem(name: "recursive".urlPercentEncoding(), value: Swift.String(recursive).urlPercentEncoding())
            items.append(recursiveQueryItem)
        }
        guard let securityProfileTargetArn = value.securityProfileTargetArn else {
            let message = "Creating a URL Query Item failed. securityProfileTargetArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let securityProfileTargetArnQueryItem = Smithy.URIQueryItem(name: "securityProfileTargetArn".urlPercentEncoding(), value: Swift.String(securityProfileTargetArn).urlPercentEncoding())
        items.append(securityProfileTargetArnQueryItem)
        return items
    }
}

extension ListStreamsInput {

    static func urlPathProvider(_ value: ListStreamsInput) -> Swift.String? {
        return "/streams"
    }
}

extension ListStreamsInput {

    static func queryItemProvider(_ value: ListStreamsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let ascendingOrder = value.ascendingOrder {
            let ascendingOrderQueryItem = Smithy.URIQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
            items.append(ascendingOrderQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension ListTargetsForPolicyInput {

    static func urlPathProvider(_ value: ListTargetsForPolicyInput) -> Swift.String? {
        guard let policyName = value.policyName else {
            return nil
        }
        return "/policy-targets/\(policyName.urlPercentEncoding())"
    }
}

extension ListTargetsForPolicyInput {

    static func queryItemProvider(_ value: ListTargetsForPolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListTargetsForSecurityProfileInput {

    static func urlPathProvider(_ value: ListTargetsForSecurityProfileInput) -> Swift.String? {
        guard let securityProfileName = value.securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())/targets"
    }
}

extension ListTargetsForSecurityProfileInput {

    static func queryItemProvider(_ value: ListTargetsForSecurityProfileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListThingGroupsInput {

    static func urlPathProvider(_ value: ListThingGroupsInput) -> Swift.String? {
        return "/thing-groups"
    }
}

extension ListThingGroupsInput {

    static func queryItemProvider(_ value: ListThingGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let parentGroup = value.parentGroup {
            let parentGroupQueryItem = Smithy.URIQueryItem(name: "parentGroup".urlPercentEncoding(), value: Swift.String(parentGroup).urlPercentEncoding())
            items.append(parentGroupQueryItem)
        }
        if let namePrefixFilter = value.namePrefixFilter {
            let namePrefixFilterQueryItem = Smithy.URIQueryItem(name: "namePrefixFilter".urlPercentEncoding(), value: Swift.String(namePrefixFilter).urlPercentEncoding())
            items.append(namePrefixFilterQueryItem)
        }
        if let recursive = value.recursive {
            let recursiveQueryItem = Smithy.URIQueryItem(name: "recursive".urlPercentEncoding(), value: Swift.String(recursive).urlPercentEncoding())
            items.append(recursiveQueryItem)
        }
        return items
    }
}

extension ListThingGroupsForThingInput {

    static func urlPathProvider(_ value: ListThingGroupsForThingInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/thing-groups"
    }
}

extension ListThingGroupsForThingInput {

    static func queryItemProvider(_ value: ListThingGroupsForThingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListThingPrincipalsInput {

    static func urlPathProvider(_ value: ListThingPrincipalsInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/principals"
    }
}

extension ListThingPrincipalsInput {

    static func queryItemProvider(_ value: ListThingPrincipalsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListThingRegistrationTaskReportsInput {

    static func urlPathProvider(_ value: ListThingRegistrationTaskReportsInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/thing-registration-tasks/\(taskId.urlPercentEncoding())/reports"
    }
}

extension ListThingRegistrationTaskReportsInput {

    static func queryItemProvider(_ value: ListThingRegistrationTaskReportsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let reportType = value.reportType else {
            let message = "Creating a URL Query Item failed. reportType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let reportTypeQueryItem = Smithy.URIQueryItem(name: "reportType".urlPercentEncoding(), value: Swift.String(reportType.rawValue).urlPercentEncoding())
        items.append(reportTypeQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListThingRegistrationTasksInput {

    static func urlPathProvider(_ value: ListThingRegistrationTasksInput) -> Swift.String? {
        return "/thing-registration-tasks"
    }
}

extension ListThingRegistrationTasksInput {

    static func queryItemProvider(_ value: ListThingRegistrationTasksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListThingsInput {

    static func urlPathProvider(_ value: ListThingsInput) -> Swift.String? {
        return "/things"
    }
}

extension ListThingsInput {

    static func queryItemProvider(_ value: ListThingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let usePrefixAttributeValue = value.usePrefixAttributeValue {
            let usePrefixAttributeValueQueryItem = Smithy.URIQueryItem(name: "usePrefixAttributeValue".urlPercentEncoding(), value: Swift.String(usePrefixAttributeValue).urlPercentEncoding())
            items.append(usePrefixAttributeValueQueryItem)
        }
        if let attributeValue = value.attributeValue {
            let attributeValueQueryItem = Smithy.URIQueryItem(name: "attributeValue".urlPercentEncoding(), value: Swift.String(attributeValue).urlPercentEncoding())
            items.append(attributeValueQueryItem)
        }
        if let thingTypeName = value.thingTypeName {
            let thingTypeNameQueryItem = Smithy.URIQueryItem(name: "thingTypeName".urlPercentEncoding(), value: Swift.String(thingTypeName).urlPercentEncoding())
            items.append(thingTypeNameQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let attributeName = value.attributeName {
            let attributeNameQueryItem = Smithy.URIQueryItem(name: "attributeName".urlPercentEncoding(), value: Swift.String(attributeName).urlPercentEncoding())
            items.append(attributeNameQueryItem)
        }
        return items
    }
}

extension ListThingsInBillingGroupInput {

    static func urlPathProvider(_ value: ListThingsInBillingGroupInput) -> Swift.String? {
        guard let billingGroupName = value.billingGroupName else {
            return nil
        }
        return "/billing-groups/\(billingGroupName.urlPercentEncoding())/things"
    }
}

extension ListThingsInBillingGroupInput {

    static func queryItemProvider(_ value: ListThingsInBillingGroupInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListThingsInThingGroupInput {

    static func urlPathProvider(_ value: ListThingsInThingGroupInput) -> Swift.String? {
        guard let thingGroupName = value.thingGroupName else {
            return nil
        }
        return "/thing-groups/\(thingGroupName.urlPercentEncoding())/things"
    }
}

extension ListThingsInThingGroupInput {

    static func queryItemProvider(_ value: ListThingsInThingGroupInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let recursive = value.recursive {
            let recursiveQueryItem = Smithy.URIQueryItem(name: "recursive".urlPercentEncoding(), value: Swift.String(recursive).urlPercentEncoding())
            items.append(recursiveQueryItem)
        }
        return items
    }
}

extension ListThingTypesInput {

    static func urlPathProvider(_ value: ListThingTypesInput) -> Swift.String? {
        return "/thing-types"
    }
}

extension ListThingTypesInput {

    static func queryItemProvider(_ value: ListThingTypesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let thingTypeName = value.thingTypeName {
            let thingTypeNameQueryItem = Smithy.URIQueryItem(name: "thingTypeName".urlPercentEncoding(), value: Swift.String(thingTypeName).urlPercentEncoding())
            items.append(thingTypeNameQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTopicRuleDestinationsInput {

    static func urlPathProvider(_ value: ListTopicRuleDestinationsInput) -> Swift.String? {
        return "/destinations"
    }
}

extension ListTopicRuleDestinationsInput {

    static func queryItemProvider(_ value: ListTopicRuleDestinationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTopicRulesInput {

    static func urlPathProvider(_ value: ListTopicRulesInput) -> Swift.String? {
        return "/rules"
    }
}

extension ListTopicRulesInput {

    static func queryItemProvider(_ value: ListTopicRulesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let ruleDisabled = value.ruleDisabled {
            let ruleDisabledQueryItem = Smithy.URIQueryItem(name: "ruleDisabled".urlPercentEncoding(), value: Swift.String(ruleDisabled).urlPercentEncoding())
            items.append(ruleDisabledQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let topic = value.topic {
            let topicQueryItem = Smithy.URIQueryItem(name: "topic".urlPercentEncoding(), value: Swift.String(topic).urlPercentEncoding())
            items.append(topicQueryItem)
        }
        return items
    }
}

extension ListV2LoggingLevelsInput {

    static func urlPathProvider(_ value: ListV2LoggingLevelsInput) -> Swift.String? {
        return "/v2LoggingLevel"
    }
}

extension ListV2LoggingLevelsInput {

    static func queryItemProvider(_ value: ListV2LoggingLevelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let targetType = value.targetType {
            let targetTypeQueryItem = Smithy.URIQueryItem(name: "targetType".urlPercentEncoding(), value: Swift.String(targetType.rawValue).urlPercentEncoding())
            items.append(targetTypeQueryItem)
        }
        return items
    }
}

extension ListViolationEventsInput {

    static func urlPathProvider(_ value: ListViolationEventsInput) -> Swift.String? {
        return "/violation-events"
    }
}

extension ListViolationEventsInput {

    static func queryItemProvider(_ value: ListViolationEventsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let securityProfileName = value.securityProfileName {
            let securityProfileNameQueryItem = Smithy.URIQueryItem(name: "securityProfileName".urlPercentEncoding(), value: Swift.String(securityProfileName).urlPercentEncoding())
            items.append(securityProfileNameQueryItem)
        }
        if let listSuppressedAlerts = value.listSuppressedAlerts {
            let listSuppressedAlertsQueryItem = Smithy.URIQueryItem(name: "listSuppressedAlerts".urlPercentEncoding(), value: Swift.String(listSuppressedAlerts).urlPercentEncoding())
            items.append(listSuppressedAlertsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let behaviorCriteriaType = value.behaviorCriteriaType {
            let behaviorCriteriaTypeQueryItem = Smithy.URIQueryItem(name: "behaviorCriteriaType".urlPercentEncoding(), value: Swift.String(behaviorCriteriaType.rawValue).urlPercentEncoding())
            items.append(behaviorCriteriaTypeQueryItem)
        }
        if let thingName = value.thingName {
            let thingNameQueryItem = Smithy.URIQueryItem(name: "thingName".urlPercentEncoding(), value: Swift.String(thingName).urlPercentEncoding())
            items.append(thingNameQueryItem)
        }
        guard let startTime = value.startTime else {
            let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startTimeQueryItem = Smithy.URIQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
        items.append(startTimeQueryItem)
        guard let endTime = value.endTime else {
            let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endTimeQueryItem = Smithy.URIQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
        items.append(endTimeQueryItem)
        if let verificationState = value.verificationState {
            let verificationStateQueryItem = Smithy.URIQueryItem(name: "verificationState".urlPercentEncoding(), value: Swift.String(verificationState.rawValue).urlPercentEncoding())
            items.append(verificationStateQueryItem)
        }
        return items
    }
}

extension PutVerificationStateOnViolationInput {

    static func urlPathProvider(_ value: PutVerificationStateOnViolationInput) -> Swift.String? {
        guard let violationId = value.violationId else {
            return nil
        }
        return "/violations/verification-state/\(violationId.urlPercentEncoding())"
    }
}

extension RegisterCACertificateInput {

    static func urlPathProvider(_ value: RegisterCACertificateInput) -> Swift.String? {
        return "/cacertificate"
    }
}

extension RegisterCACertificateInput {

    static func queryItemProvider(_ value: RegisterCACertificateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let allowAutoRegistration = value.allowAutoRegistration {
            let allowAutoRegistrationQueryItem = Smithy.URIQueryItem(name: "allowAutoRegistration".urlPercentEncoding(), value: Swift.String(allowAutoRegistration).urlPercentEncoding())
            items.append(allowAutoRegistrationQueryItem)
        }
        if let setAsActive = value.setAsActive {
            let setAsActiveQueryItem = Smithy.URIQueryItem(name: "setAsActive".urlPercentEncoding(), value: Swift.String(setAsActive).urlPercentEncoding())
            items.append(setAsActiveQueryItem)
        }
        return items
    }
}

extension RegisterCertificateInput {

    static func urlPathProvider(_ value: RegisterCertificateInput) -> Swift.String? {
        return "/certificate/register"
    }
}

extension RegisterCertificateInput {

    static func queryItemProvider(_ value: RegisterCertificateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let setAsActive = value.setAsActive {
            let setAsActiveQueryItem = Smithy.URIQueryItem(name: "setAsActive".urlPercentEncoding(), value: Swift.String(setAsActive).urlPercentEncoding())
            items.append(setAsActiveQueryItem)
        }
        return items
    }
}

extension RegisterCertificateWithoutCAInput {

    static func urlPathProvider(_ value: RegisterCertificateWithoutCAInput) -> Swift.String? {
        return "/certificate/register-no-ca"
    }
}

extension RegisterThingInput {

    static func urlPathProvider(_ value: RegisterThingInput) -> Swift.String? {
        return "/things"
    }
}

extension RejectCertificateTransferInput {

    static func urlPathProvider(_ value: RejectCertificateTransferInput) -> Swift.String? {
        guard let certificateId = value.certificateId else {
            return nil
        }
        return "/reject-certificate-transfer/\(certificateId.urlPercentEncoding())"
    }
}

extension RemoveThingFromBillingGroupInput {

    static func urlPathProvider(_ value: RemoveThingFromBillingGroupInput) -> Swift.String? {
        return "/billing-groups/removeThingFromBillingGroup"
    }
}

extension RemoveThingFromThingGroupInput {

    static func urlPathProvider(_ value: RemoveThingFromThingGroupInput) -> Swift.String? {
        return "/thing-groups/removeThingFromThingGroup"
    }
}

extension ReplaceTopicRuleInput {

    static func urlPathProvider(_ value: ReplaceTopicRuleInput) -> Swift.String? {
        guard let ruleName = value.ruleName else {
            return nil
        }
        return "/rules/\(ruleName.urlPercentEncoding())"
    }
}

extension SearchIndexInput {

    static func urlPathProvider(_ value: SearchIndexInput) -> Swift.String? {
        return "/indices/search"
    }
}

extension SetDefaultAuthorizerInput {

    static func urlPathProvider(_ value: SetDefaultAuthorizerInput) -> Swift.String? {
        return "/default-authorizer"
    }
}

extension SetDefaultPolicyVersionInput {

    static func urlPathProvider(_ value: SetDefaultPolicyVersionInput) -> Swift.String? {
        guard let policyName = value.policyName else {
            return nil
        }
        guard let policyVersionId = value.policyVersionId else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())/version/\(policyVersionId.urlPercentEncoding())"
    }
}

extension SetLoggingOptionsInput {

    static func urlPathProvider(_ value: SetLoggingOptionsInput) -> Swift.String? {
        return "/loggingOptions"
    }
}

extension SetV2LoggingLevelInput {

    static func urlPathProvider(_ value: SetV2LoggingLevelInput) -> Swift.String? {
        return "/v2LoggingLevel"
    }
}

extension SetV2LoggingOptionsInput {

    static func urlPathProvider(_ value: SetV2LoggingOptionsInput) -> Swift.String? {
        return "/v2LoggingOptions"
    }
}

extension StartAuditMitigationActionsTaskInput {

    static func urlPathProvider(_ value: StartAuditMitigationActionsTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/audit/mitigationactions/tasks/\(taskId.urlPercentEncoding())"
    }
}

extension StartDetectMitigationActionsTaskInput {

    static func urlPathProvider(_ value: StartDetectMitigationActionsTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/detect/mitigationactions/tasks/\(taskId.urlPercentEncoding())"
    }
}

extension StartOnDemandAuditTaskInput {

    static func urlPathProvider(_ value: StartOnDemandAuditTaskInput) -> Swift.String? {
        return "/audit/tasks"
    }
}

extension StartThingRegistrationTaskInput {

    static func urlPathProvider(_ value: StartThingRegistrationTaskInput) -> Swift.String? {
        return "/thing-registration-tasks"
    }
}

extension StopThingRegistrationTaskInput {

    static func urlPathProvider(_ value: StopThingRegistrationTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/thing-registration-tasks/\(taskId.urlPercentEncoding())/cancel"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension TestAuthorizationInput {

    static func urlPathProvider(_ value: TestAuthorizationInput) -> Swift.String? {
        return "/test-authorization"
    }
}

extension TestAuthorizationInput {

    static func queryItemProvider(_ value: TestAuthorizationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientId = value.clientId {
            let clientIdQueryItem = Smithy.URIQueryItem(name: "clientId".urlPercentEncoding(), value: Swift.String(clientId).urlPercentEncoding())
            items.append(clientIdQueryItem)
        }
        return items
    }
}

extension TestInvokeAuthorizerInput {

    static func urlPathProvider(_ value: TestInvokeAuthorizerInput) -> Swift.String? {
        guard let authorizerName = value.authorizerName else {
            return nil
        }
        return "/authorizer/\(authorizerName.urlPercentEncoding())/test"
    }
}

extension TransferCertificateInput {

    static func urlPathProvider(_ value: TransferCertificateInput) -> Swift.String? {
        guard let certificateId = value.certificateId else {
            return nil
        }
        return "/transfer-certificate/\(certificateId.urlPercentEncoding())"
    }
}

extension TransferCertificateInput {

    static func queryItemProvider(_ value: TransferCertificateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let targetAwsAccount = value.targetAwsAccount else {
            let message = "Creating a URL Query Item failed. targetAwsAccount is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let targetAwsAccountQueryItem = Smithy.URIQueryItem(name: "targetAwsAccount".urlPercentEncoding(), value: Swift.String(targetAwsAccount).urlPercentEncoding())
        items.append(targetAwsAccountQueryItem)
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/untag"
    }
}

extension UpdateAccountAuditConfigurationInput {

    static func urlPathProvider(_ value: UpdateAccountAuditConfigurationInput) -> Swift.String? {
        return "/audit/configuration"
    }
}

extension UpdateAuditSuppressionInput {

    static func urlPathProvider(_ value: UpdateAuditSuppressionInput) -> Swift.String? {
        return "/audit/suppressions/update"
    }
}

extension UpdateAuthorizerInput {

    static func urlPathProvider(_ value: UpdateAuthorizerInput) -> Swift.String? {
        guard let authorizerName = value.authorizerName else {
            return nil
        }
        return "/authorizer/\(authorizerName.urlPercentEncoding())"
    }
}

extension UpdateBillingGroupInput {

    static func urlPathProvider(_ value: UpdateBillingGroupInput) -> Swift.String? {
        guard let billingGroupName = value.billingGroupName else {
            return nil
        }
        return "/billing-groups/\(billingGroupName.urlPercentEncoding())"
    }
}

extension UpdateCACertificateInput {

    static func urlPathProvider(_ value: UpdateCACertificateInput) -> Swift.String? {
        guard let certificateId = value.certificateId else {
            return nil
        }
        return "/cacertificate/\(certificateId.urlPercentEncoding())"
    }
}

extension UpdateCACertificateInput {

    static func queryItemProvider(_ value: UpdateCACertificateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let newAutoRegistrationStatus = value.newAutoRegistrationStatus {
            let newAutoRegistrationStatusQueryItem = Smithy.URIQueryItem(name: "newAutoRegistrationStatus".urlPercentEncoding(), value: Swift.String(newAutoRegistrationStatus.rawValue).urlPercentEncoding())
            items.append(newAutoRegistrationStatusQueryItem)
        }
        if let newStatus = value.newStatus {
            let newStatusQueryItem = Smithy.URIQueryItem(name: "newStatus".urlPercentEncoding(), value: Swift.String(newStatus.rawValue).urlPercentEncoding())
            items.append(newStatusQueryItem)
        }
        return items
    }
}

extension UpdateCertificateInput {

    static func urlPathProvider(_ value: UpdateCertificateInput) -> Swift.String? {
        guard let certificateId = value.certificateId else {
            return nil
        }
        return "/certificates/\(certificateId.urlPercentEncoding())"
    }
}

extension UpdateCertificateInput {

    static func queryItemProvider(_ value: UpdateCertificateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let newStatus = value.newStatus else {
            let message = "Creating a URL Query Item failed. newStatus is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let newStatusQueryItem = Smithy.URIQueryItem(name: "newStatus".urlPercentEncoding(), value: Swift.String(newStatus.rawValue).urlPercentEncoding())
        items.append(newStatusQueryItem)
        return items
    }
}

extension UpdateCertificateProviderInput {

    static func urlPathProvider(_ value: UpdateCertificateProviderInput) -> Swift.String? {
        guard let certificateProviderName = value.certificateProviderName else {
            return nil
        }
        return "/certificate-providers/\(certificateProviderName.urlPercentEncoding())"
    }
}

extension UpdateCustomMetricInput {

    static func urlPathProvider(_ value: UpdateCustomMetricInput) -> Swift.String? {
        guard let metricName = value.metricName else {
            return nil
        }
        return "/custom-metric/\(metricName.urlPercentEncoding())"
    }
}

extension UpdateDimensionInput {

    static func urlPathProvider(_ value: UpdateDimensionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/dimensions/\(name.urlPercentEncoding())"
    }
}

extension UpdateDomainConfigurationInput {

    static func urlPathProvider(_ value: UpdateDomainConfigurationInput) -> Swift.String? {
        guard let domainConfigurationName = value.domainConfigurationName else {
            return nil
        }
        return "/domainConfigurations/\(domainConfigurationName.urlPercentEncoding())"
    }
}

extension UpdateDynamicThingGroupInput {

    static func urlPathProvider(_ value: UpdateDynamicThingGroupInput) -> Swift.String? {
        guard let thingGroupName = value.thingGroupName else {
            return nil
        }
        return "/dynamic-thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

extension UpdateEventConfigurationsInput {

    static func urlPathProvider(_ value: UpdateEventConfigurationsInput) -> Swift.String? {
        return "/event-configurations"
    }
}

extension UpdateFleetMetricInput {

    static func urlPathProvider(_ value: UpdateFleetMetricInput) -> Swift.String? {
        guard let metricName = value.metricName else {
            return nil
        }
        return "/fleet-metric/\(metricName.urlPercentEncoding())"
    }
}

extension UpdateIndexingConfigurationInput {

    static func urlPathProvider(_ value: UpdateIndexingConfigurationInput) -> Swift.String? {
        return "/indexing/config"
    }
}

extension UpdateJobInput {

    static func urlPathProvider(_ value: UpdateJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

extension UpdateJobInput {

    static func queryItemProvider(_ value: UpdateJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let namespaceId = value.namespaceId {
            let namespaceIdQueryItem = Smithy.URIQueryItem(name: "namespaceId".urlPercentEncoding(), value: Swift.String(namespaceId).urlPercentEncoding())
            items.append(namespaceIdQueryItem)
        }
        return items
    }
}

extension UpdateMitigationActionInput {

    static func urlPathProvider(_ value: UpdateMitigationActionInput) -> Swift.String? {
        guard let actionName = value.actionName else {
            return nil
        }
        return "/mitigationactions/actions/\(actionName.urlPercentEncoding())"
    }
}

extension UpdatePackageInput {

    static func urlPathProvider(_ value: UpdatePackageInput) -> Swift.String? {
        guard let packageName = value.packageName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())"
    }
}

extension UpdatePackageInput {

    static func queryItemProvider(_ value: UpdatePackageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension UpdatePackageConfigurationInput {

    static func urlPathProvider(_ value: UpdatePackageConfigurationInput) -> Swift.String? {
        return "/package-configuration"
    }
}

extension UpdatePackageConfigurationInput {

    static func queryItemProvider(_ value: UpdatePackageConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension UpdatePackageVersionInput {

    static func urlPathProvider(_ value: UpdatePackageVersionInput) -> Swift.String? {
        guard let packageName = value.packageName else {
            return nil
        }
        guard let versionName = value.versionName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())/versions/\(versionName.urlPercentEncoding())"
    }
}

extension UpdatePackageVersionInput {

    static func queryItemProvider(_ value: UpdatePackageVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension UpdateProvisioningTemplateInput {

    static func urlPathProvider(_ value: UpdateProvisioningTemplateInput) -> Swift.String? {
        guard let templateName = value.templateName else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())"
    }
}

extension UpdateRoleAliasInput {

    static func urlPathProvider(_ value: UpdateRoleAliasInput) -> Swift.String? {
        guard let roleAlias = value.roleAlias else {
            return nil
        }
        return "/role-aliases/\(roleAlias.urlPercentEncoding())"
    }
}

extension UpdateScheduledAuditInput {

    static func urlPathProvider(_ value: UpdateScheduledAuditInput) -> Swift.String? {
        guard let scheduledAuditName = value.scheduledAuditName else {
            return nil
        }
        return "/audit/scheduledaudits/\(scheduledAuditName.urlPercentEncoding())"
    }
}

extension UpdateSecurityProfileInput {

    static func urlPathProvider(_ value: UpdateSecurityProfileInput) -> Swift.String? {
        guard let securityProfileName = value.securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())"
    }
}

extension UpdateSecurityProfileInput {

    static func queryItemProvider(_ value: UpdateSecurityProfileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let expectedVersion = value.expectedVersion {
            let expectedVersionQueryItem = Smithy.URIQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
            items.append(expectedVersionQueryItem)
        }
        return items
    }
}

extension UpdateStreamInput {

    static func urlPathProvider(_ value: UpdateStreamInput) -> Swift.String? {
        guard let streamId = value.streamId else {
            return nil
        }
        return "/streams/\(streamId.urlPercentEncoding())"
    }
}

extension UpdateThingInput {

    static func urlPathProvider(_ value: UpdateThingInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())"
    }
}

extension UpdateThingGroupInput {

    static func urlPathProvider(_ value: UpdateThingGroupInput) -> Swift.String? {
        guard let thingGroupName = value.thingGroupName else {
            return nil
        }
        return "/thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

extension UpdateThingGroupsForThingInput {

    static func urlPathProvider(_ value: UpdateThingGroupsForThingInput) -> Swift.String? {
        return "/thing-groups/updateThingGroupsForThing"
    }
}

extension UpdateTopicRuleDestinationInput {

    static func urlPathProvider(_ value: UpdateTopicRuleDestinationInput) -> Swift.String? {
        return "/destinations"
    }
}

extension ValidateSecurityProfileBehaviorsInput {

    static func urlPathProvider(_ value: ValidateSecurityProfileBehaviorsInput) -> Swift.String? {
        return "/security-profile-behaviors/validate"
    }
}

extension AddThingToBillingGroupInput {

    static func write(value: AddThingToBillingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billingGroupArn"].write(value.billingGroupArn)
        try writer["billingGroupName"].write(value.billingGroupName)
        try writer["thingArn"].write(value.thingArn)
        try writer["thingName"].write(value.thingName)
    }
}

extension AddThingToThingGroupInput {

    static func write(value: AddThingToThingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["overrideDynamicGroups"].write(value.overrideDynamicGroups)
        try writer["thingArn"].write(value.thingArn)
        try writer["thingGroupArn"].write(value.thingGroupArn)
        try writer["thingGroupName"].write(value.thingGroupName)
        try writer["thingName"].write(value.thingName)
    }
}

extension AssociateSbomWithPackageVersionInput {

    static func write(value: AssociateSbomWithPackageVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sbom"].write(value.sbom, with: IoTClientTypes.Sbom.write(value:to:))
    }
}

extension AssociateTargetsWithJobInput {

    static func write(value: AssociateTargetsWithJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comment"].write(value.comment)
        try writer["targets"].writeList(value.targets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AttachPolicyInput {

    static func write(value: AttachPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["target"].write(value.target)
    }
}

extension CancelJobInput {

    static func write(value: CancelJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comment"].write(value.comment)
        try writer["reasonCode"].write(value.reasonCode)
    }
}

extension CancelJobExecutionInput {

    static func write(value: CancelJobExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expectedVersion"].write(value.expectedVersion)
        try writer["statusDetails"].writeMap(value.statusDetails, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateAuditSuppressionInput {

    static func write(value: CreateAuditSuppressionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["checkName"].write(value.checkName)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["description"].write(value.description)
        try writer["expirationDate"].writeTimestamp(value.expirationDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["resourceIdentifier"].write(value.resourceIdentifier, with: IoTClientTypes.ResourceIdentifier.write(value:to:))
        try writer["suppressIndefinitely"].write(value.suppressIndefinitely)
    }
}

extension CreateAuthorizerInput {

    static func write(value: CreateAuthorizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizerFunctionArn"].write(value.authorizerFunctionArn)
        try writer["enableCachingForHttp"].write(value.enableCachingForHttp)
        try writer["signingDisabled"].write(value.signingDisabled)
        try writer["status"].write(value.status)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tokenKeyName"].write(value.tokenKeyName)
        try writer["tokenSigningPublicKeys"].writeMap(value.tokenSigningPublicKeys, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateBillingGroupInput {

    static func write(value: CreateBillingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billingGroupProperties"].write(value.billingGroupProperties, with: IoTClientTypes.BillingGroupProperties.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCertificateFromCsrInput {

    static func write(value: CreateCertificateFromCsrInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateSigningRequest"].write(value.certificateSigningRequest)
    }
}

extension CreateCertificateProviderInput {

    static func write(value: CreateCertificateProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountDefaultForOperations"].writeList(value.accountDefaultForOperations, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IoTClientTypes.CertificateProviderOperation>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["lambdaFunctionArn"].write(value.lambdaFunctionArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCustomMetricInput {

    static func write(value: CreateCustomMetricInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["displayName"].write(value.displayName)
        try writer["metricType"].write(value.metricType)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDimensionInput {

    static func write(value: CreateDimensionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["stringValues"].writeList(value.stringValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreateDomainConfigurationInput {

    static func write(value: CreateDomainConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizerConfig"].write(value.authorizerConfig, with: IoTClientTypes.AuthorizerConfig.write(value:to:))
        try writer["domainName"].write(value.domainName)
        try writer["serverCertificateArns"].writeList(value.serverCertificateArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["serverCertificateConfig"].write(value.serverCertificateConfig, with: IoTClientTypes.ServerCertificateConfig.write(value:to:))
        try writer["serviceType"].write(value.serviceType)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tlsConfig"].write(value.tlsConfig, with: IoTClientTypes.TlsConfig.write(value:to:))
        try writer["validationCertificateArn"].write(value.validationCertificateArn)
    }
}

extension CreateDynamicThingGroupInput {

    static func write(value: CreateDynamicThingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["indexName"].write(value.indexName)
        try writer["queryString"].write(value.queryString)
        try writer["queryVersion"].write(value.queryVersion)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["thingGroupProperties"].write(value.thingGroupProperties, with: IoTClientTypes.ThingGroupProperties.write(value:to:))
    }
}

extension CreateFleetMetricInput {

    static func write(value: CreateFleetMetricInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregationField"].write(value.aggregationField)
        try writer["aggregationType"].write(value.aggregationType, with: IoTClientTypes.AggregationType.write(value:to:))
        try writer["description"].write(value.description)
        try writer["indexName"].write(value.indexName)
        try writer["period"].write(value.period)
        try writer["queryString"].write(value.queryString)
        try writer["queryVersion"].write(value.queryVersion)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["unit"].write(value.unit)
    }
}

extension CreateJobInput {

    static func write(value: CreateJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["abortConfig"].write(value.abortConfig, with: IoTClientTypes.AbortConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["destinationPackageVersions"].writeList(value.destinationPackageVersions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["document"].write(value.document)
        try writer["documentParameters"].writeMap(value.documentParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["documentSource"].write(value.documentSource)
        try writer["jobExecutionsRetryConfig"].write(value.jobExecutionsRetryConfig, with: IoTClientTypes.JobExecutionsRetryConfig.write(value:to:))
        try writer["jobExecutionsRolloutConfig"].write(value.jobExecutionsRolloutConfig, with: IoTClientTypes.JobExecutionsRolloutConfig.write(value:to:))
        try writer["jobTemplateArn"].write(value.jobTemplateArn)
        try writer["namespaceId"].write(value.namespaceId)
        try writer["presignedUrlConfig"].write(value.presignedUrlConfig, with: IoTClientTypes.PresignedUrlConfig.write(value:to:))
        try writer["schedulingConfig"].write(value.schedulingConfig, with: IoTClientTypes.SchedulingConfig.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetSelection"].write(value.targetSelection)
        try writer["targets"].writeList(value.targets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timeoutConfig"].write(value.timeoutConfig, with: IoTClientTypes.TimeoutConfig.write(value:to:))
    }
}

extension CreateJobTemplateInput {

    static func write(value: CreateJobTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["abortConfig"].write(value.abortConfig, with: IoTClientTypes.AbortConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["destinationPackageVersions"].writeList(value.destinationPackageVersions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["document"].write(value.document)
        try writer["documentSource"].write(value.documentSource)
        try writer["jobArn"].write(value.jobArn)
        try writer["jobExecutionsRetryConfig"].write(value.jobExecutionsRetryConfig, with: IoTClientTypes.JobExecutionsRetryConfig.write(value:to:))
        try writer["jobExecutionsRolloutConfig"].write(value.jobExecutionsRolloutConfig, with: IoTClientTypes.JobExecutionsRolloutConfig.write(value:to:))
        try writer["maintenanceWindows"].writeList(value.maintenanceWindows, memberWritingClosure: IoTClientTypes.MaintenanceWindow.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["presignedUrlConfig"].write(value.presignedUrlConfig, with: IoTClientTypes.PresignedUrlConfig.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timeoutConfig"].write(value.timeoutConfig, with: IoTClientTypes.TimeoutConfig.write(value:to:))
    }
}

extension CreateMitigationActionInput {

    static func write(value: CreateMitigationActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionParams"].write(value.actionParams, with: IoTClientTypes.MitigationActionParams.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateOTAUpdateInput {

    static func write(value: CreateOTAUpdateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalParameters"].writeMap(value.additionalParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["awsJobAbortConfig"].write(value.awsJobAbortConfig, with: IoTClientTypes.AwsJobAbortConfig.write(value:to:))
        try writer["awsJobExecutionsRolloutConfig"].write(value.awsJobExecutionsRolloutConfig, with: IoTClientTypes.AwsJobExecutionsRolloutConfig.write(value:to:))
        try writer["awsJobPresignedUrlConfig"].write(value.awsJobPresignedUrlConfig, with: IoTClientTypes.AwsJobPresignedUrlConfig.write(value:to:))
        try writer["awsJobTimeoutConfig"].write(value.awsJobTimeoutConfig, with: IoTClientTypes.AwsJobTimeoutConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["files"].writeList(value.files, memberWritingClosure: IoTClientTypes.OTAUpdateFile.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["protocols"].writeList(value.protocols, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IoTClientTypes.ModelProtocol>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetSelection"].write(value.targetSelection)
        try writer["targets"].writeList(value.targets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreatePackageInput {

    static func write(value: CreatePackageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreatePackageVersionInput {

    static func write(value: CreatePackageVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["artifact"].write(value.artifact, with: IoTClientTypes.PackageVersionArtifact.write(value:to:))
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["recipe"].write(value.recipe)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreatePolicyInput {

    static func write(value: CreatePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyDocument"].write(value.policyDocument)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreatePolicyVersionInput {

    static func write(value: CreatePolicyVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyDocument"].write(value.policyDocument)
    }
}

extension CreateProvisioningTemplateInput {

    static func write(value: CreateProvisioningTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["enabled"].write(value.enabled)
        try writer["preProvisioningHook"].write(value.preProvisioningHook, with: IoTClientTypes.ProvisioningHook.write(value:to:))
        try writer["provisioningRoleArn"].write(value.provisioningRoleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["templateBody"].write(value.templateBody)
        try writer["templateName"].write(value.templateName)
        try writer["type"].write(value.type)
    }
}

extension CreateProvisioningTemplateVersionInput {

    static func write(value: CreateProvisioningTemplateVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["templateBody"].write(value.templateBody)
    }
}

extension CreateRoleAliasInput {

    static func write(value: CreateRoleAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credentialDurationSeconds"].write(value.credentialDurationSeconds)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateScheduledAuditInput {

    static func write(value: CreateScheduledAuditInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dayOfMonth"].write(value.dayOfMonth)
        try writer["dayOfWeek"].write(value.dayOfWeek)
        try writer["frequency"].write(value.frequency)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetCheckNames"].writeList(value.targetCheckNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSecurityProfileInput {

    static func write(value: CreateSecurityProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalMetricsToRetain"].writeList(value.additionalMetricsToRetain, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["additionalMetricsToRetainV2"].writeList(value.additionalMetricsToRetainV2, memberWritingClosure: IoTClientTypes.MetricToRetain.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["alertTargets"].writeMap(value.alertTargets, valueWritingClosure: IoTClientTypes.AlertTarget.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["behaviors"].writeList(value.behaviors, memberWritingClosure: IoTClientTypes.Behavior.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["metricsExportConfig"].write(value.metricsExportConfig, with: IoTClientTypes.MetricsExportConfig.write(value:to:))
        try writer["securityProfileDescription"].write(value.securityProfileDescription)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateStreamInput {

    static func write(value: CreateStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["files"].writeList(value.files, memberWritingClosure: IoTClientTypes.StreamFile.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateThingInput {

    static func write(value: CreateThingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributePayload"].write(value.attributePayload, with: IoTClientTypes.AttributePayload.write(value:to:))
        try writer["billingGroupName"].write(value.billingGroupName)
        try writer["thingTypeName"].write(value.thingTypeName)
    }
}

extension CreateThingGroupInput {

    static func write(value: CreateThingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["parentGroupName"].write(value.parentGroupName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["thingGroupProperties"].write(value.thingGroupProperties, with: IoTClientTypes.ThingGroupProperties.write(value:to:))
    }
}

extension CreateThingTypeInput {

    static func write(value: CreateThingTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["thingTypeProperties"].write(value.thingTypeProperties, with: IoTClientTypes.ThingTypeProperties.write(value:to:))
    }
}

extension CreateTopicRuleInput {

    static func write(value: CreateTopicRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["topicRulePayload"].write(value.topicRulePayload, with: IoTClientTypes.TopicRulePayload.write(value:to:))
    }
}

extension CreateTopicRuleDestinationInput {

    static func write(value: CreateTopicRuleDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationConfiguration"].write(value.destinationConfiguration, with: IoTClientTypes.TopicRuleDestinationConfiguration.write(value:to:))
    }
}

extension DeleteAuditSuppressionInput {

    static func write(value: DeleteAuditSuppressionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["checkName"].write(value.checkName)
        try writer["resourceIdentifier"].write(value.resourceIdentifier, with: IoTClientTypes.ResourceIdentifier.write(value:to:))
    }
}

extension DeprecateThingTypeInput {

    static func write(value: DeprecateThingTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["undoDeprecate"].write(value.undoDeprecate)
    }
}

extension DescribeAuditSuppressionInput {

    static func write(value: DescribeAuditSuppressionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["checkName"].write(value.checkName)
        try writer["resourceIdentifier"].write(value.resourceIdentifier, with: IoTClientTypes.ResourceIdentifier.write(value:to:))
    }
}

extension DetachPolicyInput {

    static func write(value: DetachPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["target"].write(value.target)
    }
}

extension GetBucketsAggregationInput {

    static func write(value: GetBucketsAggregationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregationField"].write(value.aggregationField)
        try writer["bucketsAggregationType"].write(value.bucketsAggregationType, with: IoTClientTypes.BucketsAggregationType.write(value:to:))
        try writer["indexName"].write(value.indexName)
        try writer["queryString"].write(value.queryString)
        try writer["queryVersion"].write(value.queryVersion)
    }
}

extension GetCardinalityInput {

    static func write(value: GetCardinalityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregationField"].write(value.aggregationField)
        try writer["indexName"].write(value.indexName)
        try writer["queryString"].write(value.queryString)
        try writer["queryVersion"].write(value.queryVersion)
    }
}

extension GetEffectivePoliciesInput {

    static func write(value: GetEffectivePoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cognitoIdentityPoolId"].write(value.cognitoIdentityPoolId)
        try writer["principal"].write(value.principal)
    }
}

extension GetPercentilesInput {

    static func write(value: GetPercentilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregationField"].write(value.aggregationField)
        try writer["indexName"].write(value.indexName)
        try writer["percents"].writeList(value.percents, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["queryString"].write(value.queryString)
        try writer["queryVersion"].write(value.queryVersion)
    }
}

extension GetStatisticsInput {

    static func write(value: GetStatisticsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregationField"].write(value.aggregationField)
        try writer["indexName"].write(value.indexName)
        try writer["queryString"].write(value.queryString)
        try writer["queryVersion"].write(value.queryVersion)
    }
}

extension ListAuditFindingsInput {

    static func write(value: ListAuditFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["checkName"].write(value.checkName)
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["listSuppressedFindings"].write(value.listSuppressedFindings)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["resourceIdentifier"].write(value.resourceIdentifier, with: IoTClientTypes.ResourceIdentifier.write(value:to:))
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["taskId"].write(value.taskId)
    }
}

extension ListAuditSuppressionsInput {

    static func write(value: ListAuditSuppressionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ascendingOrder"].write(value.ascendingOrder)
        try writer["checkName"].write(value.checkName)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["resourceIdentifier"].write(value.resourceIdentifier, with: IoTClientTypes.ResourceIdentifier.write(value:to:))
    }
}

extension PutVerificationStateOnViolationInput {

    static func write(value: PutVerificationStateOnViolationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["verificationState"].write(value.verificationState)
        try writer["verificationStateDescription"].write(value.verificationStateDescription)
    }
}

extension RegisterCACertificateInput {

    static func write(value: RegisterCACertificateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["caCertificate"].write(value.caCertificate)
        try writer["certificateMode"].write(value.certificateMode)
        try writer["registrationConfig"].write(value.registrationConfig, with: IoTClientTypes.RegistrationConfig.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["verificationCertificate"].write(value.verificationCertificate)
    }
}

extension RegisterCertificateInput {

    static func write(value: RegisterCertificateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["caCertificatePem"].write(value.caCertificatePem)
        try writer["certificatePem"].write(value.certificatePem)
        try writer["status"].write(value.status)
    }
}

extension RegisterCertificateWithoutCAInput {

    static func write(value: RegisterCertificateWithoutCAInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificatePem"].write(value.certificatePem)
        try writer["status"].write(value.status)
    }
}

extension RegisterThingInput {

    static func write(value: RegisterThingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["templateBody"].write(value.templateBody)
    }
}

extension RejectCertificateTransferInput {

    static func write(value: RejectCertificateTransferInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rejectReason"].write(value.rejectReason)
    }
}

extension RemoveThingFromBillingGroupInput {

    static func write(value: RemoveThingFromBillingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billingGroupArn"].write(value.billingGroupArn)
        try writer["billingGroupName"].write(value.billingGroupName)
        try writer["thingArn"].write(value.thingArn)
        try writer["thingName"].write(value.thingName)
    }
}

extension RemoveThingFromThingGroupInput {

    static func write(value: RemoveThingFromThingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["thingArn"].write(value.thingArn)
        try writer["thingGroupArn"].write(value.thingGroupArn)
        try writer["thingGroupName"].write(value.thingGroupName)
        try writer["thingName"].write(value.thingName)
    }
}

extension ReplaceTopicRuleInput {

    static func write(value: ReplaceTopicRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["topicRulePayload"].write(value.topicRulePayload, with: IoTClientTypes.TopicRulePayload.write(value:to:))
    }
}

extension SearchIndexInput {

    static func write(value: SearchIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["indexName"].write(value.indexName)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["queryString"].write(value.queryString)
        try writer["queryVersion"].write(value.queryVersion)
    }
}

extension SetDefaultAuthorizerInput {

    static func write(value: SetDefaultAuthorizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizerName"].write(value.authorizerName)
    }
}

extension SetLoggingOptionsInput {

    static func write(value: SetLoggingOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["loggingOptionsPayload"].write(value.loggingOptionsPayload, with: IoTClientTypes.LoggingOptionsPayload.write(value:to:))
    }
}

extension SetV2LoggingLevelInput {

    static func write(value: SetV2LoggingLevelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logLevel"].write(value.logLevel)
        try writer["logTarget"].write(value.logTarget, with: IoTClientTypes.LogTarget.write(value:to:))
    }
}

extension SetV2LoggingOptionsInput {

    static func write(value: SetV2LoggingOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultLogLevel"].write(value.defaultLogLevel)
        try writer["disableAllLogs"].write(value.disableAllLogs)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension StartAuditMitigationActionsTaskInput {

    static func write(value: StartAuditMitigationActionsTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["auditCheckToActionsMapping"].writeMap(value.auditCheckToActionsMapping, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["target"].write(value.target, with: IoTClientTypes.AuditMitigationActionsTaskTarget.write(value:to:))
    }
}

extension StartDetectMitigationActionsTaskInput {

    static func write(value: StartDetectMitigationActionsTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["includeOnlyActiveViolations"].write(value.includeOnlyActiveViolations)
        try writer["includeSuppressedAlerts"].write(value.includeSuppressedAlerts)
        try writer["target"].write(value.target, with: IoTClientTypes.DetectMitigationActionsTaskTarget.write(value:to:))
        try writer["violationEventOccurrenceRange"].write(value.violationEventOccurrenceRange, with: IoTClientTypes.ViolationEventOccurrenceRange.write(value:to:))
    }
}

extension StartOnDemandAuditTaskInput {

    static func write(value: StartOnDemandAuditTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetCheckNames"].writeList(value.targetCheckNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartThingRegistrationTaskInput {

    static func write(value: StartThingRegistrationTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputFileBucket"].write(value.inputFileBucket)
        try writer["inputFileKey"].write(value.inputFileKey)
        try writer["roleArn"].write(value.roleArn)
        try writer["templateBody"].write(value.templateBody)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TestAuthorizationInput {

    static func write(value: TestAuthorizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authInfos"].writeList(value.authInfos, memberWritingClosure: IoTClientTypes.AuthInfo.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["cognitoIdentityPoolId"].write(value.cognitoIdentityPoolId)
        try writer["policyNamesToAdd"].writeList(value.policyNamesToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["policyNamesToSkip"].writeList(value.policyNamesToSkip, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["principal"].write(value.principal)
    }
}

extension TestInvokeAuthorizerInput {

    static func write(value: TestInvokeAuthorizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["httpContext"].write(value.httpContext, with: IoTClientTypes.HttpContext.write(value:to:))
        try writer["mqttContext"].write(value.mqttContext, with: IoTClientTypes.MqttContext.write(value:to:))
        try writer["tlsContext"].write(value.tlsContext, with: IoTClientTypes.TlsContext.write(value:to:))
        try writer["token"].write(value.token)
        try writer["tokenSignature"].write(value.tokenSignature)
    }
}

extension TransferCertificateInput {

    static func write(value: TransferCertificateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["transferMessage"].write(value.transferMessage)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAccountAuditConfigurationInput {

    static func write(value: UpdateAccountAuditConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["auditCheckConfigurations"].writeMap(value.auditCheckConfigurations, valueWritingClosure: IoTClientTypes.AuditCheckConfiguration.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["auditNotificationTargetConfigurations"].writeMap(value.auditNotificationTargetConfigurations, valueWritingClosure: IoTClientTypes.AuditNotificationTarget.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateAuditSuppressionInput {

    static func write(value: UpdateAuditSuppressionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["checkName"].write(value.checkName)
        try writer["description"].write(value.description)
        try writer["expirationDate"].writeTimestamp(value.expirationDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["resourceIdentifier"].write(value.resourceIdentifier, with: IoTClientTypes.ResourceIdentifier.write(value:to:))
        try writer["suppressIndefinitely"].write(value.suppressIndefinitely)
    }
}

extension UpdateAuthorizerInput {

    static func write(value: UpdateAuthorizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizerFunctionArn"].write(value.authorizerFunctionArn)
        try writer["enableCachingForHttp"].write(value.enableCachingForHttp)
        try writer["status"].write(value.status)
        try writer["tokenKeyName"].write(value.tokenKeyName)
        try writer["tokenSigningPublicKeys"].writeMap(value.tokenSigningPublicKeys, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateBillingGroupInput {

    static func write(value: UpdateBillingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billingGroupProperties"].write(value.billingGroupProperties, with: IoTClientTypes.BillingGroupProperties.write(value:to:))
        try writer["expectedVersion"].write(value.expectedVersion)
    }
}

extension UpdateCACertificateInput {

    static func write(value: UpdateCACertificateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["registrationConfig"].write(value.registrationConfig, with: IoTClientTypes.RegistrationConfig.write(value:to:))
        try writer["removeAutoRegistration"].write(value.removeAutoRegistration)
    }
}

extension UpdateCertificateProviderInput {

    static func write(value: UpdateCertificateProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountDefaultForOperations"].writeList(value.accountDefaultForOperations, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IoTClientTypes.CertificateProviderOperation>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lambdaFunctionArn"].write(value.lambdaFunctionArn)
    }
}

extension UpdateCustomMetricInput {

    static func write(value: UpdateCustomMetricInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayName"].write(value.displayName)
    }
}

extension UpdateDimensionInput {

    static func write(value: UpdateDimensionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["stringValues"].writeList(value.stringValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDomainConfigurationInput {

    static func write(value: UpdateDomainConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizerConfig"].write(value.authorizerConfig, with: IoTClientTypes.AuthorizerConfig.write(value:to:))
        try writer["domainConfigurationStatus"].write(value.domainConfigurationStatus)
        try writer["removeAuthorizerConfig"].write(value.removeAuthorizerConfig)
        try writer["serverCertificateConfig"].write(value.serverCertificateConfig, with: IoTClientTypes.ServerCertificateConfig.write(value:to:))
        try writer["tlsConfig"].write(value.tlsConfig, with: IoTClientTypes.TlsConfig.write(value:to:))
    }
}

extension UpdateDynamicThingGroupInput {

    static func write(value: UpdateDynamicThingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expectedVersion"].write(value.expectedVersion)
        try writer["indexName"].write(value.indexName)
        try writer["queryString"].write(value.queryString)
        try writer["queryVersion"].write(value.queryVersion)
        try writer["thingGroupProperties"].write(value.thingGroupProperties, with: IoTClientTypes.ThingGroupProperties.write(value:to:))
    }
}

extension UpdateEventConfigurationsInput {

    static func write(value: UpdateEventConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventConfigurations"].writeMap(value.eventConfigurations, valueWritingClosure: IoTClientTypes.Configuration.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateFleetMetricInput {

    static func write(value: UpdateFleetMetricInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregationField"].write(value.aggregationField)
        try writer["aggregationType"].write(value.aggregationType, with: IoTClientTypes.AggregationType.write(value:to:))
        try writer["description"].write(value.description)
        try writer["expectedVersion"].write(value.expectedVersion)
        try writer["indexName"].write(value.indexName)
        try writer["period"].write(value.period)
        try writer["queryString"].write(value.queryString)
        try writer["queryVersion"].write(value.queryVersion)
        try writer["unit"].write(value.unit)
    }
}

extension UpdateIndexingConfigurationInput {

    static func write(value: UpdateIndexingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["thingGroupIndexingConfiguration"].write(value.thingGroupIndexingConfiguration, with: IoTClientTypes.ThingGroupIndexingConfiguration.write(value:to:))
        try writer["thingIndexingConfiguration"].write(value.thingIndexingConfiguration, with: IoTClientTypes.ThingIndexingConfiguration.write(value:to:))
    }
}

extension UpdateJobInput {

    static func write(value: UpdateJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["abortConfig"].write(value.abortConfig, with: IoTClientTypes.AbortConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["jobExecutionsRetryConfig"].write(value.jobExecutionsRetryConfig, with: IoTClientTypes.JobExecutionsRetryConfig.write(value:to:))
        try writer["jobExecutionsRolloutConfig"].write(value.jobExecutionsRolloutConfig, with: IoTClientTypes.JobExecutionsRolloutConfig.write(value:to:))
        try writer["presignedUrlConfig"].write(value.presignedUrlConfig, with: IoTClientTypes.PresignedUrlConfig.write(value:to:))
        try writer["timeoutConfig"].write(value.timeoutConfig, with: IoTClientTypes.TimeoutConfig.write(value:to:))
    }
}

extension UpdateMitigationActionInput {

    static func write(value: UpdateMitigationActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionParams"].write(value.actionParams, with: IoTClientTypes.MitigationActionParams.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdatePackageInput {

    static func write(value: UpdatePackageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultVersionName"].write(value.defaultVersionName)
        try writer["description"].write(value.description)
        try writer["unsetDefaultVersion"].write(value.unsetDefaultVersion)
    }
}

extension UpdatePackageConfigurationInput {

    static func write(value: UpdatePackageConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["versionUpdateByJobsConfig"].write(value.versionUpdateByJobsConfig, with: IoTClientTypes.VersionUpdateByJobsConfig.write(value:to:))
    }
}

extension UpdatePackageVersionInput {

    static func write(value: UpdatePackageVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["artifact"].write(value.artifact, with: IoTClientTypes.PackageVersionArtifact.write(value:to:))
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["recipe"].write(value.recipe)
    }
}

extension UpdateProvisioningTemplateInput {

    static func write(value: UpdateProvisioningTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultVersionId"].write(value.defaultVersionId)
        try writer["description"].write(value.description)
        try writer["enabled"].write(value.enabled)
        try writer["preProvisioningHook"].write(value.preProvisioningHook, with: IoTClientTypes.ProvisioningHook.write(value:to:))
        try writer["provisioningRoleArn"].write(value.provisioningRoleArn)
        try writer["removePreProvisioningHook"].write(value.removePreProvisioningHook)
    }
}

extension UpdateRoleAliasInput {

    static func write(value: UpdateRoleAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credentialDurationSeconds"].write(value.credentialDurationSeconds)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateScheduledAuditInput {

    static func write(value: UpdateScheduledAuditInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dayOfMonth"].write(value.dayOfMonth)
        try writer["dayOfWeek"].write(value.dayOfWeek)
        try writer["frequency"].write(value.frequency)
        try writer["targetCheckNames"].writeList(value.targetCheckNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateSecurityProfileInput {

    static func write(value: UpdateSecurityProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalMetricsToRetain"].writeList(value.additionalMetricsToRetain, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["additionalMetricsToRetainV2"].writeList(value.additionalMetricsToRetainV2, memberWritingClosure: IoTClientTypes.MetricToRetain.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["alertTargets"].writeMap(value.alertTargets, valueWritingClosure: IoTClientTypes.AlertTarget.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["behaviors"].writeList(value.behaviors, memberWritingClosure: IoTClientTypes.Behavior.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["deleteAdditionalMetricsToRetain"].write(value.deleteAdditionalMetricsToRetain)
        try writer["deleteAlertTargets"].write(value.deleteAlertTargets)
        try writer["deleteBehaviors"].write(value.deleteBehaviors)
        try writer["deleteMetricsExportConfig"].write(value.deleteMetricsExportConfig)
        try writer["metricsExportConfig"].write(value.metricsExportConfig, with: IoTClientTypes.MetricsExportConfig.write(value:to:))
        try writer["securityProfileDescription"].write(value.securityProfileDescription)
    }
}

extension UpdateStreamInput {

    static func write(value: UpdateStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["files"].writeList(value.files, memberWritingClosure: IoTClientTypes.StreamFile.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateThingInput {

    static func write(value: UpdateThingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributePayload"].write(value.attributePayload, with: IoTClientTypes.AttributePayload.write(value:to:))
        try writer["expectedVersion"].write(value.expectedVersion)
        try writer["removeThingType"].write(value.removeThingType)
        try writer["thingTypeName"].write(value.thingTypeName)
    }
}

extension UpdateThingGroupInput {

    static func write(value: UpdateThingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expectedVersion"].write(value.expectedVersion)
        try writer["thingGroupProperties"].write(value.thingGroupProperties, with: IoTClientTypes.ThingGroupProperties.write(value:to:))
    }
}

extension UpdateThingGroupsForThingInput {

    static func write(value: UpdateThingGroupsForThingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["overrideDynamicGroups"].write(value.overrideDynamicGroups)
        try writer["thingGroupsToAdd"].writeList(value.thingGroupsToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["thingGroupsToRemove"].writeList(value.thingGroupsToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["thingName"].write(value.thingName)
    }
}

extension UpdateTopicRuleDestinationInput {

    static func write(value: UpdateTopicRuleDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["status"].write(value.status)
    }
}

extension ValidateSecurityProfileBehaviorsInput {

    static func write(value: ValidateSecurityProfileBehaviorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["behaviors"].writeList(value.behaviors, memberWritingClosure: IoTClientTypes.Behavior.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AcceptCertificateTransferOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptCertificateTransferOutput {
        return AcceptCertificateTransferOutput()
    }
}

extension AddThingToBillingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddThingToBillingGroupOutput {
        return AddThingToBillingGroupOutput()
    }
}

extension AddThingToThingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddThingToThingGroupOutput {
        return AddThingToThingGroupOutput()
    }
}

extension AssociateSbomWithPackageVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateSbomWithPackageVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateSbomWithPackageVersionOutput()
        value.packageName = try reader["packageName"].readIfPresent()
        value.sbom = try reader["sbom"].readIfPresent(with: IoTClientTypes.Sbom.read(from:))
        value.sbomValidationStatus = try reader["sbomValidationStatus"].readIfPresent()
        value.versionName = try reader["versionName"].readIfPresent()
        return value
    }
}

extension AssociateTargetsWithJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateTargetsWithJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateTargetsWithJobOutput()
        value.description = try reader["description"].readIfPresent()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobId = try reader["jobId"].readIfPresent()
        return value
    }
}

extension AttachPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachPolicyOutput {
        return AttachPolicyOutput()
    }
}

extension AttachPrincipalPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachPrincipalPolicyOutput {
        return AttachPrincipalPolicyOutput()
    }
}

extension AttachSecurityProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachSecurityProfileOutput {
        return AttachSecurityProfileOutput()
    }
}

extension AttachThingPrincipalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachThingPrincipalOutput {
        return AttachThingPrincipalOutput()
    }
}

extension CancelAuditMitigationActionsTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelAuditMitigationActionsTaskOutput {
        return CancelAuditMitigationActionsTaskOutput()
    }
}

extension CancelAuditTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelAuditTaskOutput {
        return CancelAuditTaskOutput()
    }
}

extension CancelCertificateTransferOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelCertificateTransferOutput {
        return CancelCertificateTransferOutput()
    }
}

extension CancelDetectMitigationActionsTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelDetectMitigationActionsTaskOutput {
        return CancelDetectMitigationActionsTaskOutput()
    }
}

extension CancelJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelJobOutput()
        value.description = try reader["description"].readIfPresent()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobId = try reader["jobId"].readIfPresent()
        return value
    }
}

extension CancelJobExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelJobExecutionOutput {
        return CancelJobExecutionOutput()
    }
}

extension ClearDefaultAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ClearDefaultAuthorizerOutput {
        return ClearDefaultAuthorizerOutput()
    }
}

extension ConfirmTopicRuleDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConfirmTopicRuleDestinationOutput {
        return ConfirmTopicRuleDestinationOutput()
    }
}

extension CreateAuditSuppressionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAuditSuppressionOutput {
        return CreateAuditSuppressionOutput()
    }
}

extension CreateAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAuthorizerOutput()
        value.authorizerArn = try reader["authorizerArn"].readIfPresent()
        value.authorizerName = try reader["authorizerName"].readIfPresent()
        return value
    }
}

extension CreateBillingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBillingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBillingGroupOutput()
        value.billingGroupArn = try reader["billingGroupArn"].readIfPresent()
        value.billingGroupId = try reader["billingGroupId"].readIfPresent()
        value.billingGroupName = try reader["billingGroupName"].readIfPresent()
        return value
    }
}

extension CreateCertificateFromCsrOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCertificateFromCsrOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCertificateFromCsrOutput()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateId = try reader["certificateId"].readIfPresent()
        value.certificatePem = try reader["certificatePem"].readIfPresent()
        return value
    }
}

extension CreateCertificateProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCertificateProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCertificateProviderOutput()
        value.certificateProviderArn = try reader["certificateProviderArn"].readIfPresent()
        value.certificateProviderName = try reader["certificateProviderName"].readIfPresent()
        return value
    }
}

extension CreateCustomMetricOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCustomMetricOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCustomMetricOutput()
        value.metricArn = try reader["metricArn"].readIfPresent()
        value.metricName = try reader["metricName"].readIfPresent()
        return value
    }
}

extension CreateDimensionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDimensionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDimensionOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension CreateDomainConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainConfigurationOutput()
        value.domainConfigurationArn = try reader["domainConfigurationArn"].readIfPresent()
        value.domainConfigurationName = try reader["domainConfigurationName"].readIfPresent()
        return value
    }
}

extension CreateDynamicThingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDynamicThingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDynamicThingGroupOutput()
        value.indexName = try reader["indexName"].readIfPresent()
        value.queryString = try reader["queryString"].readIfPresent()
        value.queryVersion = try reader["queryVersion"].readIfPresent()
        value.thingGroupArn = try reader["thingGroupArn"].readIfPresent()
        value.thingGroupId = try reader["thingGroupId"].readIfPresent()
        value.thingGroupName = try reader["thingGroupName"].readIfPresent()
        return value
    }
}

extension CreateFleetMetricOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFleetMetricOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFleetMetricOutput()
        value.metricArn = try reader["metricArn"].readIfPresent()
        value.metricName = try reader["metricName"].readIfPresent()
        return value
    }
}

extension CreateJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateJobOutput()
        value.description = try reader["description"].readIfPresent()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobId = try reader["jobId"].readIfPresent()
        return value
    }
}

extension CreateJobTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateJobTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateJobTemplateOutput()
        value.jobTemplateArn = try reader["jobTemplateArn"].readIfPresent()
        value.jobTemplateId = try reader["jobTemplateId"].readIfPresent()
        return value
    }
}

extension CreateKeysAndCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKeysAndCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKeysAndCertificateOutput()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateId = try reader["certificateId"].readIfPresent()
        value.certificatePem = try reader["certificatePem"].readIfPresent()
        value.keyPair = try reader["keyPair"].readIfPresent(with: IoTClientTypes.KeyPair.read(from:))
        return value
    }
}

extension CreateMitigationActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMitigationActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMitigationActionOutput()
        value.actionArn = try reader["actionArn"].readIfPresent()
        value.actionId = try reader["actionId"].readIfPresent()
        return value
    }
}

extension CreateOTAUpdateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOTAUpdateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOTAUpdateOutput()
        value.awsIotJobArn = try reader["awsIotJobArn"].readIfPresent()
        value.awsIotJobId = try reader["awsIotJobId"].readIfPresent()
        value.otaUpdateArn = try reader["otaUpdateArn"].readIfPresent()
        value.otaUpdateId = try reader["otaUpdateId"].readIfPresent()
        value.otaUpdateStatus = try reader["otaUpdateStatus"].readIfPresent()
        return value
    }
}

extension CreatePackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePackageOutput()
        value.description = try reader["description"].readIfPresent()
        value.packageArn = try reader["packageArn"].readIfPresent()
        value.packageName = try reader["packageName"].readIfPresent()
        return value
    }
}

extension CreatePackageVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePackageVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePackageVersionOutput()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.description = try reader["description"].readIfPresent()
        value.errorReason = try reader["errorReason"].readIfPresent()
        value.packageName = try reader["packageName"].readIfPresent()
        value.packageVersionArn = try reader["packageVersionArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.versionName = try reader["versionName"].readIfPresent()
        return value
    }
}

extension CreatePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePolicyOutput()
        value.policyArn = try reader["policyArn"].readIfPresent()
        value.policyDocument = try reader["policyDocument"].readIfPresent()
        value.policyName = try reader["policyName"].readIfPresent()
        value.policyVersionId = try reader["policyVersionId"].readIfPresent()
        return value
    }
}

extension CreatePolicyVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePolicyVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePolicyVersionOutput()
        value.isDefaultVersion = try reader["isDefaultVersion"].readIfPresent() ?? false
        value.policyArn = try reader["policyArn"].readIfPresent()
        value.policyDocument = try reader["policyDocument"].readIfPresent()
        value.policyVersionId = try reader["policyVersionId"].readIfPresent()
        return value
    }
}

extension CreateProvisioningClaimOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProvisioningClaimOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProvisioningClaimOutput()
        value.certificateId = try reader["certificateId"].readIfPresent()
        value.certificatePem = try reader["certificatePem"].readIfPresent()
        value.expiration = try reader["expiration"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.keyPair = try reader["keyPair"].readIfPresent(with: IoTClientTypes.KeyPair.read(from:))
        return value
    }
}

extension CreateProvisioningTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProvisioningTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProvisioningTemplateOutput()
        value.defaultVersionId = try reader["defaultVersionId"].readIfPresent()
        value.templateArn = try reader["templateArn"].readIfPresent()
        value.templateName = try reader["templateName"].readIfPresent()
        return value
    }
}

extension CreateProvisioningTemplateVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProvisioningTemplateVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProvisioningTemplateVersionOutput()
        value.isDefaultVersion = try reader["isDefaultVersion"].readIfPresent() ?? false
        value.templateArn = try reader["templateArn"].readIfPresent()
        value.templateName = try reader["templateName"].readIfPresent()
        value.versionId = try reader["versionId"].readIfPresent()
        return value
    }
}

extension CreateRoleAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRoleAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRoleAliasOutput()
        value.roleAlias = try reader["roleAlias"].readIfPresent()
        value.roleAliasArn = try reader["roleAliasArn"].readIfPresent()
        return value
    }
}

extension CreateScheduledAuditOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateScheduledAuditOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateScheduledAuditOutput()
        value.scheduledAuditArn = try reader["scheduledAuditArn"].readIfPresent()
        return value
    }
}

extension CreateSecurityProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSecurityProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSecurityProfileOutput()
        value.securityProfileArn = try reader["securityProfileArn"].readIfPresent()
        value.securityProfileName = try reader["securityProfileName"].readIfPresent()
        return value
    }
}

extension CreateStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStreamOutput()
        value.description = try reader["description"].readIfPresent()
        value.streamArn = try reader["streamArn"].readIfPresent()
        value.streamId = try reader["streamId"].readIfPresent()
        value.streamVersion = try reader["streamVersion"].readIfPresent()
        return value
    }
}

extension CreateThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateThingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateThingOutput()
        value.thingArn = try reader["thingArn"].readIfPresent()
        value.thingId = try reader["thingId"].readIfPresent()
        value.thingName = try reader["thingName"].readIfPresent()
        return value
    }
}

extension CreateThingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateThingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateThingGroupOutput()
        value.thingGroupArn = try reader["thingGroupArn"].readIfPresent()
        value.thingGroupId = try reader["thingGroupId"].readIfPresent()
        value.thingGroupName = try reader["thingGroupName"].readIfPresent()
        return value
    }
}

extension CreateThingTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateThingTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateThingTypeOutput()
        value.thingTypeArn = try reader["thingTypeArn"].readIfPresent()
        value.thingTypeId = try reader["thingTypeId"].readIfPresent()
        value.thingTypeName = try reader["thingTypeName"].readIfPresent()
        return value
    }
}

extension CreateTopicRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTopicRuleOutput {
        return CreateTopicRuleOutput()
    }
}

extension CreateTopicRuleDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTopicRuleDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTopicRuleDestinationOutput()
        value.topicRuleDestination = try reader["topicRuleDestination"].readIfPresent(with: IoTClientTypes.TopicRuleDestination.read(from:))
        return value
    }
}

extension DeleteAccountAuditConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccountAuditConfigurationOutput {
        return DeleteAccountAuditConfigurationOutput()
    }
}

extension DeleteAuditSuppressionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAuditSuppressionOutput {
        return DeleteAuditSuppressionOutput()
    }
}

extension DeleteAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAuthorizerOutput {
        return DeleteAuthorizerOutput()
    }
}

extension DeleteBillingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBillingGroupOutput {
        return DeleteBillingGroupOutput()
    }
}

extension DeleteCACertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCACertificateOutput {
        return DeleteCACertificateOutput()
    }
}

extension DeleteCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCertificateOutput {
        return DeleteCertificateOutput()
    }
}

extension DeleteCertificateProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCertificateProviderOutput {
        return DeleteCertificateProviderOutput()
    }
}

extension DeleteCustomMetricOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCustomMetricOutput {
        return DeleteCustomMetricOutput()
    }
}

extension DeleteDimensionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDimensionOutput {
        return DeleteDimensionOutput()
    }
}

extension DeleteDomainConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainConfigurationOutput {
        return DeleteDomainConfigurationOutput()
    }
}

extension DeleteDynamicThingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDynamicThingGroupOutput {
        return DeleteDynamicThingGroupOutput()
    }
}

extension DeleteFleetMetricOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFleetMetricOutput {
        return DeleteFleetMetricOutput()
    }
}

extension DeleteJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteJobOutput {
        return DeleteJobOutput()
    }
}

extension DeleteJobExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteJobExecutionOutput {
        return DeleteJobExecutionOutput()
    }
}

extension DeleteJobTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteJobTemplateOutput {
        return DeleteJobTemplateOutput()
    }
}

extension DeleteMitigationActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMitigationActionOutput {
        return DeleteMitigationActionOutput()
    }
}

extension DeleteOTAUpdateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOTAUpdateOutput {
        return DeleteOTAUpdateOutput()
    }
}

extension DeletePackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePackageOutput {
        return DeletePackageOutput()
    }
}

extension DeletePackageVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePackageVersionOutput {
        return DeletePackageVersionOutput()
    }
}

extension DeletePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePolicyOutput {
        return DeletePolicyOutput()
    }
}

extension DeletePolicyVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePolicyVersionOutput {
        return DeletePolicyVersionOutput()
    }
}

extension DeleteProvisioningTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProvisioningTemplateOutput {
        return DeleteProvisioningTemplateOutput()
    }
}

extension DeleteProvisioningTemplateVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProvisioningTemplateVersionOutput {
        return DeleteProvisioningTemplateVersionOutput()
    }
}

extension DeleteRegistrationCodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRegistrationCodeOutput {
        return DeleteRegistrationCodeOutput()
    }
}

extension DeleteRoleAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRoleAliasOutput {
        return DeleteRoleAliasOutput()
    }
}

extension DeleteScheduledAuditOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteScheduledAuditOutput {
        return DeleteScheduledAuditOutput()
    }
}

extension DeleteSecurityProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSecurityProfileOutput {
        return DeleteSecurityProfileOutput()
    }
}

extension DeleteStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStreamOutput {
        return DeleteStreamOutput()
    }
}

extension DeleteThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteThingOutput {
        return DeleteThingOutput()
    }
}

extension DeleteThingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteThingGroupOutput {
        return DeleteThingGroupOutput()
    }
}

extension DeleteThingTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteThingTypeOutput {
        return DeleteThingTypeOutput()
    }
}

extension DeleteTopicRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTopicRuleOutput {
        return DeleteTopicRuleOutput()
    }
}

extension DeleteTopicRuleDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTopicRuleDestinationOutput {
        return DeleteTopicRuleDestinationOutput()
    }
}

extension DeleteV2LoggingLevelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteV2LoggingLevelOutput {
        return DeleteV2LoggingLevelOutput()
    }
}

extension DeprecateThingTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeprecateThingTypeOutput {
        return DeprecateThingTypeOutput()
    }
}

extension DescribeAccountAuditConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountAuditConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountAuditConfigurationOutput()
        value.auditCheckConfigurations = try reader["auditCheckConfigurations"].readMapIfPresent(valueReadingClosure: IoTClientTypes.AuditCheckConfiguration.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.auditNotificationTargetConfigurations = try reader["auditNotificationTargetConfigurations"].readMapIfPresent(valueReadingClosure: IoTClientTypes.AuditNotificationTarget.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension DescribeAuditFindingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAuditFindingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAuditFindingOutput()
        value.finding = try reader["finding"].readIfPresent(with: IoTClientTypes.AuditFinding.read(from:))
        return value
    }
}

extension DescribeAuditMitigationActionsTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAuditMitigationActionsTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAuditMitigationActionsTaskOutput()
        value.actionsDefinition = try reader["actionsDefinition"].readListIfPresent(memberReadingClosure: IoTClientTypes.MitigationAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.auditCheckToActionsMapping = try reader["auditCheckToActionsMapping"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.target = try reader["target"].readIfPresent(with: IoTClientTypes.AuditMitigationActionsTaskTarget.read(from:))
        value.taskStatistics = try reader["taskStatistics"].readMapIfPresent(valueReadingClosure: IoTClientTypes.TaskStatisticsForAuditCheck.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.taskStatus = try reader["taskStatus"].readIfPresent()
        return value
    }
}

extension DescribeAuditSuppressionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAuditSuppressionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAuditSuppressionOutput()
        value.checkName = try reader["checkName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.expirationDate = try reader["expirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent(with: IoTClientTypes.ResourceIdentifier.read(from:))
        value.suppressIndefinitely = try reader["suppressIndefinitely"].readIfPresent()
        return value
    }
}

extension DescribeAuditTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAuditTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAuditTaskOutput()
        value.auditDetails = try reader["auditDetails"].readMapIfPresent(valueReadingClosure: IoTClientTypes.AuditCheckDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.scheduledAuditName = try reader["scheduledAuditName"].readIfPresent()
        value.taskStartTime = try reader["taskStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.taskStatistics = try reader["taskStatistics"].readIfPresent(with: IoTClientTypes.TaskStatistics.read(from:))
        value.taskStatus = try reader["taskStatus"].readIfPresent()
        value.taskType = try reader["taskType"].readIfPresent()
        return value
    }
}

extension DescribeAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAuthorizerOutput()
        value.authorizerDescription = try reader["authorizerDescription"].readIfPresent(with: IoTClientTypes.AuthorizerDescription.read(from:))
        return value
    }
}

extension DescribeBillingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBillingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBillingGroupOutput()
        value.billingGroupArn = try reader["billingGroupArn"].readIfPresent()
        value.billingGroupId = try reader["billingGroupId"].readIfPresent()
        value.billingGroupMetadata = try reader["billingGroupMetadata"].readIfPresent(with: IoTClientTypes.BillingGroupMetadata.read(from:))
        value.billingGroupName = try reader["billingGroupName"].readIfPresent()
        value.billingGroupProperties = try reader["billingGroupProperties"].readIfPresent(with: IoTClientTypes.BillingGroupProperties.read(from:))
        value.version = try reader["version"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeCACertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCACertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCACertificateOutput()
        value.certificateDescription = try reader["certificateDescription"].readIfPresent(with: IoTClientTypes.CACertificateDescription.read(from:))
        value.registrationConfig = try reader["registrationConfig"].readIfPresent(with: IoTClientTypes.RegistrationConfig.read(from:))
        return value
    }
}

extension DescribeCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCertificateOutput()
        value.certificateDescription = try reader["certificateDescription"].readIfPresent(with: IoTClientTypes.CertificateDescription.read(from:))
        return value
    }
}

extension DescribeCertificateProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCertificateProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCertificateProviderOutput()
        value.accountDefaultForOperations = try reader["accountDefaultForOperations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<IoTClientTypes.CertificateProviderOperation>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.certificateProviderArn = try reader["certificateProviderArn"].readIfPresent()
        value.certificateProviderName = try reader["certificateProviderName"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lambdaFunctionArn = try reader["lambdaFunctionArn"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DescribeCustomMetricOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCustomMetricOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCustomMetricOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.displayName = try reader["displayName"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metricArn = try reader["metricArn"].readIfPresent()
        value.metricName = try reader["metricName"].readIfPresent()
        value.metricType = try reader["metricType"].readIfPresent()
        return value
    }
}

extension DescribeDefaultAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDefaultAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDefaultAuthorizerOutput()
        value.authorizerDescription = try reader["authorizerDescription"].readIfPresent(with: IoTClientTypes.AuthorizerDescription.read(from:))
        return value
    }
}

extension DescribeDetectMitigationActionsTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDetectMitigationActionsTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDetectMitigationActionsTaskOutput()
        value.taskSummary = try reader["taskSummary"].readIfPresent(with: IoTClientTypes.DetectMitigationActionsTaskSummary.read(from:))
        return value
    }
}

extension DescribeDimensionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDimensionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDimensionOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.stringValues = try reader["stringValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension DescribeDomainConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDomainConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDomainConfigurationOutput()
        value.authorizerConfig = try reader["authorizerConfig"].readIfPresent(with: IoTClientTypes.AuthorizerConfig.read(from:))
        value.domainConfigurationArn = try reader["domainConfigurationArn"].readIfPresent()
        value.domainConfigurationName = try reader["domainConfigurationName"].readIfPresent()
        value.domainConfigurationStatus = try reader["domainConfigurationStatus"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent()
        value.domainType = try reader["domainType"].readIfPresent()
        value.lastStatusChangeDate = try reader["lastStatusChangeDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.serverCertificateConfig = try reader["serverCertificateConfig"].readIfPresent(with: IoTClientTypes.ServerCertificateConfig.read(from:))
        value.serverCertificates = try reader["serverCertificates"].readListIfPresent(memberReadingClosure: IoTClientTypes.ServerCertificateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.serviceType = try reader["serviceType"].readIfPresent()
        value.tlsConfig = try reader["tlsConfig"].readIfPresent(with: IoTClientTypes.TlsConfig.read(from:))
        return value
    }
}

extension DescribeEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEndpointOutput()
        value.endpointAddress = try reader["endpointAddress"].readIfPresent()
        return value
    }
}

extension DescribeEventConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventConfigurationsOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.eventConfigurations = try reader["eventConfigurations"].readMapIfPresent(valueReadingClosure: IoTClientTypes.Configuration.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DescribeFleetMetricOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFleetMetricOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFleetMetricOutput()
        value.aggregationField = try reader["aggregationField"].readIfPresent()
        value.aggregationType = try reader["aggregationType"].readIfPresent(with: IoTClientTypes.AggregationType.read(from:))
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.indexName = try reader["indexName"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metricArn = try reader["metricArn"].readIfPresent()
        value.metricName = try reader["metricName"].readIfPresent()
        value.period = try reader["period"].readIfPresent()
        value.queryString = try reader["queryString"].readIfPresent()
        value.queryVersion = try reader["queryVersion"].readIfPresent()
        value.unit = try reader["unit"].readIfPresent()
        value.version = try reader["version"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeIndexOutput()
        value.indexName = try reader["indexName"].readIfPresent()
        value.indexStatus = try reader["indexStatus"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        return value
    }
}

extension DescribeJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeJobOutput()
        value.documentSource = try reader["documentSource"].readIfPresent()
        value.job = try reader["job"].readIfPresent(with: IoTClientTypes.Job.read(from:))
        return value
    }
}

extension DescribeJobExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeJobExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeJobExecutionOutput()
        value.execution = try reader["execution"].readIfPresent(with: IoTClientTypes.JobExecution.read(from:))
        return value
    }
}

extension DescribeJobTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeJobTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeJobTemplateOutput()
        value.abortConfig = try reader["abortConfig"].readIfPresent(with: IoTClientTypes.AbortConfig.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.destinationPackageVersions = try reader["destinationPackageVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.document = try reader["document"].readIfPresent()
        value.documentSource = try reader["documentSource"].readIfPresent()
        value.jobExecutionsRetryConfig = try reader["jobExecutionsRetryConfig"].readIfPresent(with: IoTClientTypes.JobExecutionsRetryConfig.read(from:))
        value.jobExecutionsRolloutConfig = try reader["jobExecutionsRolloutConfig"].readIfPresent(with: IoTClientTypes.JobExecutionsRolloutConfig.read(from:))
        value.jobTemplateArn = try reader["jobTemplateArn"].readIfPresent()
        value.jobTemplateId = try reader["jobTemplateId"].readIfPresent()
        value.maintenanceWindows = try reader["maintenanceWindows"].readListIfPresent(memberReadingClosure: IoTClientTypes.MaintenanceWindow.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.presignedUrlConfig = try reader["presignedUrlConfig"].readIfPresent(with: IoTClientTypes.PresignedUrlConfig.read(from:))
        value.timeoutConfig = try reader["timeoutConfig"].readIfPresent(with: IoTClientTypes.TimeoutConfig.read(from:))
        return value
    }
}

extension DescribeManagedJobTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeManagedJobTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeManagedJobTemplateOutput()
        value.description = try reader["description"].readIfPresent()
        value.document = try reader["document"].readIfPresent()
        value.documentParameters = try reader["documentParameters"].readListIfPresent(memberReadingClosure: IoTClientTypes.DocumentParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.environments = try reader["environments"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.templateArn = try reader["templateArn"].readIfPresent()
        value.templateName = try reader["templateName"].readIfPresent()
        value.templateVersion = try reader["templateVersion"].readIfPresent()
        return value
    }
}

extension DescribeMitigationActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMitigationActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMitigationActionOutput()
        value.actionArn = try reader["actionArn"].readIfPresent()
        value.actionId = try reader["actionId"].readIfPresent()
        value.actionName = try reader["actionName"].readIfPresent()
        value.actionParams = try reader["actionParams"].readIfPresent(with: IoTClientTypes.MitigationActionParams.read(from:))
        value.actionType = try reader["actionType"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension DescribeProvisioningTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProvisioningTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProvisioningTemplateOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultVersionId = try reader["defaultVersionId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.preProvisioningHook = try reader["preProvisioningHook"].readIfPresent(with: IoTClientTypes.ProvisioningHook.read(from:))
        value.provisioningRoleArn = try reader["provisioningRoleArn"].readIfPresent()
        value.templateArn = try reader["templateArn"].readIfPresent()
        value.templateBody = try reader["templateBody"].readIfPresent()
        value.templateName = try reader["templateName"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension DescribeProvisioningTemplateVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProvisioningTemplateVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProvisioningTemplateVersionOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.isDefaultVersion = try reader["isDefaultVersion"].readIfPresent() ?? false
        value.templateBody = try reader["templateBody"].readIfPresent()
        value.versionId = try reader["versionId"].readIfPresent()
        return value
    }
}

extension DescribeRoleAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRoleAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRoleAliasOutput()
        value.roleAliasDescription = try reader["roleAliasDescription"].readIfPresent(with: IoTClientTypes.RoleAliasDescription.read(from:))
        return value
    }
}

extension DescribeScheduledAuditOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeScheduledAuditOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeScheduledAuditOutput()
        value.dayOfMonth = try reader["dayOfMonth"].readIfPresent()
        value.dayOfWeek = try reader["dayOfWeek"].readIfPresent()
        value.frequency = try reader["frequency"].readIfPresent()
        value.scheduledAuditArn = try reader["scheduledAuditArn"].readIfPresent()
        value.scheduledAuditName = try reader["scheduledAuditName"].readIfPresent()
        value.targetCheckNames = try reader["targetCheckNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeSecurityProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSecurityProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSecurityProfileOutput()
        value.additionalMetricsToRetain = try reader["additionalMetricsToRetain"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.additionalMetricsToRetainV2 = try reader["additionalMetricsToRetainV2"].readListIfPresent(memberReadingClosure: IoTClientTypes.MetricToRetain.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.alertTargets = try reader["alertTargets"].readMapIfPresent(valueReadingClosure: IoTClientTypes.AlertTarget.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.behaviors = try reader["behaviors"].readListIfPresent(memberReadingClosure: IoTClientTypes.Behavior.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metricsExportConfig = try reader["metricsExportConfig"].readIfPresent(with: IoTClientTypes.MetricsExportConfig.read(from:))
        value.securityProfileArn = try reader["securityProfileArn"].readIfPresent()
        value.securityProfileDescription = try reader["securityProfileDescription"].readIfPresent()
        value.securityProfileName = try reader["securityProfileName"].readIfPresent()
        value.version = try reader["version"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStreamOutput()
        value.streamInfo = try reader["streamInfo"].readIfPresent(with: IoTClientTypes.StreamInfo.read(from:))
        return value
    }
}

extension DescribeThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeThingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeThingOutput()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.billingGroupName = try reader["billingGroupName"].readIfPresent()
        value.defaultClientId = try reader["defaultClientId"].readIfPresent()
        value.thingArn = try reader["thingArn"].readIfPresent()
        value.thingId = try reader["thingId"].readIfPresent()
        value.thingName = try reader["thingName"].readIfPresent()
        value.thingTypeName = try reader["thingTypeName"].readIfPresent()
        value.version = try reader["version"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeThingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeThingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeThingGroupOutput()
        value.indexName = try reader["indexName"].readIfPresent()
        value.queryString = try reader["queryString"].readIfPresent()
        value.queryVersion = try reader["queryVersion"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.thingGroupArn = try reader["thingGroupArn"].readIfPresent()
        value.thingGroupId = try reader["thingGroupId"].readIfPresent()
        value.thingGroupMetadata = try reader["thingGroupMetadata"].readIfPresent(with: IoTClientTypes.ThingGroupMetadata.read(from:))
        value.thingGroupName = try reader["thingGroupName"].readIfPresent()
        value.thingGroupProperties = try reader["thingGroupProperties"].readIfPresent(with: IoTClientTypes.ThingGroupProperties.read(from:))
        value.version = try reader["version"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeThingRegistrationTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeThingRegistrationTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeThingRegistrationTaskOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureCount = try reader["failureCount"].readIfPresent() ?? 0
        value.inputFileBucket = try reader["inputFileBucket"].readIfPresent()
        value.inputFileKey = try reader["inputFileKey"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.message = try reader["message"].readIfPresent()
        value.percentageProgress = try reader["percentageProgress"].readIfPresent() ?? 0
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.successCount = try reader["successCount"].readIfPresent() ?? 0
        value.taskId = try reader["taskId"].readIfPresent()
        value.templateBody = try reader["templateBody"].readIfPresent()
        return value
    }
}

extension DescribeThingTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeThingTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeThingTypeOutput()
        value.thingTypeArn = try reader["thingTypeArn"].readIfPresent()
        value.thingTypeId = try reader["thingTypeId"].readIfPresent()
        value.thingTypeMetadata = try reader["thingTypeMetadata"].readIfPresent(with: IoTClientTypes.ThingTypeMetadata.read(from:))
        value.thingTypeName = try reader["thingTypeName"].readIfPresent()
        value.thingTypeProperties = try reader["thingTypeProperties"].readIfPresent(with: IoTClientTypes.ThingTypeProperties.read(from:))
        return value
    }
}

extension DetachPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachPolicyOutput {
        return DetachPolicyOutput()
    }
}

extension DetachPrincipalPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachPrincipalPolicyOutput {
        return DetachPrincipalPolicyOutput()
    }
}

extension DetachSecurityProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachSecurityProfileOutput {
        return DetachSecurityProfileOutput()
    }
}

extension DetachThingPrincipalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachThingPrincipalOutput {
        return DetachThingPrincipalOutput()
    }
}

extension DisableTopicRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableTopicRuleOutput {
        return DisableTopicRuleOutput()
    }
}

extension DisassociateSbomFromPackageVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateSbomFromPackageVersionOutput {
        return DisassociateSbomFromPackageVersionOutput()
    }
}

extension EnableTopicRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableTopicRuleOutput {
        return EnableTopicRuleOutput()
    }
}

extension GetBehaviorModelTrainingSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBehaviorModelTrainingSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBehaviorModelTrainingSummariesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.summaries = try reader["summaries"].readListIfPresent(memberReadingClosure: IoTClientTypes.BehaviorModelTrainingSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetBucketsAggregationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBucketsAggregationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBucketsAggregationOutput()
        value.buckets = try reader["buckets"].readListIfPresent(memberReadingClosure: IoTClientTypes.Bucket.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalCount = try reader["totalCount"].readIfPresent() ?? 0
        return value
    }
}

extension GetCardinalityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCardinalityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCardinalityOutput()
        value.cardinality = try reader["cardinality"].readIfPresent() ?? 0
        return value
    }
}

extension GetEffectivePoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEffectivePoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEffectivePoliciesOutput()
        value.effectivePolicies = try reader["effectivePolicies"].readListIfPresent(memberReadingClosure: IoTClientTypes.EffectivePolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetIndexingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIndexingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIndexingConfigurationOutput()
        value.thingGroupIndexingConfiguration = try reader["thingGroupIndexingConfiguration"].readIfPresent(with: IoTClientTypes.ThingGroupIndexingConfiguration.read(from:))
        value.thingIndexingConfiguration = try reader["thingIndexingConfiguration"].readIfPresent(with: IoTClientTypes.ThingIndexingConfiguration.read(from:))
        return value
    }
}

extension GetJobDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJobDocumentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJobDocumentOutput()
        value.document = try reader["document"].readIfPresent()
        return value
    }
}

extension GetLoggingOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLoggingOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLoggingOptionsOutput()
        value.logLevel = try reader["logLevel"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension GetOTAUpdateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOTAUpdateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOTAUpdateOutput()
        value.otaUpdateInfo = try reader["otaUpdateInfo"].readIfPresent(with: IoTClientTypes.OTAUpdateInfo.read(from:))
        return value
    }
}

extension GetPackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPackageOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultVersionName = try reader["defaultVersionName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.packageArn = try reader["packageArn"].readIfPresent()
        value.packageName = try reader["packageName"].readIfPresent()
        return value
    }
}

extension GetPackageConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPackageConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPackageConfigurationOutput()
        value.versionUpdateByJobsConfig = try reader["versionUpdateByJobsConfig"].readIfPresent(with: IoTClientTypes.VersionUpdateByJobsConfig.read(from:))
        return value
    }
}

extension GetPackageVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPackageVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPackageVersionOutput()
        value.artifact = try reader["artifact"].readIfPresent(with: IoTClientTypes.PackageVersionArtifact.read(from:))
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.errorReason = try reader["errorReason"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.packageName = try reader["packageName"].readIfPresent()
        value.packageVersionArn = try reader["packageVersionArn"].readIfPresent()
        value.recipe = try reader["recipe"].readIfPresent()
        value.sbom = try reader["sbom"].readIfPresent(with: IoTClientTypes.Sbom.read(from:))
        value.sbomValidationStatus = try reader["sbomValidationStatus"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.versionName = try reader["versionName"].readIfPresent()
        return value
    }
}

extension GetPercentilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPercentilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPercentilesOutput()
        value.percentiles = try reader["percentiles"].readListIfPresent(memberReadingClosure: IoTClientTypes.PercentPair.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPolicyOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultVersionId = try reader["defaultVersionId"].readIfPresent()
        value.generationId = try reader["generationId"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.policyArn = try reader["policyArn"].readIfPresent()
        value.policyDocument = try reader["policyDocument"].readIfPresent()
        value.policyName = try reader["policyName"].readIfPresent()
        return value
    }
}

extension GetPolicyVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPolicyVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPolicyVersionOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.generationId = try reader["generationId"].readIfPresent()
        value.isDefaultVersion = try reader["isDefaultVersion"].readIfPresent() ?? false
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.policyArn = try reader["policyArn"].readIfPresent()
        value.policyDocument = try reader["policyDocument"].readIfPresent()
        value.policyName = try reader["policyName"].readIfPresent()
        value.policyVersionId = try reader["policyVersionId"].readIfPresent()
        return value
    }
}

extension GetRegistrationCodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRegistrationCodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRegistrationCodeOutput()
        value.registrationCode = try reader["registrationCode"].readIfPresent()
        return value
    }
}

extension GetStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStatisticsOutput()
        value.statistics = try reader["statistics"].readIfPresent(with: IoTClientTypes.Statistics.read(from:))
        return value
    }
}

extension GetTopicRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTopicRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTopicRuleOutput()
        value.rule = try reader["rule"].readIfPresent(with: IoTClientTypes.TopicRule.read(from:))
        value.ruleArn = try reader["ruleArn"].readIfPresent()
        return value
    }
}

extension GetTopicRuleDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTopicRuleDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTopicRuleDestinationOutput()
        value.topicRuleDestination = try reader["topicRuleDestination"].readIfPresent(with: IoTClientTypes.TopicRuleDestination.read(from:))
        return value
    }
}

extension GetV2LoggingOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetV2LoggingOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetV2LoggingOptionsOutput()
        value.defaultLogLevel = try reader["defaultLogLevel"].readIfPresent()
        value.disableAllLogs = try reader["disableAllLogs"].readIfPresent() ?? false
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension ListActiveViolationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListActiveViolationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListActiveViolationsOutput()
        value.activeViolations = try reader["activeViolations"].readListIfPresent(memberReadingClosure: IoTClientTypes.ActiveViolation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAttachedPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAttachedPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAttachedPoliciesOutput()
        value.nextMarker = try reader["nextMarker"].readIfPresent()
        value.policies = try reader["policies"].readListIfPresent(memberReadingClosure: IoTClientTypes.Policy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAuditFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAuditFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAuditFindingsOutput()
        value.findings = try reader["findings"].readListIfPresent(memberReadingClosure: IoTClientTypes.AuditFinding.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAuditMitigationActionsExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAuditMitigationActionsExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAuditMitigationActionsExecutionsOutput()
        value.actionsExecutions = try reader["actionsExecutions"].readListIfPresent(memberReadingClosure: IoTClientTypes.AuditMitigationActionExecutionMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAuditMitigationActionsTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAuditMitigationActionsTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAuditMitigationActionsTasksOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tasks = try reader["tasks"].readListIfPresent(memberReadingClosure: IoTClientTypes.AuditMitigationActionsTaskMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAuditSuppressionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAuditSuppressionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAuditSuppressionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.suppressions = try reader["suppressions"].readListIfPresent(memberReadingClosure: IoTClientTypes.AuditSuppression.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAuditTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAuditTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAuditTasksOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tasks = try reader["tasks"].readListIfPresent(memberReadingClosure: IoTClientTypes.AuditTaskMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAuthorizersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAuthorizersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAuthorizersOutput()
        value.authorizers = try reader["authorizers"].readListIfPresent(memberReadingClosure: IoTClientTypes.AuthorizerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["nextMarker"].readIfPresent()
        return value
    }
}

extension ListBillingGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBillingGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBillingGroupsOutput()
        value.billingGroups = try reader["billingGroups"].readListIfPresent(memberReadingClosure: IoTClientTypes.GroupNameAndArn.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCACertificatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCACertificatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCACertificatesOutput()
        value.certificates = try reader["certificates"].readListIfPresent(memberReadingClosure: IoTClientTypes.CACertificate.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["nextMarker"].readIfPresent()
        return value
    }
}

extension ListCertificateProvidersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCertificateProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCertificateProvidersOutput()
        value.certificateProviders = try reader["certificateProviders"].readListIfPresent(memberReadingClosure: IoTClientTypes.CertificateProviderSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCertificatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCertificatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCertificatesOutput()
        value.certificates = try reader["certificates"].readListIfPresent(memberReadingClosure: IoTClientTypes.Certificate.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["nextMarker"].readIfPresent()
        return value
    }
}

extension ListCertificatesByCAOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCertificatesByCAOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCertificatesByCAOutput()
        value.certificates = try reader["certificates"].readListIfPresent(memberReadingClosure: IoTClientTypes.Certificate.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["nextMarker"].readIfPresent()
        return value
    }
}

extension ListCustomMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomMetricsOutput()
        value.metricNames = try reader["metricNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDetectMitigationActionsExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDetectMitigationActionsExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDetectMitigationActionsExecutionsOutput()
        value.actionsExecutions = try reader["actionsExecutions"].readListIfPresent(memberReadingClosure: IoTClientTypes.DetectMitigationActionExecution.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDetectMitigationActionsTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDetectMitigationActionsTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDetectMitigationActionsTasksOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tasks = try reader["tasks"].readListIfPresent(memberReadingClosure: IoTClientTypes.DetectMitigationActionsTaskSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDimensionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDimensionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDimensionsOutput()
        value.dimensionNames = try reader["dimensionNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDomainConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainConfigurationsOutput()
        value.domainConfigurations = try reader["domainConfigurations"].readListIfPresent(memberReadingClosure: IoTClientTypes.DomainConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["nextMarker"].readIfPresent()
        return value
    }
}

extension ListFleetMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFleetMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFleetMetricsOutput()
        value.fleetMetrics = try reader["fleetMetrics"].readListIfPresent(memberReadingClosure: IoTClientTypes.FleetMetricNameAndArn.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListIndicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIndicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIndicesOutput()
        value.indexNames = try reader["indexNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListJobExecutionsForJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJobExecutionsForJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJobExecutionsForJobOutput()
        value.executionSummaries = try reader["executionSummaries"].readListIfPresent(memberReadingClosure: IoTClientTypes.JobExecutionSummaryForJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListJobExecutionsForThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJobExecutionsForThingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJobExecutionsForThingOutput()
        value.executionSummaries = try reader["executionSummaries"].readListIfPresent(memberReadingClosure: IoTClientTypes.JobExecutionSummaryForThing.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJobsOutput()
        value.jobs = try reader["jobs"].readListIfPresent(memberReadingClosure: IoTClientTypes.JobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListJobTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJobTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJobTemplatesOutput()
        value.jobTemplates = try reader["jobTemplates"].readListIfPresent(memberReadingClosure: IoTClientTypes.JobTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListManagedJobTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListManagedJobTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListManagedJobTemplatesOutput()
        value.managedJobTemplates = try reader["managedJobTemplates"].readListIfPresent(memberReadingClosure: IoTClientTypes.ManagedJobTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMetricValuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMetricValuesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMetricValuesOutput()
        value.metricDatumList = try reader["metricDatumList"].readListIfPresent(memberReadingClosure: IoTClientTypes.MetricDatum.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMitigationActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMitigationActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMitigationActionsOutput()
        value.actionIdentifiers = try reader["actionIdentifiers"].readListIfPresent(memberReadingClosure: IoTClientTypes.MitigationActionIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListOTAUpdatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOTAUpdatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOTAUpdatesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.otaUpdates = try reader["otaUpdates"].readListIfPresent(memberReadingClosure: IoTClientTypes.OTAUpdateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListOutgoingCertificatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOutgoingCertificatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOutgoingCertificatesOutput()
        value.nextMarker = try reader["nextMarker"].readIfPresent()
        value.outgoingCertificates = try reader["outgoingCertificates"].readListIfPresent(memberReadingClosure: IoTClientTypes.OutgoingCertificate.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPackagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPackagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPackagesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.packageSummaries = try reader["packageSummaries"].readListIfPresent(memberReadingClosure: IoTClientTypes.PackageSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPackageVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPackageVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPackageVersionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.packageVersionSummaries = try reader["packageVersionSummaries"].readListIfPresent(memberReadingClosure: IoTClientTypes.PackageVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPoliciesOutput()
        value.nextMarker = try reader["nextMarker"].readIfPresent()
        value.policies = try reader["policies"].readListIfPresent(memberReadingClosure: IoTClientTypes.Policy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPolicyPrincipalsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPolicyPrincipalsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPolicyPrincipalsOutput()
        value.nextMarker = try reader["nextMarker"].readIfPresent()
        value.principals = try reader["principals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPolicyVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPolicyVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPolicyVersionsOutput()
        value.policyVersions = try reader["policyVersions"].readListIfPresent(memberReadingClosure: IoTClientTypes.PolicyVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPrincipalPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPrincipalPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPrincipalPoliciesOutput()
        value.nextMarker = try reader["nextMarker"].readIfPresent()
        value.policies = try reader["policies"].readListIfPresent(memberReadingClosure: IoTClientTypes.Policy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPrincipalThingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPrincipalThingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPrincipalThingsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.things = try reader["things"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProvisioningTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProvisioningTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProvisioningTemplatesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.templates = try reader["templates"].readListIfPresent(memberReadingClosure: IoTClientTypes.ProvisioningTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProvisioningTemplateVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProvisioningTemplateVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProvisioningTemplateVersionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.versions = try reader["versions"].readListIfPresent(memberReadingClosure: IoTClientTypes.ProvisioningTemplateVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRelatedResourcesForAuditFindingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRelatedResourcesForAuditFindingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRelatedResourcesForAuditFindingOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.relatedResources = try reader["relatedResources"].readListIfPresent(memberReadingClosure: IoTClientTypes.RelatedResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRoleAliasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRoleAliasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRoleAliasesOutput()
        value.nextMarker = try reader["nextMarker"].readIfPresent()
        value.roleAliases = try reader["roleAliases"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSbomValidationResultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSbomValidationResultsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSbomValidationResultsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.validationResultSummaries = try reader["validationResultSummaries"].readListIfPresent(memberReadingClosure: IoTClientTypes.SbomValidationResultSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListScheduledAuditsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListScheduledAuditsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListScheduledAuditsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.scheduledAudits = try reader["scheduledAudits"].readListIfPresent(memberReadingClosure: IoTClientTypes.ScheduledAuditMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSecurityProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSecurityProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSecurityProfilesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.securityProfileIdentifiers = try reader["securityProfileIdentifiers"].readListIfPresent(memberReadingClosure: IoTClientTypes.SecurityProfileIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSecurityProfilesForTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSecurityProfilesForTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSecurityProfilesForTargetOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.securityProfileTargetMappings = try reader["securityProfileTargetMappings"].readListIfPresent(memberReadingClosure: IoTClientTypes.SecurityProfileTargetMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListStreamsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStreamsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStreamsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.streams = try reader["streams"].readListIfPresent(memberReadingClosure: IoTClientTypes.StreamSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: IoTClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTargetsForPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTargetsForPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTargetsForPolicyOutput()
        value.nextMarker = try reader["nextMarker"].readIfPresent()
        value.targets = try reader["targets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTargetsForSecurityProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTargetsForSecurityProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTargetsForSecurityProfileOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.securityProfileTargets = try reader["securityProfileTargets"].readListIfPresent(memberReadingClosure: IoTClientTypes.SecurityProfileTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListThingGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListThingGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListThingGroupsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.thingGroups = try reader["thingGroups"].readListIfPresent(memberReadingClosure: IoTClientTypes.GroupNameAndArn.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListThingGroupsForThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListThingGroupsForThingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListThingGroupsForThingOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.thingGroups = try reader["thingGroups"].readListIfPresent(memberReadingClosure: IoTClientTypes.GroupNameAndArn.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListThingPrincipalsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListThingPrincipalsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListThingPrincipalsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.principals = try reader["principals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListThingRegistrationTaskReportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListThingRegistrationTaskReportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListThingRegistrationTaskReportsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.reportType = try reader["reportType"].readIfPresent()
        value.resourceLinks = try reader["resourceLinks"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListThingRegistrationTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListThingRegistrationTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListThingRegistrationTasksOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.taskIds = try reader["taskIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListThingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListThingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListThingsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.things = try reader["things"].readListIfPresent(memberReadingClosure: IoTClientTypes.ThingAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListThingsInBillingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListThingsInBillingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListThingsInBillingGroupOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.things = try reader["things"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListThingsInThingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListThingsInThingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListThingsInThingGroupOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.things = try reader["things"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListThingTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListThingTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListThingTypesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.thingTypes = try reader["thingTypes"].readListIfPresent(memberReadingClosure: IoTClientTypes.ThingTypeDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTopicRuleDestinationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTopicRuleDestinationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTopicRuleDestinationsOutput()
        value.destinationSummaries = try reader["destinationSummaries"].readListIfPresent(memberReadingClosure: IoTClientTypes.TopicRuleDestinationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTopicRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTopicRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTopicRulesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.rules = try reader["rules"].readListIfPresent(memberReadingClosure: IoTClientTypes.TopicRuleListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListV2LoggingLevelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListV2LoggingLevelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListV2LoggingLevelsOutput()
        value.logTargetConfigurations = try reader["logTargetConfigurations"].readListIfPresent(memberReadingClosure: IoTClientTypes.LogTargetConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListViolationEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListViolationEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListViolationEventsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.violationEvents = try reader["violationEvents"].readListIfPresent(memberReadingClosure: IoTClientTypes.ViolationEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutVerificationStateOnViolationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutVerificationStateOnViolationOutput {
        return PutVerificationStateOnViolationOutput()
    }
}

extension RegisterCACertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterCACertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterCACertificateOutput()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateId = try reader["certificateId"].readIfPresent()
        return value
    }
}

extension RegisterCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterCertificateOutput()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateId = try reader["certificateId"].readIfPresent()
        return value
    }
}

extension RegisterCertificateWithoutCAOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterCertificateWithoutCAOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterCertificateWithoutCAOutput()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateId = try reader["certificateId"].readIfPresent()
        return value
    }
}

extension RegisterThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterThingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterThingOutput()
        value.certificatePem = try reader["certificatePem"].readIfPresent()
        value.resourceArns = try reader["resourceArns"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RejectCertificateTransferOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RejectCertificateTransferOutput {
        return RejectCertificateTransferOutput()
    }
}

extension RemoveThingFromBillingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveThingFromBillingGroupOutput {
        return RemoveThingFromBillingGroupOutput()
    }
}

extension RemoveThingFromThingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveThingFromThingGroupOutput {
        return RemoveThingFromThingGroupOutput()
    }
}

extension ReplaceTopicRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ReplaceTopicRuleOutput {
        return ReplaceTopicRuleOutput()
    }
}

extension SearchIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchIndexOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.thingGroups = try reader["thingGroups"].readListIfPresent(memberReadingClosure: IoTClientTypes.ThingGroupDocument.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.things = try reader["things"].readListIfPresent(memberReadingClosure: IoTClientTypes.ThingDocument.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SetDefaultAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetDefaultAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SetDefaultAuthorizerOutput()
        value.authorizerArn = try reader["authorizerArn"].readIfPresent()
        value.authorizerName = try reader["authorizerName"].readIfPresent()
        return value
    }
}

extension SetDefaultPolicyVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetDefaultPolicyVersionOutput {
        return SetDefaultPolicyVersionOutput()
    }
}

extension SetLoggingOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetLoggingOptionsOutput {
        return SetLoggingOptionsOutput()
    }
}

extension SetV2LoggingLevelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetV2LoggingLevelOutput {
        return SetV2LoggingLevelOutput()
    }
}

extension SetV2LoggingOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetV2LoggingOptionsOutput {
        return SetV2LoggingOptionsOutput()
    }
}

extension StartAuditMitigationActionsTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAuditMitigationActionsTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAuditMitigationActionsTaskOutput()
        value.taskId = try reader["taskId"].readIfPresent()
        return value
    }
}

extension StartDetectMitigationActionsTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDetectMitigationActionsTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDetectMitigationActionsTaskOutput()
        value.taskId = try reader["taskId"].readIfPresent()
        return value
    }
}

extension StartOnDemandAuditTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartOnDemandAuditTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartOnDemandAuditTaskOutput()
        value.taskId = try reader["taskId"].readIfPresent()
        return value
    }
}

extension StartThingRegistrationTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartThingRegistrationTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartThingRegistrationTaskOutput()
        value.taskId = try reader["taskId"].readIfPresent()
        return value
    }
}

extension StopThingRegistrationTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopThingRegistrationTaskOutput {
        return StopThingRegistrationTaskOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TestAuthorizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestAuthorizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestAuthorizationOutput()
        value.authResults = try reader["authResults"].readListIfPresent(memberReadingClosure: IoTClientTypes.AuthResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TestInvokeAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestInvokeAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestInvokeAuthorizerOutput()
        value.disconnectAfterInSeconds = try reader["disconnectAfterInSeconds"].readIfPresent()
        value.isAuthenticated = try reader["isAuthenticated"].readIfPresent()
        value.policyDocuments = try reader["policyDocuments"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.principalId = try reader["principalId"].readIfPresent()
        value.refreshAfterInSeconds = try reader["refreshAfterInSeconds"].readIfPresent()
        return value
    }
}

extension TransferCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TransferCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TransferCertificateOutput()
        value.transferredCertificateArn = try reader["transferredCertificateArn"].readIfPresent()
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAccountAuditConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccountAuditConfigurationOutput {
        return UpdateAccountAuditConfigurationOutput()
    }
}

extension UpdateAuditSuppressionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAuditSuppressionOutput {
        return UpdateAuditSuppressionOutput()
    }
}

extension UpdateAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAuthorizerOutput()
        value.authorizerArn = try reader["authorizerArn"].readIfPresent()
        value.authorizerName = try reader["authorizerName"].readIfPresent()
        return value
    }
}

extension UpdateBillingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBillingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBillingGroupOutput()
        value.version = try reader["version"].readIfPresent() ?? 0
        return value
    }
}

extension UpdateCACertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCACertificateOutput {
        return UpdateCACertificateOutput()
    }
}

extension UpdateCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCertificateOutput {
        return UpdateCertificateOutput()
    }
}

extension UpdateCertificateProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCertificateProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCertificateProviderOutput()
        value.certificateProviderArn = try reader["certificateProviderArn"].readIfPresent()
        value.certificateProviderName = try reader["certificateProviderName"].readIfPresent()
        return value
    }
}

extension UpdateCustomMetricOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCustomMetricOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCustomMetricOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.displayName = try reader["displayName"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metricArn = try reader["metricArn"].readIfPresent()
        value.metricName = try reader["metricName"].readIfPresent()
        value.metricType = try reader["metricType"].readIfPresent()
        return value
    }
}

extension UpdateDimensionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDimensionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDimensionOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.stringValues = try reader["stringValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension UpdateDomainConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainConfigurationOutput()
        value.domainConfigurationArn = try reader["domainConfigurationArn"].readIfPresent()
        value.domainConfigurationName = try reader["domainConfigurationName"].readIfPresent()
        return value
    }
}

extension UpdateDynamicThingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDynamicThingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDynamicThingGroupOutput()
        value.version = try reader["version"].readIfPresent() ?? 0
        return value
    }
}

extension UpdateEventConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEventConfigurationsOutput {
        return UpdateEventConfigurationsOutput()
    }
}

extension UpdateFleetMetricOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFleetMetricOutput {
        return UpdateFleetMetricOutput()
    }
}

extension UpdateIndexingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIndexingConfigurationOutput {
        return UpdateIndexingConfigurationOutput()
    }
}

extension UpdateJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateJobOutput {
        return UpdateJobOutput()
    }
}

extension UpdateMitigationActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMitigationActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMitigationActionOutput()
        value.actionArn = try reader["actionArn"].readIfPresent()
        value.actionId = try reader["actionId"].readIfPresent()
        return value
    }
}

extension UpdatePackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePackageOutput {
        return UpdatePackageOutput()
    }
}

extension UpdatePackageConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePackageConfigurationOutput {
        return UpdatePackageConfigurationOutput()
    }
}

extension UpdatePackageVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePackageVersionOutput {
        return UpdatePackageVersionOutput()
    }
}

extension UpdateProvisioningTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProvisioningTemplateOutput {
        return UpdateProvisioningTemplateOutput()
    }
}

extension UpdateRoleAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRoleAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRoleAliasOutput()
        value.roleAlias = try reader["roleAlias"].readIfPresent()
        value.roleAliasArn = try reader["roleAliasArn"].readIfPresent()
        return value
    }
}

extension UpdateScheduledAuditOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateScheduledAuditOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateScheduledAuditOutput()
        value.scheduledAuditArn = try reader["scheduledAuditArn"].readIfPresent()
        return value
    }
}

extension UpdateSecurityProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSecurityProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSecurityProfileOutput()
        value.additionalMetricsToRetain = try reader["additionalMetricsToRetain"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.additionalMetricsToRetainV2 = try reader["additionalMetricsToRetainV2"].readListIfPresent(memberReadingClosure: IoTClientTypes.MetricToRetain.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.alertTargets = try reader["alertTargets"].readMapIfPresent(valueReadingClosure: IoTClientTypes.AlertTarget.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.behaviors = try reader["behaviors"].readListIfPresent(memberReadingClosure: IoTClientTypes.Behavior.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metricsExportConfig = try reader["metricsExportConfig"].readIfPresent(with: IoTClientTypes.MetricsExportConfig.read(from:))
        value.securityProfileArn = try reader["securityProfileArn"].readIfPresent()
        value.securityProfileDescription = try reader["securityProfileDescription"].readIfPresent()
        value.securityProfileName = try reader["securityProfileName"].readIfPresent()
        value.version = try reader["version"].readIfPresent() ?? 0
        return value
    }
}

extension UpdateStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStreamOutput()
        value.description = try reader["description"].readIfPresent()
        value.streamArn = try reader["streamArn"].readIfPresent()
        value.streamId = try reader["streamId"].readIfPresent()
        value.streamVersion = try reader["streamVersion"].readIfPresent()
        return value
    }
}

extension UpdateThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateThingOutput {
        return UpdateThingOutput()
    }
}

extension UpdateThingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateThingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateThingGroupOutput()
        value.version = try reader["version"].readIfPresent() ?? 0
        return value
    }
}

extension UpdateThingGroupsForThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateThingGroupsForThingOutput {
        return UpdateThingGroupsForThingOutput()
    }
}

extension UpdateTopicRuleDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTopicRuleDestinationOutput {
        return UpdateTopicRuleDestinationOutput()
    }
}

extension ValidateSecurityProfileBehaviorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ValidateSecurityProfileBehaviorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ValidateSecurityProfileBehaviorsOutput()
        value.valid = try reader["valid"].readIfPresent() ?? false
        value.validationErrors = try reader["validationErrors"].readListIfPresent(memberReadingClosure: IoTClientTypes.ValidationError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

enum AcceptCertificateTransferOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TransferAlreadyCompletedException": return try TransferAlreadyCompletedException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddThingToBillingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddThingToThingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateSbomWithPackageVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateTargetsWithJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachPrincipalPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachSecurityProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachThingPrincipalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelAuditMitigationActionsTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelAuditTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelCertificateTransferOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TransferAlreadyCompletedException": return try TransferAlreadyCompletedException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelDetectMitigationActionsTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelJobExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidStateTransitionException": return try InvalidStateTransitionException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ClearDefaultAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConfirmTopicRuleDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAuditSuppressionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBillingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCertificateFromCsrOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCertificateProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCustomMetricOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDimensionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CertificateValidationException": return try CertificateValidationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDynamicThingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidQueryException": return try InvalidQueryException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFleetMetricOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IndexNotReadyException": return try IndexNotReadyException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidAggregationException": return try InvalidAggregationException.makeError(baseError: baseError)
            case "InvalidQueryException": return try InvalidQueryException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateJobTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKeysAndCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMitigationActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOTAUpdateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePackageVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MalformedPolicyException": return try MalformedPolicyException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePolicyVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MalformedPolicyException": return try MalformedPolicyException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "VersionsLimitExceededException": return try VersionsLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProvisioningClaimOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProvisioningTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProvisioningTemplateVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "VersionsLimitExceededException": return try VersionsLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRoleAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateScheduledAuditOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSecurityProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateThingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateThingTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTopicRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "SqlParseException": return try SqlParseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTopicRuleDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccountAuditConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAuditSuppressionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeleteConflictException": return try DeleteConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBillingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCACertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CertificateStateException": return try CertificateStateException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CertificateStateException": return try CertificateStateException.makeError(baseError: baseError)
            case "DeleteConflictException": return try DeleteConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCertificateProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeleteConflictException": return try DeleteConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCustomMetricOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDimensionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDynamicThingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFleetMetricOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidStateTransitionException": return try InvalidStateTransitionException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteJobExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidStateTransitionException": return try InvalidStateTransitionException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteJobTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMitigationActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOTAUpdateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePackageVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeleteConflictException": return try DeleteConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePolicyVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeleteConflictException": return try DeleteConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProvisioningTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "DeleteConflictException": return try DeleteConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProvisioningTemplateVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "DeleteConflictException": return try DeleteConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRegistrationCodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRoleAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeleteConflictException": return try DeleteConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteScheduledAuditOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSecurityProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeleteConflictException": return try DeleteConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteThingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteThingTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTopicRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTopicRuleDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteV2LoggingLevelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeprecateThingTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountAuditConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAuditFindingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAuditMitigationActionsTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAuditSuppressionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAuditTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBillingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCACertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCertificateProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCustomMetricOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDefaultAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDetectMitigationActionsTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDimensionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDomainConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFleetMetricOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeJobExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeJobTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeManagedJobTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMitigationActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProvisioningTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProvisioningTemplateVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRoleAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeScheduledAuditOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSecurityProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeThingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeThingRegistrationTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeThingTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachPrincipalPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachSecurityProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachThingPrincipalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableTopicRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateSbomFromPackageVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableTopicRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBehaviorModelTrainingSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBucketsAggregationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IndexNotReadyException": return try IndexNotReadyException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidAggregationException": return try InvalidAggregationException.makeError(baseError: baseError)
            case "InvalidQueryException": return try InvalidQueryException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCardinalityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IndexNotReadyException": return try IndexNotReadyException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidAggregationException": return try InvalidAggregationException.makeError(baseError: baseError)
            case "InvalidQueryException": return try InvalidQueryException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEffectivePoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIndexingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJobDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLoggingOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOTAUpdateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPackageConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPackageVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPercentilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IndexNotReadyException": return try IndexNotReadyException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidAggregationException": return try InvalidAggregationException.makeError(baseError: baseError)
            case "InvalidQueryException": return try InvalidQueryException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPolicyVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRegistrationCodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IndexNotReadyException": return try IndexNotReadyException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidAggregationException": return try InvalidAggregationException.makeError(baseError: baseError)
            case "InvalidQueryException": return try InvalidQueryException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTopicRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTopicRuleDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetV2LoggingOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "NotConfiguredException": return try NotConfiguredException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListActiveViolationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAttachedPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAuditFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAuditMitigationActionsExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAuditMitigationActionsTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAuditSuppressionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAuditTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAuthorizersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBillingGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCACertificatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCertificateProvidersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCertificatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCertificatesByCAOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDetectMitigationActionsExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDetectMitigationActionsTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDimensionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFleetMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIndicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJobExecutionsForJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJobExecutionsForThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJobTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListManagedJobTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMetricValuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMitigationActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOTAUpdatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOutgoingCertificatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPackagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPackageVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPolicyPrincipalsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPolicyVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPrincipalPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPrincipalThingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProvisioningTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProvisioningTemplateVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRelatedResourcesForAuditFindingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRoleAliasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSbomValidationResultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListScheduledAuditsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSecurityProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSecurityProfilesForTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStreamsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTargetsForPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTargetsForSecurityProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListThingGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListThingGroupsForThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListThingPrincipalsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListThingRegistrationTaskReportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListThingRegistrationTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListThingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListThingsInBillingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListThingsInThingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListThingTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTopicRuleDestinationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTopicRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListV2LoggingLevelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "NotConfiguredException": return try NotConfiguredException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListViolationEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutVerificationStateOnViolationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterCACertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CertificateValidationException": return try CertificateValidationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "RegistrationCodeValidationException": return try RegistrationCodeValidationException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CertificateConflictException": return try CertificateConflictException.makeError(baseError: baseError)
            case "CertificateStateException": return try CertificateStateException.makeError(baseError: baseError)
            case "CertificateValidationException": return try CertificateValidationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterCertificateWithoutCAOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CertificateStateException": return try CertificateStateException.makeError(baseError: baseError)
            case "CertificateValidationException": return try CertificateValidationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceRegistrationFailureException": return try ResourceRegistrationFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RejectCertificateTransferOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TransferAlreadyCompletedException": return try TransferAlreadyCompletedException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveThingFromBillingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveThingFromThingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ReplaceTopicRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "SqlParseException": return try SqlParseException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IndexNotReadyException": return try IndexNotReadyException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidQueryException": return try InvalidQueryException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetDefaultAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetDefaultPolicyVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetLoggingOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetV2LoggingLevelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotConfiguredException": return try NotConfiguredException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetV2LoggingOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAuditMitigationActionsTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TaskAlreadyExistsException": return try TaskAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDetectMitigationActionsTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TaskAlreadyExistsException": return try TaskAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartOnDemandAuditTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartThingRegistrationTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopThingRegistrationTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestAuthorizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestInvokeAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidResponseException": return try InvalidResponseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TransferCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CertificateStateException": return try CertificateStateException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TransferConflictException": return try TransferConflictException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccountAuditConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAuditSuppressionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBillingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCACertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CertificateStateException": return try CertificateStateException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCertificateProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCustomMetricOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDimensionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CertificateValidationException": return try CertificateValidationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDynamicThingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidQueryException": return try InvalidQueryException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEventConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFleetMetricOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IndexNotReadyException": return try IndexNotReadyException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidAggregationException": return try InvalidAggregationException.makeError(baseError: baseError)
            case "InvalidQueryException": return try InvalidQueryException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIndexingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMitigationActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePackageConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePackageVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProvisioningTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRoleAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateScheduledAuditOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSecurityProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateThingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "VersionConflictException": return try VersionConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateThingGroupsForThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTopicRuleDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingResourceUpdateException": return try ConflictingResourceUpdateException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ValidateSecurityProfileBehaviorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TransferAlreadyCompletedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TransferAlreadyCompletedException {
        let reader = baseError.errorBodyReader
        var value = TransferAlreadyCompletedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension VersionConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> VersionConflictException {
        let reader = baseError.errorBodyReader
        var value = VersionConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidStateTransitionException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidStateTransitionException {
        let reader = baseError.errorBodyReader
        var value = InvalidStateTransitionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictingResourceUpdateException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictingResourceUpdateException {
        let reader = baseError.errorBodyReader
        var value = ConflictingResourceUpdateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalException {
        let reader = baseError.errorBodyReader
        var value = InternalException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceArn = try reader["resourceArn"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CertificateValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CertificateValidationException {
        let reader = baseError.errorBodyReader
        var value = CertificateValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidQueryException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidQueryException {
        let reader = baseError.errorBodyReader
        var value = InvalidQueryException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IndexNotReadyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> IndexNotReadyException {
        let reader = baseError.errorBodyReader
        var value = IndexNotReadyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAggregationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidAggregationException {
        let reader = baseError.errorBodyReader
        var value = InvalidAggregationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MalformedPolicyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MalformedPolicyException {
        let reader = baseError.errorBodyReader
        var value = MalformedPolicyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension VersionsLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> VersionsLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = VersionsLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SqlParseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SqlParseException {
        let reader = baseError.errorBodyReader
        var value = SqlParseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DeleteConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DeleteConflictException {
        let reader = baseError.errorBodyReader
        var value = DeleteConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CertificateStateException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CertificateStateException {
        let reader = baseError.errorBodyReader
        var value = CertificateStateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotConfiguredException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotConfiguredException {
        let reader = baseError.errorBodyReader
        var value = NotConfiguredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RegistrationCodeValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RegistrationCodeValidationException {
        let reader = baseError.errorBodyReader
        var value = RegistrationCodeValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CertificateConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CertificateConflictException {
        let reader = baseError.errorBodyReader
        var value = CertificateConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceRegistrationFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceRegistrationFailureException {
        let reader = baseError.errorBodyReader
        var value = ResourceRegistrationFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TaskAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TaskAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = TaskAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResponseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidResponseException {
        let reader = baseError.errorBodyReader
        var value = InvalidResponseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TransferConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TransferConflictException {
        let reader = baseError.errorBodyReader
        var value = TransferConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoTClientTypes.Sbom {

    static func write(value: IoTClientTypes.Sbom?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Location"].write(value.s3Location, with: IoTClientTypes.S3Location.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Sbom {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Sbom()
        value.s3Location = try reader["s3Location"].readIfPresent(with: IoTClientTypes.S3Location.read(from:))
        return value
    }
}

extension IoTClientTypes.S3Location {

    static func write(value: IoTClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["key"].write(value.key)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.S3Location()
        value.bucket = try reader["bucket"].readIfPresent()
        value.key = try reader["key"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.KeyPair {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.KeyPair {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.KeyPair()
        value.publicKey = try reader["PublicKey"].readIfPresent()
        value.privateKey = try reader["PrivateKey"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.TopicRuleDestination {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.TopicRuleDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.TopicRuleDestination()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.httpUrlProperties = try reader["httpUrlProperties"].readIfPresent(with: IoTClientTypes.HttpUrlDestinationProperties.read(from:))
        value.vpcProperties = try reader["vpcProperties"].readIfPresent(with: IoTClientTypes.VpcDestinationProperties.read(from:))
        return value
    }
}

extension IoTClientTypes.VpcDestinationProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.VpcDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.VpcDestinationProperties()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.HttpUrlDestinationProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.HttpUrlDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.HttpUrlDestinationProperties()
        value.confirmationUrl = try reader["confirmationUrl"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AuditNotificationTarget {

    static func write(value: IoTClientTypes.AuditNotificationTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["roleArn"].write(value.roleArn)
        try writer["targetArn"].write(value.targetArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuditNotificationTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuditNotificationTarget()
        value.targetArn = try reader["targetArn"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        return value
    }
}

extension IoTClientTypes.AuditCheckConfiguration {

    static func write(value: IoTClientTypes.AuditCheckConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuditCheckConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuditCheckConfiguration()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        return value
    }
}

extension IoTClientTypes.AuditFinding {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuditFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuditFinding()
        value.findingId = try reader["findingId"].readIfPresent()
        value.taskId = try reader["taskId"].readIfPresent()
        value.checkName = try reader["checkName"].readIfPresent()
        value.taskStartTime = try reader["taskStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.findingTime = try reader["findingTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.severity = try reader["severity"].readIfPresent()
        value.nonCompliantResource = try reader["nonCompliantResource"].readIfPresent(with: IoTClientTypes.NonCompliantResource.read(from:))
        value.relatedResources = try reader["relatedResources"].readListIfPresent(memberReadingClosure: IoTClientTypes.RelatedResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reasonForNonCompliance = try reader["reasonForNonCompliance"].readIfPresent()
        value.reasonForNonComplianceCode = try reader["reasonForNonComplianceCode"].readIfPresent()
        value.isSuppressed = try reader["isSuppressed"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.RelatedResource {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.RelatedResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.RelatedResource()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent(with: IoTClientTypes.ResourceIdentifier.read(from:))
        value.additionalInfo = try reader["additionalInfo"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.ResourceIdentifier {

    static func write(value: IoTClientTypes.ResourceIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["account"].write(value.account)
        try writer["caCertificateId"].write(value.caCertificateId)
        try writer["clientId"].write(value.clientId)
        try writer["cognitoIdentityPoolId"].write(value.cognitoIdentityPoolId)
        try writer["deviceCertificateArn"].write(value.deviceCertificateArn)
        try writer["deviceCertificateId"].write(value.deviceCertificateId)
        try writer["iamRoleArn"].write(value.iamRoleArn)
        try writer["issuerCertificateIdentifier"].write(value.issuerCertificateIdentifier, with: IoTClientTypes.IssuerCertificateIdentifier.write(value:to:))
        try writer["policyVersionIdentifier"].write(value.policyVersionIdentifier, with: IoTClientTypes.PolicyVersionIdentifier.write(value:to:))
        try writer["roleAliasArn"].write(value.roleAliasArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ResourceIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ResourceIdentifier()
        value.deviceCertificateId = try reader["deviceCertificateId"].readIfPresent()
        value.caCertificateId = try reader["caCertificateId"].readIfPresent()
        value.cognitoIdentityPoolId = try reader["cognitoIdentityPoolId"].readIfPresent()
        value.clientId = try reader["clientId"].readIfPresent()
        value.policyVersionIdentifier = try reader["policyVersionIdentifier"].readIfPresent(with: IoTClientTypes.PolicyVersionIdentifier.read(from:))
        value.account = try reader["account"].readIfPresent()
        value.iamRoleArn = try reader["iamRoleArn"].readIfPresent()
        value.roleAliasArn = try reader["roleAliasArn"].readIfPresent()
        value.issuerCertificateIdentifier = try reader["issuerCertificateIdentifier"].readIfPresent(with: IoTClientTypes.IssuerCertificateIdentifier.read(from:))
        value.deviceCertificateArn = try reader["deviceCertificateArn"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.IssuerCertificateIdentifier {

    static func write(value: IoTClientTypes.IssuerCertificateIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["issuerCertificateSerialNumber"].write(value.issuerCertificateSerialNumber)
        try writer["issuerCertificateSubject"].write(value.issuerCertificateSubject)
        try writer["issuerId"].write(value.issuerId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.IssuerCertificateIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.IssuerCertificateIdentifier()
        value.issuerCertificateSubject = try reader["issuerCertificateSubject"].readIfPresent()
        value.issuerId = try reader["issuerId"].readIfPresent()
        value.issuerCertificateSerialNumber = try reader["issuerCertificateSerialNumber"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.PolicyVersionIdentifier {

    static func write(value: IoTClientTypes.PolicyVersionIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyName"].write(value.policyName)
        try writer["policyVersionId"].write(value.policyVersionId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.PolicyVersionIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.PolicyVersionIdentifier()
        value.policyName = try reader["policyName"].readIfPresent()
        value.policyVersionId = try reader["policyVersionId"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.NonCompliantResource {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.NonCompliantResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.NonCompliantResource()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent(with: IoTClientTypes.ResourceIdentifier.read(from:))
        value.additionalInfo = try reader["additionalInfo"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.TaskStatisticsForAuditCheck {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.TaskStatisticsForAuditCheck {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.TaskStatisticsForAuditCheck()
        value.totalFindingsCount = try reader["totalFindingsCount"].readIfPresent()
        value.failedFindingsCount = try reader["failedFindingsCount"].readIfPresent()
        value.succeededFindingsCount = try reader["succeededFindingsCount"].readIfPresent()
        value.skippedFindingsCount = try reader["skippedFindingsCount"].readIfPresent()
        value.canceledFindingsCount = try reader["canceledFindingsCount"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AuditMitigationActionsTaskTarget {

    static func write(value: IoTClientTypes.AuditMitigationActionsTaskTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["auditCheckToReasonCodeFilter"].writeMap(value.auditCheckToReasonCodeFilter, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["auditTaskId"].write(value.auditTaskId)
        try writer["findingIds"].writeList(value.findingIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuditMitigationActionsTaskTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuditMitigationActionsTaskTarget()
        value.auditTaskId = try reader["auditTaskId"].readIfPresent()
        value.findingIds = try reader["findingIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.auditCheckToReasonCodeFilter = try reader["auditCheckToReasonCodeFilter"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.MitigationAction {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.MitigationAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.MitigationAction()
        value.name = try reader["name"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.actionParams = try reader["actionParams"].readIfPresent(with: IoTClientTypes.MitigationActionParams.read(from:))
        return value
    }
}

extension IoTClientTypes.MitigationActionParams {

    static func write(value: IoTClientTypes.MitigationActionParams?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addThingsToThingGroupParams"].write(value.addThingsToThingGroupParams, with: IoTClientTypes.AddThingsToThingGroupParams.write(value:to:))
        try writer["enableIoTLoggingParams"].write(value.enableIoTLoggingParams, with: IoTClientTypes.EnableIoTLoggingParams.write(value:to:))
        try writer["publishFindingToSnsParams"].write(value.publishFindingToSnsParams, with: IoTClientTypes.PublishFindingToSnsParams.write(value:to:))
        try writer["replaceDefaultPolicyVersionParams"].write(value.replaceDefaultPolicyVersionParams, with: IoTClientTypes.ReplaceDefaultPolicyVersionParams.write(value:to:))
        try writer["updateCACertificateParams"].write(value.updateCACertificateParams, with: IoTClientTypes.UpdateCACertificateParams.write(value:to:))
        try writer["updateDeviceCertificateParams"].write(value.updateDeviceCertificateParams, with: IoTClientTypes.UpdateDeviceCertificateParams.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.MitigationActionParams {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.MitigationActionParams()
        value.updateDeviceCertificateParams = try reader["updateDeviceCertificateParams"].readIfPresent(with: IoTClientTypes.UpdateDeviceCertificateParams.read(from:))
        value.updateCACertificateParams = try reader["updateCACertificateParams"].readIfPresent(with: IoTClientTypes.UpdateCACertificateParams.read(from:))
        value.addThingsToThingGroupParams = try reader["addThingsToThingGroupParams"].readIfPresent(with: IoTClientTypes.AddThingsToThingGroupParams.read(from:))
        value.replaceDefaultPolicyVersionParams = try reader["replaceDefaultPolicyVersionParams"].readIfPresent(with: IoTClientTypes.ReplaceDefaultPolicyVersionParams.read(from:))
        value.enableIoTLoggingParams = try reader["enableIoTLoggingParams"].readIfPresent(with: IoTClientTypes.EnableIoTLoggingParams.read(from:))
        value.publishFindingToSnsParams = try reader["publishFindingToSnsParams"].readIfPresent(with: IoTClientTypes.PublishFindingToSnsParams.read(from:))
        return value
    }
}

extension IoTClientTypes.PublishFindingToSnsParams {

    static func write(value: IoTClientTypes.PublishFindingToSnsParams?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["topicArn"].write(value.topicArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.PublishFindingToSnsParams {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.PublishFindingToSnsParams()
        value.topicArn = try reader["topicArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.EnableIoTLoggingParams {

    static func write(value: IoTClientTypes.EnableIoTLoggingParams?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logLevel"].write(value.logLevel)
        try writer["roleArnForLogging"].write(value.roleArnForLogging)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.EnableIoTLoggingParams {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.EnableIoTLoggingParams()
        value.roleArnForLogging = try reader["roleArnForLogging"].readIfPresent() ?? ""
        value.logLevel = try reader["logLevel"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTClientTypes.ReplaceDefaultPolicyVersionParams {

    static func write(value: IoTClientTypes.ReplaceDefaultPolicyVersionParams?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["templateName"].write(value.templateName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ReplaceDefaultPolicyVersionParams {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ReplaceDefaultPolicyVersionParams()
        value.templateName = try reader["templateName"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTClientTypes.AddThingsToThingGroupParams {

    static func write(value: IoTClientTypes.AddThingsToThingGroupParams?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["overrideDynamicGroups"].write(value.overrideDynamicGroups)
        try writer["thingGroupNames"].writeList(value.thingGroupNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AddThingsToThingGroupParams {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AddThingsToThingGroupParams()
        value.thingGroupNames = try reader["thingGroupNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.overrideDynamicGroups = try reader["overrideDynamicGroups"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.UpdateCACertificateParams {

    static func write(value: IoTClientTypes.UpdateCACertificateParams?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.UpdateCACertificateParams {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.UpdateCACertificateParams()
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTClientTypes.UpdateDeviceCertificateParams {

    static func write(value: IoTClientTypes.UpdateDeviceCertificateParams?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.UpdateDeviceCertificateParams {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.UpdateDeviceCertificateParams()
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTClientTypes.TaskStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.TaskStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.TaskStatistics()
        value.totalChecks = try reader["totalChecks"].readIfPresent()
        value.inProgressChecks = try reader["inProgressChecks"].readIfPresent()
        value.waitingForDataCollectionChecks = try reader["waitingForDataCollectionChecks"].readIfPresent()
        value.compliantChecks = try reader["compliantChecks"].readIfPresent()
        value.nonCompliantChecks = try reader["nonCompliantChecks"].readIfPresent()
        value.failedChecks = try reader["failedChecks"].readIfPresent()
        value.canceledChecks = try reader["canceledChecks"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AuditCheckDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuditCheckDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuditCheckDetails()
        value.checkRunStatus = try reader["checkRunStatus"].readIfPresent()
        value.checkCompliant = try reader["checkCompliant"].readIfPresent()
        value.totalResourcesCount = try reader["totalResourcesCount"].readIfPresent()
        value.nonCompliantResourcesCount = try reader["nonCompliantResourcesCount"].readIfPresent()
        value.suppressedNonCompliantResourcesCount = try reader["suppressedNonCompliantResourcesCount"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AuthorizerDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuthorizerDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuthorizerDescription()
        value.authorizerName = try reader["authorizerName"].readIfPresent()
        value.authorizerArn = try reader["authorizerArn"].readIfPresent()
        value.authorizerFunctionArn = try reader["authorizerFunctionArn"].readIfPresent()
        value.tokenKeyName = try reader["tokenKeyName"].readIfPresent()
        value.tokenSigningPublicKeys = try reader["tokenSigningPublicKeys"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.signingDisabled = try reader["signingDisabled"].readIfPresent()
        value.enableCachingForHttp = try reader["enableCachingForHttp"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.BillingGroupProperties {

    static func write(value: IoTClientTypes.BillingGroupProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billingGroupDescription"].write(value.billingGroupDescription)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.BillingGroupProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.BillingGroupProperties()
        value.billingGroupDescription = try reader["billingGroupDescription"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.BillingGroupMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.BillingGroupMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.BillingGroupMetadata()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.CACertificateDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.CACertificateDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.CACertificateDescription()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateId = try reader["certificateId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.certificatePem = try reader["certificatePem"].readIfPresent()
        value.ownedBy = try reader["ownedBy"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.autoRegistrationStatus = try reader["autoRegistrationStatus"].readIfPresent()
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.customerVersion = try reader["customerVersion"].readIfPresent()
        value.generationId = try reader["generationId"].readIfPresent()
        value.validity = try reader["validity"].readIfPresent(with: IoTClientTypes.CertificateValidity.read(from:))
        value.certificateMode = try reader["certificateMode"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.CertificateValidity {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.CertificateValidity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.CertificateValidity()
        value.notBefore = try reader["notBefore"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.notAfter = try reader["notAfter"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.RegistrationConfig {

    static func write(value: IoTClientTypes.RegistrationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleArn"].write(value.roleArn)
        try writer["templateBody"].write(value.templateBody)
        try writer["templateName"].write(value.templateName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.RegistrationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.RegistrationConfig()
        value.templateBody = try reader["templateBody"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.templateName = try reader["templateName"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.CertificateDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.CertificateDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.CertificateDescription()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateId = try reader["certificateId"].readIfPresent()
        value.caCertificateId = try reader["caCertificateId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.certificatePem = try reader["certificatePem"].readIfPresent()
        value.ownedBy = try reader["ownedBy"].readIfPresent()
        value.previousOwnedBy = try reader["previousOwnedBy"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.customerVersion = try reader["customerVersion"].readIfPresent()
        value.transferData = try reader["transferData"].readIfPresent(with: IoTClientTypes.TransferData.read(from:))
        value.generationId = try reader["generationId"].readIfPresent()
        value.validity = try reader["validity"].readIfPresent(with: IoTClientTypes.CertificateValidity.read(from:))
        value.certificateMode = try reader["certificateMode"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.TransferData {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.TransferData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.TransferData()
        value.transferMessage = try reader["transferMessage"].readIfPresent()
        value.rejectReason = try reader["rejectReason"].readIfPresent()
        value.transferDate = try reader["transferDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.acceptDate = try reader["acceptDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.rejectDate = try reader["rejectDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.DetectMitigationActionsTaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.DetectMitigationActionsTaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.DetectMitigationActionsTaskSummary()
        value.taskId = try reader["taskId"].readIfPresent()
        value.taskStatus = try reader["taskStatus"].readIfPresent()
        value.taskStartTime = try reader["taskStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.taskEndTime = try reader["taskEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.target = try reader["target"].readIfPresent(with: IoTClientTypes.DetectMitigationActionsTaskTarget.read(from:))
        value.violationEventOccurrenceRange = try reader["violationEventOccurrenceRange"].readIfPresent(with: IoTClientTypes.ViolationEventOccurrenceRange.read(from:))
        value.onlyActiveViolationsIncluded = try reader["onlyActiveViolationsIncluded"].readIfPresent() ?? false
        value.suppressedAlertsIncluded = try reader["suppressedAlertsIncluded"].readIfPresent() ?? false
        value.actionsDefinition = try reader["actionsDefinition"].readListIfPresent(memberReadingClosure: IoTClientTypes.MitigationAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.taskStatistics = try reader["taskStatistics"].readIfPresent(with: IoTClientTypes.DetectMitigationActionsTaskStatistics.read(from:))
        return value
    }
}

extension IoTClientTypes.DetectMitigationActionsTaskStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.DetectMitigationActionsTaskStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.DetectMitigationActionsTaskStatistics()
        value.actionsExecuted = try reader["actionsExecuted"].readIfPresent()
        value.actionsSkipped = try reader["actionsSkipped"].readIfPresent()
        value.actionsFailed = try reader["actionsFailed"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.ViolationEventOccurrenceRange {

    static func write(value: IoTClientTypes.ViolationEventOccurrenceRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ViolationEventOccurrenceRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ViolationEventOccurrenceRange()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IoTClientTypes.DetectMitigationActionsTaskTarget {

    static func write(value: IoTClientTypes.DetectMitigationActionsTaskTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["behaviorName"].write(value.behaviorName)
        try writer["securityProfileName"].write(value.securityProfileName)
        try writer["violationIds"].writeList(value.violationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.DetectMitigationActionsTaskTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.DetectMitigationActionsTaskTarget()
        value.violationIds = try reader["violationIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityProfileName = try reader["securityProfileName"].readIfPresent()
        value.behaviorName = try reader["behaviorName"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.ServerCertificateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ServerCertificateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ServerCertificateSummary()
        value.serverCertificateArn = try reader["serverCertificateArn"].readIfPresent()
        value.serverCertificateStatus = try reader["serverCertificateStatus"].readIfPresent()
        value.serverCertificateStatusDetail = try reader["serverCertificateStatusDetail"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AuthorizerConfig {

    static func write(value: IoTClientTypes.AuthorizerConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowAuthorizerOverride"].write(value.allowAuthorizerOverride)
        try writer["defaultAuthorizerName"].write(value.defaultAuthorizerName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuthorizerConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuthorizerConfig()
        value.defaultAuthorizerName = try reader["defaultAuthorizerName"].readIfPresent()
        value.allowAuthorizerOverride = try reader["allowAuthorizerOverride"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.TlsConfig {

    static func write(value: IoTClientTypes.TlsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityPolicy"].write(value.securityPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.TlsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.TlsConfig()
        value.securityPolicy = try reader["securityPolicy"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.ServerCertificateConfig {

    static func write(value: IoTClientTypes.ServerCertificateConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enableOCSPCheck"].write(value.enableOCSPCheck)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ServerCertificateConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ServerCertificateConfig()
        value.enableOCSPCheck = try reader["enableOCSPCheck"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.Configuration {

    static func write(value: IoTClientTypes.Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Configuration()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        return value
    }
}

extension IoTClientTypes.AggregationType {

    static func write(value: IoTClientTypes.AggregationType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AggregationType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AggregationType()
        value.name = try reader["name"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.Job {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Job {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Job()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobId = try reader["jobId"].readIfPresent()
        value.targetSelection = try reader["targetSelection"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.forceCanceled = try reader["forceCanceled"].readIfPresent()
        value.reasonCode = try reader["reasonCode"].readIfPresent()
        value.comment = try reader["comment"].readIfPresent()
        value.targets = try reader["targets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["description"].readIfPresent()
        value.presignedUrlConfig = try reader["presignedUrlConfig"].readIfPresent(with: IoTClientTypes.PresignedUrlConfig.read(from:))
        value.jobExecutionsRolloutConfig = try reader["jobExecutionsRolloutConfig"].readIfPresent(with: IoTClientTypes.JobExecutionsRolloutConfig.read(from:))
        value.abortConfig = try reader["abortConfig"].readIfPresent(with: IoTClientTypes.AbortConfig.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completedAt = try reader["completedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobProcessDetails = try reader["jobProcessDetails"].readIfPresent(with: IoTClientTypes.JobProcessDetails.read(from:))
        value.timeoutConfig = try reader["timeoutConfig"].readIfPresent(with: IoTClientTypes.TimeoutConfig.read(from:))
        value.namespaceId = try reader["namespaceId"].readIfPresent()
        value.jobTemplateArn = try reader["jobTemplateArn"].readIfPresent()
        value.jobExecutionsRetryConfig = try reader["jobExecutionsRetryConfig"].readIfPresent(with: IoTClientTypes.JobExecutionsRetryConfig.read(from:))
        value.documentParameters = try reader["documentParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.isConcurrent = try reader["isConcurrent"].readIfPresent()
        value.schedulingConfig = try reader["schedulingConfig"].readIfPresent(with: IoTClientTypes.SchedulingConfig.read(from:))
        value.scheduledJobRollouts = try reader["scheduledJobRollouts"].readListIfPresent(memberReadingClosure: IoTClientTypes.ScheduledJobRollout.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.destinationPackageVersions = try reader["destinationPackageVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.ScheduledJobRollout {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ScheduledJobRollout {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ScheduledJobRollout()
        value.startTime = try reader["startTime"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.SchedulingConfig {

    static func write(value: IoTClientTypes.SchedulingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endBehavior"].write(value.endBehavior)
        try writer["endTime"].write(value.endTime)
        try writer["maintenanceWindows"].writeList(value.maintenanceWindows, memberWritingClosure: IoTClientTypes.MaintenanceWindow.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["startTime"].write(value.startTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.SchedulingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.SchedulingConfig()
        value.startTime = try reader["startTime"].readIfPresent()
        value.endTime = try reader["endTime"].readIfPresent()
        value.endBehavior = try reader["endBehavior"].readIfPresent()
        value.maintenanceWindows = try reader["maintenanceWindows"].readListIfPresent(memberReadingClosure: IoTClientTypes.MaintenanceWindow.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.MaintenanceWindow {

    static func write(value: IoTClientTypes.MaintenanceWindow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["durationInMinutes"].write(value.durationInMinutes)
        try writer["startTime"].write(value.startTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.MaintenanceWindow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.MaintenanceWindow()
        value.startTime = try reader["startTime"].readIfPresent() ?? ""
        value.durationInMinutes = try reader["durationInMinutes"].readIfPresent() ?? 0
        return value
    }
}

extension IoTClientTypes.JobExecutionsRetryConfig {

    static func write(value: IoTClientTypes.JobExecutionsRetryConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["criteriaList"].writeList(value.criteriaList, memberWritingClosure: IoTClientTypes.RetryCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.JobExecutionsRetryConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.JobExecutionsRetryConfig()
        value.criteriaList = try reader["criteriaList"].readListIfPresent(memberReadingClosure: IoTClientTypes.RetryCriteria.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTClientTypes.RetryCriteria {

    static func write(value: IoTClientTypes.RetryCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["failureType"].write(value.failureType)
        try writer["numberOfRetries"].write(value.numberOfRetries)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.RetryCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.RetryCriteria()
        value.failureType = try reader["failureType"].readIfPresent() ?? .sdkUnknown("")
        value.numberOfRetries = try reader["numberOfRetries"].readIfPresent() ?? 0
        return value
    }
}

extension IoTClientTypes.TimeoutConfig {

    static func write(value: IoTClientTypes.TimeoutConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inProgressTimeoutInMinutes"].write(value.inProgressTimeoutInMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.TimeoutConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.TimeoutConfig()
        value.inProgressTimeoutInMinutes = try reader["inProgressTimeoutInMinutes"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.JobProcessDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.JobProcessDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.JobProcessDetails()
        value.processingTargets = try reader["processingTargets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.numberOfCanceledThings = try reader["numberOfCanceledThings"].readIfPresent()
        value.numberOfSucceededThings = try reader["numberOfSucceededThings"].readIfPresent()
        value.numberOfFailedThings = try reader["numberOfFailedThings"].readIfPresent()
        value.numberOfRejectedThings = try reader["numberOfRejectedThings"].readIfPresent()
        value.numberOfQueuedThings = try reader["numberOfQueuedThings"].readIfPresent()
        value.numberOfInProgressThings = try reader["numberOfInProgressThings"].readIfPresent()
        value.numberOfRemovedThings = try reader["numberOfRemovedThings"].readIfPresent()
        value.numberOfTimedOutThings = try reader["numberOfTimedOutThings"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AbortConfig {

    static func write(value: IoTClientTypes.AbortConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["criteriaList"].writeList(value.criteriaList, memberWritingClosure: IoTClientTypes.AbortCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AbortConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AbortConfig()
        value.criteriaList = try reader["criteriaList"].readListIfPresent(memberReadingClosure: IoTClientTypes.AbortCriteria.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTClientTypes.AbortCriteria {

    static func write(value: IoTClientTypes.AbortCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["failureType"].write(value.failureType)
        try writer["minNumberOfExecutedThings"].write(value.minNumberOfExecutedThings)
        try writer["thresholdPercentage"].write(value.thresholdPercentage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AbortCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AbortCriteria()
        value.failureType = try reader["failureType"].readIfPresent() ?? .sdkUnknown("")
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.thresholdPercentage = try reader["thresholdPercentage"].readIfPresent() ?? 0.0
        value.minNumberOfExecutedThings = try reader["minNumberOfExecutedThings"].readIfPresent() ?? 0
        return value
    }
}

extension IoTClientTypes.JobExecutionsRolloutConfig {

    static func write(value: IoTClientTypes.JobExecutionsRolloutConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exponentialRate"].write(value.exponentialRate, with: IoTClientTypes.ExponentialRolloutRate.write(value:to:))
        try writer["maximumPerMinute"].write(value.maximumPerMinute)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.JobExecutionsRolloutConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.JobExecutionsRolloutConfig()
        value.maximumPerMinute = try reader["maximumPerMinute"].readIfPresent()
        value.exponentialRate = try reader["exponentialRate"].readIfPresent(with: IoTClientTypes.ExponentialRolloutRate.read(from:))
        return value
    }
}

extension IoTClientTypes.ExponentialRolloutRate {

    static func write(value: IoTClientTypes.ExponentialRolloutRate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseRatePerMinute"].write(value.baseRatePerMinute)
        try writer["incrementFactor"].write(value.incrementFactor)
        try writer["rateIncreaseCriteria"].write(value.rateIncreaseCriteria, with: IoTClientTypes.RateIncreaseCriteria.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ExponentialRolloutRate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ExponentialRolloutRate()
        value.baseRatePerMinute = try reader["baseRatePerMinute"].readIfPresent() ?? 0
        value.incrementFactor = try reader["incrementFactor"].readIfPresent() ?? 0.0
        value.rateIncreaseCriteria = try reader["rateIncreaseCriteria"].readIfPresent(with: IoTClientTypes.RateIncreaseCriteria.read(from:))
        return value
    }
}

extension IoTClientTypes.RateIncreaseCriteria {

    static func write(value: IoTClientTypes.RateIncreaseCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["numberOfNotifiedThings"].write(value.numberOfNotifiedThings)
        try writer["numberOfSucceededThings"].write(value.numberOfSucceededThings)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.RateIncreaseCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.RateIncreaseCriteria()
        value.numberOfNotifiedThings = try reader["numberOfNotifiedThings"].readIfPresent()
        value.numberOfSucceededThings = try reader["numberOfSucceededThings"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.PresignedUrlConfig {

    static func write(value: IoTClientTypes.PresignedUrlConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expiresInSec"].write(value.expiresInSec)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.PresignedUrlConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.PresignedUrlConfig()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.expiresInSec = try reader["expiresInSec"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.JobExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.JobExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.JobExecution()
        value.jobId = try reader["jobId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.forceCanceled = try reader["forceCanceled"].readIfPresent()
        value.statusDetails = try reader["statusDetails"].readIfPresent(with: IoTClientTypes.JobExecutionStatusDetails.read(from:))
        value.thingArn = try reader["thingArn"].readIfPresent()
        value.queuedAt = try reader["queuedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executionNumber = try reader["executionNumber"].readIfPresent()
        value.versionNumber = try reader["versionNumber"].readIfPresent() ?? 0
        value.approximateSecondsBeforeTimedOut = try reader["approximateSecondsBeforeTimedOut"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.JobExecutionStatusDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.JobExecutionStatusDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.JobExecutionStatusDetails()
        value.detailsMap = try reader["detailsMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.DocumentParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.DocumentParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.DocumentParameter()
        value.key = try reader["key"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.regex = try reader["regex"].readIfPresent()
        value.example = try reader["example"].readIfPresent()
        value.`optional` = try reader["optional"].readIfPresent() ?? false
        return value
    }
}

extension IoTClientTypes.ProvisioningHook {

    static func write(value: IoTClientTypes.ProvisioningHook?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payloadVersion"].write(value.payloadVersion)
        try writer["targetArn"].write(value.targetArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ProvisioningHook {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ProvisioningHook()
        value.payloadVersion = try reader["payloadVersion"].readIfPresent()
        value.targetArn = try reader["targetArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.RoleAliasDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.RoleAliasDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.RoleAliasDescription()
        value.roleAlias = try reader["roleAlias"].readIfPresent()
        value.roleAliasArn = try reader["roleAliasArn"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.credentialDurationSeconds = try reader["credentialDurationSeconds"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.Behavior {

    static func write(value: IoTClientTypes.Behavior?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["criteria"].write(value.criteria, with: IoTClientTypes.BehaviorCriteria.write(value:to:))
        try writer["exportMetric"].write(value.exportMetric)
        try writer["metric"].write(value.metric)
        try writer["metricDimension"].write(value.metricDimension, with: IoTClientTypes.MetricDimension.write(value:to:))
        try writer["name"].write(value.name)
        try writer["suppressAlerts"].write(value.suppressAlerts)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Behavior {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Behavior()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.metric = try reader["metric"].readIfPresent()
        value.metricDimension = try reader["metricDimension"].readIfPresent(with: IoTClientTypes.MetricDimension.read(from:))
        value.criteria = try reader["criteria"].readIfPresent(with: IoTClientTypes.BehaviorCriteria.read(from:))
        value.suppressAlerts = try reader["suppressAlerts"].readIfPresent()
        value.exportMetric = try reader["exportMetric"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.BehaviorCriteria {

    static func write(value: IoTClientTypes.BehaviorCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comparisonOperator"].write(value.comparisonOperator)
        try writer["consecutiveDatapointsToAlarm"].write(value.consecutiveDatapointsToAlarm)
        try writer["consecutiveDatapointsToClear"].write(value.consecutiveDatapointsToClear)
        try writer["durationSeconds"].write(value.durationSeconds)
        try writer["mlDetectionConfig"].write(value.mlDetectionConfig, with: IoTClientTypes.MachineLearningDetectionConfig.write(value:to:))
        try writer["statisticalThreshold"].write(value.statisticalThreshold, with: IoTClientTypes.StatisticalThreshold.write(value:to:))
        try writer["value"].write(value.value, with: IoTClientTypes.MetricValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.BehaviorCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.BehaviorCriteria()
        value.comparisonOperator = try reader["comparisonOperator"].readIfPresent()
        value.value = try reader["value"].readIfPresent(with: IoTClientTypes.MetricValue.read(from:))
        value.durationSeconds = try reader["durationSeconds"].readIfPresent()
        value.consecutiveDatapointsToAlarm = try reader["consecutiveDatapointsToAlarm"].readIfPresent()
        value.consecutiveDatapointsToClear = try reader["consecutiveDatapointsToClear"].readIfPresent()
        value.statisticalThreshold = try reader["statisticalThreshold"].readIfPresent(with: IoTClientTypes.StatisticalThreshold.read(from:))
        value.mlDetectionConfig = try reader["mlDetectionConfig"].readIfPresent(with: IoTClientTypes.MachineLearningDetectionConfig.read(from:))
        return value
    }
}

extension IoTClientTypes.MachineLearningDetectionConfig {

    static func write(value: IoTClientTypes.MachineLearningDetectionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["confidenceLevel"].write(value.confidenceLevel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.MachineLearningDetectionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.MachineLearningDetectionConfig()
        value.confidenceLevel = try reader["confidenceLevel"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTClientTypes.StatisticalThreshold {

    static func write(value: IoTClientTypes.StatisticalThreshold?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["statistic"].write(value.statistic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.StatisticalThreshold {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.StatisticalThreshold()
        value.statistic = try reader["statistic"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.MetricValue {

    static func write(value: IoTClientTypes.MetricValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidrs"].writeList(value.cidrs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["count"].write(value.count)
        try writer["number"].write(value.number)
        try writer["numbers"].writeList(value.numbers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ports"].writeList(value.ports, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["strings"].writeList(value.strings, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.MetricValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.MetricValue()
        value.count = try reader["count"].readIfPresent()
        value.cidrs = try reader["cidrs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ports = try reader["ports"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.number = try reader["number"].readIfPresent()
        value.numbers = try reader["numbers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.strings = try reader["strings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.MetricDimension {

    static func write(value: IoTClientTypes.MetricDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dimensionName"].write(value.dimensionName)
        try writer["operator"].write(value.`operator`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.MetricDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.MetricDimension()
        value.dimensionName = try reader["dimensionName"].readIfPresent() ?? ""
        value.`operator` = try reader["operator"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AlertTarget {

    static func write(value: IoTClientTypes.AlertTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alertTargetArn"].write(value.alertTargetArn)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AlertTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AlertTarget()
        value.alertTargetArn = try reader["alertTargetArn"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.MetricToRetain {

    static func write(value: IoTClientTypes.MetricToRetain?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exportMetric"].write(value.exportMetric)
        try writer["metric"].write(value.metric)
        try writer["metricDimension"].write(value.metricDimension, with: IoTClientTypes.MetricDimension.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.MetricToRetain {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.MetricToRetain()
        value.metric = try reader["metric"].readIfPresent() ?? ""
        value.metricDimension = try reader["metricDimension"].readIfPresent(with: IoTClientTypes.MetricDimension.read(from:))
        value.exportMetric = try reader["exportMetric"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.MetricsExportConfig {

    static func write(value: IoTClientTypes.MetricsExportConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mqttTopic"].write(value.mqttTopic)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.MetricsExportConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.MetricsExportConfig()
        value.mqttTopic = try reader["mqttTopic"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.StreamInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.StreamInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.StreamInfo()
        value.streamId = try reader["streamId"].readIfPresent()
        value.streamArn = try reader["streamArn"].readIfPresent()
        value.streamVersion = try reader["streamVersion"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.files = try reader["files"].readListIfPresent(memberReadingClosure: IoTClientTypes.StreamFile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.StreamFile {

    static func write(value: IoTClientTypes.StreamFile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileId"].write(value.fileId)
        try writer["s3Location"].write(value.s3Location, with: IoTClientTypes.S3Location.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.StreamFile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.StreamFile()
        value.fileId = try reader["fileId"].readIfPresent()
        value.s3Location = try reader["s3Location"].readIfPresent(with: IoTClientTypes.S3Location.read(from:))
        return value
    }
}

extension IoTClientTypes.ThingGroupProperties {

    static func write(value: IoTClientTypes.ThingGroupProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributePayload"].write(value.attributePayload, with: IoTClientTypes.AttributePayload.write(value:to:))
        try writer["thingGroupDescription"].write(value.thingGroupDescription)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ThingGroupProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ThingGroupProperties()
        value.thingGroupDescription = try reader["thingGroupDescription"].readIfPresent()
        value.attributePayload = try reader["attributePayload"].readIfPresent(with: IoTClientTypes.AttributePayload.read(from:))
        return value
    }
}

extension IoTClientTypes.AttributePayload {

    static func write(value: IoTClientTypes.AttributePayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["merge"].write(value.merge)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AttributePayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AttributePayload()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.merge = try reader["merge"].readIfPresent() ?? false
        return value
    }
}

extension IoTClientTypes.ThingGroupMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ThingGroupMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ThingGroupMetadata()
        value.parentGroupName = try reader["parentGroupName"].readIfPresent()
        value.rootToParentThingGroups = try reader["rootToParentThingGroups"].readListIfPresent(memberReadingClosure: IoTClientTypes.GroupNameAndArn.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.GroupNameAndArn {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.GroupNameAndArn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.GroupNameAndArn()
        value.groupName = try reader["groupName"].readIfPresent()
        value.groupArn = try reader["groupArn"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.ThingTypeProperties {

    static func write(value: IoTClientTypes.ThingTypeProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["searchableAttributes"].writeList(value.searchableAttributes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["thingTypeDescription"].write(value.thingTypeDescription)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ThingTypeProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ThingTypeProperties()
        value.thingTypeDescription = try reader["thingTypeDescription"].readIfPresent()
        value.searchableAttributes = try reader["searchableAttributes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.ThingTypeMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ThingTypeMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ThingTypeMetadata()
        value.deprecated = try reader["deprecated"].readIfPresent() ?? false
        value.deprecationDate = try reader["deprecationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.BehaviorModelTrainingSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.BehaviorModelTrainingSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.BehaviorModelTrainingSummary()
        value.securityProfileName = try reader["securityProfileName"].readIfPresent()
        value.behaviorName = try reader["behaviorName"].readIfPresent()
        value.trainingDataCollectionStartDate = try reader["trainingDataCollectionStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modelStatus = try reader["modelStatus"].readIfPresent()
        value.datapointsCollectionPercentage = try reader["datapointsCollectionPercentage"].readIfPresent()
        value.lastModelRefreshDate = try reader["lastModelRefreshDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.Bucket {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Bucket {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Bucket()
        value.keyValue = try reader["keyValue"].readIfPresent()
        value.count = try reader["count"].readIfPresent() ?? 0
        return value
    }
}

extension IoTClientTypes.EffectivePolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.EffectivePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.EffectivePolicy()
        value.policyName = try reader["policyName"].readIfPresent()
        value.policyArn = try reader["policyArn"].readIfPresent()
        value.policyDocument = try reader["policyDocument"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.ThingIndexingConfiguration {

    static func write(value: IoTClientTypes.ThingIndexingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customFields"].writeList(value.customFields, memberWritingClosure: IoTClientTypes.Field.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["deviceDefenderIndexingMode"].write(value.deviceDefenderIndexingMode)
        try writer["filter"].write(value.filter, with: IoTClientTypes.IndexingFilter.write(value:to:))
        try writer["managedFields"].writeList(value.managedFields, memberWritingClosure: IoTClientTypes.Field.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["namedShadowIndexingMode"].write(value.namedShadowIndexingMode)
        try writer["thingConnectivityIndexingMode"].write(value.thingConnectivityIndexingMode)
        try writer["thingIndexingMode"].write(value.thingIndexingMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ThingIndexingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ThingIndexingConfiguration()
        value.thingIndexingMode = try reader["thingIndexingMode"].readIfPresent() ?? .sdkUnknown("")
        value.thingConnectivityIndexingMode = try reader["thingConnectivityIndexingMode"].readIfPresent()
        value.deviceDefenderIndexingMode = try reader["deviceDefenderIndexingMode"].readIfPresent()
        value.namedShadowIndexingMode = try reader["namedShadowIndexingMode"].readIfPresent()
        value.managedFields = try reader["managedFields"].readListIfPresent(memberReadingClosure: IoTClientTypes.Field.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.customFields = try reader["customFields"].readListIfPresent(memberReadingClosure: IoTClientTypes.Field.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filter = try reader["filter"].readIfPresent(with: IoTClientTypes.IndexingFilter.read(from:))
        return value
    }
}

extension IoTClientTypes.IndexingFilter {

    static func write(value: IoTClientTypes.IndexingFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["geoLocations"].writeList(value.geoLocations, memberWritingClosure: IoTClientTypes.GeoLocationTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["namedShadowNames"].writeList(value.namedShadowNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.IndexingFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.IndexingFilter()
        value.namedShadowNames = try reader["namedShadowNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.geoLocations = try reader["geoLocations"].readListIfPresent(memberReadingClosure: IoTClientTypes.GeoLocationTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.GeoLocationTarget {

    static func write(value: IoTClientTypes.GeoLocationTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["order"].write(value.order)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.GeoLocationTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.GeoLocationTarget()
        value.name = try reader["name"].readIfPresent()
        value.order = try reader["order"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.Field {

    static func write(value: IoTClientTypes.Field?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Field {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Field()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.ThingGroupIndexingConfiguration {

    static func write(value: IoTClientTypes.ThingGroupIndexingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customFields"].writeList(value.customFields, memberWritingClosure: IoTClientTypes.Field.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["managedFields"].writeList(value.managedFields, memberWritingClosure: IoTClientTypes.Field.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["thingGroupIndexingMode"].write(value.thingGroupIndexingMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ThingGroupIndexingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ThingGroupIndexingConfiguration()
        value.thingGroupIndexingMode = try reader["thingGroupIndexingMode"].readIfPresent() ?? .sdkUnknown("")
        value.managedFields = try reader["managedFields"].readListIfPresent(memberReadingClosure: IoTClientTypes.Field.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.customFields = try reader["customFields"].readListIfPresent(memberReadingClosure: IoTClientTypes.Field.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.OTAUpdateInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.OTAUpdateInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.OTAUpdateInfo()
        value.otaUpdateId = try reader["otaUpdateId"].readIfPresent()
        value.otaUpdateArn = try reader["otaUpdateArn"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.targets = try reader["targets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.protocols = try reader["protocols"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<IoTClientTypes.ModelProtocol>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsJobExecutionsRolloutConfig = try reader["awsJobExecutionsRolloutConfig"].readIfPresent(with: IoTClientTypes.AwsJobExecutionsRolloutConfig.read(from:))
        value.awsJobPresignedUrlConfig = try reader["awsJobPresignedUrlConfig"].readIfPresent(with: IoTClientTypes.AwsJobPresignedUrlConfig.read(from:))
        value.targetSelection = try reader["targetSelection"].readIfPresent()
        value.otaUpdateFiles = try reader["otaUpdateFiles"].readListIfPresent(memberReadingClosure: IoTClientTypes.OTAUpdateFile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.otaUpdateStatus = try reader["otaUpdateStatus"].readIfPresent()
        value.awsIotJobId = try reader["awsIotJobId"].readIfPresent()
        value.awsIotJobArn = try reader["awsIotJobArn"].readIfPresent()
        value.errorInfo = try reader["errorInfo"].readIfPresent(with: IoTClientTypes.ErrorInfo.read(from:))
        value.additionalParameters = try reader["additionalParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.ErrorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ErrorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ErrorInfo()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.OTAUpdateFile {

    static func write(value: IoTClientTypes.OTAUpdateFile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["codeSigning"].write(value.codeSigning, with: IoTClientTypes.CodeSigning.write(value:to:))
        try writer["fileLocation"].write(value.fileLocation, with: IoTClientTypes.FileLocation.write(value:to:))
        try writer["fileName"].write(value.fileName)
        try writer["fileType"].write(value.fileType)
        try writer["fileVersion"].write(value.fileVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.OTAUpdateFile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.OTAUpdateFile()
        value.fileName = try reader["fileName"].readIfPresent()
        value.fileType = try reader["fileType"].readIfPresent()
        value.fileVersion = try reader["fileVersion"].readIfPresent()
        value.fileLocation = try reader["fileLocation"].readIfPresent(with: IoTClientTypes.FileLocation.read(from:))
        value.codeSigning = try reader["codeSigning"].readIfPresent(with: IoTClientTypes.CodeSigning.read(from:))
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.CodeSigning {

    static func write(value: IoTClientTypes.CodeSigning?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsSignerJobId"].write(value.awsSignerJobId)
        try writer["customCodeSigning"].write(value.customCodeSigning, with: IoTClientTypes.CustomCodeSigning.write(value:to:))
        try writer["startSigningJobParameter"].write(value.startSigningJobParameter, with: IoTClientTypes.StartSigningJobParameter.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.CodeSigning {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.CodeSigning()
        value.awsSignerJobId = try reader["awsSignerJobId"].readIfPresent()
        value.startSigningJobParameter = try reader["startSigningJobParameter"].readIfPresent(with: IoTClientTypes.StartSigningJobParameter.read(from:))
        value.customCodeSigning = try reader["customCodeSigning"].readIfPresent(with: IoTClientTypes.CustomCodeSigning.read(from:))
        return value
    }
}

extension IoTClientTypes.CustomCodeSigning {

    static func write(value: IoTClientTypes.CustomCodeSigning?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateChain"].write(value.certificateChain, with: IoTClientTypes.CodeSigningCertificateChain.write(value:to:))
        try writer["hashAlgorithm"].write(value.hashAlgorithm)
        try writer["signature"].write(value.signature, with: IoTClientTypes.CodeSigningSignature.write(value:to:))
        try writer["signatureAlgorithm"].write(value.signatureAlgorithm)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.CustomCodeSigning {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.CustomCodeSigning()
        value.signature = try reader["signature"].readIfPresent(with: IoTClientTypes.CodeSigningSignature.read(from:))
        value.certificateChain = try reader["certificateChain"].readIfPresent(with: IoTClientTypes.CodeSigningCertificateChain.read(from:))
        value.hashAlgorithm = try reader["hashAlgorithm"].readIfPresent()
        value.signatureAlgorithm = try reader["signatureAlgorithm"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.CodeSigningCertificateChain {

    static func write(value: IoTClientTypes.CodeSigningCertificateChain?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateName"].write(value.certificateName)
        try writer["inlineDocument"].write(value.inlineDocument)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.CodeSigningCertificateChain {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.CodeSigningCertificateChain()
        value.certificateName = try reader["certificateName"].readIfPresent()
        value.inlineDocument = try reader["inlineDocument"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.CodeSigningSignature {

    static func write(value: IoTClientTypes.CodeSigningSignature?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inlineDocument"].write(value.inlineDocument)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.CodeSigningSignature {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.CodeSigningSignature()
        value.inlineDocument = try reader["inlineDocument"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.StartSigningJobParameter {

    static func write(value: IoTClientTypes.StartSigningJobParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destination"].write(value.destination, with: IoTClientTypes.Destination.write(value:to:))
        try writer["signingProfileName"].write(value.signingProfileName)
        try writer["signingProfileParameter"].write(value.signingProfileParameter, with: IoTClientTypes.SigningProfileParameter.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.StartSigningJobParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.StartSigningJobParameter()
        value.signingProfileParameter = try reader["signingProfileParameter"].readIfPresent(with: IoTClientTypes.SigningProfileParameter.read(from:))
        value.signingProfileName = try reader["signingProfileName"].readIfPresent()
        value.destination = try reader["destination"].readIfPresent(with: IoTClientTypes.Destination.read(from:))
        return value
    }
}

extension IoTClientTypes.Destination {

    static func write(value: IoTClientTypes.Destination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Destination"].write(value.s3Destination, with: IoTClientTypes.S3Destination.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Destination()
        value.s3Destination = try reader["s3Destination"].readIfPresent(with: IoTClientTypes.S3Destination.read(from:))
        return value
    }
}

extension IoTClientTypes.S3Destination {

    static func write(value: IoTClientTypes.S3Destination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.S3Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.S3Destination()
        value.bucket = try reader["bucket"].readIfPresent()
        value.`prefix` = try reader["prefix"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.SigningProfileParameter {

    static func write(value: IoTClientTypes.SigningProfileParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateArn"].write(value.certificateArn)
        try writer["certificatePathOnDevice"].write(value.certificatePathOnDevice)
        try writer["platform"].write(value.platform)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.SigningProfileParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.SigningProfileParameter()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.certificatePathOnDevice = try reader["certificatePathOnDevice"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.FileLocation {

    static func write(value: IoTClientTypes.FileLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Location"].write(value.s3Location, with: IoTClientTypes.S3Location.write(value:to:))
        try writer["stream"].write(value.stream, with: IoTClientTypes.Stream.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.FileLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.FileLocation()
        value.stream = try reader["stream"].readIfPresent(with: IoTClientTypes.Stream.read(from:))
        value.s3Location = try reader["s3Location"].readIfPresent(with: IoTClientTypes.S3Location.read(from:))
        return value
    }
}

extension IoTClientTypes.Stream {

    static func write(value: IoTClientTypes.Stream?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileId"].write(value.fileId)
        try writer["streamId"].write(value.streamId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Stream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Stream()
        value.streamId = try reader["streamId"].readIfPresent()
        value.fileId = try reader["fileId"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AwsJobPresignedUrlConfig {

    static func write(value: IoTClientTypes.AwsJobPresignedUrlConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expiresInSec"].write(value.expiresInSec)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AwsJobPresignedUrlConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AwsJobPresignedUrlConfig()
        value.expiresInSec = try reader["expiresInSec"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AwsJobExecutionsRolloutConfig {

    static func write(value: IoTClientTypes.AwsJobExecutionsRolloutConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exponentialRate"].write(value.exponentialRate, with: IoTClientTypes.AwsJobExponentialRolloutRate.write(value:to:))
        try writer["maximumPerMinute"].write(value.maximumPerMinute)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AwsJobExecutionsRolloutConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AwsJobExecutionsRolloutConfig()
        value.maximumPerMinute = try reader["maximumPerMinute"].readIfPresent()
        value.exponentialRate = try reader["exponentialRate"].readIfPresent(with: IoTClientTypes.AwsJobExponentialRolloutRate.read(from:))
        return value
    }
}

extension IoTClientTypes.AwsJobExponentialRolloutRate {

    static func write(value: IoTClientTypes.AwsJobExponentialRolloutRate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseRatePerMinute"].write(value.baseRatePerMinute)
        try writer["incrementFactor"].write(value.incrementFactor)
        try writer["rateIncreaseCriteria"].write(value.rateIncreaseCriteria, with: IoTClientTypes.AwsJobRateIncreaseCriteria.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AwsJobExponentialRolloutRate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AwsJobExponentialRolloutRate()
        value.baseRatePerMinute = try reader["baseRatePerMinute"].readIfPresent() ?? 0
        value.incrementFactor = try reader["incrementFactor"].readIfPresent() ?? 0
        value.rateIncreaseCriteria = try reader["rateIncreaseCriteria"].readIfPresent(with: IoTClientTypes.AwsJobRateIncreaseCriteria.read(from:))
        return value
    }
}

extension IoTClientTypes.AwsJobRateIncreaseCriteria {

    static func write(value: IoTClientTypes.AwsJobRateIncreaseCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["numberOfNotifiedThings"].write(value.numberOfNotifiedThings)
        try writer["numberOfSucceededThings"].write(value.numberOfSucceededThings)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AwsJobRateIncreaseCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AwsJobRateIncreaseCriteria()
        value.numberOfNotifiedThings = try reader["numberOfNotifiedThings"].readIfPresent()
        value.numberOfSucceededThings = try reader["numberOfSucceededThings"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.VersionUpdateByJobsConfig {

    static func write(value: IoTClientTypes.VersionUpdateByJobsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.VersionUpdateByJobsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.VersionUpdateByJobsConfig()
        value.enabled = try reader["enabled"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.PackageVersionArtifact {

    static func write(value: IoTClientTypes.PackageVersionArtifact?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Location"].write(value.s3Location, with: IoTClientTypes.S3Location.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.PackageVersionArtifact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.PackageVersionArtifact()
        value.s3Location = try reader["s3Location"].readIfPresent(with: IoTClientTypes.S3Location.read(from:))
        return value
    }
}

extension IoTClientTypes.PercentPair {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.PercentPair {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.PercentPair()
        value.percent = try reader["percent"].readIfPresent() ?? 0
        value.value = try reader["value"].readIfPresent() ?? 0
        return value
    }
}

extension IoTClientTypes.Statistics {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Statistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Statistics()
        value.count = try reader["count"].readIfPresent() ?? 0
        value.average = try reader["average"].readIfPresent()
        value.sum = try reader["sum"].readIfPresent()
        value.minimum = try reader["minimum"].readIfPresent()
        value.maximum = try reader["maximum"].readIfPresent()
        value.sumOfSquares = try reader["sumOfSquares"].readIfPresent()
        value.variance = try reader["variance"].readIfPresent()
        value.stdDeviation = try reader["stdDeviation"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.TopicRule {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.TopicRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.TopicRule()
        value.ruleName = try reader["ruleName"].readIfPresent()
        value.sql = try reader["sql"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: IoTClientTypes.Action.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ruleDisabled = try reader["ruleDisabled"].readIfPresent()
        value.awsIotSqlVersion = try reader["awsIotSqlVersion"].readIfPresent()
        value.errorAction = try reader["errorAction"].readIfPresent(with: IoTClientTypes.Action.read(from:))
        return value
    }
}

extension IoTClientTypes.Action {

    static func write(value: IoTClientTypes.Action?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudwatchAlarm"].write(value.cloudwatchAlarm, with: IoTClientTypes.CloudwatchAlarmAction.write(value:to:))
        try writer["cloudwatchLogs"].write(value.cloudwatchLogs, with: IoTClientTypes.CloudwatchLogsAction.write(value:to:))
        try writer["cloudwatchMetric"].write(value.cloudwatchMetric, with: IoTClientTypes.CloudwatchMetricAction.write(value:to:))
        try writer["dynamoDB"].write(value.dynamoDB, with: IoTClientTypes.DynamoDBAction.write(value:to:))
        try writer["dynamoDBv2"].write(value.dynamoDBv2, with: IoTClientTypes.DynamoDBv2Action.write(value:to:))
        try writer["elasticsearch"].write(value.elasticsearch, with: IoTClientTypes.ElasticsearchAction.write(value:to:))
        try writer["firehose"].write(value.firehose, with: IoTClientTypes.FirehoseAction.write(value:to:))
        try writer["http"].write(value.http, with: IoTClientTypes.HttpAction.write(value:to:))
        try writer["iotAnalytics"].write(value.iotAnalytics, with: IoTClientTypes.IotAnalyticsAction.write(value:to:))
        try writer["iotEvents"].write(value.iotEvents, with: IoTClientTypes.IotEventsAction.write(value:to:))
        try writer["iotSiteWise"].write(value.iotSiteWise, with: IoTClientTypes.IotSiteWiseAction.write(value:to:))
        try writer["kafka"].write(value.kafka, with: IoTClientTypes.KafkaAction.write(value:to:))
        try writer["kinesis"].write(value.kinesis, with: IoTClientTypes.KinesisAction.write(value:to:))
        try writer["lambda"].write(value.lambda, with: IoTClientTypes.LambdaAction.write(value:to:))
        try writer["location"].write(value.location, with: IoTClientTypes.LocationAction.write(value:to:))
        try writer["openSearch"].write(value.openSearch, with: IoTClientTypes.OpenSearchAction.write(value:to:))
        try writer["republish"].write(value.republish, with: IoTClientTypes.RepublishAction.write(value:to:))
        try writer["s3"].write(value.s3, with: IoTClientTypes.S3Action.write(value:to:))
        try writer["salesforce"].write(value.salesforce, with: IoTClientTypes.SalesforceAction.write(value:to:))
        try writer["sns"].write(value.sns, with: IoTClientTypes.SnsAction.write(value:to:))
        try writer["sqs"].write(value.sqs, with: IoTClientTypes.SqsAction.write(value:to:))
        try writer["stepFunctions"].write(value.stepFunctions, with: IoTClientTypes.StepFunctionsAction.write(value:to:))
        try writer["timestream"].write(value.timestream, with: IoTClientTypes.TimestreamAction.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Action()
        value.dynamoDB = try reader["dynamoDB"].readIfPresent(with: IoTClientTypes.DynamoDBAction.read(from:))
        value.dynamoDBv2 = try reader["dynamoDBv2"].readIfPresent(with: IoTClientTypes.DynamoDBv2Action.read(from:))
        value.lambda = try reader["lambda"].readIfPresent(with: IoTClientTypes.LambdaAction.read(from:))
        value.sns = try reader["sns"].readIfPresent(with: IoTClientTypes.SnsAction.read(from:))
        value.sqs = try reader["sqs"].readIfPresent(with: IoTClientTypes.SqsAction.read(from:))
        value.kinesis = try reader["kinesis"].readIfPresent(with: IoTClientTypes.KinesisAction.read(from:))
        value.republish = try reader["republish"].readIfPresent(with: IoTClientTypes.RepublishAction.read(from:))
        value.s3 = try reader["s3"].readIfPresent(with: IoTClientTypes.S3Action.read(from:))
        value.firehose = try reader["firehose"].readIfPresent(with: IoTClientTypes.FirehoseAction.read(from:))
        value.cloudwatchMetric = try reader["cloudwatchMetric"].readIfPresent(with: IoTClientTypes.CloudwatchMetricAction.read(from:))
        value.cloudwatchAlarm = try reader["cloudwatchAlarm"].readIfPresent(with: IoTClientTypes.CloudwatchAlarmAction.read(from:))
        value.cloudwatchLogs = try reader["cloudwatchLogs"].readIfPresent(with: IoTClientTypes.CloudwatchLogsAction.read(from:))
        value.elasticsearch = try reader["elasticsearch"].readIfPresent(with: IoTClientTypes.ElasticsearchAction.read(from:))
        value.salesforce = try reader["salesforce"].readIfPresent(with: IoTClientTypes.SalesforceAction.read(from:))
        value.iotAnalytics = try reader["iotAnalytics"].readIfPresent(with: IoTClientTypes.IotAnalyticsAction.read(from:))
        value.iotEvents = try reader["iotEvents"].readIfPresent(with: IoTClientTypes.IotEventsAction.read(from:))
        value.iotSiteWise = try reader["iotSiteWise"].readIfPresent(with: IoTClientTypes.IotSiteWiseAction.read(from:))
        value.stepFunctions = try reader["stepFunctions"].readIfPresent(with: IoTClientTypes.StepFunctionsAction.read(from:))
        value.timestream = try reader["timestream"].readIfPresent(with: IoTClientTypes.TimestreamAction.read(from:))
        value.http = try reader["http"].readIfPresent(with: IoTClientTypes.HttpAction.read(from:))
        value.kafka = try reader["kafka"].readIfPresent(with: IoTClientTypes.KafkaAction.read(from:))
        value.openSearch = try reader["openSearch"].readIfPresent(with: IoTClientTypes.OpenSearchAction.read(from:))
        value.location = try reader["location"].readIfPresent(with: IoTClientTypes.LocationAction.read(from:))
        return value
    }
}

extension IoTClientTypes.LocationAction {

    static func write(value: IoTClientTypes.LocationAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deviceId"].write(value.deviceId)
        try writer["latitude"].write(value.latitude)
        try writer["longitude"].write(value.longitude)
        try writer["roleArn"].write(value.roleArn)
        try writer["timestamp"].write(value.timestamp, with: IoTClientTypes.LocationTimestamp.write(value:to:))
        try writer["trackerName"].write(value.trackerName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.LocationAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.LocationAction()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.trackerName = try reader["trackerName"].readIfPresent() ?? ""
        value.deviceId = try reader["deviceId"].readIfPresent() ?? ""
        value.timestamp = try reader["timestamp"].readIfPresent(with: IoTClientTypes.LocationTimestamp.read(from:))
        value.latitude = try reader["latitude"].readIfPresent() ?? ""
        value.longitude = try reader["longitude"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.LocationTimestamp {

    static func write(value: IoTClientTypes.LocationTimestamp?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["unit"].write(value.unit)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.LocationTimestamp {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.LocationTimestamp()
        value.value = try reader["value"].readIfPresent() ?? ""
        value.unit = try reader["unit"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.OpenSearchAction {

    static func write(value: IoTClientTypes.OpenSearchAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endpoint"].write(value.endpoint)
        try writer["id"].write(value.id)
        try writer["index"].write(value.index)
        try writer["roleArn"].write(value.roleArn)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.OpenSearchAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.OpenSearchAction()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.endpoint = try reader["endpoint"].readIfPresent() ?? ""
        value.index = try reader["index"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.KafkaAction {

    static func write(value: IoTClientTypes.KafkaAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientProperties"].writeMap(value.clientProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["destinationArn"].write(value.destinationArn)
        try writer["headers"].writeList(value.headers, memberWritingClosure: IoTClientTypes.KafkaActionHeader.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["key"].write(value.key)
        try writer["partition"].write(value.partition)
        try writer["topic"].write(value.topic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.KafkaAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.KafkaAction()
        value.destinationArn = try reader["destinationArn"].readIfPresent() ?? ""
        value.topic = try reader["topic"].readIfPresent() ?? ""
        value.key = try reader["key"].readIfPresent()
        value.partition = try reader["partition"].readIfPresent()
        value.clientProperties = try reader["clientProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.headers = try reader["headers"].readListIfPresent(memberReadingClosure: IoTClientTypes.KafkaActionHeader.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.KafkaActionHeader {

    static func write(value: IoTClientTypes.KafkaActionHeader?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.KafkaActionHeader {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.KafkaActionHeader()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.HttpAction {

    static func write(value: IoTClientTypes.HttpAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["auth"].write(value.auth, with: IoTClientTypes.HttpAuthorization.write(value:to:))
        try writer["confirmationUrl"].write(value.confirmationUrl)
        try writer["headers"].writeList(value.headers, memberWritingClosure: IoTClientTypes.HttpActionHeader.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.HttpAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.HttpAction()
        value.url = try reader["url"].readIfPresent() ?? ""
        value.confirmationUrl = try reader["confirmationUrl"].readIfPresent()
        value.headers = try reader["headers"].readListIfPresent(memberReadingClosure: IoTClientTypes.HttpActionHeader.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.auth = try reader["auth"].readIfPresent(with: IoTClientTypes.HttpAuthorization.read(from:))
        return value
    }
}

extension IoTClientTypes.HttpAuthorization {

    static func write(value: IoTClientTypes.HttpAuthorization?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sigv4"].write(value.sigv4, with: IoTClientTypes.SigV4Authorization.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.HttpAuthorization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.HttpAuthorization()
        value.sigv4 = try reader["sigv4"].readIfPresent(with: IoTClientTypes.SigV4Authorization.read(from:))
        return value
    }
}

extension IoTClientTypes.SigV4Authorization {

    static func write(value: IoTClientTypes.SigV4Authorization?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleArn"].write(value.roleArn)
        try writer["serviceName"].write(value.serviceName)
        try writer["signingRegion"].write(value.signingRegion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.SigV4Authorization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.SigV4Authorization()
        value.signingRegion = try reader["signingRegion"].readIfPresent() ?? ""
        value.serviceName = try reader["serviceName"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.HttpActionHeader {

    static func write(value: IoTClientTypes.HttpActionHeader?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.HttpActionHeader {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.HttpActionHeader()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.TimestreamAction {

    static func write(value: IoTClientTypes.TimestreamAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["databaseName"].write(value.databaseName)
        try writer["dimensions"].writeList(value.dimensions, memberWritingClosure: IoTClientTypes.TimestreamDimension.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
        try writer["tableName"].write(value.tableName)
        try writer["timestamp"].write(value.timestamp, with: IoTClientTypes.TimestreamTimestamp.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.TimestreamAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.TimestreamAction()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.databaseName = try reader["databaseName"].readIfPresent() ?? ""
        value.tableName = try reader["tableName"].readIfPresent() ?? ""
        value.dimensions = try reader["dimensions"].readListIfPresent(memberReadingClosure: IoTClientTypes.TimestreamDimension.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timestamp = try reader["timestamp"].readIfPresent(with: IoTClientTypes.TimestreamTimestamp.read(from:))
        return value
    }
}

extension IoTClientTypes.TimestreamTimestamp {

    static func write(value: IoTClientTypes.TimestreamTimestamp?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["unit"].write(value.unit)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.TimestreamTimestamp {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.TimestreamTimestamp()
        value.value = try reader["value"].readIfPresent() ?? ""
        value.unit = try reader["unit"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.TimestreamDimension {

    static func write(value: IoTClientTypes.TimestreamDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.TimestreamDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.TimestreamDimension()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.StepFunctionsAction {

    static func write(value: IoTClientTypes.StepFunctionsAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["executionNamePrefix"].write(value.executionNamePrefix)
        try writer["roleArn"].write(value.roleArn)
        try writer["stateMachineName"].write(value.stateMachineName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.StepFunctionsAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.StepFunctionsAction()
        value.executionNamePrefix = try reader["executionNamePrefix"].readIfPresent()
        value.stateMachineName = try reader["stateMachineName"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.IotSiteWiseAction {

    static func write(value: IoTClientTypes.IotSiteWiseAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["putAssetPropertyValueEntries"].writeList(value.putAssetPropertyValueEntries, memberWritingClosure: IoTClientTypes.PutAssetPropertyValueEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.IotSiteWiseAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.IotSiteWiseAction()
        value.putAssetPropertyValueEntries = try reader["putAssetPropertyValueEntries"].readListIfPresent(memberReadingClosure: IoTClientTypes.PutAssetPropertyValueEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.PutAssetPropertyValueEntry {

    static func write(value: IoTClientTypes.PutAssetPropertyValueEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetId"].write(value.assetId)
        try writer["entryId"].write(value.entryId)
        try writer["propertyAlias"].write(value.propertyAlias)
        try writer["propertyId"].write(value.propertyId)
        try writer["propertyValues"].writeList(value.propertyValues, memberWritingClosure: IoTClientTypes.AssetPropertyValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.PutAssetPropertyValueEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.PutAssetPropertyValueEntry()
        value.entryId = try reader["entryId"].readIfPresent()
        value.assetId = try reader["assetId"].readIfPresent()
        value.propertyId = try reader["propertyId"].readIfPresent()
        value.propertyAlias = try reader["propertyAlias"].readIfPresent()
        value.propertyValues = try reader["propertyValues"].readListIfPresent(memberReadingClosure: IoTClientTypes.AssetPropertyValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTClientTypes.AssetPropertyValue {

    static func write(value: IoTClientTypes.AssetPropertyValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["quality"].write(value.quality)
        try writer["timestamp"].write(value.timestamp, with: IoTClientTypes.AssetPropertyTimestamp.write(value:to:))
        try writer["value"].write(value.value, with: IoTClientTypes.AssetPropertyVariant.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AssetPropertyValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AssetPropertyValue()
        value.value = try reader["value"].readIfPresent(with: IoTClientTypes.AssetPropertyVariant.read(from:))
        value.timestamp = try reader["timestamp"].readIfPresent(with: IoTClientTypes.AssetPropertyTimestamp.read(from:))
        value.quality = try reader["quality"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AssetPropertyTimestamp {

    static func write(value: IoTClientTypes.AssetPropertyTimestamp?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["offsetInNanos"].write(value.offsetInNanos)
        try writer["timeInSeconds"].write(value.timeInSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AssetPropertyTimestamp {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AssetPropertyTimestamp()
        value.timeInSeconds = try reader["timeInSeconds"].readIfPresent() ?? ""
        value.offsetInNanos = try reader["offsetInNanos"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AssetPropertyVariant {

    static func write(value: IoTClientTypes.AssetPropertyVariant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .booleanvalue(booleanvalue):
                try writer["booleanValue"].write(booleanvalue)
            case let .doublevalue(doublevalue):
                try writer["doubleValue"].write(doublevalue)
            case let .integervalue(integervalue):
                try writer["integerValue"].write(integervalue)
            case let .stringvalue(stringvalue):
                try writer["stringValue"].write(stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AssetPropertyVariant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "stringValue":
                return .stringvalue(try reader["stringValue"].read())
            case "integerValue":
                return .integervalue(try reader["integerValue"].read())
            case "doubleValue":
                return .doublevalue(try reader["doubleValue"].read())
            case "booleanValue":
                return .booleanvalue(try reader["booleanValue"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension IoTClientTypes.IotEventsAction {

    static func write(value: IoTClientTypes.IotEventsAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["batchMode"].write(value.batchMode)
        try writer["inputName"].write(value.inputName)
        try writer["messageId"].write(value.messageId)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.IotEventsAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.IotEventsAction()
        value.inputName = try reader["inputName"].readIfPresent() ?? ""
        value.messageId = try reader["messageId"].readIfPresent()
        value.batchMode = try reader["batchMode"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.IotAnalyticsAction {

    static func write(value: IoTClientTypes.IotAnalyticsAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["batchMode"].write(value.batchMode)
        try writer["channelArn"].write(value.channelArn)
        try writer["channelName"].write(value.channelName)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.IotAnalyticsAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.IotAnalyticsAction()
        value.channelArn = try reader["channelArn"].readIfPresent()
        value.channelName = try reader["channelName"].readIfPresent()
        value.batchMode = try reader["batchMode"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.SalesforceAction {

    static func write(value: IoTClientTypes.SalesforceAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["token"].write(value.token)
        try writer["url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.SalesforceAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.SalesforceAction()
        value.token = try reader["token"].readIfPresent() ?? ""
        value.url = try reader["url"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.ElasticsearchAction {

    static func write(value: IoTClientTypes.ElasticsearchAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endpoint"].write(value.endpoint)
        try writer["id"].write(value.id)
        try writer["index"].write(value.index)
        try writer["roleArn"].write(value.roleArn)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ElasticsearchAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ElasticsearchAction()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.endpoint = try reader["endpoint"].readIfPresent() ?? ""
        value.index = try reader["index"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.CloudwatchLogsAction {

    static func write(value: IoTClientTypes.CloudwatchLogsAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["batchMode"].write(value.batchMode)
        try writer["logGroupName"].write(value.logGroupName)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.CloudwatchLogsAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.CloudwatchLogsAction()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.logGroupName = try reader["logGroupName"].readIfPresent() ?? ""
        value.batchMode = try reader["batchMode"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.CloudwatchAlarmAction {

    static func write(value: IoTClientTypes.CloudwatchAlarmAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alarmName"].write(value.alarmName)
        try writer["roleArn"].write(value.roleArn)
        try writer["stateReason"].write(value.stateReason)
        try writer["stateValue"].write(value.stateValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.CloudwatchAlarmAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.CloudwatchAlarmAction()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.alarmName = try reader["alarmName"].readIfPresent() ?? ""
        value.stateReason = try reader["stateReason"].readIfPresent() ?? ""
        value.stateValue = try reader["stateValue"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.CloudwatchMetricAction {

    static func write(value: IoTClientTypes.CloudwatchMetricAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metricName"].write(value.metricName)
        try writer["metricNamespace"].write(value.metricNamespace)
        try writer["metricTimestamp"].write(value.metricTimestamp)
        try writer["metricUnit"].write(value.metricUnit)
        try writer["metricValue"].write(value.metricValue)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.CloudwatchMetricAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.CloudwatchMetricAction()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.metricNamespace = try reader["metricNamespace"].readIfPresent() ?? ""
        value.metricName = try reader["metricName"].readIfPresent() ?? ""
        value.metricValue = try reader["metricValue"].readIfPresent() ?? ""
        value.metricUnit = try reader["metricUnit"].readIfPresent() ?? ""
        value.metricTimestamp = try reader["metricTimestamp"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.FirehoseAction {

    static func write(value: IoTClientTypes.FirehoseAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["batchMode"].write(value.batchMode)
        try writer["deliveryStreamName"].write(value.deliveryStreamName)
        try writer["roleArn"].write(value.roleArn)
        try writer["separator"].write(value.separator)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.FirehoseAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.FirehoseAction()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.deliveryStreamName = try reader["deliveryStreamName"].readIfPresent() ?? ""
        value.separator = try reader["separator"].readIfPresent()
        value.batchMode = try reader["batchMode"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.S3Action {

    static func write(value: IoTClientTypes.S3Action?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["cannedAcl"].write(value.cannedAcl)
        try writer["key"].write(value.key)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.S3Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.S3Action()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.key = try reader["key"].readIfPresent() ?? ""
        value.cannedAcl = try reader["cannedAcl"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.RepublishAction {

    static func write(value: IoTClientTypes.RepublishAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["headers"].write(value.headers, with: IoTClientTypes.MqttHeaders.write(value:to:))
        try writer["qos"].write(value.qos)
        try writer["roleArn"].write(value.roleArn)
        try writer["topic"].write(value.topic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.RepublishAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.RepublishAction()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.topic = try reader["topic"].readIfPresent() ?? ""
        value.qos = try reader["qos"].readIfPresent()
        value.headers = try reader["headers"].readIfPresent(with: IoTClientTypes.MqttHeaders.read(from:))
        return value
    }
}

extension IoTClientTypes.MqttHeaders {

    static func write(value: IoTClientTypes.MqttHeaders?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["correlationData"].write(value.correlationData)
        try writer["messageExpiry"].write(value.messageExpiry)
        try writer["payloadFormatIndicator"].write(value.payloadFormatIndicator)
        try writer["responseTopic"].write(value.responseTopic)
        try writer["userProperties"].writeList(value.userProperties, memberWritingClosure: IoTClientTypes.UserProperty.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.MqttHeaders {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.MqttHeaders()
        value.payloadFormatIndicator = try reader["payloadFormatIndicator"].readIfPresent()
        value.contentType = try reader["contentType"].readIfPresent()
        value.responseTopic = try reader["responseTopic"].readIfPresent()
        value.correlationData = try reader["correlationData"].readIfPresent()
        value.messageExpiry = try reader["messageExpiry"].readIfPresent()
        value.userProperties = try reader["userProperties"].readListIfPresent(memberReadingClosure: IoTClientTypes.UserProperty.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.UserProperty {

    static func write(value: IoTClientTypes.UserProperty?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.UserProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.UserProperty()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.KinesisAction {

    static func write(value: IoTClientTypes.KinesisAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["partitionKey"].write(value.partitionKey)
        try writer["roleArn"].write(value.roleArn)
        try writer["streamName"].write(value.streamName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.KinesisAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.KinesisAction()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.streamName = try reader["streamName"].readIfPresent() ?? ""
        value.partitionKey = try reader["partitionKey"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.SqsAction {

    static func write(value: IoTClientTypes.SqsAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["queueUrl"].write(value.queueUrl)
        try writer["roleArn"].write(value.roleArn)
        try writer["useBase64"].write(value.useBase64)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.SqsAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.SqsAction()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.queueUrl = try reader["queueUrl"].readIfPresent() ?? ""
        value.useBase64 = try reader["useBase64"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.SnsAction {

    static func write(value: IoTClientTypes.SnsAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["messageFormat"].write(value.messageFormat)
        try writer["roleArn"].write(value.roleArn)
        try writer["targetArn"].write(value.targetArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.SnsAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.SnsAction()
        value.targetArn = try reader["targetArn"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.messageFormat = try reader["messageFormat"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.LambdaAction {

    static func write(value: IoTClientTypes.LambdaAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["functionArn"].write(value.functionArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.LambdaAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.LambdaAction()
        value.functionArn = try reader["functionArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.DynamoDBv2Action {

    static func write(value: IoTClientTypes.DynamoDBv2Action?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["putItem"].write(value.putItem, with: IoTClientTypes.PutItemInput.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.DynamoDBv2Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.DynamoDBv2Action()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.putItem = try reader["putItem"].readIfPresent(with: IoTClientTypes.PutItemInput.read(from:))
        return value
    }
}

extension IoTClientTypes.PutItemInput {

    static func write(value: IoTClientTypes.PutItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tableName"].write(value.tableName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.PutItemInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.PutItemInput()
        value.tableName = try reader["tableName"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.DynamoDBAction {

    static func write(value: IoTClientTypes.DynamoDBAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["hashKeyField"].write(value.hashKeyField)
        try writer["hashKeyType"].write(value.hashKeyType)
        try writer["hashKeyValue"].write(value.hashKeyValue)
        try writer["operation"].write(value.operation)
        try writer["payloadField"].write(value.payloadField)
        try writer["rangeKeyField"].write(value.rangeKeyField)
        try writer["rangeKeyType"].write(value.rangeKeyType)
        try writer["rangeKeyValue"].write(value.rangeKeyValue)
        try writer["roleArn"].write(value.roleArn)
        try writer["tableName"].write(value.tableName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.DynamoDBAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.DynamoDBAction()
        value.tableName = try reader["tableName"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.operation = try reader["operation"].readIfPresent()
        value.hashKeyField = try reader["hashKeyField"].readIfPresent() ?? ""
        value.hashKeyValue = try reader["hashKeyValue"].readIfPresent() ?? ""
        value.hashKeyType = try reader["hashKeyType"].readIfPresent()
        value.rangeKeyField = try reader["rangeKeyField"].readIfPresent()
        value.rangeKeyValue = try reader["rangeKeyValue"].readIfPresent()
        value.rangeKeyType = try reader["rangeKeyType"].readIfPresent()
        value.payloadField = try reader["payloadField"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.ActiveViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ActiveViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ActiveViolation()
        value.violationId = try reader["violationId"].readIfPresent()
        value.thingName = try reader["thingName"].readIfPresent()
        value.securityProfileName = try reader["securityProfileName"].readIfPresent()
        value.behavior = try reader["behavior"].readIfPresent(with: IoTClientTypes.Behavior.read(from:))
        value.lastViolationValue = try reader["lastViolationValue"].readIfPresent(with: IoTClientTypes.MetricValue.read(from:))
        value.violationEventAdditionalInfo = try reader["violationEventAdditionalInfo"].readIfPresent(with: IoTClientTypes.ViolationEventAdditionalInfo.read(from:))
        value.verificationState = try reader["verificationState"].readIfPresent()
        value.verificationStateDescription = try reader["verificationStateDescription"].readIfPresent()
        value.lastViolationTime = try reader["lastViolationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.violationStartTime = try reader["violationStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.ViolationEventAdditionalInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ViolationEventAdditionalInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ViolationEventAdditionalInfo()
        value.confidenceLevel = try reader["confidenceLevel"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.Policy {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Policy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Policy()
        value.policyName = try reader["policyName"].readIfPresent()
        value.policyArn = try reader["policyArn"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AuditMitigationActionExecutionMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuditMitigationActionExecutionMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuditMitigationActionExecutionMetadata()
        value.taskId = try reader["taskId"].readIfPresent()
        value.findingId = try reader["findingId"].readIfPresent()
        value.actionName = try reader["actionName"].readIfPresent()
        value.actionId = try reader["actionId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AuditMitigationActionsTaskMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuditMitigationActionsTaskMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuditMitigationActionsTaskMetadata()
        value.taskId = try reader["taskId"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.taskStatus = try reader["taskStatus"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AuditSuppression {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuditSuppression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuditSuppression()
        value.checkName = try reader["checkName"].readIfPresent() ?? ""
        value.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent(with: IoTClientTypes.ResourceIdentifier.read(from:))
        value.expirationDate = try reader["expirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.suppressIndefinitely = try reader["suppressIndefinitely"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AuditTaskMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuditTaskMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuditTaskMetadata()
        value.taskId = try reader["taskId"].readIfPresent()
        value.taskStatus = try reader["taskStatus"].readIfPresent()
        value.taskType = try reader["taskType"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AuthorizerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuthorizerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuthorizerSummary()
        value.authorizerName = try reader["authorizerName"].readIfPresent()
        value.authorizerArn = try reader["authorizerArn"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.CACertificate {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.CACertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.CACertificate()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateId = try reader["certificateId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.CertificateProviderSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.CertificateProviderSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.CertificateProviderSummary()
        value.certificateProviderName = try reader["certificateProviderName"].readIfPresent()
        value.certificateProviderArn = try reader["certificateProviderArn"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.Certificate {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Certificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Certificate()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateId = try reader["certificateId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.certificateMode = try reader["certificateMode"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.DetectMitigationActionExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.DetectMitigationActionExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.DetectMitigationActionExecution()
        value.taskId = try reader["taskId"].readIfPresent()
        value.violationId = try reader["violationId"].readIfPresent()
        value.actionName = try reader["actionName"].readIfPresent()
        value.thingName = try reader["thingName"].readIfPresent()
        value.executionStartDate = try reader["executionStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executionEndDate = try reader["executionEndDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.DomainConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.DomainConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.DomainConfigurationSummary()
        value.domainConfigurationName = try reader["domainConfigurationName"].readIfPresent()
        value.domainConfigurationArn = try reader["domainConfigurationArn"].readIfPresent()
        value.serviceType = try reader["serviceType"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.FleetMetricNameAndArn {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.FleetMetricNameAndArn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.FleetMetricNameAndArn()
        value.metricName = try reader["metricName"].readIfPresent()
        value.metricArn = try reader["metricArn"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.JobExecutionSummaryForJob {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.JobExecutionSummaryForJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.JobExecutionSummaryForJob()
        value.thingArn = try reader["thingArn"].readIfPresent()
        value.jobExecutionSummary = try reader["jobExecutionSummary"].readIfPresent(with: IoTClientTypes.JobExecutionSummary.read(from:))
        return value
    }
}

extension IoTClientTypes.JobExecutionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.JobExecutionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.JobExecutionSummary()
        value.status = try reader["status"].readIfPresent()
        value.queuedAt = try reader["queuedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executionNumber = try reader["executionNumber"].readIfPresent()
        value.retryAttempt = try reader["retryAttempt"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.JobExecutionSummaryForThing {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.JobExecutionSummaryForThing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.JobExecutionSummaryForThing()
        value.jobId = try reader["jobId"].readIfPresent()
        value.jobExecutionSummary = try reader["jobExecutionSummary"].readIfPresent(with: IoTClientTypes.JobExecutionSummary.read(from:))
        return value
    }
}

extension IoTClientTypes.JobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.JobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.JobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobId = try reader["jobId"].readIfPresent()
        value.thingGroupId = try reader["thingGroupId"].readIfPresent()
        value.targetSelection = try reader["targetSelection"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completedAt = try reader["completedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.isConcurrent = try reader["isConcurrent"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.JobTemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.JobTemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.JobTemplateSummary()
        value.jobTemplateArn = try reader["jobTemplateArn"].readIfPresent()
        value.jobTemplateId = try reader["jobTemplateId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.ManagedJobTemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ManagedJobTemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ManagedJobTemplateSummary()
        value.templateArn = try reader["templateArn"].readIfPresent()
        value.templateName = try reader["templateName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.environments = try reader["environments"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.templateVersion = try reader["templateVersion"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.MetricDatum {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.MetricDatum {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.MetricDatum()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.value = try reader["value"].readIfPresent(with: IoTClientTypes.MetricValue.read(from:))
        return value
    }
}

extension IoTClientTypes.MitigationActionIdentifier {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.MitigationActionIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.MitigationActionIdentifier()
        value.actionName = try reader["actionName"].readIfPresent()
        value.actionArn = try reader["actionArn"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.OTAUpdateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.OTAUpdateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.OTAUpdateSummary()
        value.otaUpdateId = try reader["otaUpdateId"].readIfPresent()
        value.otaUpdateArn = try reader["otaUpdateArn"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.OutgoingCertificate {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.OutgoingCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.OutgoingCertificate()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateId = try reader["certificateId"].readIfPresent()
        value.transferredTo = try reader["transferredTo"].readIfPresent()
        value.transferDate = try reader["transferDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.transferMessage = try reader["transferMessage"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.PackageSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.PackageSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.PackageSummary()
        value.packageName = try reader["packageName"].readIfPresent()
        value.defaultVersionName = try reader["defaultVersionName"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.PackageVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.PackageVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.PackageVersionSummary()
        value.packageName = try reader["packageName"].readIfPresent()
        value.versionName = try reader["versionName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.PolicyVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.PolicyVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.PolicyVersion()
        value.versionId = try reader["versionId"].readIfPresent()
        value.isDefaultVersion = try reader["isDefaultVersion"].readIfPresent() ?? false
        value.createDate = try reader["createDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.ProvisioningTemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ProvisioningTemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ProvisioningTemplateSummary()
        value.templateArn = try reader["templateArn"].readIfPresent()
        value.templateName = try reader["templateName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedDate = try reader["lastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.enabled = try reader["enabled"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.ProvisioningTemplateVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ProvisioningTemplateVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ProvisioningTemplateVersionSummary()
        value.versionId = try reader["versionId"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.isDefaultVersion = try reader["isDefaultVersion"].readIfPresent() ?? false
        return value
    }
}

extension IoTClientTypes.SbomValidationResultSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.SbomValidationResultSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.SbomValidationResultSummary()
        value.fileName = try reader["fileName"].readIfPresent()
        value.validationResult = try reader["validationResult"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.ScheduledAuditMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ScheduledAuditMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ScheduledAuditMetadata()
        value.scheduledAuditName = try reader["scheduledAuditName"].readIfPresent()
        value.scheduledAuditArn = try reader["scheduledAuditArn"].readIfPresent()
        value.frequency = try reader["frequency"].readIfPresent()
        value.dayOfMonth = try reader["dayOfMonth"].readIfPresent()
        value.dayOfWeek = try reader["dayOfWeek"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.SecurityProfileIdentifier {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.SecurityProfileIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.SecurityProfileIdentifier()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.SecurityProfileTargetMapping {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.SecurityProfileTargetMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.SecurityProfileTargetMapping()
        value.securityProfileIdentifier = try reader["securityProfileIdentifier"].readIfPresent(with: IoTClientTypes.SecurityProfileIdentifier.read(from:))
        value.target = try reader["target"].readIfPresent(with: IoTClientTypes.SecurityProfileTarget.read(from:))
        return value
    }
}

extension IoTClientTypes.SecurityProfileTarget {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.SecurityProfileTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.SecurityProfileTarget()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTClientTypes.StreamSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.StreamSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.StreamSummary()
        value.streamId = try reader["streamId"].readIfPresent()
        value.streamArn = try reader["streamArn"].readIfPresent()
        value.streamVersion = try reader["streamVersion"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.Tag {

    static func write(value: IoTClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.ThingAttribute {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ThingAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ThingAttribute()
        value.thingName = try reader["thingName"].readIfPresent()
        value.thingTypeName = try reader["thingTypeName"].readIfPresent()
        value.thingArn = try reader["thingArn"].readIfPresent()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent() ?? 0
        return value
    }
}

extension IoTClientTypes.ThingTypeDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ThingTypeDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ThingTypeDefinition()
        value.thingTypeName = try reader["thingTypeName"].readIfPresent()
        value.thingTypeArn = try reader["thingTypeArn"].readIfPresent()
        value.thingTypeProperties = try reader["thingTypeProperties"].readIfPresent(with: IoTClientTypes.ThingTypeProperties.read(from:))
        value.thingTypeMetadata = try reader["thingTypeMetadata"].readIfPresent(with: IoTClientTypes.ThingTypeMetadata.read(from:))
        return value
    }
}

extension IoTClientTypes.TopicRuleDestinationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.TopicRuleDestinationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.TopicRuleDestinationSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.httpUrlSummary = try reader["httpUrlSummary"].readIfPresent(with: IoTClientTypes.HttpUrlDestinationSummary.read(from:))
        value.vpcDestinationSummary = try reader["vpcDestinationSummary"].readIfPresent(with: IoTClientTypes.VpcDestinationSummary.read(from:))
        return value
    }
}

extension IoTClientTypes.VpcDestinationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.VpcDestinationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.VpcDestinationSummary()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.HttpUrlDestinationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.HttpUrlDestinationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.HttpUrlDestinationSummary()
        value.confirmationUrl = try reader["confirmationUrl"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.TopicRuleListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.TopicRuleListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.TopicRuleListItem()
        value.ruleArn = try reader["ruleArn"].readIfPresent()
        value.ruleName = try reader["ruleName"].readIfPresent()
        value.topicPattern = try reader["topicPattern"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.ruleDisabled = try reader["ruleDisabled"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.LogTargetConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.LogTargetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.LogTargetConfiguration()
        value.logTarget = try reader["logTarget"].readIfPresent(with: IoTClientTypes.LogTarget.read(from:))
        value.logLevel = try reader["logLevel"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.LogTarget {

    static func write(value: IoTClientTypes.LogTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetName"].write(value.targetName)
        try writer["targetType"].write(value.targetType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.LogTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.LogTarget()
        value.targetType = try reader["targetType"].readIfPresent() ?? .sdkUnknown("")
        value.targetName = try reader["targetName"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.ViolationEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ViolationEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ViolationEvent()
        value.violationId = try reader["violationId"].readIfPresent()
        value.thingName = try reader["thingName"].readIfPresent()
        value.securityProfileName = try reader["securityProfileName"].readIfPresent()
        value.behavior = try reader["behavior"].readIfPresent(with: IoTClientTypes.Behavior.read(from:))
        value.metricValue = try reader["metricValue"].readIfPresent(with: IoTClientTypes.MetricValue.read(from:))
        value.violationEventAdditionalInfo = try reader["violationEventAdditionalInfo"].readIfPresent(with: IoTClientTypes.ViolationEventAdditionalInfo.read(from:))
        value.violationEventType = try reader["violationEventType"].readIfPresent()
        value.verificationState = try reader["verificationState"].readIfPresent()
        value.verificationStateDescription = try reader["verificationStateDescription"].readIfPresent()
        value.violationEventTime = try reader["violationEventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTClientTypes.ThingDocument {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ThingDocument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ThingDocument()
        value.thingName = try reader["thingName"].readIfPresent()
        value.thingId = try reader["thingId"].readIfPresent()
        value.thingTypeName = try reader["thingTypeName"].readIfPresent()
        value.thingGroupNames = try reader["thingGroupNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.shadow = try reader["shadow"].readIfPresent()
        value.deviceDefender = try reader["deviceDefender"].readIfPresent()
        value.connectivity = try reader["connectivity"].readIfPresent(with: IoTClientTypes.ThingConnectivity.read(from:))
        return value
    }
}

extension IoTClientTypes.ThingConnectivity {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ThingConnectivity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ThingConnectivity()
        value.connected = try reader["connected"].readIfPresent()
        value.timestamp = try reader["timestamp"].readIfPresent()
        value.disconnectReason = try reader["disconnectReason"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.ThingGroupDocument {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ThingGroupDocument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ThingGroupDocument()
        value.thingGroupName = try reader["thingGroupName"].readIfPresent()
        value.thingGroupId = try reader["thingGroupId"].readIfPresent()
        value.thingGroupDescription = try reader["thingGroupDescription"].readIfPresent()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.parentGroupNames = try reader["parentGroupNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.AuthResult {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuthResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuthResult()
        value.authInfo = try reader["authInfo"].readIfPresent(with: IoTClientTypes.AuthInfo.read(from:))
        value.allowed = try reader["allowed"].readIfPresent(with: IoTClientTypes.Allowed.read(from:))
        value.denied = try reader["denied"].readIfPresent(with: IoTClientTypes.Denied.read(from:))
        value.authDecision = try reader["authDecision"].readIfPresent()
        value.missingContextValues = try reader["missingContextValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.Denied {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Denied {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Denied()
        value.implicitDeny = try reader["implicitDeny"].readIfPresent(with: IoTClientTypes.ImplicitDeny.read(from:))
        value.explicitDeny = try reader["explicitDeny"].readIfPresent(with: IoTClientTypes.ExplicitDeny.read(from:))
        return value
    }
}

extension IoTClientTypes.ExplicitDeny {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ExplicitDeny {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ExplicitDeny()
        value.policies = try reader["policies"].readListIfPresent(memberReadingClosure: IoTClientTypes.Policy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.ImplicitDeny {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ImplicitDeny {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ImplicitDeny()
        value.policies = try reader["policies"].readListIfPresent(memberReadingClosure: IoTClientTypes.Policy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.Allowed {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.Allowed {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.Allowed()
        value.policies = try reader["policies"].readListIfPresent(memberReadingClosure: IoTClientTypes.Policy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTClientTypes.AuthInfo {

    static func write(value: IoTClientTypes.AuthInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionType"].write(value.actionType)
        try writer["resources"].writeList(value.resources, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.AuthInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.AuthInfo()
        value.actionType = try reader["actionType"].readIfPresent()
        value.resources = try reader["resources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTClientTypes.ValidationError {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTClientTypes.ValidationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTClientTypes.ValidationError()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension IoTClientTypes.AwsJobAbortConfig {

    static func write(value: IoTClientTypes.AwsJobAbortConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["abortCriteriaList"].writeList(value.abortCriteriaList, memberWritingClosure: IoTClientTypes.AwsJobAbortCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension IoTClientTypes.AwsJobAbortCriteria {

    static func write(value: IoTClientTypes.AwsJobAbortCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["failureType"].write(value.failureType)
        try writer["minNumberOfExecutedThings"].write(value.minNumberOfExecutedThings)
        try writer["thresholdPercentage"].write(value.thresholdPercentage)
    }
}

extension IoTClientTypes.AwsJobTimeoutConfig {

    static func write(value: IoTClientTypes.AwsJobTimeoutConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inProgressTimeoutInMinutes"].write(value.inProgressTimeoutInMinutes)
    }
}

extension IoTClientTypes.TopicRulePayload {

    static func write(value: IoTClientTypes.TopicRulePayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: IoTClientTypes.Action.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["awsIotSqlVersion"].write(value.awsIotSqlVersion)
        try writer["description"].write(value.description)
        try writer["errorAction"].write(value.errorAction, with: IoTClientTypes.Action.write(value:to:))
        try writer["ruleDisabled"].write(value.ruleDisabled)
        try writer["sql"].write(value.sql)
    }
}

extension IoTClientTypes.TopicRuleDestinationConfiguration {

    static func write(value: IoTClientTypes.TopicRuleDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["httpUrlConfiguration"].write(value.httpUrlConfiguration, with: IoTClientTypes.HttpUrlDestinationConfiguration.write(value:to:))
        try writer["vpcConfiguration"].write(value.vpcConfiguration, with: IoTClientTypes.VpcDestinationConfiguration.write(value:to:))
    }
}

extension IoTClientTypes.VpcDestinationConfiguration {

    static func write(value: IoTClientTypes.VpcDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleArn"].write(value.roleArn)
        try writer["securityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpcId"].write(value.vpcId)
    }
}

extension IoTClientTypes.HttpUrlDestinationConfiguration {

    static func write(value: IoTClientTypes.HttpUrlDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["confirmationUrl"].write(value.confirmationUrl)
    }
}

extension IoTClientTypes.BucketsAggregationType {

    static func write(value: IoTClientTypes.BucketsAggregationType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["termsAggregation"].write(value.termsAggregation, with: IoTClientTypes.TermsAggregation.write(value:to:))
    }
}

extension IoTClientTypes.TermsAggregation {

    static func write(value: IoTClientTypes.TermsAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxBuckets"].write(value.maxBuckets)
    }
}

extension IoTClientTypes.LoggingOptionsPayload {

    static func write(value: IoTClientTypes.LoggingOptionsPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logLevel"].write(value.logLevel)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension IoTClientTypes.HttpContext {

    static func write(value: IoTClientTypes.HttpContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["headers"].writeMap(value.headers, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["queryString"].write(value.queryString)
    }
}

extension IoTClientTypes.MqttContext {

    static func write(value: IoTClientTypes.MqttContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientId"].write(value.clientId)
        try writer["password"].write(value.password)
        try writer["username"].write(value.username)
    }
}

extension IoTClientTypes.TlsContext {

    static func write(value: IoTClientTypes.TlsContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["serverName"].write(value.serverName)
    }
}

public enum IoTClientTypes {}
