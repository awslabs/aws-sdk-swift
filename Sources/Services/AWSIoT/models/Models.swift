// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IoTClientTypes {
    public enum AbortAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancel
        case sdkUnknown(Swift.String)

        public static var allCases: [AbortAction] {
            return [
                .cancel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AbortAction(rawValue: rawValue) ?? AbortAction.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.AbortConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criteriaList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criteriaList = criteriaList {
            var criteriaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .criteriaList)
            for abortcriteria0 in criteriaList {
                try criteriaListContainer.encode(abortcriteria0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criteriaListContainer = try containerValues.decodeIfPresent([IoTClientTypes.AbortCriteria?].self, forKey: .criteriaList)
        var criteriaListDecoded0:[IoTClientTypes.AbortCriteria]? = nil
        if let criteriaListContainer = criteriaListContainer {
            criteriaListDecoded0 = [IoTClientTypes.AbortCriteria]()
            for structure0 in criteriaListContainer {
                if let structure0 = structure0 {
                    criteriaListDecoded0?.append(structure0)
                }
            }
        }
        criteriaList = criteriaListDecoded0
    }
}

extension IoTClientTypes {
    /// The criteria that determine when and how a job abort takes place.
    public struct AbortConfig: Swift.Equatable {
        /// The list of criteria that determine when and how to abort the job.
        /// This member is required.
        public var criteriaList: [IoTClientTypes.AbortCriteria]?

        public init(
            criteriaList: [IoTClientTypes.AbortCriteria]? = nil
        )
        {
            self.criteriaList = criteriaList
        }
    }

}

extension IoTClientTypes.AbortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case failureType
        case minNumberOfExecutedThings
        case thresholdPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let failureType = self.failureType {
            try encodeContainer.encode(failureType.rawValue, forKey: .failureType)
        }
        if let minNumberOfExecutedThings = self.minNumberOfExecutedThings {
            try encodeContainer.encode(minNumberOfExecutedThings, forKey: .minNumberOfExecutedThings)
        }
        if let thresholdPercentage = self.thresholdPercentage {
            try encodeContainer.encode(thresholdPercentage, forKey: .thresholdPercentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionFailureType.self, forKey: .failureType)
        failureType = failureTypeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AbortAction.self, forKey: .action)
        action = actionDecoded
        let thresholdPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .thresholdPercentage)
        thresholdPercentage = thresholdPercentageDecoded
        let minNumberOfExecutedThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minNumberOfExecutedThings)
        minNumberOfExecutedThings = minNumberOfExecutedThingsDecoded
    }
}

extension IoTClientTypes {
    /// The criteria that determine when and how a job abort takes place.
    public struct AbortCriteria: Swift.Equatable {
        /// The type of job action to take to initiate the job abort.
        /// This member is required.
        public var action: IoTClientTypes.AbortAction?
        /// The type of job execution failures that can initiate a job abort.
        /// This member is required.
        public var failureType: IoTClientTypes.JobExecutionFailureType?
        /// The minimum number of things which must receive job execution notifications before the job can be aborted.
        /// This member is required.
        public var minNumberOfExecutedThings: Swift.Int?
        /// The minimum percentage of job execution failures that must occur to initiate the job abort. Amazon Web Services IoT Core supports up to two digits after the decimal (for example, 10.9 and 10.99, but not 10.999).
        /// This member is required.
        public var thresholdPercentage: Swift.Double?

        public init(
            action: IoTClientTypes.AbortAction? = nil,
            failureType: IoTClientTypes.JobExecutionFailureType? = nil,
            minNumberOfExecutedThings: Swift.Int? = nil,
            thresholdPercentage: Swift.Double? = nil
        )
        {
            self.action = action
            self.failureType = failureType
            self.minNumberOfExecutedThings = minNumberOfExecutedThings
            self.thresholdPercentage = thresholdPercentage
        }
    }

}

extension AcceptCertificateTransferInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let setAsActive = setAsActive {
                let setAsActiveQueryItem = ClientRuntime.URLQueryItem(name: "setAsActive".urlPercentEncoding(), value: Swift.String(setAsActive).urlPercentEncoding())
                items.append(setAsActiveQueryItem)
            }
            return items
        }
    }
}

extension AcceptCertificateTransferInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let certificateId = certificateId else {
            return nil
        }
        return "/accept-certificate-transfer/\(certificateId.urlPercentEncoding())"
    }
}

/// The input for the AcceptCertificateTransfer operation.
public struct AcceptCertificateTransferInput: Swift.Equatable {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?
    /// Specifies whether the certificate is active.
    public var setAsActive: Swift.Bool?

    public init(
        certificateId: Swift.String? = nil,
        setAsActive: Swift.Bool? = nil
    )
    {
        self.certificateId = certificateId
        self.setAsActive = setAsActive
    }
}

struct AcceptCertificateTransferInputBody: Swift.Equatable {
}

extension AcceptCertificateTransferInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AcceptCertificateTransferOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AcceptCertificateTransferOutput: Swift.Equatable {

    public init() { }
}

enum AcceptCertificateTransferOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransferAlreadyCompletedException": return try await TransferAlreadyCompletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudwatchAlarm
        case cloudwatchLogs
        case cloudwatchMetric
        case dynamoDB
        case dynamoDBv2
        case elasticsearch
        case firehose
        case http
        case iotAnalytics
        case iotEvents
        case iotSiteWise
        case kafka
        case kinesis
        case lambda
        case location
        case openSearch
        case republish
        case s3
        case salesforce
        case sns
        case sqs
        case stepFunctions
        case timestream
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudwatchAlarm = self.cloudwatchAlarm {
            try encodeContainer.encode(cloudwatchAlarm, forKey: .cloudwatchAlarm)
        }
        if let cloudwatchLogs = self.cloudwatchLogs {
            try encodeContainer.encode(cloudwatchLogs, forKey: .cloudwatchLogs)
        }
        if let cloudwatchMetric = self.cloudwatchMetric {
            try encodeContainer.encode(cloudwatchMetric, forKey: .cloudwatchMetric)
        }
        if let dynamoDB = self.dynamoDB {
            try encodeContainer.encode(dynamoDB, forKey: .dynamoDB)
        }
        if let dynamoDBv2 = self.dynamoDBv2 {
            try encodeContainer.encode(dynamoDBv2, forKey: .dynamoDBv2)
        }
        if let elasticsearch = self.elasticsearch {
            try encodeContainer.encode(elasticsearch, forKey: .elasticsearch)
        }
        if let firehose = self.firehose {
            try encodeContainer.encode(firehose, forKey: .firehose)
        }
        if let http = self.http {
            try encodeContainer.encode(http, forKey: .http)
        }
        if let iotAnalytics = self.iotAnalytics {
            try encodeContainer.encode(iotAnalytics, forKey: .iotAnalytics)
        }
        if let iotEvents = self.iotEvents {
            try encodeContainer.encode(iotEvents, forKey: .iotEvents)
        }
        if let iotSiteWise = self.iotSiteWise {
            try encodeContainer.encode(iotSiteWise, forKey: .iotSiteWise)
        }
        if let kafka = self.kafka {
            try encodeContainer.encode(kafka, forKey: .kafka)
        }
        if let kinesis = self.kinesis {
            try encodeContainer.encode(kinesis, forKey: .kinesis)
        }
        if let lambda = self.lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let openSearch = self.openSearch {
            try encodeContainer.encode(openSearch, forKey: .openSearch)
        }
        if let republish = self.republish {
            try encodeContainer.encode(republish, forKey: .republish)
        }
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let salesforce = self.salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let sns = self.sns {
            try encodeContainer.encode(sns, forKey: .sns)
        }
        if let sqs = self.sqs {
            try encodeContainer.encode(sqs, forKey: .sqs)
        }
        if let stepFunctions = self.stepFunctions {
            try encodeContainer.encode(stepFunctions, forKey: .stepFunctions)
        }
        if let timestream = self.timestream {
            try encodeContainer.encode(timestream, forKey: .timestream)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dynamoDBDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DynamoDBAction.self, forKey: .dynamoDB)
        dynamoDB = dynamoDBDecoded
        let dynamoDBv2Decoded = try containerValues.decodeIfPresent(IoTClientTypes.DynamoDBv2Action.self, forKey: .dynamoDBv2)
        dynamoDBv2 = dynamoDBv2Decoded
        let lambdaDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LambdaAction.self, forKey: .lambda)
        lambda = lambdaDecoded
        let snsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.SnsAction.self, forKey: .sns)
        sns = snsDecoded
        let sqsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.SqsAction.self, forKey: .sqs)
        sqs = sqsDecoded
        let kinesisDecoded = try containerValues.decodeIfPresent(IoTClientTypes.KinesisAction.self, forKey: .kinesis)
        kinesis = kinesisDecoded
        let republishDecoded = try containerValues.decodeIfPresent(IoTClientTypes.RepublishAction.self, forKey: .republish)
        republish = republishDecoded
        let s3Decoded = try containerValues.decodeIfPresent(IoTClientTypes.S3Action.self, forKey: .s3)
        s3 = s3Decoded
        let firehoseDecoded = try containerValues.decodeIfPresent(IoTClientTypes.FirehoseAction.self, forKey: .firehose)
        firehose = firehoseDecoded
        let cloudwatchMetricDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CloudwatchMetricAction.self, forKey: .cloudwatchMetric)
        cloudwatchMetric = cloudwatchMetricDecoded
        let cloudwatchAlarmDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CloudwatchAlarmAction.self, forKey: .cloudwatchAlarm)
        cloudwatchAlarm = cloudwatchAlarmDecoded
        let cloudwatchLogsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CloudwatchLogsAction.self, forKey: .cloudwatchLogs)
        cloudwatchLogs = cloudwatchLogsDecoded
        let elasticsearchDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ElasticsearchAction.self, forKey: .elasticsearch)
        elasticsearch = elasticsearchDecoded
        let salesforceDecoded = try containerValues.decodeIfPresent(IoTClientTypes.SalesforceAction.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let iotAnalyticsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.IotAnalyticsAction.self, forKey: .iotAnalytics)
        iotAnalytics = iotAnalyticsDecoded
        let iotEventsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.IotEventsAction.self, forKey: .iotEvents)
        iotEvents = iotEventsDecoded
        let iotSiteWiseDecoded = try containerValues.decodeIfPresent(IoTClientTypes.IotSiteWiseAction.self, forKey: .iotSiteWise)
        iotSiteWise = iotSiteWiseDecoded
        let stepFunctionsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.StepFunctionsAction.self, forKey: .stepFunctions)
        stepFunctions = stepFunctionsDecoded
        let timestreamDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TimestreamAction.self, forKey: .timestream)
        timestream = timestreamDecoded
        let httpDecoded = try containerValues.decodeIfPresent(IoTClientTypes.HttpAction.self, forKey: .http)
        http = httpDecoded
        let kafkaDecoded = try containerValues.decodeIfPresent(IoTClientTypes.KafkaAction.self, forKey: .kafka)
        kafka = kafkaDecoded
        let openSearchDecoded = try containerValues.decodeIfPresent(IoTClientTypes.OpenSearchAction.self, forKey: .openSearch)
        openSearch = openSearchDecoded
        let locationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LocationAction.self, forKey: .location)
        location = locationDecoded
    }
}

extension IoTClientTypes {
    /// Describes the actions associated with a rule.
    public struct Action: Swift.Equatable {
        /// Change the state of a CloudWatch alarm.
        public var cloudwatchAlarm: IoTClientTypes.CloudwatchAlarmAction?
        /// Send data to CloudWatch Logs.
        public var cloudwatchLogs: IoTClientTypes.CloudwatchLogsAction?
        /// Capture a CloudWatch metric.
        public var cloudwatchMetric: IoTClientTypes.CloudwatchMetricAction?
        /// Write to a DynamoDB table.
        public var dynamoDB: IoTClientTypes.DynamoDBAction?
        /// Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.
        public var dynamoDBv2: IoTClientTypes.DynamoDBv2Action?
        /// Write data to an Amazon OpenSearch Service domain. The Elasticsearch action can only be used by existing rule actions. To create a new rule action or to update an existing rule action, use the OpenSearch rule action instead. For more information, see [OpenSearchAction](https://docs.aws.amazon.com/iot/latest/apireference/API_OpenSearchAction.html).
        public var elasticsearch: IoTClientTypes.ElasticsearchAction?
        /// Write to an Amazon Kinesis Firehose stream.
        public var firehose: IoTClientTypes.FirehoseAction?
        /// Send data to an HTTPS endpoint.
        public var http: IoTClientTypes.HttpAction?
        /// Sends message data to an IoT Analytics channel.
        public var iotAnalytics: IoTClientTypes.IotAnalyticsAction?
        /// Sends an input to an IoT Events detector.
        public var iotEvents: IoTClientTypes.IotEventsAction?
        /// Sends data from the MQTT message that triggered the rule to IoT SiteWise asset properties.
        public var iotSiteWise: IoTClientTypes.IotSiteWiseAction?
        /// Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.
        public var kafka: IoTClientTypes.KafkaAction?
        /// Write data to an Amazon Kinesis stream.
        public var kinesis: IoTClientTypes.KinesisAction?
        /// Invoke a Lambda function.
        public var lambda: IoTClientTypes.LambdaAction?
        /// The Amazon Location Service rule action sends device location updates from an MQTT message to an Amazon Location tracker resource.
        public var location: IoTClientTypes.LocationAction?
        /// Write data to an Amazon OpenSearch Service domain.
        public var openSearch: IoTClientTypes.OpenSearchAction?
        /// Publish to another MQTT topic.
        public var republish: IoTClientTypes.RepublishAction?
        /// Write to an Amazon S3 bucket.
        public var s3: IoTClientTypes.S3Action?
        /// Send a message to a Salesforce IoT Cloud Input Stream.
        public var salesforce: IoTClientTypes.SalesforceAction?
        /// Publish to an Amazon SNS topic.
        public var sns: IoTClientTypes.SnsAction?
        /// Publish to an Amazon SQS queue.
        public var sqs: IoTClientTypes.SqsAction?
        /// Starts execution of a Step Functions state machine.
        public var stepFunctions: IoTClientTypes.StepFunctionsAction?
        /// The Timestream rule action writes attributes (measures) from an MQTT message into an Amazon Timestream table. For more information, see the [Timestream](https://docs.aws.amazon.com/iot/latest/developerguide/timestream-rule-action.html) topic rule action documentation.
        public var timestream: IoTClientTypes.TimestreamAction?

        public init(
            cloudwatchAlarm: IoTClientTypes.CloudwatchAlarmAction? = nil,
            cloudwatchLogs: IoTClientTypes.CloudwatchLogsAction? = nil,
            cloudwatchMetric: IoTClientTypes.CloudwatchMetricAction? = nil,
            dynamoDB: IoTClientTypes.DynamoDBAction? = nil,
            dynamoDBv2: IoTClientTypes.DynamoDBv2Action? = nil,
            elasticsearch: IoTClientTypes.ElasticsearchAction? = nil,
            firehose: IoTClientTypes.FirehoseAction? = nil,
            http: IoTClientTypes.HttpAction? = nil,
            iotAnalytics: IoTClientTypes.IotAnalyticsAction? = nil,
            iotEvents: IoTClientTypes.IotEventsAction? = nil,
            iotSiteWise: IoTClientTypes.IotSiteWiseAction? = nil,
            kafka: IoTClientTypes.KafkaAction? = nil,
            kinesis: IoTClientTypes.KinesisAction? = nil,
            lambda: IoTClientTypes.LambdaAction? = nil,
            location: IoTClientTypes.LocationAction? = nil,
            openSearch: IoTClientTypes.OpenSearchAction? = nil,
            republish: IoTClientTypes.RepublishAction? = nil,
            s3: IoTClientTypes.S3Action? = nil,
            salesforce: IoTClientTypes.SalesforceAction? = nil,
            sns: IoTClientTypes.SnsAction? = nil,
            sqs: IoTClientTypes.SqsAction? = nil,
            stepFunctions: IoTClientTypes.StepFunctionsAction? = nil,
            timestream: IoTClientTypes.TimestreamAction? = nil
        )
        {
            self.cloudwatchAlarm = cloudwatchAlarm
            self.cloudwatchLogs = cloudwatchLogs
            self.cloudwatchMetric = cloudwatchMetric
            self.dynamoDB = dynamoDB
            self.dynamoDBv2 = dynamoDBv2
            self.elasticsearch = elasticsearch
            self.firehose = firehose
            self.http = http
            self.iotAnalytics = iotAnalytics
            self.iotEvents = iotEvents
            self.iotSiteWise = iotSiteWise
            self.kafka = kafka
            self.kinesis = kinesis
            self.lambda = lambda
            self.location = location
            self.openSearch = openSearch
            self.republish = republish
            self.s3 = s3
            self.salesforce = salesforce
            self.sns = sns
            self.sqs = sqs
            self.stepFunctions = stepFunctions
            self.timestream = timestream
        }
    }

}

extension IoTClientTypes {
    public enum ActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connect
        case publish
        case receive
        case subscribe
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionType] {
            return [
                .connect,
                .publish,
                .receive,
                .subscribe,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connect: return "CONNECT"
            case .publish: return "PUBLISH"
            case .receive: return "RECEIVE"
            case .subscribe: return "SUBSCRIBE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionType(rawValue: rawValue) ?? ActionType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.ActiveViolation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case behavior
        case lastViolationTime
        case lastViolationValue
        case securityProfileName
        case thingName
        case verificationState
        case verificationStateDescription
        case violationEventAdditionalInfo
        case violationId
        case violationStartTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behavior = self.behavior {
            try encodeContainer.encode(behavior, forKey: .behavior)
        }
        if let lastViolationTime = self.lastViolationTime {
            try encodeContainer.encodeTimestamp(lastViolationTime, format: .epochSeconds, forKey: .lastViolationTime)
        }
        if let lastViolationValue = self.lastViolationValue {
            try encodeContainer.encode(lastViolationValue, forKey: .lastViolationValue)
        }
        if let securityProfileName = self.securityProfileName {
            try encodeContainer.encode(securityProfileName, forKey: .securityProfileName)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
        if let verificationState = self.verificationState {
            try encodeContainer.encode(verificationState.rawValue, forKey: .verificationState)
        }
        if let verificationStateDescription = self.verificationStateDescription {
            try encodeContainer.encode(verificationStateDescription, forKey: .verificationStateDescription)
        }
        if let violationEventAdditionalInfo = self.violationEventAdditionalInfo {
            try encodeContainer.encode(violationEventAdditionalInfo, forKey: .violationEventAdditionalInfo)
        }
        if let violationId = self.violationId {
            try encodeContainer.encode(violationId, forKey: .violationId)
        }
        if let violationStartTime = self.violationStartTime {
            try encodeContainer.encodeTimestamp(violationStartTime, format: .epochSeconds, forKey: .violationStartTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationId)
        violationId = violationIdDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let behaviorDecoded = try containerValues.decodeIfPresent(IoTClientTypes.Behavior.self, forKey: .behavior)
        behavior = behaviorDecoded
        let lastViolationValueDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MetricValue.self, forKey: .lastViolationValue)
        lastViolationValue = lastViolationValueDecoded
        let violationEventAdditionalInfoDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ViolationEventAdditionalInfo.self, forKey: .violationEventAdditionalInfo)
        violationEventAdditionalInfo = violationEventAdditionalInfoDecoded
        let verificationStateDecoded = try containerValues.decodeIfPresent(IoTClientTypes.VerificationState.self, forKey: .verificationState)
        verificationState = verificationStateDecoded
        let verificationStateDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationStateDescription)
        verificationStateDescription = verificationStateDescriptionDecoded
        let lastViolationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastViolationTime)
        lastViolationTime = lastViolationTimeDecoded
        let violationStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .violationStartTime)
        violationStartTime = violationStartTimeDecoded
    }
}

extension IoTClientTypes {
    /// Information about an active Device Defender security profile behavior violation.
    public struct ActiveViolation: Swift.Equatable {
        /// The behavior that is being violated.
        public var behavior: IoTClientTypes.Behavior?
        /// The time the most recent violation occurred.
        public var lastViolationTime: ClientRuntime.Date?
        /// The value of the metric (the measurement) that caused the most recent violation.
        public var lastViolationValue: IoTClientTypes.MetricValue?
        /// The security profile with the behavior is in violation.
        public var securityProfileName: Swift.String?
        /// The name of the thing responsible for the active violation.
        public var thingName: Swift.String?
        /// The verification state of the violation (detect alarm).
        public var verificationState: IoTClientTypes.VerificationState?
        /// The description of the verification state of the violation.
        public var verificationStateDescription: Swift.String?
        /// The details of a violation event.
        public var violationEventAdditionalInfo: IoTClientTypes.ViolationEventAdditionalInfo?
        /// The ID of the active violation.
        public var violationId: Swift.String?
        /// The time the violation started.
        public var violationStartTime: ClientRuntime.Date?

        public init(
            behavior: IoTClientTypes.Behavior? = nil,
            lastViolationTime: ClientRuntime.Date? = nil,
            lastViolationValue: IoTClientTypes.MetricValue? = nil,
            securityProfileName: Swift.String? = nil,
            thingName: Swift.String? = nil,
            verificationState: IoTClientTypes.VerificationState? = nil,
            verificationStateDescription: Swift.String? = nil,
            violationEventAdditionalInfo: IoTClientTypes.ViolationEventAdditionalInfo? = nil,
            violationId: Swift.String? = nil,
            violationStartTime: ClientRuntime.Date? = nil
        )
        {
            self.behavior = behavior
            self.lastViolationTime = lastViolationTime
            self.lastViolationValue = lastViolationValue
            self.securityProfileName = securityProfileName
            self.thingName = thingName
            self.verificationState = verificationState
            self.verificationStateDescription = verificationStateDescription
            self.violationEventAdditionalInfo = violationEventAdditionalInfo
            self.violationId = violationId
            self.violationStartTime = violationStartTime
        }
    }

}

extension AddThingToBillingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupArn
        case billingGroupName
        case thingArn
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupArn = self.billingGroupArn {
            try encodeContainer.encode(billingGroupArn, forKey: .billingGroupArn)
        }
        if let billingGroupName = self.billingGroupName {
            try encodeContainer.encode(billingGroupName, forKey: .billingGroupName)
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

extension AddThingToBillingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/billing-groups/addThingToBillingGroup"
    }
}

public struct AddThingToBillingGroupInput: Swift.Equatable {
    /// The ARN of the billing group.
    public var billingGroupArn: Swift.String?
    /// The name of the billing group. This call is asynchronous. It might take several seconds for the detachment to propagate.
    public var billingGroupName: Swift.String?
    /// The ARN of the thing to be added to the billing group.
    public var thingArn: Swift.String?
    /// The name of the thing to be added to the billing group.
    public var thingName: Swift.String?

    public init(
        billingGroupArn: Swift.String? = nil,
        billingGroupName: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingGroupName = billingGroupName
        self.thingArn = thingArn
        self.thingName = thingName
    }
}

struct AddThingToBillingGroupInputBody: Swift.Equatable {
    let billingGroupName: Swift.String?
    let billingGroupArn: Swift.String?
    let thingName: Swift.String?
    let thingArn: Swift.String?
}

extension AddThingToBillingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupArn
        case billingGroupName
        case thingArn
        case thingName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupName)
        billingGroupName = billingGroupNameDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension AddThingToBillingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AddThingToBillingGroupOutput: Swift.Equatable {

    public init() { }
}

enum AddThingToBillingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AddThingToThingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrideDynamicGroups
        case thingArn
        case thingGroupArn
        case thingGroupName
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrideDynamicGroups = self.overrideDynamicGroups {
            try encodeContainer.encode(overrideDynamicGroups, forKey: .overrideDynamicGroups)
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let thingGroupArn = self.thingGroupArn {
            try encodeContainer.encode(thingGroupArn, forKey: .thingGroupArn)
        }
        if let thingGroupName = self.thingGroupName {
            try encodeContainer.encode(thingGroupName, forKey: .thingGroupName)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

extension AddThingToThingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/thing-groups/addThingToThingGroup"
    }
}

public struct AddThingToThingGroupInput: Swift.Equatable {
    /// Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.
    public var overrideDynamicGroups: Swift.Bool?
    /// The ARN of the thing to add to a group.
    public var thingArn: Swift.String?
    /// The ARN of the group to which you are adding a thing.
    public var thingGroupArn: Swift.String?
    /// The name of the group to which you are adding a thing.
    public var thingGroupName: Swift.String?
    /// The name of the thing to add to a group.
    public var thingName: Swift.String?

    public init(
        overrideDynamicGroups: Swift.Bool? = nil,
        thingArn: Swift.String? = nil,
        thingGroupArn: Swift.String? = nil,
        thingGroupName: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.overrideDynamicGroups = overrideDynamicGroups
        self.thingArn = thingArn
        self.thingGroupArn = thingGroupArn
        self.thingGroupName = thingGroupName
        self.thingName = thingName
    }
}

struct AddThingToThingGroupInputBody: Swift.Equatable {
    let thingGroupName: Swift.String?
    let thingGroupArn: Swift.String?
    let thingName: Swift.String?
    let thingArn: Swift.String?
    let overrideDynamicGroups: Swift.Bool?
}

extension AddThingToThingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrideDynamicGroups
        case thingArn
        case thingGroupArn
        case thingGroupName
        case thingName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupName)
        thingGroupName = thingGroupNameDecoded
        let thingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupArn)
        thingGroupArn = thingGroupArnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let overrideDynamicGroupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overrideDynamicGroups)
        overrideDynamicGroups = overrideDynamicGroupsDecoded
    }
}

extension AddThingToThingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AddThingToThingGroupOutput: Swift.Equatable {

    public init() { }
}

enum AddThingToThingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.AddThingsToThingGroupParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrideDynamicGroups
        case thingGroupNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrideDynamicGroups = self.overrideDynamicGroups {
            try encodeContainer.encode(overrideDynamicGroups, forKey: .overrideDynamicGroups)
        }
        if let thingGroupNames = thingGroupNames {
            var thingGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .thingGroupNames)
            for thinggroupname0 in thingGroupNames {
                try thingGroupNamesContainer.encode(thinggroupname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .thingGroupNames)
        var thingGroupNamesDecoded0:[Swift.String]? = nil
        if let thingGroupNamesContainer = thingGroupNamesContainer {
            thingGroupNamesDecoded0 = [Swift.String]()
            for string0 in thingGroupNamesContainer {
                if let string0 = string0 {
                    thingGroupNamesDecoded0?.append(string0)
                }
            }
        }
        thingGroupNames = thingGroupNamesDecoded0
        let overrideDynamicGroupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overrideDynamicGroups)
        overrideDynamicGroups = overrideDynamicGroupsDecoded
    }
}

extension IoTClientTypes {
    /// Parameters used when defining a mitigation action that move a set of things to a thing group.
    public struct AddThingsToThingGroupParams: Swift.Equatable {
        /// Specifies if this mitigation action can move the things that triggered the mitigation action even if they are part of one or more dynamic thing groups.
        public var overrideDynamicGroups: Swift.Bool?
        /// The list of groups to which you want to add the things that triggered the mitigation action. You can add a thing to a maximum of 10 groups, but you can't add a thing to more than one group in the same hierarchy.
        /// This member is required.
        public var thingGroupNames: [Swift.String]?

        public init(
            overrideDynamicGroups: Swift.Bool? = nil,
            thingGroupNames: [Swift.String]? = nil
        )
        {
            self.overrideDynamicGroups = overrideDynamicGroups
            self.thingGroupNames = thingGroupNames
        }
    }

}

extension IoTClientTypes.AggregationType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for aggregationtypevalue0 in values {
                try valuesContainer.encode(aggregationtypevalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AggregationTypeName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension IoTClientTypes {
    /// The type of aggregation queries.
    public struct AggregationType: Swift.Equatable {
        /// The name of the aggregation type.
        /// This member is required.
        public var name: IoTClientTypes.AggregationTypeName?
        /// A list of the values of aggregation types.
        public var values: [Swift.String]?

        public init(
            name: IoTClientTypes.AggregationTypeName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension IoTClientTypes {
    public enum AggregationTypeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cardinality
        case percentiles
        case statistics
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationTypeName] {
            return [
                .cardinality,
                .percentiles,
                .statistics,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cardinality: return "Cardinality"
            case .percentiles: return "Percentiles"
            case .statistics: return "Statistics"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationTypeName(rawValue: rawValue) ?? AggregationTypeName.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.AlertTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertTargetArn
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alertTargetArn = self.alertTargetArn {
            try encodeContainer.encode(alertTargetArn, forKey: .alertTargetArn)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertTargetArn)
        alertTargetArn = alertTargetArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTClientTypes {
    /// A structure containing the alert target ARN and the role ARN.
    public struct AlertTarget: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the notification target to which alerts are sent.
        /// This member is required.
        public var alertTargetArn: Swift.String?
        /// The ARN of the role that grants permission to send alerts to the notification target.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            alertTargetArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.alertTargetArn = alertTargetArn
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes {
    /// The type of alert target: one of "SNS".
    public enum AlertTargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [AlertTargetType] {
            return [
                .sns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlertTargetType(rawValue: rawValue) ?? AlertTargetType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.Allowed: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policies
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for policy0 in policies {
                try policiesContainer.encode(policy0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([IoTClientTypes.Policy?].self, forKey: .policies)
        var policiesDecoded0:[IoTClientTypes.Policy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [IoTClientTypes.Policy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
    }
}

extension IoTClientTypes {
    /// Contains information that allowed the authorization.
    public struct Allowed: Swift.Equatable {
        /// A list of policies that allowed the authentication.
        public var policies: [IoTClientTypes.Policy]?

        public init(
            policies: [IoTClientTypes.Policy]? = nil
        )
        {
            self.policies = policies
        }
    }

}

extension IoTClientTypes.AssetPropertyTimestamp: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offsetInNanos
        case timeInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offsetInNanos = self.offsetInNanos {
            try encodeContainer.encode(offsetInNanos, forKey: .offsetInNanos)
        }
        if let timeInSeconds = self.timeInSeconds {
            try encodeContainer.encode(timeInSeconds, forKey: .timeInSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeInSeconds)
        timeInSeconds = timeInSecondsDecoded
        let offsetInNanosDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offsetInNanos)
        offsetInNanos = offsetInNanosDecoded
    }
}

extension IoTClientTypes {
    /// An asset property timestamp entry containing the following information.
    public struct AssetPropertyTimestamp: Swift.Equatable {
        /// Optional. A string that contains the nanosecond time offset. Accepts substitution templates.
        public var offsetInNanos: Swift.String?
        /// A string that contains the time in seconds since epoch. Accepts substitution templates.
        /// This member is required.
        public var timeInSeconds: Swift.String?

        public init(
            offsetInNanos: Swift.String? = nil,
            timeInSeconds: Swift.String? = nil
        )
        {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }
    }

}

extension IoTClientTypes.AssetPropertyValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quality
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quality = self.quality {
            try encodeContainer.encode(quality, forKey: .quality)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AssetPropertyVariant.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AssetPropertyTimestamp.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let qualityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quality)
        quality = qualityDecoded
    }
}

extension IoTClientTypes {
    /// An asset property value entry containing the following information.
    public struct AssetPropertyValue: Swift.Equatable {
        /// Optional. A string that describes the quality of the value. Accepts substitution templates. Must be GOOD, BAD, or UNCERTAIN.
        public var quality: Swift.String?
        /// The asset property value timestamp.
        /// This member is required.
        public var timestamp: IoTClientTypes.AssetPropertyTimestamp?
        /// The value of the asset property.
        /// This member is required.
        public var value: IoTClientTypes.AssetPropertyVariant?

        public init(
            quality: Swift.String? = nil,
            timestamp: IoTClientTypes.AssetPropertyTimestamp? = nil,
            value: IoTClientTypes.AssetPropertyVariant? = nil
        )
        {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTClientTypes.AssetPropertyVariant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case booleanvalue = "booleanValue"
        case doublevalue = "doubleValue"
        case integervalue = "integerValue"
        case sdkUnknown
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .booleanvalue(booleanvalue):
                try container.encode(booleanvalue, forKey: .booleanvalue)
            case let .doublevalue(doublevalue):
                try container.encode(doublevalue, forKey: .doublevalue)
            case let .integervalue(integervalue):
                try container.encode(integervalue, forKey: .integervalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let integervalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .integervalue)
        if let integervalue = integervalueDecoded {
            self = .integervalue(integervalue)
            return
        }
        let doublevalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .doublevalue)
        if let doublevalue = doublevalueDecoded {
            self = .doublevalue(doublevalue)
            return
        }
        let booleanvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .booleanvalue)
        if let booleanvalue = booleanvalueDecoded {
            self = .booleanvalue(booleanvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTClientTypes {
    /// Contains an asset property value (of a single type).
    public enum AssetPropertyVariant: Swift.Equatable {
        /// Optional. The string value of the value entry. Accepts substitution templates.
        case stringvalue(Swift.String)
        /// Optional. A string that contains the integer value of the value entry. Accepts substitution templates.
        case integervalue(Swift.String)
        /// Optional. A string that contains the double value of the value entry. Accepts substitution templates.
        case doublevalue(Swift.String)
        /// Optional. A string that contains the boolean value (true or false) of the value entry. Accepts substitution templates.
        case booleanvalue(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AssociateTargetsWithJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targetarn0 in targets {
                try targetsContainer.encode(targetarn0)
            }
        }
    }
}

extension AssociateTargetsWithJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let namespaceId = namespaceId {
                let namespaceIdQueryItem = ClientRuntime.URLQueryItem(name: "namespaceId".urlPercentEncoding(), value: Swift.String(namespaceId).urlPercentEncoding())
                items.append(namespaceIdQueryItem)
            }
            return items
        }
    }
}

extension AssociateTargetsWithJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())/targets"
    }
}

public struct AssociateTargetsWithJobInput: Swift.Equatable {
    /// An optional comment string describing why the job was associated with the targets.
    public var comment: Swift.String?
    /// The unique identifier you assigned to this job when it was created.
    /// This member is required.
    public var jobId: Swift.String?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is in public preview.
    public var namespaceId: Swift.String?
    /// A list of thing group ARNs that define the targets of the job.
    /// This member is required.
    public var targets: [Swift.String]?

    public init(
        comment: Swift.String? = nil,
        jobId: Swift.String? = nil,
        namespaceId: Swift.String? = nil,
        targets: [Swift.String]? = nil
    )
    {
        self.comment = comment
        self.jobId = jobId
        self.namespaceId = namespaceId
        self.targets = targets
    }
}

struct AssociateTargetsWithJobInputBody: Swift.Equatable {
    let targets: [Swift.String]?
    let comment: Swift.String?
}

extension AssociateTargetsWithJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case targets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension AssociateTargetsWithJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateTargetsWithJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.jobArn = output.jobArn
            self.jobId = output.jobId
        } else {
            self.description = nil
            self.jobArn = nil
            self.jobId = nil
        }
    }
}

public struct AssociateTargetsWithJobOutput: Swift.Equatable {
    /// A short text description of the job.
    public var description: Swift.String?
    /// An ARN identifying the job.
    public var jobArn: Swift.String?
    /// The unique identifier you assigned to this job when it was created.
    public var jobId: Swift.String?

    public init(
        description: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.description = description
        self.jobArn = jobArn
        self.jobId = jobId
    }
}

struct AssociateTargetsWithJobOutputBody: Swift.Equatable {
    let jobArn: Swift.String?
    let jobId: Swift.String?
    let description: Swift.String?
}

extension AssociateTargetsWithJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case jobArn
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum AssociateTargetsWithJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AttachPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension AttachPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let policyName = policyName else {
            return nil
        }
        return "/target-policies/\(policyName.urlPercentEncoding())"
    }
}

public struct AttachPolicyInput: Swift.Equatable {
    /// The name of the policy to attach.
    /// This member is required.
    public var policyName: Swift.String?
    /// The [identity](https://docs.aws.amazon.com/iot/latest/developerguide/security-iam.html) to which the policy is attached. For example, a thing group or a certificate.
    /// This member is required.
    public var target: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.target = target
    }
}

struct AttachPolicyInputBody: Swift.Equatable {
    let target: Swift.String?
}

extension AttachPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case target
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension AttachPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AttachPolicyOutput: Swift.Equatable {

    public init() { }
}

enum AttachPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AttachPrincipalPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let principal = principal {
            items.add(Header(name: "x-amzn-iot-principal", value: Swift.String(principal)))
        }
        return items
    }
}

extension AttachPrincipalPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let policyName = policyName else {
            return nil
        }
        return "/principal-policies/\(policyName.urlPercentEncoding())"
    }
}

/// The input for the AttachPrincipalPolicy operation.
public struct AttachPrincipalPolicyInput: Swift.Equatable {
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?
    /// The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
    /// This member is required.
    public var principal: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        principal: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.principal = principal
    }
}

struct AttachPrincipalPolicyInputBody: Swift.Equatable {
}

extension AttachPrincipalPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AttachPrincipalPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AttachPrincipalPolicyOutput: Swift.Equatable {

    public init() { }
}

enum AttachPrincipalPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AttachSecurityProfileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let securityProfileTargetArn = securityProfileTargetArn else {
                let message = "Creating a URL Query Item failed. securityProfileTargetArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let securityProfileTargetArnQueryItem = ClientRuntime.URLQueryItem(name: "securityProfileTargetArn".urlPercentEncoding(), value: Swift.String(securityProfileTargetArn).urlPercentEncoding())
            items.append(securityProfileTargetArnQueryItem)
            return items
        }
    }
}

extension AttachSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let securityProfileName = securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())/targets"
    }
}

public struct AttachSecurityProfileInput: Swift.Equatable {
    /// The security profile that is attached.
    /// This member is required.
    public var securityProfileName: Swift.String?
    /// The ARN of the target (thing group) to which the security profile is attached.
    /// This member is required.
    public var securityProfileTargetArn: Swift.String?

    public init(
        securityProfileName: Swift.String? = nil,
        securityProfileTargetArn: Swift.String? = nil
    )
    {
        self.securityProfileName = securityProfileName
        self.securityProfileTargetArn = securityProfileTargetArn
    }
}

struct AttachSecurityProfileInputBody: Swift.Equatable {
}

extension AttachSecurityProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AttachSecurityProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AttachSecurityProfileOutput: Swift.Equatable {

    public init() { }
}

enum AttachSecurityProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AttachThingPrincipalInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let principal = principal {
            items.add(Header(name: "x-amzn-principal", value: Swift.String(principal)))
        }
        return items
    }
}

extension AttachThingPrincipalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/principals"
    }
}

/// The input for the AttachThingPrincipal operation.
public struct AttachThingPrincipalInput: Swift.Equatable {
    /// The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
    /// This member is required.
    public var principal: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        principal: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.principal = principal
        self.thingName = thingName
    }
}

struct AttachThingPrincipalInputBody: Swift.Equatable {
}

extension AttachThingPrincipalInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AttachThingPrincipalOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The output from the AttachThingPrincipal operation.
public struct AttachThingPrincipalOutput: Swift.Equatable {

    public init() { }
}

enum AttachThingPrincipalOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.AttributePayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case merge
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if merge != false {
            try encodeContainer.encode(merge, forKey: .merge)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let mergeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .merge) ?? false
        merge = mergeDecoded
    }
}

extension IoTClientTypes {
    /// The attribute payload.
    public struct AttributePayload: Swift.Equatable {
        /// A JSON string containing up to three key-value pair in JSON format. For example: {\"attributes\":{\"string1\":\"string2\"}}
        public var attributes: [Swift.String:Swift.String]?
        /// Specifies whether the list of attributes provided in the AttributePayload is merged with the attributes stored in the registry, instead of overwriting them. To remove an attribute, call UpdateThing with an empty attribute value. The merge attribute is only valid when calling UpdateThing or UpdateThingGroup.
        public var merge: Swift.Bool

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            merge: Swift.Bool = false
        )
        {
            self.attributes = attributes
            self.merge = merge
        }
    }

}

extension IoTClientTypes.AuditCheckConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension IoTClientTypes {
    /// Which audit checks are enabled and disabled for this account.
    public struct AuditCheckConfiguration: Swift.Equatable {
        /// True if this audit check is enabled for this account.
        public var enabled: Swift.Bool

        public init(
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension IoTClientTypes.AuditCheckDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkCompliant
        case checkRunStatus
        case errorCode
        case message
        case nonCompliantResourcesCount
        case suppressedNonCompliantResourcesCount
        case totalResourcesCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkCompliant = self.checkCompliant {
            try encodeContainer.encode(checkCompliant, forKey: .checkCompliant)
        }
        if let checkRunStatus = self.checkRunStatus {
            try encodeContainer.encode(checkRunStatus.rawValue, forKey: .checkRunStatus)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let nonCompliantResourcesCount = self.nonCompliantResourcesCount {
            try encodeContainer.encode(nonCompliantResourcesCount, forKey: .nonCompliantResourcesCount)
        }
        if let suppressedNonCompliantResourcesCount = self.suppressedNonCompliantResourcesCount {
            try encodeContainer.encode(suppressedNonCompliantResourcesCount, forKey: .suppressedNonCompliantResourcesCount)
        }
        if let totalResourcesCount = self.totalResourcesCount {
            try encodeContainer.encode(totalResourcesCount, forKey: .totalResourcesCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkRunStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditCheckRunStatus.self, forKey: .checkRunStatus)
        checkRunStatus = checkRunStatusDecoded
        let checkCompliantDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .checkCompliant)
        checkCompliant = checkCompliantDecoded
        let totalResourcesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResourcesCount)
        totalResourcesCount = totalResourcesCountDecoded
        let nonCompliantResourcesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nonCompliantResourcesCount)
        nonCompliantResourcesCount = nonCompliantResourcesCountDecoded
        let suppressedNonCompliantResourcesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .suppressedNonCompliantResourcesCount)
        suppressedNonCompliantResourcesCount = suppressedNonCompliantResourcesCountDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes {
    /// Information about the audit check.
    public struct AuditCheckDetails: Swift.Equatable {
        /// True if the check is complete and found all resources compliant.
        public var checkCompliant: Swift.Bool?
        /// The completion status of this check. One of "IN_PROGRESS", "WAITING_FOR_DATA_COLLECTION", "CANCELED", "COMPLETED_COMPLIANT", "COMPLETED_NON_COMPLIANT", or "FAILED".
        public var checkRunStatus: IoTClientTypes.AuditCheckRunStatus?
        /// The code of any error encountered when this check is performed during this audit. One of "INSUFFICIENT_PERMISSIONS" or "AUDIT_CHECK_DISABLED".
        public var errorCode: Swift.String?
        /// The message associated with any error encountered when this check is performed during this audit.
        public var message: Swift.String?
        /// The number of resources that were found noncompliant during the check.
        public var nonCompliantResourcesCount: Swift.Int?
        /// Describes how many of the non-compliant resources created during the evaluation of an audit check were marked as suppressed.
        public var suppressedNonCompliantResourcesCount: Swift.Int?
        /// The number of resources on which the check was performed.
        public var totalResourcesCount: Swift.Int?

        public init(
            checkCompliant: Swift.Bool? = nil,
            checkRunStatus: IoTClientTypes.AuditCheckRunStatus? = nil,
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil,
            nonCompliantResourcesCount: Swift.Int? = nil,
            suppressedNonCompliantResourcesCount: Swift.Int? = nil,
            totalResourcesCount: Swift.Int? = nil
        )
        {
            self.checkCompliant = checkCompliant
            self.checkRunStatus = checkRunStatus
            self.errorCode = errorCode
            self.message = message
            self.nonCompliantResourcesCount = nonCompliantResourcesCount
            self.suppressedNonCompliantResourcesCount = suppressedNonCompliantResourcesCount
            self.totalResourcesCount = totalResourcesCount
        }
    }

}

extension IoTClientTypes {
    public enum AuditCheckRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case completedCompliant
        case completedNonCompliant
        case failed
        case inProgress
        case waitingForDataCollection
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditCheckRunStatus] {
            return [
                .canceled,
                .completedCompliant,
                .completedNonCompliant,
                .failed,
                .inProgress,
                .waitingForDataCollection,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completedCompliant: return "COMPLETED_COMPLIANT"
            case .completedNonCompliant: return "COMPLETED_NON_COMPLIANT"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .waitingForDataCollection: return "WAITING_FOR_DATA_COLLECTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuditCheckRunStatus(rawValue: rawValue) ?? AuditCheckRunStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.AuditFinding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName
        case findingId
        case findingTime
        case isSuppressed
        case nonCompliantResource
        case reasonForNonCompliance
        case reasonForNonComplianceCode
        case relatedResources
        case severity
        case taskId
        case taskStartTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = self.checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let findingId = self.findingId {
            try encodeContainer.encode(findingId, forKey: .findingId)
        }
        if let findingTime = self.findingTime {
            try encodeContainer.encodeTimestamp(findingTime, format: .epochSeconds, forKey: .findingTime)
        }
        if let isSuppressed = self.isSuppressed {
            try encodeContainer.encode(isSuppressed, forKey: .isSuppressed)
        }
        if let nonCompliantResource = self.nonCompliantResource {
            try encodeContainer.encode(nonCompliantResource, forKey: .nonCompliantResource)
        }
        if let reasonForNonCompliance = self.reasonForNonCompliance {
            try encodeContainer.encode(reasonForNonCompliance, forKey: .reasonForNonCompliance)
        }
        if let reasonForNonComplianceCode = self.reasonForNonComplianceCode {
            try encodeContainer.encode(reasonForNonComplianceCode, forKey: .reasonForNonComplianceCode)
        }
        if let relatedResources = relatedResources {
            var relatedResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedResources)
            for relatedresource0 in relatedResources {
                try relatedResourcesContainer.encode(relatedresource0)
            }
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStartTime = self.taskStartTime {
            try encodeContainer.encodeTimestamp(taskStartTime, format: .epochSeconds, forKey: .taskStartTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingId)
        findingId = findingIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let checkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let taskStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .taskStartTime)
        taskStartTime = taskStartTimeDecoded
        let findingTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .findingTime)
        findingTime = findingTimeDecoded
        let severityDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditFindingSeverity.self, forKey: .severity)
        severity = severityDecoded
        let nonCompliantResourceDecoded = try containerValues.decodeIfPresent(IoTClientTypes.NonCompliantResource.self, forKey: .nonCompliantResource)
        nonCompliantResource = nonCompliantResourceDecoded
        let relatedResourcesContainer = try containerValues.decodeIfPresent([IoTClientTypes.RelatedResource?].self, forKey: .relatedResources)
        var relatedResourcesDecoded0:[IoTClientTypes.RelatedResource]? = nil
        if let relatedResourcesContainer = relatedResourcesContainer {
            relatedResourcesDecoded0 = [IoTClientTypes.RelatedResource]()
            for structure0 in relatedResourcesContainer {
                if let structure0 = structure0 {
                    relatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        relatedResources = relatedResourcesDecoded0
        let reasonForNonComplianceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reasonForNonCompliance)
        reasonForNonCompliance = reasonForNonComplianceDecoded
        let reasonForNonComplianceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reasonForNonComplianceCode)
        reasonForNonComplianceCode = reasonForNonComplianceCodeDecoded
        let isSuppressedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSuppressed)
        isSuppressed = isSuppressedDecoded
    }
}

extension IoTClientTypes {
    /// The findings (results) of the audit.
    public struct AuditFinding: Swift.Equatable {
        /// The audit check that generated this result.
        public var checkName: Swift.String?
        /// A unique identifier for this set of audit findings. This identifier is used to apply mitigation tasks to one or more sets of findings.
        public var findingId: Swift.String?
        /// The time the result (finding) was discovered.
        public var findingTime: ClientRuntime.Date?
        /// Indicates whether the audit finding was suppressed or not during reporting.
        public var isSuppressed: Swift.Bool?
        /// The resource that was found to be noncompliant with the audit check.
        public var nonCompliantResource: IoTClientTypes.NonCompliantResource?
        /// The reason the resource was noncompliant.
        public var reasonForNonCompliance: Swift.String?
        /// A code that indicates the reason that the resource was noncompliant.
        public var reasonForNonComplianceCode: Swift.String?
        /// The list of related resources.
        public var relatedResources: [IoTClientTypes.RelatedResource]?
        /// The severity of the result (finding).
        public var severity: IoTClientTypes.AuditFindingSeverity?
        /// The ID of the audit that generated this result (finding).
        public var taskId: Swift.String?
        /// The time the audit started.
        public var taskStartTime: ClientRuntime.Date?

        public init(
            checkName: Swift.String? = nil,
            findingId: Swift.String? = nil,
            findingTime: ClientRuntime.Date? = nil,
            isSuppressed: Swift.Bool? = nil,
            nonCompliantResource: IoTClientTypes.NonCompliantResource? = nil,
            reasonForNonCompliance: Swift.String? = nil,
            reasonForNonComplianceCode: Swift.String? = nil,
            relatedResources: [IoTClientTypes.RelatedResource]? = nil,
            severity: IoTClientTypes.AuditFindingSeverity? = nil,
            taskId: Swift.String? = nil,
            taskStartTime: ClientRuntime.Date? = nil
        )
        {
            self.checkName = checkName
            self.findingId = findingId
            self.findingTime = findingTime
            self.isSuppressed = isSuppressed
            self.nonCompliantResource = nonCompliantResource
            self.reasonForNonCompliance = reasonForNonCompliance
            self.reasonForNonComplianceCode = reasonForNonComplianceCode
            self.relatedResources = relatedResources
            self.severity = severity
            self.taskId = taskId
            self.taskStartTime = taskStartTime
        }
    }

}

extension IoTClientTypes {
    public enum AuditFindingSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditFindingSeverity] {
            return [
                .critical,
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuditFindingSeverity(rawValue: rawValue) ?? AuditFindingSeverity.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum AuditFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case biweekly
        case daily
        case monthly
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditFrequency] {
            return [
                .biweekly,
                .daily,
                .monthly,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .biweekly: return "BIWEEKLY"
            case .daily: return "DAILY"
            case .monthly: return "MONTHLY"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuditFrequency(rawValue: rawValue) ?? AuditFrequency.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.AuditMitigationActionExecutionMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case actionName
        case endTime
        case errorCode
        case findingId
        case message
        case startTime
        case status
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let findingId = self.findingId {
            try encodeContainer.encode(findingId, forKey: .findingId)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let findingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingId)
        findingId = findingIdDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditMitigationActionsExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes {
    /// Returned by ListAuditMitigationActionsTask, this object contains information that describes a mitigation action that has been started.
    public struct AuditMitigationActionExecutionMetadata: Swift.Equatable {
        /// The unique identifier for the mitigation action being applied by the task.
        public var actionId: Swift.String?
        /// The friendly name of the mitigation action being applied by the task.
        public var actionName: Swift.String?
        /// The date and time when the task was completed or canceled. Blank if the task is still running.
        public var endTime: ClientRuntime.Date?
        /// If an error occurred, the code that indicates which type of error occurred.
        public var errorCode: Swift.String?
        /// The unique identifier for the findings to which the task and associated mitigation action are applied.
        public var findingId: Swift.String?
        /// If an error occurred, a message that describes the error.
        public var message: Swift.String?
        /// The date and time when the task was started.
        public var startTime: ClientRuntime.Date?
        /// The current status of the task being executed.
        public var status: IoTClientTypes.AuditMitigationActionsExecutionStatus?
        /// The unique identifier for the task that applies the mitigation action.
        public var taskId: Swift.String?

        public init(
            actionId: Swift.String? = nil,
            actionName: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            errorCode: Swift.String? = nil,
            findingId: Swift.String? = nil,
            message: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: IoTClientTypes.AuditMitigationActionsExecutionStatus? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.actionId = actionId
            self.actionName = actionName
            self.endTime = endTime
            self.errorCode = errorCode
            self.findingId = findingId
            self.message = message
            self.startTime = startTime
            self.status = status
            self.taskId = taskId
        }
    }

}

extension IoTClientTypes {
    public enum AuditMitigationActionsExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case inProgress
        case pending
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditMitigationActionsExecutionStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .inProgress,
                .pending,
                .skipped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuditMitigationActionsExecutionStatus(rawValue: rawValue) ?? AuditMitigationActionsExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.AuditMitigationActionsTaskMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startTime
        case taskId
        case taskStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStatus = self.taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditMitigationActionsTaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
    }
}

extension IoTClientTypes {
    /// Information about an audit mitigation actions task that is returned by ListAuditMitigationActionsTasks.
    public struct AuditMitigationActionsTaskMetadata: Swift.Equatable {
        /// The time at which the audit mitigation actions task was started.
        public var startTime: ClientRuntime.Date?
        /// The unique identifier for the task.
        public var taskId: Swift.String?
        /// The current state of the audit mitigation actions task.
        public var taskStatus: IoTClientTypes.AuditMitigationActionsTaskStatus?

        public init(
            startTime: ClientRuntime.Date? = nil,
            taskId: Swift.String? = nil,
            taskStatus: IoTClientTypes.AuditMitigationActionsTaskStatus? = nil
        )
        {
            self.startTime = startTime
            self.taskId = taskId
            self.taskStatus = taskStatus
        }
    }

}

extension IoTClientTypes {
    public enum AuditMitigationActionsTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditMitigationActionsTaskStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuditMitigationActionsTaskStatus(rawValue: rawValue) ?? AuditMitigationActionsTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.AuditMitigationActionsTaskTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditCheckToReasonCodeFilter
        case auditTaskId
        case findingIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditCheckToReasonCodeFilter = auditCheckToReasonCodeFilter {
            var auditCheckToReasonCodeFilterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .auditCheckToReasonCodeFilter)
            for (dictKey0, auditCheckToReasonCodeFilter0) in auditCheckToReasonCodeFilter {
                var auditCheckToReasonCodeFilter0Container = auditCheckToReasonCodeFilterContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for reasonfornoncompliancecode1 in auditCheckToReasonCodeFilter0 {
                    try auditCheckToReasonCodeFilter0Container.encode(reasonfornoncompliancecode1)
                }
            }
        }
        if let auditTaskId = self.auditTaskId {
            try encodeContainer.encode(auditTaskId, forKey: .auditTaskId)
        }
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingid0 in findingIds {
                try findingIdsContainer.encode(findingid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditTaskId)
        auditTaskId = auditTaskIdDecoded
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let auditCheckToReasonCodeFilterContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .auditCheckToReasonCodeFilter)
        var auditCheckToReasonCodeFilterDecoded0: [Swift.String:[Swift.String]]? = nil
        if let auditCheckToReasonCodeFilterContainer = auditCheckToReasonCodeFilterContainer {
            auditCheckToReasonCodeFilterDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, reasonfornoncompliancecodes0) in auditCheckToReasonCodeFilterContainer {
                var reasonfornoncompliancecodes0Decoded0: [Swift.String]? = nil
                if let reasonfornoncompliancecodes0 = reasonfornoncompliancecodes0 {
                    reasonfornoncompliancecodes0Decoded0 = [Swift.String]()
                    for string1 in reasonfornoncompliancecodes0 {
                        if let string1 = string1 {
                            reasonfornoncompliancecodes0Decoded0?.append(string1)
                        }
                    }
                }
                auditCheckToReasonCodeFilterDecoded0?[key0] = reasonfornoncompliancecodes0Decoded0
            }
        }
        auditCheckToReasonCodeFilter = auditCheckToReasonCodeFilterDecoded0
    }
}

extension IoTClientTypes {
    /// Used in MitigationActionParams, this information identifies the target findings to which the mitigation actions are applied. Only one entry appears.
    public struct AuditMitigationActionsTaskTarget: Swift.Equatable {
        /// Specifies a filter in the form of an audit check and set of reason codes that identify the findings from the audit to which the audit mitigation actions task apply.
        public var auditCheckToReasonCodeFilter: [Swift.String:[Swift.String]]?
        /// If the task will apply a mitigation action to findings from a specific audit, this value uniquely identifies the audit.
        public var auditTaskId: Swift.String?
        /// If the task will apply a mitigation action to one or more listed findings, this value uniquely identifies those findings.
        public var findingIds: [Swift.String]?

        public init(
            auditCheckToReasonCodeFilter: [Swift.String:[Swift.String]]? = nil,
            auditTaskId: Swift.String? = nil,
            findingIds: [Swift.String]? = nil
        )
        {
            self.auditCheckToReasonCodeFilter = auditCheckToReasonCodeFilter
            self.auditTaskId = auditTaskId
            self.findingIds = findingIds
        }
    }

}

extension IoTClientTypes.AuditNotificationTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case roleArn
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension IoTClientTypes {
    /// Information about the targets to which audit notifications are sent.
    public struct AuditNotificationTarget: Swift.Equatable {
        /// True if notifications to the target are enabled.
        public var enabled: Swift.Bool
        /// The ARN of the role that grants permission to send notifications to the target.
        public var roleArn: Swift.String?
        /// The ARN of the target (SNS topic) to which audit notifications are sent.
        public var targetArn: Swift.String?

        public init(
            enabled: Swift.Bool = false,
            roleArn: Swift.String? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.roleArn = roleArn
            self.targetArn = targetArn
        }
    }

}

extension IoTClientTypes {
    public enum AuditNotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditNotificationType] {
            return [
                .sns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuditNotificationType(rawValue: rawValue) ?? AuditNotificationType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.AuditSuppression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName
        case description
        case expirationDate
        case resourceIdentifier
        case suppressIndefinitely
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = self.checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = self.expirationDate {
            try encodeContainer.encodeTimestamp(expirationDate, format: .epochSeconds, forKey: .expirationDate)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let suppressIndefinitely = self.suppressIndefinitely {
            try encodeContainer.encode(suppressIndefinitely, forKey: .suppressIndefinitely)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let expirationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let suppressIndefinitelyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .suppressIndefinitely)
        suppressIndefinitely = suppressIndefinitelyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension IoTClientTypes {
    /// Filters out specific findings of a Device Defender audit.
    public struct AuditSuppression: Swift.Equatable {
        /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
        /// This member is required.
        public var checkName: Swift.String?
        /// The description of the audit suppression.
        public var description: Swift.String?
        /// The expiration date (epoch timestamp in seconds) that you want the suppression to adhere to.
        public var expirationDate: ClientRuntime.Date?
        /// Information that identifies the noncompliant resource.
        /// This member is required.
        public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
        /// Indicates whether a suppression should exist indefinitely or not.
        public var suppressIndefinitely: Swift.Bool?

        public init(
            checkName: Swift.String? = nil,
            description: Swift.String? = nil,
            expirationDate: ClientRuntime.Date? = nil,
            resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
            suppressIndefinitely: Swift.Bool? = nil
        )
        {
            self.checkName = checkName
            self.description = description
            self.expirationDate = expirationDate
            self.resourceIdentifier = resourceIdentifier
            self.suppressIndefinitely = suppressIndefinitely
        }
    }

}

extension IoTClientTypes.AuditTaskMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId
        case taskStatus
        case taskType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStatus = self.taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
        if let taskType = self.taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditTaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
    }
}

extension IoTClientTypes {
    /// The audits that were performed.
    public struct AuditTaskMetadata: Swift.Equatable {
        /// The ID of this audit.
        public var taskId: Swift.String?
        /// The status of this audit. One of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
        public var taskStatus: IoTClientTypes.AuditTaskStatus?
        /// The type of this audit. One of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED_AUDIT_TASK".
        public var taskType: IoTClientTypes.AuditTaskType?

        public init(
            taskId: Swift.String? = nil,
            taskStatus: IoTClientTypes.AuditTaskStatus? = nil,
            taskType: IoTClientTypes.AuditTaskType? = nil
        )
        {
            self.taskId = taskId
            self.taskStatus = taskStatus
            self.taskType = taskType
        }
    }

}

extension IoTClientTypes {
    public enum AuditTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditTaskStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuditTaskStatus(rawValue: rawValue) ?? AuditTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum AuditTaskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case onDemandAuditTask
        case scheduledAuditTask
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditTaskType] {
            return [
                .onDemandAuditTask,
                .scheduledAuditTask,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .onDemandAuditTask: return "ON_DEMAND_AUDIT_TASK"
            case .scheduledAuditTask: return "SCHEDULED_AUDIT_TASK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuditTaskType(rawValue: rawValue) ?? AuditTaskType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum AuthDecision: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allowed
        case explicitDeny
        case implicitDeny
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthDecision] {
            return [
                .allowed,
                .explicitDeny,
                .implicitDeny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "ALLOWED"
            case .explicitDeny: return "EXPLICIT_DENY"
            case .implicitDeny: return "IMPLICIT_DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthDecision(rawValue: rawValue) ?? AuthDecision.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.AuthInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType
        case resources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension IoTClientTypes {
    /// A collection of authorization information.
    public struct AuthInfo: Swift.Equatable {
        /// The type of action for which the principal is being authorized.
        public var actionType: IoTClientTypes.ActionType?
        /// The resources for which the principal is being authorized to perform the specified action.
        /// This member is required.
        public var resources: [Swift.String]?

        public init(
            actionType: IoTClientTypes.ActionType? = nil,
            resources: [Swift.String]? = nil
        )
        {
            self.actionType = actionType
            self.resources = resources
        }
    }

}

extension IoTClientTypes.AuthResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowed
        case authDecision
        case authInfo
        case denied
        case missingContextValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowed = self.allowed {
            try encodeContainer.encode(allowed, forKey: .allowed)
        }
        if let authDecision = self.authDecision {
            try encodeContainer.encode(authDecision.rawValue, forKey: .authDecision)
        }
        if let authInfo = self.authInfo {
            try encodeContainer.encode(authInfo, forKey: .authInfo)
        }
        if let denied = self.denied {
            try encodeContainer.encode(denied, forKey: .denied)
        }
        if let missingContextValues = missingContextValues {
            var missingContextValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .missingContextValues)
            for missingcontextvalue0 in missingContextValues {
                try missingContextValuesContainer.encode(missingcontextvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authInfoDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuthInfo.self, forKey: .authInfo)
        authInfo = authInfoDecoded
        let allowedDecoded = try containerValues.decodeIfPresent(IoTClientTypes.Allowed.self, forKey: .allowed)
        allowed = allowedDecoded
        let deniedDecoded = try containerValues.decodeIfPresent(IoTClientTypes.Denied.self, forKey: .denied)
        denied = deniedDecoded
        let authDecisionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuthDecision.self, forKey: .authDecision)
        authDecision = authDecisionDecoded
        let missingContextValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .missingContextValues)
        var missingContextValuesDecoded0:[Swift.String]? = nil
        if let missingContextValuesContainer = missingContextValuesContainer {
            missingContextValuesDecoded0 = [Swift.String]()
            for string0 in missingContextValuesContainer {
                if let string0 = string0 {
                    missingContextValuesDecoded0?.append(string0)
                }
            }
        }
        missingContextValues = missingContextValuesDecoded0
    }
}

extension IoTClientTypes {
    /// The authorizer result.
    public struct AuthResult: Swift.Equatable {
        /// The policies and statements that allowed the specified action.
        public var allowed: IoTClientTypes.Allowed?
        /// The final authorization decision of this scenario. Multiple statements are taken into account when determining the authorization decision. An explicit deny statement can override multiple allow statements.
        public var authDecision: IoTClientTypes.AuthDecision?
        /// Authorization information.
        public var authInfo: IoTClientTypes.AuthInfo?
        /// The policies and statements that denied the specified action.
        public var denied: IoTClientTypes.Denied?
        /// Contains any missing context values found while evaluating policy.
        public var missingContextValues: [Swift.String]?

        public init(
            allowed: IoTClientTypes.Allowed? = nil,
            authDecision: IoTClientTypes.AuthDecision? = nil,
            authInfo: IoTClientTypes.AuthInfo? = nil,
            denied: IoTClientTypes.Denied? = nil,
            missingContextValues: [Swift.String]? = nil
        )
        {
            self.allowed = allowed
            self.authDecision = authDecision
            self.authInfo = authInfo
            self.denied = denied
            self.missingContextValues = missingContextValues
        }
    }

}

extension IoTClientTypes.AuthorizerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowAuthorizerOverride
        case defaultAuthorizerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowAuthorizerOverride = self.allowAuthorizerOverride {
            try encodeContainer.encode(allowAuthorizerOverride, forKey: .allowAuthorizerOverride)
        }
        if let defaultAuthorizerName = self.defaultAuthorizerName {
            try encodeContainer.encode(defaultAuthorizerName, forKey: .defaultAuthorizerName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultAuthorizerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultAuthorizerName)
        defaultAuthorizerName = defaultAuthorizerNameDecoded
        let allowAuthorizerOverrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowAuthorizerOverride)
        allowAuthorizerOverride = allowAuthorizerOverrideDecoded
    }
}

extension IoTClientTypes {
    /// An object that specifies the authorization service for a domain.
    public struct AuthorizerConfig: Swift.Equatable {
        /// A Boolean that specifies whether the domain configuration's authorization service can be overridden.
        public var allowAuthorizerOverride: Swift.Bool?
        /// The name of the authorization service for a domain configuration.
        public var defaultAuthorizerName: Swift.String?

        public init(
            allowAuthorizerOverride: Swift.Bool? = nil,
            defaultAuthorizerName: Swift.String? = nil
        )
        {
            self.allowAuthorizerOverride = allowAuthorizerOverride
            self.defaultAuthorizerName = defaultAuthorizerName
        }
    }

}

extension IoTClientTypes.AuthorizerDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerArn
        case authorizerFunctionArn
        case authorizerName
        case creationDate
        case enableCachingForHttp
        case lastModifiedDate
        case signingDisabled
        case status
        case tokenKeyName
        case tokenSigningPublicKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerArn = self.authorizerArn {
            try encodeContainer.encode(authorizerArn, forKey: .authorizerArn)
        }
        if let authorizerFunctionArn = self.authorizerFunctionArn {
            try encodeContainer.encode(authorizerFunctionArn, forKey: .authorizerFunctionArn)
        }
        if let authorizerName = self.authorizerName {
            try encodeContainer.encode(authorizerName, forKey: .authorizerName)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let enableCachingForHttp = self.enableCachingForHttp {
            try encodeContainer.encode(enableCachingForHttp, forKey: .enableCachingForHttp)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let signingDisabled = self.signingDisabled {
            try encodeContainer.encode(signingDisabled, forKey: .signingDisabled)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tokenKeyName = self.tokenKeyName {
            try encodeContainer.encode(tokenKeyName, forKey: .tokenKeyName)
        }
        if let tokenSigningPublicKeys = tokenSigningPublicKeys {
            var tokenSigningPublicKeysContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tokenSigningPublicKeys)
            for (dictKey0, publicKeyMap0) in tokenSigningPublicKeys {
                try tokenSigningPublicKeysContainer.encode(publicKeyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerName)
        authorizerName = authorizerNameDecoded
        let authorizerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerArn)
        authorizerArn = authorizerArnDecoded
        let authorizerFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerFunctionArn)
        authorizerFunctionArn = authorizerFunctionArnDecoded
        let tokenKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenKeyName)
        tokenKeyName = tokenKeyNameDecoded
        let tokenSigningPublicKeysContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tokenSigningPublicKeys)
        var tokenSigningPublicKeysDecoded0: [Swift.String:Swift.String]? = nil
        if let tokenSigningPublicKeysContainer = tokenSigningPublicKeysContainer {
            tokenSigningPublicKeysDecoded0 = [Swift.String:Swift.String]()
            for (key0, keyvalue0) in tokenSigningPublicKeysContainer {
                if let keyvalue0 = keyvalue0 {
                    tokenSigningPublicKeysDecoded0?[key0] = keyvalue0
                }
            }
        }
        tokenSigningPublicKeys = tokenSigningPublicKeysDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuthorizerStatus.self, forKey: .status)
        status = statusDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let signingDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .signingDisabled)
        signingDisabled = signingDisabledDecoded
        let enableCachingForHttpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableCachingForHttp)
        enableCachingForHttp = enableCachingForHttpDecoded
    }
}

extension IoTClientTypes {
    /// The authorizer description.
    public struct AuthorizerDescription: Swift.Equatable {
        /// The authorizer ARN.
        public var authorizerArn: Swift.String?
        /// The authorizer's Lambda function ARN.
        public var authorizerFunctionArn: Swift.String?
        /// The authorizer name.
        public var authorizerName: Swift.String?
        /// The UNIX timestamp of when the authorizer was created.
        public var creationDate: ClientRuntime.Date?
        /// When true, the result from the authorizers Lambda function is cached for the time specified in refreshAfterInSeconds. The cached result is used while the device reuses the same HTTP connection.
        public var enableCachingForHttp: Swift.Bool?
        /// The UNIX timestamp of when the authorizer was last updated.
        public var lastModifiedDate: ClientRuntime.Date?
        /// Specifies whether IoT validates the token signature in an authorization request.
        public var signingDisabled: Swift.Bool?
        /// The status of the authorizer.
        public var status: IoTClientTypes.AuthorizerStatus?
        /// The key used to extract the token from the HTTP headers.
        public var tokenKeyName: Swift.String?
        /// The public keys used to validate the token signature returned by your custom authentication service.
        public var tokenSigningPublicKeys: [Swift.String:Swift.String]?

        public init(
            authorizerArn: Swift.String? = nil,
            authorizerFunctionArn: Swift.String? = nil,
            authorizerName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            enableCachingForHttp: Swift.Bool? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            signingDisabled: Swift.Bool? = nil,
            status: IoTClientTypes.AuthorizerStatus? = nil,
            tokenKeyName: Swift.String? = nil,
            tokenSigningPublicKeys: [Swift.String:Swift.String]? = nil
        )
        {
            self.authorizerArn = authorizerArn
            self.authorizerFunctionArn = authorizerFunctionArn
            self.authorizerName = authorizerName
            self.creationDate = creationDate
            self.enableCachingForHttp = enableCachingForHttp
            self.lastModifiedDate = lastModifiedDate
            self.signingDisabled = signingDisabled
            self.status = status
            self.tokenKeyName = tokenKeyName
            self.tokenSigningPublicKeys = tokenSigningPublicKeys
        }
    }

}

extension IoTClientTypes {
    public enum AuthorizerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizerStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizerStatus(rawValue: rawValue) ?? AuthorizerStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.AuthorizerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerArn
        case authorizerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerArn = self.authorizerArn {
            try encodeContainer.encode(authorizerArn, forKey: .authorizerArn)
        }
        if let authorizerName = self.authorizerName {
            try encodeContainer.encode(authorizerName, forKey: .authorizerName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerName)
        authorizerName = authorizerNameDecoded
        let authorizerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerArn)
        authorizerArn = authorizerArnDecoded
    }
}

extension IoTClientTypes {
    /// The authorizer summary.
    public struct AuthorizerSummary: Swift.Equatable {
        /// The authorizer ARN.
        public var authorizerArn: Swift.String?
        /// The authorizer name.
        public var authorizerName: Swift.String?

        public init(
            authorizerArn: Swift.String? = nil,
            authorizerName: Swift.String? = nil
        )
        {
            self.authorizerArn = authorizerArn
            self.authorizerName = authorizerName
        }
    }

}

extension IoTClientTypes {
    public enum AutoRegistrationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disable
        case enable
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoRegistrationStatus] {
            return [
                .disable,
                .enable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoRegistrationStatus(rawValue: rawValue) ?? AutoRegistrationStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.AwsJobAbortConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortCriteriaList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortCriteriaList = abortCriteriaList {
            var abortCriteriaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .abortCriteriaList)
            for awsjobabortcriteria0 in abortCriteriaList {
                try abortCriteriaListContainer.encode(awsjobabortcriteria0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let abortCriteriaListContainer = try containerValues.decodeIfPresent([IoTClientTypes.AwsJobAbortCriteria?].self, forKey: .abortCriteriaList)
        var abortCriteriaListDecoded0:[IoTClientTypes.AwsJobAbortCriteria]? = nil
        if let abortCriteriaListContainer = abortCriteriaListContainer {
            abortCriteriaListDecoded0 = [IoTClientTypes.AwsJobAbortCriteria]()
            for structure0 in abortCriteriaListContainer {
                if let structure0 = structure0 {
                    abortCriteriaListDecoded0?.append(structure0)
                }
            }
        }
        abortCriteriaList = abortCriteriaListDecoded0
    }
}

extension IoTClientTypes {
    /// The criteria that determine when and how a job abort takes place.
    public struct AwsJobAbortConfig: Swift.Equatable {
        /// The list of criteria that determine when and how to abort the job.
        /// This member is required.
        public var abortCriteriaList: [IoTClientTypes.AwsJobAbortCriteria]?

        public init(
            abortCriteriaList: [IoTClientTypes.AwsJobAbortCriteria]? = nil
        )
        {
            self.abortCriteriaList = abortCriteriaList
        }
    }

}

extension IoTClientTypes.AwsJobAbortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case failureType
        case minNumberOfExecutedThings
        case thresholdPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let failureType = self.failureType {
            try encodeContainer.encode(failureType.rawValue, forKey: .failureType)
        }
        if let minNumberOfExecutedThings = self.minNumberOfExecutedThings {
            try encodeContainer.encode(minNumberOfExecutedThings, forKey: .minNumberOfExecutedThings)
        }
        if let thresholdPercentage = self.thresholdPercentage {
            try encodeContainer.encode(thresholdPercentage, forKey: .thresholdPercentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AwsJobAbortCriteriaFailureType.self, forKey: .failureType)
        failureType = failureTypeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AwsJobAbortCriteriaAbortAction.self, forKey: .action)
        action = actionDecoded
        let thresholdPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .thresholdPercentage)
        thresholdPercentage = thresholdPercentageDecoded
        let minNumberOfExecutedThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minNumberOfExecutedThings)
        minNumberOfExecutedThings = minNumberOfExecutedThingsDecoded
    }
}

extension IoTClientTypes {
    /// The criteria that determine when and how a job abort takes place.
    public struct AwsJobAbortCriteria: Swift.Equatable {
        /// The type of job action to take to initiate the job abort.
        /// This member is required.
        public var action: IoTClientTypes.AwsJobAbortCriteriaAbortAction?
        /// The type of job execution failures that can initiate a job abort.
        /// This member is required.
        public var failureType: IoTClientTypes.AwsJobAbortCriteriaFailureType?
        /// The minimum number of things which must receive job execution notifications before the job can be aborted.
        /// This member is required.
        public var minNumberOfExecutedThings: Swift.Int?
        /// The minimum percentage of job execution failures that must occur to initiate the job abort. Amazon Web Services IoT Core supports up to two digits after the decimal (for example, 10.9 and 10.99, but not 10.999).
        /// This member is required.
        public var thresholdPercentage: Swift.Double?

        public init(
            action: IoTClientTypes.AwsJobAbortCriteriaAbortAction? = nil,
            failureType: IoTClientTypes.AwsJobAbortCriteriaFailureType? = nil,
            minNumberOfExecutedThings: Swift.Int? = nil,
            thresholdPercentage: Swift.Double? = nil
        )
        {
            self.action = action
            self.failureType = failureType
            self.minNumberOfExecutedThings = minNumberOfExecutedThings
            self.thresholdPercentage = thresholdPercentage
        }
    }

}

extension IoTClientTypes {
    public enum AwsJobAbortCriteriaAbortAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancel
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsJobAbortCriteriaAbortAction] {
            return [
                .cancel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AwsJobAbortCriteriaAbortAction(rawValue: rawValue) ?? AwsJobAbortCriteriaAbortAction.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum AwsJobAbortCriteriaFailureType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case failed
        case rejected
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsJobAbortCriteriaFailureType] {
            return [
                .all,
                .failed,
                .rejected,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .rejected: return "REJECTED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AwsJobAbortCriteriaFailureType(rawValue: rawValue) ?? AwsJobAbortCriteriaFailureType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.AwsJobExecutionsRolloutConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exponentialRate
        case maximumPerMinute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exponentialRate = self.exponentialRate {
            try encodeContainer.encode(exponentialRate, forKey: .exponentialRate)
        }
        if let maximumPerMinute = self.maximumPerMinute {
            try encodeContainer.encode(maximumPerMinute, forKey: .maximumPerMinute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumPerMinuteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumPerMinute)
        maximumPerMinute = maximumPerMinuteDecoded
        let exponentialRateDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AwsJobExponentialRolloutRate.self, forKey: .exponentialRate)
        exponentialRate = exponentialRateDecoded
    }
}

extension IoTClientTypes {
    /// Configuration for the rollout of OTA updates.
    public struct AwsJobExecutionsRolloutConfig: Swift.Equatable {
        /// The rate of increase for a job rollout. This parameter allows you to define an exponential rate increase for a job rollout.
        public var exponentialRate: IoTClientTypes.AwsJobExponentialRolloutRate?
        /// The maximum number of OTA update job executions started per minute.
        public var maximumPerMinute: Swift.Int?

        public init(
            exponentialRate: IoTClientTypes.AwsJobExponentialRolloutRate? = nil,
            maximumPerMinute: Swift.Int? = nil
        )
        {
            self.exponentialRate = exponentialRate
            self.maximumPerMinute = maximumPerMinute
        }
    }

}

extension IoTClientTypes.AwsJobExponentialRolloutRate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseRatePerMinute
        case incrementFactor
        case rateIncreaseCriteria
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseRatePerMinute = self.baseRatePerMinute {
            try encodeContainer.encode(baseRatePerMinute, forKey: .baseRatePerMinute)
        }
        if incrementFactor != 0.0 {
            try encodeContainer.encode(incrementFactor, forKey: .incrementFactor)
        }
        if let rateIncreaseCriteria = self.rateIncreaseCriteria {
            try encodeContainer.encode(rateIncreaseCriteria, forKey: .rateIncreaseCriteria)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseRatePerMinuteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseRatePerMinute)
        baseRatePerMinute = baseRatePerMinuteDecoded
        let incrementFactorDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .incrementFactor) ?? 0.0
        incrementFactor = incrementFactorDecoded
        let rateIncreaseCriteriaDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AwsJobRateIncreaseCriteria.self, forKey: .rateIncreaseCriteria)
        rateIncreaseCriteria = rateIncreaseCriteriaDecoded
    }
}

extension IoTClientTypes {
    /// The rate of increase for a job rollout. This parameter allows you to define an exponential rate increase for a job rollout.
    public struct AwsJobExponentialRolloutRate: Swift.Equatable {
        /// The minimum number of things that will be notified of a pending job, per minute, at the start of the job rollout. This is the initial rate of the rollout.
        /// This member is required.
        public var baseRatePerMinute: Swift.Int?
        /// The rate of increase for a job rollout. The number of things notified is multiplied by this factor.
        /// This member is required.
        public var incrementFactor: Swift.Double
        /// The criteria to initiate the increase in rate of rollout for a job. Amazon Web Services IoT Core supports up to one digit after the decimal (for example, 1.5, but not 1.55).
        /// This member is required.
        public var rateIncreaseCriteria: IoTClientTypes.AwsJobRateIncreaseCriteria?

        public init(
            baseRatePerMinute: Swift.Int? = nil,
            incrementFactor: Swift.Double = 0.0,
            rateIncreaseCriteria: IoTClientTypes.AwsJobRateIncreaseCriteria? = nil
        )
        {
            self.baseRatePerMinute = baseRatePerMinute
            self.incrementFactor = incrementFactor
            self.rateIncreaseCriteria = rateIncreaseCriteria
        }
    }

}

extension IoTClientTypes.AwsJobPresignedUrlConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresInSec
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiresInSec = self.expiresInSec {
            try encodeContainer.encode(expiresInSec, forKey: .expiresInSec)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expiresInSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresInSec)
        expiresInSec = expiresInSecDecoded
    }
}

extension IoTClientTypes {
    /// Configuration information for pre-signed URLs. Valid when protocols contains HTTP.
    public struct AwsJobPresignedUrlConfig: Swift.Equatable {
        /// How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 1800 seconds. Pre-signed URLs are generated when a request for the job document is received.
        public var expiresInSec: Swift.Int?

        public init(
            expiresInSec: Swift.Int? = nil
        )
        {
            self.expiresInSec = expiresInSec
        }
    }

}

extension IoTClientTypes.AwsJobRateIncreaseCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfNotifiedThings
        case numberOfSucceededThings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfNotifiedThings = self.numberOfNotifiedThings {
            try encodeContainer.encode(numberOfNotifiedThings, forKey: .numberOfNotifiedThings)
        }
        if let numberOfSucceededThings = self.numberOfSucceededThings {
            try encodeContainer.encode(numberOfSucceededThings, forKey: .numberOfSucceededThings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfNotifiedThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfNotifiedThings)
        numberOfNotifiedThings = numberOfNotifiedThingsDecoded
        let numberOfSucceededThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfSucceededThings)
        numberOfSucceededThings = numberOfSucceededThingsDecoded
    }
}

extension IoTClientTypes {
    /// The criteria to initiate the increase in rate of rollout for a job.
    public struct AwsJobRateIncreaseCriteria: Swift.Equatable {
        /// When this number of things have been notified, it will initiate an increase in the rollout rate.
        public var numberOfNotifiedThings: Swift.Int?
        /// When this number of things have succeeded in their job execution, it will initiate an increase in the rollout rate.
        public var numberOfSucceededThings: Swift.Int?

        public init(
            numberOfNotifiedThings: Swift.Int? = nil,
            numberOfSucceededThings: Swift.Int? = nil
        )
        {
            self.numberOfNotifiedThings = numberOfNotifiedThings
            self.numberOfSucceededThings = numberOfSucceededThings
        }
    }

}

extension IoTClientTypes.AwsJobTimeoutConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inProgressTimeoutInMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inProgressTimeoutInMinutes = self.inProgressTimeoutInMinutes {
            try encodeContainer.encode(inProgressTimeoutInMinutes, forKey: .inProgressTimeoutInMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inProgressTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inProgressTimeoutInMinutes)
        inProgressTimeoutInMinutes = inProgressTimeoutInMinutesDecoded
    }
}

extension IoTClientTypes {
    /// Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to TIMED_OUT.
    public struct AwsJobTimeoutConfig: Swift.Equatable {
        /// Specifies the amount of time, in minutes, this device has to finish execution of this job. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress timer can't be updated and will apply to all job executions for the job. Whenever a job execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and switch to the terminal TIMED_OUT status.
        public var inProgressTimeoutInMinutes: Swift.Int?

        public init(
            inProgressTimeoutInMinutes: Swift.Int? = nil
        )
        {
            self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
        }
    }

}

extension IoTClientTypes.Behavior: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criteria
        case metric
        case metricDimension
        case name
        case suppressAlerts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criteria = self.criteria {
            try encodeContainer.encode(criteria, forKey: .criteria)
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let metricDimension = self.metricDimension {
            try encodeContainer.encode(metricDimension, forKey: .metricDimension)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let suppressAlerts = self.suppressAlerts {
            try encodeContainer.encode(suppressAlerts, forKey: .suppressAlerts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let metricDimensionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MetricDimension.self, forKey: .metricDimension)
        metricDimension = metricDimensionDecoded
        let criteriaDecoded = try containerValues.decodeIfPresent(IoTClientTypes.BehaviorCriteria.self, forKey: .criteria)
        criteria = criteriaDecoded
        let suppressAlertsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .suppressAlerts)
        suppressAlerts = suppressAlertsDecoded
    }
}

extension IoTClientTypes {
    /// A Device Defender security profile behavior.
    public struct Behavior: Swift.Equatable {
        /// The criteria that determine if a device is behaving normally in regard to the metric. In the IoT console, you can choose to be sent an alert through Amazon SNS when IoT Device Defender detects that a device is behaving anomalously.
        public var criteria: IoTClientTypes.BehaviorCriteria?
        /// What is measured by the behavior.
        public var metric: Swift.String?
        /// The dimension for a metric in your behavior. For example, using a TOPIC_FILTER dimension, you can narrow down the scope of the metric to only MQTT topics where the name matches the pattern specified in the dimension. This can't be used with custom metrics.
        public var metricDimension: IoTClientTypes.MetricDimension?
        /// The name you've given to the behavior.
        /// This member is required.
        public var name: Swift.String?
        /// Suppresses alerts.
        public var suppressAlerts: Swift.Bool?

        public init(
            criteria: IoTClientTypes.BehaviorCriteria? = nil,
            metric: Swift.String? = nil,
            metricDimension: IoTClientTypes.MetricDimension? = nil,
            name: Swift.String? = nil,
            suppressAlerts: Swift.Bool? = nil
        )
        {
            self.criteria = criteria
            self.metric = metric
            self.metricDimension = metricDimension
            self.name = name
            self.suppressAlerts = suppressAlerts
        }
    }

}

extension IoTClientTypes.BehaviorCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator
        case consecutiveDatapointsToAlarm
        case consecutiveDatapointsToClear
        case durationSeconds
        case mlDetectionConfig
        case statisticalThreshold
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let consecutiveDatapointsToAlarm = self.consecutiveDatapointsToAlarm {
            try encodeContainer.encode(consecutiveDatapointsToAlarm, forKey: .consecutiveDatapointsToAlarm)
        }
        if let consecutiveDatapointsToClear = self.consecutiveDatapointsToClear {
            try encodeContainer.encode(consecutiveDatapointsToClear, forKey: .consecutiveDatapointsToClear)
        }
        if let durationSeconds = self.durationSeconds {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let mlDetectionConfig = self.mlDetectionConfig {
            try encodeContainer.encode(mlDetectionConfig, forKey: .mlDetectionConfig)
        }
        if let statisticalThreshold = self.statisticalThreshold {
            try encodeContainer.encode(statisticalThreshold, forKey: .statisticalThreshold)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MetricValue.self, forKey: .value)
        value = valueDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
        let consecutiveDatapointsToAlarmDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consecutiveDatapointsToAlarm)
        consecutiveDatapointsToAlarm = consecutiveDatapointsToAlarmDecoded
        let consecutiveDatapointsToClearDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .consecutiveDatapointsToClear)
        consecutiveDatapointsToClear = consecutiveDatapointsToClearDecoded
        let statisticalThresholdDecoded = try containerValues.decodeIfPresent(IoTClientTypes.StatisticalThreshold.self, forKey: .statisticalThreshold)
        statisticalThreshold = statisticalThresholdDecoded
        let mlDetectionConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MachineLearningDetectionConfig.self, forKey: .mlDetectionConfig)
        mlDetectionConfig = mlDetectionConfigDecoded
    }
}

extension IoTClientTypes {
    /// The criteria by which the behavior is determined to be normal.
    public struct BehaviorCriteria: Swift.Equatable {
        /// The operator that relates the thing measured (metric) to the criteria (containing a value or statisticalThreshold). Valid operators include:
        ///
        /// * string-list: in-set and not-in-set
        ///
        /// * number-list: in-set and not-in-set
        ///
        /// * ip-address-list: in-cidr-set and not-in-cidr-set
        ///
        /// * number: less-than, less-than-equals, greater-than, and greater-than-equals
        public var comparisonOperator: IoTClientTypes.ComparisonOperator?
        /// If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
        public var consecutiveDatapointsToAlarm: Swift.Int?
        /// If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
        public var consecutiveDatapointsToClear: Swift.Int?
        /// Use this to specify the time duration over which the behavior is evaluated, for those criteria that have a time dimension (for example, NUM_MESSAGES_SENT). For a statisticalThreshhold metric comparison, measurements from all devices are accumulated over this time duration before being used to calculate percentiles, and later, measurements from an individual device are also accumulated over this time duration before being given a percentile rank. Cannot be used with list-based metric datatypes.
        public var durationSeconds: Swift.Int?
        /// The configuration of an ML Detect
        public var mlDetectionConfig: IoTClientTypes.MachineLearningDetectionConfig?
        /// A statistical ranking (percentile)that indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
        public var statisticalThreshold: IoTClientTypes.StatisticalThreshold?
        /// The value to be compared with the metric.
        public var value: IoTClientTypes.MetricValue?

        public init(
            comparisonOperator: IoTClientTypes.ComparisonOperator? = nil,
            consecutiveDatapointsToAlarm: Swift.Int? = nil,
            consecutiveDatapointsToClear: Swift.Int? = nil,
            durationSeconds: Swift.Int? = nil,
            mlDetectionConfig: IoTClientTypes.MachineLearningDetectionConfig? = nil,
            statisticalThreshold: IoTClientTypes.StatisticalThreshold? = nil,
            value: IoTClientTypes.MetricValue? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.consecutiveDatapointsToAlarm = consecutiveDatapointsToAlarm
            self.consecutiveDatapointsToClear = consecutiveDatapointsToClear
            self.durationSeconds = durationSeconds
            self.mlDetectionConfig = mlDetectionConfig
            self.statisticalThreshold = statisticalThreshold
            self.value = value
        }
    }

}

extension IoTClientTypes {
    public enum BehaviorCriteriaType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case machineLearning
        case `static`
        case statistical
        case sdkUnknown(Swift.String)

        public static var allCases: [BehaviorCriteriaType] {
            return [
                .machineLearning,
                .static,
                .statistical,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .machineLearning: return "MACHINE_LEARNING"
            case .static: return "STATIC"
            case .statistical: return "STATISTICAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BehaviorCriteriaType(rawValue: rawValue) ?? BehaviorCriteriaType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.BehaviorModelTrainingSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case behaviorName
        case datapointsCollectionPercentage
        case lastModelRefreshDate
        case modelStatus
        case securityProfileName
        case trainingDataCollectionStartDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behaviorName = self.behaviorName {
            try encodeContainer.encode(behaviorName, forKey: .behaviorName)
        }
        if let datapointsCollectionPercentage = self.datapointsCollectionPercentage {
            try encodeContainer.encode(datapointsCollectionPercentage, forKey: .datapointsCollectionPercentage)
        }
        if let lastModelRefreshDate = self.lastModelRefreshDate {
            try encodeContainer.encodeTimestamp(lastModelRefreshDate, format: .epochSeconds, forKey: .lastModelRefreshDate)
        }
        if let modelStatus = self.modelStatus {
            try encodeContainer.encode(modelStatus.rawValue, forKey: .modelStatus)
        }
        if let securityProfileName = self.securityProfileName {
            try encodeContainer.encode(securityProfileName, forKey: .securityProfileName)
        }
        if let trainingDataCollectionStartDate = self.trainingDataCollectionStartDate {
            try encodeContainer.encodeTimestamp(trainingDataCollectionStartDate, format: .epochSeconds, forKey: .trainingDataCollectionStartDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let behaviorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .behaviorName)
        behaviorName = behaviorNameDecoded
        let trainingDataCollectionStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .trainingDataCollectionStartDate)
        trainingDataCollectionStartDate = trainingDataCollectionStartDateDecoded
        let modelStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ModelStatus.self, forKey: .modelStatus)
        modelStatus = modelStatusDecoded
        let datapointsCollectionPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .datapointsCollectionPercentage)
        datapointsCollectionPercentage = datapointsCollectionPercentageDecoded
        let lastModelRefreshDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModelRefreshDate)
        lastModelRefreshDate = lastModelRefreshDateDecoded
    }
}

extension IoTClientTypes {
    /// The summary of an ML Detect behavior model.
    public struct BehaviorModelTrainingSummary: Swift.Equatable {
        /// The name of the behavior.
        public var behaviorName: Swift.String?
        /// The percentage of datapoints collected.
        public var datapointsCollectionPercentage: Swift.Double?
        /// The date the model was last refreshed.
        public var lastModelRefreshDate: ClientRuntime.Date?
        /// The status of the behavior model.
        public var modelStatus: IoTClientTypes.ModelStatus?
        /// The name of the security profile.
        public var securityProfileName: Swift.String?
        /// The date a training model started collecting data.
        public var trainingDataCollectionStartDate: ClientRuntime.Date?

        public init(
            behaviorName: Swift.String? = nil,
            datapointsCollectionPercentage: Swift.Double? = nil,
            lastModelRefreshDate: ClientRuntime.Date? = nil,
            modelStatus: IoTClientTypes.ModelStatus? = nil,
            securityProfileName: Swift.String? = nil,
            trainingDataCollectionStartDate: ClientRuntime.Date? = nil
        )
        {
            self.behaviorName = behaviorName
            self.datapointsCollectionPercentage = datapointsCollectionPercentage
            self.lastModelRefreshDate = lastModelRefreshDate
            self.modelStatus = modelStatus
            self.securityProfileName = securityProfileName
            self.trainingDataCollectionStartDate = trainingDataCollectionStartDate
        }
    }

}

extension IoTClientTypes.BillingGroupMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension IoTClientTypes {
    /// Additional information about the billing group.
    public struct BillingGroupMetadata: Swift.Equatable {
        /// The date the billing group was created.
        public var creationDate: ClientRuntime.Date?

        public init(
            creationDate: ClientRuntime.Date? = nil
        )
        {
            self.creationDate = creationDate
        }
    }

}

extension IoTClientTypes.BillingGroupProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupDescription
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupDescription = self.billingGroupDescription {
            try encodeContainer.encode(billingGroupDescription, forKey: .billingGroupDescription)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupDescription)
        billingGroupDescription = billingGroupDescriptionDecoded
    }
}

extension IoTClientTypes {
    /// The properties of a billing group.
    public struct BillingGroupProperties: Swift.Equatable {
        /// The description of the billing group.
        public var billingGroupDescription: Swift.String?

        public init(
            billingGroupDescription: Swift.String? = nil
        )
        {
            self.billingGroupDescription = billingGroupDescription
        }
    }

}

extension IoTClientTypes.Bucket: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case keyValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let keyValue = self.keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
    }
}

extension IoTClientTypes {
    /// A count of documents that meets a specific aggregation criteria.
    public struct Bucket: Swift.Equatable {
        /// The number of documents that have the value counted for the particular bucket.
        public var count: Swift.Int
        /// The value counted for the particular bucket.
        public var keyValue: Swift.String?

        public init(
            count: Swift.Int = 0,
            keyValue: Swift.String? = nil
        )
        {
            self.count = count
            self.keyValue = keyValue
        }
    }

}

extension IoTClientTypes.BucketsAggregationType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termsAggregation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let termsAggregation = self.termsAggregation {
            try encodeContainer.encode(termsAggregation, forKey: .termsAggregation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let termsAggregationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TermsAggregation.self, forKey: .termsAggregation)
        termsAggregation = termsAggregationDecoded
    }
}

extension IoTClientTypes {
    /// The type of bucketed aggregation performed.
    public struct BucketsAggregationType: Swift.Equatable {
        /// Performs an aggregation that will return a list of buckets. The list of buckets is a ranked list of the number of occurrences of an aggregation field value.
        public var termsAggregation: IoTClientTypes.TermsAggregation?

        public init(
            termsAggregation: IoTClientTypes.TermsAggregation? = nil
        )
        {
            self.termsAggregation = termsAggregation
        }
    }

}

extension IoTClientTypes.CACertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateId
        case creationDate
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CACertificateStatus.self, forKey: .status)
        status = statusDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension IoTClientTypes {
    /// A CA certificate.
    public struct CACertificate: Swift.Equatable {
        /// The ARN of the CA certificate.
        public var certificateArn: Swift.String?
        /// The ID of the CA certificate.
        public var certificateId: Swift.String?
        /// The date the CA certificate was created.
        public var creationDate: ClientRuntime.Date?
        /// The status of the CA certificate. The status value REGISTER_INACTIVE is deprecated and should not be used.
        public var status: IoTClientTypes.CACertificateStatus?

        public init(
            certificateArn: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            status: IoTClientTypes.CACertificateStatus? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateId = certificateId
            self.creationDate = creationDate
            self.status = status
        }
    }

}

extension IoTClientTypes.CACertificateDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoRegistrationStatus
        case certificateArn
        case certificateId
        case certificateMode
        case certificatePem
        case creationDate
        case customerVersion
        case generationId
        case lastModifiedDate
        case ownedBy
        case status
        case validity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoRegistrationStatus = self.autoRegistrationStatus {
            try encodeContainer.encode(autoRegistrationStatus.rawValue, forKey: .autoRegistrationStatus)
        }
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let certificateMode = self.certificateMode {
            try encodeContainer.encode(certificateMode.rawValue, forKey: .certificateMode)
        }
        if let certificatePem = self.certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let customerVersion = self.customerVersion {
            try encodeContainer.encode(customerVersion, forKey: .customerVersion)
        }
        if let generationId = self.generationId {
            try encodeContainer.encode(generationId, forKey: .generationId)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let ownedBy = self.ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let validity = self.validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CACertificateStatus.self, forKey: .status)
        status = statusDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let autoRegistrationStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AutoRegistrationStatus.self, forKey: .autoRegistrationStatus)
        autoRegistrationStatus = autoRegistrationStatusDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let customerVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .customerVersion)
        customerVersion = customerVersionDecoded
        let generationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationId)
        generationId = generationIdDecoded
        let validityDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CertificateValidity.self, forKey: .validity)
        validity = validityDecoded
        let certificateModeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CertificateMode.self, forKey: .certificateMode)
        certificateMode = certificateModeDecoded
    }
}

extension IoTClientTypes {
    /// Describes a CA certificate.
    public struct CACertificateDescription: Swift.Equatable {
        /// Whether the CA certificate configured for auto registration of device certificates. Valid values are "ENABLE" and "DISABLE"
        public var autoRegistrationStatus: IoTClientTypes.AutoRegistrationStatus?
        /// The CA certificate ARN.
        public var certificateArn: Swift.String?
        /// The CA certificate ID.
        public var certificateId: Swift.String?
        /// The mode of the CA. All the device certificates that are registered using this CA will be registered in the same mode as the CA. For more information about certificate mode for device certificates, see [certificate mode](https://docs.aws.amazon.com/iot/latest/apireference/API_CertificateDescription.html#iot-Type-CertificateDescription-certificateMode).
        public var certificateMode: IoTClientTypes.CertificateMode?
        /// The CA certificate data, in PEM format.
        public var certificatePem: Swift.String?
        /// The date the CA certificate was created.
        public var creationDate: ClientRuntime.Date?
        /// The customer version of the CA certificate.
        public var customerVersion: Swift.Int?
        /// The generation ID of the CA certificate.
        public var generationId: Swift.String?
        /// The date the CA certificate was last modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The owner of the CA certificate.
        public var ownedBy: Swift.String?
        /// The status of a CA certificate.
        public var status: IoTClientTypes.CACertificateStatus?
        /// When the CA certificate is valid.
        public var validity: IoTClientTypes.CertificateValidity?

        public init(
            autoRegistrationStatus: IoTClientTypes.AutoRegistrationStatus? = nil,
            certificateArn: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            certificateMode: IoTClientTypes.CertificateMode? = nil,
            certificatePem: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            customerVersion: Swift.Int? = nil,
            generationId: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            ownedBy: Swift.String? = nil,
            status: IoTClientTypes.CACertificateStatus? = nil,
            validity: IoTClientTypes.CertificateValidity? = nil
        )
        {
            self.autoRegistrationStatus = autoRegistrationStatus
            self.certificateArn = certificateArn
            self.certificateId = certificateId
            self.certificateMode = certificateMode
            self.certificatePem = certificatePem
            self.creationDate = creationDate
            self.customerVersion = customerVersion
            self.generationId = generationId
            self.lastModifiedDate = lastModifiedDate
            self.ownedBy = ownedBy
            self.status = status
            self.validity = validity
        }
    }

}

extension IoTClientTypes {
    public enum CACertificateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [CACertificateStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CACertificateStatus(rawValue: rawValue) ?? CACertificateStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum CACertificateUpdateAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deactivate
        case sdkUnknown(Swift.String)

        public static var allCases: [CACertificateUpdateAction] {
            return [
                .deactivate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deactivate: return "DEACTIVATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CACertificateUpdateAction(rawValue: rawValue) ?? CACertificateUpdateAction.sdkUnknown(rawValue)
        }
    }
}

extension CancelAuditMitigationActionsTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/audit/mitigationactions/tasks/\(taskId.urlPercentEncoding())/cancel"
    }
}

public struct CancelAuditMitigationActionsTaskInput: Swift.Equatable {
    /// The unique identifier for the task that you want to cancel.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct CancelAuditMitigationActionsTaskInputBody: Swift.Equatable {
}

extension CancelAuditMitigationActionsTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelAuditMitigationActionsTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelAuditMitigationActionsTaskOutput: Swift.Equatable {

    public init() { }
}

enum CancelAuditMitigationActionsTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelAuditTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/audit/tasks/\(taskId.urlPercentEncoding())/cancel"
    }
}

public struct CancelAuditTaskInput: Swift.Equatable {
    /// The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct CancelAuditTaskInputBody: Swift.Equatable {
}

extension CancelAuditTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelAuditTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelAuditTaskOutput: Swift.Equatable {

    public init() { }
}

enum CancelAuditTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelCertificateTransferInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let certificateId = certificateId else {
            return nil
        }
        return "/cancel-certificate-transfer/\(certificateId.urlPercentEncoding())"
    }
}

/// The input for the CancelCertificateTransfer operation.
public struct CancelCertificateTransferInput: Swift.Equatable {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct CancelCertificateTransferInputBody: Swift.Equatable {
}

extension CancelCertificateTransferInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelCertificateTransferOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelCertificateTransferOutput: Swift.Equatable {

    public init() { }
}

enum CancelCertificateTransferOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransferAlreadyCompletedException": return try await TransferAlreadyCompletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelDetectMitigationActionsTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/detect/mitigationactions/tasks/\(taskId.urlPercentEncoding())/cancel"
    }
}

public struct CancelDetectMitigationActionsTaskInput: Swift.Equatable {
    /// The unique identifier of the task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct CancelDetectMitigationActionsTaskInputBody: Swift.Equatable {
}

extension CancelDetectMitigationActionsTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelDetectMitigationActionsTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelDetectMitigationActionsTaskOutput: Swift.Equatable {

    public init() { }
}

enum CancelDetectMitigationActionsTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelJobExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedVersion
        case statusDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedVersion = self.expectedVersion {
            try encodeContainer.encode(expectedVersion, forKey: .expectedVersion)
        }
        if let statusDetails = statusDetails {
            var statusDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .statusDetails)
            for (dictKey0, detailsMap0) in statusDetails {
                try statusDetailsContainer.encode(detailsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CancelJobExecutionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let force = force {
                let forceQueryItem = ClientRuntime.URLQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
                items.append(forceQueryItem)
            }
            return items
        }
    }
}

extension CancelJobExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/cancel"
    }
}

public struct CancelJobExecutionInput: Swift.Equatable {
    /// (Optional) The expected current version of the job execution. Each time you update the job execution, its version is incremented. If the version of the job execution stored in Jobs does not match, the update is rejected with a VersionMismatch error, and an ErrorResponse that contains the current job execution status data is returned. (This makes it unnecessary to perform a separate DescribeJobExecution request in order to obtain the job execution status data.)
    public var expectedVersion: Swift.Int?
    /// (Optional) If true the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set force to true, then an InvalidStateTransitionException will be thrown. The default is false. Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.
    public var force: Swift.Bool?
    /// The ID of the job to be canceled.
    /// This member is required.
    public var jobId: Swift.String?
    /// A collection of name/value pairs that describe the status of the job execution. If not specified, the statusDetails are unchanged. You can specify at most 10 name/value pairs.
    public var statusDetails: [Swift.String:Swift.String]?
    /// The name of the thing whose execution of the job will be canceled.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        expectedVersion: Swift.Int? = nil,
        force: Swift.Bool? = nil,
        jobId: Swift.String? = nil,
        statusDetails: [Swift.String:Swift.String]? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.force = force
        self.jobId = jobId
        self.statusDetails = statusDetails
        self.thingName = thingName
    }
}

struct CancelJobExecutionInputBody: Swift.Equatable {
    let expectedVersion: Swift.Int?
    let statusDetails: [Swift.String:Swift.String]?
}

extension CancelJobExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedVersion
        case statusDetails
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expectedVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedVersion)
        expectedVersion = expectedVersionDecoded
        let statusDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .statusDetails)
        var statusDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let statusDetailsContainer = statusDetailsContainer {
            statusDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, detailsvalue0) in statusDetailsContainer {
                if let detailsvalue0 = detailsvalue0 {
                    statusDetailsDecoded0?[key0] = detailsvalue0
                }
            }
        }
        statusDetails = statusDetailsDecoded0
    }
}

extension CancelJobExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelJobExecutionOutput: Swift.Equatable {

    public init() { }
}

enum CancelJobExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateTransitionException": return try await InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case reasonCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let reasonCode = self.reasonCode {
            try encodeContainer.encode(reasonCode, forKey: .reasonCode)
        }
    }
}

extension CancelJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let force = force {
                let forceQueryItem = ClientRuntime.URLQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
                items.append(forceQueryItem)
            }
            return items
        }
    }
}

extension CancelJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())/cancel"
    }
}

public struct CancelJobInput: Swift.Equatable {
    /// An optional comment string describing why the job was canceled.
    public var comment: Swift.String?
    /// (Optional) If true job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is false. Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.
    public var force: Swift.Bool?
    /// The unique identifier you assigned to this job when it was created.
    /// This member is required.
    public var jobId: Swift.String?
    /// (Optional)A reason code string that explains why the job was canceled.
    public var reasonCode: Swift.String?

    public init(
        comment: Swift.String? = nil,
        force: Swift.Bool? = nil,
        jobId: Swift.String? = nil,
        reasonCode: Swift.String? = nil
    )
    {
        self.comment = comment
        self.force = force
        self.jobId = jobId
        self.reasonCode = reasonCode
    }
}

struct CancelJobInputBody: Swift.Equatable {
    let reasonCode: Swift.String?
    let comment: Swift.String?
}

extension CancelJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case reasonCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reasonCode)
        reasonCode = reasonCodeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CancelJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.jobArn = output.jobArn
            self.jobId = output.jobId
        } else {
            self.description = nil
            self.jobArn = nil
            self.jobId = nil
        }
    }
}

public struct CancelJobOutput: Swift.Equatable {
    /// A short text description of the job.
    public var description: Swift.String?
    /// The job ARN.
    public var jobArn: Swift.String?
    /// The unique identifier you assigned to this job when it was created.
    public var jobId: Swift.String?

    public init(
        description: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.description = description
        self.jobArn = jobArn
        self.jobId = jobId
    }
}

struct CancelJobOutputBody: Swift.Equatable {
    let jobArn: Swift.String?
    let jobId: Swift.String?
    let description: Swift.String?
}

extension CancelJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case jobArn
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum CancelJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes {
    public enum CannedAccessControlList: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedread
        case awsexecread
        case bucketownerfullcontrol
        case bucketownerread
        case logdeliverywrite
        case `private`
        case publicread
        case publicreadwrite
        case sdkUnknown(Swift.String)

        public static var allCases: [CannedAccessControlList] {
            return [
                .authenticatedread,
                .awsexecread,
                .bucketownerfullcontrol,
                .bucketownerread,
                .logdeliverywrite,
                .private,
                .publicread,
                .publicreadwrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedread: return "authenticated-read"
            case .awsexecread: return "aws-exec-read"
            case .bucketownerfullcontrol: return "bucket-owner-full-control"
            case .bucketownerread: return "bucket-owner-read"
            case .logdeliverywrite: return "log-delivery-write"
            case .private: return "private"
            case .publicread: return "public-read"
            case .publicreadwrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CannedAccessControlList(rawValue: rawValue) ?? CannedAccessControlList.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.Certificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateId
        case certificateMode
        case creationDate
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let certificateMode = self.certificateMode {
            try encodeContainer.encode(certificateMode.rawValue, forKey: .certificateMode)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CertificateStatus.self, forKey: .status)
        status = statusDecoded
        let certificateModeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CertificateMode.self, forKey: .certificateMode)
        certificateMode = certificateModeDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension IoTClientTypes {
    /// Information about a certificate.
    public struct Certificate: Swift.Equatable {
        /// The ARN of the certificate.
        public var certificateArn: Swift.String?
        /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
        public var certificateId: Swift.String?
        /// The mode of the certificate. DEFAULT: A certificate in DEFAULT mode is either generated by Amazon Web Services IoT Core or registered with an issuer certificate authority (CA) in DEFAULT mode. Devices with certificates in DEFAULT mode aren't required to send the Server Name Indication (SNI) extension when connecting to Amazon Web Services IoT Core. However, to use features such as custom domains and VPC endpoints, we recommend that you use the SNI extension when connecting to Amazon Web Services IoT Core. SNI_ONLY: A certificate in SNI_ONLY mode is registered without an issuer CA. Devices with certificates in SNI_ONLY mode must send the SNI extension when connecting to Amazon Web Services IoT Core.
        public var certificateMode: IoTClientTypes.CertificateMode?
        /// The date and time the certificate was created.
        public var creationDate: ClientRuntime.Date?
        /// The status of the certificate. The status value REGISTER_INACTIVE is deprecated and should not be used.
        public var status: IoTClientTypes.CertificateStatus?

        public init(
            certificateArn: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            certificateMode: IoTClientTypes.CertificateMode? = nil,
            creationDate: ClientRuntime.Date? = nil,
            status: IoTClientTypes.CertificateStatus? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateId = certificateId
            self.certificateMode = certificateMode
            self.creationDate = creationDate
            self.status = status
        }
    }

}

extension CertificateConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CertificateConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Unable to verify the CA certificate used to sign the device certificate you are attempting to register. This is happens when you have registered more than one CA certificate that has the same subject field and public key.
public struct CertificateConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CertificateConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CertificateConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CertificateConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes.CertificateDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caCertificateId
        case certificateArn
        case certificateId
        case certificateMode
        case certificatePem
        case creationDate
        case customerVersion
        case generationId
        case lastModifiedDate
        case ownedBy
        case previousOwnedBy
        case status
        case transferData
        case validity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caCertificateId = self.caCertificateId {
            try encodeContainer.encode(caCertificateId, forKey: .caCertificateId)
        }
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let certificateMode = self.certificateMode {
            try encodeContainer.encode(certificateMode.rawValue, forKey: .certificateMode)
        }
        if let certificatePem = self.certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let customerVersion = self.customerVersion {
            try encodeContainer.encode(customerVersion, forKey: .customerVersion)
        }
        if let generationId = self.generationId {
            try encodeContainer.encode(generationId, forKey: .generationId)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let ownedBy = self.ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let previousOwnedBy = self.previousOwnedBy {
            try encodeContainer.encode(previousOwnedBy, forKey: .previousOwnedBy)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let transferData = self.transferData {
            try encodeContainer.encode(transferData, forKey: .transferData)
        }
        if let validity = self.validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let caCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caCertificateId)
        caCertificateId = caCertificateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CertificateStatus.self, forKey: .status)
        status = statusDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let previousOwnedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .previousOwnedBy)
        previousOwnedBy = previousOwnedByDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let customerVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .customerVersion)
        customerVersion = customerVersionDecoded
        let transferDataDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TransferData.self, forKey: .transferData)
        transferData = transferDataDecoded
        let generationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationId)
        generationId = generationIdDecoded
        let validityDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CertificateValidity.self, forKey: .validity)
        validity = validityDecoded
        let certificateModeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CertificateMode.self, forKey: .certificateMode)
        certificateMode = certificateModeDecoded
    }
}

extension IoTClientTypes {
    /// Describes a certificate.
    public struct CertificateDescription: Swift.Equatable {
        /// The certificate ID of the CA certificate used to sign this certificate.
        public var caCertificateId: Swift.String?
        /// The ARN of the certificate.
        public var certificateArn: Swift.String?
        /// The ID of the certificate.
        public var certificateId: Swift.String?
        /// The mode of the certificate. DEFAULT: A certificate in DEFAULT mode is either generated by Amazon Web Services IoT Core or registered with an issuer certificate authority (CA) in DEFAULT mode. Devices with certificates in DEFAULT mode aren't required to send the Server Name Indication (SNI) extension when connecting to Amazon Web Services IoT Core. However, to use features such as custom domains and VPC endpoints, we recommend that you use the SNI extension when connecting to Amazon Web Services IoT Core. SNI_ONLY: A certificate in SNI_ONLY mode is registered without an issuer CA. Devices with certificates in SNI_ONLY mode must send the SNI extension when connecting to Amazon Web Services IoT Core. For more information about the value for SNI extension, see [Transport security in IoT](https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html).
        public var certificateMode: IoTClientTypes.CertificateMode?
        /// The certificate data, in PEM format.
        public var certificatePem: Swift.String?
        /// The date and time the certificate was created.
        public var creationDate: ClientRuntime.Date?
        /// The customer version of the certificate.
        public var customerVersion: Swift.Int?
        /// The generation ID of the certificate.
        public var generationId: Swift.String?
        /// The date and time the certificate was last modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The ID of the Amazon Web Services account that owns the certificate.
        public var ownedBy: Swift.String?
        /// The ID of the Amazon Web Services account of the previous owner of the certificate.
        public var previousOwnedBy: Swift.String?
        /// The status of the certificate.
        public var status: IoTClientTypes.CertificateStatus?
        /// The transfer data.
        public var transferData: IoTClientTypes.TransferData?
        /// When the certificate is valid.
        public var validity: IoTClientTypes.CertificateValidity?

        public init(
            caCertificateId: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            certificateMode: IoTClientTypes.CertificateMode? = nil,
            certificatePem: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            customerVersion: Swift.Int? = nil,
            generationId: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            ownedBy: Swift.String? = nil,
            previousOwnedBy: Swift.String? = nil,
            status: IoTClientTypes.CertificateStatus? = nil,
            transferData: IoTClientTypes.TransferData? = nil,
            validity: IoTClientTypes.CertificateValidity? = nil
        )
        {
            self.caCertificateId = caCertificateId
            self.certificateArn = certificateArn
            self.certificateId = certificateId
            self.certificateMode = certificateMode
            self.certificatePem = certificatePem
            self.creationDate = creationDate
            self.customerVersion = customerVersion
            self.generationId = generationId
            self.lastModifiedDate = lastModifiedDate
            self.ownedBy = ownedBy
            self.previousOwnedBy = previousOwnedBy
            self.status = status
            self.transferData = transferData
            self.validity = validity
        }
    }

}

extension IoTClientTypes {
    public enum CertificateMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case sniOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateMode] {
            return [
                .default,
                .sniOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .sniOnly: return "SNI_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateMode(rawValue: rawValue) ?? CertificateMode.sdkUnknown(rawValue)
        }
    }
}

extension CertificateStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CertificateStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The certificate operation is not allowed.
public struct CertificateStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CertificateStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CertificateStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CertificateStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes {
    public enum CertificateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case pendingActivation
        case pendingTransfer
        case registerInactive
        case revoked
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateStatus] {
            return [
                .active,
                .inactive,
                .pendingActivation,
                .pendingTransfer,
                .registerInactive,
                .revoked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .pendingActivation: return "PENDING_ACTIVATION"
            case .pendingTransfer: return "PENDING_TRANSFER"
            case .registerInactive: return "REGISTER_INACTIVE"
            case .revoked: return "REVOKED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateStatus(rawValue: rawValue) ?? CertificateStatus.sdkUnknown(rawValue)
        }
    }
}

extension CertificateValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CertificateValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The certificate is invalid.
public struct CertificateValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Additional information about the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CertificateValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CertificateValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CertificateValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes.CertificateValidity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notAfter
        case notBefore
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notAfter = self.notAfter {
            try encodeContainer.encodeTimestamp(notAfter, format: .epochSeconds, forKey: .notAfter)
        }
        if let notBefore = self.notBefore {
            try encodeContainer.encodeTimestamp(notBefore, format: .epochSeconds, forKey: .notBefore)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notBefore)
        notBefore = notBeforeDecoded
        let notAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .notAfter)
        notAfter = notAfterDecoded
    }
}

extension IoTClientTypes {
    /// When the certificate is valid.
    public struct CertificateValidity: Swift.Equatable {
        /// The certificate is not valid after this date.
        public var notAfter: ClientRuntime.Date?
        /// The certificate is not valid before this date.
        public var notBefore: ClientRuntime.Date?

        public init(
            notAfter: ClientRuntime.Date? = nil,
            notBefore: ClientRuntime.Date? = nil
        )
        {
            self.notAfter = notAfter
            self.notBefore = notBefore
        }
    }

}

extension ClearDefaultAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/default-authorizer"
    }
}

public struct ClearDefaultAuthorizerInput: Swift.Equatable {

    public init() { }
}

struct ClearDefaultAuthorizerInputBody: Swift.Equatable {
}

extension ClearDefaultAuthorizerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ClearDefaultAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ClearDefaultAuthorizerOutput: Swift.Equatable {

    public init() { }
}

enum ClearDefaultAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.CloudwatchAlarmAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmName
        case roleArn
        case stateReason
        case stateValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmName = self.alarmName {
            try encodeContainer.encode(alarmName, forKey: .alarmName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stateReason = self.stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let stateValue = self.stateValue {
            try encodeContainer.encode(stateValue, forKey: .stateValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let alarmNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmName)
        alarmName = alarmNameDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateValue)
        stateValue = stateValueDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action that updates a CloudWatch alarm.
    public struct CloudwatchAlarmAction: Swift.Equatable {
        /// The CloudWatch alarm name.
        /// This member is required.
        public var alarmName: Swift.String?
        /// The IAM role that allows access to the CloudWatch alarm.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The reason for the alarm change.
        /// This member is required.
        public var stateReason: Swift.String?
        /// The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        /// This member is required.
        public var stateValue: Swift.String?

        public init(
            alarmName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            stateReason: Swift.String? = nil,
            stateValue: Swift.String? = nil
        )
        {
            self.alarmName = alarmName
            self.roleArn = roleArn
            self.stateReason = stateReason
            self.stateValue = stateValue
        }
    }

}

extension IoTClientTypes.CloudwatchLogsAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchMode
        case logGroupName
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchMode = self.batchMode {
            try encodeContainer.encode(batchMode, forKey: .batchMode)
        }
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let batchModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .batchMode)
        batchMode = batchModeDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action that sends data to CloudWatch Logs.
    public struct CloudwatchLogsAction: Swift.Equatable {
        /// Indicates whether batches of log records will be extracted and uploaded into CloudWatch. Values include true or false (default).
        public var batchMode: Swift.Bool?
        /// The CloudWatch log group to which the action sends data.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The IAM role that allows access to the CloudWatch log.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            batchMode: Swift.Bool? = nil,
            logGroupName: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.batchMode = batchMode
            self.logGroupName = logGroupName
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes.CloudwatchMetricAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName
        case metricNamespace
        case metricTimestamp
        case metricUnit
        case metricValue
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricNamespace = self.metricNamespace {
            try encodeContainer.encode(metricNamespace, forKey: .metricNamespace)
        }
        if let metricTimestamp = self.metricTimestamp {
            try encodeContainer.encode(metricTimestamp, forKey: .metricTimestamp)
        }
        if let metricUnit = self.metricUnit {
            try encodeContainer.encode(metricUnit, forKey: .metricUnit)
        }
        if let metricValue = self.metricValue {
            try encodeContainer.encode(metricValue, forKey: .metricValue)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let metricNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricNamespace)
        metricNamespace = metricNamespaceDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricValue)
        metricValue = metricValueDecoded
        let metricUnitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricUnit)
        metricUnit = metricUnitDecoded
        let metricTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricTimestamp)
        metricTimestamp = metricTimestampDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action that captures a CloudWatch metric.
    public struct CloudwatchMetricAction: Swift.Equatable {
        /// The CloudWatch metric name.
        /// This member is required.
        public var metricName: Swift.String?
        /// The CloudWatch metric namespace name.
        /// This member is required.
        public var metricNamespace: Swift.String?
        /// An optional [Unix timestamp](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp).
        public var metricTimestamp: Swift.String?
        /// The [metric unit](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit) supported by CloudWatch.
        /// This member is required.
        public var metricUnit: Swift.String?
        /// The CloudWatch metric value.
        /// This member is required.
        public var metricValue: Swift.String?
        /// The IAM role that allows access to the CloudWatch metric.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            metricName: Swift.String? = nil,
            metricNamespace: Swift.String? = nil,
            metricTimestamp: Swift.String? = nil,
            metricUnit: Swift.String? = nil,
            metricValue: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.metricNamespace = metricNamespace
            self.metricTimestamp = metricTimestamp
            self.metricUnit = metricUnit
            self.metricValue = metricValue
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes.CodeSigning: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsSignerJobId
        case customCodeSigning
        case startSigningJobParameter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsSignerJobId = self.awsSignerJobId {
            try encodeContainer.encode(awsSignerJobId, forKey: .awsSignerJobId)
        }
        if let customCodeSigning = self.customCodeSigning {
            try encodeContainer.encode(customCodeSigning, forKey: .customCodeSigning)
        }
        if let startSigningJobParameter = self.startSigningJobParameter {
            try encodeContainer.encode(startSigningJobParameter, forKey: .startSigningJobParameter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsSignerJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsSignerJobId)
        awsSignerJobId = awsSignerJobIdDecoded
        let startSigningJobParameterDecoded = try containerValues.decodeIfPresent(IoTClientTypes.StartSigningJobParameter.self, forKey: .startSigningJobParameter)
        startSigningJobParameter = startSigningJobParameterDecoded
        let customCodeSigningDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CustomCodeSigning.self, forKey: .customCodeSigning)
        customCodeSigning = customCodeSigningDecoded
    }
}

extension IoTClientTypes {
    /// Describes the method to use when code signing a file.
    public struct CodeSigning: Swift.Equatable {
        /// The ID of the AWSSignerJob which was created to sign the file.
        public var awsSignerJobId: Swift.String?
        /// A custom method for code signing a file.
        public var customCodeSigning: IoTClientTypes.CustomCodeSigning?
        /// Describes the code-signing job.
        public var startSigningJobParameter: IoTClientTypes.StartSigningJobParameter?

        public init(
            awsSignerJobId: Swift.String? = nil,
            customCodeSigning: IoTClientTypes.CustomCodeSigning? = nil,
            startSigningJobParameter: IoTClientTypes.StartSigningJobParameter? = nil
        )
        {
            self.awsSignerJobId = awsSignerJobId
            self.customCodeSigning = customCodeSigning
            self.startSigningJobParameter = startSigningJobParameter
        }
    }

}

extension IoTClientTypes.CodeSigningCertificateChain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateName
        case inlineDocument
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateName = self.certificateName {
            try encodeContainer.encode(certificateName, forKey: .certificateName)
        }
        if let inlineDocument = self.inlineDocument {
            try encodeContainer.encode(inlineDocument, forKey: .inlineDocument)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let inlineDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inlineDocument)
        inlineDocument = inlineDocumentDecoded
    }
}

extension IoTClientTypes {
    /// Describes the certificate chain being used when code signing a file.
    public struct CodeSigningCertificateChain: Swift.Equatable {
        /// The name of the certificate.
        public var certificateName: Swift.String?
        /// A base64 encoded binary representation of the code signing certificate chain.
        public var inlineDocument: Swift.String?

        public init(
            certificateName: Swift.String? = nil,
            inlineDocument: Swift.String? = nil
        )
        {
            self.certificateName = certificateName
            self.inlineDocument = inlineDocument
        }
    }

}

extension IoTClientTypes.CodeSigningSignature: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlineDocument
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inlineDocument = self.inlineDocument {
            try encodeContainer.encode(inlineDocument.base64EncodedString(), forKey: .inlineDocument)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlineDocumentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .inlineDocument)
        inlineDocument = inlineDocumentDecoded
    }
}

extension IoTClientTypes {
    /// Describes the signature for a file.
    public struct CodeSigningSignature: Swift.Equatable {
        /// A base64 encoded binary representation of the code signing signature.
        public var inlineDocument: ClientRuntime.Data?

        public init(
            inlineDocument: ClientRuntime.Data? = nil
        )
        {
            self.inlineDocument = inlineDocument
        }
    }

}

extension IoTClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case greaterThan
        case greaterThanEquals
        case inCidrSet
        case inPortSet
        case inSet
        case lessThan
        case lessThanEquals
        case notInCidrSet
        case notInPortSet
        case notInSet
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .greaterThan,
                .greaterThanEquals,
                .inCidrSet,
                .inPortSet,
                .inSet,
                .lessThan,
                .lessThanEquals,
                .notInCidrSet,
                .notInPortSet,
                .notInSet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .greaterThan: return "greater-than"
            case .greaterThanEquals: return "greater-than-equals"
            case .inCidrSet: return "in-cidr-set"
            case .inPortSet: return "in-port-set"
            case .inSet: return "in-set"
            case .lessThan: return "less-than"
            case .lessThanEquals: return "less-than-equals"
            case .notInCidrSet: return "not-in-cidr-set"
            case .notInPortSet: return "not-in-port-set"
            case .notInSet: return "not-in-set"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum ConfidenceLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfidenceLevel] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfidenceLevel(rawValue: rawValue) ?? ConfidenceLevel.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension IoTClientTypes {
    /// Configuration.
    public struct Configuration: Swift.Equatable {
        /// True to enable the configuration.
        public var enabled: Swift.Bool

        public init(
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension ConfirmTopicRuleDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let confirmationToken = confirmationToken else {
            return nil
        }
        return "/confirmdestination/\(confirmationToken.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct ConfirmTopicRuleDestinationInput: Swift.Equatable {
    /// The token used to confirm ownership or access to the topic rule confirmation URL.
    /// This member is required.
    public var confirmationToken: Swift.String?

    public init(
        confirmationToken: Swift.String? = nil
    )
    {
        self.confirmationToken = confirmationToken
    }
}

struct ConfirmTopicRuleDestinationInputBody: Swift.Equatable {
}

extension ConfirmTopicRuleDestinationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ConfirmTopicRuleDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ConfirmTopicRuleDestinationOutput: Swift.Equatable {

    public init() { }
}

enum ConfirmTopicRuleDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource with the same name already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// A resource with the same name already exists.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ConflictingResourceUpdateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictingResourceUpdateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.
public struct ConflictingResourceUpdateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictingResourceUpdateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictingResourceUpdateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictingResourceUpdateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAuditSuppressionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName
        case clientRequestToken
        case description
        case expirationDate
        case resourceIdentifier
        case suppressIndefinitely
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = self.checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = self.expirationDate {
            try encodeContainer.encodeTimestamp(expirationDate, format: .epochSeconds, forKey: .expirationDate)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let suppressIndefinitely = self.suppressIndefinitely {
            try encodeContainer.encode(suppressIndefinitely, forKey: .suppressIndefinitely)
        }
    }
}

extension CreateAuditSuppressionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/suppressions/create"
    }
}

public struct CreateAuditSuppressionInput: Swift.Equatable {
    /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    /// This member is required.
    public var checkName: Swift.String?
    /// Each audit supression must have a unique client request token. If you try to create a new audit suppression with the same token as one that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The description of the audit suppression.
    public var description: Swift.String?
    /// The epoch timestamp in seconds at which this suppression expires.
    public var expirationDate: ClientRuntime.Date?
    /// Information that identifies the noncompliant resource.
    /// This member is required.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
    /// Indicates whether a suppression should exist indefinitely or not.
    public var suppressIndefinitely: Swift.Bool?

    public init(
        checkName: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        expirationDate: ClientRuntime.Date? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
        suppressIndefinitely: Swift.Bool? = nil
    )
    {
        self.checkName = checkName
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.expirationDate = expirationDate
        self.resourceIdentifier = resourceIdentifier
        self.suppressIndefinitely = suppressIndefinitely
    }
}

struct CreateAuditSuppressionInputBody: Swift.Equatable {
    let checkName: Swift.String?
    let resourceIdentifier: IoTClientTypes.ResourceIdentifier?
    let expirationDate: ClientRuntime.Date?
    let suppressIndefinitely: Swift.Bool?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
}

extension CreateAuditSuppressionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName
        case clientRequestToken
        case description
        case expirationDate
        case resourceIdentifier
        case suppressIndefinitely
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let expirationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let suppressIndefinitelyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .suppressIndefinitely)
        suppressIndefinitely = suppressIndefinitelyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateAuditSuppressionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateAuditSuppressionOutput: Swift.Equatable {

    public init() { }
}

enum CreateAuditSuppressionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerFunctionArn
        case enableCachingForHttp
        case signingDisabled
        case status
        case tags
        case tokenKeyName
        case tokenSigningPublicKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerFunctionArn = self.authorizerFunctionArn {
            try encodeContainer.encode(authorizerFunctionArn, forKey: .authorizerFunctionArn)
        }
        if let enableCachingForHttp = self.enableCachingForHttp {
            try encodeContainer.encode(enableCachingForHttp, forKey: .enableCachingForHttp)
        }
        if let signingDisabled = self.signingDisabled {
            try encodeContainer.encode(signingDisabled, forKey: .signingDisabled)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let tokenKeyName = self.tokenKeyName {
            try encodeContainer.encode(tokenKeyName, forKey: .tokenKeyName)
        }
        if let tokenSigningPublicKeys = tokenSigningPublicKeys {
            var tokenSigningPublicKeysContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tokenSigningPublicKeys)
            for (dictKey0, publicKeyMap0) in tokenSigningPublicKeys {
                try tokenSigningPublicKeysContainer.encode(publicKeyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let authorizerName = authorizerName else {
            return nil
        }
        return "/authorizer/\(authorizerName.urlPercentEncoding())"
    }
}

public struct CreateAuthorizerInput: Swift.Equatable {
    /// The ARN of the authorizer's Lambda function.
    /// This member is required.
    public var authorizerFunctionArn: Swift.String?
    /// The authorizer name.
    /// This member is required.
    public var authorizerName: Swift.String?
    /// When true, the result from the authorizers Lambda function is cached for clients that use persistent HTTP connections. The results are cached for the time specified by the Lambda function in refreshAfterInSeconds. This value does not affect authorization of clients that use MQTT connections. The default value is false.
    public var enableCachingForHttp: Swift.Bool?
    /// Specifies whether IoT validates the token signature in an authorization request.
    public var signingDisabled: Swift.Bool?
    /// The status of the create authorizer request.
    public var status: IoTClientTypes.AuthorizerStatus?
    /// Metadata which can be used to manage the custom authorizer. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: [IoTClientTypes.Tag]?
    /// The name of the token key used to extract the token from the HTTP headers.
    public var tokenKeyName: Swift.String?
    /// The public keys used to verify the digital signature returned by your custom authentication service.
    public var tokenSigningPublicKeys: [Swift.String:Swift.String]?

    public init(
        authorizerFunctionArn: Swift.String? = nil,
        authorizerName: Swift.String? = nil,
        enableCachingForHttp: Swift.Bool? = nil,
        signingDisabled: Swift.Bool? = nil,
        status: IoTClientTypes.AuthorizerStatus? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        tokenKeyName: Swift.String? = nil,
        tokenSigningPublicKeys: [Swift.String:Swift.String]? = nil
    )
    {
        self.authorizerFunctionArn = authorizerFunctionArn
        self.authorizerName = authorizerName
        self.enableCachingForHttp = enableCachingForHttp
        self.signingDisabled = signingDisabled
        self.status = status
        self.tags = tags
        self.tokenKeyName = tokenKeyName
        self.tokenSigningPublicKeys = tokenSigningPublicKeys
    }
}

struct CreateAuthorizerInputBody: Swift.Equatable {
    let authorizerFunctionArn: Swift.String?
    let tokenKeyName: Swift.String?
    let tokenSigningPublicKeys: [Swift.String:Swift.String]?
    let status: IoTClientTypes.AuthorizerStatus?
    let tags: [IoTClientTypes.Tag]?
    let signingDisabled: Swift.Bool?
    let enableCachingForHttp: Swift.Bool?
}

extension CreateAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerFunctionArn
        case enableCachingForHttp
        case signingDisabled
        case status
        case tags
        case tokenKeyName
        case tokenSigningPublicKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerFunctionArn)
        authorizerFunctionArn = authorizerFunctionArnDecoded
        let tokenKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenKeyName)
        tokenKeyName = tokenKeyNameDecoded
        let tokenSigningPublicKeysContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tokenSigningPublicKeys)
        var tokenSigningPublicKeysDecoded0: [Swift.String:Swift.String]? = nil
        if let tokenSigningPublicKeysContainer = tokenSigningPublicKeysContainer {
            tokenSigningPublicKeysDecoded0 = [Swift.String:Swift.String]()
            for (key0, keyvalue0) in tokenSigningPublicKeysContainer {
                if let keyvalue0 = keyvalue0 {
                    tokenSigningPublicKeysDecoded0?[key0] = keyvalue0
                }
            }
        }
        tokenSigningPublicKeys = tokenSigningPublicKeysDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuthorizerStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let signingDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .signingDisabled)
        signingDisabled = signingDisabledDecoded
        let enableCachingForHttpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableCachingForHttp)
        enableCachingForHttp = enableCachingForHttpDecoded
    }
}

extension CreateAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAuthorizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizerArn = output.authorizerArn
            self.authorizerName = output.authorizerName
        } else {
            self.authorizerArn = nil
            self.authorizerName = nil
        }
    }
}

public struct CreateAuthorizerOutput: Swift.Equatable {
    /// The authorizer ARN.
    public var authorizerArn: Swift.String?
    /// The authorizer's name.
    public var authorizerName: Swift.String?

    public init(
        authorizerArn: Swift.String? = nil,
        authorizerName: Swift.String? = nil
    )
    {
        self.authorizerArn = authorizerArn
        self.authorizerName = authorizerName
    }
}

struct CreateAuthorizerOutputBody: Swift.Equatable {
    let authorizerName: Swift.String?
    let authorizerArn: Swift.String?
}

extension CreateAuthorizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerArn
        case authorizerName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerName)
        authorizerName = authorizerNameDecoded
        let authorizerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerArn)
        authorizerArn = authorizerArnDecoded
    }
}

enum CreateAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBillingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupProperties
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupProperties = self.billingGroupProperties {
            try encodeContainer.encode(billingGroupProperties, forKey: .billingGroupProperties)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateBillingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let billingGroupName = billingGroupName else {
            return nil
        }
        return "/billing-groups/\(billingGroupName.urlPercentEncoding())"
    }
}

public struct CreateBillingGroupInput: Swift.Equatable {
    /// The name you wish to give to the billing group.
    /// This member is required.
    public var billingGroupName: Swift.String?
    /// The properties of the billing group.
    public var billingGroupProperties: IoTClientTypes.BillingGroupProperties?
    /// Metadata which can be used to manage the billing group.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        billingGroupName: Swift.String? = nil,
        billingGroupProperties: IoTClientTypes.BillingGroupProperties? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.billingGroupName = billingGroupName
        self.billingGroupProperties = billingGroupProperties
        self.tags = tags
    }
}

struct CreateBillingGroupInputBody: Swift.Equatable {
    let billingGroupProperties: IoTClientTypes.BillingGroupProperties?
    let tags: [IoTClientTypes.Tag]?
}

extension CreateBillingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupProperties
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupPropertiesDecoded = try containerValues.decodeIfPresent(IoTClientTypes.BillingGroupProperties.self, forKey: .billingGroupProperties)
        billingGroupProperties = billingGroupPropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBillingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBillingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.billingGroupArn = output.billingGroupArn
            self.billingGroupId = output.billingGroupId
            self.billingGroupName = output.billingGroupName
        } else {
            self.billingGroupArn = nil
            self.billingGroupId = nil
            self.billingGroupName = nil
        }
    }
}

public struct CreateBillingGroupOutput: Swift.Equatable {
    /// The ARN of the billing group.
    public var billingGroupArn: Swift.String?
    /// The ID of the billing group.
    public var billingGroupId: Swift.String?
    /// The name you gave to the billing group.
    public var billingGroupName: Swift.String?

    public init(
        billingGroupArn: Swift.String? = nil,
        billingGroupId: Swift.String? = nil,
        billingGroupName: Swift.String? = nil
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingGroupId = billingGroupId
        self.billingGroupName = billingGroupName
    }
}

struct CreateBillingGroupOutputBody: Swift.Equatable {
    let billingGroupName: Swift.String?
    let billingGroupArn: Swift.String?
    let billingGroupId: Swift.String?
}

extension CreateBillingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupArn
        case billingGroupId
        case billingGroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupName)
        billingGroupName = billingGroupNameDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let billingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupId)
        billingGroupId = billingGroupIdDecoded
    }
}

enum CreateBillingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCertificateFromCsrInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateSigningRequest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateSigningRequest = self.certificateSigningRequest {
            try encodeContainer.encode(certificateSigningRequest, forKey: .certificateSigningRequest)
        }
    }
}

extension CreateCertificateFromCsrInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let setAsActive = setAsActive {
                let setAsActiveQueryItem = ClientRuntime.URLQueryItem(name: "setAsActive".urlPercentEncoding(), value: Swift.String(setAsActive).urlPercentEncoding())
                items.append(setAsActiveQueryItem)
            }
            return items
        }
    }
}

extension CreateCertificateFromCsrInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/certificates"
    }
}

/// The input for the CreateCertificateFromCsr operation.
public struct CreateCertificateFromCsrInput: Swift.Equatable {
    /// The certificate signing request (CSR).
    /// This member is required.
    public var certificateSigningRequest: Swift.String?
    /// Specifies whether the certificate is active.
    public var setAsActive: Swift.Bool?

    public init(
        certificateSigningRequest: Swift.String? = nil,
        setAsActive: Swift.Bool? = nil
    )
    {
        self.certificateSigningRequest = certificateSigningRequest
        self.setAsActive = setAsActive
    }
}

struct CreateCertificateFromCsrInputBody: Swift.Equatable {
    let certificateSigningRequest: Swift.String?
}

extension CreateCertificateFromCsrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateSigningRequest
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateSigningRequestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateSigningRequest)
        certificateSigningRequest = certificateSigningRequestDecoded
    }
}

extension CreateCertificateFromCsrOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCertificateFromCsrOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateArn = output.certificateArn
            self.certificateId = output.certificateId
            self.certificatePem = output.certificatePem
        } else {
            self.certificateArn = nil
            self.certificateId = nil
            self.certificatePem = nil
        }
    }
}

/// The output from the CreateCertificateFromCsr operation.
public struct CreateCertificateFromCsrOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the certificate. You can use the ARN as a principal for policy operations.
    public var certificateArn: Swift.String?
    /// The ID of the certificate. Certificate management operations only take a certificateId.
    public var certificateId: Swift.String?
    /// The certificate data, in PEM format.
    public var certificatePem: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        certificateId: Swift.String? = nil,
        certificatePem: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
        self.certificatePem = certificatePem
    }
}

struct CreateCertificateFromCsrOutputBody: Swift.Equatable {
    let certificateArn: Swift.String?
    let certificateId: Swift.String?
    let certificatePem: Swift.String?
}

extension CreateCertificateFromCsrOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateId
        case certificatePem
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
    }
}

enum CreateCertificateFromCsrOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCustomMetricInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case displayName
        case metricType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let metricType = self.metricType {
            try encodeContainer.encode(metricType.rawValue, forKey: .metricType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateCustomMetricInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let metricName = metricName else {
            return nil
        }
        return "/custom-metric/\(metricName.urlPercentEncoding())"
    }
}

public struct CreateCustomMetricInput: Swift.Equatable {
    /// Each custom metric must have a unique client request token. If you try to create a new custom metric that already exists with a different token, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The friendly name in the console for the custom metric. This name doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. You can update the friendly name after you define it.
    public var displayName: Swift.String?
    /// The name of the custom metric. This will be used in the metric report submitted from the device/thing. The name can't begin with aws:. You can't change the name after you define it.
    /// This member is required.
    public var metricName: Swift.String?
    /// The type of the custom metric. The type number only takes a single metric value as an input, but when you submit the metrics value in the DeviceMetrics report, you must pass it as an array with a single value.
    /// This member is required.
    public var metricType: IoTClientTypes.CustomMetricType?
    /// Metadata that can be used to manage the custom metric.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        metricName: Swift.String? = nil,
        metricType: IoTClientTypes.CustomMetricType? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.displayName = displayName
        self.metricName = metricName
        self.metricType = metricType
        self.tags = tags
    }
}

struct CreateCustomMetricInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let metricType: IoTClientTypes.CustomMetricType?
    let tags: [IoTClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateCustomMetricInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case displayName
        case metricType
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let metricTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CustomMetricType.self, forKey: .metricType)
        metricType = metricTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateCustomMetricOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCustomMetricOutputBody = try responseDecoder.decode(responseBody: data)
            self.metricArn = output.metricArn
            self.metricName = output.metricName
        } else {
            self.metricArn = nil
            self.metricName = nil
        }
    }
}

public struct CreateCustomMetricOutput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the custom metric. For example, arn:aws-partition:iot:region:accountId:custommetric/metricName
    public var metricArn: Swift.String?
    /// The name of the custom metric to be used in the metric report.
    public var metricName: Swift.String?

    public init(
        metricArn: Swift.String? = nil,
        metricName: Swift.String? = nil
    )
    {
        self.metricArn = metricArn
        self.metricName = metricName
    }
}

struct CreateCustomMetricOutputBody: Swift.Equatable {
    let metricName: Swift.String?
    let metricArn: Swift.String?
}

extension CreateCustomMetricOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricArn
        case metricName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricArn)
        metricArn = metricArnDecoded
    }
}

enum CreateCustomMetricOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDimensionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case stringValues
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let stringValues = stringValues {
            var stringValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringValues)
            for dimensionstringvalue0 in stringValues {
                try stringValuesContainer.encode(dimensionstringvalue0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateDimensionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/dimensions/\(name.urlPercentEncoding())"
    }
}

public struct CreateDimensionInput: Swift.Equatable {
    /// Each dimension must have a unique client request token. If you try to create a new dimension with the same token as a dimension that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the value or list of values for the dimension. For TOPIC_FILTER dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").
    /// This member is required.
    public var stringValues: [Swift.String]?
    /// Metadata that can be used to manage the dimension.
    public var tags: [IoTClientTypes.Tag]?
    /// Specifies the type of dimension. Supported types: TOPIC_FILTER.
    /// This member is required.
    public var type: IoTClientTypes.DimensionType?

    public init(
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        stringValues: [Swift.String]? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        type: IoTClientTypes.DimensionType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.stringValues = stringValues
        self.tags = tags
        self.type = type
    }
}

struct CreateDimensionInputBody: Swift.Equatable {
    let type: IoTClientTypes.DimensionType?
    let stringValues: [Swift.String]?
    let tags: [IoTClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateDimensionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case stringValues
        case tags
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DimensionType.self, forKey: .type)
        type = typeDecoded
        let stringValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stringValues)
        var stringValuesDecoded0:[Swift.String]? = nil
        if let stringValuesContainer = stringValuesContainer {
            stringValuesDecoded0 = [Swift.String]()
            for string0 in stringValuesContainer {
                if let string0 = string0 {
                    stringValuesDecoded0?.append(string0)
                }
            }
        }
        stringValues = stringValuesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateDimensionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDimensionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateDimensionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created dimension.
    public var arn: Swift.String?
    /// A unique identifier for the dimension.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateDimensionOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension CreateDimensionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateDimensionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDomainConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerConfig
        case domainName
        case serverCertificateArns
        case serviceType
        case tags
        case tlsConfig
        case validationCertificateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerConfig = self.authorizerConfig {
            try encodeContainer.encode(authorizerConfig, forKey: .authorizerConfig)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let serverCertificateArns = serverCertificateArns {
            var serverCertificateArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverCertificateArns)
            for acmcertificatearn0 in serverCertificateArns {
                try serverCertificateArnsContainer.encode(acmcertificatearn0)
            }
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let tlsConfig = self.tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
        if let validationCertificateArn = self.validationCertificateArn {
            try encodeContainer.encode(validationCertificateArn, forKey: .validationCertificateArn)
        }
    }
}

extension CreateDomainConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainConfigurationName = domainConfigurationName else {
            return nil
        }
        return "/domainConfigurations/\(domainConfigurationName.urlPercentEncoding())"
    }
}

public struct CreateDomainConfigurationInput: Swift.Equatable {
    /// An object that specifies the authorization service for a domain.
    public var authorizerConfig: IoTClientTypes.AuthorizerConfig?
    /// The name of the domain configuration. This value must be unique to a region.
    /// This member is required.
    public var domainConfigurationName: Swift.String?
    /// The name of the domain.
    public var domainName: Swift.String?
    /// The ARNs of the certificates that IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for Amazon Web Services-managed domains.
    public var serverCertificateArns: [Swift.String]?
    /// The type of service delivered by the endpoint. Amazon Web Services IoT Core currently supports only the DATA service type.
    public var serviceType: IoTClientTypes.ServiceType?
    /// Metadata which can be used to manage the domain configuration. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: [IoTClientTypes.Tag]?
    /// An object that specifies the TLS configuration for a domain.
    public var tlsConfig: IoTClientTypes.TlsConfig?
    /// The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for Amazon Web Services-managed domains.
    public var validationCertificateArn: Swift.String?

    public init(
        authorizerConfig: IoTClientTypes.AuthorizerConfig? = nil,
        domainConfigurationName: Swift.String? = nil,
        domainName: Swift.String? = nil,
        serverCertificateArns: [Swift.String]? = nil,
        serviceType: IoTClientTypes.ServiceType? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        tlsConfig: IoTClientTypes.TlsConfig? = nil,
        validationCertificateArn: Swift.String? = nil
    )
    {
        self.authorizerConfig = authorizerConfig
        self.domainConfigurationName = domainConfigurationName
        self.domainName = domainName
        self.serverCertificateArns = serverCertificateArns
        self.serviceType = serviceType
        self.tags = tags
        self.tlsConfig = tlsConfig
        self.validationCertificateArn = validationCertificateArn
    }
}

struct CreateDomainConfigurationInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let serverCertificateArns: [Swift.String]?
    let validationCertificateArn: Swift.String?
    let authorizerConfig: IoTClientTypes.AuthorizerConfig?
    let serviceType: IoTClientTypes.ServiceType?
    let tags: [IoTClientTypes.Tag]?
    let tlsConfig: IoTClientTypes.TlsConfig?
}

extension CreateDomainConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerConfig
        case domainName
        case serverCertificateArns
        case serviceType
        case tags
        case tlsConfig
        case validationCertificateArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let serverCertificateArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .serverCertificateArns)
        var serverCertificateArnsDecoded0:[Swift.String]? = nil
        if let serverCertificateArnsContainer = serverCertificateArnsContainer {
            serverCertificateArnsDecoded0 = [Swift.String]()
            for string0 in serverCertificateArnsContainer {
                if let string0 = string0 {
                    serverCertificateArnsDecoded0?.append(string0)
                }
            }
        }
        serverCertificateArns = serverCertificateArnsDecoded0
        let validationCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationCertificateArn)
        validationCertificateArn = validationCertificateArnDecoded
        let authorizerConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuthorizerConfig.self, forKey: .authorizerConfig)
        authorizerConfig = authorizerConfigDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let tlsConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension CreateDomainConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDomainConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainConfigurationArn = output.domainConfigurationArn
            self.domainConfigurationName = output.domainConfigurationName
        } else {
            self.domainConfigurationArn = nil
            self.domainConfigurationName = nil
        }
    }
}

public struct CreateDomainConfigurationOutput: Swift.Equatable {
    /// The ARN of the domain configuration.
    public var domainConfigurationArn: Swift.String?
    /// The name of the domain configuration.
    public var domainConfigurationName: Swift.String?

    public init(
        domainConfigurationArn: Swift.String? = nil,
        domainConfigurationName: Swift.String? = nil
    )
    {
        self.domainConfigurationArn = domainConfigurationArn
        self.domainConfigurationName = domainConfigurationName
    }
}

struct CreateDomainConfigurationOutputBody: Swift.Equatable {
    let domainConfigurationName: Swift.String?
    let domainConfigurationArn: Swift.String?
}

extension CreateDomainConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainConfigurationArn
        case domainConfigurationName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainConfigurationName)
        domainConfigurationName = domainConfigurationNameDecoded
        let domainConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainConfigurationArn)
        domainConfigurationArn = domainConfigurationArnDecoded
    }
}

enum CreateDomainConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CertificateValidationException": return try await CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDynamicThingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexName
        case queryString
        case queryVersion
        case tags
        case thingGroupProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = self.queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let thingGroupProperties = self.thingGroupProperties {
            try encodeContainer.encode(thingGroupProperties, forKey: .thingGroupProperties)
        }
    }
}

extension CreateDynamicThingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingGroupName = thingGroupName else {
            return nil
        }
        return "/dynamic-thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

public struct CreateDynamicThingGroupInput: Swift.Equatable {
    /// The dynamic thing group index name. Currently one index is supported: AWS_Things.
    public var indexName: Swift.String?
    /// The dynamic thing group search query string. See [Query Syntax](https://docs.aws.amazon.com/iot/latest/developerguide/query-syntax.html) for information about query string syntax.
    /// This member is required.
    public var queryString: Swift.String?
    /// The dynamic thing group query version. Currently one query version is supported: "2017-09-30". If not specified, the query version defaults to this value.
    public var queryVersion: Swift.String?
    /// Metadata which can be used to manage the dynamic thing group.
    public var tags: [IoTClientTypes.Tag]?
    /// The dynamic thing group name to create.
    /// This member is required.
    public var thingGroupName: Swift.String?
    /// The dynamic thing group properties.
    public var thingGroupProperties: IoTClientTypes.ThingGroupProperties?

    public init(
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        thingGroupName: Swift.String? = nil,
        thingGroupProperties: IoTClientTypes.ThingGroupProperties? = nil
    )
    {
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.tags = tags
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
    }
}

struct CreateDynamicThingGroupInputBody: Swift.Equatable {
    let thingGroupProperties: IoTClientTypes.ThingGroupProperties?
    let indexName: Swift.String?
    let queryString: Swift.String?
    let queryVersion: Swift.String?
    let tags: [IoTClientTypes.Tag]?
}

extension CreateDynamicThingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexName
        case queryString
        case queryVersion
        case tags
        case thingGroupProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupPropertiesDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingGroupProperties.self, forKey: .thingGroupProperties)
        thingGroupProperties = thingGroupPropertiesDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDynamicThingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDynamicThingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.indexName = output.indexName
            self.queryString = output.queryString
            self.queryVersion = output.queryVersion
            self.thingGroupArn = output.thingGroupArn
            self.thingGroupId = output.thingGroupId
            self.thingGroupName = output.thingGroupName
        } else {
            self.indexName = nil
            self.queryString = nil
            self.queryVersion = nil
            self.thingGroupArn = nil
            self.thingGroupId = nil
            self.thingGroupName = nil
        }
    }
}

public struct CreateDynamicThingGroupOutput: Swift.Equatable {
    /// The dynamic thing group index name.
    public var indexName: Swift.String?
    /// The dynamic thing group search query string.
    public var queryString: Swift.String?
    /// The dynamic thing group query version.
    public var queryVersion: Swift.String?
    /// The dynamic thing group ARN.
    public var thingGroupArn: Swift.String?
    /// The dynamic thing group ID.
    public var thingGroupId: Swift.String?
    /// The dynamic thing group name.
    public var thingGroupName: Swift.String?

    public init(
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        thingGroupArn: Swift.String? = nil,
        thingGroupId: Swift.String? = nil,
        thingGroupName: Swift.String? = nil
    )
    {
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.thingGroupArn = thingGroupArn
        self.thingGroupId = thingGroupId
        self.thingGroupName = thingGroupName
    }
}

struct CreateDynamicThingGroupOutputBody: Swift.Equatable {
    let thingGroupName: Swift.String?
    let thingGroupArn: Swift.String?
    let thingGroupId: Swift.String?
    let indexName: Swift.String?
    let queryString: Swift.String?
    let queryVersion: Swift.String?
}

extension CreateDynamicThingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexName
        case queryString
        case queryVersion
        case thingGroupArn
        case thingGroupId
        case thingGroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupName)
        thingGroupName = thingGroupNameDecoded
        let thingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupArn)
        thingGroupArn = thingGroupArnDecoded
        let thingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupId)
        thingGroupId = thingGroupIdDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
    }
}

enum CreateDynamicThingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidQueryException": return try await InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFleetMetricInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationField
        case aggregationType
        case description
        case indexName
        case period
        case queryString
        case queryVersion
        case tags
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationField = self.aggregationField {
            try encodeContainer.encode(aggregationField, forKey: .aggregationField)
        }
        if let aggregationType = self.aggregationType {
            try encodeContainer.encode(aggregationType, forKey: .aggregationType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let period = self.period {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = self.queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }
}

extension CreateFleetMetricInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let metricName = metricName else {
            return nil
        }
        return "/fleet-metric/\(metricName.urlPercentEncoding())"
    }
}

public struct CreateFleetMetricInput: Swift.Equatable {
    /// The field to aggregate.
    /// This member is required.
    public var aggregationField: Swift.String?
    /// The type of the aggregation query.
    /// This member is required.
    public var aggregationType: IoTClientTypes.AggregationType?
    /// The fleet metric description.
    public var description: Swift.String?
    /// The name of the index to search.
    public var indexName: Swift.String?
    /// The name of the fleet metric to create.
    /// This member is required.
    public var metricName: Swift.String?
    /// The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.
    /// This member is required.
    public var period: Swift.Int?
    /// The search query string.
    /// This member is required.
    public var queryString: Swift.String?
    /// The query version.
    public var queryVersion: Swift.String?
    /// Metadata, which can be used to manage the fleet metric.
    public var tags: [IoTClientTypes.Tag]?
    /// Used to support unit transformation such as milliseconds to seconds. The unit must be supported by [CW metric](https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html). Default to null.
    public var unit: IoTClientTypes.FleetMetricUnit?

    public init(
        aggregationField: Swift.String? = nil,
        aggregationType: IoTClientTypes.AggregationType? = nil,
        description: Swift.String? = nil,
        indexName: Swift.String? = nil,
        metricName: Swift.String? = nil,
        period: Swift.Int? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        unit: IoTClientTypes.FleetMetricUnit? = nil
    )
    {
        self.aggregationField = aggregationField
        self.aggregationType = aggregationType
        self.description = description
        self.indexName = indexName
        self.metricName = metricName
        self.period = period
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.tags = tags
        self.unit = unit
    }
}

struct CreateFleetMetricInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let aggregationType: IoTClientTypes.AggregationType?
    let period: Swift.Int?
    let aggregationField: Swift.String?
    let description: Swift.String?
    let queryVersion: Swift.String?
    let indexName: Swift.String?
    let unit: IoTClientTypes.FleetMetricUnit?
    let tags: [IoTClientTypes.Tag]?
}

extension CreateFleetMetricInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationField
        case aggregationType
        case description
        case indexName
        case period
        case queryString
        case queryVersion
        case tags
        case unit
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let aggregationTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AggregationType.self, forKey: .aggregationType)
        aggregationType = aggregationTypeDecoded
        let periodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .period)
        period = periodDecoded
        let aggregationFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregationField)
        aggregationField = aggregationFieldDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let unitDecoded = try containerValues.decodeIfPresent(IoTClientTypes.FleetMetricUnit.self, forKey: .unit)
        unit = unitDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFleetMetricOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFleetMetricOutputBody = try responseDecoder.decode(responseBody: data)
            self.metricArn = output.metricArn
            self.metricName = output.metricName
        } else {
            self.metricArn = nil
            self.metricName = nil
        }
    }
}

public struct CreateFleetMetricOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new fleet metric.
    public var metricArn: Swift.String?
    /// The name of the fleet metric to create.
    public var metricName: Swift.String?

    public init(
        metricArn: Swift.String? = nil,
        metricName: Swift.String? = nil
    )
    {
        self.metricArn = metricArn
        self.metricName = metricName
    }
}

struct CreateFleetMetricOutputBody: Swift.Equatable {
    let metricName: Swift.String?
    let metricArn: Swift.String?
}

extension CreateFleetMetricOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricArn
        case metricName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricArn)
        metricArn = metricArnDecoded
    }
}

enum CreateFleetMetricOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IndexNotReadyException": return try await IndexNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAggregationException": return try await InvalidAggregationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidQueryException": return try await InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortConfig
        case description
        case destinationPackageVersions
        case document
        case documentParameters
        case documentSource
        case jobExecutionsRetryConfig
        case jobExecutionsRolloutConfig
        case jobTemplateArn
        case namespaceId
        case presignedUrlConfig
        case schedulingConfig
        case tags
        case targetSelection
        case targets
        case timeoutConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortConfig = self.abortConfig {
            try encodeContainer.encode(abortConfig, forKey: .abortConfig)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationPackageVersions = destinationPackageVersions {
            var destinationPackageVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPackageVersions)
            for packageversionarn0 in destinationPackageVersions {
                try destinationPackageVersionsContainer.encode(packageversionarn0)
            }
        }
        if let document = self.document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let documentParameters = documentParameters {
            var documentParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .documentParameters)
            for (dictKey0, parameterMap0) in documentParameters {
                try documentParametersContainer.encode(parameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let documentSource = self.documentSource {
            try encodeContainer.encode(documentSource, forKey: .documentSource)
        }
        if let jobExecutionsRetryConfig = self.jobExecutionsRetryConfig {
            try encodeContainer.encode(jobExecutionsRetryConfig, forKey: .jobExecutionsRetryConfig)
        }
        if let jobExecutionsRolloutConfig = self.jobExecutionsRolloutConfig {
            try encodeContainer.encode(jobExecutionsRolloutConfig, forKey: .jobExecutionsRolloutConfig)
        }
        if let jobTemplateArn = self.jobTemplateArn {
            try encodeContainer.encode(jobTemplateArn, forKey: .jobTemplateArn)
        }
        if let namespaceId = self.namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let presignedUrlConfig = self.presignedUrlConfig {
            try encodeContainer.encode(presignedUrlConfig, forKey: .presignedUrlConfig)
        }
        if let schedulingConfig = self.schedulingConfig {
            try encodeContainer.encode(schedulingConfig, forKey: .schedulingConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetSelection = self.targetSelection {
            try encodeContainer.encode(targetSelection.rawValue, forKey: .targetSelection)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targetarn0 in targets {
                try targetsContainer.encode(targetarn0)
            }
        }
        if let timeoutConfig = self.timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }
}

extension CreateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct CreateJobInput: Swift.Equatable {
    /// Allows you to create the criteria to abort a job.
    public var abortConfig: IoTClientTypes.AbortConfig?
    /// A short text description of the job.
    public var description: Swift.String?
    /// The package version Amazon Resource Names (ARNs) that are installed on the device when the job successfully completes. Note:The following Length Constraints relates to a single string. Up to five strings are allowed.
    public var destinationPackageVersions: [Swift.String]?
    /// The job document. Required if you don't specify a value for documentSource.
    public var document: Swift.String?
    /// Parameters of an Amazon Web Services managed template that you can specify to create the job document. documentParameters can only be used when creating jobs from Amazon Web Services managed templates. This parameter can't be used with custom job templates or to create jobs from them.
    public var documentParameters: [Swift.String:Swift.String]?
    /// An S3 link, or S3 object URL, to the job document. The link is an Amazon S3 object URL and is required if you don't specify a value for document. For example, --document-source https://s3.region-code.amazonaws.com/example-firmware/device-firmware.1.0 For more information, see [Methods for accessing a bucket](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-bucket-intro.html).
    public var documentSource: Swift.String?
    /// Allows you to create the criteria to retry a job.
    public var jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
    /// Allows you to create a staged rollout of the job.
    public var jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
    /// A job identifier which must be unique for your Amazon Web Services account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.
    /// This member is required.
    public var jobId: Swift.String?
    /// The ARN of the job template used to create the job.
    public var jobTemplateArn: Swift.String?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is in public preview.
    public var namespaceId: Swift.String?
    /// Configuration information for pre-signed S3 URLs.
    public var presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
    /// The configuration that allows you to schedule a job for a future date and time in addition to specifying the end behavior for each job execution.
    public var schedulingConfig: IoTClientTypes.SchedulingConfig?
    /// Metadata which can be used to manage the job.
    public var tags: [IoTClientTypes.Tag]?
    /// Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.
    public var targetSelection: IoTClientTypes.TargetSelection?
    /// A list of things and thing groups to which the job should be sent.
    /// This member is required.
    public var targets: [Swift.String]?
    /// Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to TIMED_OUT.
    public var timeoutConfig: IoTClientTypes.TimeoutConfig?

    public init(
        abortConfig: IoTClientTypes.AbortConfig? = nil,
        description: Swift.String? = nil,
        destinationPackageVersions: [Swift.String]? = nil,
        document: Swift.String? = nil,
        documentParameters: [Swift.String:Swift.String]? = nil,
        documentSource: Swift.String? = nil,
        jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig? = nil,
        jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig? = nil,
        jobId: Swift.String? = nil,
        jobTemplateArn: Swift.String? = nil,
        namespaceId: Swift.String? = nil,
        presignedUrlConfig: IoTClientTypes.PresignedUrlConfig? = nil,
        schedulingConfig: IoTClientTypes.SchedulingConfig? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        targetSelection: IoTClientTypes.TargetSelection? = nil,
        targets: [Swift.String]? = nil,
        timeoutConfig: IoTClientTypes.TimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.description = description
        self.destinationPackageVersions = destinationPackageVersions
        self.document = document
        self.documentParameters = documentParameters
        self.documentSource = documentSource
        self.jobExecutionsRetryConfig = jobExecutionsRetryConfig
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.jobId = jobId
        self.jobTemplateArn = jobTemplateArn
        self.namespaceId = namespaceId
        self.presignedUrlConfig = presignedUrlConfig
        self.schedulingConfig = schedulingConfig
        self.tags = tags
        self.targetSelection = targetSelection
        self.targets = targets
        self.timeoutConfig = timeoutConfig
    }
}

struct CreateJobInputBody: Swift.Equatable {
    let targets: [Swift.String]?
    let documentSource: Swift.String?
    let document: Swift.String?
    let description: Swift.String?
    let presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
    let targetSelection: IoTClientTypes.TargetSelection?
    let jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
    let abortConfig: IoTClientTypes.AbortConfig?
    let timeoutConfig: IoTClientTypes.TimeoutConfig?
    let tags: [IoTClientTypes.Tag]?
    let namespaceId: Swift.String?
    let jobTemplateArn: Swift.String?
    let jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
    let documentParameters: [Swift.String:Swift.String]?
    let schedulingConfig: IoTClientTypes.SchedulingConfig?
    let destinationPackageVersions: [Swift.String]?
}

extension CreateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortConfig
        case description
        case destinationPackageVersions
        case document
        case documentParameters
        case documentSource
        case jobExecutionsRetryConfig
        case jobExecutionsRolloutConfig
        case jobTemplateArn
        case namespaceId
        case presignedUrlConfig
        case schedulingConfig
        case tags
        case targetSelection
        case targets
        case timeoutConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let documentSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentSource)
        documentSource = documentSourceDecoded
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let presignedUrlConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.PresignedUrlConfig.self, forKey: .presignedUrlConfig)
        presignedUrlConfig = presignedUrlConfigDecoded
        let targetSelectionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TargetSelection.self, forKey: .targetSelection)
        targetSelection = targetSelectionDecoded
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let jobTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTemplateArn)
        jobTemplateArn = jobTemplateArnDecoded
        let jobExecutionsRetryConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionsRetryConfig.self, forKey: .jobExecutionsRetryConfig)
        jobExecutionsRetryConfig = jobExecutionsRetryConfigDecoded
        let documentParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .documentParameters)
        var documentParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let documentParametersContainer = documentParametersContainer {
            documentParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in documentParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    documentParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        documentParameters = documentParametersDecoded0
        let schedulingConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.SchedulingConfig.self, forKey: .schedulingConfig)
        schedulingConfig = schedulingConfigDecoded
        let destinationPackageVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinationPackageVersions)
        var destinationPackageVersionsDecoded0:[Swift.String]? = nil
        if let destinationPackageVersionsContainer = destinationPackageVersionsContainer {
            destinationPackageVersionsDecoded0 = [Swift.String]()
            for string0 in destinationPackageVersionsContainer {
                if let string0 = string0 {
                    destinationPackageVersionsDecoded0?.append(string0)
                }
            }
        }
        destinationPackageVersions = destinationPackageVersionsDecoded0
    }
}

extension CreateJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.jobArn = output.jobArn
            self.jobId = output.jobId
        } else {
            self.description = nil
            self.jobArn = nil
            self.jobId = nil
        }
    }
}

public struct CreateJobOutput: Swift.Equatable {
    /// The job description.
    public var description: Swift.String?
    /// The job ARN.
    public var jobArn: Swift.String?
    /// The unique identifier you assigned to this job.
    public var jobId: Swift.String?

    public init(
        description: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.description = description
        self.jobArn = jobArn
        self.jobId = jobId
    }
}

struct CreateJobOutputBody: Swift.Equatable {
    let jobArn: Swift.String?
    let jobId: Swift.String?
    let description: Swift.String?
}

extension CreateJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case jobArn
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum CreateJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateJobTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortConfig
        case description
        case destinationPackageVersions
        case document
        case documentSource
        case jobArn
        case jobExecutionsRetryConfig
        case jobExecutionsRolloutConfig
        case maintenanceWindows
        case presignedUrlConfig
        case tags
        case timeoutConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortConfig = self.abortConfig {
            try encodeContainer.encode(abortConfig, forKey: .abortConfig)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationPackageVersions = destinationPackageVersions {
            var destinationPackageVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPackageVersions)
            for packageversionarn0 in destinationPackageVersions {
                try destinationPackageVersionsContainer.encode(packageversionarn0)
            }
        }
        if let document = self.document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let documentSource = self.documentSource {
            try encodeContainer.encode(documentSource, forKey: .documentSource)
        }
        if let jobArn = self.jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobExecutionsRetryConfig = self.jobExecutionsRetryConfig {
            try encodeContainer.encode(jobExecutionsRetryConfig, forKey: .jobExecutionsRetryConfig)
        }
        if let jobExecutionsRolloutConfig = self.jobExecutionsRolloutConfig {
            try encodeContainer.encode(jobExecutionsRolloutConfig, forKey: .jobExecutionsRolloutConfig)
        }
        if let maintenanceWindows = maintenanceWindows {
            var maintenanceWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .maintenanceWindows)
            for maintenancewindow0 in maintenanceWindows {
                try maintenanceWindowsContainer.encode(maintenancewindow0)
            }
        }
        if let presignedUrlConfig = self.presignedUrlConfig {
            try encodeContainer.encode(presignedUrlConfig, forKey: .presignedUrlConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeoutConfig = self.timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }
}

extension CreateJobTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobTemplateId = jobTemplateId else {
            return nil
        }
        return "/job-templates/\(jobTemplateId.urlPercentEncoding())"
    }
}

public struct CreateJobTemplateInput: Swift.Equatable {
    /// The criteria that determine when and how a job abort takes place.
    public var abortConfig: IoTClientTypes.AbortConfig?
    /// A description of the job document.
    /// This member is required.
    public var description: Swift.String?
    /// The package version Amazon Resource Names (ARNs) that are installed on the device when the job successfully completes. Note:The following Length Constraints relates to a single string. Up to five strings are allowed.
    public var destinationPackageVersions: [Swift.String]?
    /// The job document. Required if you don't specify a value for documentSource.
    public var document: Swift.String?
    /// An S3 link, or S3 object URL, to the job document. The link is an Amazon S3 object URL and is required if you don't specify a value for document. For example, --document-source https://s3.region-code.amazonaws.com/example-firmware/device-firmware.1.0 For more information, see [Methods for accessing a bucket](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-bucket-intro.html).
    public var documentSource: Swift.String?
    /// The ARN of the job to use as the basis for the job template.
    public var jobArn: Swift.String?
    /// Allows you to create the criteria to retry a job.
    public var jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
    /// Allows you to create a staged rollout of a job.
    public var jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
    /// A unique identifier for the job template. We recommend using a UUID. Alpha-numeric characters, "-", and "_" are valid for use here.
    /// This member is required.
    public var jobTemplateId: Swift.String?
    /// Allows you to configure an optional maintenance window for the rollout of a job document to all devices in the target group for a job.
    public var maintenanceWindows: [IoTClientTypes.MaintenanceWindow]?
    /// Configuration for pre-signed S3 URLs.
    public var presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
    /// Metadata that can be used to manage the job template.
    public var tags: [IoTClientTypes.Tag]?
    /// Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to TIMED_OUT.
    public var timeoutConfig: IoTClientTypes.TimeoutConfig?

    public init(
        abortConfig: IoTClientTypes.AbortConfig? = nil,
        description: Swift.String? = nil,
        destinationPackageVersions: [Swift.String]? = nil,
        document: Swift.String? = nil,
        documentSource: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig? = nil,
        jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig? = nil,
        jobTemplateId: Swift.String? = nil,
        maintenanceWindows: [IoTClientTypes.MaintenanceWindow]? = nil,
        presignedUrlConfig: IoTClientTypes.PresignedUrlConfig? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        timeoutConfig: IoTClientTypes.TimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.description = description
        self.destinationPackageVersions = destinationPackageVersions
        self.document = document
        self.documentSource = documentSource
        self.jobArn = jobArn
        self.jobExecutionsRetryConfig = jobExecutionsRetryConfig
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.jobTemplateId = jobTemplateId
        self.maintenanceWindows = maintenanceWindows
        self.presignedUrlConfig = presignedUrlConfig
        self.tags = tags
        self.timeoutConfig = timeoutConfig
    }
}

struct CreateJobTemplateInputBody: Swift.Equatable {
    let jobArn: Swift.String?
    let documentSource: Swift.String?
    let document: Swift.String?
    let description: Swift.String?
    let presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
    let jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
    let abortConfig: IoTClientTypes.AbortConfig?
    let timeoutConfig: IoTClientTypes.TimeoutConfig?
    let tags: [IoTClientTypes.Tag]?
    let jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
    let maintenanceWindows: [IoTClientTypes.MaintenanceWindow]?
    let destinationPackageVersions: [Swift.String]?
}

extension CreateJobTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortConfig
        case description
        case destinationPackageVersions
        case document
        case documentSource
        case jobArn
        case jobExecutionsRetryConfig
        case jobExecutionsRolloutConfig
        case maintenanceWindows
        case presignedUrlConfig
        case tags
        case timeoutConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let documentSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentSource)
        documentSource = documentSourceDecoded
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let presignedUrlConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.PresignedUrlConfig.self, forKey: .presignedUrlConfig)
        presignedUrlConfig = presignedUrlConfigDecoded
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let jobExecutionsRetryConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionsRetryConfig.self, forKey: .jobExecutionsRetryConfig)
        jobExecutionsRetryConfig = jobExecutionsRetryConfigDecoded
        let maintenanceWindowsContainer = try containerValues.decodeIfPresent([IoTClientTypes.MaintenanceWindow?].self, forKey: .maintenanceWindows)
        var maintenanceWindowsDecoded0:[IoTClientTypes.MaintenanceWindow]? = nil
        if let maintenanceWindowsContainer = maintenanceWindowsContainer {
            maintenanceWindowsDecoded0 = [IoTClientTypes.MaintenanceWindow]()
            for structure0 in maintenanceWindowsContainer {
                if let structure0 = structure0 {
                    maintenanceWindowsDecoded0?.append(structure0)
                }
            }
        }
        maintenanceWindows = maintenanceWindowsDecoded0
        let destinationPackageVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinationPackageVersions)
        var destinationPackageVersionsDecoded0:[Swift.String]? = nil
        if let destinationPackageVersionsContainer = destinationPackageVersionsContainer {
            destinationPackageVersionsDecoded0 = [Swift.String]()
            for string0 in destinationPackageVersionsContainer {
                if let string0 = string0 {
                    destinationPackageVersionsDecoded0?.append(string0)
                }
            }
        }
        destinationPackageVersions = destinationPackageVersionsDecoded0
    }
}

extension CreateJobTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateJobTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobTemplateArn = output.jobTemplateArn
            self.jobTemplateId = output.jobTemplateId
        } else {
            self.jobTemplateArn = nil
            self.jobTemplateId = nil
        }
    }
}

public struct CreateJobTemplateOutput: Swift.Equatable {
    /// The ARN of the job template.
    public var jobTemplateArn: Swift.String?
    /// The unique identifier of the job template.
    public var jobTemplateId: Swift.String?

    public init(
        jobTemplateArn: Swift.String? = nil,
        jobTemplateId: Swift.String? = nil
    )
    {
        self.jobTemplateArn = jobTemplateArn
        self.jobTemplateId = jobTemplateId
    }
}

struct CreateJobTemplateOutputBody: Swift.Equatable {
    let jobTemplateArn: Swift.String?
    let jobTemplateId: Swift.String?
}

extension CreateJobTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobTemplateArn
        case jobTemplateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTemplateArn)
        jobTemplateArn = jobTemplateArnDecoded
        let jobTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTemplateId)
        jobTemplateId = jobTemplateIdDecoded
    }
}

enum CreateJobTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateKeysAndCertificateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let setAsActive = setAsActive {
                let setAsActiveQueryItem = ClientRuntime.URLQueryItem(name: "setAsActive".urlPercentEncoding(), value: Swift.String(setAsActive).urlPercentEncoding())
                items.append(setAsActiveQueryItem)
            }
            return items
        }
    }
}

extension CreateKeysAndCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/keys-and-certificate"
    }
}

/// The input for the CreateKeysAndCertificate operation. Requires permission to access the [CreateKeysAndCertificateRequest](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions) action.
public struct CreateKeysAndCertificateInput: Swift.Equatable {
    /// Specifies whether the certificate is active.
    public var setAsActive: Swift.Bool?

    public init(
        setAsActive: Swift.Bool? = nil
    )
    {
        self.setAsActive = setAsActive
    }
}

struct CreateKeysAndCertificateInputBody: Swift.Equatable {
}

extension CreateKeysAndCertificateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CreateKeysAndCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKeysAndCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateArn = output.certificateArn
            self.certificateId = output.certificateId
            self.certificatePem = output.certificatePem
            self.keyPair = output.keyPair
        } else {
            self.certificateArn = nil
            self.certificateId = nil
            self.certificatePem = nil
            self.keyPair = nil
        }
    }
}

/// The output of the CreateKeysAndCertificate operation.
public struct CreateKeysAndCertificateOutput: Swift.Equatable {
    /// The ARN of the certificate.
    public var certificateArn: Swift.String?
    /// The ID of the certificate. IoT issues a default subject name for the certificate (for example, IoT Certificate).
    public var certificateId: Swift.String?
    /// The certificate data, in PEM format.
    public var certificatePem: Swift.String?
    /// The generated key pair.
    public var keyPair: IoTClientTypes.KeyPair?

    public init(
        certificateArn: Swift.String? = nil,
        certificateId: Swift.String? = nil,
        certificatePem: Swift.String? = nil,
        keyPair: IoTClientTypes.KeyPair? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
        self.certificatePem = certificatePem
        self.keyPair = keyPair
    }
}

struct CreateKeysAndCertificateOutputBody: Swift.Equatable {
    let certificateArn: Swift.String?
    let certificateId: Swift.String?
    let certificatePem: Swift.String?
    let keyPair: IoTClientTypes.KeyPair?
}

extension CreateKeysAndCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateId
        case certificatePem
        case keyPair
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(IoTClientTypes.KeyPair.self, forKey: .keyPair)
        keyPair = keyPairDecoded
    }
}

enum CreateKeysAndCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMitigationActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionParams
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionParams = self.actionParams {
            try encodeContainer.encode(actionParams, forKey: .actionParams)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMitigationActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let actionName = actionName else {
            return nil
        }
        return "/mitigationactions/actions/\(actionName.urlPercentEncoding())"
    }
}

public struct CreateMitigationActionInput: Swift.Equatable {
    /// A friendly name for the action. Choose a friendly name that accurately describes the action (for example, EnableLoggingAction).
    /// This member is required.
    public var actionName: Swift.String?
    /// Defines the type of action and the parameters for that action.
    /// This member is required.
    public var actionParams: IoTClientTypes.MitigationActionParams?
    /// The ARN of the IAM role that is used to apply the mitigation action.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Metadata that can be used to manage the mitigation action.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        actionName: Swift.String? = nil,
        actionParams: IoTClientTypes.MitigationActionParams? = nil,
        roleArn: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.actionName = actionName
        self.actionParams = actionParams
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateMitigationActionInputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let actionParams: IoTClientTypes.MitigationActionParams?
    let tags: [IoTClientTypes.Tag]?
}

extension CreateMitigationActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionParams
        case roleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let actionParamsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MitigationActionParams.self, forKey: .actionParams)
        actionParams = actionParamsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMitigationActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMitigationActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionArn = output.actionArn
            self.actionId = output.actionId
        } else {
            self.actionArn = nil
            self.actionId = nil
        }
    }
}

public struct CreateMitigationActionOutput: Swift.Equatable {
    /// The ARN for the new mitigation action.
    public var actionArn: Swift.String?
    /// A unique identifier for the new mitigation action.
    public var actionId: Swift.String?

    public init(
        actionArn: Swift.String? = nil,
        actionId: Swift.String? = nil
    )
    {
        self.actionArn = actionArn
        self.actionId = actionId
    }
}

struct CreateMitigationActionOutputBody: Swift.Equatable {
    let actionArn: Swift.String?
    let actionId: Swift.String?
}

extension CreateMitigationActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionArn
        case actionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionArn)
        actionArn = actionArnDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

enum CreateMitigationActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateOTAUpdateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalParameters
        case awsJobAbortConfig
        case awsJobExecutionsRolloutConfig
        case awsJobPresignedUrlConfig
        case awsJobTimeoutConfig
        case description
        case files
        case protocols
        case roleArn
        case tags
        case targetSelection
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalParameters = additionalParameters {
            var additionalParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalParameters)
            for (dictKey0, additionalParameterMap0) in additionalParameters {
                try additionalParametersContainer.encode(additionalParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let awsJobAbortConfig = self.awsJobAbortConfig {
            try encodeContainer.encode(awsJobAbortConfig, forKey: .awsJobAbortConfig)
        }
        if let awsJobExecutionsRolloutConfig = self.awsJobExecutionsRolloutConfig {
            try encodeContainer.encode(awsJobExecutionsRolloutConfig, forKey: .awsJobExecutionsRolloutConfig)
        }
        if let awsJobPresignedUrlConfig = self.awsJobPresignedUrlConfig {
            try encodeContainer.encode(awsJobPresignedUrlConfig, forKey: .awsJobPresignedUrlConfig)
        }
        if let awsJobTimeoutConfig = self.awsJobTimeoutConfig {
            try encodeContainer.encode(awsJobTimeoutConfig, forKey: .awsJobTimeoutConfig)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let files = files {
            var filesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .files)
            for otaupdatefile0 in files {
                try filesContainer.encode(otaupdatefile0)
            }
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocol0 in protocols {
                try protocolsContainer.encode(protocol0.rawValue)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetSelection = self.targetSelection {
            try encodeContainer.encode(targetSelection.rawValue, forKey: .targetSelection)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for target0 in targets {
                try targetsContainer.encode(target0)
            }
        }
    }
}

extension CreateOTAUpdateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let otaUpdateId = otaUpdateId else {
            return nil
        }
        return "/otaUpdates/\(otaUpdateId.urlPercentEncoding())"
    }
}

public struct CreateOTAUpdateInput: Swift.Equatable {
    /// A list of additional OTA update parameters, which are name-value pairs. They won't be sent to devices as a part of the Job document.
    public var additionalParameters: [Swift.String:Swift.String]?
    /// The criteria that determine when and how a job abort takes place.
    public var awsJobAbortConfig: IoTClientTypes.AwsJobAbortConfig?
    /// Configuration for the rollout of OTA updates.
    public var awsJobExecutionsRolloutConfig: IoTClientTypes.AwsJobExecutionsRolloutConfig?
    /// Configuration information for pre-signed URLs.
    public var awsJobPresignedUrlConfig: IoTClientTypes.AwsJobPresignedUrlConfig?
    /// Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to TIMED_OUT.
    public var awsJobTimeoutConfig: IoTClientTypes.AwsJobTimeoutConfig?
    /// The description of the OTA update.
    public var description: Swift.String?
    /// The files to be streamed by the OTA update.
    /// This member is required.
    public var files: [IoTClientTypes.OTAUpdateFile]?
    /// The ID of the OTA update to be created.
    /// This member is required.
    public var otaUpdateId: Swift.String?
    /// The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.
    public var protocols: [IoTClientTypes.ModelProtocol]?
    /// The IAM role that grants Amazon Web Services IoT Core access to the Amazon S3, IoT jobs and Amazon Web Services Code Signing resources to create an OTA update job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Metadata which can be used to manage updates.
    public var tags: [IoTClientTypes.Tag]?
    /// Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.
    public var targetSelection: IoTClientTypes.TargetSelection?
    /// The devices targeted to receive OTA updates.
    /// This member is required.
    public var targets: [Swift.String]?

    public init(
        additionalParameters: [Swift.String:Swift.String]? = nil,
        awsJobAbortConfig: IoTClientTypes.AwsJobAbortConfig? = nil,
        awsJobExecutionsRolloutConfig: IoTClientTypes.AwsJobExecutionsRolloutConfig? = nil,
        awsJobPresignedUrlConfig: IoTClientTypes.AwsJobPresignedUrlConfig? = nil,
        awsJobTimeoutConfig: IoTClientTypes.AwsJobTimeoutConfig? = nil,
        description: Swift.String? = nil,
        files: [IoTClientTypes.OTAUpdateFile]? = nil,
        otaUpdateId: Swift.String? = nil,
        protocols: [IoTClientTypes.ModelProtocol]? = nil,
        roleArn: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        targetSelection: IoTClientTypes.TargetSelection? = nil,
        targets: [Swift.String]? = nil
    )
    {
        self.additionalParameters = additionalParameters
        self.awsJobAbortConfig = awsJobAbortConfig
        self.awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfig
        self.awsJobPresignedUrlConfig = awsJobPresignedUrlConfig
        self.awsJobTimeoutConfig = awsJobTimeoutConfig
        self.description = description
        self.files = files
        self.otaUpdateId = otaUpdateId
        self.protocols = protocols
        self.roleArn = roleArn
        self.tags = tags
        self.targetSelection = targetSelection
        self.targets = targets
    }
}

struct CreateOTAUpdateInputBody: Swift.Equatable {
    let description: Swift.String?
    let targets: [Swift.String]?
    let protocols: [IoTClientTypes.ModelProtocol]?
    let targetSelection: IoTClientTypes.TargetSelection?
    let awsJobExecutionsRolloutConfig: IoTClientTypes.AwsJobExecutionsRolloutConfig?
    let awsJobPresignedUrlConfig: IoTClientTypes.AwsJobPresignedUrlConfig?
    let awsJobAbortConfig: IoTClientTypes.AwsJobAbortConfig?
    let awsJobTimeoutConfig: IoTClientTypes.AwsJobTimeoutConfig?
    let files: [IoTClientTypes.OTAUpdateFile]?
    let roleArn: Swift.String?
    let additionalParameters: [Swift.String:Swift.String]?
    let tags: [IoTClientTypes.Tag]?
}

extension CreateOTAUpdateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalParameters
        case awsJobAbortConfig
        case awsJobExecutionsRolloutConfig
        case awsJobPresignedUrlConfig
        case awsJobTimeoutConfig
        case description
        case files
        case protocols
        case roleArn
        case tags
        case targetSelection
        case targets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let protocolsContainer = try containerValues.decodeIfPresent([IoTClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[IoTClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [IoTClientTypes.ModelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
        let targetSelectionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TargetSelection.self, forKey: .targetSelection)
        targetSelection = targetSelectionDecoded
        let awsJobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AwsJobExecutionsRolloutConfig.self, forKey: .awsJobExecutionsRolloutConfig)
        awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfigDecoded
        let awsJobPresignedUrlConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AwsJobPresignedUrlConfig.self, forKey: .awsJobPresignedUrlConfig)
        awsJobPresignedUrlConfig = awsJobPresignedUrlConfigDecoded
        let awsJobAbortConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AwsJobAbortConfig.self, forKey: .awsJobAbortConfig)
        awsJobAbortConfig = awsJobAbortConfigDecoded
        let awsJobTimeoutConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AwsJobTimeoutConfig.self, forKey: .awsJobTimeoutConfig)
        awsJobTimeoutConfig = awsJobTimeoutConfigDecoded
        let filesContainer = try containerValues.decodeIfPresent([IoTClientTypes.OTAUpdateFile?].self, forKey: .files)
        var filesDecoded0:[IoTClientTypes.OTAUpdateFile]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [IoTClientTypes.OTAUpdateFile]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let additionalParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalParameters)
        var additionalParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalParametersContainer = additionalParametersContainer {
            additionalParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in additionalParametersContainer {
                if let value0 = value0 {
                    additionalParametersDecoded0?[key0] = value0
                }
            }
        }
        additionalParameters = additionalParametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateOTAUpdateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateOTAUpdateOutputBody = try responseDecoder.decode(responseBody: data)
            self.awsIotJobArn = output.awsIotJobArn
            self.awsIotJobId = output.awsIotJobId
            self.otaUpdateArn = output.otaUpdateArn
            self.otaUpdateId = output.otaUpdateId
            self.otaUpdateStatus = output.otaUpdateStatus
        } else {
            self.awsIotJobArn = nil
            self.awsIotJobId = nil
            self.otaUpdateArn = nil
            self.otaUpdateId = nil
            self.otaUpdateStatus = nil
        }
    }
}

public struct CreateOTAUpdateOutput: Swift.Equatable {
    /// The IoT job ARN associated with the OTA update.
    public var awsIotJobArn: Swift.String?
    /// The IoT job ID associated with the OTA update.
    public var awsIotJobId: Swift.String?
    /// The OTA update ARN.
    public var otaUpdateArn: Swift.String?
    /// The OTA update ID.
    public var otaUpdateId: Swift.String?
    /// The OTA update status.
    public var otaUpdateStatus: IoTClientTypes.OTAUpdateStatus?

    public init(
        awsIotJobArn: Swift.String? = nil,
        awsIotJobId: Swift.String? = nil,
        otaUpdateArn: Swift.String? = nil,
        otaUpdateId: Swift.String? = nil,
        otaUpdateStatus: IoTClientTypes.OTAUpdateStatus? = nil
    )
    {
        self.awsIotJobArn = awsIotJobArn
        self.awsIotJobId = awsIotJobId
        self.otaUpdateArn = otaUpdateArn
        self.otaUpdateId = otaUpdateId
        self.otaUpdateStatus = otaUpdateStatus
    }
}

struct CreateOTAUpdateOutputBody: Swift.Equatable {
    let otaUpdateId: Swift.String?
    let awsIotJobId: Swift.String?
    let otaUpdateArn: Swift.String?
    let awsIotJobArn: Swift.String?
    let otaUpdateStatus: IoTClientTypes.OTAUpdateStatus?
}

extension CreateOTAUpdateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsIotJobArn
        case awsIotJobId
        case otaUpdateArn
        case otaUpdateId
        case otaUpdateStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otaUpdateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .otaUpdateId)
        otaUpdateId = otaUpdateIdDecoded
        let awsIotJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsIotJobId)
        awsIotJobId = awsIotJobIdDecoded
        let otaUpdateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .otaUpdateArn)
        otaUpdateArn = otaUpdateArnDecoded
        let awsIotJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsIotJobArn)
        awsIotJobArn = awsIotJobArnDecoded
        let otaUpdateStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.OTAUpdateStatus.self, forKey: .otaUpdateStatus)
        otaUpdateStatus = otaUpdateStatusDecoded
    }
}

enum CreateOTAUpdateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePackageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePackageInput(clientToken: \(Swift.String(describing: clientToken)), packageName: \(Swift.String(describing: packageName)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

extension CreatePackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePackageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension CreatePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageName = packageName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())"
    }
}

public struct CreatePackageInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A summary of the package being created. This can be used to outline the package's contents or purpose.
    public var description: Swift.String?
    /// The name of the new software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// Metadata that can be used to manage the package.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        packageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.packageName = packageName
        self.tags = tags
    }
}

struct CreatePackageInputBody: Swift.Equatable {
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePackageOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePackageOutput(packageArn: \(Swift.String(describing: packageArn)), packageName: \(Swift.String(describing: packageName)), description: \"CONTENT_REDACTED\")"}
}

extension CreatePackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePackageOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.packageArn = output.packageArn
            self.packageName = output.packageName
        } else {
            self.description = nil
            self.packageArn = nil
            self.packageName = nil
        }
    }
}

public struct CreatePackageOutput: Swift.Equatable {
    /// The package description.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) for the package.
    public var packageArn: Swift.String?
    /// The name of the software package.
    public var packageName: Swift.String?

    public init(
        description: Swift.String? = nil,
        packageArn: Swift.String? = nil,
        packageName: Swift.String? = nil
    )
    {
        self.description = description
        self.packageArn = packageArn
        self.packageName = packageName
    }
}

struct CreatePackageOutputBody: Swift.Equatable {
    let packageName: Swift.String?
    let packageArn: Swift.String?
    let description: Swift.String?
}

extension CreatePackageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case packageArn
        case packageName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageArn)
        packageArn = packageArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum CreatePackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePackageVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePackageVersionInput(clientToken: \(Swift.String(describing: clientToken)), packageName: \(Swift.String(describing: packageName)), tags: \(Swift.String(describing: tags)), versionName: \(Swift.String(describing: versionName)), attributes: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

extension CreatePackageVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case description
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, resourceAttributes0) in attributes {
                try attributesContainer.encode(resourceAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePackageVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension CreatePackageVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageName = packageName else {
            return nil
        }
        guard let versionName = versionName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())/versions/\(versionName.urlPercentEncoding())"
    }
}

public struct CreatePackageVersionInput: Swift.Equatable {
    /// Metadata that can be used to define a package versions configuration. For example, the S3 file location, configuration options that are being sent to the device or fleet. The combined size of all the attributes on a package version is limited to 3KB.
    public var attributes: [Swift.String:Swift.String]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A summary of the package version being created. This can be used to outline the package's contents or purpose.
    public var description: Swift.String?
    /// The name of the associated software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// Metadata that can be used to manage the package version.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the new package version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        packageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.clientToken = clientToken
        self.description = description
        self.packageName = packageName
        self.tags = tags
        self.versionName = versionName
    }
}

struct CreatePackageVersionInputBody: Swift.Equatable {
    let description: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePackageVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case description
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, resourceattributevalue0) in attributesContainer {
                if let resourceattributevalue0 = resourceattributevalue0 {
                    attributesDecoded0?[key0] = resourceattributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePackageVersionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePackageVersionOutput(errorReason: \(Swift.String(describing: errorReason)), packageName: \(Swift.String(describing: packageName)), packageVersionArn: \(Swift.String(describing: packageVersionArn)), status: \(Swift.String(describing: status)), versionName: \(Swift.String(describing: versionName)), attributes: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

extension CreatePackageVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePackageVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
            self.description = output.description
            self.errorReason = output.errorReason
            self.packageName = output.packageName
            self.packageVersionArn = output.packageVersionArn
            self.status = output.status
            self.versionName = output.versionName
        } else {
            self.attributes = nil
            self.description = nil
            self.errorReason = nil
            self.packageName = nil
            self.packageVersionArn = nil
            self.status = nil
            self.versionName = nil
        }
    }
}

public struct CreatePackageVersionOutput: Swift.Equatable {
    /// Metadata that were added to the package version that can be used to define a package versions configuration.
    public var attributes: [Swift.String:Swift.String]?
    /// The package version description.
    public var description: Swift.String?
    /// Error reason for a package version failure during creation or update.
    public var errorReason: Swift.String?
    /// The name of the associated software package.
    public var packageName: Swift.String?
    /// The Amazon Resource Name (ARN) for the package.
    public var packageVersionArn: Swift.String?
    /// The status of the package version. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle).
    public var status: IoTClientTypes.PackageVersionStatus?
    /// The name of the new package version.
    public var versionName: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        description: Swift.String? = nil,
        errorReason: Swift.String? = nil,
        packageName: Swift.String? = nil,
        packageVersionArn: Swift.String? = nil,
        status: IoTClientTypes.PackageVersionStatus? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.description = description
        self.errorReason = errorReason
        self.packageName = packageName
        self.packageVersionArn = packageVersionArn
        self.status = status
        self.versionName = versionName
    }
}

struct CreatePackageVersionOutputBody: Swift.Equatable {
    let packageVersionArn: Swift.String?
    let packageName: Swift.String?
    let versionName: Swift.String?
    let description: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let status: IoTClientTypes.PackageVersionStatus?
    let errorReason: Swift.String?
}

extension CreatePackageVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case description
        case errorReason
        case packageName
        case packageVersionArn
        case status
        case versionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersionArn)
        packageVersionArn = packageVersionArnDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, resourceattributevalue0) in attributesContainer {
                if let resourceattributevalue0 = resourceattributevalue0 {
                    attributesDecoded0?[key0] = resourceattributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
        let errorReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorReason)
        errorReason = errorReasonDecoded
    }
}

enum CreatePackageVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyDocument = self.policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let policyName = policyName else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())"
    }
}

/// The input for the CreatePolicy operation.
public struct CreatePolicyInput: Swift.Equatable {
    /// The JSON document that describes the policy. policyDocument must have a minimum length of 1, with a maximum length of 2048, excluding whitespace.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?
    /// Metadata which can be used to manage the policy. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: [IoTClientTypes.Tag]?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.tags = tags
    }
}

struct CreatePolicyInputBody: Swift.Equatable {
    let policyDocument: Swift.String?
    let tags: [IoTClientTypes.Tag]?
}

extension CreatePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyArn = output.policyArn
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
            self.policyVersionId = output.policyVersionId
        } else {
            self.policyArn = nil
            self.policyDocument = nil
            self.policyName = nil
            self.policyVersionId = nil
        }
    }
}

/// The output from the CreatePolicy operation.
public struct CreatePolicyOutput: Swift.Equatable {
    /// The policy ARN.
    public var policyArn: Swift.String?
    /// The JSON document that describes the policy.
    public var policyDocument: Swift.String?
    /// The policy name.
    public var policyName: Swift.String?
    /// The policy version ID.
    public var policyVersionId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        policyVersionId: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

struct CreatePolicyOutputBody: Swift.Equatable {
    let policyName: Swift.String?
    let policyArn: Swift.String?
    let policyDocument: Swift.String?
    let policyVersionId: Swift.String?
}

extension CreatePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn
        case policyDocument
        case policyName
        case policyVersionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let policyVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersionId)
        policyVersionId = policyVersionIdDecoded
    }
}

enum CreatePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MalformedPolicyException": return try await MalformedPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePolicyVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyDocument = self.policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
    }
}

extension CreatePolicyVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let setAsDefault = setAsDefault {
                let setAsDefaultQueryItem = ClientRuntime.URLQueryItem(name: "setAsDefault".urlPercentEncoding(), value: Swift.String(setAsDefault).urlPercentEncoding())
                items.append(setAsDefaultQueryItem)
            }
            return items
        }
    }
}

extension CreatePolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let policyName = policyName else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())/version"
    }
}

/// The input for the CreatePolicyVersion operation.
public struct CreatePolicyVersionInput: Swift.Equatable {
    /// The JSON document that describes the policy. Minimum length of 1. Maximum length of 2048, excluding whitespace.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?
    /// Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
    public var setAsDefault: Swift.Bool?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        setAsDefault: Swift.Bool? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.setAsDefault = setAsDefault
    }
}

struct CreatePolicyVersionInputBody: Swift.Equatable {
    let policyDocument: Swift.String?
}

extension CreatePolicyVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension CreatePolicyVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePolicyVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.isDefaultVersion = output.isDefaultVersion
            self.policyArn = output.policyArn
            self.policyDocument = output.policyDocument
            self.policyVersionId = output.policyVersionId
        } else {
            self.isDefaultVersion = false
            self.policyArn = nil
            self.policyDocument = nil
            self.policyVersionId = nil
        }
    }
}

/// The output of the CreatePolicyVersion operation.
public struct CreatePolicyVersionOutput: Swift.Equatable {
    /// Specifies whether the policy version is the default.
    public var isDefaultVersion: Swift.Bool
    /// The policy ARN.
    public var policyArn: Swift.String?
    /// The JSON document that describes the policy.
    public var policyDocument: Swift.String?
    /// The policy version ID.
    public var policyVersionId: Swift.String?

    public init(
        isDefaultVersion: Swift.Bool = false,
        policyArn: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyVersionId: Swift.String? = nil
    )
    {
        self.isDefaultVersion = isDefaultVersion
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.policyVersionId = policyVersionId
    }
}

struct CreatePolicyVersionOutputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let policyDocument: Swift.String?
    let policyVersionId: Swift.String?
    let isDefaultVersion: Swift.Bool
}

extension CreatePolicyVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isDefaultVersion
        case policyArn
        case policyDocument
        case policyVersionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let policyVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersionId)
        policyVersionId = policyVersionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefaultVersion) ?? false
        isDefaultVersion = isDefaultVersionDecoded
    }
}

enum CreatePolicyVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MalformedPolicyException": return try await MalformedPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionsLimitExceededException": return try await VersionsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProvisioningClaimInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let templateName = templateName else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())/provisioning-claim"
    }
}

public struct CreateProvisioningClaimInput: Swift.Equatable {
    /// The name of the provisioning template to use.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        templateName: Swift.String? = nil
    )
    {
        self.templateName = templateName
    }
}

struct CreateProvisioningClaimInputBody: Swift.Equatable {
}

extension CreateProvisioningClaimInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CreateProvisioningClaimOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProvisioningClaimOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateId = output.certificateId
            self.certificatePem = output.certificatePem
            self.expiration = output.expiration
            self.keyPair = output.keyPair
        } else {
            self.certificateId = nil
            self.certificatePem = nil
            self.expiration = nil
            self.keyPair = nil
        }
    }
}

public struct CreateProvisioningClaimOutput: Swift.Equatable {
    /// The ID of the certificate.
    public var certificateId: Swift.String?
    /// The provisioning claim certificate.
    public var certificatePem: Swift.String?
    /// The provisioning claim expiration time.
    public var expiration: ClientRuntime.Date?
    /// The provisioning claim key pair.
    public var keyPair: IoTClientTypes.KeyPair?

    public init(
        certificateId: Swift.String? = nil,
        certificatePem: Swift.String? = nil,
        expiration: ClientRuntime.Date? = nil,
        keyPair: IoTClientTypes.KeyPair? = nil
    )
    {
        self.certificateId = certificateId
        self.certificatePem = certificatePem
        self.expiration = expiration
        self.keyPair = keyPair
    }
}

struct CreateProvisioningClaimOutputBody: Swift.Equatable {
    let certificateId: Swift.String?
    let certificatePem: Swift.String?
    let keyPair: IoTClientTypes.KeyPair?
    let expiration: ClientRuntime.Date?
}

extension CreateProvisioningClaimOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateId
        case certificatePem
        case expiration
        case keyPair
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(IoTClientTypes.KeyPair.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let expirationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiration)
        expiration = expirationDecoded
    }
}

enum CreateProvisioningClaimOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProvisioningTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case enabled
        case preProvisioningHook
        case provisioningRoleArn
        case tags
        case templateBody
        case templateName
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let preProvisioningHook = self.preProvisioningHook {
            try encodeContainer.encode(preProvisioningHook, forKey: .preProvisioningHook)
        }
        if let provisioningRoleArn = self.provisioningRoleArn {
            try encodeContainer.encode(provisioningRoleArn, forKey: .provisioningRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let templateBody = self.templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateProvisioningTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/provisioning-templates"
    }
}

public struct CreateProvisioningTemplateInput: Swift.Equatable {
    /// The description of the provisioning template.
    public var description: Swift.String?
    /// True to enable the provisioning template, otherwise false.
    public var enabled: Swift.Bool?
    /// Creates a pre-provisioning hook template. Only supports template of type FLEET_PROVISIONING. For more information about provisioning template types, see [type](https://docs.aws.amazon.com/iot/latest/apireference/API_CreateProvisioningTemplate.html#iot-CreateProvisioningTemplate-request-type).
    public var preProvisioningHook: IoTClientTypes.ProvisioningHook?
    /// The role ARN for the role associated with the provisioning template. This IoT role grants permission to provision a device.
    /// This member is required.
    public var provisioningRoleArn: Swift.String?
    /// Metadata which can be used to manage the provisioning template. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: [IoTClientTypes.Tag]?
    /// The JSON formatted contents of the provisioning template.
    /// This member is required.
    public var templateBody: Swift.String?
    /// The name of the provisioning template.
    /// This member is required.
    public var templateName: Swift.String?
    /// The type you define in a provisioning template. You can create a template with only one type. You can't change the template type after its creation. The default value is FLEET_PROVISIONING. For more information about provisioning template, see: [Provisioning template](https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html).
    public var type: IoTClientTypes.TemplateType?

    public init(
        description: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        preProvisioningHook: IoTClientTypes.ProvisioningHook? = nil,
        provisioningRoleArn: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        templateBody: Swift.String? = nil,
        templateName: Swift.String? = nil,
        type: IoTClientTypes.TemplateType? = nil
    )
    {
        self.description = description
        self.enabled = enabled
        self.preProvisioningHook = preProvisioningHook
        self.provisioningRoleArn = provisioningRoleArn
        self.tags = tags
        self.templateBody = templateBody
        self.templateName = templateName
        self.type = type
    }
}

struct CreateProvisioningTemplateInputBody: Swift.Equatable {
    let templateName: Swift.String?
    let description: Swift.String?
    let templateBody: Swift.String?
    let enabled: Swift.Bool?
    let provisioningRoleArn: Swift.String?
    let preProvisioningHook: IoTClientTypes.ProvisioningHook?
    let tags: [IoTClientTypes.Tag]?
    let type: IoTClientTypes.TemplateType?
}

extension CreateProvisioningTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case enabled
        case preProvisioningHook
        case provisioningRoleArn
        case tags
        case templateBody
        case templateName
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let provisioningRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningRoleArn)
        provisioningRoleArn = provisioningRoleArnDecoded
        let preProvisioningHookDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ProvisioningHook.self, forKey: .preProvisioningHook)
        preProvisioningHook = preProvisioningHookDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TemplateType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateProvisioningTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProvisioningTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.defaultVersionId = output.defaultVersionId
            self.templateArn = output.templateArn
            self.templateName = output.templateName
        } else {
            self.defaultVersionId = nil
            self.templateArn = nil
            self.templateName = nil
        }
    }
}

public struct CreateProvisioningTemplateOutput: Swift.Equatable {
    /// The default version of the provisioning template.
    public var defaultVersionId: Swift.Int?
    /// The ARN that identifies the provisioning template.
    public var templateArn: Swift.String?
    /// The name of the provisioning template.
    public var templateName: Swift.String?

    public init(
        defaultVersionId: Swift.Int? = nil,
        templateArn: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.defaultVersionId = defaultVersionId
        self.templateArn = templateArn
        self.templateName = templateName
    }
}

struct CreateProvisioningTemplateOutputBody: Swift.Equatable {
    let templateArn: Swift.String?
    let templateName: Swift.String?
    let defaultVersionId: Swift.Int?
}

extension CreateProvisioningTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultVersionId
        case templateArn
        case templateName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
    }
}

enum CreateProvisioningTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProvisioningTemplateVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateBody
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateBody = self.templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
    }
}

extension CreateProvisioningTemplateVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let setAsDefault = setAsDefault {
                let setAsDefaultQueryItem = ClientRuntime.URLQueryItem(name: "setAsDefault".urlPercentEncoding(), value: Swift.String(setAsDefault).urlPercentEncoding())
                items.append(setAsDefaultQueryItem)
            }
            return items
        }
    }
}

extension CreateProvisioningTemplateVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let templateName = templateName else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())/versions"
    }
}

public struct CreateProvisioningTemplateVersionInput: Swift.Equatable {
    /// Sets a fleet provision template version as the default version.
    public var setAsDefault: Swift.Bool?
    /// The JSON formatted contents of the provisioning template.
    /// This member is required.
    public var templateBody: Swift.String?
    /// The name of the provisioning template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        setAsDefault: Swift.Bool? = nil,
        templateBody: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.setAsDefault = setAsDefault
        self.templateBody = templateBody
        self.templateName = templateName
    }
}

struct CreateProvisioningTemplateVersionInputBody: Swift.Equatable {
    let templateBody: Swift.String?
}

extension CreateProvisioningTemplateVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateBody
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
    }
}

extension CreateProvisioningTemplateVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProvisioningTemplateVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.isDefaultVersion = output.isDefaultVersion
            self.templateArn = output.templateArn
            self.templateName = output.templateName
            self.versionId = output.versionId
        } else {
            self.isDefaultVersion = false
            self.templateArn = nil
            self.templateName = nil
            self.versionId = nil
        }
    }
}

public struct CreateProvisioningTemplateVersionOutput: Swift.Equatable {
    /// True if the provisioning template version is the default version, otherwise false.
    public var isDefaultVersion: Swift.Bool
    /// The ARN that identifies the provisioning template.
    public var templateArn: Swift.String?
    /// The name of the provisioning template.
    public var templateName: Swift.String?
    /// The version of the provisioning template.
    public var versionId: Swift.Int?

    public init(
        isDefaultVersion: Swift.Bool = false,
        templateArn: Swift.String? = nil,
        templateName: Swift.String? = nil,
        versionId: Swift.Int? = nil
    )
    {
        self.isDefaultVersion = isDefaultVersion
        self.templateArn = templateArn
        self.templateName = templateName
        self.versionId = versionId
    }
}

struct CreateProvisioningTemplateVersionOutputBody: Swift.Equatable {
    let templateArn: Swift.String?
    let templateName: Swift.String?
    let versionId: Swift.Int?
    let isDefaultVersion: Swift.Bool
}

extension CreateProvisioningTemplateVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isDefaultVersion
        case templateArn
        case templateName
        case versionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefaultVersion) ?? false
        isDefaultVersion = isDefaultVersionDecoded
    }
}

enum CreateProvisioningTemplateVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionsLimitExceededException": return try await VersionsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRoleAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentialDurationSeconds
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentialDurationSeconds = self.credentialDurationSeconds {
            try encodeContainer.encode(credentialDurationSeconds, forKey: .credentialDurationSeconds)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateRoleAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let roleAlias = roleAlias else {
            return nil
        }
        return "/role-aliases/\(roleAlias.urlPercentEncoding())"
    }
}

public struct CreateRoleAliasInput: Swift.Equatable {
    /// How long (in seconds) the credentials will be valid. The default value is 3,600 seconds. This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.
    public var credentialDurationSeconds: Swift.Int?
    /// The role alias that points to a role ARN. This allows you to change the role without having to update the device.
    /// This member is required.
    public var roleAlias: Swift.String?
    /// The role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Metadata which can be used to manage the role alias. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: [IoTClientTypes.Tag]?

    public init(
        credentialDurationSeconds: Swift.Int? = nil,
        roleAlias: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.credentialDurationSeconds = credentialDurationSeconds
        self.roleAlias = roleAlias
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateRoleAliasInputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let credentialDurationSeconds: Swift.Int?
    let tags: [IoTClientTypes.Tag]?
}

extension CreateRoleAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentialDurationSeconds
        case roleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let credentialDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .credentialDurationSeconds)
        credentialDurationSeconds = credentialDurationSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRoleAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRoleAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.roleAlias = output.roleAlias
            self.roleAliasArn = output.roleAliasArn
        } else {
            self.roleAlias = nil
            self.roleAliasArn = nil
        }
    }
}

public struct CreateRoleAliasOutput: Swift.Equatable {
    /// The role alias.
    public var roleAlias: Swift.String?
    /// The role alias ARN.
    public var roleAliasArn: Swift.String?

    public init(
        roleAlias: Swift.String? = nil,
        roleAliasArn: Swift.String? = nil
    )
    {
        self.roleAlias = roleAlias
        self.roleAliasArn = roleAliasArn
    }
}

struct CreateRoleAliasOutputBody: Swift.Equatable {
    let roleAlias: Swift.String?
    let roleAliasArn: Swift.String?
}

extension CreateRoleAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleAlias
        case roleAliasArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleAlias)
        roleAlias = roleAliasDecoded
        let roleAliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleAliasArn)
        roleAliasArn = roleAliasArnDecoded
    }
}

enum CreateRoleAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateScheduledAuditInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth
        case dayOfWeek
        case frequency
        case tags
        case targetCheckNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = self.dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = self.dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetCheckNames = targetCheckNames {
            var targetCheckNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetCheckNames)
            for auditcheckname0 in targetCheckNames {
                try targetCheckNamesContainer.encode(auditcheckname0)
            }
        }
    }
}

extension CreateScheduledAuditInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let scheduledAuditName = scheduledAuditName else {
            return nil
        }
        return "/audit/scheduledaudits/\(scheduledAuditName.urlPercentEncoding())"
    }
}

public struct CreateScheduledAuditInput: Swift.Equatable {
    /// The day of the month on which the scheduled audit takes place. This can be "1" through "31" or "LAST". This field is required if the "frequency" parameter is set to MONTHLY. If days 29 to 31 are specified, and the month doesn't have that many days, the audit takes place on the LAST day of the month.
    public var dayOfMonth: Swift.String?
    /// The day of the week on which the scheduled audit takes place, either SUN, MON, TUE, WED, THU, FRI, or SAT. This field is required if the frequency parameter is set to WEEKLY or BIWEEKLY.
    public var dayOfWeek: IoTClientTypes.DayOfWeek?
    /// How often the scheduled audit takes place, either DAILY, WEEKLY, BIWEEKLY or MONTHLY. The start time of each audit is determined by the system.
    /// This member is required.
    public var frequency: IoTClientTypes.AuditFrequency?
    /// The name you want to give to the scheduled audit. (Max. 128 chars)
    /// This member is required.
    public var scheduledAuditName: Swift.String?
    /// Metadata that can be used to manage the scheduled audit.
    public var tags: [IoTClientTypes.Tag]?
    /// Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    /// This member is required.
    public var targetCheckNames: [Swift.String]?

    public init(
        dayOfMonth: Swift.String? = nil,
        dayOfWeek: IoTClientTypes.DayOfWeek? = nil,
        frequency: IoTClientTypes.AuditFrequency? = nil,
        scheduledAuditName: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        targetCheckNames: [Swift.String]? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.frequency = frequency
        self.scheduledAuditName = scheduledAuditName
        self.tags = tags
        self.targetCheckNames = targetCheckNames
    }
}

struct CreateScheduledAuditInputBody: Swift.Equatable {
    let frequency: IoTClientTypes.AuditFrequency?
    let dayOfMonth: Swift.String?
    let dayOfWeek: IoTClientTypes.DayOfWeek?
    let targetCheckNames: [Swift.String]?
    let tags: [IoTClientTypes.Tag]?
}

extension CreateScheduledAuditInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth
        case dayOfWeek
        case frequency
        case tags
        case targetCheckNames
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frequencyDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let targetCheckNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetCheckNames)
        var targetCheckNamesDecoded0:[Swift.String]? = nil
        if let targetCheckNamesContainer = targetCheckNamesContainer {
            targetCheckNamesDecoded0 = [Swift.String]()
            for string0 in targetCheckNamesContainer {
                if let string0 = string0 {
                    targetCheckNamesDecoded0?.append(string0)
                }
            }
        }
        targetCheckNames = targetCheckNamesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateScheduledAuditOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateScheduledAuditOutputBody = try responseDecoder.decode(responseBody: data)
            self.scheduledAuditArn = output.scheduledAuditArn
        } else {
            self.scheduledAuditArn = nil
        }
    }
}

public struct CreateScheduledAuditOutput: Swift.Equatable {
    /// The ARN of the scheduled audit.
    public var scheduledAuditArn: Swift.String?

    public init(
        scheduledAuditArn: Swift.String? = nil
    )
    {
        self.scheduledAuditArn = scheduledAuditArn
    }
}

struct CreateScheduledAuditOutputBody: Swift.Equatable {
    let scheduledAuditArn: Swift.String?
}

extension CreateScheduledAuditOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledAuditArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledAuditArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledAuditArn)
        scheduledAuditArn = scheduledAuditArnDecoded
    }
}

enum CreateScheduledAuditOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSecurityProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetricsToRetain
        case additionalMetricsToRetainV2
        case alertTargets
        case behaviors
        case securityProfileDescription
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetricsToRetain = additionalMetricsToRetain {
            var additionalMetricsToRetainContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalMetricsToRetain)
            for behaviormetric0 in additionalMetricsToRetain {
                try additionalMetricsToRetainContainer.encode(behaviormetric0)
            }
        }
        if let additionalMetricsToRetainV2 = additionalMetricsToRetainV2 {
            var additionalMetricsToRetainV2Container = encodeContainer.nestedUnkeyedContainer(forKey: .additionalMetricsToRetainV2)
            for metrictoretain0 in additionalMetricsToRetainV2 {
                try additionalMetricsToRetainV2Container.encode(metrictoretain0)
            }
        }
        if let alertTargets = alertTargets {
            var alertTargetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .alertTargets)
            for (dictKey0, alertTargets0) in alertTargets {
                try alertTargetsContainer.encode(alertTargets0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let behaviors = behaviors {
            var behaviorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .behaviors)
            for behavior0 in behaviors {
                try behaviorsContainer.encode(behavior0)
            }
        }
        if let securityProfileDescription = self.securityProfileDescription {
            try encodeContainer.encode(securityProfileDescription, forKey: .securityProfileDescription)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let securityProfileName = securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())"
    }
}

public struct CreateSecurityProfileInput: Swift.Equatable {
    /// Please use [CreateSecurityProfileRequest$additionalMetricsToRetainV2] instead. A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.
    @available(*, deprecated, message: "Use additionalMetricsToRetainV2.")
    public var additionalMetricsToRetain: [Swift.String]?
    /// A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.
    public var additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]?
    /// Specifies the destinations to which alerts are sent. (Alerts are always sent to the console.) Alerts are generated when a device (thing) violates a behavior.
    public var alertTargets: [Swift.String:IoTClientTypes.AlertTarget]?
    /// Specifies the behaviors that, when violated by a device (thing), cause an alert.
    public var behaviors: [IoTClientTypes.Behavior]?
    /// A description of the security profile.
    public var securityProfileDescription: Swift.String?
    /// The name you are giving to the security profile.
    /// This member is required.
    public var securityProfileName: Swift.String?
    /// Metadata that can be used to manage the security profile.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        additionalMetricsToRetain: [Swift.String]? = nil,
        additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]? = nil,
        alertTargets: [Swift.String:IoTClientTypes.AlertTarget]? = nil,
        behaviors: [IoTClientTypes.Behavior]? = nil,
        securityProfileDescription: Swift.String? = nil,
        securityProfileName: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.additionalMetricsToRetain = additionalMetricsToRetain
        self.additionalMetricsToRetainV2 = additionalMetricsToRetainV2
        self.alertTargets = alertTargets
        self.behaviors = behaviors
        self.securityProfileDescription = securityProfileDescription
        self.securityProfileName = securityProfileName
        self.tags = tags
    }
}

struct CreateSecurityProfileInputBody: Swift.Equatable {
    let securityProfileDescription: Swift.String?
    let behaviors: [IoTClientTypes.Behavior]?
    let alertTargets: [Swift.String:IoTClientTypes.AlertTarget]?
    let additionalMetricsToRetain: [Swift.String]?
    let additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]?
    let tags: [IoTClientTypes.Tag]?
}

extension CreateSecurityProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetricsToRetain
        case additionalMetricsToRetainV2
        case alertTargets
        case behaviors
        case securityProfileDescription
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileDescription)
        securityProfileDescription = securityProfileDescriptionDecoded
        let behaviorsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Behavior?].self, forKey: .behaviors)
        var behaviorsDecoded0:[IoTClientTypes.Behavior]? = nil
        if let behaviorsContainer = behaviorsContainer {
            behaviorsDecoded0 = [IoTClientTypes.Behavior]()
            for structure0 in behaviorsContainer {
                if let structure0 = structure0 {
                    behaviorsDecoded0?.append(structure0)
                }
            }
        }
        behaviors = behaviorsDecoded0
        let alertTargetsContainer = try containerValues.decodeIfPresent([Swift.String: IoTClientTypes.AlertTarget?].self, forKey: .alertTargets)
        var alertTargetsDecoded0: [Swift.String:IoTClientTypes.AlertTarget]? = nil
        if let alertTargetsContainer = alertTargetsContainer {
            alertTargetsDecoded0 = [Swift.String:IoTClientTypes.AlertTarget]()
            for (key0, alerttarget0) in alertTargetsContainer {
                if let alerttarget0 = alerttarget0 {
                    alertTargetsDecoded0?[key0] = alerttarget0
                }
            }
        }
        alertTargets = alertTargetsDecoded0
        let additionalMetricsToRetainContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .additionalMetricsToRetain)
        var additionalMetricsToRetainDecoded0:[Swift.String]? = nil
        if let additionalMetricsToRetainContainer = additionalMetricsToRetainContainer {
            additionalMetricsToRetainDecoded0 = [Swift.String]()
            for string0 in additionalMetricsToRetainContainer {
                if let string0 = string0 {
                    additionalMetricsToRetainDecoded0?.append(string0)
                }
            }
        }
        additionalMetricsToRetain = additionalMetricsToRetainDecoded0
        let additionalMetricsToRetainV2Container = try containerValues.decodeIfPresent([IoTClientTypes.MetricToRetain?].self, forKey: .additionalMetricsToRetainV2)
        var additionalMetricsToRetainV2Decoded0:[IoTClientTypes.MetricToRetain]? = nil
        if let additionalMetricsToRetainV2Container = additionalMetricsToRetainV2Container {
            additionalMetricsToRetainV2Decoded0 = [IoTClientTypes.MetricToRetain]()
            for structure0 in additionalMetricsToRetainV2Container {
                if let structure0 = structure0 {
                    additionalMetricsToRetainV2Decoded0?.append(structure0)
                }
            }
        }
        additionalMetricsToRetainV2 = additionalMetricsToRetainV2Decoded0
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSecurityProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSecurityProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.securityProfileArn = output.securityProfileArn
            self.securityProfileName = output.securityProfileName
        } else {
            self.securityProfileArn = nil
            self.securityProfileName = nil
        }
    }
}

public struct CreateSecurityProfileOutput: Swift.Equatable {
    /// The ARN of the security profile.
    public var securityProfileArn: Swift.String?
    /// The name you gave to the security profile.
    public var securityProfileName: Swift.String?

    public init(
        securityProfileArn: Swift.String? = nil,
        securityProfileName: Swift.String? = nil
    )
    {
        self.securityProfileArn = securityProfileArn
        self.securityProfileName = securityProfileName
    }
}

struct CreateSecurityProfileOutputBody: Swift.Equatable {
    let securityProfileName: Swift.String?
    let securityProfileArn: Swift.String?
}

extension CreateSecurityProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityProfileArn
        case securityProfileName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let securityProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileArn)
        securityProfileArn = securityProfileArnDecoded
    }
}

enum CreateSecurityProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case files
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let files = files {
            var filesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .files)
            for streamfile0 in files {
                try filesContainer.encode(streamfile0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let streamId = streamId else {
            return nil
        }
        return "/streams/\(streamId.urlPercentEncoding())"
    }
}

public struct CreateStreamInput: Swift.Equatable {
    /// A description of the stream.
    public var description: Swift.String?
    /// The files to stream.
    /// This member is required.
    public var files: [IoTClientTypes.StreamFile]?
    /// An IAM role that allows the IoT service principal to access your S3 files.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The stream ID.
    /// This member is required.
    public var streamId: Swift.String?
    /// Metadata which can be used to manage streams.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        files: [IoTClientTypes.StreamFile]? = nil,
        roleArn: Swift.String? = nil,
        streamId: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.files = files
        self.roleArn = roleArn
        self.streamId = streamId
        self.tags = tags
    }
}

struct CreateStreamInputBody: Swift.Equatable {
    let description: Swift.String?
    let files: [IoTClientTypes.StreamFile]?
    let roleArn: Swift.String?
    let tags: [IoTClientTypes.Tag]?
}

extension CreateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case files
        case roleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let filesContainer = try containerValues.decodeIfPresent([IoTClientTypes.StreamFile?].self, forKey: .files)
        var filesDecoded0:[IoTClientTypes.StreamFile]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [IoTClientTypes.StreamFile]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.streamArn = output.streamArn
            self.streamId = output.streamId
            self.streamVersion = output.streamVersion
        } else {
            self.description = nil
            self.streamArn = nil
            self.streamId = nil
            self.streamVersion = nil
        }
    }
}

public struct CreateStreamOutput: Swift.Equatable {
    /// A description of the stream.
    public var description: Swift.String?
    /// The stream ARN.
    public var streamArn: Swift.String?
    /// The stream ID.
    public var streamId: Swift.String?
    /// The version of the stream.
    public var streamVersion: Swift.Int?

    public init(
        description: Swift.String? = nil,
        streamArn: Swift.String? = nil,
        streamId: Swift.String? = nil,
        streamVersion: Swift.Int? = nil
    )
    {
        self.description = description
        self.streamArn = streamArn
        self.streamId = streamId
        self.streamVersion = streamVersion
    }
}

struct CreateStreamOutputBody: Swift.Equatable {
    let streamId: Swift.String?
    let streamArn: Swift.String?
    let description: Swift.String?
    let streamVersion: Swift.Int?
}

extension CreateStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case streamArn
        case streamId
        case streamVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let streamVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .streamVersion)
        streamVersion = streamVersionDecoded
    }
}

enum CreateStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateThingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parentGroupName
        case tags
        case thingGroupProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parentGroupName = self.parentGroupName {
            try encodeContainer.encode(parentGroupName, forKey: .parentGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let thingGroupProperties = self.thingGroupProperties {
            try encodeContainer.encode(thingGroupProperties, forKey: .thingGroupProperties)
        }
    }
}

extension CreateThingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingGroupName = thingGroupName else {
            return nil
        }
        return "/thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

public struct CreateThingGroupInput: Swift.Equatable {
    /// The name of the parent thing group.
    public var parentGroupName: Swift.String?
    /// Metadata which can be used to manage the thing group.
    public var tags: [IoTClientTypes.Tag]?
    /// The thing group name to create.
    /// This member is required.
    public var thingGroupName: Swift.String?
    /// The thing group properties.
    public var thingGroupProperties: IoTClientTypes.ThingGroupProperties?

    public init(
        parentGroupName: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        thingGroupName: Swift.String? = nil,
        thingGroupProperties: IoTClientTypes.ThingGroupProperties? = nil
    )
    {
        self.parentGroupName = parentGroupName
        self.tags = tags
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
    }
}

struct CreateThingGroupInputBody: Swift.Equatable {
    let parentGroupName: Swift.String?
    let thingGroupProperties: IoTClientTypes.ThingGroupProperties?
    let tags: [IoTClientTypes.Tag]?
}

extension CreateThingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parentGroupName
        case tags
        case thingGroupProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentGroupName)
        parentGroupName = parentGroupNameDecoded
        let thingGroupPropertiesDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingGroupProperties.self, forKey: .thingGroupProperties)
        thingGroupProperties = thingGroupPropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateThingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateThingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.thingGroupArn = output.thingGroupArn
            self.thingGroupId = output.thingGroupId
            self.thingGroupName = output.thingGroupName
        } else {
            self.thingGroupArn = nil
            self.thingGroupId = nil
            self.thingGroupName = nil
        }
    }
}

public struct CreateThingGroupOutput: Swift.Equatable {
    /// The thing group ARN.
    public var thingGroupArn: Swift.String?
    /// The thing group ID.
    public var thingGroupId: Swift.String?
    /// The thing group name.
    public var thingGroupName: Swift.String?

    public init(
        thingGroupArn: Swift.String? = nil,
        thingGroupId: Swift.String? = nil,
        thingGroupName: Swift.String? = nil
    )
    {
        self.thingGroupArn = thingGroupArn
        self.thingGroupId = thingGroupId
        self.thingGroupName = thingGroupName
    }
}

struct CreateThingGroupOutputBody: Swift.Equatable {
    let thingGroupName: Swift.String?
    let thingGroupArn: Swift.String?
    let thingGroupId: Swift.String?
}

extension CreateThingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingGroupArn
        case thingGroupId
        case thingGroupName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupName)
        thingGroupName = thingGroupNameDecoded
        let thingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupArn)
        thingGroupArn = thingGroupArnDecoded
        let thingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupId)
        thingGroupId = thingGroupIdDecoded
    }
}

enum CreateThingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributePayload
        case billingGroupName
        case thingTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributePayload = self.attributePayload {
            try encodeContainer.encode(attributePayload, forKey: .attributePayload)
        }
        if let billingGroupName = self.billingGroupName {
            try encodeContainer.encode(billingGroupName, forKey: .billingGroupName)
        }
        if let thingTypeName = self.thingTypeName {
            try encodeContainer.encode(thingTypeName, forKey: .thingTypeName)
        }
    }
}

extension CreateThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())"
    }
}

/// The input for the CreateThing operation.
public struct CreateThingInput: Swift.Equatable {
    /// The attribute payload, which consists of up to three name/value pairs in a JSON document. For example: {\"attributes\":{\"string1\":\"string2\"}}
    public var attributePayload: IoTClientTypes.AttributePayload?
    /// The name of the billing group the thing will be added to.
    public var billingGroupName: Swift.String?
    /// The name of the thing to create. You can't change a thing's name after you create it. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.
    /// This member is required.
    public var thingName: Swift.String?
    /// The name of the thing type associated with the new thing.
    public var thingTypeName: Swift.String?

    public init(
        attributePayload: IoTClientTypes.AttributePayload? = nil,
        billingGroupName: Swift.String? = nil,
        thingName: Swift.String? = nil,
        thingTypeName: Swift.String? = nil
    )
    {
        self.attributePayload = attributePayload
        self.billingGroupName = billingGroupName
        self.thingName = thingName
        self.thingTypeName = thingTypeName
    }
}

struct CreateThingInputBody: Swift.Equatable {
    let thingTypeName: Swift.String?
    let attributePayload: IoTClientTypes.AttributePayload?
    let billingGroupName: Swift.String?
}

extension CreateThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributePayload
        case billingGroupName
        case thingTypeName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let attributePayloadDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AttributePayload.self, forKey: .attributePayload)
        attributePayload = attributePayloadDecoded
        let billingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupName)
        billingGroupName = billingGroupNameDecoded
    }
}

extension CreateThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateThingOutputBody = try responseDecoder.decode(responseBody: data)
            self.thingArn = output.thingArn
            self.thingId = output.thingId
            self.thingName = output.thingName
        } else {
            self.thingArn = nil
            self.thingId = nil
            self.thingName = nil
        }
    }
}

/// The output of the CreateThing operation.
public struct CreateThingOutput: Swift.Equatable {
    /// The ARN of the new thing.
    public var thingArn: Swift.String?
    /// The thing ID.
    public var thingId: Swift.String?
    /// The name of the new thing.
    public var thingName: Swift.String?

    public init(
        thingArn: Swift.String? = nil,
        thingId: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.thingArn = thingArn
        self.thingId = thingId
        self.thingName = thingName
    }
}

struct CreateThingOutputBody: Swift.Equatable {
    let thingName: Swift.String?
    let thingArn: Swift.String?
    let thingId: Swift.String?
}

extension CreateThingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn
        case thingId
        case thingName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let thingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingId)
        thingId = thingIdDecoded
    }
}

enum CreateThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateThingTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
        case thingTypeProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let thingTypeProperties = self.thingTypeProperties {
            try encodeContainer.encode(thingTypeProperties, forKey: .thingTypeProperties)
        }
    }
}

extension CreateThingTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingTypeName = thingTypeName else {
            return nil
        }
        return "/thing-types/\(thingTypeName.urlPercentEncoding())"
    }
}

/// The input for the CreateThingType operation.
public struct CreateThingTypeInput: Swift.Equatable {
    /// Metadata which can be used to manage the thing type.
    public var tags: [IoTClientTypes.Tag]?
    /// The name of the thing type.
    /// This member is required.
    public var thingTypeName: Swift.String?
    /// The ThingTypeProperties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names.
    public var thingTypeProperties: IoTClientTypes.ThingTypeProperties?

    public init(
        tags: [IoTClientTypes.Tag]? = nil,
        thingTypeName: Swift.String? = nil,
        thingTypeProperties: IoTClientTypes.ThingTypeProperties? = nil
    )
    {
        self.tags = tags
        self.thingTypeName = thingTypeName
        self.thingTypeProperties = thingTypeProperties
    }
}

struct CreateThingTypeInputBody: Swift.Equatable {
    let thingTypeProperties: IoTClientTypes.ThingTypeProperties?
    let tags: [IoTClientTypes.Tag]?
}

extension CreateThingTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
        case thingTypeProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypePropertiesDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingTypeProperties.self, forKey: .thingTypeProperties)
        thingTypeProperties = thingTypePropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateThingTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateThingTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.thingTypeArn = output.thingTypeArn
            self.thingTypeId = output.thingTypeId
            self.thingTypeName = output.thingTypeName
        } else {
            self.thingTypeArn = nil
            self.thingTypeId = nil
            self.thingTypeName = nil
        }
    }
}

/// The output of the CreateThingType operation.
public struct CreateThingTypeOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the thing type.
    public var thingTypeArn: Swift.String?
    /// The thing type ID.
    public var thingTypeId: Swift.String?
    /// The name of the thing type.
    public var thingTypeName: Swift.String?

    public init(
        thingTypeArn: Swift.String? = nil,
        thingTypeId: Swift.String? = nil,
        thingTypeName: Swift.String? = nil
    )
    {
        self.thingTypeArn = thingTypeArn
        self.thingTypeId = thingTypeId
        self.thingTypeName = thingTypeName
    }
}

struct CreateThingTypeOutputBody: Swift.Equatable {
    let thingTypeName: Swift.String?
    let thingTypeArn: Swift.String?
    let thingTypeId: Swift.String?
}

extension CreateThingTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingTypeArn
        case thingTypeId
        case thingTypeName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let thingTypeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeArn)
        thingTypeArn = thingTypeArnDecoded
        let thingTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeId)
        thingTypeId = thingTypeIdDecoded
    }
}

enum CreateThingTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTopicRuleDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
    }
}

extension CreateTopicRuleDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/destinations"
    }
}

public struct CreateTopicRuleDestinationInput: Swift.Equatable {
    /// The topic rule destination configuration.
    /// This member is required.
    public var destinationConfiguration: IoTClientTypes.TopicRuleDestinationConfiguration?

    public init(
        destinationConfiguration: IoTClientTypes.TopicRuleDestinationConfiguration? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
    }
}

struct CreateTopicRuleDestinationInputBody: Swift.Equatable {
    let destinationConfiguration: IoTClientTypes.TopicRuleDestinationConfiguration?
}

extension CreateTopicRuleDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TopicRuleDestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
    }
}

extension CreateTopicRuleDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTopicRuleDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.topicRuleDestination = output.topicRuleDestination
        } else {
            self.topicRuleDestination = nil
        }
    }
}

public struct CreateTopicRuleDestinationOutput: Swift.Equatable {
    /// The topic rule destination.
    public var topicRuleDestination: IoTClientTypes.TopicRuleDestination?

    public init(
        topicRuleDestination: IoTClientTypes.TopicRuleDestination? = nil
    )
    {
        self.topicRuleDestination = topicRuleDestination
    }
}

struct CreateTopicRuleDestinationOutputBody: Swift.Equatable {
    let topicRuleDestination: IoTClientTypes.TopicRuleDestination?
}

extension CreateTopicRuleDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicRuleDestination
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicRuleDestinationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TopicRuleDestination.self, forKey: .topicRuleDestination)
        topicRuleDestination = topicRuleDestinationDecoded
    }
}

enum CreateTopicRuleDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct CreateTopicRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTopicRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTopicRuleInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateTopicRuleOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let topicRulePayload = input.operationInput.topicRulePayload {
                let topicRulePayloadData = try encoder.encode(topicRulePayload)
                let topicRulePayloadBody = ClientRuntime.HttpBody.data(topicRulePayloadData)
                input.builder.withBody(topicRulePayloadBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let topicRulePayloadData = "{}".data(using: .utf8)!
                    let topicRulePayloadBody = ClientRuntime.HttpBody.data(topicRulePayloadData)
                    input.builder.withBody(topicRulePayloadBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTopicRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTopicRuleOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateTopicRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicRulePayload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicRulePayload = self.topicRulePayload {
            try encodeContainer.encode(topicRulePayload, forKey: .topicRulePayload)
        }
    }
}

extension CreateTopicRuleInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let tags = tags {
            items.add(Header(name: "x-amz-tagging", value: Swift.String(tags)))
        }
        return items
    }
}

extension CreateTopicRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ruleName = ruleName else {
            return nil
        }
        return "/rules/\(ruleName.urlPercentEncoding())"
    }
}

/// The input for the CreateTopicRule operation.
public struct CreateTopicRuleInput: Swift.Equatable {
    /// The name of the rule.
    /// This member is required.
    public var ruleName: Swift.String?
    /// Metadata which can be used to manage the topic rule. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: --tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: Swift.String?
    /// The rule payload.
    /// This member is required.
    public var topicRulePayload: IoTClientTypes.TopicRulePayload?

    public init(
        ruleName: Swift.String? = nil,
        tags: Swift.String? = nil,
        topicRulePayload: IoTClientTypes.TopicRulePayload? = nil
    )
    {
        self.ruleName = ruleName
        self.tags = tags
        self.topicRulePayload = topicRulePayload
    }
}

struct CreateTopicRuleInputBody: Swift.Equatable {
    let topicRulePayload: IoTClientTypes.TopicRulePayload?
}

extension CreateTopicRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicRulePayload
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicRulePayloadDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TopicRulePayload.self, forKey: .topicRulePayload)
        topicRulePayload = topicRulePayloadDecoded
    }
}

extension CreateTopicRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateTopicRuleOutput: Swift.Equatable {

    public init() { }
}

enum CreateTopicRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SqlParseException": return try await SqlParseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.CustomCodeSigning: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateChain
        case hashAlgorithm
        case signature
        case signatureAlgorithm
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateChain = self.certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
        if let hashAlgorithm = self.hashAlgorithm {
            try encodeContainer.encode(hashAlgorithm, forKey: .hashAlgorithm)
        }
        if let signature = self.signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
        if let signatureAlgorithm = self.signatureAlgorithm {
            try encodeContainer.encode(signatureAlgorithm, forKey: .signatureAlgorithm)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signatureDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CodeSigningSignature.self, forKey: .signature)
        signature = signatureDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CodeSigningCertificateChain.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        let hashAlgorithmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hashAlgorithm)
        hashAlgorithm = hashAlgorithmDecoded
        let signatureAlgorithmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signatureAlgorithm)
        signatureAlgorithm = signatureAlgorithmDecoded
    }
}

extension IoTClientTypes {
    /// Describes a custom method used to code sign a file.
    public struct CustomCodeSigning: Swift.Equatable {
        /// The certificate chain.
        public var certificateChain: IoTClientTypes.CodeSigningCertificateChain?
        /// The hash algorithm used to code sign the file. You can use a string as the algorithm name if the target over-the-air (OTA) update devices are able to verify the signature that was generated using the same signature algorithm. For example, FreeRTOS uses SHA256 or SHA1, so you can pass either of them based on which was used for generating the signature.
        public var hashAlgorithm: Swift.String?
        /// The signature for the file.
        public var signature: IoTClientTypes.CodeSigningSignature?
        /// The signature algorithm used to code sign the file. You can use a string as the algorithm name if the target over-the-air (OTA) update devices are able to verify the signature that was generated using the same signature algorithm. For example, FreeRTOS uses ECDSA or RSA, so you can pass either of them based on which was used for generating the signature.
        public var signatureAlgorithm: Swift.String?

        public init(
            certificateChain: IoTClientTypes.CodeSigningCertificateChain? = nil,
            hashAlgorithm: Swift.String? = nil,
            signature: IoTClientTypes.CodeSigningSignature? = nil,
            signatureAlgorithm: Swift.String? = nil
        )
        {
            self.certificateChain = certificateChain
            self.hashAlgorithm = hashAlgorithm
            self.signature = signature
            self.signatureAlgorithm = signatureAlgorithm
        }
    }

}

extension IoTClientTypes {
    public enum CustomMetricType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ipAddressList
        case number
        case numberList
        case stringList
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomMetricType] {
            return [
                .ipAddressList,
                .number,
                .numberList,
                .stringList,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipAddressList: return "ip-address-list"
            case .number: return "number"
            case .numberList: return "number-list"
            case .stringList: return "string-list"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomMetricType(rawValue: rawValue) ?? CustomMetricType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum DayOfWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fri
        case mon
        case sat
        case sun
        case thu
        case tue
        case wed
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .fri,
                .mon,
                .sat,
                .sun,
                .thu,
                .tue,
                .wed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fri: return "FRI"
            case .mon: return "MON"
            case .sat: return "SAT"
            case .sun: return "SUN"
            case .thu: return "THU"
            case .tue: return "TUE"
            case .wed: return "WED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DayOfWeek(rawValue: rawValue) ?? DayOfWeek.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAccountAuditConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let deleteScheduledAudits = deleteScheduledAudits {
                let deleteScheduledAuditsQueryItem = ClientRuntime.URLQueryItem(name: "deleteScheduledAudits".urlPercentEncoding(), value: Swift.String(deleteScheduledAudits).urlPercentEncoding())
                items.append(deleteScheduledAuditsQueryItem)
            }
            return items
        }
    }
}

extension DeleteAccountAuditConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/configuration"
    }
}

public struct DeleteAccountAuditConfigurationInput: Swift.Equatable {
    /// If true, all scheduled audits are deleted.
    public var deleteScheduledAudits: Swift.Bool?

    public init(
        deleteScheduledAudits: Swift.Bool? = nil
    )
    {
        self.deleteScheduledAudits = deleteScheduledAudits
    }
}

struct DeleteAccountAuditConfigurationInputBody: Swift.Equatable {
}

extension DeleteAccountAuditConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccountAuditConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccountAuditConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccountAuditConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAuditSuppressionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName
        case resourceIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = self.checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }
}

extension DeleteAuditSuppressionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/suppressions/delete"
    }
}

public struct DeleteAuditSuppressionInput: Swift.Equatable {
    /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    /// This member is required.
    public var checkName: Swift.String?
    /// Information that identifies the noncompliant resource.
    /// This member is required.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?

    public init(
        checkName: Swift.String? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil
    )
    {
        self.checkName = checkName
        self.resourceIdentifier = resourceIdentifier
    }
}

struct DeleteAuditSuppressionInputBody: Swift.Equatable {
    let checkName: Swift.String?
    let resourceIdentifier: IoTClientTypes.ResourceIdentifier?
}

extension DeleteAuditSuppressionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName
        case resourceIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
    }
}

extension DeleteAuditSuppressionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAuditSuppressionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAuditSuppressionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let authorizerName = authorizerName else {
            return nil
        }
        return "/authorizer/\(authorizerName.urlPercentEncoding())"
    }
}

public struct DeleteAuthorizerInput: Swift.Equatable {
    /// The name of the authorizer to delete.
    /// This member is required.
    public var authorizerName: Swift.String?

    public init(
        authorizerName: Swift.String? = nil
    )
    {
        self.authorizerName = authorizerName
    }
}

struct DeleteAuthorizerInputBody: Swift.Equatable {
}

extension DeleteAuthorizerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAuthorizerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeleteConflictException": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBillingGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let expectedVersion = expectedVersion {
                let expectedVersionQueryItem = ClientRuntime.URLQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
                items.append(expectedVersionQueryItem)
            }
            return items
        }
    }
}

extension DeleteBillingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let billingGroupName = billingGroupName else {
            return nil
        }
        return "/billing-groups/\(billingGroupName.urlPercentEncoding())"
    }
}

public struct DeleteBillingGroupInput: Swift.Equatable {
    /// The name of the billing group.
    /// This member is required.
    public var billingGroupName: Swift.String?
    /// The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the DeleteBillingGroup request is rejected with a VersionConflictException.
    public var expectedVersion: Swift.Int?

    public init(
        billingGroupName: Swift.String? = nil,
        expectedVersion: Swift.Int? = nil
    )
    {
        self.billingGroupName = billingGroupName
        self.expectedVersion = expectedVersion
    }
}

struct DeleteBillingGroupInputBody: Swift.Equatable {
}

extension DeleteBillingGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBillingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBillingGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBillingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCACertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let certificateId = certificateId else {
            return nil
        }
        return "/cacertificate/\(certificateId.urlPercentEncoding())"
    }
}

/// Input for the DeleteCACertificate operation.
public struct DeleteCACertificateInput: Swift.Equatable {
    /// The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct DeleteCACertificateInputBody: Swift.Equatable {
}

extension DeleteCACertificateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCACertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The output for the DeleteCACertificate operation.
public struct DeleteCACertificateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCACertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CertificateStateException": return try await CertificateStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCertificateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let forceDelete = forceDelete {
                let forceDeleteQueryItem = ClientRuntime.URLQueryItem(name: "forceDelete".urlPercentEncoding(), value: Swift.String(forceDelete).urlPercentEncoding())
                items.append(forceDeleteQueryItem)
            }
            return items
        }
    }
}

extension DeleteCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let certificateId = certificateId else {
            return nil
        }
        return "/certificates/\(certificateId.urlPercentEncoding())"
    }
}

/// The input for the DeleteCertificate operation.
public struct DeleteCertificateInput: Swift.Equatable {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?
    /// Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.
    public var forceDelete: Swift.Bool?

    public init(
        certificateId: Swift.String? = nil,
        forceDelete: Swift.Bool? = nil
    )
    {
        self.certificateId = certificateId
        self.forceDelete = forceDelete
    }
}

struct DeleteCertificateInputBody: Swift.Equatable {
}

extension DeleteCertificateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCertificateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CertificateStateException": return try await CertificateStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DeleteConflictException": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You can't delete the resource because it is attached to one or more resources.
public struct DeleteConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeleteConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeleteConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeleteConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteCustomMetricInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let metricName = metricName else {
            return nil
        }
        return "/custom-metric/\(metricName.urlPercentEncoding())"
    }
}

public struct DeleteCustomMetricInput: Swift.Equatable {
    /// The name of the custom metric.
    /// This member is required.
    public var metricName: Swift.String?

    public init(
        metricName: Swift.String? = nil
    )
    {
        self.metricName = metricName
    }
}

struct DeleteCustomMetricInputBody: Swift.Equatable {
}

extension DeleteCustomMetricInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCustomMetricOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCustomMetricOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCustomMetricOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDimensionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/dimensions/\(name.urlPercentEncoding())"
    }
}

public struct DeleteDimensionInput: Swift.Equatable {
    /// The unique identifier for the dimension that you want to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDimensionInputBody: Swift.Equatable {
}

extension DeleteDimensionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDimensionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDimensionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDimensionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDomainConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainConfigurationName = domainConfigurationName else {
            return nil
        }
        return "/domainConfigurations/\(domainConfigurationName.urlPercentEncoding())"
    }
}

public struct DeleteDomainConfigurationInput: Swift.Equatable {
    /// The name of the domain configuration to be deleted.
    /// This member is required.
    public var domainConfigurationName: Swift.String?

    public init(
        domainConfigurationName: Swift.String? = nil
    )
    {
        self.domainConfigurationName = domainConfigurationName
    }
}

struct DeleteDomainConfigurationInputBody: Swift.Equatable {
}

extension DeleteDomainConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDomainConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDomainConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDynamicThingGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let expectedVersion = expectedVersion {
                let expectedVersionQueryItem = ClientRuntime.URLQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
                items.append(expectedVersionQueryItem)
            }
            return items
        }
    }
}

extension DeleteDynamicThingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingGroupName = thingGroupName else {
            return nil
        }
        return "/dynamic-thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

public struct DeleteDynamicThingGroupInput: Swift.Equatable {
    /// The expected version of the dynamic thing group to delete.
    public var expectedVersion: Swift.Int?
    /// The name of the dynamic thing group to delete.
    /// This member is required.
    public var thingGroupName: Swift.String?

    public init(
        expectedVersion: Swift.Int? = nil,
        thingGroupName: Swift.String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.thingGroupName = thingGroupName
    }
}

struct DeleteDynamicThingGroupInputBody: Swift.Equatable {
}

extension DeleteDynamicThingGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDynamicThingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDynamicThingGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDynamicThingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFleetMetricInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let expectedVersion = expectedVersion {
                let expectedVersionQueryItem = ClientRuntime.URLQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
                items.append(expectedVersionQueryItem)
            }
            return items
        }
    }
}

extension DeleteFleetMetricInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let metricName = metricName else {
            return nil
        }
        return "/fleet-metric/\(metricName.urlPercentEncoding())"
    }
}

public struct DeleteFleetMetricInput: Swift.Equatable {
    /// The expected version of the fleet metric to delete.
    public var expectedVersion: Swift.Int?
    /// The name of the fleet metric to delete.
    /// This member is required.
    public var metricName: Swift.String?

    public init(
        expectedVersion: Swift.Int? = nil,
        metricName: Swift.String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.metricName = metricName
    }
}

struct DeleteFleetMetricInputBody: Swift.Equatable {
}

extension DeleteFleetMetricInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFleetMetricOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFleetMetricOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFleetMetricOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteJobExecutionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let namespaceId = namespaceId {
                let namespaceIdQueryItem = ClientRuntime.URLQueryItem(name: "namespaceId".urlPercentEncoding(), value: Swift.String(namespaceId).urlPercentEncoding())
                items.append(namespaceIdQueryItem)
            }
            if let force = force {
                let forceQueryItem = ClientRuntime.URLQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
                items.append(forceQueryItem)
            }
            return items
        }
    }
}

extension DeleteJobExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        guard let executionNumber = executionNumber else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/executionNumber/\(executionNumber)"
    }
}

public struct DeleteJobExecutionInput: Swift.Equatable {
    /// The ID of the job execution to be deleted. The executionNumber refers to the execution of a particular job on a particular device. Note that once a job execution is deleted, the executionNumber may be reused by IoT, so be sure you get and use the correct value here.
    /// This member is required.
    public var executionNumber: Swift.Int?
    /// (Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false. Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.
    public var force: Swift.Bool?
    /// The ID of the job whose execution on a particular device will be deleted.
    /// This member is required.
    public var jobId: Swift.String?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is in public preview.
    public var namespaceId: Swift.String?
    /// The name of the thing whose job execution will be deleted.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        executionNumber: Swift.Int? = nil,
        force: Swift.Bool? = nil,
        jobId: Swift.String? = nil,
        namespaceId: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.executionNumber = executionNumber
        self.force = force
        self.jobId = jobId
        self.namespaceId = namespaceId
        self.thingName = thingName
    }
}

struct DeleteJobExecutionInputBody: Swift.Equatable {
}

extension DeleteJobExecutionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteJobExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteJobExecutionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteJobExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateTransitionException": return try await InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let namespaceId = namespaceId {
                let namespaceIdQueryItem = ClientRuntime.URLQueryItem(name: "namespaceId".urlPercentEncoding(), value: Swift.String(namespaceId).urlPercentEncoding())
                items.append(namespaceIdQueryItem)
            }
            if let force = force {
                let forceQueryItem = ClientRuntime.URLQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
                items.append(forceQueryItem)
            }
            return items
        }
    }
}

extension DeleteJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DeleteJobInput: Swift.Equatable {
    /// (Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false. Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.
    public var force: Swift.Bool?
    /// The ID of the job to be deleted. After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is in public preview.
    public var namespaceId: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        jobId: Swift.String? = nil,
        namespaceId: Swift.String? = nil
    )
    {
        self.force = force
        self.jobId = jobId
        self.namespaceId = namespaceId
    }
}

struct DeleteJobInputBody: Swift.Equatable {
}

extension DeleteJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateTransitionException": return try await InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteJobTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobTemplateId = jobTemplateId else {
            return nil
        }
        return "/job-templates/\(jobTemplateId.urlPercentEncoding())"
    }
}

public struct DeleteJobTemplateInput: Swift.Equatable {
    /// The unique identifier of the job template to delete.
    /// This member is required.
    public var jobTemplateId: Swift.String?

    public init(
        jobTemplateId: Swift.String? = nil
    )
    {
        self.jobTemplateId = jobTemplateId
    }
}

struct DeleteJobTemplateInputBody: Swift.Equatable {
}

extension DeleteJobTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteJobTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteJobTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteJobTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMitigationActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let actionName = actionName else {
            return nil
        }
        return "/mitigationactions/actions/\(actionName.urlPercentEncoding())"
    }
}

public struct DeleteMitigationActionInput: Swift.Equatable {
    /// The name of the mitigation action that you want to delete.
    /// This member is required.
    public var actionName: Swift.String?

    public init(
        actionName: Swift.String? = nil
    )
    {
        self.actionName = actionName
    }
}

struct DeleteMitigationActionInputBody: Swift.Equatable {
}

extension DeleteMitigationActionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMitigationActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMitigationActionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMitigationActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteOTAUpdateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let deleteStream = deleteStream {
                let deleteStreamQueryItem = ClientRuntime.URLQueryItem(name: "deleteStream".urlPercentEncoding(), value: Swift.String(deleteStream).urlPercentEncoding())
                items.append(deleteStreamQueryItem)
            }
            if let forceDeleteAWSJob = forceDeleteAWSJob {
                let forceDeleteAWSJobQueryItem = ClientRuntime.URLQueryItem(name: "forceDeleteAWSJob".urlPercentEncoding(), value: Swift.String(forceDeleteAWSJob).urlPercentEncoding())
                items.append(forceDeleteAWSJobQueryItem)
            }
            return items
        }
    }
}

extension DeleteOTAUpdateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let otaUpdateId = otaUpdateId else {
            return nil
        }
        return "/otaUpdates/\(otaUpdateId.urlPercentEncoding())"
    }
}

public struct DeleteOTAUpdateInput: Swift.Equatable {
    /// When true, the stream created by the OTAUpdate process is deleted when the OTA update is deleted. Ignored if the stream specified in the OTAUpdate is supplied by the user.
    public var deleteStream: Swift.Bool?
    /// When true, deletes the IoT job created by the OTAUpdate process even if it is "IN_PROGRESS". Otherwise, if the job is not in a terminal state ("COMPLETED" or "CANCELED") an exception will occur. The default is false.
    public var forceDeleteAWSJob: Swift.Bool?
    /// The ID of the OTA update to delete.
    /// This member is required.
    public var otaUpdateId: Swift.String?

    public init(
        deleteStream: Swift.Bool? = nil,
        forceDeleteAWSJob: Swift.Bool? = nil,
        otaUpdateId: Swift.String? = nil
    )
    {
        self.deleteStream = deleteStream
        self.forceDeleteAWSJob = forceDeleteAWSJob
        self.otaUpdateId = otaUpdateId
    }
}

struct DeleteOTAUpdateInputBody: Swift.Equatable {
}

extension DeleteOTAUpdateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOTAUpdateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteOTAUpdateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteOTAUpdateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePackageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeletePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageName = packageName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())"
    }
}

public struct DeletePackageInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The name of the target software package.
    /// This member is required.
    public var packageName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        packageName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.packageName = packageName
    }
}

struct DeletePackageInputBody: Swift.Equatable {
}

extension DeletePackageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePackageOutput: Swift.Equatable {

    public init() { }
}

enum DeletePackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePackageVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeletePackageVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageName = packageName else {
            return nil
        }
        guard let versionName = versionName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())/versions/\(versionName.urlPercentEncoding())"
    }
}

public struct DeletePackageVersionInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The name of the associated software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The name of the target package version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        packageName: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.packageName = packageName
        self.versionName = versionName
    }
}

struct DeletePackageVersionInputBody: Swift.Equatable {
}

extension DeletePackageVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePackageVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePackageVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeletePackageVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let policyName = policyName else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())"
    }
}

/// The input for the DeletePolicy operation.
public struct DeletePolicyInput: Swift.Equatable {
    /// The name of the policy to delete.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        policyName: Swift.String? = nil
    )
    {
        self.policyName = policyName
    }
}

struct DeletePolicyInputBody: Swift.Equatable {
}

extension DeletePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeletePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeleteConflictException": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let policyName = policyName else {
            return nil
        }
        guard let policyVersionId = policyVersionId else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())/version/\(policyVersionId.urlPercentEncoding())"
    }
}

/// The input for the DeletePolicyVersion operation.
public struct DeletePolicyVersionInput: Swift.Equatable {
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The policy version ID.
    /// This member is required.
    public var policyVersionId: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        policyVersionId: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

struct DeletePolicyVersionInputBody: Swift.Equatable {
}

extension DeletePolicyVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePolicyVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePolicyVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeletePolicyVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeleteConflictException": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProvisioningTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let templateName = templateName else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())"
    }
}

public struct DeleteProvisioningTemplateInput: Swift.Equatable {
    /// The name of the fleet provision template to delete.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        templateName: Swift.String? = nil
    )
    {
        self.templateName = templateName
    }
}

struct DeleteProvisioningTemplateInputBody: Swift.Equatable {
}

extension DeleteProvisioningTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProvisioningTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProvisioningTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProvisioningTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DeleteConflictException": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProvisioningTemplateVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let templateName = templateName else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())/versions/\(versionId)"
    }
}

public struct DeleteProvisioningTemplateVersionInput: Swift.Equatable {
    /// The name of the provisioning template version to delete.
    /// This member is required.
    public var templateName: Swift.String?
    /// The provisioning template version ID to delete.
    /// This member is required.
    public var versionId: Swift.Int?

    public init(
        templateName: Swift.String? = nil,
        versionId: Swift.Int? = nil
    )
    {
        self.templateName = templateName
        self.versionId = versionId
    }
}

struct DeleteProvisioningTemplateVersionInputBody: Swift.Equatable {
}

extension DeleteProvisioningTemplateVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProvisioningTemplateVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProvisioningTemplateVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProvisioningTemplateVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DeleteConflictException": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRegistrationCodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/registrationcode"
    }
}

/// The input for the DeleteRegistrationCode operation.
public struct DeleteRegistrationCodeInput: Swift.Equatable {

    public init() { }
}

struct DeleteRegistrationCodeInputBody: Swift.Equatable {
}

extension DeleteRegistrationCodeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRegistrationCodeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The output for the DeleteRegistrationCode operation.
public struct DeleteRegistrationCodeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRegistrationCodeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRoleAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let roleAlias = roleAlias else {
            return nil
        }
        return "/role-aliases/\(roleAlias.urlPercentEncoding())"
    }
}

public struct DeleteRoleAliasInput: Swift.Equatable {
    /// The role alias to delete.
    /// This member is required.
    public var roleAlias: Swift.String?

    public init(
        roleAlias: Swift.String? = nil
    )
    {
        self.roleAlias = roleAlias
    }
}

struct DeleteRoleAliasInputBody: Swift.Equatable {
}

extension DeleteRoleAliasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRoleAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRoleAliasOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRoleAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeleteConflictException": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteScheduledAuditInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let scheduledAuditName = scheduledAuditName else {
            return nil
        }
        return "/audit/scheduledaudits/\(scheduledAuditName.urlPercentEncoding())"
    }
}

public struct DeleteScheduledAuditInput: Swift.Equatable {
    /// The name of the scheduled audit you want to delete.
    /// This member is required.
    public var scheduledAuditName: Swift.String?

    public init(
        scheduledAuditName: Swift.String? = nil
    )
    {
        self.scheduledAuditName = scheduledAuditName
    }
}

struct DeleteScheduledAuditInputBody: Swift.Equatable {
}

extension DeleteScheduledAuditInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteScheduledAuditOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteScheduledAuditOutput: Swift.Equatable {

    public init() { }
}

enum DeleteScheduledAuditOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSecurityProfileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let expectedVersion = expectedVersion {
                let expectedVersionQueryItem = ClientRuntime.URLQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
                items.append(expectedVersionQueryItem)
            }
            return items
        }
    }
}

extension DeleteSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let securityProfileName = securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())"
    }
}

public struct DeleteSecurityProfileInput: Swift.Equatable {
    /// The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a VersionConflictException is thrown.
    public var expectedVersion: Swift.Int?
    /// The name of the security profile to be deleted.
    /// This member is required.
    public var securityProfileName: Swift.String?

    public init(
        expectedVersion: Swift.Int? = nil,
        securityProfileName: Swift.String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.securityProfileName = securityProfileName
    }
}

struct DeleteSecurityProfileInputBody: Swift.Equatable {
}

extension DeleteSecurityProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSecurityProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSecurityProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSecurityProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let streamId = streamId else {
            return nil
        }
        return "/streams/\(streamId.urlPercentEncoding())"
    }
}

public struct DeleteStreamInput: Swift.Equatable {
    /// The stream ID.
    /// This member is required.
    public var streamId: Swift.String?

    public init(
        streamId: Swift.String? = nil
    )
    {
        self.streamId = streamId
    }
}

struct DeleteStreamInputBody: Swift.Equatable {
}

extension DeleteStreamInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStreamOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DeleteConflictException": return try await DeleteConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteThingGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let expectedVersion = expectedVersion {
                let expectedVersionQueryItem = ClientRuntime.URLQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
                items.append(expectedVersionQueryItem)
            }
            return items
        }
    }
}

extension DeleteThingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingGroupName = thingGroupName else {
            return nil
        }
        return "/thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

public struct DeleteThingGroupInput: Swift.Equatable {
    /// The expected version of the thing group to delete.
    public var expectedVersion: Swift.Int?
    /// The name of the thing group to delete.
    /// This member is required.
    public var thingGroupName: Swift.String?

    public init(
        expectedVersion: Swift.Int? = nil,
        thingGroupName: Swift.String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.thingGroupName = thingGroupName
    }
}

struct DeleteThingGroupInputBody: Swift.Equatable {
}

extension DeleteThingGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteThingGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteThingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteThingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let expectedVersion = expectedVersion {
                let expectedVersionQueryItem = ClientRuntime.URLQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
                items.append(expectedVersionQueryItem)
            }
            return items
        }
    }
}

extension DeleteThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())"
    }
}

/// The input for the DeleteThing operation.
public struct DeleteThingInput: Swift.Equatable {
    /// The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the DeleteThing request is rejected with a VersionConflictException.
    public var expectedVersion: Swift.Int?
    /// The name of the thing to delete.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        expectedVersion: Swift.Int? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.thingName = thingName
    }
}

struct DeleteThingInputBody: Swift.Equatable {
}

extension DeleteThingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The output of the DeleteThing operation.
public struct DeleteThingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteThingTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingTypeName = thingTypeName else {
            return nil
        }
        return "/thing-types/\(thingTypeName.urlPercentEncoding())"
    }
}

/// The input for the DeleteThingType operation.
public struct DeleteThingTypeInput: Swift.Equatable {
    /// The name of the thing type.
    /// This member is required.
    public var thingTypeName: Swift.String?

    public init(
        thingTypeName: Swift.String? = nil
    )
    {
        self.thingTypeName = thingTypeName
    }
}

struct DeleteThingTypeInputBody: Swift.Equatable {
}

extension DeleteThingTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThingTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The output for the DeleteThingType operation.
public struct DeleteThingTypeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteThingTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTopicRuleDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/destinations/\(arn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct DeleteTopicRuleDestinationInput: Swift.Equatable {
    /// The ARN of the topic rule destination to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteTopicRuleDestinationInputBody: Swift.Equatable {
}

extension DeleteTopicRuleDestinationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTopicRuleDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTopicRuleDestinationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTopicRuleDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTopicRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ruleName = ruleName else {
            return nil
        }
        return "/rules/\(ruleName.urlPercentEncoding())"
    }
}

/// The input for the DeleteTopicRule operation.
public struct DeleteTopicRuleInput: Swift.Equatable {
    /// The name of the rule.
    /// This member is required.
    public var ruleName: Swift.String?

    public init(
        ruleName: Swift.String? = nil
    )
    {
        self.ruleName = ruleName
    }
}

struct DeleteTopicRuleInputBody: Swift.Equatable {
}

extension DeleteTopicRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTopicRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTopicRuleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTopicRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteV2LoggingLevelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let targetName = targetName else {
                let message = "Creating a URL Query Item failed. targetName is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let targetNameQueryItem = ClientRuntime.URLQueryItem(name: "targetName".urlPercentEncoding(), value: Swift.String(targetName).urlPercentEncoding())
            items.append(targetNameQueryItem)
            guard let targetType = targetType else {
                let message = "Creating a URL Query Item failed. targetType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let targetTypeQueryItem = ClientRuntime.URLQueryItem(name: "targetType".urlPercentEncoding(), value: Swift.String(targetType.rawValue).urlPercentEncoding())
            items.append(targetTypeQueryItem)
            return items
        }
    }
}

extension DeleteV2LoggingLevelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2LoggingLevel"
    }
}

public struct DeleteV2LoggingLevelInput: Swift.Equatable {
    /// The name of the resource for which you are configuring logging.
    /// This member is required.
    public var targetName: Swift.String?
    /// The type of resource for which you are configuring logging. Must be THING_Group.
    /// This member is required.
    public var targetType: IoTClientTypes.LogTargetType?

    public init(
        targetName: Swift.String? = nil,
        targetType: IoTClientTypes.LogTargetType? = nil
    )
    {
        self.targetName = targetName
        self.targetType = targetType
    }
}

struct DeleteV2LoggingLevelInputBody: Swift.Equatable {
}

extension DeleteV2LoggingLevelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteV2LoggingLevelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteV2LoggingLevelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteV2LoggingLevelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.Denied: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explicitDeny
        case implicitDeny
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explicitDeny = self.explicitDeny {
            try encodeContainer.encode(explicitDeny, forKey: .explicitDeny)
        }
        if let implicitDeny = self.implicitDeny {
            try encodeContainer.encode(implicitDeny, forKey: .implicitDeny)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let implicitDenyDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ImplicitDeny.self, forKey: .implicitDeny)
        implicitDeny = implicitDenyDecoded
        let explicitDenyDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ExplicitDeny.self, forKey: .explicitDeny)
        explicitDeny = explicitDenyDecoded
    }
}

extension IoTClientTypes {
    /// Contains information that denied the authorization.
    public struct Denied: Swift.Equatable {
        /// Information that explicitly denies the authorization.
        public var explicitDeny: IoTClientTypes.ExplicitDeny?
        /// Information that implicitly denies the authorization. When a policy doesn't explicitly deny or allow an action on a resource it is considered an implicit deny.
        public var implicitDeny: IoTClientTypes.ImplicitDeny?

        public init(
            explicitDeny: IoTClientTypes.ExplicitDeny? = nil,
            implicitDeny: IoTClientTypes.ImplicitDeny? = nil
        )
        {
            self.explicitDeny = explicitDeny
            self.implicitDeny = implicitDeny
        }
    }

}

extension DeprecateThingTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case undoDeprecate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let undoDeprecate = self.undoDeprecate {
            try encodeContainer.encode(undoDeprecate, forKey: .undoDeprecate)
        }
    }
}

extension DeprecateThingTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingTypeName = thingTypeName else {
            return nil
        }
        return "/thing-types/\(thingTypeName.urlPercentEncoding())/deprecate"
    }
}

/// The input for the DeprecateThingType operation.
public struct DeprecateThingTypeInput: Swift.Equatable {
    /// The name of the thing type to deprecate.
    /// This member is required.
    public var thingTypeName: Swift.String?
    /// Whether to undeprecate a deprecated thing type. If true, the thing type will not be deprecated anymore and you can associate it with things.
    public var undoDeprecate: Swift.Bool?

    public init(
        thingTypeName: Swift.String? = nil,
        undoDeprecate: Swift.Bool? = nil
    )
    {
        self.thingTypeName = thingTypeName
        self.undoDeprecate = undoDeprecate
    }
}

struct DeprecateThingTypeInputBody: Swift.Equatable {
    let undoDeprecate: Swift.Bool?
}

extension DeprecateThingTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case undoDeprecate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let undoDeprecateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .undoDeprecate)
        undoDeprecate = undoDeprecateDecoded
    }
}

extension DeprecateThingTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The output for the DeprecateThingType operation.
public struct DeprecateThingTypeOutput: Swift.Equatable {

    public init() { }
}

enum DeprecateThingTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountAuditConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/configuration"
    }
}

public struct DescribeAccountAuditConfigurationInput: Swift.Equatable {

    public init() { }
}

struct DescribeAccountAuditConfigurationInputBody: Swift.Equatable {
}

extension DescribeAccountAuditConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountAuditConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountAuditConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.auditCheckConfigurations = output.auditCheckConfigurations
            self.auditNotificationTargetConfigurations = output.auditNotificationTargetConfigurations
            self.roleArn = output.roleArn
        } else {
            self.auditCheckConfigurations = nil
            self.auditNotificationTargetConfigurations = nil
            self.roleArn = nil
        }
    }
}

public struct DescribeAccountAuditConfigurationOutput: Swift.Equatable {
    /// Which audit checks are enabled and disabled for this account.
    public var auditCheckConfigurations: [Swift.String:IoTClientTypes.AuditCheckConfiguration]?
    /// Information about the targets to which audit notifications are sent for this account.
    public var auditNotificationTargetConfigurations: [Swift.String:IoTClientTypes.AuditNotificationTarget]?
    /// The ARN of the role that grants permission to IoT to access information about your devices, policies, certificates, and other items as required when performing an audit. On the first call to UpdateAccountAuditConfiguration, this parameter is required.
    public var roleArn: Swift.String?

    public init(
        auditCheckConfigurations: [Swift.String:IoTClientTypes.AuditCheckConfiguration]? = nil,
        auditNotificationTargetConfigurations: [Swift.String:IoTClientTypes.AuditNotificationTarget]? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.auditCheckConfigurations = auditCheckConfigurations
        self.auditNotificationTargetConfigurations = auditNotificationTargetConfigurations
        self.roleArn = roleArn
    }
}

struct DescribeAccountAuditConfigurationOutputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let auditNotificationTargetConfigurations: [Swift.String:IoTClientTypes.AuditNotificationTarget]?
    let auditCheckConfigurations: [Swift.String:IoTClientTypes.AuditCheckConfiguration]?
}

extension DescribeAccountAuditConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditCheckConfigurations
        case auditNotificationTargetConfigurations
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let auditNotificationTargetConfigurationsContainer = try containerValues.decodeIfPresent([Swift.String: IoTClientTypes.AuditNotificationTarget?].self, forKey: .auditNotificationTargetConfigurations)
        var auditNotificationTargetConfigurationsDecoded0: [Swift.String:IoTClientTypes.AuditNotificationTarget]? = nil
        if let auditNotificationTargetConfigurationsContainer = auditNotificationTargetConfigurationsContainer {
            auditNotificationTargetConfigurationsDecoded0 = [Swift.String:IoTClientTypes.AuditNotificationTarget]()
            for (key0, auditnotificationtarget0) in auditNotificationTargetConfigurationsContainer {
                if let auditnotificationtarget0 = auditnotificationtarget0 {
                    auditNotificationTargetConfigurationsDecoded0?[key0] = auditnotificationtarget0
                }
            }
        }
        auditNotificationTargetConfigurations = auditNotificationTargetConfigurationsDecoded0
        let auditCheckConfigurationsContainer = try containerValues.decodeIfPresent([Swift.String: IoTClientTypes.AuditCheckConfiguration?].self, forKey: .auditCheckConfigurations)
        var auditCheckConfigurationsDecoded0: [Swift.String:IoTClientTypes.AuditCheckConfiguration]? = nil
        if let auditCheckConfigurationsContainer = auditCheckConfigurationsContainer {
            auditCheckConfigurationsDecoded0 = [Swift.String:IoTClientTypes.AuditCheckConfiguration]()
            for (key0, auditcheckconfiguration0) in auditCheckConfigurationsContainer {
                if let auditcheckconfiguration0 = auditcheckconfiguration0 {
                    auditCheckConfigurationsDecoded0?[key0] = auditcheckconfiguration0
                }
            }
        }
        auditCheckConfigurations = auditCheckConfigurationsDecoded0
    }
}

enum DescribeAccountAuditConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAuditFindingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let findingId = findingId else {
            return nil
        }
        return "/audit/findings/\(findingId.urlPercentEncoding())"
    }
}

public struct DescribeAuditFindingInput: Swift.Equatable {
    /// A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.
    /// This member is required.
    public var findingId: Swift.String?

    public init(
        findingId: Swift.String? = nil
    )
    {
        self.findingId = findingId
    }
}

struct DescribeAuditFindingInputBody: Swift.Equatable {
}

extension DescribeAuditFindingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAuditFindingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAuditFindingOutputBody = try responseDecoder.decode(responseBody: data)
            self.finding = output.finding
        } else {
            self.finding = nil
        }
    }
}

public struct DescribeAuditFindingOutput: Swift.Equatable {
    /// The findings (results) of the audit.
    public var finding: IoTClientTypes.AuditFinding?

    public init(
        finding: IoTClientTypes.AuditFinding? = nil
    )
    {
        self.finding = finding
    }
}

struct DescribeAuditFindingOutputBody: Swift.Equatable {
    let finding: IoTClientTypes.AuditFinding?
}

extension DescribeAuditFindingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finding
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditFinding.self, forKey: .finding)
        finding = findingDecoded
    }
}

enum DescribeAuditFindingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAuditMitigationActionsTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/audit/mitigationactions/tasks/\(taskId.urlPercentEncoding())"
    }
}

public struct DescribeAuditMitigationActionsTaskInput: Swift.Equatable {
    /// The unique identifier for the audit mitigation task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct DescribeAuditMitigationActionsTaskInputBody: Swift.Equatable {
}

extension DescribeAuditMitigationActionsTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAuditMitigationActionsTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAuditMitigationActionsTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionsDefinition = output.actionsDefinition
            self.auditCheckToActionsMapping = output.auditCheckToActionsMapping
            self.endTime = output.endTime
            self.startTime = output.startTime
            self.target = output.target
            self.taskStatistics = output.taskStatistics
            self.taskStatus = output.taskStatus
        } else {
            self.actionsDefinition = nil
            self.auditCheckToActionsMapping = nil
            self.endTime = nil
            self.startTime = nil
            self.target = nil
            self.taskStatistics = nil
            self.taskStatus = nil
        }
    }
}

public struct DescribeAuditMitigationActionsTaskOutput: Swift.Equatable {
    /// Specifies the mitigation actions and their parameters that are applied as part of this task.
    public var actionsDefinition: [IoTClientTypes.MitigationAction]?
    /// Specifies the mitigation actions that should be applied to specific audit checks.
    public var auditCheckToActionsMapping: [Swift.String:[Swift.String]]?
    /// The date and time when the task was completed or canceled.
    public var endTime: ClientRuntime.Date?
    /// The date and time when the task was started.
    public var startTime: ClientRuntime.Date?
    /// Identifies the findings to which the mitigation actions are applied. This can be by audit checks, by audit task, or a set of findings.
    public var target: IoTClientTypes.AuditMitigationActionsTaskTarget?
    /// Aggregate counts of the results when the mitigation tasks were applied to the findings for this audit mitigation actions task.
    public var taskStatistics: [Swift.String:IoTClientTypes.TaskStatisticsForAuditCheck]?
    /// The current status of the task.
    public var taskStatus: IoTClientTypes.AuditMitigationActionsTaskStatus?

    public init(
        actionsDefinition: [IoTClientTypes.MitigationAction]? = nil,
        auditCheckToActionsMapping: [Swift.String:[Swift.String]]? = nil,
        endTime: ClientRuntime.Date? = nil,
        startTime: ClientRuntime.Date? = nil,
        target: IoTClientTypes.AuditMitigationActionsTaskTarget? = nil,
        taskStatistics: [Swift.String:IoTClientTypes.TaskStatisticsForAuditCheck]? = nil,
        taskStatus: IoTClientTypes.AuditMitigationActionsTaskStatus? = nil
    )
    {
        self.actionsDefinition = actionsDefinition
        self.auditCheckToActionsMapping = auditCheckToActionsMapping
        self.endTime = endTime
        self.startTime = startTime
        self.target = target
        self.taskStatistics = taskStatistics
        self.taskStatus = taskStatus
    }
}

struct DescribeAuditMitigationActionsTaskOutputBody: Swift.Equatable {
    let taskStatus: IoTClientTypes.AuditMitigationActionsTaskStatus?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let taskStatistics: [Swift.String:IoTClientTypes.TaskStatisticsForAuditCheck]?
    let target: IoTClientTypes.AuditMitigationActionsTaskTarget?
    let auditCheckToActionsMapping: [Swift.String:[Swift.String]]?
    let actionsDefinition: [IoTClientTypes.MitigationAction]?
}

extension DescribeAuditMitigationActionsTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionsDefinition
        case auditCheckToActionsMapping
        case endTime
        case startTime
        case target
        case taskStatistics
        case taskStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditMitigationActionsTaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let taskStatisticsContainer = try containerValues.decodeIfPresent([Swift.String: IoTClientTypes.TaskStatisticsForAuditCheck?].self, forKey: .taskStatistics)
        var taskStatisticsDecoded0: [Swift.String:IoTClientTypes.TaskStatisticsForAuditCheck]? = nil
        if let taskStatisticsContainer = taskStatisticsContainer {
            taskStatisticsDecoded0 = [Swift.String:IoTClientTypes.TaskStatisticsForAuditCheck]()
            for (key0, taskstatisticsforauditcheck0) in taskStatisticsContainer {
                if let taskstatisticsforauditcheck0 = taskstatisticsforauditcheck0 {
                    taskStatisticsDecoded0?[key0] = taskstatisticsforauditcheck0
                }
            }
        }
        taskStatistics = taskStatisticsDecoded0
        let targetDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditMitigationActionsTaskTarget.self, forKey: .target)
        target = targetDecoded
        let auditCheckToActionsMappingContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .auditCheckToActionsMapping)
        var auditCheckToActionsMappingDecoded0: [Swift.String:[Swift.String]]? = nil
        if let auditCheckToActionsMappingContainer = auditCheckToActionsMappingContainer {
            auditCheckToActionsMappingDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, mitigationactionnamelist0) in auditCheckToActionsMappingContainer {
                var mitigationactionnamelist0Decoded0: [Swift.String]? = nil
                if let mitigationactionnamelist0 = mitigationactionnamelist0 {
                    mitigationactionnamelist0Decoded0 = [Swift.String]()
                    for string1 in mitigationactionnamelist0 {
                        if let string1 = string1 {
                            mitigationactionnamelist0Decoded0?.append(string1)
                        }
                    }
                }
                auditCheckToActionsMappingDecoded0?[key0] = mitigationactionnamelist0Decoded0
            }
        }
        auditCheckToActionsMapping = auditCheckToActionsMappingDecoded0
        let actionsDefinitionContainer = try containerValues.decodeIfPresent([IoTClientTypes.MitigationAction?].self, forKey: .actionsDefinition)
        var actionsDefinitionDecoded0:[IoTClientTypes.MitigationAction]? = nil
        if let actionsDefinitionContainer = actionsDefinitionContainer {
            actionsDefinitionDecoded0 = [IoTClientTypes.MitigationAction]()
            for structure0 in actionsDefinitionContainer {
                if let structure0 = structure0 {
                    actionsDefinitionDecoded0?.append(structure0)
                }
            }
        }
        actionsDefinition = actionsDefinitionDecoded0
    }
}

enum DescribeAuditMitigationActionsTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAuditSuppressionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName
        case resourceIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = self.checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }
}

extension DescribeAuditSuppressionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/suppressions/describe"
    }
}

public struct DescribeAuditSuppressionInput: Swift.Equatable {
    /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    /// This member is required.
    public var checkName: Swift.String?
    /// Information that identifies the noncompliant resource.
    /// This member is required.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?

    public init(
        checkName: Swift.String? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil
    )
    {
        self.checkName = checkName
        self.resourceIdentifier = resourceIdentifier
    }
}

struct DescribeAuditSuppressionInputBody: Swift.Equatable {
    let checkName: Swift.String?
    let resourceIdentifier: IoTClientTypes.ResourceIdentifier?
}

extension DescribeAuditSuppressionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName
        case resourceIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
    }
}

extension DescribeAuditSuppressionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAuditSuppressionOutputBody = try responseDecoder.decode(responseBody: data)
            self.checkName = output.checkName
            self.description = output.description
            self.expirationDate = output.expirationDate
            self.resourceIdentifier = output.resourceIdentifier
            self.suppressIndefinitely = output.suppressIndefinitely
        } else {
            self.checkName = nil
            self.description = nil
            self.expirationDate = nil
            self.resourceIdentifier = nil
            self.suppressIndefinitely = nil
        }
    }
}

public struct DescribeAuditSuppressionOutput: Swift.Equatable {
    /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    public var checkName: Swift.String?
    /// The description of the audit suppression.
    public var description: Swift.String?
    /// The epoch timestamp in seconds at which this suppression expires.
    public var expirationDate: ClientRuntime.Date?
    /// Information that identifies the noncompliant resource.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
    /// Indicates whether a suppression should exist indefinitely or not.
    public var suppressIndefinitely: Swift.Bool?

    public init(
        checkName: Swift.String? = nil,
        description: Swift.String? = nil,
        expirationDate: ClientRuntime.Date? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
        suppressIndefinitely: Swift.Bool? = nil
    )
    {
        self.checkName = checkName
        self.description = description
        self.expirationDate = expirationDate
        self.resourceIdentifier = resourceIdentifier
        self.suppressIndefinitely = suppressIndefinitely
    }
}

struct DescribeAuditSuppressionOutputBody: Swift.Equatable {
    let checkName: Swift.String?
    let resourceIdentifier: IoTClientTypes.ResourceIdentifier?
    let expirationDate: ClientRuntime.Date?
    let suppressIndefinitely: Swift.Bool?
    let description: Swift.String?
}

extension DescribeAuditSuppressionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName
        case description
        case expirationDate
        case resourceIdentifier
        case suppressIndefinitely
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let expirationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let suppressIndefinitelyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .suppressIndefinitely)
        suppressIndefinitely = suppressIndefinitelyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum DescribeAuditSuppressionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAuditTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/audit/tasks/\(taskId.urlPercentEncoding())"
    }
}

public struct DescribeAuditTaskInput: Swift.Equatable {
    /// The ID of the audit whose information you want to get.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct DescribeAuditTaskInputBody: Swift.Equatable {
}

extension DescribeAuditTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAuditTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAuditTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.auditDetails = output.auditDetails
            self.scheduledAuditName = output.scheduledAuditName
            self.taskStartTime = output.taskStartTime
            self.taskStatistics = output.taskStatistics
            self.taskStatus = output.taskStatus
            self.taskType = output.taskType
        } else {
            self.auditDetails = nil
            self.scheduledAuditName = nil
            self.taskStartTime = nil
            self.taskStatistics = nil
            self.taskStatus = nil
            self.taskType = nil
        }
    }
}

public struct DescribeAuditTaskOutput: Swift.Equatable {
    /// Detailed information about each check performed during this audit.
    public var auditDetails: [Swift.String:IoTClientTypes.AuditCheckDetails]?
    /// The name of the scheduled audit (only if the audit was a scheduled audit).
    public var scheduledAuditName: Swift.String?
    /// The time the audit started.
    public var taskStartTime: ClientRuntime.Date?
    /// Statistical information about the audit.
    public var taskStatistics: IoTClientTypes.TaskStatistics?
    /// The status of the audit: one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
    public var taskStatus: IoTClientTypes.AuditTaskStatus?
    /// The type of audit: "ON_DEMAND_AUDIT_TASK" or "SCHEDULED_AUDIT_TASK".
    public var taskType: IoTClientTypes.AuditTaskType?

    public init(
        auditDetails: [Swift.String:IoTClientTypes.AuditCheckDetails]? = nil,
        scheduledAuditName: Swift.String? = nil,
        taskStartTime: ClientRuntime.Date? = nil,
        taskStatistics: IoTClientTypes.TaskStatistics? = nil,
        taskStatus: IoTClientTypes.AuditTaskStatus? = nil,
        taskType: IoTClientTypes.AuditTaskType? = nil
    )
    {
        self.auditDetails = auditDetails
        self.scheduledAuditName = scheduledAuditName
        self.taskStartTime = taskStartTime
        self.taskStatistics = taskStatistics
        self.taskStatus = taskStatus
        self.taskType = taskType
    }
}

struct DescribeAuditTaskOutputBody: Swift.Equatable {
    let taskStatus: IoTClientTypes.AuditTaskStatus?
    let taskType: IoTClientTypes.AuditTaskType?
    let taskStartTime: ClientRuntime.Date?
    let taskStatistics: IoTClientTypes.TaskStatistics?
    let scheduledAuditName: Swift.String?
    let auditDetails: [Swift.String:IoTClientTypes.AuditCheckDetails]?
}

extension DescribeAuditTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditDetails
        case scheduledAuditName
        case taskStartTime
        case taskStatistics
        case taskStatus
        case taskType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditTaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let taskStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .taskStartTime)
        taskStartTime = taskStartTimeDecoded
        let taskStatisticsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TaskStatistics.self, forKey: .taskStatistics)
        taskStatistics = taskStatisticsDecoded
        let scheduledAuditNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledAuditName)
        scheduledAuditName = scheduledAuditNameDecoded
        let auditDetailsContainer = try containerValues.decodeIfPresent([Swift.String: IoTClientTypes.AuditCheckDetails?].self, forKey: .auditDetails)
        var auditDetailsDecoded0: [Swift.String:IoTClientTypes.AuditCheckDetails]? = nil
        if let auditDetailsContainer = auditDetailsContainer {
            auditDetailsDecoded0 = [Swift.String:IoTClientTypes.AuditCheckDetails]()
            for (key0, auditcheckdetails0) in auditDetailsContainer {
                if let auditcheckdetails0 = auditcheckdetails0 {
                    auditDetailsDecoded0?[key0] = auditcheckdetails0
                }
            }
        }
        auditDetails = auditDetailsDecoded0
    }
}

enum DescribeAuditTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let authorizerName = authorizerName else {
            return nil
        }
        return "/authorizer/\(authorizerName.urlPercentEncoding())"
    }
}

public struct DescribeAuthorizerInput: Swift.Equatable {
    /// The name of the authorizer to describe.
    /// This member is required.
    public var authorizerName: Swift.String?

    public init(
        authorizerName: Swift.String? = nil
    )
    {
        self.authorizerName = authorizerName
    }
}

struct DescribeAuthorizerInputBody: Swift.Equatable {
}

extension DescribeAuthorizerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAuthorizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizerDescription = output.authorizerDescription
        } else {
            self.authorizerDescription = nil
        }
    }
}

public struct DescribeAuthorizerOutput: Swift.Equatable {
    /// The authorizer description.
    public var authorizerDescription: IoTClientTypes.AuthorizerDescription?

    public init(
        authorizerDescription: IoTClientTypes.AuthorizerDescription? = nil
    )
    {
        self.authorizerDescription = authorizerDescription
    }
}

struct DescribeAuthorizerOutputBody: Swift.Equatable {
    let authorizerDescription: IoTClientTypes.AuthorizerDescription?
}

extension DescribeAuthorizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerDescription
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerDescriptionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuthorizerDescription.self, forKey: .authorizerDescription)
        authorizerDescription = authorizerDescriptionDecoded
    }
}

enum DescribeAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBillingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let billingGroupName = billingGroupName else {
            return nil
        }
        return "/billing-groups/\(billingGroupName.urlPercentEncoding())"
    }
}

public struct DescribeBillingGroupInput: Swift.Equatable {
    /// The name of the billing group.
    /// This member is required.
    public var billingGroupName: Swift.String?

    public init(
        billingGroupName: Swift.String? = nil
    )
    {
        self.billingGroupName = billingGroupName
    }
}

struct DescribeBillingGroupInputBody: Swift.Equatable {
}

extension DescribeBillingGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBillingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBillingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.billingGroupArn = output.billingGroupArn
            self.billingGroupId = output.billingGroupId
            self.billingGroupMetadata = output.billingGroupMetadata
            self.billingGroupName = output.billingGroupName
            self.billingGroupProperties = output.billingGroupProperties
            self.version = output.version
        } else {
            self.billingGroupArn = nil
            self.billingGroupId = nil
            self.billingGroupMetadata = nil
            self.billingGroupName = nil
            self.billingGroupProperties = nil
            self.version = 0
        }
    }
}

public struct DescribeBillingGroupOutput: Swift.Equatable {
    /// The ARN of the billing group.
    public var billingGroupArn: Swift.String?
    /// The ID of the billing group.
    public var billingGroupId: Swift.String?
    /// Additional information about the billing group.
    public var billingGroupMetadata: IoTClientTypes.BillingGroupMetadata?
    /// The name of the billing group.
    public var billingGroupName: Swift.String?
    /// The properties of the billing group.
    public var billingGroupProperties: IoTClientTypes.BillingGroupProperties?
    /// The version of the billing group.
    public var version: Swift.Int

    public init(
        billingGroupArn: Swift.String? = nil,
        billingGroupId: Swift.String? = nil,
        billingGroupMetadata: IoTClientTypes.BillingGroupMetadata? = nil,
        billingGroupName: Swift.String? = nil,
        billingGroupProperties: IoTClientTypes.BillingGroupProperties? = nil,
        version: Swift.Int = 0
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingGroupId = billingGroupId
        self.billingGroupMetadata = billingGroupMetadata
        self.billingGroupName = billingGroupName
        self.billingGroupProperties = billingGroupProperties
        self.version = version
    }
}

struct DescribeBillingGroupOutputBody: Swift.Equatable {
    let billingGroupName: Swift.String?
    let billingGroupId: Swift.String?
    let billingGroupArn: Swift.String?
    let version: Swift.Int
    let billingGroupProperties: IoTClientTypes.BillingGroupProperties?
    let billingGroupMetadata: IoTClientTypes.BillingGroupMetadata?
}

extension DescribeBillingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupArn
        case billingGroupId
        case billingGroupMetadata
        case billingGroupName
        case billingGroupProperties
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupName)
        billingGroupName = billingGroupNameDecoded
        let billingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupId)
        billingGroupId = billingGroupIdDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let billingGroupPropertiesDecoded = try containerValues.decodeIfPresent(IoTClientTypes.BillingGroupProperties.self, forKey: .billingGroupProperties)
        billingGroupProperties = billingGroupPropertiesDecoded
        let billingGroupMetadataDecoded = try containerValues.decodeIfPresent(IoTClientTypes.BillingGroupMetadata.self, forKey: .billingGroupMetadata)
        billingGroupMetadata = billingGroupMetadataDecoded
    }
}

enum DescribeBillingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCACertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let certificateId = certificateId else {
            return nil
        }
        return "/cacertificate/\(certificateId.urlPercentEncoding())"
    }
}

/// The input for the DescribeCACertificate operation.
public struct DescribeCACertificateInput: Swift.Equatable {
    /// The CA certificate identifier.
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct DescribeCACertificateInputBody: Swift.Equatable {
}

extension DescribeCACertificateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCACertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCACertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateDescription = output.certificateDescription
            self.registrationConfig = output.registrationConfig
        } else {
            self.certificateDescription = nil
            self.registrationConfig = nil
        }
    }
}

/// The output from the DescribeCACertificate operation.
public struct DescribeCACertificateOutput: Swift.Equatable {
    /// The CA certificate description.
    public var certificateDescription: IoTClientTypes.CACertificateDescription?
    /// Information about the registration configuration.
    public var registrationConfig: IoTClientTypes.RegistrationConfig?

    public init(
        certificateDescription: IoTClientTypes.CACertificateDescription? = nil,
        registrationConfig: IoTClientTypes.RegistrationConfig? = nil
    )
    {
        self.certificateDescription = certificateDescription
        self.registrationConfig = registrationConfig
    }
}

struct DescribeCACertificateOutputBody: Swift.Equatable {
    let certificateDescription: IoTClientTypes.CACertificateDescription?
    let registrationConfig: IoTClientTypes.RegistrationConfig?
}

extension DescribeCACertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateDescription
        case registrationConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDescriptionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CACertificateDescription.self, forKey: .certificateDescription)
        certificateDescription = certificateDescriptionDecoded
        let registrationConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
    }
}

enum DescribeCACertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let certificateId = certificateId else {
            return nil
        }
        return "/certificates/\(certificateId.urlPercentEncoding())"
    }
}

/// The input for the DescribeCertificate operation.
public struct DescribeCertificateInput: Swift.Equatable {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?

    public init(
        certificateId: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
    }
}

struct DescribeCertificateInputBody: Swift.Equatable {
}

extension DescribeCertificateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateDescription = output.certificateDescription
        } else {
            self.certificateDescription = nil
        }
    }
}

/// The output of the DescribeCertificate operation.
public struct DescribeCertificateOutput: Swift.Equatable {
    /// The description of the certificate.
    public var certificateDescription: IoTClientTypes.CertificateDescription?

    public init(
        certificateDescription: IoTClientTypes.CertificateDescription? = nil
    )
    {
        self.certificateDescription = certificateDescription
    }
}

struct DescribeCertificateOutputBody: Swift.Equatable {
    let certificateDescription: IoTClientTypes.CertificateDescription?
}

extension DescribeCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateDescription
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDescriptionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CertificateDescription.self, forKey: .certificateDescription)
        certificateDescription = certificateDescriptionDecoded
    }
}

enum DescribeCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCustomMetricInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let metricName = metricName else {
            return nil
        }
        return "/custom-metric/\(metricName.urlPercentEncoding())"
    }
}

public struct DescribeCustomMetricInput: Swift.Equatable {
    /// The name of the custom metric.
    /// This member is required.
    public var metricName: Swift.String?

    public init(
        metricName: Swift.String? = nil
    )
    {
        self.metricName = metricName
    }
}

struct DescribeCustomMetricInputBody: Swift.Equatable {
}

extension DescribeCustomMetricInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCustomMetricOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCustomMetricOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.displayName = output.displayName
            self.lastModifiedDate = output.lastModifiedDate
            self.metricArn = output.metricArn
            self.metricName = output.metricName
            self.metricType = output.metricType
        } else {
            self.creationDate = nil
            self.displayName = nil
            self.lastModifiedDate = nil
            self.metricArn = nil
            self.metricName = nil
            self.metricType = nil
        }
    }
}

public struct DescribeCustomMetricOutput: Swift.Equatable {
    /// The creation date of the custom metric in milliseconds since epoch.
    public var creationDate: ClientRuntime.Date?
    /// Field represents a friendly name in the console for the custom metric; doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. Can be updated.
    public var displayName: Swift.String?
    /// The time the custom metric was last modified in milliseconds since epoch.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The Amazon Resource Number (ARN) of the custom metric.
    public var metricArn: Swift.String?
    /// The name of the custom metric.
    public var metricName: Swift.String?
    /// The type of the custom metric. The type number only takes a single metric value as an input, but while submitting the metrics value in the DeviceMetrics report, it must be passed as an array with a single value.
    public var metricType: IoTClientTypes.CustomMetricType?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        metricArn: Swift.String? = nil,
        metricName: Swift.String? = nil,
        metricType: IoTClientTypes.CustomMetricType? = nil
    )
    {
        self.creationDate = creationDate
        self.displayName = displayName
        self.lastModifiedDate = lastModifiedDate
        self.metricArn = metricArn
        self.metricName = metricName
        self.metricType = metricType
    }
}

struct DescribeCustomMetricOutputBody: Swift.Equatable {
    let metricName: Swift.String?
    let metricArn: Swift.String?
    let metricType: IoTClientTypes.CustomMetricType?
    let displayName: Swift.String?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
}

extension DescribeCustomMetricOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case displayName
        case lastModifiedDate
        case metricArn
        case metricName
        case metricType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricArn)
        metricArn = metricArnDecoded
        let metricTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CustomMetricType.self, forKey: .metricType)
        metricType = metricTypeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

enum DescribeCustomMetricOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDefaultAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/default-authorizer"
    }
}

public struct DescribeDefaultAuthorizerInput: Swift.Equatable {

    public init() { }
}

struct DescribeDefaultAuthorizerInputBody: Swift.Equatable {
}

extension DescribeDefaultAuthorizerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDefaultAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDefaultAuthorizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizerDescription = output.authorizerDescription
        } else {
            self.authorizerDescription = nil
        }
    }
}

public struct DescribeDefaultAuthorizerOutput: Swift.Equatable {
    /// The default authorizer's description.
    public var authorizerDescription: IoTClientTypes.AuthorizerDescription?

    public init(
        authorizerDescription: IoTClientTypes.AuthorizerDescription? = nil
    )
    {
        self.authorizerDescription = authorizerDescription
    }
}

struct DescribeDefaultAuthorizerOutputBody: Swift.Equatable {
    let authorizerDescription: IoTClientTypes.AuthorizerDescription?
}

extension DescribeDefaultAuthorizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerDescription
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerDescriptionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuthorizerDescription.self, forKey: .authorizerDescription)
        authorizerDescription = authorizerDescriptionDecoded
    }
}

enum DescribeDefaultAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDetectMitigationActionsTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/detect/mitigationactions/tasks/\(taskId.urlPercentEncoding())"
    }
}

public struct DescribeDetectMitigationActionsTaskInput: Swift.Equatable {
    /// The unique identifier of the task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct DescribeDetectMitigationActionsTaskInputBody: Swift.Equatable {
}

extension DescribeDetectMitigationActionsTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDetectMitigationActionsTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDetectMitigationActionsTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.taskSummary = output.taskSummary
        } else {
            self.taskSummary = nil
        }
    }
}

public struct DescribeDetectMitigationActionsTaskOutput: Swift.Equatable {
    /// The description of a task.
    public var taskSummary: IoTClientTypes.DetectMitigationActionsTaskSummary?

    public init(
        taskSummary: IoTClientTypes.DetectMitigationActionsTaskSummary? = nil
    )
    {
        self.taskSummary = taskSummary
    }
}

struct DescribeDetectMitigationActionsTaskOutputBody: Swift.Equatable {
    let taskSummary: IoTClientTypes.DetectMitigationActionsTaskSummary?
}

extension DescribeDetectMitigationActionsTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskSummaryDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DetectMitigationActionsTaskSummary.self, forKey: .taskSummary)
        taskSummary = taskSummaryDecoded
    }
}

enum DescribeDetectMitigationActionsTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDimensionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/dimensions/\(name.urlPercentEncoding())"
    }
}

public struct DescribeDimensionInput: Swift.Equatable {
    /// The unique identifier for the dimension.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeDimensionInputBody: Swift.Equatable {
}

extension DescribeDimensionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDimensionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDimensionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDate = output.creationDate
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
            self.stringValues = output.stringValues
            self.type = output.type
        } else {
            self.arn = nil
            self.creationDate = nil
            self.lastModifiedDate = nil
            self.name = nil
            self.stringValues = nil
            self.type = nil
        }
    }
}

public struct DescribeDimensionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the dimension.
    public var arn: Swift.String?
    /// The date the dimension was created.
    public var creationDate: ClientRuntime.Date?
    /// The date the dimension was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The unique identifier for the dimension.
    public var name: Swift.String?
    /// The value or list of values used to scope the dimension. For example, for topic filters, this is the pattern used to match the MQTT topic name.
    public var stringValues: [Swift.String]?
    /// The type of the dimension.
    public var type: IoTClientTypes.DimensionType?

    public init(
        arn: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        stringValues: [Swift.String]? = nil,
        type: IoTClientTypes.DimensionType? = nil
    )
    {
        self.arn = arn
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.stringValues = stringValues
        self.type = type
    }
}

struct DescribeDimensionOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let type: IoTClientTypes.DimensionType?
    let stringValues: [Swift.String]?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
}

extension DescribeDimensionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDate
        case lastModifiedDate
        case name
        case stringValues
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DimensionType.self, forKey: .type)
        type = typeDecoded
        let stringValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stringValues)
        var stringValuesDecoded0:[Swift.String]? = nil
        if let stringValuesContainer = stringValuesContainer {
            stringValuesDecoded0 = [Swift.String]()
            for string0 in stringValuesContainer {
                if let string0 = string0 {
                    stringValuesDecoded0?.append(string0)
                }
            }
        }
        stringValues = stringValuesDecoded0
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

enum DescribeDimensionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDomainConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainConfigurationName = domainConfigurationName else {
            return nil
        }
        return "/domainConfigurations/\(domainConfigurationName.urlPercentEncoding())"
    }
}

public struct DescribeDomainConfigurationInput: Swift.Equatable {
    /// The name of the domain configuration.
    /// This member is required.
    public var domainConfigurationName: Swift.String?

    public init(
        domainConfigurationName: Swift.String? = nil
    )
    {
        self.domainConfigurationName = domainConfigurationName
    }
}

struct DescribeDomainConfigurationInputBody: Swift.Equatable {
}

extension DescribeDomainConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDomainConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDomainConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizerConfig = output.authorizerConfig
            self.domainConfigurationArn = output.domainConfigurationArn
            self.domainConfigurationName = output.domainConfigurationName
            self.domainConfigurationStatus = output.domainConfigurationStatus
            self.domainName = output.domainName
            self.domainType = output.domainType
            self.lastStatusChangeDate = output.lastStatusChangeDate
            self.serverCertificates = output.serverCertificates
            self.serviceType = output.serviceType
            self.tlsConfig = output.tlsConfig
        } else {
            self.authorizerConfig = nil
            self.domainConfigurationArn = nil
            self.domainConfigurationName = nil
            self.domainConfigurationStatus = nil
            self.domainName = nil
            self.domainType = nil
            self.lastStatusChangeDate = nil
            self.serverCertificates = nil
            self.serviceType = nil
            self.tlsConfig = nil
        }
    }
}

public struct DescribeDomainConfigurationOutput: Swift.Equatable {
    /// An object that specifies the authorization service for a domain.
    public var authorizerConfig: IoTClientTypes.AuthorizerConfig?
    /// The ARN of the domain configuration.
    public var domainConfigurationArn: Swift.String?
    /// The name of the domain configuration.
    public var domainConfigurationName: Swift.String?
    /// A Boolean value that specifies the current state of the domain configuration.
    public var domainConfigurationStatus: IoTClientTypes.DomainConfigurationStatus?
    /// The name of the domain.
    public var domainName: Swift.String?
    /// The type of the domain.
    public var domainType: IoTClientTypes.DomainType?
    /// The date and time the domain configuration's status was last changed.
    public var lastStatusChangeDate: ClientRuntime.Date?
    /// A list containing summary information about the server certificate included in the domain configuration.
    public var serverCertificates: [IoTClientTypes.ServerCertificateSummary]?
    /// The type of service delivered by the endpoint.
    public var serviceType: IoTClientTypes.ServiceType?
    /// An object that specifies the TLS configuration for a domain.
    public var tlsConfig: IoTClientTypes.TlsConfig?

    public init(
        authorizerConfig: IoTClientTypes.AuthorizerConfig? = nil,
        domainConfigurationArn: Swift.String? = nil,
        domainConfigurationName: Swift.String? = nil,
        domainConfigurationStatus: IoTClientTypes.DomainConfigurationStatus? = nil,
        domainName: Swift.String? = nil,
        domainType: IoTClientTypes.DomainType? = nil,
        lastStatusChangeDate: ClientRuntime.Date? = nil,
        serverCertificates: [IoTClientTypes.ServerCertificateSummary]? = nil,
        serviceType: IoTClientTypes.ServiceType? = nil,
        tlsConfig: IoTClientTypes.TlsConfig? = nil
    )
    {
        self.authorizerConfig = authorizerConfig
        self.domainConfigurationArn = domainConfigurationArn
        self.domainConfigurationName = domainConfigurationName
        self.domainConfigurationStatus = domainConfigurationStatus
        self.domainName = domainName
        self.domainType = domainType
        self.lastStatusChangeDate = lastStatusChangeDate
        self.serverCertificates = serverCertificates
        self.serviceType = serviceType
        self.tlsConfig = tlsConfig
    }
}

struct DescribeDomainConfigurationOutputBody: Swift.Equatable {
    let domainConfigurationName: Swift.String?
    let domainConfigurationArn: Swift.String?
    let domainName: Swift.String?
    let serverCertificates: [IoTClientTypes.ServerCertificateSummary]?
    let authorizerConfig: IoTClientTypes.AuthorizerConfig?
    let domainConfigurationStatus: IoTClientTypes.DomainConfigurationStatus?
    let serviceType: IoTClientTypes.ServiceType?
    let domainType: IoTClientTypes.DomainType?
    let lastStatusChangeDate: ClientRuntime.Date?
    let tlsConfig: IoTClientTypes.TlsConfig?
}

extension DescribeDomainConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerConfig
        case domainConfigurationArn
        case domainConfigurationName
        case domainConfigurationStatus
        case domainName
        case domainType
        case lastStatusChangeDate
        case serverCertificates
        case serviceType
        case tlsConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainConfigurationName)
        domainConfigurationName = domainConfigurationNameDecoded
        let domainConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainConfigurationArn)
        domainConfigurationArn = domainConfigurationArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let serverCertificatesContainer = try containerValues.decodeIfPresent([IoTClientTypes.ServerCertificateSummary?].self, forKey: .serverCertificates)
        var serverCertificatesDecoded0:[IoTClientTypes.ServerCertificateSummary]? = nil
        if let serverCertificatesContainer = serverCertificatesContainer {
            serverCertificatesDecoded0 = [IoTClientTypes.ServerCertificateSummary]()
            for structure0 in serverCertificatesContainer {
                if let structure0 = structure0 {
                    serverCertificatesDecoded0?.append(structure0)
                }
            }
        }
        serverCertificates = serverCertificatesDecoded0
        let authorizerConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuthorizerConfig.self, forKey: .authorizerConfig)
        authorizerConfig = authorizerConfigDecoded
        let domainConfigurationStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DomainConfigurationStatus.self, forKey: .domainConfigurationStatus)
        domainConfigurationStatus = domainConfigurationStatusDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let domainTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DomainType.self, forKey: .domainType)
        domainType = domainTypeDecoded
        let lastStatusChangeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStatusChangeDate)
        lastStatusChangeDate = lastStatusChangeDateDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

enum DescribeDomainConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEndpointInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let endpointType = endpointType {
                let endpointTypeQueryItem = ClientRuntime.URLQueryItem(name: "endpointType".urlPercentEncoding(), value: Swift.String(endpointType).urlPercentEncoding())
                items.append(endpointTypeQueryItem)
            }
            return items
        }
    }
}

extension DescribeEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/endpoint"
    }
}

/// The input for the DescribeEndpoint operation.
public struct DescribeEndpointInput: Swift.Equatable {
    /// The endpoint type. Valid endpoint types include:
    ///
    /// * iot:Data - Returns a VeriSign signed data endpoint.
    ///
    ///
    ///
    ///
    /// * iot:Data-ATS - Returns an ATS signed data endpoint.
    ///
    ///
    ///
    ///
    /// * iot:CredentialProvider - Returns an IoT credentials provider API endpoint.
    ///
    ///
    ///
    ///
    /// * iot:Jobs - Returns an IoT device management Jobs API endpoint.
    ///
    ///
    /// We strongly recommend that customers use the newer iot:Data-ATS endpoint type to avoid issues related to the widespread distrust of Symantec certificate authorities. ATS Signed Certificates are more secure and are trusted by most popular browsers.
    public var endpointType: Swift.String?

    public init(
        endpointType: Swift.String? = nil
    )
    {
        self.endpointType = endpointType
    }
}

struct DescribeEndpointInputBody: Swift.Equatable {
}

extension DescribeEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpointAddress = output.endpointAddress
        } else {
            self.endpointAddress = nil
        }
    }
}

/// The output from the DescribeEndpoint operation.
public struct DescribeEndpointOutput: Swift.Equatable {
    /// The endpoint. The format of the endpoint is as follows: identifier.iot.region.amazonaws.com.
    public var endpointAddress: Swift.String?

    public init(
        endpointAddress: Swift.String? = nil
    )
    {
        self.endpointAddress = endpointAddress
    }
}

struct DescribeEndpointOutputBody: Swift.Equatable {
    let endpointAddress: Swift.String?
}

extension DescribeEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointAddress
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointAddress)
        endpointAddress = endpointAddressDecoded
    }
}

enum DescribeEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/event-configurations"
    }
}

public struct DescribeEventConfigurationsInput: Swift.Equatable {

    public init() { }
}

struct DescribeEventConfigurationsInputBody: Swift.Equatable {
}

extension DescribeEventConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEventConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.eventConfigurations = output.eventConfigurations
            self.lastModifiedDate = output.lastModifiedDate
        } else {
            self.creationDate = nil
            self.eventConfigurations = nil
            self.lastModifiedDate = nil
        }
    }
}

public struct DescribeEventConfigurationsOutput: Swift.Equatable {
    /// The creation date of the event configuration.
    public var creationDate: ClientRuntime.Date?
    /// The event configurations.
    public var eventConfigurations: [Swift.String:IoTClientTypes.Configuration]?
    /// The date the event configurations were last modified.
    public var lastModifiedDate: ClientRuntime.Date?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        eventConfigurations: [Swift.String:IoTClientTypes.Configuration]? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil
    )
    {
        self.creationDate = creationDate
        self.eventConfigurations = eventConfigurations
        self.lastModifiedDate = lastModifiedDate
    }
}

struct DescribeEventConfigurationsOutputBody: Swift.Equatable {
    let eventConfigurations: [Swift.String:IoTClientTypes.Configuration]?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
}

extension DescribeEventConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case eventConfigurations
        case lastModifiedDate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventConfigurationsContainer = try containerValues.decodeIfPresent([Swift.String: IoTClientTypes.Configuration?].self, forKey: .eventConfigurations)
        var eventConfigurationsDecoded0: [Swift.String:IoTClientTypes.Configuration]? = nil
        if let eventConfigurationsContainer = eventConfigurationsContainer {
            eventConfigurationsDecoded0 = [Swift.String:IoTClientTypes.Configuration]()
            for (key0, configuration0) in eventConfigurationsContainer {
                if let configuration0 = configuration0 {
                    eventConfigurationsDecoded0?[key0] = configuration0
                }
            }
        }
        eventConfigurations = eventConfigurationsDecoded0
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

enum DescribeEventConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFleetMetricInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let metricName = metricName else {
            return nil
        }
        return "/fleet-metric/\(metricName.urlPercentEncoding())"
    }
}

public struct DescribeFleetMetricInput: Swift.Equatable {
    /// The name of the fleet metric to describe.
    /// This member is required.
    public var metricName: Swift.String?

    public init(
        metricName: Swift.String? = nil
    )
    {
        self.metricName = metricName
    }
}

struct DescribeFleetMetricInputBody: Swift.Equatable {
}

extension DescribeFleetMetricInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFleetMetricOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFleetMetricOutputBody = try responseDecoder.decode(responseBody: data)
            self.aggregationField = output.aggregationField
            self.aggregationType = output.aggregationType
            self.creationDate = output.creationDate
            self.description = output.description
            self.indexName = output.indexName
            self.lastModifiedDate = output.lastModifiedDate
            self.metricArn = output.metricArn
            self.metricName = output.metricName
            self.period = output.period
            self.queryString = output.queryString
            self.queryVersion = output.queryVersion
            self.unit = output.unit
            self.version = output.version
        } else {
            self.aggregationField = nil
            self.aggregationType = nil
            self.creationDate = nil
            self.description = nil
            self.indexName = nil
            self.lastModifiedDate = nil
            self.metricArn = nil
            self.metricName = nil
            self.period = nil
            self.queryString = nil
            self.queryVersion = nil
            self.unit = nil
            self.version = 0
        }
    }
}

public struct DescribeFleetMetricOutput: Swift.Equatable {
    /// The field to aggregate.
    public var aggregationField: Swift.String?
    /// The type of the aggregation query.
    public var aggregationType: IoTClientTypes.AggregationType?
    /// The date when the fleet metric is created.
    public var creationDate: ClientRuntime.Date?
    /// The fleet metric description.
    public var description: Swift.String?
    /// The name of the index to search.
    public var indexName: Swift.String?
    /// The date when the fleet metric is last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The ARN of the fleet metric to describe.
    public var metricArn: Swift.String?
    /// The name of the fleet metric to describe.
    public var metricName: Swift.String?
    /// The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.
    public var period: Swift.Int?
    /// The search query string.
    public var queryString: Swift.String?
    /// The query version.
    public var queryVersion: Swift.String?
    /// Used to support unit transformation such as milliseconds to seconds. The unit must be supported by [CW metric](https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html).
    public var unit: IoTClientTypes.FleetMetricUnit?
    /// The version of the fleet metric.
    public var version: Swift.Int

    public init(
        aggregationField: Swift.String? = nil,
        aggregationType: IoTClientTypes.AggregationType? = nil,
        creationDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        indexName: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        metricArn: Swift.String? = nil,
        metricName: Swift.String? = nil,
        period: Swift.Int? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        unit: IoTClientTypes.FleetMetricUnit? = nil,
        version: Swift.Int = 0
    )
    {
        self.aggregationField = aggregationField
        self.aggregationType = aggregationType
        self.creationDate = creationDate
        self.description = description
        self.indexName = indexName
        self.lastModifiedDate = lastModifiedDate
        self.metricArn = metricArn
        self.metricName = metricName
        self.period = period
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.unit = unit
        self.version = version
    }
}

struct DescribeFleetMetricOutputBody: Swift.Equatable {
    let metricName: Swift.String?
    let queryString: Swift.String?
    let aggregationType: IoTClientTypes.AggregationType?
    let period: Swift.Int?
    let aggregationField: Swift.String?
    let description: Swift.String?
    let queryVersion: Swift.String?
    let indexName: Swift.String?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
    let unit: IoTClientTypes.FleetMetricUnit?
    let version: Swift.Int
    let metricArn: Swift.String?
}

extension DescribeFleetMetricOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationField
        case aggregationType
        case creationDate
        case description
        case indexName
        case lastModifiedDate
        case metricArn
        case metricName
        case period
        case queryString
        case queryVersion
        case unit
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let aggregationTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AggregationType.self, forKey: .aggregationType)
        aggregationType = aggregationTypeDecoded
        let periodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .period)
        period = periodDecoded
        let aggregationFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregationField)
        aggregationField = aggregationFieldDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let unitDecoded = try containerValues.decodeIfPresent(IoTClientTypes.FleetMetricUnit.self, forKey: .unit)
        unit = unitDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let metricArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricArn)
        metricArn = metricArnDecoded
    }
}

enum DescribeFleetMetricOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let indexName = indexName else {
            return nil
        }
        return "/indices/\(indexName.urlPercentEncoding())"
    }
}

public struct DescribeIndexInput: Swift.Equatable {
    /// The index name.
    /// This member is required.
    public var indexName: Swift.String?

    public init(
        indexName: Swift.String? = nil
    )
    {
        self.indexName = indexName
    }
}

struct DescribeIndexInputBody: Swift.Equatable {
}

extension DescribeIndexInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeIndexOutputBody = try responseDecoder.decode(responseBody: data)
            self.indexName = output.indexName
            self.indexStatus = output.indexStatus
            self.schema = output.schema
        } else {
            self.indexName = nil
            self.indexStatus = nil
            self.schema = nil
        }
    }
}

public struct DescribeIndexOutput: Swift.Equatable {
    /// The index name.
    public var indexName: Swift.String?
    /// The index status.
    public var indexStatus: IoTClientTypes.IndexStatus?
    /// Contains a value that specifies the type of indexing performed. Valid values are:
    ///
    /// * REGISTRY  Your thing index contains only registry data.
    ///
    /// * REGISTRY_AND_SHADOW - Your thing index contains registry data and shadow data.
    ///
    /// * REGISTRY_AND_CONNECTIVITY_STATUS - Your thing index contains registry data and thing connectivity status data.
    ///
    /// * REGISTRY_AND_SHADOW_AND_CONNECTIVITY_STATUS - Your thing index contains registry data, shadow data, and thing connectivity status data.
    ///
    /// * MULTI_INDEXING_MODE - Your thing index contains multiple data sources. For more information, see [GetIndexingConfiguration](https://docs.aws.amazon.com/iot/latest/apireference/API_GetIndexingConfiguration.html).
    public var schema: Swift.String?

    public init(
        indexName: Swift.String? = nil,
        indexStatus: IoTClientTypes.IndexStatus? = nil,
        schema: Swift.String? = nil
    )
    {
        self.indexName = indexName
        self.indexStatus = indexStatus
        self.schema = schema
    }
}

struct DescribeIndexOutputBody: Swift.Equatable {
    let indexName: Swift.String?
    let indexStatus: IoTClientTypes.IndexStatus?
    let schema: Swift.String?
}

extension DescribeIndexOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexName
        case indexStatus
        case schema
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let indexStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.IndexStatus.self, forKey: .indexStatus)
        indexStatus = indexStatusDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

enum DescribeIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJobExecutionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let executionNumber = executionNumber {
                let executionNumberQueryItem = ClientRuntime.URLQueryItem(name: "executionNumber".urlPercentEncoding(), value: Swift.String(executionNumber).urlPercentEncoding())
                items.append(executionNumberQueryItem)
            }
            return items
        }
    }
}

extension DescribeJobExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeJobExecutionInput: Swift.Equatable {
    /// A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.
    public var executionNumber: Swift.Int?
    /// The unique identifier you assigned to this job when it was created.
    /// This member is required.
    public var jobId: Swift.String?
    /// The name of the thing on which the job execution is running.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        executionNumber: Swift.Int? = nil,
        jobId: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.executionNumber = executionNumber
        self.jobId = jobId
        self.thingName = thingName
    }
}

struct DescribeJobExecutionInputBody: Swift.Equatable {
}

extension DescribeJobExecutionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJobExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.execution = output.execution
        } else {
            self.execution = nil
        }
    }
}

public struct DescribeJobExecutionOutput: Swift.Equatable {
    /// Information about the job execution.
    public var execution: IoTClientTypes.JobExecution?

    public init(
        execution: IoTClientTypes.JobExecution? = nil
    )
    {
        self.execution = execution
    }
}

struct DescribeJobExecutionOutputBody: Swift.Equatable {
    let execution: IoTClientTypes.JobExecution?
}

extension DescribeJobExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case execution
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecution.self, forKey: .execution)
        execution = executionDecoded
    }
}

enum DescribeJobExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeJobInput: Swift.Equatable {
    /// The unique identifier you assigned to this job when it was created.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeJobInputBody: Swift.Equatable {
}

extension DescribeJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.documentSource = output.documentSource
            self.job = output.job
        } else {
            self.documentSource = nil
            self.job = nil
        }
    }
}

public struct DescribeJobOutput: Swift.Equatable {
    /// An S3 link to the job document.
    public var documentSource: Swift.String?
    /// Information about the job.
    public var job: IoTClientTypes.Job?

    public init(
        documentSource: Swift.String? = nil,
        job: IoTClientTypes.Job? = nil
    )
    {
        self.documentSource = documentSource
        self.job = job
    }
}

struct DescribeJobOutputBody: Swift.Equatable {
    let documentSource: Swift.String?
    let job: IoTClientTypes.Job?
}

extension DescribeJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentSource
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentSource)
        documentSource = documentSourceDecoded
        let jobDecoded = try containerValues.decodeIfPresent(IoTClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

enum DescribeJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJobTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobTemplateId = jobTemplateId else {
            return nil
        }
        return "/job-templates/\(jobTemplateId.urlPercentEncoding())"
    }
}

public struct DescribeJobTemplateInput: Swift.Equatable {
    /// The unique identifier of the job template.
    /// This member is required.
    public var jobTemplateId: Swift.String?

    public init(
        jobTemplateId: Swift.String? = nil
    )
    {
        self.jobTemplateId = jobTemplateId
    }
}

struct DescribeJobTemplateInputBody: Swift.Equatable {
}

extension DescribeJobTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJobTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.abortConfig = output.abortConfig
            self.createdAt = output.createdAt
            self.description = output.description
            self.destinationPackageVersions = output.destinationPackageVersions
            self.document = output.document
            self.documentSource = output.documentSource
            self.jobExecutionsRetryConfig = output.jobExecutionsRetryConfig
            self.jobExecutionsRolloutConfig = output.jobExecutionsRolloutConfig
            self.jobTemplateArn = output.jobTemplateArn
            self.jobTemplateId = output.jobTemplateId
            self.maintenanceWindows = output.maintenanceWindows
            self.presignedUrlConfig = output.presignedUrlConfig
            self.timeoutConfig = output.timeoutConfig
        } else {
            self.abortConfig = nil
            self.createdAt = nil
            self.description = nil
            self.destinationPackageVersions = nil
            self.document = nil
            self.documentSource = nil
            self.jobExecutionsRetryConfig = nil
            self.jobExecutionsRolloutConfig = nil
            self.jobTemplateArn = nil
            self.jobTemplateId = nil
            self.maintenanceWindows = nil
            self.presignedUrlConfig = nil
            self.timeoutConfig = nil
        }
    }
}

public struct DescribeJobTemplateOutput: Swift.Equatable {
    /// The criteria that determine when and how a job abort takes place.
    public var abortConfig: IoTClientTypes.AbortConfig?
    /// The time, in seconds since the epoch, when the job template was created.
    public var createdAt: ClientRuntime.Date?
    /// A description of the job template.
    public var description: Swift.String?
    /// The package version Amazon Resource Names (ARNs) that are installed on the device when the job successfully completes. Note:The following Length Constraints relates to a single string. Up to five strings are allowed.
    public var destinationPackageVersions: [Swift.String]?
    /// The job document.
    public var document: Swift.String?
    /// An S3 link to the job document.
    public var documentSource: Swift.String?
    /// The configuration that determines how many retries are allowed for each failure type for a job.
    public var jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
    /// Allows you to create a staged rollout of a job.
    public var jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
    /// The ARN of the job template.
    public var jobTemplateArn: Swift.String?
    /// The unique identifier of the job template.
    public var jobTemplateId: Swift.String?
    /// Allows you to configure an optional maintenance window for the rollout of a job document to all devices in the target group for a job.
    public var maintenanceWindows: [IoTClientTypes.MaintenanceWindow]?
    /// Configuration for pre-signed S3 URLs.
    public var presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
    /// Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to TIMED_OUT.
    public var timeoutConfig: IoTClientTypes.TimeoutConfig?

    public init(
        abortConfig: IoTClientTypes.AbortConfig? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        destinationPackageVersions: [Swift.String]? = nil,
        document: Swift.String? = nil,
        documentSource: Swift.String? = nil,
        jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig? = nil,
        jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig? = nil,
        jobTemplateArn: Swift.String? = nil,
        jobTemplateId: Swift.String? = nil,
        maintenanceWindows: [IoTClientTypes.MaintenanceWindow]? = nil,
        presignedUrlConfig: IoTClientTypes.PresignedUrlConfig? = nil,
        timeoutConfig: IoTClientTypes.TimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.createdAt = createdAt
        self.description = description
        self.destinationPackageVersions = destinationPackageVersions
        self.document = document
        self.documentSource = documentSource
        self.jobExecutionsRetryConfig = jobExecutionsRetryConfig
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.jobTemplateArn = jobTemplateArn
        self.jobTemplateId = jobTemplateId
        self.maintenanceWindows = maintenanceWindows
        self.presignedUrlConfig = presignedUrlConfig
        self.timeoutConfig = timeoutConfig
    }
}

struct DescribeJobTemplateOutputBody: Swift.Equatable {
    let jobTemplateArn: Swift.String?
    let jobTemplateId: Swift.String?
    let description: Swift.String?
    let documentSource: Swift.String?
    let document: Swift.String?
    let createdAt: ClientRuntime.Date?
    let presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
    let jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
    let abortConfig: IoTClientTypes.AbortConfig?
    let timeoutConfig: IoTClientTypes.TimeoutConfig?
    let jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
    let maintenanceWindows: [IoTClientTypes.MaintenanceWindow]?
    let destinationPackageVersions: [Swift.String]?
}

extension DescribeJobTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortConfig
        case createdAt
        case description
        case destinationPackageVersions
        case document
        case documentSource
        case jobExecutionsRetryConfig
        case jobExecutionsRolloutConfig
        case jobTemplateArn
        case jobTemplateId
        case maintenanceWindows
        case presignedUrlConfig
        case timeoutConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTemplateArn)
        jobTemplateArn = jobTemplateArnDecoded
        let jobTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTemplateId)
        jobTemplateId = jobTemplateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let documentSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentSource)
        documentSource = documentSourceDecoded
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let presignedUrlConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.PresignedUrlConfig.self, forKey: .presignedUrlConfig)
        presignedUrlConfig = presignedUrlConfigDecoded
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
        let jobExecutionsRetryConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionsRetryConfig.self, forKey: .jobExecutionsRetryConfig)
        jobExecutionsRetryConfig = jobExecutionsRetryConfigDecoded
        let maintenanceWindowsContainer = try containerValues.decodeIfPresent([IoTClientTypes.MaintenanceWindow?].self, forKey: .maintenanceWindows)
        var maintenanceWindowsDecoded0:[IoTClientTypes.MaintenanceWindow]? = nil
        if let maintenanceWindowsContainer = maintenanceWindowsContainer {
            maintenanceWindowsDecoded0 = [IoTClientTypes.MaintenanceWindow]()
            for structure0 in maintenanceWindowsContainer {
                if let structure0 = structure0 {
                    maintenanceWindowsDecoded0?.append(structure0)
                }
            }
        }
        maintenanceWindows = maintenanceWindowsDecoded0
        let destinationPackageVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinationPackageVersions)
        var destinationPackageVersionsDecoded0:[Swift.String]? = nil
        if let destinationPackageVersionsContainer = destinationPackageVersionsContainer {
            destinationPackageVersionsDecoded0 = [Swift.String]()
            for string0 in destinationPackageVersionsContainer {
                if let string0 = string0 {
                    destinationPackageVersionsDecoded0?.append(string0)
                }
            }
        }
        destinationPackageVersions = destinationPackageVersionsDecoded0
    }
}

enum DescribeJobTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeManagedJobTemplateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let templateVersion = templateVersion {
                let templateVersionQueryItem = ClientRuntime.URLQueryItem(name: "templateVersion".urlPercentEncoding(), value: Swift.String(templateVersion).urlPercentEncoding())
                items.append(templateVersionQueryItem)
            }
            return items
        }
    }
}

extension DescribeManagedJobTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let templateName = templateName else {
            return nil
        }
        return "/managed-job-templates/\(templateName.urlPercentEncoding())"
    }
}

public struct DescribeManagedJobTemplateInput: Swift.Equatable {
    /// The unique name of a managed job template, which is required.
    /// This member is required.
    public var templateName: Swift.String?
    /// An optional parameter to specify version of a managed template. If not specified, the pre-defined default version is returned.
    public var templateVersion: Swift.String?

    public init(
        templateName: Swift.String? = nil,
        templateVersion: Swift.String? = nil
    )
    {
        self.templateName = templateName
        self.templateVersion = templateVersion
    }
}

struct DescribeManagedJobTemplateInputBody: Swift.Equatable {
}

extension DescribeManagedJobTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeManagedJobTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeManagedJobTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.document = output.document
            self.documentParameters = output.documentParameters
            self.environments = output.environments
            self.templateArn = output.templateArn
            self.templateName = output.templateName
            self.templateVersion = output.templateVersion
        } else {
            self.description = nil
            self.document = nil
            self.documentParameters = nil
            self.environments = nil
            self.templateArn = nil
            self.templateName = nil
            self.templateVersion = nil
        }
    }
}

public struct DescribeManagedJobTemplateOutput: Swift.Equatable {
    /// The unique description of a managed template.
    public var description: Swift.String?
    /// The document schema for a managed job template.
    public var document: Swift.String?
    /// A map of key-value pairs that you can use as guidance to specify the inputs for creating a job from a managed template. documentParameters can only be used when creating jobs from Amazon Web Services managed templates. This parameter can't be used with custom job templates or to create jobs from them.
    public var documentParameters: [IoTClientTypes.DocumentParameter]?
    /// A list of environments that are supported with the managed job template.
    public var environments: [Swift.String]?
    /// The unique Amazon Resource Name (ARN) of the managed template.
    public var templateArn: Swift.String?
    /// The unique name of a managed template, such as AWS-Reboot.
    public var templateName: Swift.String?
    /// The version for a managed template.
    public var templateVersion: Swift.String?

    public init(
        description: Swift.String? = nil,
        document: Swift.String? = nil,
        documentParameters: [IoTClientTypes.DocumentParameter]? = nil,
        environments: [Swift.String]? = nil,
        templateArn: Swift.String? = nil,
        templateName: Swift.String? = nil,
        templateVersion: Swift.String? = nil
    )
    {
        self.description = description
        self.document = document
        self.documentParameters = documentParameters
        self.environments = environments
        self.templateArn = templateArn
        self.templateName = templateName
        self.templateVersion = templateVersion
    }
}

struct DescribeManagedJobTemplateOutputBody: Swift.Equatable {
    let templateName: Swift.String?
    let templateArn: Swift.String?
    let description: Swift.String?
    let templateVersion: Swift.String?
    let environments: [Swift.String]?
    let documentParameters: [IoTClientTypes.DocumentParameter]?
    let document: Swift.String?
}

extension DescribeManagedJobTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case document
        case documentParameters
        case environments
        case templateArn
        case templateName
        case templateVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let templateVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateVersion)
        templateVersion = templateVersionDecoded
        let environmentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .environments)
        var environmentsDecoded0:[Swift.String]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [Swift.String]()
            for string0 in environmentsContainer {
                if let string0 = string0 {
                    environmentsDecoded0?.append(string0)
                }
            }
        }
        environments = environmentsDecoded0
        let documentParametersContainer = try containerValues.decodeIfPresent([IoTClientTypes.DocumentParameter?].self, forKey: .documentParameters)
        var documentParametersDecoded0:[IoTClientTypes.DocumentParameter]? = nil
        if let documentParametersContainer = documentParametersContainer {
            documentParametersDecoded0 = [IoTClientTypes.DocumentParameter]()
            for structure0 in documentParametersContainer {
                if let structure0 = structure0 {
                    documentParametersDecoded0?.append(structure0)
                }
            }
        }
        documentParameters = documentParametersDecoded0
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
    }
}

enum DescribeManagedJobTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMitigationActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let actionName = actionName else {
            return nil
        }
        return "/mitigationactions/actions/\(actionName.urlPercentEncoding())"
    }
}

public struct DescribeMitigationActionInput: Swift.Equatable {
    /// The friendly name that uniquely identifies the mitigation action.
    /// This member is required.
    public var actionName: Swift.String?

    public init(
        actionName: Swift.String? = nil
    )
    {
        self.actionName = actionName
    }
}

struct DescribeMitigationActionInputBody: Swift.Equatable {
}

extension DescribeMitigationActionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeMitigationActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMitigationActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionArn = output.actionArn
            self.actionId = output.actionId
            self.actionName = output.actionName
            self.actionParams = output.actionParams
            self.actionType = output.actionType
            self.creationDate = output.creationDate
            self.lastModifiedDate = output.lastModifiedDate
            self.roleArn = output.roleArn
        } else {
            self.actionArn = nil
            self.actionId = nil
            self.actionName = nil
            self.actionParams = nil
            self.actionType = nil
            self.creationDate = nil
            self.lastModifiedDate = nil
            self.roleArn = nil
        }
    }
}

public struct DescribeMitigationActionOutput: Swift.Equatable {
    /// The ARN that identifies this migration action.
    public var actionArn: Swift.String?
    /// A unique identifier for this action.
    public var actionId: Swift.String?
    /// The friendly name that uniquely identifies the mitigation action.
    public var actionName: Swift.String?
    /// Parameters that control how the mitigation action is applied, specific to the type of mitigation action.
    public var actionParams: IoTClientTypes.MitigationActionParams?
    /// The type of mitigation action.
    public var actionType: IoTClientTypes.MitigationActionType?
    /// The date and time when the mitigation action was added to your Amazon Web Services accounts.
    public var creationDate: ClientRuntime.Date?
    /// The date and time when the mitigation action was last changed.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The ARN of the IAM role used to apply this action.
    public var roleArn: Swift.String?

    public init(
        actionArn: Swift.String? = nil,
        actionId: Swift.String? = nil,
        actionName: Swift.String? = nil,
        actionParams: IoTClientTypes.MitigationActionParams? = nil,
        actionType: IoTClientTypes.MitigationActionType? = nil,
        creationDate: ClientRuntime.Date? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.actionArn = actionArn
        self.actionId = actionId
        self.actionName = actionName
        self.actionParams = actionParams
        self.actionType = actionType
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.roleArn = roleArn
    }
}

struct DescribeMitigationActionOutputBody: Swift.Equatable {
    let actionName: Swift.String?
    let actionType: IoTClientTypes.MitigationActionType?
    let actionArn: Swift.String?
    let actionId: Swift.String?
    let roleArn: Swift.String?
    let actionParams: IoTClientTypes.MitigationActionParams?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
}

extension DescribeMitigationActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionArn
        case actionId
        case actionName
        case actionParams
        case actionType
        case creationDate
        case lastModifiedDate
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MitigationActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let actionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionArn)
        actionArn = actionArnDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let actionParamsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MitigationActionParams.self, forKey: .actionParams)
        actionParams = actionParamsDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

enum DescribeMitigationActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProvisioningTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let templateName = templateName else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())"
    }
}

public struct DescribeProvisioningTemplateInput: Swift.Equatable {
    /// The name of the provisioning template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        templateName: Swift.String? = nil
    )
    {
        self.templateName = templateName
    }
}

struct DescribeProvisioningTemplateInputBody: Swift.Equatable {
}

extension DescribeProvisioningTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProvisioningTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProvisioningTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.defaultVersionId = output.defaultVersionId
            self.description = output.description
            self.enabled = output.enabled
            self.lastModifiedDate = output.lastModifiedDate
            self.preProvisioningHook = output.preProvisioningHook
            self.provisioningRoleArn = output.provisioningRoleArn
            self.templateArn = output.templateArn
            self.templateBody = output.templateBody
            self.templateName = output.templateName
            self.type = output.type
        } else {
            self.creationDate = nil
            self.defaultVersionId = nil
            self.description = nil
            self.enabled = false
            self.lastModifiedDate = nil
            self.preProvisioningHook = nil
            self.provisioningRoleArn = nil
            self.templateArn = nil
            self.templateBody = nil
            self.templateName = nil
            self.type = nil
        }
    }
}

public struct DescribeProvisioningTemplateOutput: Swift.Equatable {
    /// The date when the provisioning template was created.
    public var creationDate: ClientRuntime.Date?
    /// The default fleet template version ID.
    public var defaultVersionId: Swift.Int?
    /// The description of the provisioning template.
    public var description: Swift.String?
    /// True if the provisioning template is enabled, otherwise false.
    public var enabled: Swift.Bool
    /// The date when the provisioning template was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// Gets information about a pre-provisioned hook.
    public var preProvisioningHook: IoTClientTypes.ProvisioningHook?
    /// The ARN of the role associated with the provisioning template. This IoT role grants permission to provision a device.
    public var provisioningRoleArn: Swift.String?
    /// The ARN of the provisioning template.
    public var templateArn: Swift.String?
    /// The JSON formatted contents of the provisioning template.
    public var templateBody: Swift.String?
    /// The name of the provisioning template.
    public var templateName: Swift.String?
    /// The type you define in a provisioning template. You can create a template with only one type. You can't change the template type after its creation. The default value is FLEET_PROVISIONING. For more information about provisioning template, see: [Provisioning template](https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html).
    public var type: IoTClientTypes.TemplateType?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        defaultVersionId: Swift.Int? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool = false,
        lastModifiedDate: ClientRuntime.Date? = nil,
        preProvisioningHook: IoTClientTypes.ProvisioningHook? = nil,
        provisioningRoleArn: Swift.String? = nil,
        templateArn: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateName: Swift.String? = nil,
        type: IoTClientTypes.TemplateType? = nil
    )
    {
        self.creationDate = creationDate
        self.defaultVersionId = defaultVersionId
        self.description = description
        self.enabled = enabled
        self.lastModifiedDate = lastModifiedDate
        self.preProvisioningHook = preProvisioningHook
        self.provisioningRoleArn = provisioningRoleArn
        self.templateArn = templateArn
        self.templateBody = templateBody
        self.templateName = templateName
        self.type = type
    }
}

struct DescribeProvisioningTemplateOutputBody: Swift.Equatable {
    let templateArn: Swift.String?
    let templateName: Swift.String?
    let description: Swift.String?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
    let defaultVersionId: Swift.Int?
    let templateBody: Swift.String?
    let enabled: Swift.Bool
    let provisioningRoleArn: Swift.String?
    let preProvisioningHook: IoTClientTypes.ProvisioningHook?
    let type: IoTClientTypes.TemplateType?
}

extension DescribeProvisioningTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case defaultVersionId
        case description
        case enabled
        case lastModifiedDate
        case preProvisioningHook
        case provisioningRoleArn
        case templateArn
        case templateBody
        case templateName
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let provisioningRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningRoleArn)
        provisioningRoleArn = provisioningRoleArnDecoded
        let preProvisioningHookDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ProvisioningHook.self, forKey: .preProvisioningHook)
        preProvisioningHook = preProvisioningHookDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TemplateType.self, forKey: .type)
        type = typeDecoded
    }
}

enum DescribeProvisioningTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProvisioningTemplateVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let templateName = templateName else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())/versions/\(versionId)"
    }
}

public struct DescribeProvisioningTemplateVersionInput: Swift.Equatable {
    /// The template name.
    /// This member is required.
    public var templateName: Swift.String?
    /// The provisioning template version ID.
    /// This member is required.
    public var versionId: Swift.Int?

    public init(
        templateName: Swift.String? = nil,
        versionId: Swift.Int? = nil
    )
    {
        self.templateName = templateName
        self.versionId = versionId
    }
}

struct DescribeProvisioningTemplateVersionInputBody: Swift.Equatable {
}

extension DescribeProvisioningTemplateVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProvisioningTemplateVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProvisioningTemplateVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.isDefaultVersion = output.isDefaultVersion
            self.templateBody = output.templateBody
            self.versionId = output.versionId
        } else {
            self.creationDate = nil
            self.isDefaultVersion = false
            self.templateBody = nil
            self.versionId = nil
        }
    }
}

public struct DescribeProvisioningTemplateVersionOutput: Swift.Equatable {
    /// The date when the provisioning template version was created.
    public var creationDate: ClientRuntime.Date?
    /// True if the provisioning template version is the default version.
    public var isDefaultVersion: Swift.Bool
    /// The JSON formatted contents of the provisioning template version.
    public var templateBody: Swift.String?
    /// The provisioning template version ID.
    public var versionId: Swift.Int?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        isDefaultVersion: Swift.Bool = false,
        templateBody: Swift.String? = nil,
        versionId: Swift.Int? = nil
    )
    {
        self.creationDate = creationDate
        self.isDefaultVersion = isDefaultVersion
        self.templateBody = templateBody
        self.versionId = versionId
    }
}

struct DescribeProvisioningTemplateVersionOutputBody: Swift.Equatable {
    let versionId: Swift.Int?
    let creationDate: ClientRuntime.Date?
    let templateBody: Swift.String?
    let isDefaultVersion: Swift.Bool
}

extension DescribeProvisioningTemplateVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case isDefaultVersion
        case templateBody
        case versionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionId)
        versionId = versionIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let isDefaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefaultVersion) ?? false
        isDefaultVersion = isDefaultVersionDecoded
    }
}

enum DescribeProvisioningTemplateVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRoleAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let roleAlias = roleAlias else {
            return nil
        }
        return "/role-aliases/\(roleAlias.urlPercentEncoding())"
    }
}

public struct DescribeRoleAliasInput: Swift.Equatable {
    /// The role alias to describe.
    /// This member is required.
    public var roleAlias: Swift.String?

    public init(
        roleAlias: Swift.String? = nil
    )
    {
        self.roleAlias = roleAlias
    }
}

struct DescribeRoleAliasInputBody: Swift.Equatable {
}

extension DescribeRoleAliasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRoleAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRoleAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.roleAliasDescription = output.roleAliasDescription
        } else {
            self.roleAliasDescription = nil
        }
    }
}

public struct DescribeRoleAliasOutput: Swift.Equatable {
    /// The role alias description.
    public var roleAliasDescription: IoTClientTypes.RoleAliasDescription?

    public init(
        roleAliasDescription: IoTClientTypes.RoleAliasDescription? = nil
    )
    {
        self.roleAliasDescription = roleAliasDescription
    }
}

struct DescribeRoleAliasOutputBody: Swift.Equatable {
    let roleAliasDescription: IoTClientTypes.RoleAliasDescription?
}

extension DescribeRoleAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleAliasDescription
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleAliasDescriptionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.RoleAliasDescription.self, forKey: .roleAliasDescription)
        roleAliasDescription = roleAliasDescriptionDecoded
    }
}

enum DescribeRoleAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeScheduledAuditInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let scheduledAuditName = scheduledAuditName else {
            return nil
        }
        return "/audit/scheduledaudits/\(scheduledAuditName.urlPercentEncoding())"
    }
}

public struct DescribeScheduledAuditInput: Swift.Equatable {
    /// The name of the scheduled audit whose information you want to get.
    /// This member is required.
    public var scheduledAuditName: Swift.String?

    public init(
        scheduledAuditName: Swift.String? = nil
    )
    {
        self.scheduledAuditName = scheduledAuditName
    }
}

struct DescribeScheduledAuditInputBody: Swift.Equatable {
}

extension DescribeScheduledAuditInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeScheduledAuditOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeScheduledAuditOutputBody = try responseDecoder.decode(responseBody: data)
            self.dayOfMonth = output.dayOfMonth
            self.dayOfWeek = output.dayOfWeek
            self.frequency = output.frequency
            self.scheduledAuditArn = output.scheduledAuditArn
            self.scheduledAuditName = output.scheduledAuditName
            self.targetCheckNames = output.targetCheckNames
        } else {
            self.dayOfMonth = nil
            self.dayOfWeek = nil
            self.frequency = nil
            self.scheduledAuditArn = nil
            self.scheduledAuditName = nil
            self.targetCheckNames = nil
        }
    }
}

public struct DescribeScheduledAuditOutput: Swift.Equatable {
    /// The day of the month on which the scheduled audit takes place. This is will be 1 through 31 or LAST. If days 29-31 are specified, and the month does not have that many days, the audit takes place on the LAST day of the month.
    public var dayOfMonth: Swift.String?
    /// The day of the week on which the scheduled audit takes place, either one of SUN, MON, TUE, WED, THU, FRI, or SAT.
    public var dayOfWeek: IoTClientTypes.DayOfWeek?
    /// How often the scheduled audit takes place, either one of DAILY, WEEKLY, BIWEEKLY, or MONTHLY. The start time of each audit is determined by the system.
    public var frequency: IoTClientTypes.AuditFrequency?
    /// The ARN of the scheduled audit.
    public var scheduledAuditArn: Swift.String?
    /// The name of the scheduled audit.
    public var scheduledAuditName: Swift.String?
    /// Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    public var targetCheckNames: [Swift.String]?

    public init(
        dayOfMonth: Swift.String? = nil,
        dayOfWeek: IoTClientTypes.DayOfWeek? = nil,
        frequency: IoTClientTypes.AuditFrequency? = nil,
        scheduledAuditArn: Swift.String? = nil,
        scheduledAuditName: Swift.String? = nil,
        targetCheckNames: [Swift.String]? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.frequency = frequency
        self.scheduledAuditArn = scheduledAuditArn
        self.scheduledAuditName = scheduledAuditName
        self.targetCheckNames = targetCheckNames
    }
}

struct DescribeScheduledAuditOutputBody: Swift.Equatable {
    let frequency: IoTClientTypes.AuditFrequency?
    let dayOfMonth: Swift.String?
    let dayOfWeek: IoTClientTypes.DayOfWeek?
    let targetCheckNames: [Swift.String]?
    let scheduledAuditName: Swift.String?
    let scheduledAuditArn: Swift.String?
}

extension DescribeScheduledAuditOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth
        case dayOfWeek
        case frequency
        case scheduledAuditArn
        case scheduledAuditName
        case targetCheckNames
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frequencyDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let targetCheckNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetCheckNames)
        var targetCheckNamesDecoded0:[Swift.String]? = nil
        if let targetCheckNamesContainer = targetCheckNamesContainer {
            targetCheckNamesDecoded0 = [Swift.String]()
            for string0 in targetCheckNamesContainer {
                if let string0 = string0 {
                    targetCheckNamesDecoded0?.append(string0)
                }
            }
        }
        targetCheckNames = targetCheckNamesDecoded0
        let scheduledAuditNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledAuditName)
        scheduledAuditName = scheduledAuditNameDecoded
        let scheduledAuditArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledAuditArn)
        scheduledAuditArn = scheduledAuditArnDecoded
    }
}

enum DescribeScheduledAuditOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let securityProfileName = securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())"
    }
}

public struct DescribeSecurityProfileInput: Swift.Equatable {
    /// The name of the security profile whose information you want to get.
    /// This member is required.
    public var securityProfileName: Swift.String?

    public init(
        securityProfileName: Swift.String? = nil
    )
    {
        self.securityProfileName = securityProfileName
    }
}

struct DescribeSecurityProfileInputBody: Swift.Equatable {
}

extension DescribeSecurityProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSecurityProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSecurityProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.additionalMetricsToRetain = output.additionalMetricsToRetain
            self.additionalMetricsToRetainV2 = output.additionalMetricsToRetainV2
            self.alertTargets = output.alertTargets
            self.behaviors = output.behaviors
            self.creationDate = output.creationDate
            self.lastModifiedDate = output.lastModifiedDate
            self.securityProfileArn = output.securityProfileArn
            self.securityProfileDescription = output.securityProfileDescription
            self.securityProfileName = output.securityProfileName
            self.version = output.version
        } else {
            self.additionalMetricsToRetain = nil
            self.additionalMetricsToRetainV2 = nil
            self.alertTargets = nil
            self.behaviors = nil
            self.creationDate = nil
            self.lastModifiedDate = nil
            self.securityProfileArn = nil
            self.securityProfileDescription = nil
            self.securityProfileName = nil
            self.version = 0
        }
    }
}

public struct DescribeSecurityProfileOutput: Swift.Equatable {
    /// Please use [DescribeSecurityProfileResponse$additionalMetricsToRetainV2] instead. A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here.
    @available(*, deprecated, message: "Use additionalMetricsToRetainV2.")
    public var additionalMetricsToRetain: [Swift.String]?
    /// A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here.
    public var additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]?
    /// Where the alerts are sent. (Alerts are always sent to the console.)
    public var alertTargets: [Swift.String:IoTClientTypes.AlertTarget]?
    /// Specifies the behaviors that, when violated by a device (thing), cause an alert.
    public var behaviors: [IoTClientTypes.Behavior]?
    /// The time the security profile was created.
    public var creationDate: ClientRuntime.Date?
    /// The time the security profile was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The ARN of the security profile.
    public var securityProfileArn: Swift.String?
    /// A description of the security profile (associated with the security profile when it was created or updated).
    public var securityProfileDescription: Swift.String?
    /// The name of the security profile.
    public var securityProfileName: Swift.String?
    /// The version of the security profile. A new version is generated whenever the security profile is updated.
    public var version: Swift.Int

    public init(
        additionalMetricsToRetain: [Swift.String]? = nil,
        additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]? = nil,
        alertTargets: [Swift.String:IoTClientTypes.AlertTarget]? = nil,
        behaviors: [IoTClientTypes.Behavior]? = nil,
        creationDate: ClientRuntime.Date? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        securityProfileArn: Swift.String? = nil,
        securityProfileDescription: Swift.String? = nil,
        securityProfileName: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.additionalMetricsToRetain = additionalMetricsToRetain
        self.additionalMetricsToRetainV2 = additionalMetricsToRetainV2
        self.alertTargets = alertTargets
        self.behaviors = behaviors
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.securityProfileArn = securityProfileArn
        self.securityProfileDescription = securityProfileDescription
        self.securityProfileName = securityProfileName
        self.version = version
    }
}

struct DescribeSecurityProfileOutputBody: Swift.Equatable {
    let securityProfileName: Swift.String?
    let securityProfileArn: Swift.String?
    let securityProfileDescription: Swift.String?
    let behaviors: [IoTClientTypes.Behavior]?
    let alertTargets: [Swift.String:IoTClientTypes.AlertTarget]?
    let additionalMetricsToRetain: [Swift.String]?
    let additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]?
    let version: Swift.Int
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
}

extension DescribeSecurityProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetricsToRetain
        case additionalMetricsToRetainV2
        case alertTargets
        case behaviors
        case creationDate
        case lastModifiedDate
        case securityProfileArn
        case securityProfileDescription
        case securityProfileName
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let securityProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileArn)
        securityProfileArn = securityProfileArnDecoded
        let securityProfileDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileDescription)
        securityProfileDescription = securityProfileDescriptionDecoded
        let behaviorsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Behavior?].self, forKey: .behaviors)
        var behaviorsDecoded0:[IoTClientTypes.Behavior]? = nil
        if let behaviorsContainer = behaviorsContainer {
            behaviorsDecoded0 = [IoTClientTypes.Behavior]()
            for structure0 in behaviorsContainer {
                if let structure0 = structure0 {
                    behaviorsDecoded0?.append(structure0)
                }
            }
        }
        behaviors = behaviorsDecoded0
        let alertTargetsContainer = try containerValues.decodeIfPresent([Swift.String: IoTClientTypes.AlertTarget?].self, forKey: .alertTargets)
        var alertTargetsDecoded0: [Swift.String:IoTClientTypes.AlertTarget]? = nil
        if let alertTargetsContainer = alertTargetsContainer {
            alertTargetsDecoded0 = [Swift.String:IoTClientTypes.AlertTarget]()
            for (key0, alerttarget0) in alertTargetsContainer {
                if let alerttarget0 = alerttarget0 {
                    alertTargetsDecoded0?[key0] = alerttarget0
                }
            }
        }
        alertTargets = alertTargetsDecoded0
        let additionalMetricsToRetainContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .additionalMetricsToRetain)
        var additionalMetricsToRetainDecoded0:[Swift.String]? = nil
        if let additionalMetricsToRetainContainer = additionalMetricsToRetainContainer {
            additionalMetricsToRetainDecoded0 = [Swift.String]()
            for string0 in additionalMetricsToRetainContainer {
                if let string0 = string0 {
                    additionalMetricsToRetainDecoded0?.append(string0)
                }
            }
        }
        additionalMetricsToRetain = additionalMetricsToRetainDecoded0
        let additionalMetricsToRetainV2Container = try containerValues.decodeIfPresent([IoTClientTypes.MetricToRetain?].self, forKey: .additionalMetricsToRetainV2)
        var additionalMetricsToRetainV2Decoded0:[IoTClientTypes.MetricToRetain]? = nil
        if let additionalMetricsToRetainV2Container = additionalMetricsToRetainV2Container {
            additionalMetricsToRetainV2Decoded0 = [IoTClientTypes.MetricToRetain]()
            for structure0 in additionalMetricsToRetainV2Container {
                if let structure0 = structure0 {
                    additionalMetricsToRetainV2Decoded0?.append(structure0)
                }
            }
        }
        additionalMetricsToRetainV2 = additionalMetricsToRetainV2Decoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

enum DescribeSecurityProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let streamId = streamId else {
            return nil
        }
        return "/streams/\(streamId.urlPercentEncoding())"
    }
}

public struct DescribeStreamInput: Swift.Equatable {
    /// The stream ID.
    /// This member is required.
    public var streamId: Swift.String?

    public init(
        streamId: Swift.String? = nil
    )
    {
        self.streamId = streamId
    }
}

struct DescribeStreamInputBody: Swift.Equatable {
}

extension DescribeStreamInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamInfo = output.streamInfo
        } else {
            self.streamInfo = nil
        }
    }
}

public struct DescribeStreamOutput: Swift.Equatable {
    /// Information about the stream.
    public var streamInfo: IoTClientTypes.StreamInfo?

    public init(
        streamInfo: IoTClientTypes.StreamInfo? = nil
    )
    {
        self.streamInfo = streamInfo
    }
}

struct DescribeStreamOutputBody: Swift.Equatable {
    let streamInfo: IoTClientTypes.StreamInfo?
}

extension DescribeStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamInfo
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamInfoDecoded = try containerValues.decodeIfPresent(IoTClientTypes.StreamInfo.self, forKey: .streamInfo)
        streamInfo = streamInfoDecoded
    }
}

enum DescribeStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeThingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingGroupName = thingGroupName else {
            return nil
        }
        return "/thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

public struct DescribeThingGroupInput: Swift.Equatable {
    /// The name of the thing group.
    /// This member is required.
    public var thingGroupName: Swift.String?

    public init(
        thingGroupName: Swift.String? = nil
    )
    {
        self.thingGroupName = thingGroupName
    }
}

struct DescribeThingGroupInputBody: Swift.Equatable {
}

extension DescribeThingGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeThingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeThingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.indexName = output.indexName
            self.queryString = output.queryString
            self.queryVersion = output.queryVersion
            self.status = output.status
            self.thingGroupArn = output.thingGroupArn
            self.thingGroupId = output.thingGroupId
            self.thingGroupMetadata = output.thingGroupMetadata
            self.thingGroupName = output.thingGroupName
            self.thingGroupProperties = output.thingGroupProperties
            self.version = output.version
        } else {
            self.indexName = nil
            self.queryString = nil
            self.queryVersion = nil
            self.status = nil
            self.thingGroupArn = nil
            self.thingGroupId = nil
            self.thingGroupMetadata = nil
            self.thingGroupName = nil
            self.thingGroupProperties = nil
            self.version = 0
        }
    }
}

public struct DescribeThingGroupOutput: Swift.Equatable {
    /// The dynamic thing group index name.
    public var indexName: Swift.String?
    /// The dynamic thing group search query string.
    public var queryString: Swift.String?
    /// The dynamic thing group query version.
    public var queryVersion: Swift.String?
    /// The dynamic thing group status.
    public var status: IoTClientTypes.DynamicGroupStatus?
    /// The thing group ARN.
    public var thingGroupArn: Swift.String?
    /// The thing group ID.
    public var thingGroupId: Swift.String?
    /// Thing group metadata.
    public var thingGroupMetadata: IoTClientTypes.ThingGroupMetadata?
    /// The name of the thing group.
    public var thingGroupName: Swift.String?
    /// The thing group properties.
    public var thingGroupProperties: IoTClientTypes.ThingGroupProperties?
    /// The version of the thing group.
    public var version: Swift.Int

    public init(
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        status: IoTClientTypes.DynamicGroupStatus? = nil,
        thingGroupArn: Swift.String? = nil,
        thingGroupId: Swift.String? = nil,
        thingGroupMetadata: IoTClientTypes.ThingGroupMetadata? = nil,
        thingGroupName: Swift.String? = nil,
        thingGroupProperties: IoTClientTypes.ThingGroupProperties? = nil,
        version: Swift.Int = 0
    )
    {
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.status = status
        self.thingGroupArn = thingGroupArn
        self.thingGroupId = thingGroupId
        self.thingGroupMetadata = thingGroupMetadata
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
        self.version = version
    }
}

struct DescribeThingGroupOutputBody: Swift.Equatable {
    let thingGroupName: Swift.String?
    let thingGroupId: Swift.String?
    let thingGroupArn: Swift.String?
    let version: Swift.Int
    let thingGroupProperties: IoTClientTypes.ThingGroupProperties?
    let thingGroupMetadata: IoTClientTypes.ThingGroupMetadata?
    let indexName: Swift.String?
    let queryString: Swift.String?
    let queryVersion: Swift.String?
    let status: IoTClientTypes.DynamicGroupStatus?
}

extension DescribeThingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexName
        case queryString
        case queryVersion
        case status
        case thingGroupArn
        case thingGroupId
        case thingGroupMetadata
        case thingGroupName
        case thingGroupProperties
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupName)
        thingGroupName = thingGroupNameDecoded
        let thingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupId)
        thingGroupId = thingGroupIdDecoded
        let thingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupArn)
        thingGroupArn = thingGroupArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let thingGroupPropertiesDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingGroupProperties.self, forKey: .thingGroupProperties)
        thingGroupProperties = thingGroupPropertiesDecoded
        let thingGroupMetadataDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingGroupMetadata.self, forKey: .thingGroupMetadata)
        thingGroupMetadata = thingGroupMetadataDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DynamicGroupStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DescribeThingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())"
    }
}

/// The input for the DescribeThing operation.
public struct DescribeThingInput: Swift.Equatable {
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        thingName: Swift.String? = nil
    )
    {
        self.thingName = thingName
    }
}

struct DescribeThingInputBody: Swift.Equatable {
}

extension DescribeThingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeThingOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
            self.billingGroupName = output.billingGroupName
            self.defaultClientId = output.defaultClientId
            self.thingArn = output.thingArn
            self.thingId = output.thingId
            self.thingName = output.thingName
            self.thingTypeName = output.thingTypeName
            self.version = output.version
        } else {
            self.attributes = nil
            self.billingGroupName = nil
            self.defaultClientId = nil
            self.thingArn = nil
            self.thingId = nil
            self.thingName = nil
            self.thingTypeName = nil
            self.version = 0
        }
    }
}

/// The output from the DescribeThing operation.
public struct DescribeThingOutput: Swift.Equatable {
    /// The thing attributes.
    public var attributes: [Swift.String:Swift.String]?
    /// The name of the billing group the thing belongs to.
    public var billingGroupName: Swift.String?
    /// The default MQTT client ID. For a typical device, the thing name is also used as the default MQTT client ID. Although we dont require a mapping between a thing's registry name and its use of MQTT client IDs, certificates, or shadow state, we recommend that you choose a thing name and use it as the MQTT client ID for the registry and the Device Shadow service. This lets you better organize your IoT fleet without removing the flexibility of the underlying device certificate model or shadows.
    public var defaultClientId: Swift.String?
    /// The ARN of the thing to describe.
    public var thingArn: Swift.String?
    /// The ID of the thing to describe.
    public var thingId: Swift.String?
    /// The name of the thing.
    public var thingName: Swift.String?
    /// The thing type name.
    public var thingTypeName: Swift.String?
    /// The current version of the thing record in the registry. To avoid unintentional changes to the information in the registry, you can pass the version information in the expectedVersion parameter of the UpdateThing and DeleteThing calls.
    public var version: Swift.Int

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        billingGroupName: Swift.String? = nil,
        defaultClientId: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        thingId: Swift.String? = nil,
        thingName: Swift.String? = nil,
        thingTypeName: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.attributes = attributes
        self.billingGroupName = billingGroupName
        self.defaultClientId = defaultClientId
        self.thingArn = thingArn
        self.thingId = thingId
        self.thingName = thingName
        self.thingTypeName = thingTypeName
        self.version = version
    }
}

struct DescribeThingOutputBody: Swift.Equatable {
    let defaultClientId: Swift.String?
    let thingName: Swift.String?
    let thingId: Swift.String?
    let thingArn: Swift.String?
    let thingTypeName: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let version: Swift.Int
    let billingGroupName: Swift.String?
}

extension DescribeThingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case billingGroupName
        case defaultClientId
        case thingArn
        case thingId
        case thingName
        case thingTypeName
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultClientId)
        defaultClientId = defaultClientIdDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingId)
        thingId = thingIdDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let billingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupName)
        billingGroupName = billingGroupNameDecoded
    }
}

enum DescribeThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeThingRegistrationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/thing-registration-tasks/\(taskId.urlPercentEncoding())"
    }
}

public struct DescribeThingRegistrationTaskInput: Swift.Equatable {
    /// The task ID.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct DescribeThingRegistrationTaskInputBody: Swift.Equatable {
}

extension DescribeThingRegistrationTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeThingRegistrationTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeThingRegistrationTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.failureCount = output.failureCount
            self.inputFileBucket = output.inputFileBucket
            self.inputFileKey = output.inputFileKey
            self.lastModifiedDate = output.lastModifiedDate
            self.message = output.message
            self.percentageProgress = output.percentageProgress
            self.roleArn = output.roleArn
            self.status = output.status
            self.successCount = output.successCount
            self.taskId = output.taskId
            self.templateBody = output.templateBody
        } else {
            self.creationDate = nil
            self.failureCount = 0
            self.inputFileBucket = nil
            self.inputFileKey = nil
            self.lastModifiedDate = nil
            self.message = nil
            self.percentageProgress = 0
            self.roleArn = nil
            self.status = nil
            self.successCount = 0
            self.taskId = nil
            self.templateBody = nil
        }
    }
}

public struct DescribeThingRegistrationTaskOutput: Swift.Equatable {
    /// The task creation date.
    public var creationDate: ClientRuntime.Date?
    /// The number of things that failed to be provisioned.
    public var failureCount: Swift.Int
    /// The S3 bucket that contains the input file.
    public var inputFileBucket: Swift.String?
    /// The input file key.
    public var inputFileKey: Swift.String?
    /// The date when the task was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The message.
    public var message: Swift.String?
    /// The progress of the bulk provisioning task expressed as a percentage.
    public var percentageProgress: Swift.Int
    /// The role ARN that grants access to the input file bucket.
    public var roleArn: Swift.String?
    /// The status of the bulk thing provisioning task.
    public var status: IoTClientTypes.Status?
    /// The number of things successfully provisioned.
    public var successCount: Swift.Int
    /// The task ID.
    public var taskId: Swift.String?
    /// The task's template.
    public var templateBody: Swift.String?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        failureCount: Swift.Int = 0,
        inputFileBucket: Swift.String? = nil,
        inputFileKey: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        message: Swift.String? = nil,
        percentageProgress: Swift.Int = 0,
        roleArn: Swift.String? = nil,
        status: IoTClientTypes.Status? = nil,
        successCount: Swift.Int = 0,
        taskId: Swift.String? = nil,
        templateBody: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.failureCount = failureCount
        self.inputFileBucket = inputFileBucket
        self.inputFileKey = inputFileKey
        self.lastModifiedDate = lastModifiedDate
        self.message = message
        self.percentageProgress = percentageProgress
        self.roleArn = roleArn
        self.status = status
        self.successCount = successCount
        self.taskId = taskId
        self.templateBody = templateBody
    }
}

struct DescribeThingRegistrationTaskOutputBody: Swift.Equatable {
    let taskId: Swift.String?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
    let templateBody: Swift.String?
    let inputFileBucket: Swift.String?
    let inputFileKey: Swift.String?
    let roleArn: Swift.String?
    let status: IoTClientTypes.Status?
    let message: Swift.String?
    let successCount: Swift.Int
    let failureCount: Swift.Int
    let percentageProgress: Swift.Int
}

extension DescribeThingRegistrationTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case failureCount
        case inputFileBucket
        case inputFileKey
        case lastModifiedDate
        case message
        case percentageProgress
        case roleArn
        case status
        case successCount
        case taskId
        case templateBody
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let inputFileBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputFileBucket)
        inputFileBucket = inputFileBucketDecoded
        let inputFileKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputFileKey)
        inputFileKey = inputFileKeyDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let successCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .successCount) ?? 0
        successCount = successCountDecoded
        let failureCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failureCount) ?? 0
        failureCount = failureCountDecoded
        let percentageProgressDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentageProgress) ?? 0
        percentageProgress = percentageProgressDecoded
    }
}

enum DescribeThingRegistrationTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeThingTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingTypeName = thingTypeName else {
            return nil
        }
        return "/thing-types/\(thingTypeName.urlPercentEncoding())"
    }
}

/// The input for the DescribeThingType operation.
public struct DescribeThingTypeInput: Swift.Equatable {
    /// The name of the thing type.
    /// This member is required.
    public var thingTypeName: Swift.String?

    public init(
        thingTypeName: Swift.String? = nil
    )
    {
        self.thingTypeName = thingTypeName
    }
}

struct DescribeThingTypeInputBody: Swift.Equatable {
}

extension DescribeThingTypeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeThingTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeThingTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.thingTypeArn = output.thingTypeArn
            self.thingTypeId = output.thingTypeId
            self.thingTypeMetadata = output.thingTypeMetadata
            self.thingTypeName = output.thingTypeName
            self.thingTypeProperties = output.thingTypeProperties
        } else {
            self.thingTypeArn = nil
            self.thingTypeId = nil
            self.thingTypeMetadata = nil
            self.thingTypeName = nil
            self.thingTypeProperties = nil
        }
    }
}

/// The output for the DescribeThingType operation.
public struct DescribeThingTypeOutput: Swift.Equatable {
    /// The thing type ARN.
    public var thingTypeArn: Swift.String?
    /// The thing type ID.
    public var thingTypeId: Swift.String?
    /// The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when it was deprecated.
    public var thingTypeMetadata: IoTClientTypes.ThingTypeMetadata?
    /// The name of the thing type.
    public var thingTypeName: Swift.String?
    /// The ThingTypeProperties contains information about the thing type including description, and a list of searchable thing attribute names.
    public var thingTypeProperties: IoTClientTypes.ThingTypeProperties?

    public init(
        thingTypeArn: Swift.String? = nil,
        thingTypeId: Swift.String? = nil,
        thingTypeMetadata: IoTClientTypes.ThingTypeMetadata? = nil,
        thingTypeName: Swift.String? = nil,
        thingTypeProperties: IoTClientTypes.ThingTypeProperties? = nil
    )
    {
        self.thingTypeArn = thingTypeArn
        self.thingTypeId = thingTypeId
        self.thingTypeMetadata = thingTypeMetadata
        self.thingTypeName = thingTypeName
        self.thingTypeProperties = thingTypeProperties
    }
}

struct DescribeThingTypeOutputBody: Swift.Equatable {
    let thingTypeName: Swift.String?
    let thingTypeId: Swift.String?
    let thingTypeArn: Swift.String?
    let thingTypeProperties: IoTClientTypes.ThingTypeProperties?
    let thingTypeMetadata: IoTClientTypes.ThingTypeMetadata?
}

extension DescribeThingTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingTypeArn
        case thingTypeId
        case thingTypeMetadata
        case thingTypeName
        case thingTypeProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let thingTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeId)
        thingTypeId = thingTypeIdDecoded
        let thingTypeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeArn)
        thingTypeArn = thingTypeArnDecoded
        let thingTypePropertiesDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingTypeProperties.self, forKey: .thingTypeProperties)
        thingTypeProperties = thingTypePropertiesDecoded
        let thingTypeMetadataDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingTypeMetadata.self, forKey: .thingTypeMetadata)
        thingTypeMetadata = thingTypeMetadataDecoded
    }
}

enum DescribeThingTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Destination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Destination = self.s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DestinationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

extension IoTClientTypes {
    /// Describes the location of the updated firmware.
    public struct Destination: Swift.Equatable {
        /// Describes the location in S3 of the updated firmware.
        public var s3Destination: IoTClientTypes.S3Destination?

        public init(
            s3Destination: IoTClientTypes.S3Destination? = nil
        )
        {
            self.s3Destination = s3Destination
        }
    }

}

extension DetachPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension DetachPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let policyName = policyName else {
            return nil
        }
        return "/target-policies/\(policyName.urlPercentEncoding())"
    }
}

public struct DetachPolicyInput: Swift.Equatable {
    /// The policy to detach.
    /// This member is required.
    public var policyName: Swift.String?
    /// The target from which the policy will be detached.
    /// This member is required.
    public var target: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.target = target
    }
}

struct DetachPolicyInputBody: Swift.Equatable {
    let target: Swift.String?
}

extension DetachPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case target
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension DetachPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DetachPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DetachPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetachPrincipalPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let principal = principal {
            items.add(Header(name: "x-amzn-iot-principal", value: Swift.String(principal)))
        }
        return items
    }
}

extension DetachPrincipalPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let policyName = policyName else {
            return nil
        }
        return "/principal-policies/\(policyName.urlPercentEncoding())"
    }
}

/// The input for the DetachPrincipalPolicy operation.
public struct DetachPrincipalPolicyInput: Swift.Equatable {
    /// The name of the policy to detach.
    /// This member is required.
    public var policyName: Swift.String?
    /// The principal. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    /// This member is required.
    public var principal: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        principal: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.principal = principal
    }
}

struct DetachPrincipalPolicyInputBody: Swift.Equatable {
}

extension DetachPrincipalPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DetachPrincipalPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DetachPrincipalPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DetachPrincipalPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetachSecurityProfileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let securityProfileTargetArn = securityProfileTargetArn else {
                let message = "Creating a URL Query Item failed. securityProfileTargetArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let securityProfileTargetArnQueryItem = ClientRuntime.URLQueryItem(name: "securityProfileTargetArn".urlPercentEncoding(), value: Swift.String(securityProfileTargetArn).urlPercentEncoding())
            items.append(securityProfileTargetArnQueryItem)
            return items
        }
    }
}

extension DetachSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let securityProfileName = securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())/targets"
    }
}

public struct DetachSecurityProfileInput: Swift.Equatable {
    /// The security profile that is detached.
    /// This member is required.
    public var securityProfileName: Swift.String?
    /// The ARN of the thing group from which the security profile is detached.
    /// This member is required.
    public var securityProfileTargetArn: Swift.String?

    public init(
        securityProfileName: Swift.String? = nil,
        securityProfileTargetArn: Swift.String? = nil
    )
    {
        self.securityProfileName = securityProfileName
        self.securityProfileTargetArn = securityProfileTargetArn
    }
}

struct DetachSecurityProfileInputBody: Swift.Equatable {
}

extension DetachSecurityProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DetachSecurityProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DetachSecurityProfileOutput: Swift.Equatable {

    public init() { }
}

enum DetachSecurityProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetachThingPrincipalInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let principal = principal {
            items.add(Header(name: "x-amzn-principal", value: Swift.String(principal)))
        }
        return items
    }
}

extension DetachThingPrincipalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/principals"
    }
}

/// The input for the DetachThingPrincipal operation.
public struct DetachThingPrincipalInput: Swift.Equatable {
    /// If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.
    /// This member is required.
    public var principal: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        principal: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.principal = principal
        self.thingName = thingName
    }
}

struct DetachThingPrincipalInputBody: Swift.Equatable {
}

extension DetachThingPrincipalInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DetachThingPrincipalOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The output from the DetachThingPrincipal operation.
public struct DetachThingPrincipalOutput: Swift.Equatable {

    public init() { }
}

enum DetachThingPrincipalOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.DetectMitigationActionExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName
        case errorCode
        case executionEndDate
        case executionStartDate
        case message
        case status
        case taskId
        case thingName
        case violationId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let executionEndDate = self.executionEndDate {
            try encodeContainer.encodeTimestamp(executionEndDate, format: .epochSeconds, forKey: .executionEndDate)
        }
        if let executionStartDate = self.executionStartDate {
            try encodeContainer.encodeTimestamp(executionStartDate, format: .epochSeconds, forKey: .executionStartDate)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
        if let violationId = self.violationId {
            try encodeContainer.encode(violationId, forKey: .violationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let violationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationId)
        violationId = violationIdDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let executionStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .executionStartDate)
        executionStartDate = executionStartDateDecoded
        let executionEndDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .executionEndDate)
        executionEndDate = executionEndDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DetectMitigationActionExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes {
    /// Describes which mitigation actions should be executed.
    public struct DetectMitigationActionExecution: Swift.Equatable {
        /// The friendly name that uniquely identifies the mitigation action.
        public var actionName: Swift.String?
        /// The error code of a mitigation action.
        public var errorCode: Swift.String?
        /// The date a mitigation action ended.
        public var executionEndDate: ClientRuntime.Date?
        /// The date a mitigation action was started.
        public var executionStartDate: ClientRuntime.Date?
        /// The message of a mitigation action.
        public var message: Swift.String?
        /// The status of a mitigation action.
        public var status: IoTClientTypes.DetectMitigationActionExecutionStatus?
        /// The unique identifier of the task.
        public var taskId: Swift.String?
        /// The name of the thing.
        public var thingName: Swift.String?
        /// The unique identifier of the violation.
        public var violationId: Swift.String?

        public init(
            actionName: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            executionEndDate: ClientRuntime.Date? = nil,
            executionStartDate: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            status: IoTClientTypes.DetectMitigationActionExecutionStatus? = nil,
            taskId: Swift.String? = nil,
            thingName: Swift.String? = nil,
            violationId: Swift.String? = nil
        )
        {
            self.actionName = actionName
            self.errorCode = errorCode
            self.executionEndDate = executionEndDate
            self.executionStartDate = executionStartDate
            self.message = message
            self.status = status
            self.taskId = taskId
            self.thingName = thingName
            self.violationId = violationId
        }
    }

}

extension IoTClientTypes {
    public enum DetectMitigationActionExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case skipped
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectMitigationActionExecutionStatus] {
            return [
                .failed,
                .inProgress,
                .skipped,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .skipped: return "SKIPPED"
            case .successful: return "SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetectMitigationActionExecutionStatus(rawValue: rawValue) ?? DetectMitigationActionExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.DetectMitigationActionsTaskStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionsExecuted
        case actionsFailed
        case actionsSkipped
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionsExecuted = self.actionsExecuted {
            try encodeContainer.encode(actionsExecuted, forKey: .actionsExecuted)
        }
        if let actionsFailed = self.actionsFailed {
            try encodeContainer.encode(actionsFailed, forKey: .actionsFailed)
        }
        if let actionsSkipped = self.actionsSkipped {
            try encodeContainer.encode(actionsSkipped, forKey: .actionsSkipped)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsExecutedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .actionsExecuted)
        actionsExecuted = actionsExecutedDecoded
        let actionsSkippedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .actionsSkipped)
        actionsSkipped = actionsSkippedDecoded
        let actionsFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .actionsFailed)
        actionsFailed = actionsFailedDecoded
    }
}

extension IoTClientTypes {
    /// The statistics of a mitigation action task.
    public struct DetectMitigationActionsTaskStatistics: Swift.Equatable {
        /// The actions that were performed.
        public var actionsExecuted: Swift.Int?
        /// The actions that failed.
        public var actionsFailed: Swift.Int?
        /// The actions that were skipped.
        public var actionsSkipped: Swift.Int?

        public init(
            actionsExecuted: Swift.Int? = nil,
            actionsFailed: Swift.Int? = nil,
            actionsSkipped: Swift.Int? = nil
        )
        {
            self.actionsExecuted = actionsExecuted
            self.actionsFailed = actionsFailed
            self.actionsSkipped = actionsSkipped
        }
    }

}

extension IoTClientTypes {
    public enum DetectMitigationActionsTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectMitigationActionsTaskStatus] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .successful: return "SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetectMitigationActionsTaskStatus(rawValue: rawValue) ?? DetectMitigationActionsTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.DetectMitigationActionsTaskSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionsDefinition
        case onlyActiveViolationsIncluded
        case suppressedAlertsIncluded
        case target
        case taskEndTime
        case taskId
        case taskStartTime
        case taskStatistics
        case taskStatus
        case violationEventOccurrenceRange
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionsDefinition = actionsDefinition {
            var actionsDefinitionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionsDefinition)
            for mitigationaction0 in actionsDefinition {
                try actionsDefinitionContainer.encode(mitigationaction0)
            }
        }
        if onlyActiveViolationsIncluded != false {
            try encodeContainer.encode(onlyActiveViolationsIncluded, forKey: .onlyActiveViolationsIncluded)
        }
        if suppressedAlertsIncluded != false {
            try encodeContainer.encode(suppressedAlertsIncluded, forKey: .suppressedAlertsIncluded)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let taskEndTime = self.taskEndTime {
            try encodeContainer.encodeTimestamp(taskEndTime, format: .epochSeconds, forKey: .taskEndTime)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStartTime = self.taskStartTime {
            try encodeContainer.encodeTimestamp(taskStartTime, format: .epochSeconds, forKey: .taskStartTime)
        }
        if let taskStatistics = self.taskStatistics {
            try encodeContainer.encode(taskStatistics, forKey: .taskStatistics)
        }
        if let taskStatus = self.taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
        if let violationEventOccurrenceRange = self.violationEventOccurrenceRange {
            try encodeContainer.encode(violationEventOccurrenceRange, forKey: .violationEventOccurrenceRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DetectMitigationActionsTaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let taskStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .taskStartTime)
        taskStartTime = taskStartTimeDecoded
        let taskEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .taskEndTime)
        taskEndTime = taskEndTimeDecoded
        let targetDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DetectMitigationActionsTaskTarget.self, forKey: .target)
        target = targetDecoded
        let violationEventOccurrenceRangeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ViolationEventOccurrenceRange.self, forKey: .violationEventOccurrenceRange)
        violationEventOccurrenceRange = violationEventOccurrenceRangeDecoded
        let onlyActiveViolationsIncludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .onlyActiveViolationsIncluded) ?? false
        onlyActiveViolationsIncluded = onlyActiveViolationsIncludedDecoded
        let suppressedAlertsIncludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .suppressedAlertsIncluded) ?? false
        suppressedAlertsIncluded = suppressedAlertsIncludedDecoded
        let actionsDefinitionContainer = try containerValues.decodeIfPresent([IoTClientTypes.MitigationAction?].self, forKey: .actionsDefinition)
        var actionsDefinitionDecoded0:[IoTClientTypes.MitigationAction]? = nil
        if let actionsDefinitionContainer = actionsDefinitionContainer {
            actionsDefinitionDecoded0 = [IoTClientTypes.MitigationAction]()
            for structure0 in actionsDefinitionContainer {
                if let structure0 = structure0 {
                    actionsDefinitionDecoded0?.append(structure0)
                }
            }
        }
        actionsDefinition = actionsDefinitionDecoded0
        let taskStatisticsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DetectMitigationActionsTaskStatistics.self, forKey: .taskStatistics)
        taskStatistics = taskStatisticsDecoded
    }
}

extension IoTClientTypes {
    /// The summary of the mitigation action tasks.
    public struct DetectMitigationActionsTaskSummary: Swift.Equatable {
        /// The definition of the actions.
        public var actionsDefinition: [IoTClientTypes.MitigationAction]?
        /// Includes only active violations.
        public var onlyActiveViolationsIncluded: Swift.Bool
        /// Includes suppressed alerts.
        public var suppressedAlertsIncluded: Swift.Bool
        /// Specifies the ML Detect findings to which the mitigation actions are applied.
        public var target: IoTClientTypes.DetectMitigationActionsTaskTarget?
        /// The date the task ended.
        public var taskEndTime: ClientRuntime.Date?
        /// The unique identifier of the task.
        public var taskId: Swift.String?
        /// The date the task started.
        public var taskStartTime: ClientRuntime.Date?
        /// The statistics of a mitigation action task.
        public var taskStatistics: IoTClientTypes.DetectMitigationActionsTaskStatistics?
        /// The status of the task.
        public var taskStatus: IoTClientTypes.DetectMitigationActionsTaskStatus?
        /// Specifies the time period of which violation events occurred between.
        public var violationEventOccurrenceRange: IoTClientTypes.ViolationEventOccurrenceRange?

        public init(
            actionsDefinition: [IoTClientTypes.MitigationAction]? = nil,
            onlyActiveViolationsIncluded: Swift.Bool = false,
            suppressedAlertsIncluded: Swift.Bool = false,
            target: IoTClientTypes.DetectMitigationActionsTaskTarget? = nil,
            taskEndTime: ClientRuntime.Date? = nil,
            taskId: Swift.String? = nil,
            taskStartTime: ClientRuntime.Date? = nil,
            taskStatistics: IoTClientTypes.DetectMitigationActionsTaskStatistics? = nil,
            taskStatus: IoTClientTypes.DetectMitigationActionsTaskStatus? = nil,
            violationEventOccurrenceRange: IoTClientTypes.ViolationEventOccurrenceRange? = nil
        )
        {
            self.actionsDefinition = actionsDefinition
            self.onlyActiveViolationsIncluded = onlyActiveViolationsIncluded
            self.suppressedAlertsIncluded = suppressedAlertsIncluded
            self.target = target
            self.taskEndTime = taskEndTime
            self.taskId = taskId
            self.taskStartTime = taskStartTime
            self.taskStatistics = taskStatistics
            self.taskStatus = taskStatus
            self.violationEventOccurrenceRange = violationEventOccurrenceRange
        }
    }

}

extension IoTClientTypes.DetectMitigationActionsTaskTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case behaviorName
        case securityProfileName
        case violationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behaviorName = self.behaviorName {
            try encodeContainer.encode(behaviorName, forKey: .behaviorName)
        }
        if let securityProfileName = self.securityProfileName {
            try encodeContainer.encode(securityProfileName, forKey: .securityProfileName)
        }
        if let violationIds = violationIds {
            var violationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violationIds)
            for violationid0 in violationIds {
                try violationIdsContainer.encode(violationid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .violationIds)
        var violationIdsDecoded0:[Swift.String]? = nil
        if let violationIdsContainer = violationIdsContainer {
            violationIdsDecoded0 = [Swift.String]()
            for string0 in violationIdsContainer {
                if let string0 = string0 {
                    violationIdsDecoded0?.append(string0)
                }
            }
        }
        violationIds = violationIdsDecoded0
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let behaviorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .behaviorName)
        behaviorName = behaviorNameDecoded
    }
}

extension IoTClientTypes {
    /// The target of a mitigation action task.
    public struct DetectMitigationActionsTaskTarget: Swift.Equatable {
        /// The name of the behavior.
        public var behaviorName: Swift.String?
        /// The name of the security profile.
        public var securityProfileName: Swift.String?
        /// The unique identifiers of the violations.
        public var violationIds: [Swift.String]?

        public init(
            behaviorName: Swift.String? = nil,
            securityProfileName: Swift.String? = nil,
            violationIds: [Swift.String]? = nil
        )
        {
            self.behaviorName = behaviorName
            self.securityProfileName = securityProfileName
            self.violationIds = violationIds
        }
    }

}

extension IoTClientTypes {
    public enum DeviceCertificateUpdateAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deactivate
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceCertificateUpdateAction] {
            return [
                .deactivate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deactivate: return "DEACTIVATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceCertificateUpdateAction(rawValue: rawValue) ?? DeviceCertificateUpdateAction.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum DeviceDefenderIndexingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case violations
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceDefenderIndexingMode] {
            return [
                .off,
                .violations,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .violations: return "VIOLATIONS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceDefenderIndexingMode(rawValue: rawValue) ?? DeviceDefenderIndexingMode.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum DimensionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case topicFilter
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionType] {
            return [
                .topicFilter,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .topicFilter: return "TOPIC_FILTER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DimensionType(rawValue: rawValue) ?? DimensionType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum DimensionValueOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `in`
        case notIn
        case sdkUnknown(Swift.String)

        public static var allCases: [DimensionValueOperator] {
            return [
                .in,
                .notIn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .in: return "IN"
            case .notIn: return "NOT_IN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DimensionValueOperator(rawValue: rawValue) ?? DimensionValueOperator.sdkUnknown(rawValue)
        }
    }
}

extension DisableTopicRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ruleName = ruleName else {
            return nil
        }
        return "/rules/\(ruleName.urlPercentEncoding())/disable"
    }
}

/// The input for the DisableTopicRuleRequest operation.
public struct DisableTopicRuleInput: Swift.Equatable {
    /// The name of the rule to disable.
    /// This member is required.
    public var ruleName: Swift.String?

    public init(
        ruleName: Swift.String? = nil
    )
    {
        self.ruleName = ruleName
    }
}

struct DisableTopicRuleInputBody: Swift.Equatable {
}

extension DisableTopicRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisableTopicRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisableTopicRuleOutput: Swift.Equatable {

    public init() { }
}

enum DisableTopicRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.DocumentParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case example
        case key
        case `optional` = "optional"
        case regex
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let example = self.example {
            try encodeContainer.encode(example, forKey: .example)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if `optional` != false {
            try encodeContainer.encode(`optional`, forKey: .`optional`)
        }
        if let regex = self.regex {
            try encodeContainer.encode(regex, forKey: .regex)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let regexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regex)
        regex = regexDecoded
        let exampleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .example)
        example = exampleDecoded
        let optionalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optional) ?? false
        `optional` = optionalDecoded
    }
}

extension IoTClientTypes {
    /// A map of key-value pairs containing the patterns that need to be replaced in a managed template job document schema. You can use the description of each key as a guidance to specify the inputs during runtime when creating a job. documentParameters can only be used when creating jobs from Amazon Web Services managed templates. This parameter can't be used with custom job templates or to create jobs from them.
    public struct DocumentParameter: Swift.Equatable {
        /// Description of the map field containing the patterns that need to be replaced in a managed template job document schema.
        public var description: Swift.String?
        /// An example illustrating a pattern that need to be replaced in a managed template job document schema.
        public var example: Swift.String?
        /// Key of the map field containing the patterns that need to be replaced in a managed template job document schema.
        public var key: Swift.String?
        /// Specifies whether a pattern that needs to be replaced in a managed template job document schema is optional or required.
        public var `optional`: Swift.Bool
        /// A regular expression of the patterns that need to be replaced in a managed template job document schema.
        public var regex: Swift.String?

        public init(
            description: Swift.String? = nil,
            example: Swift.String? = nil,
            key: Swift.String? = nil,
            `optional`: Swift.Bool = false,
            regex: Swift.String? = nil
        )
        {
            self.description = description
            self.example = example
            self.key = key
            self.`optional` = `optional`
            self.regex = regex
        }
    }

}

extension IoTClientTypes {
    public enum DomainConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainConfigurationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainConfigurationStatus(rawValue: rawValue) ?? DomainConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.DomainConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainConfigurationArn
        case domainConfigurationName
        case serviceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainConfigurationArn = self.domainConfigurationArn {
            try encodeContainer.encode(domainConfigurationArn, forKey: .domainConfigurationArn)
        }
        if let domainConfigurationName = self.domainConfigurationName {
            try encodeContainer.encode(domainConfigurationName, forKey: .domainConfigurationName)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainConfigurationName)
        domainConfigurationName = domainConfigurationNameDecoded
        let domainConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainConfigurationArn)
        domainConfigurationArn = domainConfigurationArnDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
    }
}

extension IoTClientTypes {
    /// The summary of a domain configuration. A domain configuration specifies custom IoT-specific information about a domain. A domain configuration can be associated with an Amazon Web Services-managed domain (for example, dbc123defghijk.iot.us-west-2.amazonaws.com), a customer managed domain, or a default endpoint.
    ///
    /// * Data
    ///
    /// * Jobs
    ///
    /// * CredentialProvider
    public struct DomainConfigurationSummary: Swift.Equatable {
        /// The ARN of the domain configuration.
        public var domainConfigurationArn: Swift.String?
        /// The name of the domain configuration. This value must be unique to a region.
        public var domainConfigurationName: Swift.String?
        /// The type of service delivered by the endpoint.
        public var serviceType: IoTClientTypes.ServiceType?

        public init(
            domainConfigurationArn: Swift.String? = nil,
            domainConfigurationName: Swift.String? = nil,
            serviceType: IoTClientTypes.ServiceType? = nil
        )
        {
            self.domainConfigurationArn = domainConfigurationArn
            self.domainConfigurationName = domainConfigurationName
            self.serviceType = serviceType
        }
    }

}

extension IoTClientTypes {
    public enum DomainType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsManaged
        case customerManaged
        case endpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainType] {
            return [
                .awsManaged,
                .customerManaged,
                .endpoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "AWS_MANAGED"
            case .customerManaged: return "CUSTOMER_MANAGED"
            case .endpoint: return "ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainType(rawValue: rawValue) ?? DomainType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum DynamicGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case building
        case rebuilding
        case sdkUnknown(Swift.String)

        public static var allCases: [DynamicGroupStatus] {
            return [
                .active,
                .building,
                .rebuilding,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .building: return "BUILDING"
            case .rebuilding: return "REBUILDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DynamicGroupStatus(rawValue: rawValue) ?? DynamicGroupStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.DynamoDBAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hashKeyField
        case hashKeyType
        case hashKeyValue
        case operation
        case payloadField
        case rangeKeyField
        case rangeKeyType
        case rangeKeyValue
        case roleArn
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashKeyField = self.hashKeyField {
            try encodeContainer.encode(hashKeyField, forKey: .hashKeyField)
        }
        if let hashKeyType = self.hashKeyType {
            try encodeContainer.encode(hashKeyType.rawValue, forKey: .hashKeyType)
        }
        if let hashKeyValue = self.hashKeyValue {
            try encodeContainer.encode(hashKeyValue, forKey: .hashKeyValue)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let payloadField = self.payloadField {
            try encodeContainer.encode(payloadField, forKey: .payloadField)
        }
        if let rangeKeyField = self.rangeKeyField {
            try encodeContainer.encode(rangeKeyField, forKey: .rangeKeyField)
        }
        if let rangeKeyType = self.rangeKeyType {
            try encodeContainer.encode(rangeKeyType.rawValue, forKey: .rangeKeyType)
        }
        if let rangeKeyValue = self.rangeKeyValue {
            try encodeContainer.encode(rangeKeyValue, forKey: .rangeKeyValue)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let hashKeyFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hashKeyField)
        hashKeyField = hashKeyFieldDecoded
        let hashKeyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hashKeyValue)
        hashKeyValue = hashKeyValueDecoded
        let hashKeyTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DynamoKeyType.self, forKey: .hashKeyType)
        hashKeyType = hashKeyTypeDecoded
        let rangeKeyFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rangeKeyField)
        rangeKeyField = rangeKeyFieldDecoded
        let rangeKeyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rangeKeyValue)
        rangeKeyValue = rangeKeyValueDecoded
        let rangeKeyTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DynamoKeyType.self, forKey: .rangeKeyType)
        rangeKeyType = rangeKeyTypeDecoded
        let payloadFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadField)
        payloadField = payloadFieldDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action to write to a DynamoDB table. The tableName, hashKeyField, and rangeKeyField values must match the values used when you created the table. The hashKeyValue and rangeKeyvalue fields use a substitution template syntax. These templates provide data at runtime. The syntax is as follows: ${sql-expression}. You can specify any valid expression in a WHERE or SELECT clause, including JSON properties, comparisons, calculations, and functions. For example, the following field uses the third level of the topic: "hashKeyValue": "${topic(3)}" The following field uses the timestamp: "rangeKeyValue": "${timestamp()}"
    public struct DynamoDBAction: Swift.Equatable {
        /// The hash key name.
        /// This member is required.
        public var hashKeyField: Swift.String?
        /// The hash key type. Valid values are "STRING" or "NUMBER"
        public var hashKeyType: IoTClientTypes.DynamoKeyType?
        /// The hash key value.
        /// This member is required.
        public var hashKeyValue: Swift.String?
        /// The type of operation to be performed. This follows the substitution template, so it can be ${operation}, but the substitution must result in one of the following: INSERT, UPDATE, or DELETE.
        public var operation: Swift.String?
        /// The action payload. This name can be customized.
        public var payloadField: Swift.String?
        /// The range key name.
        public var rangeKeyField: Swift.String?
        /// The range key type. Valid values are "STRING" or "NUMBER"
        public var rangeKeyType: IoTClientTypes.DynamoKeyType?
        /// The range key value.
        public var rangeKeyValue: Swift.String?
        /// The ARN of the IAM role that grants access to the DynamoDB table.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The name of the DynamoDB table.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            hashKeyField: Swift.String? = nil,
            hashKeyType: IoTClientTypes.DynamoKeyType? = nil,
            hashKeyValue: Swift.String? = nil,
            operation: Swift.String? = nil,
            payloadField: Swift.String? = nil,
            rangeKeyField: Swift.String? = nil,
            rangeKeyType: IoTClientTypes.DynamoKeyType? = nil,
            rangeKeyValue: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.hashKeyField = hashKeyField
            self.hashKeyType = hashKeyType
            self.hashKeyValue = hashKeyValue
            self.operation = operation
            self.payloadField = payloadField
            self.rangeKeyField = rangeKeyField
            self.rangeKeyType = rangeKeyType
            self.rangeKeyValue = rangeKeyValue
            self.roleArn = roleArn
            self.tableName = tableName
        }
    }

}

extension IoTClientTypes.DynamoDBv2Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case putItem
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let putItem = self.putItem {
            try encodeContainer.encode(putItem, forKey: .putItem)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let putItemDecoded = try containerValues.decodeIfPresent(IoTClientTypes.PutItemInput.self, forKey: .putItem)
        putItem = putItemDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action to write to a DynamoDB table. This DynamoDB action writes each attribute in the message payload into it's own column in the DynamoDB table.
    public struct DynamoDBv2Action: Swift.Equatable {
        /// Specifies the DynamoDB table to which the message data will be written. For example: { "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } } Each attribute in the message payload will be written to a separate column in the DynamoDB database.
        /// This member is required.
        public var putItem: IoTClientTypes.PutItemInput?
        /// The ARN of the IAM role that grants access to the DynamoDB table.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            putItem: IoTClientTypes.PutItemInput? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.putItem = putItem
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes {
    public enum DynamoKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [DynamoKeyType] {
            return [
                .number,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .number: return "NUMBER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DynamoKeyType(rawValue: rawValue) ?? DynamoKeyType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.EffectivePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn
        case policyDocument
        case policyName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyDocument = self.policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension IoTClientTypes {
    /// The policy that has the effect on the authorization results.
    public struct EffectivePolicy: Swift.Equatable {
        /// The policy ARN.
        public var policyArn: Swift.String?
        /// The IAM policy document.
        public var policyDocument: Swift.String?
        /// The policy name.
        public var policyName: Swift.String?

        public init(
            policyArn: Swift.String? = nil,
            policyDocument: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyArn = policyArn
            self.policyDocument = policyDocument
            self.policyName = policyName
        }
    }

}

extension IoTClientTypes.ElasticsearchAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
        case id
        case index
        case roleArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let index = self.index {
            try encodeContainer.encode(index, forKey: .index)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let indexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .index)
        index = indexDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action that writes data to an Amazon OpenSearch Service domain. The Elasticsearch action can only be used by existing rule actions. To create a new rule action or to update an existing rule action, use the OpenSearch rule action instead. For more information, see [OpenSearchAction](https://docs.aws.amazon.com/iot/latest/apireference/API_OpenSearchAction.html).
    public struct ElasticsearchAction: Swift.Equatable {
        /// The endpoint of your OpenSearch domain.
        /// This member is required.
        public var endpoint: Swift.String?
        /// The unique identifier for the document you are storing.
        /// This member is required.
        public var id: Swift.String?
        /// The index where you want to store your data.
        /// This member is required.
        public var index: Swift.String?
        /// The IAM role ARN that has access to OpenSearch.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The type of document you are storing.
        /// This member is required.
        public var type: Swift.String?

        public init(
            endpoint: Swift.String? = nil,
            id: Swift.String? = nil,
            index: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.id = id
            self.index = index
            self.roleArn = roleArn
            self.type = type
        }
    }

}

extension IoTClientTypes.EnableIoTLoggingParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel
        case roleArnForLogging
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let roleArnForLogging = self.roleArnForLogging {
            try encodeContainer.encode(roleArnForLogging, forKey: .roleArnForLogging)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnForLoggingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArnForLogging)
        roleArnForLogging = roleArnForLoggingDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension IoTClientTypes {
    /// Parameters used when defining a mitigation action that enable Amazon Web Services IoT Core logging.
    public struct EnableIoTLoggingParams: Swift.Equatable {
        /// Specifies the type of information to be logged.
        /// This member is required.
        public var logLevel: IoTClientTypes.LogLevel?
        /// The Amazon Resource Name (ARN) of the IAM role used for logging.
        /// This member is required.
        public var roleArnForLogging: Swift.String?

        public init(
            logLevel: IoTClientTypes.LogLevel? = nil,
            roleArnForLogging: Swift.String? = nil
        )
        {
            self.logLevel = logLevel
            self.roleArnForLogging = roleArnForLogging
        }
    }

}

extension EnableTopicRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ruleName = ruleName else {
            return nil
        }
        return "/rules/\(ruleName.urlPercentEncoding())/enable"
    }
}

/// The input for the EnableTopicRuleRequest operation.
public struct EnableTopicRuleInput: Swift.Equatable {
    /// The name of the topic rule to enable.
    /// This member is required.
    public var ruleName: Swift.String?

    public init(
        ruleName: Swift.String? = nil
    )
    {
        self.ruleName = ruleName
    }
}

struct EnableTopicRuleInputBody: Swift.Equatable {
}

extension EnableTopicRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension EnableTopicRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct EnableTopicRuleOutput: Swift.Equatable {

    public init() { }
}

enum EnableTopicRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.ErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes {
    /// Error information.
    public struct ErrorInfo: Swift.Equatable {
        /// The error code.
        public var code: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IoTClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case caCertificate
        case certificate
        case job
        case jobExecution
        case policy
        case thing
        case thingGroup
        case thingGroupHierarchy
        case thingGroupMembership
        case thingType
        case thingTypeAssociation
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .caCertificate,
                .certificate,
                .job,
                .jobExecution,
                .policy,
                .thing,
                .thingGroup,
                .thingGroupHierarchy,
                .thingGroupMembership,
                .thingType,
                .thingTypeAssociation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .caCertificate: return "CA_CERTIFICATE"
            case .certificate: return "CERTIFICATE"
            case .job: return "JOB"
            case .jobExecution: return "JOB_EXECUTION"
            case .policy: return "POLICY"
            case .thing: return "THING"
            case .thingGroup: return "THING_GROUP"
            case .thingGroupHierarchy: return "THING_GROUP_HIERARCHY"
            case .thingGroupMembership: return "THING_GROUP_MEMBERSHIP"
            case .thingType: return "THING_TYPE"
            case .thingTypeAssociation: return "THING_TYPE_ASSOCIATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.ExplicitDeny: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policies
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for policy0 in policies {
                try policiesContainer.encode(policy0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([IoTClientTypes.Policy?].self, forKey: .policies)
        var policiesDecoded0:[IoTClientTypes.Policy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [IoTClientTypes.Policy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
    }
}

extension IoTClientTypes {
    /// Information that explicitly denies authorization.
    public struct ExplicitDeny: Swift.Equatable {
        /// The policies that denied the authorization.
        public var policies: [IoTClientTypes.Policy]?

        public init(
            policies: [IoTClientTypes.Policy]? = nil
        )
        {
            self.policies = policies
        }
    }

}

extension IoTClientTypes.ExponentialRolloutRate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseRatePerMinute
        case incrementFactor
        case rateIncreaseCriteria
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseRatePerMinute = self.baseRatePerMinute {
            try encodeContainer.encode(baseRatePerMinute, forKey: .baseRatePerMinute)
        }
        if incrementFactor != 0.0 {
            try encodeContainer.encode(incrementFactor, forKey: .incrementFactor)
        }
        if let rateIncreaseCriteria = self.rateIncreaseCriteria {
            try encodeContainer.encode(rateIncreaseCriteria, forKey: .rateIncreaseCriteria)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseRatePerMinuteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseRatePerMinute)
        baseRatePerMinute = baseRatePerMinuteDecoded
        let incrementFactorDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .incrementFactor) ?? 0.0
        incrementFactor = incrementFactorDecoded
        let rateIncreaseCriteriaDecoded = try containerValues.decodeIfPresent(IoTClientTypes.RateIncreaseCriteria.self, forKey: .rateIncreaseCriteria)
        rateIncreaseCriteria = rateIncreaseCriteriaDecoded
    }
}

extension IoTClientTypes {
    /// Allows you to create an exponential rate of rollout for a job.
    public struct ExponentialRolloutRate: Swift.Equatable {
        /// The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.
        /// This member is required.
        public var baseRatePerMinute: Swift.Int?
        /// The exponential factor to increase the rate of rollout for a job. Amazon Web Services IoT Core supports up to one digit after the decimal (for example, 1.5, but not 1.55).
        /// This member is required.
        public var incrementFactor: Swift.Double
        /// The criteria to initiate the increase in rate of rollout for a job.
        /// This member is required.
        public var rateIncreaseCriteria: IoTClientTypes.RateIncreaseCriteria?

        public init(
            baseRatePerMinute: Swift.Int? = nil,
            incrementFactor: Swift.Double = 0.0,
            rateIncreaseCriteria: IoTClientTypes.RateIncreaseCriteria? = nil
        )
        {
            self.baseRatePerMinute = baseRatePerMinute
            self.incrementFactor = incrementFactor
            self.rateIncreaseCriteria = rateIncreaseCriteria
        }
    }

}

extension IoTClientTypes.Field: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.FieldType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTClientTypes {
    /// Describes the name and data type at a field.
    public struct Field: Swift.Equatable {
        /// The name of the field.
        public var name: Swift.String?
        /// The data type of the field.
        public var type: IoTClientTypes.FieldType?

        public init(
            name: Swift.String? = nil,
            type: IoTClientTypes.FieldType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension IoTClientTypes {
    public enum FieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldType] {
            return [
                .boolean,
                .number,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "Boolean"
            case .number: return "Number"
            case .string: return "String"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FieldType(rawValue: rawValue) ?? FieldType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.FileLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location
        case stream
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let stream = self.stream {
            try encodeContainer.encode(stream, forKey: .stream)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(IoTClientTypes.Stream.self, forKey: .stream)
        stream = streamDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension IoTClientTypes {
    /// The location of the OTA update.
    public struct FileLocation: Swift.Equatable {
        /// The location of the updated firmware in S3.
        public var s3Location: IoTClientTypes.S3Location?
        /// The stream that contains the OTA update.
        public var stream: IoTClientTypes.Stream?

        public init(
            s3Location: IoTClientTypes.S3Location? = nil,
            stream: IoTClientTypes.Stream? = nil
        )
        {
            self.s3Location = s3Location
            self.stream = stream
        }
    }

}

extension IoTClientTypes.FirehoseAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchMode
        case deliveryStreamName
        case roleArn
        case separator
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchMode = self.batchMode {
            try encodeContainer.encode(batchMode, forKey: .batchMode)
        }
        if let deliveryStreamName = self.deliveryStreamName {
            try encodeContainer.encode(deliveryStreamName, forKey: .deliveryStreamName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let separator = self.separator {
            try encodeContainer.encode(separator, forKey: .separator)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let deliveryStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStreamName)
        deliveryStreamName = deliveryStreamNameDecoded
        let separatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .separator)
        separator = separatorDecoded
        let batchModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .batchMode)
        batchMode = batchModeDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action that writes data to an Amazon Kinesis Firehose stream.
    public struct FirehoseAction: Swift.Equatable {
        /// Whether to deliver the Kinesis Data Firehose stream as a batch by using [PutRecordBatch](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html). The default value is false. When batchMode is true and the rule's SQL statement evaluates to an Array, each Array element forms one record in the [PutRecordBatch](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html) request. The resulting array can't have more than 500 records.
        public var batchMode: Swift.Bool?
        /// The delivery stream name.
        /// This member is required.
        public var deliveryStreamName: Swift.String?
        /// The IAM role that grants access to the Amazon Kinesis Firehose stream.
        /// This member is required.
        public var roleArn: Swift.String?
        /// A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
        public var separator: Swift.String?

        public init(
            batchMode: Swift.Bool? = nil,
            deliveryStreamName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            separator: Swift.String? = nil
        )
        {
            self.batchMode = batchMode
            self.deliveryStreamName = deliveryStreamName
            self.roleArn = roleArn
            self.separator = separator
        }
    }

}

extension IoTClientTypes.FleetMetricNameAndArn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricArn
        case metricName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricArn = self.metricArn {
            try encodeContainer.encode(metricArn, forKey: .metricArn)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricArn)
        metricArn = metricArnDecoded
    }
}

extension IoTClientTypes {
    /// The name and ARN of a fleet metric.
    public struct FleetMetricNameAndArn: Swift.Equatable {
        /// The fleet metric ARN.
        public var metricArn: Swift.String?
        /// The fleet metric name.
        public var metricName: Swift.String?

        public init(
            metricArn: Swift.String? = nil,
            metricName: Swift.String? = nil
        )
        {
            self.metricArn = metricArn
            self.metricName = metricName
        }
    }

}

extension IoTClientTypes {
    public enum FleetMetricUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bits
        case bitssecond
        case bytes
        case bytessecond
        case count
        case countsecond
        case gigabits
        case gigabitssecond
        case gigabytes
        case gigabytessecond
        case kilobits
        case kilobitssecond
        case kilobytes
        case kilobytessecond
        case megabits
        case megabitssecond
        case megabytes
        case megabytessecond
        case microseconds
        case milliseconds
        case `none`
        case percent
        case seconds
        case terabits
        case terabitssecond
        case terabytes
        case terabytessecond
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetMetricUnit] {
            return [
                .bits,
                .bitssecond,
                .bytes,
                .bytessecond,
                .count,
                .countsecond,
                .gigabits,
                .gigabitssecond,
                .gigabytes,
                .gigabytessecond,
                .kilobits,
                .kilobitssecond,
                .kilobytes,
                .kilobytessecond,
                .megabits,
                .megabitssecond,
                .megabytes,
                .megabytessecond,
                .microseconds,
                .milliseconds,
                .none,
                .percent,
                .seconds,
                .terabits,
                .terabitssecond,
                .terabytes,
                .terabytessecond,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bits: return "Bits"
            case .bitssecond: return "Bits/Second"
            case .bytes: return "Bytes"
            case .bytessecond: return "Bytes/Second"
            case .count: return "Count"
            case .countsecond: return "Count/Second"
            case .gigabits: return "Gigabits"
            case .gigabitssecond: return "Gigabits/Second"
            case .gigabytes: return "Gigabytes"
            case .gigabytessecond: return "Gigabytes/Second"
            case .kilobits: return "Kilobits"
            case .kilobitssecond: return "Kilobits/Second"
            case .kilobytes: return "Kilobytes"
            case .kilobytessecond: return "Kilobytes/Second"
            case .megabits: return "Megabits"
            case .megabitssecond: return "Megabits/Second"
            case .megabytes: return "Megabytes"
            case .megabytessecond: return "Megabytes/Second"
            case .microseconds: return "Microseconds"
            case .milliseconds: return "Milliseconds"
            case .none: return "None"
            case .percent: return "Percent"
            case .seconds: return "Seconds"
            case .terabits: return "Terabits"
            case .terabitssecond: return "Terabits/Second"
            case .terabytes: return "Terabytes"
            case .terabytessecond: return "Terabytes/Second"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetMetricUnit(rawValue: rawValue) ?? FleetMetricUnit.sdkUnknown(rawValue)
        }
    }
}

extension GetBehaviorModelTrainingSummariesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let securityProfileName = securityProfileName {
                let securityProfileNameQueryItem = ClientRuntime.URLQueryItem(name: "securityProfileName".urlPercentEncoding(), value: Swift.String(securityProfileName).urlPercentEncoding())
                items.append(securityProfileNameQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetBehaviorModelTrainingSummariesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/behavior-model-training/summaries"
    }
}

public struct GetBehaviorModelTrainingSummariesInput: Swift.Equatable {
    /// The maximum number of results to return at one time. The default is 10.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The name of the security profile.
    public var securityProfileName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfileName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileName = securityProfileName
    }
}

struct GetBehaviorModelTrainingSummariesInputBody: Swift.Equatable {
}

extension GetBehaviorModelTrainingSummariesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBehaviorModelTrainingSummariesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBehaviorModelTrainingSummariesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct GetBehaviorModelTrainingSummariesOutput: Swift.Equatable {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of all ML Detect behaviors and their model status for a given Security Profile.
    public var summaries: [IoTClientTypes.BehaviorModelTrainingSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTClientTypes.BehaviorModelTrainingSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct GetBehaviorModelTrainingSummariesOutputBody: Swift.Equatable {
    let summaries: [IoTClientTypes.BehaviorModelTrainingSummary]?
    let nextToken: Swift.String?
}

extension GetBehaviorModelTrainingSummariesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTClientTypes.BehaviorModelTrainingSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTClientTypes.BehaviorModelTrainingSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTClientTypes.BehaviorModelTrainingSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetBehaviorModelTrainingSummariesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBucketsAggregationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationField
        case bucketsAggregationType
        case indexName
        case queryString
        case queryVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationField = self.aggregationField {
            try encodeContainer.encode(aggregationField, forKey: .aggregationField)
        }
        if let bucketsAggregationType = self.bucketsAggregationType {
            try encodeContainer.encode(bucketsAggregationType, forKey: .bucketsAggregationType)
        }
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = self.queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
    }
}

extension GetBucketsAggregationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/indices/buckets"
    }
}

public struct GetBucketsAggregationInput: Swift.Equatable {
    /// The aggregation field.
    /// This member is required.
    public var aggregationField: Swift.String?
    /// The basic control of the response shape and the bucket aggregation type to perform.
    /// This member is required.
    public var bucketsAggregationType: IoTClientTypes.BucketsAggregationType?
    /// The name of the index to search.
    public var indexName: Swift.String?
    /// The search query string.
    /// This member is required.
    public var queryString: Swift.String?
    /// The version of the query.
    public var queryVersion: Swift.String?

    public init(
        aggregationField: Swift.String? = nil,
        bucketsAggregationType: IoTClientTypes.BucketsAggregationType? = nil,
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil
    )
    {
        self.aggregationField = aggregationField
        self.bucketsAggregationType = bucketsAggregationType
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

struct GetBucketsAggregationInputBody: Swift.Equatable {
    let indexName: Swift.String?
    let queryString: Swift.String?
    let aggregationField: Swift.String?
    let queryVersion: Swift.String?
    let bucketsAggregationType: IoTClientTypes.BucketsAggregationType?
}

extension GetBucketsAggregationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationField
        case bucketsAggregationType
        case indexName
        case queryString
        case queryVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let aggregationFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregationField)
        aggregationField = aggregationFieldDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
        let bucketsAggregationTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.BucketsAggregationType.self, forKey: .bucketsAggregationType)
        bucketsAggregationType = bucketsAggregationTypeDecoded
    }
}

extension GetBucketsAggregationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBucketsAggregationOutputBody = try responseDecoder.decode(responseBody: data)
            self.buckets = output.buckets
            self.totalCount = output.totalCount
        } else {
            self.buckets = nil
            self.totalCount = 0
        }
    }
}

public struct GetBucketsAggregationOutput: Swift.Equatable {
    /// The main part of the response with a list of buckets. Each bucket contains a keyValue and a count. keyValue: The aggregation field value counted for the particular bucket. count: The number of documents that have that value.
    public var buckets: [IoTClientTypes.Bucket]?
    /// The total number of things that fit the query string criteria.
    public var totalCount: Swift.Int

    public init(
        buckets: [IoTClientTypes.Bucket]? = nil,
        totalCount: Swift.Int = 0
    )
    {
        self.buckets = buckets
        self.totalCount = totalCount
    }
}

struct GetBucketsAggregationOutputBody: Swift.Equatable {
    let totalCount: Swift.Int
    let buckets: [IoTClientTypes.Bucket]?
}

extension GetBucketsAggregationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buckets
        case totalCount
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount) ?? 0
        totalCount = totalCountDecoded
        let bucketsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Bucket?].self, forKey: .buckets)
        var bucketsDecoded0:[IoTClientTypes.Bucket]? = nil
        if let bucketsContainer = bucketsContainer {
            bucketsDecoded0 = [IoTClientTypes.Bucket]()
            for structure0 in bucketsContainer {
                if let structure0 = structure0 {
                    bucketsDecoded0?.append(structure0)
                }
            }
        }
        buckets = bucketsDecoded0
    }
}

enum GetBucketsAggregationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IndexNotReadyException": return try await IndexNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAggregationException": return try await InvalidAggregationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidQueryException": return try await InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCardinalityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationField
        case indexName
        case queryString
        case queryVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationField = self.aggregationField {
            try encodeContainer.encode(aggregationField, forKey: .aggregationField)
        }
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = self.queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
    }
}

extension GetCardinalityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/indices/cardinality"
    }
}

public struct GetCardinalityInput: Swift.Equatable {
    /// The field to aggregate.
    public var aggregationField: Swift.String?
    /// The name of the index to search.
    public var indexName: Swift.String?
    /// The search query string.
    /// This member is required.
    public var queryString: Swift.String?
    /// The query version.
    public var queryVersion: Swift.String?

    public init(
        aggregationField: Swift.String? = nil,
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil
    )
    {
        self.aggregationField = aggregationField
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

struct GetCardinalityInputBody: Swift.Equatable {
    let indexName: Swift.String?
    let queryString: Swift.String?
    let aggregationField: Swift.String?
    let queryVersion: Swift.String?
}

extension GetCardinalityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationField
        case indexName
        case queryString
        case queryVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let aggregationFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregationField)
        aggregationField = aggregationFieldDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
    }
}

extension GetCardinalityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCardinalityOutputBody = try responseDecoder.decode(responseBody: data)
            self.cardinality = output.cardinality
        } else {
            self.cardinality = 0
        }
    }
}

public struct GetCardinalityOutput: Swift.Equatable {
    /// The approximate count of unique values that match the query.
    public var cardinality: Swift.Int

    public init(
        cardinality: Swift.Int = 0
    )
    {
        self.cardinality = cardinality
    }
}

struct GetCardinalityOutputBody: Swift.Equatable {
    let cardinality: Swift.Int
}

extension GetCardinalityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cardinality
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cardinalityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cardinality) ?? 0
        cardinality = cardinalityDecoded
    }
}

enum GetCardinalityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IndexNotReadyException": return try await IndexNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAggregationException": return try await InvalidAggregationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidQueryException": return try await InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEffectivePoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitoIdentityPoolId
        case principal
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cognitoIdentityPoolId = self.cognitoIdentityPoolId {
            try encodeContainer.encode(cognitoIdentityPoolId, forKey: .cognitoIdentityPoolId)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
    }
}

extension GetEffectivePoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let thingName = thingName {
                let thingNameQueryItem = ClientRuntime.URLQueryItem(name: "thingName".urlPercentEncoding(), value: Swift.String(thingName).urlPercentEncoding())
                items.append(thingNameQueryItem)
            }
            return items
        }
    }
}

extension GetEffectivePoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/effective-policies"
    }
}

public struct GetEffectivePoliciesInput: Swift.Equatable {
    /// The Cognito identity pool ID.
    public var cognitoIdentityPoolId: Swift.String?
    /// The principal. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    public var principal: Swift.String?
    /// The thing name.
    public var thingName: Swift.String?

    public init(
        cognitoIdentityPoolId: Swift.String? = nil,
        principal: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.cognitoIdentityPoolId = cognitoIdentityPoolId
        self.principal = principal
        self.thingName = thingName
    }
}

struct GetEffectivePoliciesInputBody: Swift.Equatable {
    let principal: Swift.String?
    let cognitoIdentityPoolId: Swift.String?
}

extension GetEffectivePoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitoIdentityPoolId
        case principal
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let cognitoIdentityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cognitoIdentityPoolId)
        cognitoIdentityPoolId = cognitoIdentityPoolIdDecoded
    }
}

extension GetEffectivePoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEffectivePoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.effectivePolicies = output.effectivePolicies
        } else {
            self.effectivePolicies = nil
        }
    }
}

public struct GetEffectivePoliciesOutput: Swift.Equatable {
    /// The effective policies.
    public var effectivePolicies: [IoTClientTypes.EffectivePolicy]?

    public init(
        effectivePolicies: [IoTClientTypes.EffectivePolicy]? = nil
    )
    {
        self.effectivePolicies = effectivePolicies
    }
}

struct GetEffectivePoliciesOutputBody: Swift.Equatable {
    let effectivePolicies: [IoTClientTypes.EffectivePolicy]?
}

extension GetEffectivePoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectivePolicies
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectivePoliciesContainer = try containerValues.decodeIfPresent([IoTClientTypes.EffectivePolicy?].self, forKey: .effectivePolicies)
        var effectivePoliciesDecoded0:[IoTClientTypes.EffectivePolicy]? = nil
        if let effectivePoliciesContainer = effectivePoliciesContainer {
            effectivePoliciesDecoded0 = [IoTClientTypes.EffectivePolicy]()
            for structure0 in effectivePoliciesContainer {
                if let structure0 = structure0 {
                    effectivePoliciesDecoded0?.append(structure0)
                }
            }
        }
        effectivePolicies = effectivePoliciesDecoded0
    }
}

enum GetEffectivePoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIndexingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/indexing/config"
    }
}

public struct GetIndexingConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetIndexingConfigurationInputBody: Swift.Equatable {
}

extension GetIndexingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIndexingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIndexingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.thingGroupIndexingConfiguration = output.thingGroupIndexingConfiguration
            self.thingIndexingConfiguration = output.thingIndexingConfiguration
        } else {
            self.thingGroupIndexingConfiguration = nil
            self.thingIndexingConfiguration = nil
        }
    }
}

public struct GetIndexingConfigurationOutput: Swift.Equatable {
    /// The index configuration.
    public var thingGroupIndexingConfiguration: IoTClientTypes.ThingGroupIndexingConfiguration?
    /// Thing indexing configuration.
    public var thingIndexingConfiguration: IoTClientTypes.ThingIndexingConfiguration?

    public init(
        thingGroupIndexingConfiguration: IoTClientTypes.ThingGroupIndexingConfiguration? = nil,
        thingIndexingConfiguration: IoTClientTypes.ThingIndexingConfiguration? = nil
    )
    {
        self.thingGroupIndexingConfiguration = thingGroupIndexingConfiguration
        self.thingIndexingConfiguration = thingIndexingConfiguration
    }
}

struct GetIndexingConfigurationOutputBody: Swift.Equatable {
    let thingIndexingConfiguration: IoTClientTypes.ThingIndexingConfiguration?
    let thingGroupIndexingConfiguration: IoTClientTypes.ThingGroupIndexingConfiguration?
}

extension GetIndexingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingGroupIndexingConfiguration
        case thingIndexingConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingIndexingConfigurationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingIndexingConfiguration.self, forKey: .thingIndexingConfiguration)
        thingIndexingConfiguration = thingIndexingConfigurationDecoded
        let thingGroupIndexingConfigurationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingGroupIndexingConfiguration.self, forKey: .thingGroupIndexingConfiguration)
        thingGroupIndexingConfiguration = thingGroupIndexingConfigurationDecoded
    }
}

enum GetIndexingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetJobDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())/job-document"
    }
}

public struct GetJobDocumentInput: Swift.Equatable {
    /// The unique identifier you assigned to this job when it was created.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobDocumentInputBody: Swift.Equatable {
}

extension GetJobDocumentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetJobDocumentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetJobDocumentOutputBody = try responseDecoder.decode(responseBody: data)
            self.document = output.document
        } else {
            self.document = nil
        }
    }
}

public struct GetJobDocumentOutput: Swift.Equatable {
    /// The job document content.
    public var document: Swift.String?

    public init(
        document: Swift.String? = nil
    )
    {
        self.document = document
    }
}

struct GetJobDocumentOutputBody: Swift.Equatable {
    let document: Swift.String?
}

extension GetJobDocumentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
    }
}

enum GetJobDocumentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/loggingOptions"
    }
}

/// The input for the GetLoggingOptions operation.
public struct GetLoggingOptionsInput: Swift.Equatable {

    public init() { }
}

struct GetLoggingOptionsInputBody: Swift.Equatable {
}

extension GetLoggingOptionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLoggingOptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLoggingOptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.logLevel = output.logLevel
            self.roleArn = output.roleArn
        } else {
            self.logLevel = nil
            self.roleArn = nil
        }
    }
}

/// The output from the GetLoggingOptions operation.
public struct GetLoggingOptionsOutput: Swift.Equatable {
    /// The logging level.
    public var logLevel: IoTClientTypes.LogLevel?
    /// The ARN of the IAM role that grants access.
    public var roleArn: Swift.String?

    public init(
        logLevel: IoTClientTypes.LogLevel? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.logLevel = logLevel
        self.roleArn = roleArn
    }
}

struct GetLoggingOptionsOutputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let logLevel: IoTClientTypes.LogLevel?
}

extension GetLoggingOptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

enum GetLoggingOptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetOTAUpdateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let otaUpdateId = otaUpdateId else {
            return nil
        }
        return "/otaUpdates/\(otaUpdateId.urlPercentEncoding())"
    }
}

public struct GetOTAUpdateInput: Swift.Equatable {
    /// The OTA update ID.
    /// This member is required.
    public var otaUpdateId: Swift.String?

    public init(
        otaUpdateId: Swift.String? = nil
    )
    {
        self.otaUpdateId = otaUpdateId
    }
}

struct GetOTAUpdateInputBody: Swift.Equatable {
}

extension GetOTAUpdateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetOTAUpdateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOTAUpdateOutputBody = try responseDecoder.decode(responseBody: data)
            self.otaUpdateInfo = output.otaUpdateInfo
        } else {
            self.otaUpdateInfo = nil
        }
    }
}

public struct GetOTAUpdateOutput: Swift.Equatable {
    /// The OTA update info.
    public var otaUpdateInfo: IoTClientTypes.OTAUpdateInfo?

    public init(
        otaUpdateInfo: IoTClientTypes.OTAUpdateInfo? = nil
    )
    {
        self.otaUpdateInfo = otaUpdateInfo
    }
}

struct GetOTAUpdateOutputBody: Swift.Equatable {
    let otaUpdateInfo: IoTClientTypes.OTAUpdateInfo?
}

extension GetOTAUpdateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case otaUpdateInfo
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otaUpdateInfoDecoded = try containerValues.decodeIfPresent(IoTClientTypes.OTAUpdateInfo.self, forKey: .otaUpdateInfo)
        otaUpdateInfo = otaUpdateInfoDecoded
    }
}

enum GetOTAUpdateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPackageConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/package-configuration"
    }
}

public struct GetPackageConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetPackageConfigurationInputBody: Swift.Equatable {
}

extension GetPackageConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPackageConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPackageConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.versionUpdateByJobsConfig = output.versionUpdateByJobsConfig
        } else {
            self.versionUpdateByJobsConfig = nil
        }
    }
}

public struct GetPackageConfigurationOutput: Swift.Equatable {
    /// The version that is associated to a specific job.
    public var versionUpdateByJobsConfig: IoTClientTypes.VersionUpdateByJobsConfig?

    public init(
        versionUpdateByJobsConfig: IoTClientTypes.VersionUpdateByJobsConfig? = nil
    )
    {
        self.versionUpdateByJobsConfig = versionUpdateByJobsConfig
    }
}

struct GetPackageConfigurationOutputBody: Swift.Equatable {
    let versionUpdateByJobsConfig: IoTClientTypes.VersionUpdateByJobsConfig?
}

extension GetPackageConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versionUpdateByJobsConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionUpdateByJobsConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.VersionUpdateByJobsConfig.self, forKey: .versionUpdateByJobsConfig)
        versionUpdateByJobsConfig = versionUpdateByJobsConfigDecoded
    }
}

enum GetPackageConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageName = packageName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())"
    }
}

public struct GetPackageInput: Swift.Equatable {
    /// The name of the target software package.
    /// This member is required.
    public var packageName: Swift.String?

    public init(
        packageName: Swift.String? = nil
    )
    {
        self.packageName = packageName
    }
}

struct GetPackageInputBody: Swift.Equatable {
}

extension GetPackageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPackageOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPackageOutput(creationDate: \(Swift.String(describing: creationDate)), defaultVersionName: \(Swift.String(describing: defaultVersionName)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), packageArn: \(Swift.String(describing: packageArn)), packageName: \(Swift.String(describing: packageName)), description: \"CONTENT_REDACTED\")"}
}

extension GetPackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPackageOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.defaultVersionName = output.defaultVersionName
            self.description = output.description
            self.lastModifiedDate = output.lastModifiedDate
            self.packageArn = output.packageArn
            self.packageName = output.packageName
        } else {
            self.creationDate = nil
            self.defaultVersionName = nil
            self.description = nil
            self.lastModifiedDate = nil
            self.packageArn = nil
            self.packageName = nil
        }
    }
}

public struct GetPackageOutput: Swift.Equatable {
    /// The date the package was created.
    public var creationDate: ClientRuntime.Date?
    /// The name of the default package version.
    public var defaultVersionName: Swift.String?
    /// The package description.
    public var description: Swift.String?
    /// The date when the package was last updated.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The ARN for the package.
    public var packageArn: Swift.String?
    /// The name of the software package.
    public var packageName: Swift.String?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        defaultVersionName: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        packageArn: Swift.String? = nil,
        packageName: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.defaultVersionName = defaultVersionName
        self.description = description
        self.lastModifiedDate = lastModifiedDate
        self.packageArn = packageArn
        self.packageName = packageName
    }
}

struct GetPackageOutputBody: Swift.Equatable {
    let packageName: Swift.String?
    let packageArn: Swift.String?
    let description: Swift.String?
    let defaultVersionName: Swift.String?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
}

extension GetPackageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case defaultVersionName
        case description
        case lastModifiedDate
        case packageArn
        case packageName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageArn)
        packageArn = packageArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultVersionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersionName)
        defaultVersionName = defaultVersionNameDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

enum GetPackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPackageVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageName = packageName else {
            return nil
        }
        guard let versionName = versionName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())/versions/\(versionName.urlPercentEncoding())"
    }
}

public struct GetPackageVersionInput: Swift.Equatable {
    /// The name of the associated package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The name of the target package version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        packageName: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.packageName = packageName
        self.versionName = versionName
    }
}

struct GetPackageVersionInputBody: Swift.Equatable {
}

extension GetPackageVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPackageVersionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPackageVersionOutput(creationDate: \(Swift.String(describing: creationDate)), errorReason: \(Swift.String(describing: errorReason)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), packageName: \(Swift.String(describing: packageName)), packageVersionArn: \(Swift.String(describing: packageVersionArn)), status: \(Swift.String(describing: status)), versionName: \(Swift.String(describing: versionName)), attributes: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

extension GetPackageVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPackageVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
            self.creationDate = output.creationDate
            self.description = output.description
            self.errorReason = output.errorReason
            self.lastModifiedDate = output.lastModifiedDate
            self.packageName = output.packageName
            self.packageVersionArn = output.packageVersionArn
            self.status = output.status
            self.versionName = output.versionName
        } else {
            self.attributes = nil
            self.creationDate = nil
            self.description = nil
            self.errorReason = nil
            self.lastModifiedDate = nil
            self.packageName = nil
            self.packageVersionArn = nil
            self.status = nil
            self.versionName = nil
        }
    }
}

public struct GetPackageVersionOutput: Swift.Equatable {
    /// Metadata that were added to the package version that can be used to define a package versions configuration.
    public var attributes: [Swift.String:Swift.String]?
    /// The date when the package version was created.
    public var creationDate: ClientRuntime.Date?
    /// The package version description.
    public var description: Swift.String?
    /// Error reason for a package version failure during creation or update.
    public var errorReason: Swift.String?
    /// The date when the package version was last updated.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The name of the software package.
    public var packageName: Swift.String?
    /// The ARN for the package version.
    public var packageVersionArn: Swift.String?
    /// The status associated to the package version. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle).
    public var status: IoTClientTypes.PackageVersionStatus?
    /// The name of the package version.
    public var versionName: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        creationDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        errorReason: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        packageName: Swift.String? = nil,
        packageVersionArn: Swift.String? = nil,
        status: IoTClientTypes.PackageVersionStatus? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.creationDate = creationDate
        self.description = description
        self.errorReason = errorReason
        self.lastModifiedDate = lastModifiedDate
        self.packageName = packageName
        self.packageVersionArn = packageVersionArn
        self.status = status
        self.versionName = versionName
    }
}

struct GetPackageVersionOutputBody: Swift.Equatable {
    let packageVersionArn: Swift.String?
    let packageName: Swift.String?
    let versionName: Swift.String?
    let description: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let status: IoTClientTypes.PackageVersionStatus?
    let errorReason: Swift.String?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
}

extension GetPackageVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case creationDate
        case description
        case errorReason
        case lastModifiedDate
        case packageName
        case packageVersionArn
        case status
        case versionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersionArn)
        packageVersionArn = packageVersionArnDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, resourceattributevalue0) in attributesContainer {
                if let resourceattributevalue0 = resourceattributevalue0 {
                    attributesDecoded0?[key0] = resourceattributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
        let errorReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorReason)
        errorReason = errorReasonDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

enum GetPackageVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPercentilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationField
        case indexName
        case percents
        case queryString
        case queryVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationField = self.aggregationField {
            try encodeContainer.encode(aggregationField, forKey: .aggregationField)
        }
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let percents = percents {
            var percentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .percents)
            for percent0 in percents {
                try percentsContainer.encode(percent0)
            }
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = self.queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
    }
}

extension GetPercentilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/indices/percentiles"
    }
}

public struct GetPercentilesInput: Swift.Equatable {
    /// The field to aggregate.
    public var aggregationField: Swift.String?
    /// The name of the index to search.
    public var indexName: Swift.String?
    /// The percentile groups returned.
    public var percents: [Swift.Double]?
    /// The search query string.
    /// This member is required.
    public var queryString: Swift.String?
    /// The query version.
    public var queryVersion: Swift.String?

    public init(
        aggregationField: Swift.String? = nil,
        indexName: Swift.String? = nil,
        percents: [Swift.Double]? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil
    )
    {
        self.aggregationField = aggregationField
        self.indexName = indexName
        self.percents = percents
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

struct GetPercentilesInputBody: Swift.Equatable {
    let indexName: Swift.String?
    let queryString: Swift.String?
    let aggregationField: Swift.String?
    let queryVersion: Swift.String?
    let percents: [Swift.Double]?
}

extension GetPercentilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationField
        case indexName
        case percents
        case queryString
        case queryVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let aggregationFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregationField)
        aggregationField = aggregationFieldDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
        let percentsContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .percents)
        var percentsDecoded0:[Swift.Double]? = nil
        if let percentsContainer = percentsContainer {
            percentsDecoded0 = [Swift.Double]()
            for double0 in percentsContainer {
                if let double0 = double0 {
                    percentsDecoded0?.append(double0)
                }
            }
        }
        percents = percentsDecoded0
    }
}

extension GetPercentilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPercentilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.percentiles = output.percentiles
        } else {
            self.percentiles = nil
        }
    }
}

public struct GetPercentilesOutput: Swift.Equatable {
    /// The percentile values of the aggregated fields.
    public var percentiles: [IoTClientTypes.PercentPair]?

    public init(
        percentiles: [IoTClientTypes.PercentPair]? = nil
    )
    {
        self.percentiles = percentiles
    }
}

struct GetPercentilesOutputBody: Swift.Equatable {
    let percentiles: [IoTClientTypes.PercentPair]?
}

extension GetPercentilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentiles
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentilesContainer = try containerValues.decodeIfPresent([IoTClientTypes.PercentPair?].self, forKey: .percentiles)
        var percentilesDecoded0:[IoTClientTypes.PercentPair]? = nil
        if let percentilesContainer = percentilesContainer {
            percentilesDecoded0 = [IoTClientTypes.PercentPair]()
            for structure0 in percentilesContainer {
                if let structure0 = structure0 {
                    percentilesDecoded0?.append(structure0)
                }
            }
        }
        percentiles = percentilesDecoded0
    }
}

enum GetPercentilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IndexNotReadyException": return try await IndexNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAggregationException": return try await InvalidAggregationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidQueryException": return try await InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let policyName = policyName else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())"
    }
}

/// The input for the GetPolicy operation.
public struct GetPolicyInput: Swift.Equatable {
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        policyName: Swift.String? = nil
    )
    {
        self.policyName = policyName
    }
}

struct GetPolicyInputBody: Swift.Equatable {
}

extension GetPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.defaultVersionId = output.defaultVersionId
            self.generationId = output.generationId
            self.lastModifiedDate = output.lastModifiedDate
            self.policyArn = output.policyArn
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
        } else {
            self.creationDate = nil
            self.defaultVersionId = nil
            self.generationId = nil
            self.lastModifiedDate = nil
            self.policyArn = nil
            self.policyDocument = nil
            self.policyName = nil
        }
    }
}

/// The output from the GetPolicy operation.
public struct GetPolicyOutput: Swift.Equatable {
    /// The date the policy was created.
    public var creationDate: ClientRuntime.Date?
    /// The default policy version ID.
    public var defaultVersionId: Swift.String?
    /// The generation ID of the policy.
    public var generationId: Swift.String?
    /// The date the policy was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The policy ARN.
    public var policyArn: Swift.String?
    /// The JSON document that describes the policy.
    public var policyDocument: Swift.String?
    /// The policy name.
    public var policyName: Swift.String?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        defaultVersionId: Swift.String? = nil,
        generationId: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        policyArn: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.defaultVersionId = defaultVersionId
        self.generationId = generationId
        self.lastModifiedDate = lastModifiedDate
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.policyName = policyName
    }
}

struct GetPolicyOutputBody: Swift.Equatable {
    let policyName: Swift.String?
    let policyArn: Swift.String?
    let policyDocument: Swift.String?
    let defaultVersionId: Swift.String?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
    let generationId: Swift.String?
}

extension GetPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case defaultVersionId
        case generationId
        case lastModifiedDate
        case policyArn
        case policyDocument
        case policyName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let generationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationId)
        generationId = generationIdDecoded
    }
}

enum GetPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let policyName = policyName else {
            return nil
        }
        guard let policyVersionId = policyVersionId else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())/version/\(policyVersionId.urlPercentEncoding())"
    }
}

/// The input for the GetPolicyVersion operation.
public struct GetPolicyVersionInput: Swift.Equatable {
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The policy version ID.
    /// This member is required.
    public var policyVersionId: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        policyVersionId: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

struct GetPolicyVersionInputBody: Swift.Equatable {
}

extension GetPolicyVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPolicyVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPolicyVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.generationId = output.generationId
            self.isDefaultVersion = output.isDefaultVersion
            self.lastModifiedDate = output.lastModifiedDate
            self.policyArn = output.policyArn
            self.policyDocument = output.policyDocument
            self.policyName = output.policyName
            self.policyVersionId = output.policyVersionId
        } else {
            self.creationDate = nil
            self.generationId = nil
            self.isDefaultVersion = false
            self.lastModifiedDate = nil
            self.policyArn = nil
            self.policyDocument = nil
            self.policyName = nil
            self.policyVersionId = nil
        }
    }
}

/// The output from the GetPolicyVersion operation.
public struct GetPolicyVersionOutput: Swift.Equatable {
    /// The date the policy was created.
    public var creationDate: ClientRuntime.Date?
    /// The generation ID of the policy version.
    public var generationId: Swift.String?
    /// Specifies whether the policy version is the default.
    public var isDefaultVersion: Swift.Bool
    /// The date the policy was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The policy ARN.
    public var policyArn: Swift.String?
    /// The JSON document that describes the policy.
    public var policyDocument: Swift.String?
    /// The policy name.
    public var policyName: Swift.String?
    /// The policy version ID.
    public var policyVersionId: Swift.String?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        generationId: Swift.String? = nil,
        isDefaultVersion: Swift.Bool = false,
        lastModifiedDate: ClientRuntime.Date? = nil,
        policyArn: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        policyVersionId: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.generationId = generationId
        self.isDefaultVersion = isDefaultVersion
        self.lastModifiedDate = lastModifiedDate
        self.policyArn = policyArn
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

struct GetPolicyVersionOutputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let policyName: Swift.String?
    let policyDocument: Swift.String?
    let policyVersionId: Swift.String?
    let isDefaultVersion: Swift.Bool
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
    let generationId: Swift.String?
}

extension GetPolicyVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case generationId
        case isDefaultVersion
        case lastModifiedDate
        case policyArn
        case policyDocument
        case policyName
        case policyVersionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let policyVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersionId)
        policyVersionId = policyVersionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefaultVersion) ?? false
        isDefaultVersion = isDefaultVersionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let generationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationId)
        generationId = generationIdDecoded
    }
}

enum GetPolicyVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRegistrationCodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/registrationcode"
    }
}

/// The input to the GetRegistrationCode operation.
public struct GetRegistrationCodeInput: Swift.Equatable {

    public init() { }
}

struct GetRegistrationCodeInputBody: Swift.Equatable {
}

extension GetRegistrationCodeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRegistrationCodeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRegistrationCodeOutputBody = try responseDecoder.decode(responseBody: data)
            self.registrationCode = output.registrationCode
        } else {
            self.registrationCode = nil
        }
    }
}

/// The output from the GetRegistrationCode operation.
public struct GetRegistrationCodeOutput: Swift.Equatable {
    /// The CA certificate registration code.
    public var registrationCode: Swift.String?

    public init(
        registrationCode: Swift.String? = nil
    )
    {
        self.registrationCode = registrationCode
    }
}

struct GetRegistrationCodeOutputBody: Swift.Equatable {
    let registrationCode: Swift.String?
}

extension GetRegistrationCodeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationCode)
        registrationCode = registrationCodeDecoded
    }
}

enum GetRegistrationCodeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationField
        case indexName
        case queryString
        case queryVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationField = self.aggregationField {
            try encodeContainer.encode(aggregationField, forKey: .aggregationField)
        }
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = self.queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
    }
}

extension GetStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/indices/statistics"
    }
}

public struct GetStatisticsInput: Swift.Equatable {
    /// The aggregation field name.
    public var aggregationField: Swift.String?
    /// The name of the index to search. The default value is AWS_Things.
    public var indexName: Swift.String?
    /// The query used to search. You can specify "*" for the query string to get the count of all indexed things in your Amazon Web Services account.
    /// This member is required.
    public var queryString: Swift.String?
    /// The version of the query used to search.
    public var queryVersion: Swift.String?

    public init(
        aggregationField: Swift.String? = nil,
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil
    )
    {
        self.aggregationField = aggregationField
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

struct GetStatisticsInputBody: Swift.Equatable {
    let indexName: Swift.String?
    let queryString: Swift.String?
    let aggregationField: Swift.String?
    let queryVersion: Swift.String?
}

extension GetStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationField
        case indexName
        case queryString
        case queryVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let aggregationFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregationField)
        aggregationField = aggregationFieldDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
    }
}

extension GetStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.statistics = output.statistics
        } else {
            self.statistics = nil
        }
    }
}

public struct GetStatisticsOutput: Swift.Equatable {
    /// The statistics returned by the Fleet Indexing service based on the query and aggregation field.
    public var statistics: IoTClientTypes.Statistics?

    public init(
        statistics: IoTClientTypes.Statistics? = nil
    )
    {
        self.statistics = statistics
    }
}

struct GetStatisticsOutputBody: Swift.Equatable {
    let statistics: IoTClientTypes.Statistics?
}

extension GetStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statistics
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statisticsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.Statistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

enum GetStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IndexNotReadyException": return try await IndexNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAggregationException": return try await InvalidAggregationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidQueryException": return try await InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTopicRuleDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/destinations/\(arn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetTopicRuleDestinationInput: Swift.Equatable {
    /// The ARN of the topic rule destination.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetTopicRuleDestinationInputBody: Swift.Equatable {
}

extension GetTopicRuleDestinationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTopicRuleDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTopicRuleDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.topicRuleDestination = output.topicRuleDestination
        } else {
            self.topicRuleDestination = nil
        }
    }
}

public struct GetTopicRuleDestinationOutput: Swift.Equatable {
    /// The topic rule destination.
    public var topicRuleDestination: IoTClientTypes.TopicRuleDestination?

    public init(
        topicRuleDestination: IoTClientTypes.TopicRuleDestination? = nil
    )
    {
        self.topicRuleDestination = topicRuleDestination
    }
}

struct GetTopicRuleDestinationOutputBody: Swift.Equatable {
    let topicRuleDestination: IoTClientTypes.TopicRuleDestination?
}

extension GetTopicRuleDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicRuleDestination
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicRuleDestinationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TopicRuleDestination.self, forKey: .topicRuleDestination)
        topicRuleDestination = topicRuleDestinationDecoded
    }
}

enum GetTopicRuleDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTopicRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ruleName = ruleName else {
            return nil
        }
        return "/rules/\(ruleName.urlPercentEncoding())"
    }
}

/// The input for the GetTopicRule operation.
public struct GetTopicRuleInput: Swift.Equatable {
    /// The name of the rule.
    /// This member is required.
    public var ruleName: Swift.String?

    public init(
        ruleName: Swift.String? = nil
    )
    {
        self.ruleName = ruleName
    }
}

struct GetTopicRuleInputBody: Swift.Equatable {
}

extension GetTopicRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTopicRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTopicRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.rule = output.rule
            self.ruleArn = output.ruleArn
        } else {
            self.rule = nil
            self.ruleArn = nil
        }
    }
}

/// The output from the GetTopicRule operation.
public struct GetTopicRuleOutput: Swift.Equatable {
    /// The rule.
    public var rule: IoTClientTypes.TopicRule?
    /// The rule ARN.
    public var ruleArn: Swift.String?

    public init(
        rule: IoTClientTypes.TopicRule? = nil,
        ruleArn: Swift.String? = nil
    )
    {
        self.rule = rule
        self.ruleArn = ruleArn
    }
}

struct GetTopicRuleOutputBody: Swift.Equatable {
    let ruleArn: Swift.String?
    let rule: IoTClientTypes.TopicRule?
}

extension GetTopicRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rule
        case ruleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
        let ruleDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TopicRule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

enum GetTopicRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetV2LoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2LoggingOptions"
    }
}

public struct GetV2LoggingOptionsInput: Swift.Equatable {

    public init() { }
}

struct GetV2LoggingOptionsInputBody: Swift.Equatable {
}

extension GetV2LoggingOptionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetV2LoggingOptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetV2LoggingOptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.defaultLogLevel = output.defaultLogLevel
            self.disableAllLogs = output.disableAllLogs
            self.roleArn = output.roleArn
        } else {
            self.defaultLogLevel = nil
            self.disableAllLogs = false
            self.roleArn = nil
        }
    }
}

public struct GetV2LoggingOptionsOutput: Swift.Equatable {
    /// The default log level.
    public var defaultLogLevel: IoTClientTypes.LogLevel?
    /// Disables all logs.
    public var disableAllLogs: Swift.Bool
    /// The IAM role ARN IoT uses to write to your CloudWatch logs.
    public var roleArn: Swift.String?

    public init(
        defaultLogLevel: IoTClientTypes.LogLevel? = nil,
        disableAllLogs: Swift.Bool = false,
        roleArn: Swift.String? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.disableAllLogs = disableAllLogs
        self.roleArn = roleArn
    }
}

struct GetV2LoggingOptionsOutputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let defaultLogLevel: IoTClientTypes.LogLevel?
    let disableAllLogs: Swift.Bool
}

extension GetV2LoggingOptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel
        case disableAllLogs
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let disableAllLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableAllLogs) ?? false
        disableAllLogs = disableAllLogsDecoded
    }
}

enum GetV2LoggingOptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotConfiguredException": return try await NotConfiguredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.GroupNameAndArn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupArn
        case groupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupArn = self.groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
    }
}

extension IoTClientTypes {
    /// The name and ARN of a group.
    public struct GroupNameAndArn: Swift.Equatable {
        /// The group ARN.
        public var groupArn: Swift.String?
        /// The group name.
        public var groupName: Swift.String?

        public init(
            groupArn: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupArn = groupArn
            self.groupName = groupName
        }
    }

}

extension IoTClientTypes.HttpAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auth
        case confirmationUrl
        case headers
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auth = self.auth {
            try encodeContainer.encode(auth, forKey: .auth)
        }
        if let confirmationUrl = self.confirmationUrl {
            try encodeContainer.encode(confirmationUrl, forKey: .confirmationUrl)
        }
        if let headers = headers {
            var headersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headers)
            for httpactionheader0 in headers {
                try headersContainer.encode(httpactionheader0)
            }
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let confirmationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .confirmationUrl)
        confirmationUrl = confirmationUrlDecoded
        let headersContainer = try containerValues.decodeIfPresent([IoTClientTypes.HttpActionHeader?].self, forKey: .headers)
        var headersDecoded0:[IoTClientTypes.HttpActionHeader]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [IoTClientTypes.HttpActionHeader]()
            for structure0 in headersContainer {
                if let structure0 = structure0 {
                    headersDecoded0?.append(structure0)
                }
            }
        }
        headers = headersDecoded0
        let authDecoded = try containerValues.decodeIfPresent(IoTClientTypes.HttpAuthorization.self, forKey: .auth)
        auth = authDecoded
    }
}

extension IoTClientTypes {
    /// Send data to an HTTPS endpoint.
    public struct HttpAction: Swift.Equatable {
        /// The authentication method to use when sending data to an HTTPS endpoint.
        public var auth: IoTClientTypes.HttpAuthorization?
        /// The URL to which IoT sends a confirmation message. The value of the confirmation URL must be a prefix of the endpoint URL. If you do not specify a confirmation URL IoT uses the endpoint URL as the confirmation URL. If you use substitution templates in the confirmationUrl, you must create and enable topic rule destinations that match each possible value of the substitution template before traffic is allowed to your endpoint URL.
        public var confirmationUrl: Swift.String?
        /// The HTTP headers to send with the message data.
        public var headers: [IoTClientTypes.HttpActionHeader]?
        /// The endpoint URL. If substitution templates are used in the URL, you must also specify a confirmationUrl. If this is a new destination, a new TopicRuleDestination is created if possible.
        /// This member is required.
        public var url: Swift.String?

        public init(
            auth: IoTClientTypes.HttpAuthorization? = nil,
            confirmationUrl: Swift.String? = nil,
            headers: [IoTClientTypes.HttpActionHeader]? = nil,
            url: Swift.String? = nil
        )
        {
            self.auth = auth
            self.confirmationUrl = confirmationUrl
            self.headers = headers
            self.url = url
        }
    }

}

extension IoTClientTypes.HttpActionHeader: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTClientTypes {
    /// The HTTP action header.
    public struct HttpActionHeader: Swift.Equatable {
        /// The HTTP header key.
        /// This member is required.
        public var key: Swift.String?
        /// The HTTP header value. Substitution templates are supported.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension IoTClientTypes.HttpAuthorization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sigv4
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sigv4 = self.sigv4 {
            try encodeContainer.encode(sigv4, forKey: .sigv4)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sigv4Decoded = try containerValues.decodeIfPresent(IoTClientTypes.SigV4Authorization.self, forKey: .sigv4)
        sigv4 = sigv4Decoded
    }
}

extension IoTClientTypes {
    /// The authorization method used to send messages.
    public struct HttpAuthorization: Swift.Equatable {
        /// Use Sig V4 authorization. For more information, see [Signature Version 4 Signing Process](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html).
        public var sigv4: IoTClientTypes.SigV4Authorization?

        public init(
            sigv4: IoTClientTypes.SigV4Authorization? = nil
        )
        {
            self.sigv4 = sigv4
        }
    }

}

extension IoTClientTypes.HttpContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headers
        case queryString
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headers = headers {
            var headersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .headers)
            for (dictKey0, httpHeaders0) in headers {
                try headersContainer.encode(httpHeaders0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headers)
        var headersDecoded0: [Swift.String:Swift.String]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [Swift.String:Swift.String]()
            for (key0, httpheadervalue0) in headersContainer {
                if let httpheadervalue0 = httpheadervalue0 {
                    headersDecoded0?[key0] = httpheadervalue0
                }
            }
        }
        headers = headersDecoded0
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
    }
}

extension IoTClientTypes {
    /// Specifies the HTTP context to use for the test authorizer request.
    public struct HttpContext: Swift.Equatable {
        /// The header keys and values in an HTTP authorization request.
        public var headers: [Swift.String:Swift.String]?
        /// The query string keys and values in an HTTP authorization request.
        public var queryString: Swift.String?

        public init(
            headers: [Swift.String:Swift.String]? = nil,
            queryString: Swift.String? = nil
        )
        {
            self.headers = headers
            self.queryString = queryString
        }
    }

}

extension IoTClientTypes.HttpUrlDestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confirmationUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confirmationUrl = self.confirmationUrl {
            try encodeContainer.encode(confirmationUrl, forKey: .confirmationUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confirmationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .confirmationUrl)
        confirmationUrl = confirmationUrlDecoded
    }
}

extension IoTClientTypes {
    /// HTTP URL destination configuration used by the topic rule's HTTP action.
    public struct HttpUrlDestinationConfiguration: Swift.Equatable {
        /// The URL IoT uses to confirm ownership of or access to the topic rule destination URL.
        /// This member is required.
        public var confirmationUrl: Swift.String?

        public init(
            confirmationUrl: Swift.String? = nil
        )
        {
            self.confirmationUrl = confirmationUrl
        }
    }

}

extension IoTClientTypes.HttpUrlDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confirmationUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confirmationUrl = self.confirmationUrl {
            try encodeContainer.encode(confirmationUrl, forKey: .confirmationUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confirmationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .confirmationUrl)
        confirmationUrl = confirmationUrlDecoded
    }
}

extension IoTClientTypes {
    /// HTTP URL destination properties.
    public struct HttpUrlDestinationProperties: Swift.Equatable {
        /// The URL used to confirm the HTTP topic rule destination URL.
        public var confirmationUrl: Swift.String?

        public init(
            confirmationUrl: Swift.String? = nil
        )
        {
            self.confirmationUrl = confirmationUrl
        }
    }

}

extension IoTClientTypes.HttpUrlDestinationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confirmationUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confirmationUrl = self.confirmationUrl {
            try encodeContainer.encode(confirmationUrl, forKey: .confirmationUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confirmationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .confirmationUrl)
        confirmationUrl = confirmationUrlDecoded
    }
}

extension IoTClientTypes {
    /// Information about an HTTP URL destination.
    public struct HttpUrlDestinationSummary: Swift.Equatable {
        /// The URL used to confirm ownership of or access to the HTTP topic rule destination URL.
        public var confirmationUrl: Swift.String?

        public init(
            confirmationUrl: Swift.String? = nil
        )
        {
            self.confirmationUrl = confirmationUrl
        }
    }

}

extension IoTClientTypes.ImplicitDeny: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policies
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for policy0 in policies {
                try policiesContainer.encode(policy0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([IoTClientTypes.Policy?].self, forKey: .policies)
        var policiesDecoded0:[IoTClientTypes.Policy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [IoTClientTypes.Policy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
    }
}

extension IoTClientTypes {
    /// Information that implicitly denies authorization. When policy doesn't explicitly deny or allow an action on a resource it is considered an implicit deny.
    public struct ImplicitDeny: Swift.Equatable {
        /// Policies that don't contain a matching allow or deny statement for the specified action on the specified resource.
        public var policies: [IoTClientTypes.Policy]?

        public init(
            policies: [IoTClientTypes.Policy]? = nil
        )
        {
            self.policies = policies
        }
    }

}

extension IndexNotReadyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IndexNotReadyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The index is not ready.
public struct IndexNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IndexNotReadyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IndexNotReadyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IndexNotReadyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes {
    public enum IndexStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case building
        case rebuilding
        case sdkUnknown(Swift.String)

        public static var allCases: [IndexStatus] {
            return [
                .active,
                .building,
                .rebuilding,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .building: return "BUILDING"
            case .rebuilding: return "REBUILDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IndexStatus(rawValue: rawValue) ?? IndexStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.IndexingFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedShadowNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namedShadowNames = namedShadowNames {
            var namedShadowNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .namedShadowNames)
            for shadowname0 in namedShadowNames {
                try namedShadowNamesContainer.encode(shadowname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedShadowNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .namedShadowNames)
        var namedShadowNamesDecoded0:[Swift.String]? = nil
        if let namedShadowNamesContainer = namedShadowNamesContainer {
            namedShadowNamesDecoded0 = [Swift.String]()
            for string0 in namedShadowNamesContainer {
                if let string0 = string0 {
                    namedShadowNamesDecoded0?.append(string0)
                }
            }
        }
        namedShadowNames = namedShadowNamesDecoded0
    }
}

extension IoTClientTypes {
    /// Provides additional filters for specific data sources. Named shadow is the only data source that currently supports and requires a filter. To add named shadows to your fleet indexing configuration, set namedShadowIndexingMode to be ON and specify your shadow names in filter.
    public struct IndexingFilter: Swift.Equatable {
        /// The shadow names that you select to index. The default maximum number of shadow names for indexing is 10. To increase the limit, see [Amazon Web Services IoT Device Management Quotas](https://docs.aws.amazon.com/general/latest/gr/iot_device_management.html#fleet-indexing-limits) in the Amazon Web Services General Reference.
        public var namedShadowNames: [Swift.String]?

        public init(
            namedShadowNames: [Swift.String]? = nil
        )
        {
            self.namedShadowNames = namedShadowNames
        }
    }

}

extension InternalException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error has occurred.
public struct InternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error has occurred.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Internal error from the service that indicates an unexpected error or that the service is unavailable.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAggregationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidAggregationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The aggregation is invalid.
public struct InvalidAggregationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAggregationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidAggregationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAggregationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidQueryException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidQueryExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The query is invalid.
public struct InvalidQueryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidQueryException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidQueryExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidQueryExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is not valid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResponseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidResponseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The response is invalid.
public struct InvalidResponseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResponseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidResponseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResponseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateTransitionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidStateTransitionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An attempt was made to change to an invalid state, for example by deleting a job or a job execution which is "IN_PROGRESS" without setting the force parameter.
public struct InvalidStateTransitionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidStateTransitionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidStateTransitionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidStateTransitionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes.IotAnalyticsAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchMode
        case channelArn
        case channelName
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchMode = self.batchMode {
            try encodeContainer.encode(batchMode, forKey: .batchMode)
        }
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let batchModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .batchMode)
        batchMode = batchModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTClientTypes {
    /// Sends message data to an IoT Analytics channel.
    public struct IotAnalyticsAction: Swift.Equatable {
        /// Whether to process the action as a batch. The default value is false. When batchMode is true and the rule SQL statement evaluates to an Array, each Array element is delivered as a separate message when passed by [BatchPutMessage](https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_BatchPutMessage.html) to the IoT Analytics channel. The resulting array can't have more than 100 messages.
        public var batchMode: Swift.Bool?
        /// (deprecated) The ARN of the IoT Analytics channel to which message data will be sent.
        public var channelArn: Swift.String?
        /// The name of the IoT Analytics channel to which message data will be sent.
        public var channelName: Swift.String?
        /// The ARN of the role which has a policy that grants IoT Analytics permission to send message data via IoT Analytics (iotanalytics:BatchPutMessage).
        public var roleArn: Swift.String?

        public init(
            batchMode: Swift.Bool? = nil,
            channelArn: Swift.String? = nil,
            channelName: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.batchMode = batchMode
            self.channelArn = channelArn
            self.channelName = channelName
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes.IotEventsAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchMode
        case inputName
        case messageId
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchMode = self.batchMode {
            try encodeContainer.encode(batchMode, forKey: .batchMode)
        }
        if let inputName = self.inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let batchModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .batchMode)
        batchMode = batchModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTClientTypes {
    /// Sends an input to an IoT Events detector.
    public struct IotEventsAction: Swift.Equatable {
        /// Whether to process the event actions as a batch. The default value is false. When batchMode is true, you can't specify a messageId. When batchMode is true and the rule SQL statement evaluates to an Array, each Array element is treated as a separate message when it's sent to IoT Events by calling [BatchPutMessage](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchPutMessage.html). The resulting array can't have more than 10 messages.
        public var batchMode: Swift.Bool?
        /// The name of the IoT Events input.
        /// This member is required.
        public var inputName: Swift.String?
        /// The ID of the message. The default messageId is a new UUID value. When batchMode is true, you can't specify a messageId--a new UUID value will be assigned. Assign a value to this property to ensure that only one input (message) with a given messageId will be processed by an IoT Events detector.
        public var messageId: Swift.String?
        /// The ARN of the role that grants IoT permission to send an input to an IoT Events detector. ("Action":"iotevents:BatchPutMessage").
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            batchMode: Swift.Bool? = nil,
            inputName: Swift.String? = nil,
            messageId: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.batchMode = batchMode
            self.inputName = inputName
            self.messageId = messageId
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes.IotSiteWiseAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case putAssetPropertyValueEntries
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let putAssetPropertyValueEntries = putAssetPropertyValueEntries {
            var putAssetPropertyValueEntriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .putAssetPropertyValueEntries)
            for putassetpropertyvalueentry0 in putAssetPropertyValueEntries {
                try putAssetPropertyValueEntriesContainer.encode(putassetpropertyvalueentry0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let putAssetPropertyValueEntriesContainer = try containerValues.decodeIfPresent([IoTClientTypes.PutAssetPropertyValueEntry?].self, forKey: .putAssetPropertyValueEntries)
        var putAssetPropertyValueEntriesDecoded0:[IoTClientTypes.PutAssetPropertyValueEntry]? = nil
        if let putAssetPropertyValueEntriesContainer = putAssetPropertyValueEntriesContainer {
            putAssetPropertyValueEntriesDecoded0 = [IoTClientTypes.PutAssetPropertyValueEntry]()
            for structure0 in putAssetPropertyValueEntriesContainer {
                if let structure0 = structure0 {
                    putAssetPropertyValueEntriesDecoded0?.append(structure0)
                }
            }
        }
        putAssetPropertyValueEntries = putAssetPropertyValueEntriesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action to send data from an MQTT message that triggered the rule to IoT SiteWise asset properties.
    public struct IotSiteWiseAction: Swift.Equatable {
        /// A list of asset property value entries.
        /// This member is required.
        public var putAssetPropertyValueEntries: [IoTClientTypes.PutAssetPropertyValueEntry]?
        /// The ARN of the role that grants IoT permission to send an asset property value to IoT SiteWise. ("Action": "iotsitewise:BatchPutAssetPropertyValue"). The trust policy can restrict access to specific asset hierarchy paths.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            putAssetPropertyValueEntries: [IoTClientTypes.PutAssetPropertyValueEntry]? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.putAssetPropertyValueEntries = putAssetPropertyValueEntries
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes.IssuerCertificateIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case issuerCertificateSerialNumber
        case issuerCertificateSubject
        case issuerId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let issuerCertificateSerialNumber = self.issuerCertificateSerialNumber {
            try encodeContainer.encode(issuerCertificateSerialNumber, forKey: .issuerCertificateSerialNumber)
        }
        if let issuerCertificateSubject = self.issuerCertificateSubject {
            try encodeContainer.encode(issuerCertificateSubject, forKey: .issuerCertificateSubject)
        }
        if let issuerId = self.issuerId {
            try encodeContainer.encode(issuerId, forKey: .issuerId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issuerCertificateSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuerCertificateSubject)
        issuerCertificateSubject = issuerCertificateSubjectDecoded
        let issuerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuerId)
        issuerId = issuerIdDecoded
        let issuerCertificateSerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuerCertificateSerialNumber)
        issuerCertificateSerialNumber = issuerCertificateSerialNumberDecoded
    }
}

extension IoTClientTypes {
    /// The certificate issuer indentifier.
    public struct IssuerCertificateIdentifier: Swift.Equatable {
        /// The issuer certificate serial number.
        public var issuerCertificateSerialNumber: Swift.String?
        /// The subject of the issuer certificate.
        public var issuerCertificateSubject: Swift.String?
        /// The issuer ID.
        public var issuerId: Swift.String?

        public init(
            issuerCertificateSerialNumber: Swift.String? = nil,
            issuerCertificateSubject: Swift.String? = nil,
            issuerId: Swift.String? = nil
        )
        {
            self.issuerCertificateSerialNumber = issuerCertificateSerialNumber
            self.issuerCertificateSubject = issuerCertificateSubject
            self.issuerId = issuerId
        }
    }

}

extension IoTClientTypes.Job: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortConfig
        case comment
        case completedAt
        case createdAt
        case description
        case destinationPackageVersions
        case documentParameters
        case forceCanceled
        case isConcurrent
        case jobArn
        case jobExecutionsRetryConfig
        case jobExecutionsRolloutConfig
        case jobId
        case jobProcessDetails
        case jobTemplateArn
        case lastUpdatedAt
        case namespaceId
        case presignedUrlConfig
        case reasonCode
        case scheduledJobRollouts
        case schedulingConfig
        case status
        case targetSelection
        case targets
        case timeoutConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortConfig = self.abortConfig {
            try encodeContainer.encode(abortConfig, forKey: .abortConfig)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let completedAt = self.completedAt {
            try encodeContainer.encodeTimestamp(completedAt, format: .epochSeconds, forKey: .completedAt)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationPackageVersions = destinationPackageVersions {
            var destinationPackageVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPackageVersions)
            for packageversionarn0 in destinationPackageVersions {
                try destinationPackageVersionsContainer.encode(packageversionarn0)
            }
        }
        if let documentParameters = documentParameters {
            var documentParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .documentParameters)
            for (dictKey0, parameterMap0) in documentParameters {
                try documentParametersContainer.encode(parameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let forceCanceled = self.forceCanceled {
            try encodeContainer.encode(forceCanceled, forKey: .forceCanceled)
        }
        if let isConcurrent = self.isConcurrent {
            try encodeContainer.encode(isConcurrent, forKey: .isConcurrent)
        }
        if let jobArn = self.jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobExecutionsRetryConfig = self.jobExecutionsRetryConfig {
            try encodeContainer.encode(jobExecutionsRetryConfig, forKey: .jobExecutionsRetryConfig)
        }
        if let jobExecutionsRolloutConfig = self.jobExecutionsRolloutConfig {
            try encodeContainer.encode(jobExecutionsRolloutConfig, forKey: .jobExecutionsRolloutConfig)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobProcessDetails = self.jobProcessDetails {
            try encodeContainer.encode(jobProcessDetails, forKey: .jobProcessDetails)
        }
        if let jobTemplateArn = self.jobTemplateArn {
            try encodeContainer.encode(jobTemplateArn, forKey: .jobTemplateArn)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let namespaceId = self.namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let presignedUrlConfig = self.presignedUrlConfig {
            try encodeContainer.encode(presignedUrlConfig, forKey: .presignedUrlConfig)
        }
        if let reasonCode = self.reasonCode {
            try encodeContainer.encode(reasonCode, forKey: .reasonCode)
        }
        if let scheduledJobRollouts = scheduledJobRollouts {
            var scheduledJobRolloutsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scheduledJobRollouts)
            for scheduledjobrollout0 in scheduledJobRollouts {
                try scheduledJobRolloutsContainer.encode(scheduledjobrollout0)
            }
        }
        if let schedulingConfig = self.schedulingConfig {
            try encodeContainer.encode(schedulingConfig, forKey: .schedulingConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetSelection = self.targetSelection {
            try encodeContainer.encode(targetSelection.rawValue, forKey: .targetSelection)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targetarn0 in targets {
                try targetsContainer.encode(targetarn0)
            }
        }
        if let timeoutConfig = self.timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let targetSelectionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TargetSelection.self, forKey: .targetSelection)
        targetSelection = targetSelectionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let forceCanceledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceCanceled)
        forceCanceled = forceCanceledDecoded
        let reasonCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reasonCode)
        reasonCode = reasonCodeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let presignedUrlConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.PresignedUrlConfig.self, forKey: .presignedUrlConfig)
        presignedUrlConfig = presignedUrlConfigDecoded
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let completedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completedAt)
        completedAt = completedAtDecoded
        let jobProcessDetailsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobProcessDetails.self, forKey: .jobProcessDetails)
        jobProcessDetails = jobProcessDetailsDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let jobTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTemplateArn)
        jobTemplateArn = jobTemplateArnDecoded
        let jobExecutionsRetryConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionsRetryConfig.self, forKey: .jobExecutionsRetryConfig)
        jobExecutionsRetryConfig = jobExecutionsRetryConfigDecoded
        let documentParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .documentParameters)
        var documentParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let documentParametersContainer = documentParametersContainer {
            documentParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in documentParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    documentParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        documentParameters = documentParametersDecoded0
        let isConcurrentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isConcurrent)
        isConcurrent = isConcurrentDecoded
        let schedulingConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.SchedulingConfig.self, forKey: .schedulingConfig)
        schedulingConfig = schedulingConfigDecoded
        let scheduledJobRolloutsContainer = try containerValues.decodeIfPresent([IoTClientTypes.ScheduledJobRollout?].self, forKey: .scheduledJobRollouts)
        var scheduledJobRolloutsDecoded0:[IoTClientTypes.ScheduledJobRollout]? = nil
        if let scheduledJobRolloutsContainer = scheduledJobRolloutsContainer {
            scheduledJobRolloutsDecoded0 = [IoTClientTypes.ScheduledJobRollout]()
            for structure0 in scheduledJobRolloutsContainer {
                if let structure0 = structure0 {
                    scheduledJobRolloutsDecoded0?.append(structure0)
                }
            }
        }
        scheduledJobRollouts = scheduledJobRolloutsDecoded0
        let destinationPackageVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinationPackageVersions)
        var destinationPackageVersionsDecoded0:[Swift.String]? = nil
        if let destinationPackageVersionsContainer = destinationPackageVersionsContainer {
            destinationPackageVersionsDecoded0 = [Swift.String]()
            for string0 in destinationPackageVersionsContainer {
                if let string0 = string0 {
                    destinationPackageVersionsDecoded0?.append(string0)
                }
            }
        }
        destinationPackageVersions = destinationPackageVersionsDecoded0
    }
}

extension IoTClientTypes {
    /// The Job object contains details about a job.
    public struct Job: Swift.Equatable {
        /// Configuration for criteria to abort the job.
        public var abortConfig: IoTClientTypes.AbortConfig?
        /// If the job was updated, describes the reason for the update.
        public var comment: Swift.String?
        /// The time, in seconds since the epoch, when the job was completed.
        public var completedAt: ClientRuntime.Date?
        /// The time, in seconds since the epoch, when the job was created.
        public var createdAt: ClientRuntime.Date?
        /// A short text description of the job.
        public var description: Swift.String?
        /// The package version Amazon Resource Names (ARNs) that are installed on the device when the job successfully completes. Note:The following Length Constraints relates to a single string. Up to five strings are allowed.
        public var destinationPackageVersions: [Swift.String]?
        /// A key-value map that pairs the patterns that need to be replaced in a managed template job document schema. You can use the description of each key as a guidance to specify the inputs during runtime when creating a job. documentParameters can only be used when creating jobs from Amazon Web Services managed templates. This parameter can't be used with custom job templates or to create jobs from them.
        public var documentParameters: [Swift.String:Swift.String]?
        /// Will be true if the job was canceled with the optional force parameter set to true.
        public var forceCanceled: Swift.Bool?
        /// Indicates whether a job is concurrent. Will be true when a job is rolling out new job executions or canceling previously created executions, otherwise false.
        public var isConcurrent: Swift.Bool?
        /// An ARN identifying the job with format "arn:aws:iot:region:account:job/jobId".
        public var jobArn: Swift.String?
        /// The configuration for the criteria to retry the job.
        public var jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
        /// Allows you to create a staged rollout of a job.
        public var jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
        /// The unique identifier you assigned to this job when it was created.
        public var jobId: Swift.String?
        /// Details about the job process.
        public var jobProcessDetails: IoTClientTypes.JobProcessDetails?
        /// The ARN of the job template used to create the job.
        public var jobTemplateArn: Swift.String?
        /// The time, in seconds since the epoch, when the job was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is in public preview.
        public var namespaceId: Swift.String?
        /// Configuration for pre-signed S3 URLs.
        public var presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
        /// If the job was updated, provides the reason code for the update.
        public var reasonCode: Swift.String?
        /// Displays the next seven maintenance window occurrences and their start times.
        public var scheduledJobRollouts: [IoTClientTypes.ScheduledJobRollout]?
        /// The configuration that allows you to schedule a job for a future date and time in addition to specifying the end behavior for each job execution.
        public var schedulingConfig: IoTClientTypes.SchedulingConfig?
        /// The status of the job, one of IN_PROGRESS, CANCELED, DELETION_IN_PROGRESS or COMPLETED.
        public var status: IoTClientTypes.JobStatus?
        /// Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a device when the thing representing the device is added to a target group, even after the job was completed by all things originally in the group. We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.
        public var targetSelection: IoTClientTypes.TargetSelection?
        /// A list of IoT things and thing groups to which the job should be sent.
        public var targets: [Swift.String]?
        /// Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to TIMED_OUT.
        public var timeoutConfig: IoTClientTypes.TimeoutConfig?

        public init(
            abortConfig: IoTClientTypes.AbortConfig? = nil,
            comment: Swift.String? = nil,
            completedAt: ClientRuntime.Date? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            destinationPackageVersions: [Swift.String]? = nil,
            documentParameters: [Swift.String:Swift.String]? = nil,
            forceCanceled: Swift.Bool? = nil,
            isConcurrent: Swift.Bool? = nil,
            jobArn: Swift.String? = nil,
            jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig? = nil,
            jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig? = nil,
            jobId: Swift.String? = nil,
            jobProcessDetails: IoTClientTypes.JobProcessDetails? = nil,
            jobTemplateArn: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            namespaceId: Swift.String? = nil,
            presignedUrlConfig: IoTClientTypes.PresignedUrlConfig? = nil,
            reasonCode: Swift.String? = nil,
            scheduledJobRollouts: [IoTClientTypes.ScheduledJobRollout]? = nil,
            schedulingConfig: IoTClientTypes.SchedulingConfig? = nil,
            status: IoTClientTypes.JobStatus? = nil,
            targetSelection: IoTClientTypes.TargetSelection? = nil,
            targets: [Swift.String]? = nil,
            timeoutConfig: IoTClientTypes.TimeoutConfig? = nil
        )
        {
            self.abortConfig = abortConfig
            self.comment = comment
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.description = description
            self.destinationPackageVersions = destinationPackageVersions
            self.documentParameters = documentParameters
            self.forceCanceled = forceCanceled
            self.isConcurrent = isConcurrent
            self.jobArn = jobArn
            self.jobExecutionsRetryConfig = jobExecutionsRetryConfig
            self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
            self.jobId = jobId
            self.jobProcessDetails = jobProcessDetails
            self.jobTemplateArn = jobTemplateArn
            self.lastUpdatedAt = lastUpdatedAt
            self.namespaceId = namespaceId
            self.presignedUrlConfig = presignedUrlConfig
            self.reasonCode = reasonCode
            self.scheduledJobRollouts = scheduledJobRollouts
            self.schedulingConfig = schedulingConfig
            self.status = status
            self.targetSelection = targetSelection
            self.targets = targets
            self.timeoutConfig = timeoutConfig
        }
    }

}

extension IoTClientTypes {
    public enum JobEndBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancel
        case forceCancel
        case stopRollout
        case sdkUnknown(Swift.String)

        public static var allCases: [JobEndBehavior] {
            return [
                .cancel,
                .forceCancel,
                .stopRollout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case .forceCancel: return "FORCE_CANCEL"
            case .stopRollout: return "STOP_ROLLOUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobEndBehavior(rawValue: rawValue) ?? JobEndBehavior.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.JobExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateSecondsBeforeTimedOut
        case executionNumber
        case forceCanceled
        case jobId
        case lastUpdatedAt
        case queuedAt
        case startedAt
        case status
        case statusDetails
        case thingArn
        case versionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateSecondsBeforeTimedOut = self.approximateSecondsBeforeTimedOut {
            try encodeContainer.encode(approximateSecondsBeforeTimedOut, forKey: .approximateSecondsBeforeTimedOut)
        }
        if let executionNumber = self.executionNumber {
            try encodeContainer.encode(executionNumber, forKey: .executionNumber)
        }
        if let forceCanceled = self.forceCanceled {
            try encodeContainer.encode(forceCanceled, forKey: .forceCanceled)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let queuedAt = self.queuedAt {
            try encodeContainer.encodeTimestamp(queuedAt, format: .epochSeconds, forKey: .queuedAt)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .epochSeconds, forKey: .startedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = self.statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let forceCanceledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceCanceled)
        forceCanceled = forceCanceledDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionStatusDetails.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let queuedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .queuedAt)
        queuedAt = queuedAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedAt)
        startedAt = startedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let executionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionNumber)
        executionNumber = executionNumberDecoded
        let versionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionNumber) ?? 0
        versionNumber = versionNumberDecoded
        let approximateSecondsBeforeTimedOutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateSecondsBeforeTimedOut)
        approximateSecondsBeforeTimedOut = approximateSecondsBeforeTimedOutDecoded
    }
}

extension IoTClientTypes {
    /// The job execution object represents the execution of a job on a particular device.
    public struct JobExecution: Swift.Equatable {
        /// The estimated number of seconds that remain before the job execution status will be changed to TIMED_OUT. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The actual job execution timeout can occur up to 60 seconds later than the estimated duration. This value will not be included if the job execution has reached a terminal status.
        public var approximateSecondsBeforeTimedOut: Swift.Int?
        /// A string (consisting of the digits "0" through "9") which identifies this particular job execution on this particular device. It can be used in commands which return or update job execution information.
        public var executionNumber: Swift.Int?
        /// Will be true if the job execution was canceled with the optional force parameter set to true.
        public var forceCanceled: Swift.Bool?
        /// The unique identifier you assigned to the job when it was created.
        public var jobId: Swift.String?
        /// The time, in seconds since the epoch, when the job execution was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The time, in seconds since the epoch, when the job execution was queued.
        public var queuedAt: ClientRuntime.Date?
        /// The time, in seconds since the epoch, when the job execution started.
        public var startedAt: ClientRuntime.Date?
        /// The status of the job execution (IN_PROGRESS, QUEUED, FAILED, SUCCEEDED, TIMED_OUT, CANCELED, or REJECTED).
        public var status: IoTClientTypes.JobExecutionStatus?
        /// A collection of name/value pairs that describe the status of the job execution.
        public var statusDetails: IoTClientTypes.JobExecutionStatusDetails?
        /// The ARN of the thing on which the job execution is running.
        public var thingArn: Swift.String?
        /// The version of the job execution. Job execution versions are incremented each time they are updated by a device.
        public var versionNumber: Swift.Int

        public init(
            approximateSecondsBeforeTimedOut: Swift.Int? = nil,
            executionNumber: Swift.Int? = nil,
            forceCanceled: Swift.Bool? = nil,
            jobId: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            queuedAt: ClientRuntime.Date? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: IoTClientTypes.JobExecutionStatus? = nil,
            statusDetails: IoTClientTypes.JobExecutionStatusDetails? = nil,
            thingArn: Swift.String? = nil,
            versionNumber: Swift.Int = 0
        )
        {
            self.approximateSecondsBeforeTimedOut = approximateSecondsBeforeTimedOut
            self.executionNumber = executionNumber
            self.forceCanceled = forceCanceled
            self.jobId = jobId
            self.lastUpdatedAt = lastUpdatedAt
            self.queuedAt = queuedAt
            self.startedAt = startedAt
            self.status = status
            self.statusDetails = statusDetails
            self.thingArn = thingArn
            self.versionNumber = versionNumber
        }
    }

}

extension IoTClientTypes {
    public enum JobExecutionFailureType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case failed
        case rejected
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [JobExecutionFailureType] {
            return [
                .all,
                .failed,
                .rejected,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .rejected: return "REJECTED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobExecutionFailureType(rawValue: rawValue) ?? JobExecutionFailureType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum JobExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case queued
        case rejected
        case removed
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [JobExecutionStatus] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .queued,
                .rejected,
                .removed,
                .succeeded,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .rejected: return "REJECTED"
            case .removed: return "REMOVED"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobExecutionStatus(rawValue: rawValue) ?? JobExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.JobExecutionStatusDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detailsMap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailsMap = detailsMap {
            var detailsMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .detailsMap)
            for (dictKey0, detailsMap0) in detailsMap {
                try detailsMapContainer.encode(detailsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .detailsMap)
        var detailsMapDecoded0: [Swift.String:Swift.String]? = nil
        if let detailsMapContainer = detailsMapContainer {
            detailsMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, detailsvalue0) in detailsMapContainer {
                if let detailsvalue0 = detailsvalue0 {
                    detailsMapDecoded0?[key0] = detailsvalue0
                }
            }
        }
        detailsMap = detailsMapDecoded0
    }
}

extension IoTClientTypes {
    /// Details of the job execution status.
    public struct JobExecutionStatusDetails: Swift.Equatable {
        /// The job execution status.
        public var detailsMap: [Swift.String:Swift.String]?

        public init(
            detailsMap: [Swift.String:Swift.String]? = nil
        )
        {
            self.detailsMap = detailsMap
        }
    }

}

extension IoTClientTypes.JobExecutionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionNumber
        case lastUpdatedAt
        case queuedAt
        case retryAttempt
        case startedAt
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionNumber = self.executionNumber {
            try encodeContainer.encode(executionNumber, forKey: .executionNumber)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let queuedAt = self.queuedAt {
            try encodeContainer.encodeTimestamp(queuedAt, format: .epochSeconds, forKey: .queuedAt)
        }
        if let retryAttempt = self.retryAttempt {
            try encodeContainer.encode(retryAttempt, forKey: .retryAttempt)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .epochSeconds, forKey: .startedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let queuedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .queuedAt)
        queuedAt = queuedAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedAt)
        startedAt = startedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let executionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionNumber)
        executionNumber = executionNumberDecoded
        let retryAttemptDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryAttempt)
        retryAttempt = retryAttemptDecoded
    }
}

extension IoTClientTypes {
    /// The job execution summary.
    public struct JobExecutionSummary: Swift.Equatable {
        /// A string (consisting of the digits "0" through "9") which identifies this particular job execution on this particular device. It can be used later in commands which return or update job execution information.
        public var executionNumber: Swift.Int?
        /// The time, in seconds since the epoch, when the job execution was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The time, in seconds since the epoch, when the job execution was queued.
        public var queuedAt: ClientRuntime.Date?
        /// The number that indicates how many retry attempts have been completed for this job on this device.
        public var retryAttempt: Swift.Int?
        /// The time, in seconds since the epoch, when the job execution started.
        public var startedAt: ClientRuntime.Date?
        /// The status of the job execution.
        public var status: IoTClientTypes.JobExecutionStatus?

        public init(
            executionNumber: Swift.Int? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            queuedAt: ClientRuntime.Date? = nil,
            retryAttempt: Swift.Int? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: IoTClientTypes.JobExecutionStatus? = nil
        )
        {
            self.executionNumber = executionNumber
            self.lastUpdatedAt = lastUpdatedAt
            self.queuedAt = queuedAt
            self.retryAttempt = retryAttempt
            self.startedAt = startedAt
            self.status = status
        }
    }

}

extension IoTClientTypes.JobExecutionSummaryForJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobExecutionSummary
        case thingArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobExecutionSummary = self.jobExecutionSummary {
            try encodeContainer.encode(jobExecutionSummary, forKey: .jobExecutionSummary)
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let jobExecutionSummaryDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionSummary.self, forKey: .jobExecutionSummary)
        jobExecutionSummary = jobExecutionSummaryDecoded
    }
}

extension IoTClientTypes {
    /// Contains a summary of information about job executions for a specific job.
    public struct JobExecutionSummaryForJob: Swift.Equatable {
        /// Contains a subset of information about a job execution.
        public var jobExecutionSummary: IoTClientTypes.JobExecutionSummary?
        /// The ARN of the thing on which the job execution is running.
        public var thingArn: Swift.String?

        public init(
            jobExecutionSummary: IoTClientTypes.JobExecutionSummary? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.jobExecutionSummary = jobExecutionSummary
            self.thingArn = thingArn
        }
    }

}

extension IoTClientTypes.JobExecutionSummaryForThing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobExecutionSummary
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobExecutionSummary = self.jobExecutionSummary {
            try encodeContainer.encode(jobExecutionSummary, forKey: .jobExecutionSummary)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobExecutionSummaryDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionSummary.self, forKey: .jobExecutionSummary)
        jobExecutionSummary = jobExecutionSummaryDecoded
    }
}

extension IoTClientTypes {
    /// The job execution summary for a thing.
    public struct JobExecutionSummaryForThing: Swift.Equatable {
        /// Contains a subset of information about a job execution.
        public var jobExecutionSummary: IoTClientTypes.JobExecutionSummary?
        /// The unique identifier you assigned to this job when it was created.
        public var jobId: Swift.String?

        public init(
            jobExecutionSummary: IoTClientTypes.JobExecutionSummary? = nil,
            jobId: Swift.String? = nil
        )
        {
            self.jobExecutionSummary = jobExecutionSummary
            self.jobId = jobId
        }
    }

}

extension IoTClientTypes.JobExecutionsRetryConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criteriaList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criteriaList = criteriaList {
            var criteriaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .criteriaList)
            for retrycriteria0 in criteriaList {
                try criteriaListContainer.encode(retrycriteria0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criteriaListContainer = try containerValues.decodeIfPresent([IoTClientTypes.RetryCriteria?].self, forKey: .criteriaList)
        var criteriaListDecoded0:[IoTClientTypes.RetryCriteria]? = nil
        if let criteriaListContainer = criteriaListContainer {
            criteriaListDecoded0 = [IoTClientTypes.RetryCriteria]()
            for structure0 in criteriaListContainer {
                if let structure0 = structure0 {
                    criteriaListDecoded0?.append(structure0)
                }
            }
        }
        criteriaList = criteriaListDecoded0
    }
}

extension IoTClientTypes {
    /// The configuration that determines how many retries are allowed for each failure type for a job.
    public struct JobExecutionsRetryConfig: Swift.Equatable {
        /// The list of criteria that determines how many retries are allowed for each failure type for a job.
        /// This member is required.
        public var criteriaList: [IoTClientTypes.RetryCriteria]?

        public init(
            criteriaList: [IoTClientTypes.RetryCriteria]? = nil
        )
        {
            self.criteriaList = criteriaList
        }
    }

}

extension IoTClientTypes.JobExecutionsRolloutConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exponentialRate
        case maximumPerMinute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exponentialRate = self.exponentialRate {
            try encodeContainer.encode(exponentialRate, forKey: .exponentialRate)
        }
        if let maximumPerMinute = self.maximumPerMinute {
            try encodeContainer.encode(maximumPerMinute, forKey: .maximumPerMinute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumPerMinuteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumPerMinute)
        maximumPerMinute = maximumPerMinuteDecoded
        let exponentialRateDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ExponentialRolloutRate.self, forKey: .exponentialRate)
        exponentialRate = exponentialRateDecoded
    }
}

extension IoTClientTypes {
    /// Allows you to create a staged rollout of a job.
    public struct JobExecutionsRolloutConfig: Swift.Equatable {
        /// The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.
        public var exponentialRate: IoTClientTypes.ExponentialRolloutRate?
        /// The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.
        public var maximumPerMinute: Swift.Int?

        public init(
            exponentialRate: IoTClientTypes.ExponentialRolloutRate? = nil,
            maximumPerMinute: Swift.Int? = nil
        )
        {
            self.exponentialRate = exponentialRate
            self.maximumPerMinute = maximumPerMinute
        }
    }

}

extension IoTClientTypes.JobProcessDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfCanceledThings
        case numberOfFailedThings
        case numberOfInProgressThings
        case numberOfQueuedThings
        case numberOfRejectedThings
        case numberOfRemovedThings
        case numberOfSucceededThings
        case numberOfTimedOutThings
        case processingTargets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfCanceledThings = self.numberOfCanceledThings {
            try encodeContainer.encode(numberOfCanceledThings, forKey: .numberOfCanceledThings)
        }
        if let numberOfFailedThings = self.numberOfFailedThings {
            try encodeContainer.encode(numberOfFailedThings, forKey: .numberOfFailedThings)
        }
        if let numberOfInProgressThings = self.numberOfInProgressThings {
            try encodeContainer.encode(numberOfInProgressThings, forKey: .numberOfInProgressThings)
        }
        if let numberOfQueuedThings = self.numberOfQueuedThings {
            try encodeContainer.encode(numberOfQueuedThings, forKey: .numberOfQueuedThings)
        }
        if let numberOfRejectedThings = self.numberOfRejectedThings {
            try encodeContainer.encode(numberOfRejectedThings, forKey: .numberOfRejectedThings)
        }
        if let numberOfRemovedThings = self.numberOfRemovedThings {
            try encodeContainer.encode(numberOfRemovedThings, forKey: .numberOfRemovedThings)
        }
        if let numberOfSucceededThings = self.numberOfSucceededThings {
            try encodeContainer.encode(numberOfSucceededThings, forKey: .numberOfSucceededThings)
        }
        if let numberOfTimedOutThings = self.numberOfTimedOutThings {
            try encodeContainer.encode(numberOfTimedOutThings, forKey: .numberOfTimedOutThings)
        }
        if let processingTargets = processingTargets {
            var processingTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processingTargets)
            for processingtargetname0 in processingTargets {
                try processingTargetsContainer.encode(processingtargetname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processingTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .processingTargets)
        var processingTargetsDecoded0:[Swift.String]? = nil
        if let processingTargetsContainer = processingTargetsContainer {
            processingTargetsDecoded0 = [Swift.String]()
            for string0 in processingTargetsContainer {
                if let string0 = string0 {
                    processingTargetsDecoded0?.append(string0)
                }
            }
        }
        processingTargets = processingTargetsDecoded0
        let numberOfCanceledThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfCanceledThings)
        numberOfCanceledThings = numberOfCanceledThingsDecoded
        let numberOfSucceededThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfSucceededThings)
        numberOfSucceededThings = numberOfSucceededThingsDecoded
        let numberOfFailedThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfFailedThings)
        numberOfFailedThings = numberOfFailedThingsDecoded
        let numberOfRejectedThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRejectedThings)
        numberOfRejectedThings = numberOfRejectedThingsDecoded
        let numberOfQueuedThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfQueuedThings)
        numberOfQueuedThings = numberOfQueuedThingsDecoded
        let numberOfInProgressThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfInProgressThings)
        numberOfInProgressThings = numberOfInProgressThingsDecoded
        let numberOfRemovedThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRemovedThings)
        numberOfRemovedThings = numberOfRemovedThingsDecoded
        let numberOfTimedOutThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfTimedOutThings)
        numberOfTimedOutThings = numberOfTimedOutThingsDecoded
    }
}

extension IoTClientTypes {
    /// The job process details.
    public struct JobProcessDetails: Swift.Equatable {
        /// The number of things that cancelled the job.
        public var numberOfCanceledThings: Swift.Int?
        /// The number of things that failed executing the job.
        public var numberOfFailedThings: Swift.Int?
        /// The number of things currently executing the job.
        public var numberOfInProgressThings: Swift.Int?
        /// The number of things that are awaiting execution of the job.
        public var numberOfQueuedThings: Swift.Int?
        /// The number of things that rejected the job.
        public var numberOfRejectedThings: Swift.Int?
        /// The number of things that are no longer scheduled to execute the job because they have been deleted or have been removed from the group that was a target of the job.
        public var numberOfRemovedThings: Swift.Int?
        /// The number of things which successfully completed the job.
        public var numberOfSucceededThings: Swift.Int?
        /// The number of things whose job execution status is TIMED_OUT.
        public var numberOfTimedOutThings: Swift.Int?
        /// The target devices to which the job execution is being rolled out. This value will be null after the job execution has finished rolling out to all the target devices.
        public var processingTargets: [Swift.String]?

        public init(
            numberOfCanceledThings: Swift.Int? = nil,
            numberOfFailedThings: Swift.Int? = nil,
            numberOfInProgressThings: Swift.Int? = nil,
            numberOfQueuedThings: Swift.Int? = nil,
            numberOfRejectedThings: Swift.Int? = nil,
            numberOfRemovedThings: Swift.Int? = nil,
            numberOfSucceededThings: Swift.Int? = nil,
            numberOfTimedOutThings: Swift.Int? = nil,
            processingTargets: [Swift.String]? = nil
        )
        {
            self.numberOfCanceledThings = numberOfCanceledThings
            self.numberOfFailedThings = numberOfFailedThings
            self.numberOfInProgressThings = numberOfInProgressThings
            self.numberOfQueuedThings = numberOfQueuedThings
            self.numberOfRejectedThings = numberOfRejectedThings
            self.numberOfRemovedThings = numberOfRemovedThings
            self.numberOfSucceededThings = numberOfSucceededThings
            self.numberOfTimedOutThings = numberOfTimedOutThings
            self.processingTargets = processingTargets
        }
    }

}

extension IoTClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case completed
        case deletionInProgress
        case inProgress
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .canceled,
                .completed,
                .deletionInProgress,
                .inProgress,
                .scheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .deletionInProgress: return "DELETION_IN_PROGRESS"
            case .inProgress: return "IN_PROGRESS"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.JobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completedAt
        case createdAt
        case isConcurrent
        case jobArn
        case jobId
        case lastUpdatedAt
        case status
        case targetSelection
        case thingGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedAt = self.completedAt {
            try encodeContainer.encodeTimestamp(completedAt, format: .epochSeconds, forKey: .completedAt)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let isConcurrent = self.isConcurrent {
            try encodeContainer.encode(isConcurrent, forKey: .isConcurrent)
        }
        if let jobArn = self.jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetSelection = self.targetSelection {
            try encodeContainer.encode(targetSelection.rawValue, forKey: .targetSelection)
        }
        if let thingGroupId = self.thingGroupId {
            try encodeContainer.encode(thingGroupId, forKey: .thingGroupId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let thingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupId)
        thingGroupId = thingGroupIdDecoded
        let targetSelectionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TargetSelection.self, forKey: .targetSelection)
        targetSelection = targetSelectionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let completedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completedAt)
        completedAt = completedAtDecoded
        let isConcurrentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isConcurrent)
        isConcurrent = isConcurrentDecoded
    }
}

extension IoTClientTypes {
    /// The job summary.
    public struct JobSummary: Swift.Equatable {
        /// The time, in seconds since the epoch, when the job completed.
        public var completedAt: ClientRuntime.Date?
        /// The time, in seconds since the epoch, when the job was created.
        public var createdAt: ClientRuntime.Date?
        /// Indicates whether a job is concurrent. Will be true when a job is rolling out new job executions or canceling previously created executions, otherwise false.
        public var isConcurrent: Swift.Bool?
        /// The job ARN.
        public var jobArn: Swift.String?
        /// The unique identifier you assigned to this job when it was created.
        public var jobId: Swift.String?
        /// The time, in seconds since the epoch, when the job was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The job summary status.
        public var status: IoTClientTypes.JobStatus?
        /// Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.
        public var targetSelection: IoTClientTypes.TargetSelection?
        /// The ID of the thing group.
        public var thingGroupId: Swift.String?

        public init(
            completedAt: ClientRuntime.Date? = nil,
            createdAt: ClientRuntime.Date? = nil,
            isConcurrent: Swift.Bool? = nil,
            jobArn: Swift.String? = nil,
            jobId: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            status: IoTClientTypes.JobStatus? = nil,
            targetSelection: IoTClientTypes.TargetSelection? = nil,
            thingGroupId: Swift.String? = nil
        )
        {
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.isConcurrent = isConcurrent
            self.jobArn = jobArn
            self.jobId = jobId
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.targetSelection = targetSelection
            self.thingGroupId = thingGroupId
        }
    }

}

extension IoTClientTypes.JobTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case jobTemplateArn
        case jobTemplateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let jobTemplateArn = self.jobTemplateArn {
            try encodeContainer.encode(jobTemplateArn, forKey: .jobTemplateArn)
        }
        if let jobTemplateId = self.jobTemplateId {
            try encodeContainer.encode(jobTemplateId, forKey: .jobTemplateId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTemplateArn)
        jobTemplateArn = jobTemplateArnDecoded
        let jobTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTemplateId)
        jobTemplateId = jobTemplateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension IoTClientTypes {
    /// An object that contains information about the job template.
    public struct JobTemplateSummary: Swift.Equatable {
        /// The time, in seconds since the epoch, when the job template was created.
        public var createdAt: ClientRuntime.Date?
        /// A description of the job template.
        public var description: Swift.String?
        /// The ARN of the job template.
        public var jobTemplateArn: Swift.String?
        /// The unique identifier of the job template.
        public var jobTemplateId: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            jobTemplateArn: Swift.String? = nil,
            jobTemplateId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.jobTemplateArn = jobTemplateArn
            self.jobTemplateId = jobTemplateId
        }
    }

}

extension IoTClientTypes.KafkaAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientProperties
        case destinationArn
        case headers
        case key
        case partition
        case topic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientProperties = clientProperties {
            var clientPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .clientProperties)
            for (dictKey0, clientProperties0) in clientProperties {
                try clientPropertiesContainer.encode(clientProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let headers = headers {
            var headersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headers)
            for kafkaactionheader0 in headers {
                try headersContainer.encode(kafkaactionheader0)
            }
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let partition = self.partition {
            try encodeContainer.encode(partition, forKey: .partition)
        }
        if let topic = self.topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let topicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topic)
        topic = topicDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let partitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partition)
        partition = partitionDecoded
        let clientPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .clientProperties)
        var clientPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let clientPropertiesContainer = clientPropertiesContainer {
            clientPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in clientPropertiesContainer {
                if let string0 = string0 {
                    clientPropertiesDecoded0?[key0] = string0
                }
            }
        }
        clientProperties = clientPropertiesDecoded0
        let headersContainer = try containerValues.decodeIfPresent([IoTClientTypes.KafkaActionHeader?].self, forKey: .headers)
        var headersDecoded0:[IoTClientTypes.KafkaActionHeader]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [IoTClientTypes.KafkaActionHeader]()
            for structure0 in headersContainer {
                if let structure0 = structure0 {
                    headersDecoded0?.append(structure0)
                }
            }
        }
        headers = headersDecoded0
    }
}

extension IoTClientTypes {
    /// Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.
    public struct KafkaAction: Swift.Equatable {
        /// Properties of the Apache Kafka producer client.
        /// This member is required.
        public var clientProperties: [Swift.String:Swift.String]?
        /// The ARN of Kafka action's VPC TopicRuleDestination.
        /// This member is required.
        public var destinationArn: Swift.String?
        /// The list of Kafka headers that you specify.
        public var headers: [IoTClientTypes.KafkaActionHeader]?
        /// The Kafka message key.
        public var key: Swift.String?
        /// The Kafka message partition.
        public var partition: Swift.String?
        /// The Kafka topic for messages to be sent to the Kafka broker.
        /// This member is required.
        public var topic: Swift.String?

        public init(
            clientProperties: [Swift.String:Swift.String]? = nil,
            destinationArn: Swift.String? = nil,
            headers: [IoTClientTypes.KafkaActionHeader]? = nil,
            key: Swift.String? = nil,
            partition: Swift.String? = nil,
            topic: Swift.String? = nil
        )
        {
            self.clientProperties = clientProperties
            self.destinationArn = destinationArn
            self.headers = headers
            self.key = key
            self.partition = partition
            self.topic = topic
        }
    }

}

extension IoTClientTypes.KafkaActionHeader: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTClientTypes {
    /// Specifies a Kafka header using key-value pairs when you create a Rules Kafka Action. You can use these headers to route data from IoT clients to downstream Kafka clusters without modifying your message payload. For more information about Rule's Kafka action, see [Apache Kafka](https://docs.aws.amazon.com/iot/latest/developerguide/apache-kafka-rule-action.html).
    public struct KafkaActionHeader: Swift.Equatable {
        /// The key of the Kafka header.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the Kafka header.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension IoTClientTypes.KeyPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case privateKey = "PrivateKey"
        case publicKey = "PublicKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let privateKey = self.privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
        if let publicKey = self.publicKey {
            try encodeContainer.encode(publicKey, forKey: .publicKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
    }
}

extension IoTClientTypes.KeyPair: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyPair(publicKey: \(Swift.String(describing: publicKey)), privateKey: \"CONTENT_REDACTED\")"}
}

extension IoTClientTypes {
    /// Describes a key pair.
    public struct KeyPair: Swift.Equatable {
        /// The private key.
        public var privateKey: Swift.String?
        /// The public key.
        public var publicKey: Swift.String?

        public init(
            privateKey: Swift.String? = nil,
            publicKey: Swift.String? = nil
        )
        {
            self.privateKey = privateKey
            self.publicKey = publicKey
        }
    }

}

extension IoTClientTypes.KinesisAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case partitionKey
        case roleArn
        case streamName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let partitionKey = self.partitionKey {
            try encodeContainer.encode(partitionKey, forKey: .partitionKey)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let partitionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partitionKey)
        partitionKey = partitionKeyDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action to write data to an Amazon Kinesis stream.
    public struct KinesisAction: Swift.Equatable {
        /// The partition key.
        public var partitionKey: Swift.String?
        /// The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The name of the Amazon Kinesis stream.
        /// This member is required.
        public var streamName: Swift.String?

        public init(
            partitionKey: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            streamName: Swift.String? = nil
        )
        {
            self.partitionKey = partitionKey
            self.roleArn = roleArn
            self.streamName = streamName
        }
    }

}

extension IoTClientTypes.LambdaAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionArn = self.functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action to invoke a Lambda function.
    public struct LambdaAction: Swift.Equatable {
        /// The ARN of the Lambda function.
        /// This member is required.
        public var functionArn: Swift.String?

        public init(
            functionArn: Swift.String? = nil
        )
        {
            self.functionArn = functionArn
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A limit has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListActiveViolationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let securityProfileName = securityProfileName {
                let securityProfileNameQueryItem = ClientRuntime.URLQueryItem(name: "securityProfileName".urlPercentEncoding(), value: Swift.String(securityProfileName).urlPercentEncoding())
                items.append(securityProfileNameQueryItem)
            }
            if let listSuppressedAlerts = listSuppressedAlerts {
                let listSuppressedAlertsQueryItem = ClientRuntime.URLQueryItem(name: "listSuppressedAlerts".urlPercentEncoding(), value: Swift.String(listSuppressedAlerts).urlPercentEncoding())
                items.append(listSuppressedAlertsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let behaviorCriteriaType = behaviorCriteriaType {
                let behaviorCriteriaTypeQueryItem = ClientRuntime.URLQueryItem(name: "behaviorCriteriaType".urlPercentEncoding(), value: Swift.String(behaviorCriteriaType.rawValue).urlPercentEncoding())
                items.append(behaviorCriteriaTypeQueryItem)
            }
            if let thingName = thingName {
                let thingNameQueryItem = ClientRuntime.URLQueryItem(name: "thingName".urlPercentEncoding(), value: Swift.String(thingName).urlPercentEncoding())
                items.append(thingNameQueryItem)
            }
            if let verificationState = verificationState {
                let verificationStateQueryItem = ClientRuntime.URLQueryItem(name: "verificationState".urlPercentEncoding(), value: Swift.String(verificationState.rawValue).urlPercentEncoding())
                items.append(verificationStateQueryItem)
            }
            return items
        }
    }
}

extension ListActiveViolationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/active-violations"
    }
}

public struct ListActiveViolationsInput: Swift.Equatable {
    /// The criteria for a behavior.
    public var behaviorCriteriaType: IoTClientTypes.BehaviorCriteriaType?
    /// A list of all suppressed alerts.
    public var listSuppressedAlerts: Swift.Bool?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The name of the Device Defender security profile for which violations are listed.
    public var securityProfileName: Swift.String?
    /// The name of the thing whose active violations are listed.
    public var thingName: Swift.String?
    /// The verification state of the violation (detect alarm).
    public var verificationState: IoTClientTypes.VerificationState?

    public init(
        behaviorCriteriaType: IoTClientTypes.BehaviorCriteriaType? = nil,
        listSuppressedAlerts: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfileName: Swift.String? = nil,
        thingName: Swift.String? = nil,
        verificationState: IoTClientTypes.VerificationState? = nil
    )
    {
        self.behaviorCriteriaType = behaviorCriteriaType
        self.listSuppressedAlerts = listSuppressedAlerts
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileName = securityProfileName
        self.thingName = thingName
        self.verificationState = verificationState
    }
}

struct ListActiveViolationsInputBody: Swift.Equatable {
}

extension ListActiveViolationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListActiveViolationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListActiveViolationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.activeViolations = output.activeViolations
            self.nextToken = output.nextToken
        } else {
            self.activeViolations = nil
            self.nextToken = nil
        }
    }
}

public struct ListActiveViolationsOutput: Swift.Equatable {
    /// The list of active violations.
    public var activeViolations: [IoTClientTypes.ActiveViolation]?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        activeViolations: [IoTClientTypes.ActiveViolation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.activeViolations = activeViolations
        self.nextToken = nextToken
    }
}

struct ListActiveViolationsOutputBody: Swift.Equatable {
    let activeViolations: [IoTClientTypes.ActiveViolation]?
    let nextToken: Swift.String?
}

extension ListActiveViolationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeViolations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeViolationsContainer = try containerValues.decodeIfPresent([IoTClientTypes.ActiveViolation?].self, forKey: .activeViolations)
        var activeViolationsDecoded0:[IoTClientTypes.ActiveViolation]? = nil
        if let activeViolationsContainer = activeViolationsContainer {
            activeViolationsDecoded0 = [IoTClientTypes.ActiveViolation]()
            for structure0 in activeViolationsContainer {
                if let structure0 = structure0 {
                    activeViolationsDecoded0?.append(structure0)
                }
            }
        }
        activeViolations = activeViolationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListActiveViolationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAttachedPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            if let recursive = recursive {
                let recursiveQueryItem = ClientRuntime.URLQueryItem(name: "recursive".urlPercentEncoding(), value: Swift.String(recursive).urlPercentEncoding())
                items.append(recursiveQueryItem)
            }
            return items
        }
    }
}

extension ListAttachedPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let target = target else {
            return nil
        }
        return "/attached-policies/\(target.urlPercentEncoding())"
    }
}

public struct ListAttachedPoliciesInput: Swift.Equatable {
    /// The token to retrieve the next set of results.
    public var marker: Swift.String?
    /// The maximum number of results to be returned per request.
    public var pageSize: Swift.Int?
    /// When true, recursively list attached policies.
    public var recursive: Swift.Bool?
    /// The group or principal for which the policies will be listed. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    /// This member is required.
    public var target: Swift.String?

    public init(
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        recursive: Swift.Bool? = nil,
        target: Swift.String? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
        self.recursive = recursive
        self.target = target
    }
}

struct ListAttachedPoliciesInputBody: Swift.Equatable {
}

extension ListAttachedPoliciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAttachedPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAttachedPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.policies = output.policies
        } else {
            self.nextMarker = nil
            self.policies = nil
        }
    }
}

public struct ListAttachedPoliciesOutput: Swift.Equatable {
    /// The token to retrieve the next set of results, or ``null`` if there are no more results.
    public var nextMarker: Swift.String?
    /// The policies.
    public var policies: [IoTClientTypes.Policy]?

    public init(
        nextMarker: Swift.String? = nil,
        policies: [IoTClientTypes.Policy]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.policies = policies
    }
}

struct ListAttachedPoliciesOutputBody: Swift.Equatable {
    let policies: [IoTClientTypes.Policy]?
    let nextMarker: Swift.String?
}

extension ListAttachedPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker
        case policies
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([IoTClientTypes.Policy?].self, forKey: .policies)
        var policiesDecoded0:[IoTClientTypes.Policy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [IoTClientTypes.Policy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListAttachedPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAuditFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName
        case endTime
        case listSuppressedFindings
        case maxResults
        case nextToken
        case resourceIdentifier
        case startTime
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = self.checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let listSuppressedFindings = self.listSuppressedFindings {
            try encodeContainer.encode(listSuppressedFindings, forKey: .listSuppressedFindings)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }
}

extension ListAuditFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/findings"
    }
}

public struct ListAuditFindingsInput: Swift.Equatable {
    /// A filter to limit results to the findings for the specified audit check.
    public var checkName: Swift.String?
    /// A filter to limit results to those found before the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    public var endTime: ClientRuntime.Date?
    /// Boolean flag indicating whether only the suppressed findings or the unsuppressed findings should be listed. If this parameter isn't provided, the response will list both suppressed and unsuppressed findings.
    public var listSuppressedFindings: Swift.Bool?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Information identifying the noncompliant resource.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
    /// A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    public var startTime: ClientRuntime.Date?
    /// A filter to limit results to the audit with the specified ID. You must specify either the taskId or the startTime and endTime, but not both.
    public var taskId: Swift.String?

    public init(
        checkName: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        listSuppressedFindings: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
        startTime: ClientRuntime.Date? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.checkName = checkName
        self.endTime = endTime
        self.listSuppressedFindings = listSuppressedFindings
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
        self.startTime = startTime
        self.taskId = taskId
    }
}

struct ListAuditFindingsInputBody: Swift.Equatable {
    let taskId: Swift.String?
    let checkName: Swift.String?
    let resourceIdentifier: IoTClientTypes.ResourceIdentifier?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let listSuppressedFindings: Swift.Bool?
}

extension ListAuditFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName
        case endTime
        case listSuppressedFindings
        case maxResults
        case nextToken
        case resourceIdentifier
        case startTime
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let checkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let listSuppressedFindingsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .listSuppressedFindings)
        listSuppressedFindings = listSuppressedFindingsDecoded
    }
}

extension ListAuditFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAuditFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

public struct ListAuditFindingsOutput: Swift.Equatable {
    /// The findings (results) of the audit.
    public var findings: [IoTClientTypes.AuditFinding]?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        findings: [IoTClientTypes.AuditFinding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct ListAuditFindingsOutputBody: Swift.Equatable {
    let findings: [IoTClientTypes.AuditFinding]?
    let nextToken: Swift.String?
}

extension ListAuditFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([IoTClientTypes.AuditFinding?].self, forKey: .findings)
        var findingsDecoded0:[IoTClientTypes.AuditFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [IoTClientTypes.AuditFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAuditFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAuditMitigationActionsExecutionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let actionStatus = actionStatus {
                let actionStatusQueryItem = ClientRuntime.URLQueryItem(name: "actionStatus".urlPercentEncoding(), value: Swift.String(actionStatus.rawValue).urlPercentEncoding())
                items.append(actionStatusQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let findingId = findingId else {
                let message = "Creating a URL Query Item failed. findingId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let findingIdQueryItem = ClientRuntime.URLQueryItem(name: "findingId".urlPercentEncoding(), value: Swift.String(findingId).urlPercentEncoding())
            items.append(findingIdQueryItem)
            guard let taskId = taskId else {
                let message = "Creating a URL Query Item failed. taskId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let taskIdQueryItem = ClientRuntime.URLQueryItem(name: "taskId".urlPercentEncoding(), value: Swift.String(taskId).urlPercentEncoding())
            items.append(taskIdQueryItem)
            return items
        }
    }
}

extension ListAuditMitigationActionsExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/mitigationactions/executions"
    }
}

public struct ListAuditMitigationActionsExecutionsInput: Swift.Equatable {
    /// Specify this filter to limit results to those with a specific status.
    public var actionStatus: IoTClientTypes.AuditMitigationActionsExecutionStatus?
    /// Specify this filter to limit results to those that were applied to a specific audit finding.
    /// This member is required.
    public var findingId: Swift.String?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Specify this filter to limit results to actions for a specific audit mitigation actions task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        actionStatus: IoTClientTypes.AuditMitigationActionsExecutionStatus? = nil,
        findingId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.actionStatus = actionStatus
        self.findingId = findingId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskId = taskId
    }
}

struct ListAuditMitigationActionsExecutionsInputBody: Swift.Equatable {
}

extension ListAuditMitigationActionsExecutionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAuditMitigationActionsExecutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAuditMitigationActionsExecutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionsExecutions = output.actionsExecutions
            self.nextToken = output.nextToken
        } else {
            self.actionsExecutions = nil
            self.nextToken = nil
        }
    }
}

public struct ListAuditMitigationActionsExecutionsOutput: Swift.Equatable {
    /// A set of task execution results based on the input parameters. Details include the mitigation action applied, start time, and task status.
    public var actionsExecutions: [IoTClientTypes.AuditMitigationActionExecutionMetadata]?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        actionsExecutions: [IoTClientTypes.AuditMitigationActionExecutionMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionsExecutions = actionsExecutions
        self.nextToken = nextToken
    }
}

struct ListAuditMitigationActionsExecutionsOutputBody: Swift.Equatable {
    let actionsExecutions: [IoTClientTypes.AuditMitigationActionExecutionMetadata]?
    let nextToken: Swift.String?
}

extension ListAuditMitigationActionsExecutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionsExecutions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsExecutionsContainer = try containerValues.decodeIfPresent([IoTClientTypes.AuditMitigationActionExecutionMetadata?].self, forKey: .actionsExecutions)
        var actionsExecutionsDecoded0:[IoTClientTypes.AuditMitigationActionExecutionMetadata]? = nil
        if let actionsExecutionsContainer = actionsExecutionsContainer {
            actionsExecutionsDecoded0 = [IoTClientTypes.AuditMitigationActionExecutionMetadata]()
            for structure0 in actionsExecutionsContainer {
                if let structure0 = structure0 {
                    actionsExecutionsDecoded0?.append(structure0)
                }
            }
        }
        actionsExecutions = actionsExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAuditMitigationActionsExecutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAuditMitigationActionsTasksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let findingId = findingId {
                let findingIdQueryItem = ClientRuntime.URLQueryItem(name: "findingId".urlPercentEncoding(), value: Swift.String(findingId).urlPercentEncoding())
                items.append(findingIdQueryItem)
            }
            guard let startTime = startTime else {
                let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
            guard let endTime = endTime else {
                let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
            if let auditTaskId = auditTaskId {
                let auditTaskIdQueryItem = ClientRuntime.URLQueryItem(name: "auditTaskId".urlPercentEncoding(), value: Swift.String(auditTaskId).urlPercentEncoding())
                items.append(auditTaskIdQueryItem)
            }
            if let taskStatus = taskStatus {
                let taskStatusQueryItem = ClientRuntime.URLQueryItem(name: "taskStatus".urlPercentEncoding(), value: Swift.String(taskStatus.rawValue).urlPercentEncoding())
                items.append(taskStatusQueryItem)
            }
            return items
        }
    }
}

extension ListAuditMitigationActionsTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/mitigationactions/tasks"
    }
}

public struct ListAuditMitigationActionsTasksInput: Swift.Equatable {
    /// Specify this filter to limit results to tasks that were applied to results for a specific audit.
    public var auditTaskId: Swift.String?
    /// Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// Specify this filter to limit results to tasks that were applied to a specific audit finding.
    public var findingId: Swift.String?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Specify this filter to limit results to tasks that began on or after a specific date and time.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// Specify this filter to limit results to tasks that are in a specific state.
    public var taskStatus: IoTClientTypes.AuditMitigationActionsTaskStatus?

    public init(
        auditTaskId: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        findingId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        taskStatus: IoTClientTypes.AuditMitigationActionsTaskStatus? = nil
    )
    {
        self.auditTaskId = auditTaskId
        self.endTime = endTime
        self.findingId = findingId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.taskStatus = taskStatus
    }
}

struct ListAuditMitigationActionsTasksInputBody: Swift.Equatable {
}

extension ListAuditMitigationActionsTasksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAuditMitigationActionsTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAuditMitigationActionsTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct ListAuditMitigationActionsTasksOutput: Swift.Equatable {
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The collection of audit mitigation tasks that matched the filter criteria.
    public var tasks: [IoTClientTypes.AuditMitigationActionsTaskMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [IoTClientTypes.AuditMitigationActionsTaskMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct ListAuditMitigationActionsTasksOutputBody: Swift.Equatable {
    let tasks: [IoTClientTypes.AuditMitigationActionsTaskMetadata]?
    let nextToken: Swift.String?
}

extension ListAuditMitigationActionsTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tasks
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([IoTClientTypes.AuditMitigationActionsTaskMetadata?].self, forKey: .tasks)
        var tasksDecoded0:[IoTClientTypes.AuditMitigationActionsTaskMetadata]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [IoTClientTypes.AuditMitigationActionsTaskMetadata]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAuditMitigationActionsTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAuditSuppressionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ascendingOrder
        case checkName
        case maxResults
        case nextToken
        case resourceIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ascendingOrder = self.ascendingOrder {
            try encodeContainer.encode(ascendingOrder, forKey: .ascendingOrder)
        }
        if let checkName = self.checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }
}

extension ListAuditSuppressionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/suppressions/list"
    }
}

public struct ListAuditSuppressionsInput: Swift.Equatable {
    /// Determines whether suppressions are listed in ascending order by expiration date or not. If parameter isn't provided, ascendingOrder=true.
    public var ascendingOrder: Swift.Bool?
    /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    public var checkName: Swift.String?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Information that identifies the noncompliant resource.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?

    public init(
        ascendingOrder: Swift.Bool? = nil,
        checkName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.checkName = checkName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
    }
}

struct ListAuditSuppressionsInputBody: Swift.Equatable {
    let checkName: Swift.String?
    let resourceIdentifier: IoTClientTypes.ResourceIdentifier?
    let ascendingOrder: Swift.Bool?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAuditSuppressionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ascendingOrder
        case checkName
        case maxResults
        case nextToken
        case resourceIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let ascendingOrderDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ascendingOrder)
        ascendingOrder = ascendingOrderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAuditSuppressionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAuditSuppressionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.suppressions = output.suppressions
        } else {
            self.nextToken = nil
            self.suppressions = nil
        }
    }
}

public struct ListAuditSuppressionsOutput: Swift.Equatable {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// List of audit suppressions.
    public var suppressions: [IoTClientTypes.AuditSuppression]?

    public init(
        nextToken: Swift.String? = nil,
        suppressions: [IoTClientTypes.AuditSuppression]? = nil
    )
    {
        self.nextToken = nextToken
        self.suppressions = suppressions
    }
}

struct ListAuditSuppressionsOutputBody: Swift.Equatable {
    let suppressions: [IoTClientTypes.AuditSuppression]?
    let nextToken: Swift.String?
}

extension ListAuditSuppressionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case suppressions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suppressionsContainer = try containerValues.decodeIfPresent([IoTClientTypes.AuditSuppression?].self, forKey: .suppressions)
        var suppressionsDecoded0:[IoTClientTypes.AuditSuppression]? = nil
        if let suppressionsContainer = suppressionsContainer {
            suppressionsDecoded0 = [IoTClientTypes.AuditSuppression]()
            for structure0 in suppressionsContainer {
                if let structure0 = structure0 {
                    suppressionsDecoded0?.append(structure0)
                }
            }
        }
        suppressions = suppressionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAuditSuppressionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAuditTasksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let taskType = taskType {
                let taskTypeQueryItem = ClientRuntime.URLQueryItem(name: "taskType".urlPercentEncoding(), value: Swift.String(taskType.rawValue).urlPercentEncoding())
                items.append(taskTypeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let startTime = startTime else {
                let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
            guard let endTime = endTime else {
                let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
            if let taskStatus = taskStatus {
                let taskStatusQueryItem = ClientRuntime.URLQueryItem(name: "taskStatus".urlPercentEncoding(), value: Swift.String(taskStatus.rawValue).urlPercentEncoding())
                items.append(taskStatusQueryItem)
            }
            return items
        }
    }
}

extension ListAuditTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/tasks"
    }
}

public struct ListAuditTasksInput: Swift.Equatable {
    /// The end of the time period.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The beginning of the time period. Audit information is retained for a limited time (90 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".
    public var taskStatus: IoTClientTypes.AuditTaskStatus?
    /// A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".
    public var taskType: IoTClientTypes.AuditTaskType?

    public init(
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        taskStatus: IoTClientTypes.AuditTaskStatus? = nil,
        taskType: IoTClientTypes.AuditTaskType? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.taskStatus = taskStatus
        self.taskType = taskType
    }
}

struct ListAuditTasksInputBody: Swift.Equatable {
}

extension ListAuditTasksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAuditTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAuditTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct ListAuditTasksOutput: Swift.Equatable {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The audits that were performed during the specified time period.
    public var tasks: [IoTClientTypes.AuditTaskMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [IoTClientTypes.AuditTaskMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct ListAuditTasksOutputBody: Swift.Equatable {
    let tasks: [IoTClientTypes.AuditTaskMetadata]?
    let nextToken: Swift.String?
}

extension ListAuditTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tasks
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([IoTClientTypes.AuditTaskMetadata?].self, forKey: .tasks)
        var tasksDecoded0:[IoTClientTypes.AuditTaskMetadata]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [IoTClientTypes.AuditTaskMetadata]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAuditTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAuthorizersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ascendingOrder = ascendingOrder {
                let ascendingOrderQueryItem = ClientRuntime.URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
                items.append(ascendingOrderQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListAuthorizersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/authorizers"
    }
}

public struct ListAuthorizersInput: Swift.Equatable {
    /// Return the list of authorizers in ascending alphabetical order.
    public var ascendingOrder: Swift.Bool?
    /// A marker used to get the next set of results.
    public var marker: Swift.String?
    /// The maximum number of results to return at one time.
    public var pageSize: Swift.Int?
    /// The status of the list authorizers request.
    public var status: IoTClientTypes.AuthorizerStatus?

    public init(
        ascendingOrder: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        status: IoTClientTypes.AuthorizerStatus? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
        self.status = status
    }
}

struct ListAuthorizersInputBody: Swift.Equatable {
}

extension ListAuthorizersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAuthorizersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAuthorizersOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizers = output.authorizers
            self.nextMarker = output.nextMarker
        } else {
            self.authorizers = nil
            self.nextMarker = nil
        }
    }
}

public struct ListAuthorizersOutput: Swift.Equatable {
    /// The authorizers.
    public var authorizers: [IoTClientTypes.AuthorizerSummary]?
    /// A marker used to get the next set of results.
    public var nextMarker: Swift.String?

    public init(
        authorizers: [IoTClientTypes.AuthorizerSummary]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.authorizers = authorizers
        self.nextMarker = nextMarker
    }
}

struct ListAuthorizersOutputBody: Swift.Equatable {
    let authorizers: [IoTClientTypes.AuthorizerSummary]?
    let nextMarker: Swift.String?
}

extension ListAuthorizersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizers
        case nextMarker
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizersContainer = try containerValues.decodeIfPresent([IoTClientTypes.AuthorizerSummary?].self, forKey: .authorizers)
        var authorizersDecoded0:[IoTClientTypes.AuthorizerSummary]? = nil
        if let authorizersContainer = authorizersContainer {
            authorizersDecoded0 = [IoTClientTypes.AuthorizerSummary]()
            for structure0 in authorizersContainer {
                if let structure0 = structure0 {
                    authorizersDecoded0?.append(structure0)
                }
            }
        }
        authorizers = authorizersDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListAuthorizersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBillingGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let namePrefixFilter = namePrefixFilter {
                let namePrefixFilterQueryItem = ClientRuntime.URLQueryItem(name: "namePrefixFilter".urlPercentEncoding(), value: Swift.String(namePrefixFilter).urlPercentEncoding())
                items.append(namePrefixFilterQueryItem)
            }
            return items
        }
    }
}

extension ListBillingGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/billing-groups"
    }
}

public struct ListBillingGroupsInput: Swift.Equatable {
    /// The maximum number of results to return per request.
    public var maxResults: Swift.Int?
    /// Limit the results to billing groups whose names have the given prefix.
    public var namePrefixFilter: Swift.String?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        namePrefixFilter: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namePrefixFilter = namePrefixFilter
        self.nextToken = nextToken
    }
}

struct ListBillingGroupsInputBody: Swift.Equatable {
}

extension ListBillingGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBillingGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBillingGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.billingGroups = output.billingGroups
            self.nextToken = output.nextToken
        } else {
            self.billingGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListBillingGroupsOutput: Swift.Equatable {
    /// The list of billing groups.
    public var billingGroups: [IoTClientTypes.GroupNameAndArn]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        billingGroups: [IoTClientTypes.GroupNameAndArn]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingGroups = billingGroups
        self.nextToken = nextToken
    }
}

struct ListBillingGroupsOutputBody: Swift.Equatable {
    let billingGroups: [IoTClientTypes.GroupNameAndArn]?
    let nextToken: Swift.String?
}

extension ListBillingGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroups
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupsContainer = try containerValues.decodeIfPresent([IoTClientTypes.GroupNameAndArn?].self, forKey: .billingGroups)
        var billingGroupsDecoded0:[IoTClientTypes.GroupNameAndArn]? = nil
        if let billingGroupsContainer = billingGroupsContainer {
            billingGroupsDecoded0 = [IoTClientTypes.GroupNameAndArn]()
            for structure0 in billingGroupsContainer {
                if let structure0 = structure0 {
                    billingGroupsDecoded0?.append(structure0)
                }
            }
        }
        billingGroups = billingGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBillingGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCACertificatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ascendingOrder = ascendingOrder {
                let ascendingOrderQueryItem = ClientRuntime.URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
                items.append(ascendingOrderQueryItem)
            }
            if let templateName = templateName {
                let templateNameQueryItem = ClientRuntime.URLQueryItem(name: "templateName".urlPercentEncoding(), value: Swift.String(templateName).urlPercentEncoding())
                items.append(templateNameQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListCACertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cacertificates"
    }
}

/// Input for the ListCACertificates operation.
public struct ListCACertificatesInput: Swift.Equatable {
    /// Determines the order of the results.
    public var ascendingOrder: Swift.Bool?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?
    /// The name of the provisioning template.
    public var templateName: Swift.String?

    public init(
        ascendingOrder: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
        self.templateName = templateName
    }
}

struct ListCACertificatesInputBody: Swift.Equatable {
}

extension ListCACertificatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCACertificatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCACertificatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
            self.nextMarker = output.nextMarker
        } else {
            self.certificates = nil
            self.nextMarker = nil
        }
    }
}

/// The output from the ListCACertificates operation.
public struct ListCACertificatesOutput: Swift.Equatable {
    /// The CA certificates registered in your Amazon Web Services account.
    public var certificates: [IoTClientTypes.CACertificate]?
    /// The current position within the list of CA certificates.
    public var nextMarker: Swift.String?

    public init(
        certificates: [IoTClientTypes.CACertificate]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.nextMarker = nextMarker
    }
}

struct ListCACertificatesOutputBody: Swift.Equatable {
    let certificates: [IoTClientTypes.CACertificate]?
    let nextMarker: Swift.String?
}

extension ListCACertificatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates
        case nextMarker
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatesContainer = try containerValues.decodeIfPresent([IoTClientTypes.CACertificate?].self, forKey: .certificates)
        var certificatesDecoded0:[IoTClientTypes.CACertificate]? = nil
        if let certificatesContainer = certificatesContainer {
            certificatesDecoded0 = [IoTClientTypes.CACertificate]()
            for structure0 in certificatesContainer {
                if let structure0 = structure0 {
                    certificatesDecoded0?.append(structure0)
                }
            }
        }
        certificates = certificatesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListCACertificatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCertificatesByCAInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ascendingOrder = ascendingOrder {
                let ascendingOrderQueryItem = ClientRuntime.URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
                items.append(ascendingOrderQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListCertificatesByCAInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let caCertificateId = caCertificateId else {
            return nil
        }
        return "/certificates-by-ca/\(caCertificateId.urlPercentEncoding())"
    }
}

/// The input to the ListCertificatesByCA operation.
public struct ListCertificatesByCAInput: Swift.Equatable {
    /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
    public var ascendingOrder: Swift.Bool?
    /// The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
    /// This member is required.
    public var caCertificateId: Swift.String?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?

    public init(
        ascendingOrder: Swift.Bool? = nil,
        caCertificateId: Swift.String? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.caCertificateId = caCertificateId
        self.marker = marker
        self.pageSize = pageSize
    }
}

struct ListCertificatesByCAInputBody: Swift.Equatable {
}

extension ListCertificatesByCAInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCertificatesByCAOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCertificatesByCAOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
            self.nextMarker = output.nextMarker
        } else {
            self.certificates = nil
            self.nextMarker = nil
        }
    }
}

/// The output of the ListCertificatesByCA operation.
public struct ListCertificatesByCAOutput: Swift.Equatable {
    /// The device certificates signed by the specified CA certificate.
    public var certificates: [IoTClientTypes.Certificate]?
    /// The marker for the next set of results, or null if there are no additional results.
    public var nextMarker: Swift.String?

    public init(
        certificates: [IoTClientTypes.Certificate]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.nextMarker = nextMarker
    }
}

struct ListCertificatesByCAOutputBody: Swift.Equatable {
    let certificates: [IoTClientTypes.Certificate]?
    let nextMarker: Swift.String?
}

extension ListCertificatesByCAOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates
        case nextMarker
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatesContainer = try containerValues.decodeIfPresent([IoTClientTypes.Certificate?].self, forKey: .certificates)
        var certificatesDecoded0:[IoTClientTypes.Certificate]? = nil
        if let certificatesContainer = certificatesContainer {
            certificatesDecoded0 = [IoTClientTypes.Certificate]()
            for structure0 in certificatesContainer {
                if let structure0 = structure0 {
                    certificatesDecoded0?.append(structure0)
                }
            }
        }
        certificates = certificatesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListCertificatesByCAOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCertificatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ascendingOrder = ascendingOrder {
                let ascendingOrderQueryItem = ClientRuntime.URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
                items.append(ascendingOrderQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/certificates"
    }
}

/// The input for the ListCertificates operation.
public struct ListCertificatesInput: Swift.Equatable {
    /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
    public var ascendingOrder: Swift.Bool?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?

    public init(
        ascendingOrder: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
    }
}

struct ListCertificatesInputBody: Swift.Equatable {
}

extension ListCertificatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCertificatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCertificatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
            self.nextMarker = output.nextMarker
        } else {
            self.certificates = nil
            self.nextMarker = nil
        }
    }
}

/// The output of the ListCertificates operation.
public struct ListCertificatesOutput: Swift.Equatable {
    /// The descriptions of the certificates.
    public var certificates: [IoTClientTypes.Certificate]?
    /// The marker for the next set of results, or null if there are no additional results.
    public var nextMarker: Swift.String?

    public init(
        certificates: [IoTClientTypes.Certificate]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.nextMarker = nextMarker
    }
}

struct ListCertificatesOutputBody: Swift.Equatable {
    let certificates: [IoTClientTypes.Certificate]?
    let nextMarker: Swift.String?
}

extension ListCertificatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates
        case nextMarker
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatesContainer = try containerValues.decodeIfPresent([IoTClientTypes.Certificate?].self, forKey: .certificates)
        var certificatesDecoded0:[IoTClientTypes.Certificate]? = nil
        if let certificatesContainer = certificatesContainer {
            certificatesDecoded0 = [IoTClientTypes.Certificate]()
            for structure0 in certificatesContainer {
                if let structure0 = structure0 {
                    certificatesDecoded0?.append(structure0)
                }
            }
        }
        certificates = certificatesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListCertificatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCustomMetricsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCustomMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/custom-metrics"
    }
}

public struct ListCustomMetricsInput: Swift.Equatable {
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomMetricsInputBody: Swift.Equatable {
}

extension ListCustomMetricsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCustomMetricsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomMetricsOutputBody = try responseDecoder.decode(responseBody: data)
            self.metricNames = output.metricNames
            self.nextToken = output.nextToken
        } else {
            self.metricNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomMetricsOutput: Swift.Equatable {
    /// The name of the custom metric.
    public var metricNames: [Swift.String]?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        metricNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricNames = metricNames
        self.nextToken = nextToken
    }
}

struct ListCustomMetricsOutputBody: Swift.Equatable {
    let metricNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListCustomMetricsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricNames
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metricNames)
        var metricNamesDecoded0:[Swift.String]? = nil
        if let metricNamesContainer = metricNamesContainer {
            metricNamesDecoded0 = [Swift.String]()
            for string0 in metricNamesContainer {
                if let string0 = string0 {
                    metricNamesDecoded0?.append(string0)
                }
            }
        }
        metricNames = metricNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCustomMetricsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDetectMitigationActionsExecutionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let thingName = thingName {
                let thingNameQueryItem = ClientRuntime.URLQueryItem(name: "thingName".urlPercentEncoding(), value: Swift.String(thingName).urlPercentEncoding())
                items.append(thingNameQueryItem)
            }
            if let startTime = startTime {
                let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
                items.append(startTimeQueryItem)
            }
            if let endTime = endTime {
                let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
                items.append(endTimeQueryItem)
            }
            if let taskId = taskId {
                let taskIdQueryItem = ClientRuntime.URLQueryItem(name: "taskId".urlPercentEncoding(), value: Swift.String(taskId).urlPercentEncoding())
                items.append(taskIdQueryItem)
            }
            if let violationId = violationId {
                let violationIdQueryItem = ClientRuntime.URLQueryItem(name: "violationId".urlPercentEncoding(), value: Swift.String(violationId).urlPercentEncoding())
                items.append(violationIdQueryItem)
            }
            return items
        }
    }
}

extension ListDetectMitigationActionsExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/detect/mitigationactions/executions"
    }
}

public struct ListDetectMitigationActionsExecutionsInput: Swift.Equatable {
    /// The end of the time period for which ML Detect mitigation actions executions are returned.
    public var endTime: ClientRuntime.Date?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    public var startTime: ClientRuntime.Date?
    /// The unique identifier of the task.
    public var taskId: Swift.String?
    /// The name of the thing whose mitigation actions are listed.
    public var thingName: Swift.String?
    /// The unique identifier of the violation.
    public var violationId: Swift.String?

    public init(
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        taskId: Swift.String? = nil,
        thingName: Swift.String? = nil,
        violationId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.taskId = taskId
        self.thingName = thingName
        self.violationId = violationId
    }
}

struct ListDetectMitigationActionsExecutionsInputBody: Swift.Equatable {
}

extension ListDetectMitigationActionsExecutionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDetectMitigationActionsExecutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDetectMitigationActionsExecutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionsExecutions = output.actionsExecutions
            self.nextToken = output.nextToken
        } else {
            self.actionsExecutions = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectMitigationActionsExecutionsOutput: Swift.Equatable {
    /// List of actions executions.
    public var actionsExecutions: [IoTClientTypes.DetectMitigationActionExecution]?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        actionsExecutions: [IoTClientTypes.DetectMitigationActionExecution]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionsExecutions = actionsExecutions
        self.nextToken = nextToken
    }
}

struct ListDetectMitigationActionsExecutionsOutputBody: Swift.Equatable {
    let actionsExecutions: [IoTClientTypes.DetectMitigationActionExecution]?
    let nextToken: Swift.String?
}

extension ListDetectMitigationActionsExecutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionsExecutions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsExecutionsContainer = try containerValues.decodeIfPresent([IoTClientTypes.DetectMitigationActionExecution?].self, forKey: .actionsExecutions)
        var actionsExecutionsDecoded0:[IoTClientTypes.DetectMitigationActionExecution]? = nil
        if let actionsExecutionsContainer = actionsExecutionsContainer {
            actionsExecutionsDecoded0 = [IoTClientTypes.DetectMitigationActionExecution]()
            for structure0 in actionsExecutionsContainer {
                if let structure0 = structure0 {
                    actionsExecutionsDecoded0?.append(structure0)
                }
            }
        }
        actionsExecutions = actionsExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDetectMitigationActionsExecutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDetectMitigationActionsTasksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let startTime = startTime else {
                let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
            guard let endTime = endTime else {
                let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
            return items
        }
    }
}

extension ListDetectMitigationActionsTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/detect/mitigationactions/tasks"
    }
}

public struct ListDetectMitigationActionsTasksInput: Swift.Equatable {
    /// The end of the time period for which ML Detect mitigation actions tasks are returned.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct ListDetectMitigationActionsTasksInputBody: Swift.Equatable {
}

extension ListDetectMitigationActionsTasksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDetectMitigationActionsTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDetectMitigationActionsTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct ListDetectMitigationActionsTasksOutput: Swift.Equatable {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The collection of ML Detect mitigation tasks that matched the filter criteria.
    public var tasks: [IoTClientTypes.DetectMitigationActionsTaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [IoTClientTypes.DetectMitigationActionsTaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct ListDetectMitigationActionsTasksOutputBody: Swift.Equatable {
    let tasks: [IoTClientTypes.DetectMitigationActionsTaskSummary]?
    let nextToken: Swift.String?
}

extension ListDetectMitigationActionsTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tasks
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([IoTClientTypes.DetectMitigationActionsTaskSummary?].self, forKey: .tasks)
        var tasksDecoded0:[IoTClientTypes.DetectMitigationActionsTaskSummary]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [IoTClientTypes.DetectMitigationActionsTaskSummary]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDetectMitigationActionsTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDimensionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDimensionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dimensions"
    }
}

public struct ListDimensionsInput: Swift.Equatable {
    /// The maximum number of results to retrieve at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDimensionsInputBody: Swift.Equatable {
}

extension ListDimensionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDimensionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDimensionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dimensionNames = output.dimensionNames
            self.nextToken = output.nextToken
        } else {
            self.dimensionNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListDimensionsOutput: Swift.Equatable {
    /// A list of the names of the defined dimensions. Use DescribeDimension to get details for a dimension.
    public var dimensionNames: [Swift.String]?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        dimensionNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dimensionNames = dimensionNames
        self.nextToken = nextToken
    }
}

struct ListDimensionsOutputBody: Swift.Equatable {
    let dimensionNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListDimensionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionNames
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensionNames)
        var dimensionNamesDecoded0:[Swift.String]? = nil
        if let dimensionNamesContainer = dimensionNamesContainer {
            dimensionNamesDecoded0 = [Swift.String]()
            for string0 in dimensionNamesContainer {
                if let string0 = string0 {
                    dimensionNamesDecoded0?.append(string0)
                }
            }
        }
        dimensionNames = dimensionNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDimensionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDomainConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let serviceType = serviceType {
                let serviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "serviceType".urlPercentEncoding(), value: Swift.String(serviceType.rawValue).urlPercentEncoding())
                items.append(serviceTypeQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListDomainConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/domainConfigurations"
    }
}

public struct ListDomainConfigurationsInput: Swift.Equatable {
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?
    /// The type of service delivered by the endpoint.
    public var serviceType: IoTClientTypes.ServiceType?

    public init(
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        serviceType: IoTClientTypes.ServiceType? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
        self.serviceType = serviceType
    }
}

struct ListDomainConfigurationsInputBody: Swift.Equatable {
}

extension ListDomainConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDomainConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainConfigurations = output.domainConfigurations
            self.nextMarker = output.nextMarker
        } else {
            self.domainConfigurations = nil
            self.nextMarker = nil
        }
    }
}

public struct ListDomainConfigurationsOutput: Swift.Equatable {
    /// A list of objects that contain summary information about the user's domain configurations.
    public var domainConfigurations: [IoTClientTypes.DomainConfigurationSummary]?
    /// The marker for the next set of results.
    public var nextMarker: Swift.String?

    public init(
        domainConfigurations: [IoTClientTypes.DomainConfigurationSummary]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.domainConfigurations = domainConfigurations
        self.nextMarker = nextMarker
    }
}

struct ListDomainConfigurationsOutputBody: Swift.Equatable {
    let domainConfigurations: [IoTClientTypes.DomainConfigurationSummary]?
    let nextMarker: Swift.String?
}

extension ListDomainConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainConfigurations
        case nextMarker
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainConfigurationsContainer = try containerValues.decodeIfPresent([IoTClientTypes.DomainConfigurationSummary?].self, forKey: .domainConfigurations)
        var domainConfigurationsDecoded0:[IoTClientTypes.DomainConfigurationSummary]? = nil
        if let domainConfigurationsContainer = domainConfigurationsContainer {
            domainConfigurationsDecoded0 = [IoTClientTypes.DomainConfigurationSummary]()
            for structure0 in domainConfigurationsContainer {
                if let structure0 = structure0 {
                    domainConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainConfigurations = domainConfigurationsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListDomainConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFleetMetricsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFleetMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/fleet-metrics"
    }
}

public struct ListFleetMetricsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFleetMetricsInputBody: Swift.Equatable {
}

extension ListFleetMetricsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFleetMetricsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFleetMetricsOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleetMetrics = output.fleetMetrics
            self.nextToken = output.nextToken
        } else {
            self.fleetMetrics = nil
            self.nextToken = nil
        }
    }
}

public struct ListFleetMetricsOutput: Swift.Equatable {
    /// The list of fleet metrics objects.
    public var fleetMetrics: [IoTClientTypes.FleetMetricNameAndArn]?
    /// The token for the next set of results. Will not be returned if the operation has returned all results.
    public var nextToken: Swift.String?

    public init(
        fleetMetrics: [IoTClientTypes.FleetMetricNameAndArn]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetMetrics = fleetMetrics
        self.nextToken = nextToken
    }
}

struct ListFleetMetricsOutputBody: Swift.Equatable {
    let fleetMetrics: [IoTClientTypes.FleetMetricNameAndArn]?
    let nextToken: Swift.String?
}

extension ListFleetMetricsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetMetrics
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetMetricsContainer = try containerValues.decodeIfPresent([IoTClientTypes.FleetMetricNameAndArn?].self, forKey: .fleetMetrics)
        var fleetMetricsDecoded0:[IoTClientTypes.FleetMetricNameAndArn]? = nil
        if let fleetMetricsContainer = fleetMetricsContainer {
            fleetMetricsDecoded0 = [IoTClientTypes.FleetMetricNameAndArn]()
            for structure0 in fleetMetricsContainer {
                if let structure0 = structure0 {
                    fleetMetricsDecoded0?.append(structure0)
                }
            }
        }
        fleetMetrics = fleetMetricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFleetMetricsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIndicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIndicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/indices"
    }
}

public struct ListIndicesInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The token used to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIndicesInputBody: Swift.Equatable {
}

extension ListIndicesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIndicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIndicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.indexNames = output.indexNames
            self.nextToken = output.nextToken
        } else {
            self.indexNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListIndicesOutput: Swift.Equatable {
    /// The index names.
    public var indexNames: [Swift.String]?
    /// The token used to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        indexNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexNames = indexNames
        self.nextToken = nextToken
    }
}

struct ListIndicesOutputBody: Swift.Equatable {
    let indexNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListIndicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexNames
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .indexNames)
        var indexNamesDecoded0:[Swift.String]? = nil
        if let indexNamesContainer = indexNamesContainer {
            indexNamesDecoded0 = [Swift.String]()
            for string0 in indexNamesContainer {
                if let string0 = string0 {
                    indexNamesDecoded0?.append(string0)
                }
            }
        }
        indexNames = indexNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIndicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJobExecutionsForJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListJobExecutionsForJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())/things"
    }
}

public struct ListJobExecutionsForJobInput: Swift.Equatable {
    /// The unique identifier you assigned to this job when it was created.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The status of the job.
    public var status: IoTClientTypes.JobExecutionStatus?

    public init(
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: IoTClientTypes.JobExecutionStatus? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListJobExecutionsForJobInputBody: Swift.Equatable {
}

extension ListJobExecutionsForJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobExecutionsForJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobExecutionsForJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.executionSummaries = output.executionSummaries
            self.nextToken = output.nextToken
        } else {
            self.executionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobExecutionsForJobOutput: Swift.Equatable {
    /// A list of job execution summaries.
    public var executionSummaries: [IoTClientTypes.JobExecutionSummaryForJob]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        executionSummaries: [IoTClientTypes.JobExecutionSummaryForJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.executionSummaries = executionSummaries
        self.nextToken = nextToken
    }
}

struct ListJobExecutionsForJobOutputBody: Swift.Equatable {
    let executionSummaries: [IoTClientTypes.JobExecutionSummaryForJob]?
    let nextToken: Swift.String?
}

extension ListJobExecutionsForJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionSummariesContainer = try containerValues.decodeIfPresent([IoTClientTypes.JobExecutionSummaryForJob?].self, forKey: .executionSummaries)
        var executionSummariesDecoded0:[IoTClientTypes.JobExecutionSummaryForJob]? = nil
        if let executionSummariesContainer = executionSummariesContainer {
            executionSummariesDecoded0 = [IoTClientTypes.JobExecutionSummaryForJob]()
            for structure0 in executionSummariesContainer {
                if let structure0 = structure0 {
                    executionSummariesDecoded0?.append(structure0)
                }
            }
        }
        executionSummaries = executionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobExecutionsForJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJobExecutionsForThingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let jobId = jobId {
                let jobIdQueryItem = ClientRuntime.URLQueryItem(name: "jobId".urlPercentEncoding(), value: Swift.String(jobId).urlPercentEncoding())
                items.append(jobIdQueryItem)
            }
            if let namespaceId = namespaceId {
                let namespaceIdQueryItem = ClientRuntime.URLQueryItem(name: "namespaceId".urlPercentEncoding(), value: Swift.String(namespaceId).urlPercentEncoding())
                items.append(namespaceIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListJobExecutionsForThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/jobs"
    }
}

public struct ListJobExecutionsForThingInput: Swift.Equatable {
    /// The unique identifier you assigned to this job when it was created.
    public var jobId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is in public preview.
    public var namespaceId: Swift.String?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional filter that lets you search for jobs that have the specified status.
    public var status: IoTClientTypes.JobExecutionStatus?
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespaceId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        status: IoTClientTypes.JobExecutionStatus? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.namespaceId = namespaceId
        self.nextToken = nextToken
        self.status = status
        self.thingName = thingName
    }
}

struct ListJobExecutionsForThingInputBody: Swift.Equatable {
}

extension ListJobExecutionsForThingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobExecutionsForThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobExecutionsForThingOutputBody = try responseDecoder.decode(responseBody: data)
            self.executionSummaries = output.executionSummaries
            self.nextToken = output.nextToken
        } else {
            self.executionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobExecutionsForThingOutput: Swift.Equatable {
    /// A list of job execution summaries.
    public var executionSummaries: [IoTClientTypes.JobExecutionSummaryForThing]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        executionSummaries: [IoTClientTypes.JobExecutionSummaryForThing]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.executionSummaries = executionSummaries
        self.nextToken = nextToken
    }
}

struct ListJobExecutionsForThingOutputBody: Swift.Equatable {
    let executionSummaries: [IoTClientTypes.JobExecutionSummaryForThing]?
    let nextToken: Swift.String?
}

extension ListJobExecutionsForThingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionSummariesContainer = try containerValues.decodeIfPresent([IoTClientTypes.JobExecutionSummaryForThing?].self, forKey: .executionSummaries)
        var executionSummariesDecoded0:[IoTClientTypes.JobExecutionSummaryForThing]? = nil
        if let executionSummariesContainer = executionSummariesContainer {
            executionSummariesDecoded0 = [IoTClientTypes.JobExecutionSummaryForThing]()
            for structure0 in executionSummariesContainer {
                if let structure0 = structure0 {
                    executionSummariesDecoded0?.append(structure0)
                }
            }
        }
        executionSummaries = executionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobExecutionsForThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJobTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListJobTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/job-templates"
    }
}

public struct ListJobTemplatesInput: Swift.Equatable {
    /// The maximum number of results to return in the list.
    public var maxResults: Swift.Int?
    /// The token to use to return the next set of results in the list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJobTemplatesInputBody: Swift.Equatable {
}

extension ListJobTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobTemplates = output.jobTemplates
            self.nextToken = output.nextToken
        } else {
            self.jobTemplates = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobTemplatesOutput: Swift.Equatable {
    /// A list of objects that contain information about the job templates.
    public var jobTemplates: [IoTClientTypes.JobTemplateSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        jobTemplates: [IoTClientTypes.JobTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobTemplates = jobTemplates
        self.nextToken = nextToken
    }
}

struct ListJobTemplatesOutputBody: Swift.Equatable {
    let jobTemplates: [IoTClientTypes.JobTemplateSummary]?
    let nextToken: Swift.String?
}

extension ListJobTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobTemplates
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTemplatesContainer = try containerValues.decodeIfPresent([IoTClientTypes.JobTemplateSummary?].self, forKey: .jobTemplates)
        var jobTemplatesDecoded0:[IoTClientTypes.JobTemplateSummary]? = nil
        if let jobTemplatesContainer = jobTemplatesContainer {
            jobTemplatesDecoded0 = [IoTClientTypes.JobTemplateSummary]()
            for structure0 in jobTemplatesContainer {
                if let structure0 = structure0 {
                    jobTemplatesDecoded0?.append(structure0)
                }
            }
        }
        jobTemplates = jobTemplatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let thingGroupId = thingGroupId {
                let thingGroupIdQueryItem = ClientRuntime.URLQueryItem(name: "thingGroupId".urlPercentEncoding(), value: Swift.String(thingGroupId).urlPercentEncoding())
                items.append(thingGroupIdQueryItem)
            }
            if let namespaceId = namespaceId {
                let namespaceIdQueryItem = ClientRuntime.URLQueryItem(name: "namespaceId".urlPercentEncoding(), value: Swift.String(namespaceId).urlPercentEncoding())
                items.append(namespaceIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let thingGroupName = thingGroupName {
                let thingGroupNameQueryItem = ClientRuntime.URLQueryItem(name: "thingGroupName".urlPercentEncoding(), value: Swift.String(thingGroupName).urlPercentEncoding())
                items.append(thingGroupNameQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            if let targetSelection = targetSelection {
                let targetSelectionQueryItem = ClientRuntime.URLQueryItem(name: "targetSelection".urlPercentEncoding(), value: Swift.String(targetSelection.rawValue).urlPercentEncoding())
                items.append(targetSelectionQueryItem)
            }
            return items
        }
    }
}

extension ListJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs"
    }
}

public struct ListJobsInput: Swift.Equatable {
    /// The maximum number of results to return per request.
    public var maxResults: Swift.Int?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is in public preview.
    public var namespaceId: Swift.String?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional filter that lets you search for jobs that have the specified status.
    public var status: IoTClientTypes.JobStatus?
    /// Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. We recommend that you use continuous jobs instead of snapshot jobs for dynamic thing group targets. By using continuous jobs, devices that join the group receive the job execution even after the job has been created.
    public var targetSelection: IoTClientTypes.TargetSelection?
    /// A filter that limits the returned jobs to those for the specified group.
    public var thingGroupId: Swift.String?
    /// A filter that limits the returned jobs to those for the specified group.
    public var thingGroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        namespaceId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        status: IoTClientTypes.JobStatus? = nil,
        targetSelection: IoTClientTypes.TargetSelection? = nil,
        thingGroupId: Swift.String? = nil,
        thingGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namespaceId = namespaceId
        self.nextToken = nextToken
        self.status = status
        self.targetSelection = targetSelection
        self.thingGroupId = thingGroupId
        self.thingGroupName = thingGroupName
    }
}

struct ListJobsInputBody: Swift.Equatable {
}

extension ListJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutput: Swift.Equatable {
    /// A list of jobs.
    public var jobs: [IoTClientTypes.JobSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        jobs: [IoTClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputBody: Swift.Equatable {
    let jobs: [IoTClientTypes.JobSummary]?
    let nextToken: Swift.String?
}

extension ListJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([IoTClientTypes.JobSummary?].self, forKey: .jobs)
        var jobsDecoded0:[IoTClientTypes.JobSummary]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [IoTClientTypes.JobSummary]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListManagedJobTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let templateName = templateName {
                let templateNameQueryItem = ClientRuntime.URLQueryItem(name: "templateName".urlPercentEncoding(), value: Swift.String(templateName).urlPercentEncoding())
                items.append(templateNameQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListManagedJobTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/managed-job-templates"
    }
}

public struct ListManagedJobTemplatesInput: Swift.Equatable {
    /// Maximum number of entries that can be returned.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional parameter for template name. If specified, only the versions of the managed job templates that have the specified template name will be returned.
    public var templateName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateName = templateName
    }
}

struct ListManagedJobTemplatesInputBody: Swift.Equatable {
}

extension ListManagedJobTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListManagedJobTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListManagedJobTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.managedJobTemplates = output.managedJobTemplates
            self.nextToken = output.nextToken
        } else {
            self.managedJobTemplates = nil
            self.nextToken = nil
        }
    }
}

public struct ListManagedJobTemplatesOutput: Swift.Equatable {
    /// A list of managed job templates that are returned.
    public var managedJobTemplates: [IoTClientTypes.ManagedJobTemplateSummary]?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        managedJobTemplates: [IoTClientTypes.ManagedJobTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.managedJobTemplates = managedJobTemplates
        self.nextToken = nextToken
    }
}

struct ListManagedJobTemplatesOutputBody: Swift.Equatable {
    let managedJobTemplates: [IoTClientTypes.ManagedJobTemplateSummary]?
    let nextToken: Swift.String?
}

extension ListManagedJobTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managedJobTemplates
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managedJobTemplatesContainer = try containerValues.decodeIfPresent([IoTClientTypes.ManagedJobTemplateSummary?].self, forKey: .managedJobTemplates)
        var managedJobTemplatesDecoded0:[IoTClientTypes.ManagedJobTemplateSummary]? = nil
        if let managedJobTemplatesContainer = managedJobTemplatesContainer {
            managedJobTemplatesDecoded0 = [IoTClientTypes.ManagedJobTemplateSummary]()
            for structure0 in managedJobTemplatesContainer {
                if let structure0 = structure0 {
                    managedJobTemplatesDecoded0?.append(structure0)
                }
            }
        }
        managedJobTemplates = managedJobTemplatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListManagedJobTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMetricValuesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let metricName = metricName else {
                let message = "Creating a URL Query Item failed. metricName is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let metricNameQueryItem = ClientRuntime.URLQueryItem(name: "metricName".urlPercentEncoding(), value: Swift.String(metricName).urlPercentEncoding())
            items.append(metricNameQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let thingName = thingName else {
                let message = "Creating a URL Query Item failed. thingName is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let thingNameQueryItem = ClientRuntime.URLQueryItem(name: "thingName".urlPercentEncoding(), value: Swift.String(thingName).urlPercentEncoding())
            items.append(thingNameQueryItem)
            guard let startTime = startTime else {
                let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
            guard let endTime = endTime else {
                let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
            if let dimensionName = dimensionName {
                let dimensionNameQueryItem = ClientRuntime.URLQueryItem(name: "dimensionName".urlPercentEncoding(), value: Swift.String(dimensionName).urlPercentEncoding())
                items.append(dimensionNameQueryItem)
            }
            if let dimensionValueOperator = dimensionValueOperator {
                let dimensionValueOperatorQueryItem = ClientRuntime.URLQueryItem(name: "dimensionValueOperator".urlPercentEncoding(), value: Swift.String(dimensionValueOperator.rawValue).urlPercentEncoding())
                items.append(dimensionValueOperatorQueryItem)
            }
            return items
        }
    }
}

extension ListMetricValuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/metric-values"
    }
}

public struct ListMetricValuesInput: Swift.Equatable {
    /// The dimension name.
    public var dimensionName: Swift.String?
    /// The dimension value operator.
    public var dimensionValueOperator: IoTClientTypes.DimensionValueOperator?
    /// The end of the time period for which metric values are returned.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The name of the security profile metric for which values are returned.
    /// This member is required.
    public var metricName: Swift.String?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The start of the time period for which metric values are returned.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// The name of the thing for which security profile metric values are returned.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        dimensionName: Swift.String? = nil,
        dimensionValueOperator: IoTClientTypes.DimensionValueOperator? = nil,
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        metricName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.dimensionName = dimensionName
        self.dimensionValueOperator = dimensionValueOperator
        self.endTime = endTime
        self.maxResults = maxResults
        self.metricName = metricName
        self.nextToken = nextToken
        self.startTime = startTime
        self.thingName = thingName
    }
}

struct ListMetricValuesInputBody: Swift.Equatable {
}

extension ListMetricValuesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMetricValuesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMetricValuesOutputBody = try responseDecoder.decode(responseBody: data)
            self.metricDatumList = output.metricDatumList
            self.nextToken = output.nextToken
        } else {
            self.metricDatumList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMetricValuesOutput: Swift.Equatable {
    /// The data the thing reports for the metric during the specified time period.
    public var metricDatumList: [IoTClientTypes.MetricDatum]?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        metricDatumList: [IoTClientTypes.MetricDatum]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricDatumList = metricDatumList
        self.nextToken = nextToken
    }
}

struct ListMetricValuesOutputBody: Swift.Equatable {
    let metricDatumList: [IoTClientTypes.MetricDatum]?
    let nextToken: Swift.String?
}

extension ListMetricValuesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDatumList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDatumListContainer = try containerValues.decodeIfPresent([IoTClientTypes.MetricDatum?].self, forKey: .metricDatumList)
        var metricDatumListDecoded0:[IoTClientTypes.MetricDatum]? = nil
        if let metricDatumListContainer = metricDatumListContainer {
            metricDatumListDecoded0 = [IoTClientTypes.MetricDatum]()
            for structure0 in metricDatumListContainer {
                if let structure0 = structure0 {
                    metricDatumListDecoded0?.append(structure0)
                }
            }
        }
        metricDatumList = metricDatumListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMetricValuesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMitigationActionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let actionType = actionType {
                let actionTypeQueryItem = ClientRuntime.URLQueryItem(name: "actionType".urlPercentEncoding(), value: Swift.String(actionType.rawValue).urlPercentEncoding())
                items.append(actionTypeQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListMitigationActionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/mitigationactions/actions"
    }
}

public struct ListMitigationActionsInput: Swift.Equatable {
    /// Specify a value to limit the result to mitigation actions with a specific action type.
    public var actionType: IoTClientTypes.MitigationActionType?
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        actionType: IoTClientTypes.MitigationActionType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionType = actionType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMitigationActionsInputBody: Swift.Equatable {
}

extension ListMitigationActionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMitigationActionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMitigationActionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionIdentifiers = output.actionIdentifiers
            self.nextToken = output.nextToken
        } else {
            self.actionIdentifiers = nil
            self.nextToken = nil
        }
    }
}

public struct ListMitigationActionsOutput: Swift.Equatable {
    /// A set of actions that matched the specified filter criteria.
    public var actionIdentifiers: [IoTClientTypes.MitigationActionIdentifier]?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        actionIdentifiers: [IoTClientTypes.MitigationActionIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionIdentifiers = actionIdentifiers
        self.nextToken = nextToken
    }
}

struct ListMitigationActionsOutputBody: Swift.Equatable {
    let actionIdentifiers: [IoTClientTypes.MitigationActionIdentifier]?
    let nextToken: Swift.String?
}

extension ListMitigationActionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionIdentifiers
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdentifiersContainer = try containerValues.decodeIfPresent([IoTClientTypes.MitigationActionIdentifier?].self, forKey: .actionIdentifiers)
        var actionIdentifiersDecoded0:[IoTClientTypes.MitigationActionIdentifier]? = nil
        if let actionIdentifiersContainer = actionIdentifiersContainer {
            actionIdentifiersDecoded0 = [IoTClientTypes.MitigationActionIdentifier]()
            for structure0 in actionIdentifiersContainer {
                if let structure0 = structure0 {
                    actionIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        actionIdentifiers = actionIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMitigationActionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOTAUpdatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let otaUpdateStatus = otaUpdateStatus {
                let otaUpdateStatusQueryItem = ClientRuntime.URLQueryItem(name: "otaUpdateStatus".urlPercentEncoding(), value: Swift.String(otaUpdateStatus.rawValue).urlPercentEncoding())
                items.append(otaUpdateStatusQueryItem)
            }
            return items
        }
    }
}

extension ListOTAUpdatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/otaUpdates"
    }
}

public struct ListOTAUpdatesInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token used to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The OTA update job status.
    public var otaUpdateStatus: IoTClientTypes.OTAUpdateStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        otaUpdateStatus: IoTClientTypes.OTAUpdateStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.otaUpdateStatus = otaUpdateStatus
    }
}

struct ListOTAUpdatesInputBody: Swift.Equatable {
}

extension ListOTAUpdatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOTAUpdatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOTAUpdatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.otaUpdates = output.otaUpdates
        } else {
            self.nextToken = nil
            self.otaUpdates = nil
        }
    }
}

public struct ListOTAUpdatesOutput: Swift.Equatable {
    /// A token to use to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of OTA update jobs.
    public var otaUpdates: [IoTClientTypes.OTAUpdateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        otaUpdates: [IoTClientTypes.OTAUpdateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.otaUpdates = otaUpdates
    }
}

struct ListOTAUpdatesOutputBody: Swift.Equatable {
    let otaUpdates: [IoTClientTypes.OTAUpdateSummary]?
    let nextToken: Swift.String?
}

extension ListOTAUpdatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case otaUpdates
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otaUpdatesContainer = try containerValues.decodeIfPresent([IoTClientTypes.OTAUpdateSummary?].self, forKey: .otaUpdates)
        var otaUpdatesDecoded0:[IoTClientTypes.OTAUpdateSummary]? = nil
        if let otaUpdatesContainer = otaUpdatesContainer {
            otaUpdatesDecoded0 = [IoTClientTypes.OTAUpdateSummary]()
            for structure0 in otaUpdatesContainer {
                if let structure0 = structure0 {
                    otaUpdatesDecoded0?.append(structure0)
                }
            }
        }
        otaUpdates = otaUpdatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListOTAUpdatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOutgoingCertificatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ascendingOrder = ascendingOrder {
                let ascendingOrderQueryItem = ClientRuntime.URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
                items.append(ascendingOrderQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListOutgoingCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/certificates-out-going"
    }
}

/// The input to the ListOutgoingCertificates operation.
public struct ListOutgoingCertificatesInput: Swift.Equatable {
    /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
    public var ascendingOrder: Swift.Bool?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?

    public init(
        ascendingOrder: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
    }
}

struct ListOutgoingCertificatesInputBody: Swift.Equatable {
}

extension ListOutgoingCertificatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOutgoingCertificatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOutgoingCertificatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.outgoingCertificates = output.outgoingCertificates
        } else {
            self.nextMarker = nil
            self.outgoingCertificates = nil
        }
    }
}

/// The output from the ListOutgoingCertificates operation.
public struct ListOutgoingCertificatesOutput: Swift.Equatable {
    /// The marker for the next set of results.
    public var nextMarker: Swift.String?
    /// The certificates that are being transferred but not yet accepted.
    public var outgoingCertificates: [IoTClientTypes.OutgoingCertificate]?

    public init(
        nextMarker: Swift.String? = nil,
        outgoingCertificates: [IoTClientTypes.OutgoingCertificate]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.outgoingCertificates = outgoingCertificates
    }
}

struct ListOutgoingCertificatesOutputBody: Swift.Equatable {
    let outgoingCertificates: [IoTClientTypes.OutgoingCertificate]?
    let nextMarker: Swift.String?
}

extension ListOutgoingCertificatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker
        case outgoingCertificates
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outgoingCertificatesContainer = try containerValues.decodeIfPresent([IoTClientTypes.OutgoingCertificate?].self, forKey: .outgoingCertificates)
        var outgoingCertificatesDecoded0:[IoTClientTypes.OutgoingCertificate]? = nil
        if let outgoingCertificatesContainer = outgoingCertificatesContainer {
            outgoingCertificatesDecoded0 = [IoTClientTypes.OutgoingCertificate]()
            for structure0 in outgoingCertificatesContainer {
                if let structure0 = structure0 {
                    outgoingCertificatesDecoded0?.append(structure0)
                }
            }
        }
        outgoingCertificates = outgoingCertificatesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListOutgoingCertificatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPackageVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListPackageVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageName = packageName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())/versions"
    }
}

public struct ListPackageVersionsInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The name of the target software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The status of the package version. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle).
    public var status: IoTClientTypes.PackageVersionStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        packageName: Swift.String? = nil,
        status: IoTClientTypes.PackageVersionStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.packageName = packageName
        self.status = status
    }
}

struct ListPackageVersionsInputBody: Swift.Equatable {
}

extension ListPackageVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPackageVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPackageVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packageVersionSummaries = output.packageVersionSummaries
        } else {
            self.nextToken = nil
            self.packageVersionSummaries = nil
        }
    }
}

public struct ListPackageVersionsOutput: Swift.Equatable {
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Lists the package versions associated to the package.
    public var packageVersionSummaries: [IoTClientTypes.PackageVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        packageVersionSummaries: [IoTClientTypes.PackageVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageVersionSummaries = packageVersionSummaries
    }
}

struct ListPackageVersionsOutputBody: Swift.Equatable {
    let packageVersionSummaries: [IoTClientTypes.PackageVersionSummary]?
    let nextToken: Swift.String?
}

extension ListPackageVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case packageVersionSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionSummariesContainer = try containerValues.decodeIfPresent([IoTClientTypes.PackageVersionSummary?].self, forKey: .packageVersionSummaries)
        var packageVersionSummariesDecoded0:[IoTClientTypes.PackageVersionSummary]? = nil
        if let packageVersionSummariesContainer = packageVersionSummariesContainer {
            packageVersionSummariesDecoded0 = [IoTClientTypes.PackageVersionSummary]()
            for structure0 in packageVersionSummariesContainer {
                if let structure0 = structure0 {
                    packageVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        packageVersionSummaries = packageVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPackageVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPackagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListPackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packages"
    }
}

public struct ListPackagesInput: Swift.Equatable {
    /// The maximum number of results returned at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPackagesInputBody: Swift.Equatable {
}

extension ListPackagesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPackagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPackagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packageSummaries = output.packageSummaries
        } else {
            self.nextToken = nil
            self.packageSummaries = nil
        }
    }
}

public struct ListPackagesOutput: Swift.Equatable {
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The software package summary.
    public var packageSummaries: [IoTClientTypes.PackageSummary]?

    public init(
        nextToken: Swift.String? = nil,
        packageSummaries: [IoTClientTypes.PackageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageSummaries = packageSummaries
    }
}

struct ListPackagesOutputBody: Swift.Equatable {
    let packageSummaries: [IoTClientTypes.PackageSummary]?
    let nextToken: Swift.String?
}

extension ListPackagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case packageSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageSummariesContainer = try containerValues.decodeIfPresent([IoTClientTypes.PackageSummary?].self, forKey: .packageSummaries)
        var packageSummariesDecoded0:[IoTClientTypes.PackageSummary]? = nil
        if let packageSummariesContainer = packageSummariesContainer {
            packageSummariesDecoded0 = [IoTClientTypes.PackageSummary]()
            for structure0 in packageSummariesContainer {
                if let structure0 = structure0 {
                    packageSummariesDecoded0?.append(structure0)
                }
            }
        }
        packageSummaries = packageSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPackagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ascendingOrder = ascendingOrder {
                let ascendingOrderQueryItem = ClientRuntime.URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
                items.append(ascendingOrderQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/policies"
    }
}

/// The input for the ListPolicies operation.
public struct ListPoliciesInput: Swift.Equatable {
    /// Specifies the order for results. If true, the results are returned in ascending creation order.
    public var ascendingOrder: Swift.Bool?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?

    public init(
        ascendingOrder: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
    }
}

struct ListPoliciesInputBody: Swift.Equatable {
}

extension ListPoliciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.policies = output.policies
        } else {
            self.nextMarker = nil
            self.policies = nil
        }
    }
}

/// The output from the ListPolicies operation.
public struct ListPoliciesOutput: Swift.Equatable {
    /// The marker for the next set of results, or null if there are no additional results.
    public var nextMarker: Swift.String?
    /// The descriptions of the policies.
    public var policies: [IoTClientTypes.Policy]?

    public init(
        nextMarker: Swift.String? = nil,
        policies: [IoTClientTypes.Policy]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.policies = policies
    }
}

struct ListPoliciesOutputBody: Swift.Equatable {
    let policies: [IoTClientTypes.Policy]?
    let nextMarker: Swift.String?
}

extension ListPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker
        case policies
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([IoTClientTypes.Policy?].self, forKey: .policies)
        var policiesDecoded0:[IoTClientTypes.Policy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [IoTClientTypes.Policy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPolicyPrincipalsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let policyName = policyName {
            items.add(Header(name: "x-amzn-iot-policy", value: Swift.String(policyName)))
        }
        return items
    }
}

extension ListPolicyPrincipalsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ascendingOrder = ascendingOrder {
                let ascendingOrderQueryItem = ClientRuntime.URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
                items.append(ascendingOrderQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListPolicyPrincipalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/policy-principals"
    }
}

/// The input for the ListPolicyPrincipals operation.
public struct ListPolicyPrincipalsInput: Swift.Equatable {
    /// Specifies the order for results. If true, the results are returned in ascending creation order.
    public var ascendingOrder: Swift.Bool?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        ascendingOrder: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
        self.policyName = policyName
    }
}

struct ListPolicyPrincipalsInputBody: Swift.Equatable {
}

extension ListPolicyPrincipalsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPolicyPrincipalsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPolicyPrincipalsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.principals = output.principals
        } else {
            self.nextMarker = nil
            self.principals = nil
        }
    }
}

/// The output from the ListPolicyPrincipals operation.
public struct ListPolicyPrincipalsOutput: Swift.Equatable {
    /// The marker for the next set of results, or null if there are no additional results.
    public var nextMarker: Swift.String?
    /// The descriptions of the principals.
    public var principals: [Swift.String]?

    public init(
        nextMarker: Swift.String? = nil,
        principals: [Swift.String]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.principals = principals
    }
}

struct ListPolicyPrincipalsOutputBody: Swift.Equatable {
    let principals: [Swift.String]?
    let nextMarker: Swift.String?
}

extension ListPolicyPrincipalsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker
        case principals
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListPolicyPrincipalsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPolicyVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let policyName = policyName else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())/version"
    }
}

/// The input for the ListPolicyVersions operation.
public struct ListPolicyVersionsInput: Swift.Equatable {
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        policyName: Swift.String? = nil
    )
    {
        self.policyName = policyName
    }
}

struct ListPolicyVersionsInputBody: Swift.Equatable {
}

extension ListPolicyVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPolicyVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPolicyVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyVersions = output.policyVersions
        } else {
            self.policyVersions = nil
        }
    }
}

/// The output from the ListPolicyVersions operation.
public struct ListPolicyVersionsOutput: Swift.Equatable {
    /// The policy versions.
    public var policyVersions: [IoTClientTypes.PolicyVersion]?

    public init(
        policyVersions: [IoTClientTypes.PolicyVersion]? = nil
    )
    {
        self.policyVersions = policyVersions
    }
}

struct ListPolicyVersionsOutputBody: Swift.Equatable {
    let policyVersions: [IoTClientTypes.PolicyVersion]?
}

extension ListPolicyVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyVersions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyVersionsContainer = try containerValues.decodeIfPresent([IoTClientTypes.PolicyVersion?].self, forKey: .policyVersions)
        var policyVersionsDecoded0:[IoTClientTypes.PolicyVersion]? = nil
        if let policyVersionsContainer = policyVersionsContainer {
            policyVersionsDecoded0 = [IoTClientTypes.PolicyVersion]()
            for structure0 in policyVersionsContainer {
                if let structure0 = structure0 {
                    policyVersionsDecoded0?.append(structure0)
                }
            }
        }
        policyVersions = policyVersionsDecoded0
    }
}

enum ListPolicyVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPrincipalPoliciesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let principal = principal {
            items.add(Header(name: "x-amzn-iot-principal", value: Swift.String(principal)))
        }
        return items
    }
}

extension ListPrincipalPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ascendingOrder = ascendingOrder {
                let ascendingOrderQueryItem = ClientRuntime.URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
                items.append(ascendingOrderQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListPrincipalPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/principal-policies"
    }
}

/// The input for the ListPrincipalPolicies operation.
public struct ListPrincipalPoliciesInput: Swift.Equatable {
    /// Specifies the order for results. If true, results are returned in ascending creation order.
    public var ascendingOrder: Swift.Bool?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?
    /// The principal. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    /// This member is required.
    public var principal: Swift.String?

    public init(
        ascendingOrder: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        principal: Swift.String? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
        self.principal = principal
    }
}

struct ListPrincipalPoliciesInputBody: Swift.Equatable {
}

extension ListPrincipalPoliciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPrincipalPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPrincipalPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.policies = output.policies
        } else {
            self.nextMarker = nil
            self.policies = nil
        }
    }
}

/// The output from the ListPrincipalPolicies operation.
public struct ListPrincipalPoliciesOutput: Swift.Equatable {
    /// The marker for the next set of results, or null if there are no additional results.
    public var nextMarker: Swift.String?
    /// The policies.
    public var policies: [IoTClientTypes.Policy]?

    public init(
        nextMarker: Swift.String? = nil,
        policies: [IoTClientTypes.Policy]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.policies = policies
    }
}

struct ListPrincipalPoliciesOutputBody: Swift.Equatable {
    let policies: [IoTClientTypes.Policy]?
    let nextMarker: Swift.String?
}

extension ListPrincipalPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker
        case policies
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([IoTClientTypes.Policy?].self, forKey: .policies)
        var policiesDecoded0:[IoTClientTypes.Policy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [IoTClientTypes.Policy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListPrincipalPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPrincipalThingsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let principal = principal {
            items.add(Header(name: "x-amzn-principal", value: Swift.String(principal)))
        }
        return items
    }
}

extension ListPrincipalThingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPrincipalThingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/principals/things"
    }
}

/// The input for the ListPrincipalThings operation.
public struct ListPrincipalThingsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The principal.
    /// This member is required.
    public var principal: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
    }
}

struct ListPrincipalThingsInputBody: Swift.Equatable {
}

extension ListPrincipalThingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPrincipalThingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPrincipalThingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.things = output.things
        } else {
            self.nextToken = nil
            self.things = nil
        }
    }
}

/// The output from the ListPrincipalThings operation.
public struct ListPrincipalThingsOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The things.
    public var things: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        things: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

struct ListPrincipalThingsOutputBody: Swift.Equatable {
    let things: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListPrincipalThingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case things
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .things)
        var thingsDecoded0:[Swift.String]? = nil
        if let thingsContainer = thingsContainer {
            thingsDecoded0 = [Swift.String]()
            for string0 in thingsContainer {
                if let string0 = string0 {
                    thingsDecoded0?.append(string0)
                }
            }
        }
        things = thingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPrincipalThingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProvisioningTemplateVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListProvisioningTemplateVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let templateName = templateName else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())/versions"
    }
}

public struct ListProvisioningTemplateVersionsInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The name of the provisioning template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateName = templateName
    }
}

struct ListProvisioningTemplateVersionsInputBody: Swift.Equatable {
}

extension ListProvisioningTemplateVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProvisioningTemplateVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProvisioningTemplateVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListProvisioningTemplateVersionsOutput: Swift.Equatable {
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of provisioning template versions.
    public var versions: [IoTClientTypes.ProvisioningTemplateVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [IoTClientTypes.ProvisioningTemplateVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListProvisioningTemplateVersionsOutputBody: Swift.Equatable {
    let versions: [IoTClientTypes.ProvisioningTemplateVersionSummary]?
    let nextToken: Swift.String?
}

extension ListProvisioningTemplateVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case versions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([IoTClientTypes.ProvisioningTemplateVersionSummary?].self, forKey: .versions)
        var versionsDecoded0:[IoTClientTypes.ProvisioningTemplateVersionSummary]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [IoTClientTypes.ProvisioningTemplateVersionSummary]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProvisioningTemplateVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProvisioningTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListProvisioningTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/provisioning-templates"
    }
}

public struct ListProvisioningTemplatesInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProvisioningTemplatesInputBody: Swift.Equatable {
}

extension ListProvisioningTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProvisioningTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProvisioningTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templates = output.templates
        } else {
            self.nextToken = nil
            self.templates = nil
        }
    }
}

public struct ListProvisioningTemplatesOutput: Swift.Equatable {
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of provisioning templates
    public var templates: [IoTClientTypes.ProvisioningTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templates: [IoTClientTypes.ProvisioningTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templates = templates
    }
}

struct ListProvisioningTemplatesOutputBody: Swift.Equatable {
    let templates: [IoTClientTypes.ProvisioningTemplateSummary]?
    let nextToken: Swift.String?
}

extension ListProvisioningTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templates
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templatesContainer = try containerValues.decodeIfPresent([IoTClientTypes.ProvisioningTemplateSummary?].self, forKey: .templates)
        var templatesDecoded0:[IoTClientTypes.ProvisioningTemplateSummary]? = nil
        if let templatesContainer = templatesContainer {
            templatesDecoded0 = [IoTClientTypes.ProvisioningTemplateSummary]()
            for structure0 in templatesContainer {
                if let structure0 = structure0 {
                    templatesDecoded0?.append(structure0)
                }
            }
        }
        templates = templatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProvisioningTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRelatedResourcesForAuditFindingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let findingId = findingId else {
                let message = "Creating a URL Query Item failed. findingId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let findingIdQueryItem = ClientRuntime.URLQueryItem(name: "findingId".urlPercentEncoding(), value: Swift.String(findingId).urlPercentEncoding())
            items.append(findingIdQueryItem)
            return items
        }
    }
}

extension ListRelatedResourcesForAuditFindingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/relatedResources"
    }
}

public struct ListRelatedResourcesForAuditFindingInput: Swift.Equatable {
    /// The finding Id.
    /// This member is required.
    public var findingId: Swift.String?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        findingId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingId = findingId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRelatedResourcesForAuditFindingInputBody: Swift.Equatable {
}

extension ListRelatedResourcesForAuditFindingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRelatedResourcesForAuditFindingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRelatedResourcesForAuditFindingOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.relatedResources = output.relatedResources
        } else {
            self.nextToken = nil
            self.relatedResources = nil
        }
    }
}

public struct ListRelatedResourcesForAuditFindingOutput: Swift.Equatable {
    /// A token that can be used to retrieve the next set of results, or null for the first API call.
    public var nextToken: Swift.String?
    /// The related resources.
    public var relatedResources: [IoTClientTypes.RelatedResource]?

    public init(
        nextToken: Swift.String? = nil,
        relatedResources: [IoTClientTypes.RelatedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.relatedResources = relatedResources
    }
}

struct ListRelatedResourcesForAuditFindingOutputBody: Swift.Equatable {
    let relatedResources: [IoTClientTypes.RelatedResource]?
    let nextToken: Swift.String?
}

extension ListRelatedResourcesForAuditFindingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case relatedResources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relatedResourcesContainer = try containerValues.decodeIfPresent([IoTClientTypes.RelatedResource?].self, forKey: .relatedResources)
        var relatedResourcesDecoded0:[IoTClientTypes.RelatedResource]? = nil
        if let relatedResourcesContainer = relatedResourcesContainer {
            relatedResourcesDecoded0 = [IoTClientTypes.RelatedResource]()
            for structure0 in relatedResourcesContainer {
                if let structure0 = structure0 {
                    relatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        relatedResources = relatedResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRelatedResourcesForAuditFindingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRoleAliasesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ascendingOrder = ascendingOrder {
                let ascendingOrderQueryItem = ClientRuntime.URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
                items.append(ascendingOrderQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListRoleAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/role-aliases"
    }
}

public struct ListRoleAliasesInput: Swift.Equatable {
    /// Return the list of role aliases in ascending alphabetical order.
    public var ascendingOrder: Swift.Bool?
    /// A marker used to get the next set of results.
    public var marker: Swift.String?
    /// The maximum number of results to return at one time.
    public var pageSize: Swift.Int?

    public init(
        ascendingOrder: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.marker = marker
        self.pageSize = pageSize
    }
}

struct ListRoleAliasesInputBody: Swift.Equatable {
}

extension ListRoleAliasesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRoleAliasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRoleAliasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.roleAliases = output.roleAliases
        } else {
            self.nextMarker = nil
            self.roleAliases = nil
        }
    }
}

public struct ListRoleAliasesOutput: Swift.Equatable {
    /// A marker used to get the next set of results.
    public var nextMarker: Swift.String?
    /// The role aliases.
    public var roleAliases: [Swift.String]?

    public init(
        nextMarker: Swift.String? = nil,
        roleAliases: [Swift.String]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.roleAliases = roleAliases
    }
}

struct ListRoleAliasesOutputBody: Swift.Equatable {
    let roleAliases: [Swift.String]?
    let nextMarker: Swift.String?
}

extension ListRoleAliasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker
        case roleAliases
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleAliasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roleAliases)
        var roleAliasesDecoded0:[Swift.String]? = nil
        if let roleAliasesContainer = roleAliasesContainer {
            roleAliasesDecoded0 = [Swift.String]()
            for string0 in roleAliasesContainer {
                if let string0 = string0 {
                    roleAliasesDecoded0?.append(string0)
                }
            }
        }
        roleAliases = roleAliasesDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListRoleAliasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListScheduledAuditsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListScheduledAuditsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/scheduledaudits"
    }
}

public struct ListScheduledAuditsInput: Swift.Equatable {
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListScheduledAuditsInputBody: Swift.Equatable {
}

extension ListScheduledAuditsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListScheduledAuditsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListScheduledAuditsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.scheduledAudits = output.scheduledAudits
        } else {
            self.nextToken = nil
            self.scheduledAudits = nil
        }
    }
}

public struct ListScheduledAuditsOutput: Swift.Equatable {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of scheduled audits.
    public var scheduledAudits: [IoTClientTypes.ScheduledAuditMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        scheduledAudits: [IoTClientTypes.ScheduledAuditMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.scheduledAudits = scheduledAudits
    }
}

struct ListScheduledAuditsOutputBody: Swift.Equatable {
    let scheduledAudits: [IoTClientTypes.ScheduledAuditMetadata]?
    let nextToken: Swift.String?
}

extension ListScheduledAuditsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case scheduledAudits
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledAuditsContainer = try containerValues.decodeIfPresent([IoTClientTypes.ScheduledAuditMetadata?].self, forKey: .scheduledAudits)
        var scheduledAuditsDecoded0:[IoTClientTypes.ScheduledAuditMetadata]? = nil
        if let scheduledAuditsContainer = scheduledAuditsContainer {
            scheduledAuditsDecoded0 = [IoTClientTypes.ScheduledAuditMetadata]()
            for structure0 in scheduledAuditsContainer {
                if let structure0 = structure0 {
                    scheduledAuditsDecoded0?.append(structure0)
                }
            }
        }
        scheduledAudits = scheduledAuditsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListScheduledAuditsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSecurityProfilesForTargetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let recursive = recursive {
                let recursiveQueryItem = ClientRuntime.URLQueryItem(name: "recursive".urlPercentEncoding(), value: Swift.String(recursive).urlPercentEncoding())
                items.append(recursiveQueryItem)
            }
            guard let securityProfileTargetArn = securityProfileTargetArn else {
                let message = "Creating a URL Query Item failed. securityProfileTargetArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let securityProfileTargetArnQueryItem = ClientRuntime.URLQueryItem(name: "securityProfileTargetArn".urlPercentEncoding(), value: Swift.String(securityProfileTargetArn).urlPercentEncoding())
            items.append(securityProfileTargetArnQueryItem)
            return items
        }
    }
}

extension ListSecurityProfilesForTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/security-profiles-for-target"
    }
}

public struct ListSecurityProfilesForTargetInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// If true, return child groups too.
    public var recursive: Swift.Bool?
    /// The ARN of the target (thing group) whose attached security profiles you want to get.
    /// This member is required.
    public var securityProfileTargetArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recursive: Swift.Bool? = nil,
        securityProfileTargetArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recursive = recursive
        self.securityProfileTargetArn = securityProfileTargetArn
    }
}

struct ListSecurityProfilesForTargetInputBody: Swift.Equatable {
}

extension ListSecurityProfilesForTargetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSecurityProfilesForTargetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSecurityProfilesForTargetOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityProfileTargetMappings = output.securityProfileTargetMappings
        } else {
            self.nextToken = nil
            self.securityProfileTargetMappings = nil
        }
    }
}

public struct ListSecurityProfilesForTargetOutput: Swift.Equatable {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of security profiles and their associated targets.
    public var securityProfileTargetMappings: [IoTClientTypes.SecurityProfileTargetMapping]?

    public init(
        nextToken: Swift.String? = nil,
        securityProfileTargetMappings: [IoTClientTypes.SecurityProfileTargetMapping]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityProfileTargetMappings = securityProfileTargetMappings
    }
}

struct ListSecurityProfilesForTargetOutputBody: Swift.Equatable {
    let securityProfileTargetMappings: [IoTClientTypes.SecurityProfileTargetMapping]?
    let nextToken: Swift.String?
}

extension ListSecurityProfilesForTargetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case securityProfileTargetMappings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileTargetMappingsContainer = try containerValues.decodeIfPresent([IoTClientTypes.SecurityProfileTargetMapping?].self, forKey: .securityProfileTargetMappings)
        var securityProfileTargetMappingsDecoded0:[IoTClientTypes.SecurityProfileTargetMapping]? = nil
        if let securityProfileTargetMappingsContainer = securityProfileTargetMappingsContainer {
            securityProfileTargetMappingsDecoded0 = [IoTClientTypes.SecurityProfileTargetMapping]()
            for structure0 in securityProfileTargetMappingsContainer {
                if let structure0 = structure0 {
                    securityProfileTargetMappingsDecoded0?.append(structure0)
                }
            }
        }
        securityProfileTargetMappings = securityProfileTargetMappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSecurityProfilesForTargetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSecurityProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let metricName = metricName {
                let metricNameQueryItem = ClientRuntime.URLQueryItem(name: "metricName".urlPercentEncoding(), value: Swift.String(metricName).urlPercentEncoding())
                items.append(metricNameQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let dimensionName = dimensionName {
                let dimensionNameQueryItem = ClientRuntime.URLQueryItem(name: "dimensionName".urlPercentEncoding(), value: Swift.String(dimensionName).urlPercentEncoding())
                items.append(dimensionNameQueryItem)
            }
            return items
        }
    }
}

extension ListSecurityProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/security-profiles"
    }
}

public struct ListSecurityProfilesInput: Swift.Equatable {
    /// A filter to limit results to the security profiles that use the defined dimension. Cannot be used with metricName
    public var dimensionName: Swift.String?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The name of the custom metric. Cannot be used with dimensionName.
    public var metricName: Swift.String?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        dimensionName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metricName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dimensionName = dimensionName
        self.maxResults = maxResults
        self.metricName = metricName
        self.nextToken = nextToken
    }
}

struct ListSecurityProfilesInputBody: Swift.Equatable {
}

extension ListSecurityProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSecurityProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSecurityProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityProfileIdentifiers = output.securityProfileIdentifiers
        } else {
            self.nextToken = nil
            self.securityProfileIdentifiers = nil
        }
    }
}

public struct ListSecurityProfilesOutput: Swift.Equatable {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of security profile identifiers (names and ARNs).
    public var securityProfileIdentifiers: [IoTClientTypes.SecurityProfileIdentifier]?

    public init(
        nextToken: Swift.String? = nil,
        securityProfileIdentifiers: [IoTClientTypes.SecurityProfileIdentifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityProfileIdentifiers = securityProfileIdentifiers
    }
}

struct ListSecurityProfilesOutputBody: Swift.Equatable {
    let securityProfileIdentifiers: [IoTClientTypes.SecurityProfileIdentifier]?
    let nextToken: Swift.String?
}

extension ListSecurityProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case securityProfileIdentifiers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileIdentifiersContainer = try containerValues.decodeIfPresent([IoTClientTypes.SecurityProfileIdentifier?].self, forKey: .securityProfileIdentifiers)
        var securityProfileIdentifiersDecoded0:[IoTClientTypes.SecurityProfileIdentifier]? = nil
        if let securityProfileIdentifiersContainer = securityProfileIdentifiersContainer {
            securityProfileIdentifiersDecoded0 = [IoTClientTypes.SecurityProfileIdentifier]()
            for structure0 in securityProfileIdentifiersContainer {
                if let structure0 = structure0 {
                    securityProfileIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        securityProfileIdentifiers = securityProfileIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSecurityProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStreamsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ascendingOrder = ascendingOrder {
                let ascendingOrderQueryItem = ClientRuntime.URLQueryItem(name: "isAscendingOrder".urlPercentEncoding(), value: Swift.String(ascendingOrder).urlPercentEncoding())
                items.append(ascendingOrderQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListStreamsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/streams"
    }
}

public struct ListStreamsInput: Swift.Equatable {
    /// Set to true to return the list of streams in ascending order.
    public var ascendingOrder: Swift.Bool?
    /// The maximum number of results to return at a time.
    public var maxResults: Swift.Int?
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        ascendingOrder: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ascendingOrder = ascendingOrder
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStreamsInputBody: Swift.Equatable {
}

extension ListStreamsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStreamsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStreamsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streams = output.streams
        } else {
            self.nextToken = nil
            self.streams = nil
        }
    }
}

public struct ListStreamsOutput: Swift.Equatable {
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of streams.
    public var streams: [IoTClientTypes.StreamSummary]?

    public init(
        nextToken: Swift.String? = nil,
        streams: [IoTClientTypes.StreamSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streams = streams
    }
}

struct ListStreamsOutputBody: Swift.Equatable {
    let streams: [IoTClientTypes.StreamSummary]?
    let nextToken: Swift.String?
}

extension ListStreamsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case streams
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamsContainer = try containerValues.decodeIfPresent([IoTClientTypes.StreamSummary?].self, forKey: .streams)
        var streamsDecoded0:[IoTClientTypes.StreamSummary]? = nil
        if let streamsContainer = streamsContainer {
            streamsDecoded0 = [IoTClientTypes.StreamSummary]()
            for structure0 in streamsContainer {
                if let structure0 = structure0 {
                    streamsDecoded0?.append(structure0)
                }
            }
        }
        streams = streamsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStreamsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of tags assigned to the resource.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [IoTClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTargetsForPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListTargetsForPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let policyName = policyName else {
            return nil
        }
        return "/policy-targets/\(policyName.urlPercentEncoding())"
    }
}

public struct ListTargetsForPolicyInput: Swift.Equatable {
    /// A marker used to get the next set of results.
    public var marker: Swift.String?
    /// The maximum number of results to return at one time.
    public var pageSize: Swift.Int?
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
        self.policyName = policyName
    }
}

struct ListTargetsForPolicyInputBody: Swift.Equatable {
}

extension ListTargetsForPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTargetsForPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTargetsForPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.targets = output.targets
        } else {
            self.nextMarker = nil
            self.targets = nil
        }
    }
}

public struct ListTargetsForPolicyOutput: Swift.Equatable {
    /// A marker used to get the next set of results.
    public var nextMarker: Swift.String?
    /// The policy targets.
    public var targets: [Swift.String]?

    public init(
        nextMarker: Swift.String? = nil,
        targets: [Swift.String]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.targets = targets
    }
}

struct ListTargetsForPolicyOutputBody: Swift.Equatable {
    let targets: [Swift.String]?
    let nextMarker: Swift.String?
}

extension ListTargetsForPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker
        case targets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum ListTargetsForPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTargetsForSecurityProfileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTargetsForSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let securityProfileName = securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())/targets"
    }
}

public struct ListTargetsForSecurityProfileInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The security profile.
    /// This member is required.
    public var securityProfileName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfileName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileName = securityProfileName
    }
}

struct ListTargetsForSecurityProfileInputBody: Swift.Equatable {
}

extension ListTargetsForSecurityProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTargetsForSecurityProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTargetsForSecurityProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.securityProfileTargets = output.securityProfileTargets
        } else {
            self.nextToken = nil
            self.securityProfileTargets = nil
        }
    }
}

public struct ListTargetsForSecurityProfileOutput: Swift.Equatable {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The thing groups to which the security profile is attached.
    public var securityProfileTargets: [IoTClientTypes.SecurityProfileTarget]?

    public init(
        nextToken: Swift.String? = nil,
        securityProfileTargets: [IoTClientTypes.SecurityProfileTarget]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityProfileTargets = securityProfileTargets
    }
}

struct ListTargetsForSecurityProfileOutputBody: Swift.Equatable {
    let securityProfileTargets: [IoTClientTypes.SecurityProfileTarget]?
    let nextToken: Swift.String?
}

extension ListTargetsForSecurityProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case securityProfileTargets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileTargetsContainer = try containerValues.decodeIfPresent([IoTClientTypes.SecurityProfileTarget?].self, forKey: .securityProfileTargets)
        var securityProfileTargetsDecoded0:[IoTClientTypes.SecurityProfileTarget]? = nil
        if let securityProfileTargetsContainer = securityProfileTargetsContainer {
            securityProfileTargetsDecoded0 = [IoTClientTypes.SecurityProfileTarget]()
            for structure0 in securityProfileTargetsContainer {
                if let structure0 = structure0 {
                    securityProfileTargetsDecoded0?.append(structure0)
                }
            }
        }
        securityProfileTargets = securityProfileTargetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTargetsForSecurityProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListThingGroupsForThingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListThingGroupsForThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/thing-groups"
    }
}

public struct ListThingGroupsForThingInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingName = thingName
    }
}

struct ListThingGroupsForThingInputBody: Swift.Equatable {
}

extension ListThingGroupsForThingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListThingGroupsForThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListThingGroupsForThingOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.thingGroups = output.thingGroups
        } else {
            self.nextToken = nil
            self.thingGroups = nil
        }
    }
}

public struct ListThingGroupsForThingOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The thing groups.
    public var thingGroups: [IoTClientTypes.GroupNameAndArn]?

    public init(
        nextToken: Swift.String? = nil,
        thingGroups: [IoTClientTypes.GroupNameAndArn]? = nil
    )
    {
        self.nextToken = nextToken
        self.thingGroups = thingGroups
    }
}

struct ListThingGroupsForThingOutputBody: Swift.Equatable {
    let thingGroups: [IoTClientTypes.GroupNameAndArn]?
    let nextToken: Swift.String?
}

extension ListThingGroupsForThingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case thingGroups
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupsContainer = try containerValues.decodeIfPresent([IoTClientTypes.GroupNameAndArn?].self, forKey: .thingGroups)
        var thingGroupsDecoded0:[IoTClientTypes.GroupNameAndArn]? = nil
        if let thingGroupsContainer = thingGroupsContainer {
            thingGroupsDecoded0 = [IoTClientTypes.GroupNameAndArn]()
            for structure0 in thingGroupsContainer {
                if let structure0 = structure0 {
                    thingGroupsDecoded0?.append(structure0)
                }
            }
        }
        thingGroups = thingGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListThingGroupsForThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListThingGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let parentGroup = parentGroup {
                let parentGroupQueryItem = ClientRuntime.URLQueryItem(name: "parentGroup".urlPercentEncoding(), value: Swift.String(parentGroup).urlPercentEncoding())
                items.append(parentGroupQueryItem)
            }
            if let namePrefixFilter = namePrefixFilter {
                let namePrefixFilterQueryItem = ClientRuntime.URLQueryItem(name: "namePrefixFilter".urlPercentEncoding(), value: Swift.String(namePrefixFilter).urlPercentEncoding())
                items.append(namePrefixFilterQueryItem)
            }
            if let recursive = recursive {
                let recursiveQueryItem = ClientRuntime.URLQueryItem(name: "recursive".urlPercentEncoding(), value: Swift.String(recursive).urlPercentEncoding())
                items.append(recursiveQueryItem)
            }
            return items
        }
    }
}

extension ListThingGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/thing-groups"
    }
}

public struct ListThingGroupsInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A filter that limits the results to those with the specified name prefix.
    public var namePrefixFilter: Swift.String?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// A filter that limits the results to those with the specified parent group.
    public var parentGroup: Swift.String?
    /// If true, return child groups as well.
    public var recursive: Swift.Bool?

    public init(
        maxResults: Swift.Int? = nil,
        namePrefixFilter: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        parentGroup: Swift.String? = nil,
        recursive: Swift.Bool? = nil
    )
    {
        self.maxResults = maxResults
        self.namePrefixFilter = namePrefixFilter
        self.nextToken = nextToken
        self.parentGroup = parentGroup
        self.recursive = recursive
    }
}

struct ListThingGroupsInputBody: Swift.Equatable {
}

extension ListThingGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListThingGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListThingGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.thingGroups = output.thingGroups
        } else {
            self.nextToken = nil
            self.thingGroups = nil
        }
    }
}

public struct ListThingGroupsOutput: Swift.Equatable {
    /// The token to use to get the next set of results. Will not be returned if operation has returned all results.
    public var nextToken: Swift.String?
    /// The thing groups.
    public var thingGroups: [IoTClientTypes.GroupNameAndArn]?

    public init(
        nextToken: Swift.String? = nil,
        thingGroups: [IoTClientTypes.GroupNameAndArn]? = nil
    )
    {
        self.nextToken = nextToken
        self.thingGroups = thingGroups
    }
}

struct ListThingGroupsOutputBody: Swift.Equatable {
    let thingGroups: [IoTClientTypes.GroupNameAndArn]?
    let nextToken: Swift.String?
}

extension ListThingGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case thingGroups
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupsContainer = try containerValues.decodeIfPresent([IoTClientTypes.GroupNameAndArn?].self, forKey: .thingGroups)
        var thingGroupsDecoded0:[IoTClientTypes.GroupNameAndArn]? = nil
        if let thingGroupsContainer = thingGroupsContainer {
            thingGroupsDecoded0 = [IoTClientTypes.GroupNameAndArn]()
            for structure0 in thingGroupsContainer {
                if let structure0 = structure0 {
                    thingGroupsDecoded0?.append(structure0)
                }
            }
        }
        thingGroups = thingGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListThingGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListThingPrincipalsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListThingPrincipalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/principals"
    }
}

/// The input for the ListThingPrincipal operation.
public struct ListThingPrincipalsInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingName = thingName
    }
}

struct ListThingPrincipalsInputBody: Swift.Equatable {
}

extension ListThingPrincipalsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListThingPrincipalsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListThingPrincipalsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.principals = output.principals
        } else {
            self.nextToken = nil
            self.principals = nil
        }
    }
}

/// The output from the ListThingPrincipals operation.
public struct ListThingPrincipalsOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The principals associated with the thing.
    public var principals: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        principals: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.principals = principals
    }
}

struct ListThingPrincipalsOutputBody: Swift.Equatable {
    let principals: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListThingPrincipalsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case principals
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListThingPrincipalsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListThingRegistrationTaskReportsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let reportType = reportType else {
                let message = "Creating a URL Query Item failed. reportType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let reportTypeQueryItem = ClientRuntime.URLQueryItem(name: "reportType".urlPercentEncoding(), value: Swift.String(reportType.rawValue).urlPercentEncoding())
            items.append(reportTypeQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListThingRegistrationTaskReportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/thing-registration-tasks/\(taskId.urlPercentEncoding())/reports"
    }
}

public struct ListThingRegistrationTaskReportsInput: Swift.Equatable {
    /// The maximum number of results to return per request.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The type of task report.
    /// This member is required.
    public var reportType: IoTClientTypes.ReportType?
    /// The id of the task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        reportType: IoTClientTypes.ReportType? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reportType = reportType
        self.taskId = taskId
    }
}

struct ListThingRegistrationTaskReportsInputBody: Swift.Equatable {
}

extension ListThingRegistrationTaskReportsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListThingRegistrationTaskReportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListThingRegistrationTaskReportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportType = output.reportType
            self.resourceLinks = output.resourceLinks
        } else {
            self.nextToken = nil
            self.reportType = nil
            self.resourceLinks = nil
        }
    }
}

public struct ListThingRegistrationTaskReportsOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The type of task report.
    public var reportType: IoTClientTypes.ReportType?
    /// Links to the task resources.
    public var resourceLinks: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        reportType: IoTClientTypes.ReportType? = nil,
        resourceLinks: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportType = reportType
        self.resourceLinks = resourceLinks
    }
}

struct ListThingRegistrationTaskReportsOutputBody: Swift.Equatable {
    let resourceLinks: [Swift.String]?
    let reportType: IoTClientTypes.ReportType?
    let nextToken: Swift.String?
}

extension ListThingRegistrationTaskReportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case reportType
        case resourceLinks
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceLinksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceLinks)
        var resourceLinksDecoded0:[Swift.String]? = nil
        if let resourceLinksContainer = resourceLinksContainer {
            resourceLinksDecoded0 = [Swift.String]()
            for string0 in resourceLinksContainer {
                if let string0 = string0 {
                    resourceLinksDecoded0?.append(string0)
                }
            }
        }
        resourceLinks = resourceLinksDecoded0
        let reportTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ReportType.self, forKey: .reportType)
        reportType = reportTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListThingRegistrationTaskReportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListThingRegistrationTasksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListThingRegistrationTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/thing-registration-tasks"
    }
}

public struct ListThingRegistrationTasksInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The status of the bulk thing provisioning task.
    public var status: IoTClientTypes.Status?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: IoTClientTypes.Status? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListThingRegistrationTasksInputBody: Swift.Equatable {
}

extension ListThingRegistrationTasksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListThingRegistrationTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListThingRegistrationTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.taskIds = output.taskIds
        } else {
            self.nextToken = nil
            self.taskIds = nil
        }
    }
}

public struct ListThingRegistrationTasksOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of bulk thing provisioning task IDs.
    public var taskIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        taskIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskIds = taskIds
    }
}

struct ListThingRegistrationTasksOutputBody: Swift.Equatable {
    let taskIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListThingRegistrationTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case taskIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .taskIds)
        var taskIdsDecoded0:[Swift.String]? = nil
        if let taskIdsContainer = taskIdsContainer {
            taskIdsDecoded0 = [Swift.String]()
            for string0 in taskIdsContainer {
                if let string0 = string0 {
                    taskIdsDecoded0?.append(string0)
                }
            }
        }
        taskIds = taskIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListThingRegistrationTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListThingTypesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let thingTypeName = thingTypeName {
                let thingTypeNameQueryItem = ClientRuntime.URLQueryItem(name: "thingTypeName".urlPercentEncoding(), value: Swift.String(thingTypeName).urlPercentEncoding())
                items.append(thingTypeNameQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListThingTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/thing-types"
    }
}

/// The input for the ListThingTypes operation.
public struct ListThingTypesInput: Swift.Equatable {
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The name of the thing type.
    public var thingTypeName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        thingTypeName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingTypeName = thingTypeName
    }
}

struct ListThingTypesInputBody: Swift.Equatable {
}

extension ListThingTypesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListThingTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListThingTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.thingTypes = output.thingTypes
        } else {
            self.nextToken = nil
            self.thingTypes = nil
        }
    }
}

/// The output for the ListThingTypes operation.
public struct ListThingTypesOutput: Swift.Equatable {
    /// The token for the next set of results. Will not be returned if operation has returned all results.
    public var nextToken: Swift.String?
    /// The thing types.
    public var thingTypes: [IoTClientTypes.ThingTypeDefinition]?

    public init(
        nextToken: Swift.String? = nil,
        thingTypes: [IoTClientTypes.ThingTypeDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.thingTypes = thingTypes
    }
}

struct ListThingTypesOutputBody: Swift.Equatable {
    let thingTypes: [IoTClientTypes.ThingTypeDefinition]?
    let nextToken: Swift.String?
}

extension ListThingTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case thingTypes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypesContainer = try containerValues.decodeIfPresent([IoTClientTypes.ThingTypeDefinition?].self, forKey: .thingTypes)
        var thingTypesDecoded0:[IoTClientTypes.ThingTypeDefinition]? = nil
        if let thingTypesContainer = thingTypesContainer {
            thingTypesDecoded0 = [IoTClientTypes.ThingTypeDefinition]()
            for structure0 in thingTypesContainer {
                if let structure0 = structure0 {
                    thingTypesDecoded0?.append(structure0)
                }
            }
        }
        thingTypes = thingTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListThingTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListThingsInBillingGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListThingsInBillingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let billingGroupName = billingGroupName else {
            return nil
        }
        return "/billing-groups/\(billingGroupName.urlPercentEncoding())/things"
    }
}

public struct ListThingsInBillingGroupInput: Swift.Equatable {
    /// The name of the billing group.
    /// This member is required.
    public var billingGroupName: Swift.String?
    /// The maximum number of results to return per request.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        billingGroupName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingGroupName = billingGroupName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListThingsInBillingGroupInputBody: Swift.Equatable {
}

extension ListThingsInBillingGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListThingsInBillingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListThingsInBillingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.things = output.things
        } else {
            self.nextToken = nil
            self.things = nil
        }
    }
}

public struct ListThingsInBillingGroupOutput: Swift.Equatable {
    /// The token to use to get the next set of results. Will not be returned if operation has returned all results.
    public var nextToken: Swift.String?
    /// A list of things in the billing group.
    public var things: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        things: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

struct ListThingsInBillingGroupOutputBody: Swift.Equatable {
    let things: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListThingsInBillingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case things
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .things)
        var thingsDecoded0:[Swift.String]? = nil
        if let thingsContainer = thingsContainer {
            thingsDecoded0 = [Swift.String]()
            for string0 in thingsContainer {
                if let string0 = string0 {
                    thingsDecoded0?.append(string0)
                }
            }
        }
        things = thingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListThingsInBillingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListThingsInThingGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let recursive = recursive {
                let recursiveQueryItem = ClientRuntime.URLQueryItem(name: "recursive".urlPercentEncoding(), value: Swift.String(recursive).urlPercentEncoding())
                items.append(recursiveQueryItem)
            }
            return items
        }
    }
}

extension ListThingsInThingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingGroupName = thingGroupName else {
            return nil
        }
        return "/thing-groups/\(thingGroupName.urlPercentEncoding())/things"
    }
}

public struct ListThingsInThingGroupInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// When true, list things in this thing group and in all child groups as well.
    public var recursive: Swift.Bool?
    /// The thing group name.
    /// This member is required.
    public var thingGroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recursive: Swift.Bool? = nil,
        thingGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recursive = recursive
        self.thingGroupName = thingGroupName
    }
}

struct ListThingsInThingGroupInputBody: Swift.Equatable {
}

extension ListThingsInThingGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListThingsInThingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListThingsInThingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.things = output.things
        } else {
            self.nextToken = nil
            self.things = nil
        }
    }
}

public struct ListThingsInThingGroupOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The things in the specified thing group.
    public var things: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        things: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

struct ListThingsInThingGroupOutputBody: Swift.Equatable {
    let things: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListThingsInThingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case things
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .things)
        var thingsDecoded0:[Swift.String]? = nil
        if let thingsContainer = thingsContainer {
            thingsDecoded0 = [Swift.String]()
            for string0 in thingsContainer {
                if let string0 = string0 {
                    thingsDecoded0?.append(string0)
                }
            }
        }
        things = thingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListThingsInThingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListThingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let usePrefixAttributeValue = usePrefixAttributeValue {
                let usePrefixAttributeValueQueryItem = ClientRuntime.URLQueryItem(name: "usePrefixAttributeValue".urlPercentEncoding(), value: Swift.String(usePrefixAttributeValue).urlPercentEncoding())
                items.append(usePrefixAttributeValueQueryItem)
            }
            if let attributeValue = attributeValue {
                let attributeValueQueryItem = ClientRuntime.URLQueryItem(name: "attributeValue".urlPercentEncoding(), value: Swift.String(attributeValue).urlPercentEncoding())
                items.append(attributeValueQueryItem)
            }
            if let thingTypeName = thingTypeName {
                let thingTypeNameQueryItem = ClientRuntime.URLQueryItem(name: "thingTypeName".urlPercentEncoding(), value: Swift.String(thingTypeName).urlPercentEncoding())
                items.append(thingTypeNameQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let attributeName = attributeName {
                let attributeNameQueryItem = ClientRuntime.URLQueryItem(name: "attributeName".urlPercentEncoding(), value: Swift.String(attributeName).urlPercentEncoding())
                items.append(attributeNameQueryItem)
            }
            return items
        }
    }
}

extension ListThingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/things"
    }
}

/// The input for the ListThings operation.
public struct ListThingsInput: Swift.Equatable {
    /// The attribute name used to search for things.
    public var attributeName: Swift.String?
    /// The attribute value used to search for things.
    public var attributeValue: Swift.String?
    /// The maximum number of results to return in this operation.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The name of the thing type used to search for things.
    public var thingTypeName: Swift.String?
    /// When true, the action returns the thing resources with attribute values that start with the attributeValue provided. When false, or not present, the action returns only the thing resources with attribute values that match the entire attributeValue provided.
    public var usePrefixAttributeValue: Swift.Bool?

    public init(
        attributeName: Swift.String? = nil,
        attributeValue: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        thingTypeName: Swift.String? = nil,
        usePrefixAttributeValue: Swift.Bool? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingTypeName = thingTypeName
        self.usePrefixAttributeValue = usePrefixAttributeValue
    }
}

struct ListThingsInputBody: Swift.Equatable {
}

extension ListThingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListThingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListThingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.things = output.things
        } else {
            self.nextToken = nil
            self.things = nil
        }
    }
}

/// The output from the ListThings operation.
public struct ListThingsOutput: Swift.Equatable {
    /// The token to use to get the next set of results. Will not be returned if operation has returned all results.
    public var nextToken: Swift.String?
    /// The things.
    public var things: [IoTClientTypes.ThingAttribute]?

    public init(
        nextToken: Swift.String? = nil,
        things: [IoTClientTypes.ThingAttribute]? = nil
    )
    {
        self.nextToken = nextToken
        self.things = things
    }
}

struct ListThingsOutputBody: Swift.Equatable {
    let things: [IoTClientTypes.ThingAttribute]?
    let nextToken: Swift.String?
}

extension ListThingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case things
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingsContainer = try containerValues.decodeIfPresent([IoTClientTypes.ThingAttribute?].self, forKey: .things)
        var thingsDecoded0:[IoTClientTypes.ThingAttribute]? = nil
        if let thingsContainer = thingsContainer {
            thingsDecoded0 = [IoTClientTypes.ThingAttribute]()
            for structure0 in thingsContainer {
                if let structure0 = structure0 {
                    thingsDecoded0?.append(structure0)
                }
            }
        }
        things = thingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListThingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTopicRuleDestinationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListTopicRuleDestinationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/destinations"
    }
}

public struct ListTopicRuleDestinationsInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTopicRuleDestinationsInputBody: Swift.Equatable {
}

extension ListTopicRuleDestinationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTopicRuleDestinationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTopicRuleDestinationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationSummaries = output.destinationSummaries
            self.nextToken = output.nextToken
        } else {
            self.destinationSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListTopicRuleDestinationsOutput: Swift.Equatable {
    /// Information about a topic rule destination.
    public var destinationSummaries: [IoTClientTypes.TopicRuleDestinationSummary]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        destinationSummaries: [IoTClientTypes.TopicRuleDestinationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinationSummaries = destinationSummaries
        self.nextToken = nextToken
    }
}

struct ListTopicRuleDestinationsOutputBody: Swift.Equatable {
    let destinationSummaries: [IoTClientTypes.TopicRuleDestinationSummary]?
    let nextToken: Swift.String?
}

extension ListTopicRuleDestinationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationSummariesContainer = try containerValues.decodeIfPresent([IoTClientTypes.TopicRuleDestinationSummary?].self, forKey: .destinationSummaries)
        var destinationSummariesDecoded0:[IoTClientTypes.TopicRuleDestinationSummary]? = nil
        if let destinationSummariesContainer = destinationSummariesContainer {
            destinationSummariesDecoded0 = [IoTClientTypes.TopicRuleDestinationSummary]()
            for structure0 in destinationSummariesContainer {
                if let structure0 = structure0 {
                    destinationSummariesDecoded0?.append(structure0)
                }
            }
        }
        destinationSummaries = destinationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTopicRuleDestinationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTopicRulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ruleDisabled = ruleDisabled {
                let ruleDisabledQueryItem = ClientRuntime.URLQueryItem(name: "ruleDisabled".urlPercentEncoding(), value: Swift.String(ruleDisabled).urlPercentEncoding())
                items.append(ruleDisabledQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let topic = topic {
                let topicQueryItem = ClientRuntime.URLQueryItem(name: "topic".urlPercentEncoding(), value: Swift.String(topic).urlPercentEncoding())
                items.append(topicQueryItem)
            }
            return items
        }
    }
}

extension ListTopicRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/rules"
    }
}

/// The input for the ListTopicRules operation.
public struct ListTopicRulesInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// Specifies whether the rule is disabled.
    public var ruleDisabled: Swift.Bool?
    /// The topic.
    public var topic: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ruleDisabled: Swift.Bool? = nil,
        topic: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ruleDisabled = ruleDisabled
        self.topic = topic
    }
}

struct ListTopicRulesInputBody: Swift.Equatable {
}

extension ListTopicRulesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTopicRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTopicRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.rules = nil
        }
    }
}

/// The output from the ListTopicRules operation.
public struct ListTopicRulesOutput: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The rules.
    public var rules: [IoTClientTypes.TopicRuleListItem]?

    public init(
        nextToken: Swift.String? = nil,
        rules: [IoTClientTypes.TopicRuleListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.rules = rules
    }
}

struct ListTopicRulesOutputBody: Swift.Equatable {
    let rules: [IoTClientTypes.TopicRuleListItem]?
    let nextToken: Swift.String?
}

extension ListTopicRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case rules
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([IoTClientTypes.TopicRuleListItem?].self, forKey: .rules)
        var rulesDecoded0:[IoTClientTypes.TopicRuleListItem]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [IoTClientTypes.TopicRuleListItem]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTopicRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListV2LoggingLevelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let targetType = targetType {
                let targetTypeQueryItem = ClientRuntime.URLQueryItem(name: "targetType".urlPercentEncoding(), value: Swift.String(targetType.rawValue).urlPercentEncoding())
                items.append(targetTypeQueryItem)
            }
            return items
        }
    }
}

extension ListV2LoggingLevelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2LoggingLevel"
    }
}

public struct ListV2LoggingLevelsInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?
    /// The type of resource for which you are configuring logging. Must be THING_Group.
    public var targetType: IoTClientTypes.LogTargetType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetType: IoTClientTypes.LogTargetType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetType = targetType
    }
}

struct ListV2LoggingLevelsInputBody: Swift.Equatable {
}

extension ListV2LoggingLevelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListV2LoggingLevelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListV2LoggingLevelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.logTargetConfigurations = output.logTargetConfigurations
            self.nextToken = output.nextToken
        } else {
            self.logTargetConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListV2LoggingLevelsOutput: Swift.Equatable {
    /// The logging configuration for a target.
    public var logTargetConfigurations: [IoTClientTypes.LogTargetConfiguration]?
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        logTargetConfigurations: [IoTClientTypes.LogTargetConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.logTargetConfigurations = logTargetConfigurations
        self.nextToken = nextToken
    }
}

struct ListV2LoggingLevelsOutputBody: Swift.Equatable {
    let logTargetConfigurations: [IoTClientTypes.LogTargetConfiguration]?
    let nextToken: Swift.String?
}

extension ListV2LoggingLevelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logTargetConfigurations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logTargetConfigurationsContainer = try containerValues.decodeIfPresent([IoTClientTypes.LogTargetConfiguration?].self, forKey: .logTargetConfigurations)
        var logTargetConfigurationsDecoded0:[IoTClientTypes.LogTargetConfiguration]? = nil
        if let logTargetConfigurationsContainer = logTargetConfigurationsContainer {
            logTargetConfigurationsDecoded0 = [IoTClientTypes.LogTargetConfiguration]()
            for structure0 in logTargetConfigurationsContainer {
                if let structure0 = structure0 {
                    logTargetConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        logTargetConfigurations = logTargetConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListV2LoggingLevelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotConfiguredException": return try await NotConfiguredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListViolationEventsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let securityProfileName = securityProfileName {
                let securityProfileNameQueryItem = ClientRuntime.URLQueryItem(name: "securityProfileName".urlPercentEncoding(), value: Swift.String(securityProfileName).urlPercentEncoding())
                items.append(securityProfileNameQueryItem)
            }
            if let listSuppressedAlerts = listSuppressedAlerts {
                let listSuppressedAlertsQueryItem = ClientRuntime.URLQueryItem(name: "listSuppressedAlerts".urlPercentEncoding(), value: Swift.String(listSuppressedAlerts).urlPercentEncoding())
                items.append(listSuppressedAlertsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let behaviorCriteriaType = behaviorCriteriaType {
                let behaviorCriteriaTypeQueryItem = ClientRuntime.URLQueryItem(name: "behaviorCriteriaType".urlPercentEncoding(), value: Swift.String(behaviorCriteriaType.rawValue).urlPercentEncoding())
                items.append(behaviorCriteriaTypeQueryItem)
            }
            if let thingName = thingName {
                let thingNameQueryItem = ClientRuntime.URLQueryItem(name: "thingName".urlPercentEncoding(), value: Swift.String(thingName).urlPercentEncoding())
                items.append(thingNameQueryItem)
            }
            guard let startTime = startTime else {
                let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
            guard let endTime = endTime else {
                let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
            if let verificationState = verificationState {
                let verificationStateQueryItem = ClientRuntime.URLQueryItem(name: "verificationState".urlPercentEncoding(), value: Swift.String(verificationState.rawValue).urlPercentEncoding())
                items.append(verificationStateQueryItem)
            }
            return items
        }
    }
}

extension ListViolationEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/violation-events"
    }
}

public struct ListViolationEventsInput: Swift.Equatable {
    /// The criteria for a behavior.
    public var behaviorCriteriaType: IoTClientTypes.BehaviorCriteriaType?
    /// The end time for the alerts to be listed.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// A list of all suppressed alerts.
    public var listSuppressedAlerts: Swift.Bool?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// A filter to limit results to those alerts generated by the specified security profile.
    public var securityProfileName: Swift.String?
    /// The start time for the alerts to be listed.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// A filter to limit results to those alerts caused by the specified thing.
    public var thingName: Swift.String?
    /// The verification state of the violation (detect alarm).
    public var verificationState: IoTClientTypes.VerificationState?

    public init(
        behaviorCriteriaType: IoTClientTypes.BehaviorCriteriaType? = nil,
        endTime: ClientRuntime.Date? = nil,
        listSuppressedAlerts: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityProfileName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        thingName: Swift.String? = nil,
        verificationState: IoTClientTypes.VerificationState? = nil
    )
    {
        self.behaviorCriteriaType = behaviorCriteriaType
        self.endTime = endTime
        self.listSuppressedAlerts = listSuppressedAlerts
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityProfileName = securityProfileName
        self.startTime = startTime
        self.thingName = thingName
        self.verificationState = verificationState
    }
}

struct ListViolationEventsInputBody: Swift.Equatable {
}

extension ListViolationEventsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListViolationEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListViolationEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.violationEvents = output.violationEvents
        } else {
            self.nextToken = nil
            self.violationEvents = nil
        }
    }
}

public struct ListViolationEventsOutput: Swift.Equatable {
    /// A token that can be used to retrieve the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The security profile violation alerts issued for this account during the given time period, potentially filtered by security profile, behavior violated, or thing (device) violating.
    public var violationEvents: [IoTClientTypes.ViolationEvent]?

    public init(
        nextToken: Swift.String? = nil,
        violationEvents: [IoTClientTypes.ViolationEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.violationEvents = violationEvents
    }
}

struct ListViolationEventsOutputBody: Swift.Equatable {
    let violationEvents: [IoTClientTypes.ViolationEvent]?
    let nextToken: Swift.String?
}

extension ListViolationEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case violationEvents
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationEventsContainer = try containerValues.decodeIfPresent([IoTClientTypes.ViolationEvent?].self, forKey: .violationEvents)
        var violationEventsDecoded0:[IoTClientTypes.ViolationEvent]? = nil
        if let violationEventsContainer = violationEventsContainer {
            violationEventsDecoded0 = [IoTClientTypes.ViolationEvent]()
            for structure0 in violationEventsContainer {
                if let structure0 = structure0 {
                    violationEventsDecoded0?.append(structure0)
                }
            }
        }
        violationEvents = violationEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListViolationEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.LocationAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId
        case latitude
        case longitude
        case roleArn
        case timestamp
        case trackerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let latitude = self.latitude {
            try encodeContainer.encode(latitude, forKey: .latitude)
        }
        if let longitude = self.longitude {
            try encodeContainer.encode(longitude, forKey: .longitude)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let trackerName = self.trackerName {
            try encodeContainer.encode(trackerName, forKey: .trackerName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let trackerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackerName)
        trackerName = trackerNameDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LocationTimestamp.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let latitudeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latitude)
        latitude = latitudeDecoded
        let longitudeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longitude)
        longitude = longitudeDecoded
    }
}

extension IoTClientTypes {
    /// The Amazon Location rule action sends device location updates from an MQTT message to an Amazon Location tracker resource.
    public struct LocationAction: Swift.Equatable {
        /// The unique ID of the device providing the location data.
        /// This member is required.
        public var deviceId: Swift.String?
        /// A string that evaluates to a double value that represents the latitude of the device's location.
        /// This member is required.
        public var latitude: Swift.String?
        /// A string that evaluates to a double value that represents the longitude of the device's location.
        /// This member is required.
        public var longitude: Swift.String?
        /// The IAM role that grants permission to write to the Amazon Location resource.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The time that the location data was sampled. The default value is the time the MQTT message was processed.
        public var timestamp: IoTClientTypes.LocationTimestamp?
        /// The name of the tracker resource in Amazon Location in which the location is updated.
        /// This member is required.
        public var trackerName: Swift.String?

        public init(
            deviceId: Swift.String? = nil,
            latitude: Swift.String? = nil,
            longitude: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            timestamp: IoTClientTypes.LocationTimestamp? = nil,
            trackerName: Swift.String? = nil
        )
        {
            self.deviceId = deviceId
            self.latitude = latitude
            self.longitude = longitude
            self.roleArn = roleArn
            self.timestamp = timestamp
            self.trackerName = trackerName
        }
    }

}

extension IoTClientTypes.LocationTimestamp: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension IoTClientTypes {
    /// Describes how to interpret an application-defined timestamp value from an MQTT message payload and the precision of that value.
    public struct LocationTimestamp: Swift.Equatable {
        /// The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS | MILLISECONDS | MICROSECONDS | NANOSECONDS. The default is MILLISECONDS.
        public var unit: Swift.String?
        /// An expression that returns a long epoch time value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            unit: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension IoTClientTypes {
    public enum LogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case debug
        case disabled
        case error
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .debug,
                .disabled,
                .error,
                .info,
                .warn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .disabled: return "DISABLED"
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogLevel(rawValue: rawValue) ?? LogLevel.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.LogTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetName
        case targetType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetName = self.targetName {
            try encodeContainer.encode(targetName, forKey: .targetName)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LogTargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let targetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetName)
        targetName = targetNameDecoded
    }
}

extension IoTClientTypes {
    /// A log target.
    public struct LogTarget: Swift.Equatable {
        /// The target name.
        public var targetName: Swift.String?
        /// The target type.
        /// This member is required.
        public var targetType: IoTClientTypes.LogTargetType?

        public init(
            targetName: Swift.String? = nil,
            targetType: IoTClientTypes.LogTargetType? = nil
        )
        {
            self.targetName = targetName
            self.targetType = targetType
        }
    }

}

extension IoTClientTypes.LogTargetConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel
        case logTarget
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let logTarget = self.logTarget {
            try encodeContainer.encode(logTarget, forKey: .logTarget)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logTargetDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LogTarget.self, forKey: .logTarget)
        logTarget = logTargetDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension IoTClientTypes {
    /// The target configuration.
    public struct LogTargetConfiguration: Swift.Equatable {
        /// The logging level.
        public var logLevel: IoTClientTypes.LogLevel?
        /// A log target
        public var logTarget: IoTClientTypes.LogTarget?

        public init(
            logLevel: IoTClientTypes.LogLevel? = nil,
            logTarget: IoTClientTypes.LogTarget? = nil
        )
        {
            self.logLevel = logLevel
            self.logTarget = logTarget
        }
    }

}

extension IoTClientTypes {
    public enum LogTargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clientId
        case `default`
        case deviceDefender
        case eventType
        case principalId
        case sourceIp
        case thingGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [LogTargetType] {
            return [
                .clientId,
                .default,
                .deviceDefender,
                .eventType,
                .principalId,
                .sourceIp,
                .thingGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clientId: return "CLIENT_ID"
            case .default: return "DEFAULT"
            case .deviceDefender: return "DEVICE_DEFENDER"
            case .eventType: return "EVENT_TYPE"
            case .principalId: return "PRINCIPAL_ID"
            case .sourceIp: return "SOURCE_IP"
            case .thingGroup: return "THING_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogTargetType(rawValue: rawValue) ?? LogTargetType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.LoggingOptionsPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension IoTClientTypes {
    /// Describes the logging options payload.
    public struct LoggingOptionsPayload: Swift.Equatable {
        /// The log level.
        public var logLevel: IoTClientTypes.LogLevel?
        /// The ARN of the IAM role that grants access.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            logLevel: IoTClientTypes.LogLevel? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.logLevel = logLevel
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes.MachineLearningDetectionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confidenceLevel
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confidenceLevel = self.confidenceLevel {
            try encodeContainer.encode(confidenceLevel.rawValue, forKey: .confidenceLevel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confidenceLevelDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ConfidenceLevel.self, forKey: .confidenceLevel)
        confidenceLevel = confidenceLevelDecoded
    }
}

extension IoTClientTypes {
    /// The configuration of an ML Detect Security Profile.
    public struct MachineLearningDetectionConfig: Swift.Equatable {
        /// The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
        /// This member is required.
        public var confidenceLevel: IoTClientTypes.ConfidenceLevel?

        public init(
            confidenceLevel: IoTClientTypes.ConfidenceLevel? = nil
        )
        {
            self.confidenceLevel = confidenceLevel
        }
    }

}

extension IoTClientTypes.MaintenanceWindow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInMinutes
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = self.durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
    }
}

extension IoTClientTypes {
    /// An optional configuration within the SchedulingConfig to setup a recurring maintenance window with a predetermined start time and duration for the rollout of a job document to all devices in a target group for a job.
    public struct MaintenanceWindow: Swift.Equatable {
        /// Displays the duration of the next maintenance window.
        /// This member is required.
        public var durationInMinutes: Swift.Int?
        /// Displays the start time of the next maintenance window.
        /// This member is required.
        public var startTime: Swift.String?

        public init(
            durationInMinutes: Swift.Int? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.startTime = startTime
        }
    }

}

extension MalformedPolicyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MalformedPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The policy documentation is not valid.
public struct MalformedPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedPolicyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MalformedPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MalformedPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes.ManagedJobTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case environments
        case templateArn
        case templateName
        case templateVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environments = environments {
            var environmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environments)
            for environment0 in environments {
                try environmentsContainer.encode(environment0)
            }
        }
        if let templateArn = self.templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateVersion = self.templateVersion {
            try encodeContainer.encode(templateVersion, forKey: .templateVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .environments)
        var environmentsDecoded0:[Swift.String]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [Swift.String]()
            for string0 in environmentsContainer {
                if let string0 = string0 {
                    environmentsDecoded0?.append(string0)
                }
            }
        }
        environments = environmentsDecoded0
        let templateVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateVersion)
        templateVersion = templateVersionDecoded
    }
}

extension IoTClientTypes {
    /// An object that contains information about the managed template.
    public struct ManagedJobTemplateSummary: Swift.Equatable {
        /// The description for a managed template.
        public var description: Swift.String?
        /// A list of environments that are supported with the managed job template.
        public var environments: [Swift.String]?
        /// The Amazon Resource Name (ARN) for a managed template.
        public var templateArn: Swift.String?
        /// The unique Name for a managed template.
        public var templateName: Swift.String?
        /// The version for a managed template.
        public var templateVersion: Swift.String?

        public init(
            description: Swift.String? = nil,
            environments: [Swift.String]? = nil,
            templateArn: Swift.String? = nil,
            templateName: Swift.String? = nil,
            templateVersion: Swift.String? = nil
        )
        {
            self.description = description
            self.environments = environments
            self.templateArn = templateArn
            self.templateName = templateName
            self.templateVersion = templateVersion
        }
    }

}

extension IoTClientTypes {
    public enum MessageFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case raw
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageFormat] {
            return [
                .json,
                .raw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .raw: return "RAW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageFormat(rawValue: rawValue) ?? MessageFormat.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.MetricDatum: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MetricValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTClientTypes {
    /// A metric.
    public struct MetricDatum: Swift.Equatable {
        /// The time the metric value was reported.
        public var timestamp: ClientRuntime.Date?
        /// The value reported for the metric.
        public var value: IoTClientTypes.MetricValue?

        public init(
            timestamp: ClientRuntime.Date? = nil,
            value: IoTClientTypes.MetricValue? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTClientTypes.MetricDimension: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionName
        case `operator` = "operator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionName = self.dimensionName {
            try encodeContainer.encode(dimensionName, forKey: .dimensionName)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DimensionValueOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension IoTClientTypes {
    /// The dimension of a metric.
    public struct MetricDimension: Swift.Equatable {
        /// A unique identifier for the dimension.
        /// This member is required.
        public var dimensionName: Swift.String?
        /// Defines how the dimensionValues of a dimension are interpreted. For example, for dimension type TOPIC_FILTER, the IN operator, a message will be counted only if its topic matches one of the topic filters. With NOT_IN operator, a message will be counted only if it doesn't match any of the topic filters. The operator is optional: if it's not provided (is null), it will be interpreted as IN.
        public var `operator`: IoTClientTypes.DimensionValueOperator?

        public init(
            dimensionName: Swift.String? = nil,
            `operator`: IoTClientTypes.DimensionValueOperator? = nil
        )
        {
            self.dimensionName = dimensionName
            self.`operator` = `operator`
        }
    }

}

extension IoTClientTypes.MetricToRetain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metric
        case metricDimension
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let metricDimension = self.metricDimension {
            try encodeContainer.encode(metricDimension, forKey: .metricDimension)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let metricDimensionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MetricDimension.self, forKey: .metricDimension)
        metricDimension = metricDimensionDecoded
    }
}

extension IoTClientTypes {
    /// The metric you want to retain. Dimensions are optional.
    public struct MetricToRetain: Swift.Equatable {
        /// What is measured by the behavior.
        /// This member is required.
        public var metric: Swift.String?
        /// The dimension of a metric. This can't be used with custom metrics.
        public var metricDimension: IoTClientTypes.MetricDimension?

        public init(
            metric: Swift.String? = nil,
            metricDimension: IoTClientTypes.MetricDimension? = nil
        )
        {
            self.metric = metric
            self.metricDimension = metricDimension
        }
    }

}

extension IoTClientTypes.MetricValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrs
        case count
        case number
        case numbers
        case ports
        case strings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrs = cidrs {
            var cidrsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrs)
            for cidr0 in cidrs {
                try cidrsContainer.encode(cidr0)
            }
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let number = self.number {
            try encodeContainer.encode(number, forKey: .number)
        }
        if let numbers = numbers {
            var numbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .numbers)
            for number0 in numbers {
                try numbersContainer.encode(number0)
            }
        }
        if let ports = ports {
            var portsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ports)
            for port0 in ports {
                try portsContainer.encode(port0)
            }
        }
        if let strings = strings {
            var stringsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .strings)
            for stringvalue0 in strings {
                try stringsContainer.encode(stringvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
        let cidrsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrs)
        var cidrsDecoded0:[Swift.String]? = nil
        if let cidrsContainer = cidrsContainer {
            cidrsDecoded0 = [Swift.String]()
            for string0 in cidrsContainer {
                if let string0 = string0 {
                    cidrsDecoded0?.append(string0)
                }
            }
        }
        cidrs = cidrsDecoded0
        let portsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .ports)
        var portsDecoded0:[Swift.Int]? = nil
        if let portsContainer = portsContainer {
            portsDecoded0 = [Swift.Int]()
            for integer0 in portsContainer {
                if let integer0 = integer0 {
                    portsDecoded0?.append(integer0)
                }
            }
        }
        ports = portsDecoded0
        let numberDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .number)
        number = numberDecoded
        let numbersContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .numbers)
        var numbersDecoded0:[Swift.Double]? = nil
        if let numbersContainer = numbersContainer {
            numbersDecoded0 = [Swift.Double]()
            for double0 in numbersContainer {
                if let double0 = double0 {
                    numbersDecoded0?.append(double0)
                }
            }
        }
        numbers = numbersDecoded0
        let stringsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .strings)
        var stringsDecoded0:[Swift.String]? = nil
        if let stringsContainer = stringsContainer {
            stringsDecoded0 = [Swift.String]()
            for string0 in stringsContainer {
                if let string0 = string0 {
                    stringsDecoded0?.append(string0)
                }
            }
        }
        strings = stringsDecoded0
    }
}

extension IoTClientTypes {
    /// The value to be compared with the metric.
    public struct MetricValue: Swift.Equatable {
        /// If the comparisonOperator calls for a set of CIDRs, use this to specify that set to be compared with the metric.
        public var cidrs: [Swift.String]?
        /// If the comparisonOperator calls for a numeric value, use this to specify that numeric value to be compared with the metric.
        public var count: Swift.Int?
        /// The numeral value of a metric.
        public var number: Swift.Double?
        /// The numeral values of a metric.
        public var numbers: [Swift.Double]?
        /// If the comparisonOperator calls for a set of ports, use this to specify that set to be compared with the metric.
        public var ports: [Swift.Int]?
        /// The string values of a metric.
        public var strings: [Swift.String]?

        public init(
            cidrs: [Swift.String]? = nil,
            count: Swift.Int? = nil,
            number: Swift.Double? = nil,
            numbers: [Swift.Double]? = nil,
            ports: [Swift.Int]? = nil,
            strings: [Swift.String]? = nil
        )
        {
            self.cidrs = cidrs
            self.count = count
            self.number = number
            self.numbers = numbers
            self.ports = ports
            self.strings = strings
        }
    }

}

extension IoTClientTypes.MitigationAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionParams
        case id
        case name
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionParams = self.actionParams {
            try encodeContainer.encode(actionParams, forKey: .actionParams)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let actionParamsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MitigationActionParams.self, forKey: .actionParams)
        actionParams = actionParamsDecoded
    }
}

extension IoTClientTypes {
    /// Describes which changes should be applied as part of a mitigation action.
    public struct MitigationAction: Swift.Equatable {
        /// The set of parameters for this mitigation action. The parameters vary, depending on the kind of action you apply.
        public var actionParams: IoTClientTypes.MitigationActionParams?
        /// A unique identifier for the mitigation action.
        public var id: Swift.String?
        /// A user-friendly name for the mitigation action.
        public var name: Swift.String?
        /// The IAM role ARN used to apply this mitigation action.
        public var roleArn: Swift.String?

        public init(
            actionParams: IoTClientTypes.MitigationActionParams? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.actionParams = actionParams
            self.id = id
            self.name = name
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes.MitigationActionIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionArn
        case actionName
        case creationDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionArn = self.actionArn {
            try encodeContainer.encode(actionArn, forKey: .actionArn)
        }
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let actionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionArn)
        actionArn = actionArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension IoTClientTypes {
    /// Information that identifies a mitigation action. This information is returned by ListMitigationActions.
    public struct MitigationActionIdentifier: Swift.Equatable {
        /// The IAM role ARN used to apply this mitigation action.
        public var actionArn: Swift.String?
        /// The friendly name of the mitigation action.
        public var actionName: Swift.String?
        /// The date when this mitigation action was created.
        public var creationDate: ClientRuntime.Date?

        public init(
            actionArn: Swift.String? = nil,
            actionName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil
        )
        {
            self.actionArn = actionArn
            self.actionName = actionName
            self.creationDate = creationDate
        }
    }

}

extension IoTClientTypes.MitigationActionParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addThingsToThingGroupParams
        case enableIoTLoggingParams
        case publishFindingToSnsParams
        case replaceDefaultPolicyVersionParams
        case updateCACertificateParams
        case updateDeviceCertificateParams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addThingsToThingGroupParams = self.addThingsToThingGroupParams {
            try encodeContainer.encode(addThingsToThingGroupParams, forKey: .addThingsToThingGroupParams)
        }
        if let enableIoTLoggingParams = self.enableIoTLoggingParams {
            try encodeContainer.encode(enableIoTLoggingParams, forKey: .enableIoTLoggingParams)
        }
        if let publishFindingToSnsParams = self.publishFindingToSnsParams {
            try encodeContainer.encode(publishFindingToSnsParams, forKey: .publishFindingToSnsParams)
        }
        if let replaceDefaultPolicyVersionParams = self.replaceDefaultPolicyVersionParams {
            try encodeContainer.encode(replaceDefaultPolicyVersionParams, forKey: .replaceDefaultPolicyVersionParams)
        }
        if let updateCACertificateParams = self.updateCACertificateParams {
            try encodeContainer.encode(updateCACertificateParams, forKey: .updateCACertificateParams)
        }
        if let updateDeviceCertificateParams = self.updateDeviceCertificateParams {
            try encodeContainer.encode(updateDeviceCertificateParams, forKey: .updateDeviceCertificateParams)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDeviceCertificateParamsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.UpdateDeviceCertificateParams.self, forKey: .updateDeviceCertificateParams)
        updateDeviceCertificateParams = updateDeviceCertificateParamsDecoded
        let updateCACertificateParamsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.UpdateCACertificateParams.self, forKey: .updateCACertificateParams)
        updateCACertificateParams = updateCACertificateParamsDecoded
        let addThingsToThingGroupParamsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AddThingsToThingGroupParams.self, forKey: .addThingsToThingGroupParams)
        addThingsToThingGroupParams = addThingsToThingGroupParamsDecoded
        let replaceDefaultPolicyVersionParamsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ReplaceDefaultPolicyVersionParams.self, forKey: .replaceDefaultPolicyVersionParams)
        replaceDefaultPolicyVersionParams = replaceDefaultPolicyVersionParamsDecoded
        let enableIoTLoggingParamsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.EnableIoTLoggingParams.self, forKey: .enableIoTLoggingParams)
        enableIoTLoggingParams = enableIoTLoggingParamsDecoded
        let publishFindingToSnsParamsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.PublishFindingToSnsParams.self, forKey: .publishFindingToSnsParams)
        publishFindingToSnsParams = publishFindingToSnsParamsDecoded
    }
}

extension IoTClientTypes {
    /// The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).
    public struct MitigationActionParams: Swift.Equatable {
        /// Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.
        public var addThingsToThingGroupParams: IoTClientTypes.AddThingsToThingGroupParams?
        /// Parameters to define a mitigation action that enables Amazon Web Services IoT Core logging at a specified level of detail.
        public var enableIoTLoggingParams: IoTClientTypes.EnableIoTLoggingParams?
        /// Parameters to define a mitigation action that publishes findings to Amazon Simple Notification Service (Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
        public var publishFindingToSnsParams: IoTClientTypes.PublishFindingToSnsParams?
        /// Parameters to define a mitigation action that adds a blank policy to restrict permissions.
        public var replaceDefaultPolicyVersionParams: IoTClientTypes.ReplaceDefaultPolicyVersionParams?
        /// Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
        public var updateCACertificateParams: IoTClientTypes.UpdateCACertificateParams?
        /// Parameters to define a mitigation action that changes the state of the device certificate to inactive.
        public var updateDeviceCertificateParams: IoTClientTypes.UpdateDeviceCertificateParams?

        public init(
            addThingsToThingGroupParams: IoTClientTypes.AddThingsToThingGroupParams? = nil,
            enableIoTLoggingParams: IoTClientTypes.EnableIoTLoggingParams? = nil,
            publishFindingToSnsParams: IoTClientTypes.PublishFindingToSnsParams? = nil,
            replaceDefaultPolicyVersionParams: IoTClientTypes.ReplaceDefaultPolicyVersionParams? = nil,
            updateCACertificateParams: IoTClientTypes.UpdateCACertificateParams? = nil,
            updateDeviceCertificateParams: IoTClientTypes.UpdateDeviceCertificateParams? = nil
        )
        {
            self.addThingsToThingGroupParams = addThingsToThingGroupParams
            self.enableIoTLoggingParams = enableIoTLoggingParams
            self.publishFindingToSnsParams = publishFindingToSnsParams
            self.replaceDefaultPolicyVersionParams = replaceDefaultPolicyVersionParams
            self.updateCACertificateParams = updateCACertificateParams
            self.updateDeviceCertificateParams = updateDeviceCertificateParams
        }
    }

}

extension IoTClientTypes {
    public enum MitigationActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addThingsToThingGroup
        case enableIotLogging
        case publishFindingToSns
        case replaceDefaultPolicyVersion
        case updateCaCertificate
        case updateDeviceCertificate
        case sdkUnknown(Swift.String)

        public static var allCases: [MitigationActionType] {
            return [
                .addThingsToThingGroup,
                .enableIotLogging,
                .publishFindingToSns,
                .replaceDefaultPolicyVersion,
                .updateCaCertificate,
                .updateDeviceCertificate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addThingsToThingGroup: return "ADD_THINGS_TO_THING_GROUP"
            case .enableIotLogging: return "ENABLE_IOT_LOGGING"
            case .publishFindingToSns: return "PUBLISH_FINDING_TO_SNS"
            case .replaceDefaultPolicyVersion: return "REPLACE_DEFAULT_POLICY_VERSION"
            case .updateCaCertificate: return "UPDATE_CA_CERTIFICATE"
            case .updateDeviceCertificate: return "UPDATE_DEVICE_CERTIFICATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MitigationActionType(rawValue: rawValue) ?? MitigationActionType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum ModelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case expired
        case pendingBuild
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelStatus] {
            return [
                .active,
                .expired,
                .pendingBuild,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .expired: return "EXPIRED"
            case .pendingBuild: return "PENDING_BUILD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelStatus(rawValue: rawValue) ?? ModelStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.MqttContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let password = self.password {
            try encodeContainer.encode(password.base64EncodedString(), forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .password)
        password = passwordDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
    }
}

extension IoTClientTypes {
    /// Specifies the MQTT context to use for the test authorizer request
    public struct MqttContext: Swift.Equatable {
        /// The value of the clientId key in an MQTT authorization request.
        public var clientId: Swift.String?
        /// The value of the password key in an MQTT authorization request.
        public var password: ClientRuntime.Data?
        /// The value of the username key in an MQTT authorization request.
        public var username: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            password: ClientRuntime.Data? = nil,
            username: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.password = password
            self.username = username
        }
    }

}

extension IoTClientTypes.MqttHeaders: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case correlationData
        case messageExpiry
        case payloadFormatIndicator
        case responseTopic
        case userProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let correlationData = self.correlationData {
            try encodeContainer.encode(correlationData, forKey: .correlationData)
        }
        if let messageExpiry = self.messageExpiry {
            try encodeContainer.encode(messageExpiry, forKey: .messageExpiry)
        }
        if let payloadFormatIndicator = self.payloadFormatIndicator {
            try encodeContainer.encode(payloadFormatIndicator, forKey: .payloadFormatIndicator)
        }
        if let responseTopic = self.responseTopic {
            try encodeContainer.encode(responseTopic, forKey: .responseTopic)
        }
        if let userProperties = userProperties {
            var userPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userProperties)
            for userproperty0 in userProperties {
                try userPropertiesContainer.encode(userproperty0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadFormatIndicatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormatIndicator)
        payloadFormatIndicator = payloadFormatIndicatorDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let responseTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseTopic)
        responseTopic = responseTopicDecoded
        let correlationDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .correlationData)
        correlationData = correlationDataDecoded
        let messageExpiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageExpiry)
        messageExpiry = messageExpiryDecoded
        let userPropertiesContainer = try containerValues.decodeIfPresent([IoTClientTypes.UserProperty?].self, forKey: .userProperties)
        var userPropertiesDecoded0:[IoTClientTypes.UserProperty]? = nil
        if let userPropertiesContainer = userPropertiesContainer {
            userPropertiesDecoded0 = [IoTClientTypes.UserProperty]()
            for structure0 in userPropertiesContainer {
                if let structure0 = structure0 {
                    userPropertiesDecoded0?.append(structure0)
                }
            }
        }
        userProperties = userPropertiesDecoded0
    }
}

extension IoTClientTypes {
    /// Specifies MQTT Version 5.0 headers information. For more information, see [ MQTT](https://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html) from Amazon Web Services IoT Core Developer Guide.
    public struct MqttHeaders: Swift.Equatable {
        /// A UTF-8 encoded string that describes the content of the publishing message. For more information, see [ Content Type](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901118) from the MQTT Version 5.0 specification. Supports [substitution templates](https://docs.aws.amazon.com/iot/latest/developerguide/iot-substitution-templates.html).
        public var contentType: Swift.String?
        /// The base64-encoded binary data used by the sender of the request message to identify which request the response message is for when it's received. For more information, see [ Correlation Data](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901115) from the MQTT Version 5.0 specification. This binary data must be based64-encoded. Supports [substitution templates](https://docs.aws.amazon.com/iot/latest/developerguide/iot-substitution-templates.html).
        public var correlationData: Swift.String?
        /// A user-defined integer value that will persist a message at the message broker for a specified amount of time to ensure that the message will expire if it's no longer relevant to the subscriber. The value of messageExpiry represents the number of seconds before it expires. For more information about the limits of messageExpiry, see [Amazon Web Services IoT Core message broker and protocol limits and quotas ](https://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html) from the Amazon Web Services Reference Guide. Supports [substitution templates](https://docs.aws.amazon.com/iot/latest/developerguide/iot-substitution-templates.html).
        public var messageExpiry: Swift.String?
        /// An Enum string value that indicates whether the payload is formatted as UTF-8. Valid values are UNSPECIFIED_BYTES and UTF8_DATA. For more information, see [ Payload Format Indicator](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901111) from the MQTT Version 5.0 specification. Supports [substitution templates](https://docs.aws.amazon.com/iot/latest/developerguide/iot-substitution-templates.html).
        public var payloadFormatIndicator: Swift.String?
        /// A UTF-8 encoded string that's used as the topic name for a response message. The response topic is used to describe the topic which the receiver should publish to as part of the request-response flow. The topic must not contain wildcard characters. For more information, see [ Response Topic](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901114) from the MQTT Version 5.0 specification. Supports [substitution templates](https://docs.aws.amazon.com/iot/latest/developerguide/iot-substitution-templates.html).
        public var responseTopic: Swift.String?
        /// An array of key-value pairs that you define in the MQTT5 header.
        public var userProperties: [IoTClientTypes.UserProperty]?

        public init(
            contentType: Swift.String? = nil,
            correlationData: Swift.String? = nil,
            messageExpiry: Swift.String? = nil,
            payloadFormatIndicator: Swift.String? = nil,
            responseTopic: Swift.String? = nil,
            userProperties: [IoTClientTypes.UserProperty]? = nil
        )
        {
            self.contentType = contentType
            self.correlationData = correlationData
            self.messageExpiry = messageExpiry
            self.payloadFormatIndicator = payloadFormatIndicator
            self.responseTopic = responseTopic
            self.userProperties = userProperties
        }
    }

}

extension IoTClientTypes {
    public enum NamedShadowIndexingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [NamedShadowIndexingMode] {
            return [
                .off,
                .on,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .on: return "ON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NamedShadowIndexingMode(rawValue: rawValue) ?? NamedShadowIndexingMode.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.NonCompliantResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case resourceIdentifier
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            var additionalInfoContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalInfo)
            for (dictKey0, stringMap0) in additionalInfo {
                try additionalInfoContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let additionalInfoContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalInfo)
        var additionalInfoDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalInfoContainer = additionalInfoContainer {
            additionalInfoDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in additionalInfoContainer {
                if let string0 = string0 {
                    additionalInfoDecoded0?[key0] = string0
                }
            }
        }
        additionalInfo = additionalInfoDecoded0
    }
}

extension IoTClientTypes {
    /// Information about the resource that was noncompliant with the audit check.
    public struct NonCompliantResource: Swift.Equatable {
        /// Other information about the noncompliant resource.
        public var additionalInfo: [Swift.String:Swift.String]?
        /// Information that identifies the noncompliant resource.
        public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
        /// The type of the noncompliant resource.
        public var resourceType: IoTClientTypes.ResourceType?

        public init(
            additionalInfo: [Swift.String:Swift.String]? = nil,
            resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
            resourceType: IoTClientTypes.ResourceType? = nil
        )
        {
            self.additionalInfo = additionalInfo
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }
    }

}

extension NotConfiguredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotConfiguredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource is not configured.
public struct NotConfiguredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotConfiguredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotConfiguredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotConfiguredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes.OTAUpdateFile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case codeSigning
        case fileLocation
        case fileName
        case fileType
        case fileVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributesMap0) in attributes {
                try attributesContainer.encode(attributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let codeSigning = self.codeSigning {
            try encodeContainer.encode(codeSigning, forKey: .codeSigning)
        }
        if let fileLocation = self.fileLocation {
            try encodeContainer.encode(fileLocation, forKey: .fileLocation)
        }
        if let fileName = self.fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
        if let fileType = self.fileType {
            try encodeContainer.encode(fileType, forKey: .fileType)
        }
        if let fileVersion = self.fileVersion {
            try encodeContainer.encode(fileVersion, forKey: .fileVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
        let fileTypeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let fileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileVersion)
        fileVersion = fileVersionDecoded
        let fileLocationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.FileLocation.self, forKey: .fileLocation)
        fileLocation = fileLocationDecoded
        let codeSigningDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CodeSigning.self, forKey: .codeSigning)
        codeSigning = codeSigningDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in attributesContainer {
                if let value0 = value0 {
                    attributesDecoded0?[key0] = value0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension IoTClientTypes {
    /// Describes a file to be associated with an OTA update.
    public struct OTAUpdateFile: Swift.Equatable {
        /// A list of name-attribute pairs. They won't be sent to devices as a part of the Job document.
        public var attributes: [Swift.String:Swift.String]?
        /// The code signing method of the file.
        public var codeSigning: IoTClientTypes.CodeSigning?
        /// The location of the updated firmware.
        public var fileLocation: IoTClientTypes.FileLocation?
        /// The name of the file.
        public var fileName: Swift.String?
        /// An integer value you can include in the job document to allow your devices to identify the type of file received from the cloud.
        public var fileType: Swift.Int?
        /// The file version.
        public var fileVersion: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            codeSigning: IoTClientTypes.CodeSigning? = nil,
            fileLocation: IoTClientTypes.FileLocation? = nil,
            fileName: Swift.String? = nil,
            fileType: Swift.Int? = nil,
            fileVersion: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.codeSigning = codeSigning
            self.fileLocation = fileLocation
            self.fileName = fileName
            self.fileType = fileType
            self.fileVersion = fileVersion
        }
    }

}

extension IoTClientTypes.OTAUpdateInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalParameters
        case awsIotJobArn
        case awsIotJobId
        case awsJobExecutionsRolloutConfig
        case awsJobPresignedUrlConfig
        case creationDate
        case description
        case errorInfo
        case lastModifiedDate
        case otaUpdateArn
        case otaUpdateFiles
        case otaUpdateId
        case otaUpdateStatus
        case protocols
        case targetSelection
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalParameters = additionalParameters {
            var additionalParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalParameters)
            for (dictKey0, additionalParameterMap0) in additionalParameters {
                try additionalParametersContainer.encode(additionalParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let awsIotJobArn = self.awsIotJobArn {
            try encodeContainer.encode(awsIotJobArn, forKey: .awsIotJobArn)
        }
        if let awsIotJobId = self.awsIotJobId {
            try encodeContainer.encode(awsIotJobId, forKey: .awsIotJobId)
        }
        if let awsJobExecutionsRolloutConfig = self.awsJobExecutionsRolloutConfig {
            try encodeContainer.encode(awsJobExecutionsRolloutConfig, forKey: .awsJobExecutionsRolloutConfig)
        }
        if let awsJobPresignedUrlConfig = self.awsJobPresignedUrlConfig {
            try encodeContainer.encode(awsJobPresignedUrlConfig, forKey: .awsJobPresignedUrlConfig)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let otaUpdateArn = self.otaUpdateArn {
            try encodeContainer.encode(otaUpdateArn, forKey: .otaUpdateArn)
        }
        if let otaUpdateFiles = otaUpdateFiles {
            var otaUpdateFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .otaUpdateFiles)
            for otaupdatefile0 in otaUpdateFiles {
                try otaUpdateFilesContainer.encode(otaupdatefile0)
            }
        }
        if let otaUpdateId = self.otaUpdateId {
            try encodeContainer.encode(otaUpdateId, forKey: .otaUpdateId)
        }
        if let otaUpdateStatus = self.otaUpdateStatus {
            try encodeContainer.encode(otaUpdateStatus.rawValue, forKey: .otaUpdateStatus)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocol0 in protocols {
                try protocolsContainer.encode(protocol0.rawValue)
            }
        }
        if let targetSelection = self.targetSelection {
            try encodeContainer.encode(targetSelection.rawValue, forKey: .targetSelection)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for target0 in targets {
                try targetsContainer.encode(target0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otaUpdateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .otaUpdateId)
        otaUpdateId = otaUpdateIdDecoded
        let otaUpdateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .otaUpdateArn)
        otaUpdateArn = otaUpdateArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let protocolsContainer = try containerValues.decodeIfPresent([IoTClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[IoTClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [IoTClientTypes.ModelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
        let awsJobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AwsJobExecutionsRolloutConfig.self, forKey: .awsJobExecutionsRolloutConfig)
        awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfigDecoded
        let awsJobPresignedUrlConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AwsJobPresignedUrlConfig.self, forKey: .awsJobPresignedUrlConfig)
        awsJobPresignedUrlConfig = awsJobPresignedUrlConfigDecoded
        let targetSelectionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TargetSelection.self, forKey: .targetSelection)
        targetSelection = targetSelectionDecoded
        let otaUpdateFilesContainer = try containerValues.decodeIfPresent([IoTClientTypes.OTAUpdateFile?].self, forKey: .otaUpdateFiles)
        var otaUpdateFilesDecoded0:[IoTClientTypes.OTAUpdateFile]? = nil
        if let otaUpdateFilesContainer = otaUpdateFilesContainer {
            otaUpdateFilesDecoded0 = [IoTClientTypes.OTAUpdateFile]()
            for structure0 in otaUpdateFilesContainer {
                if let structure0 = structure0 {
                    otaUpdateFilesDecoded0?.append(structure0)
                }
            }
        }
        otaUpdateFiles = otaUpdateFilesDecoded0
        let otaUpdateStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.OTAUpdateStatus.self, forKey: .otaUpdateStatus)
        otaUpdateStatus = otaUpdateStatusDecoded
        let awsIotJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsIotJobId)
        awsIotJobId = awsIotJobIdDecoded
        let awsIotJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsIotJobArn)
        awsIotJobArn = awsIotJobArnDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let additionalParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalParameters)
        var additionalParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalParametersContainer = additionalParametersContainer {
            additionalParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in additionalParametersContainer {
                if let value0 = value0 {
                    additionalParametersDecoded0?[key0] = value0
                }
            }
        }
        additionalParameters = additionalParametersDecoded0
    }
}

extension IoTClientTypes {
    /// Information about an OTA update.
    public struct OTAUpdateInfo: Swift.Equatable {
        /// A collection of name/value pairs
        public var additionalParameters: [Swift.String:Swift.String]?
        /// The IoT job ARN associated with the OTA update.
        public var awsIotJobArn: Swift.String?
        /// The IoT job ID associated with the OTA update.
        public var awsIotJobId: Swift.String?
        /// Configuration for the rollout of OTA updates.
        public var awsJobExecutionsRolloutConfig: IoTClientTypes.AwsJobExecutionsRolloutConfig?
        /// Configuration information for pre-signed URLs. Valid when protocols contains HTTP.
        public var awsJobPresignedUrlConfig: IoTClientTypes.AwsJobPresignedUrlConfig?
        /// The date when the OTA update was created.
        public var creationDate: ClientRuntime.Date?
        /// A description of the OTA update.
        public var description: Swift.String?
        /// Error information associated with the OTA update.
        public var errorInfo: IoTClientTypes.ErrorInfo?
        /// The date when the OTA update was last updated.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The OTA update ARN.
        public var otaUpdateArn: Swift.String?
        /// A list of files associated with the OTA update.
        public var otaUpdateFiles: [IoTClientTypes.OTAUpdateFile]?
        /// The OTA update ID.
        public var otaUpdateId: Swift.String?
        /// The status of the OTA update.
        public var otaUpdateStatus: IoTClientTypes.OTAUpdateStatus?
        /// The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP, MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol.
        public var protocols: [IoTClientTypes.ModelProtocol]?
        /// Specifies whether the OTA update will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the OTA update (SNAPSHOT). If continuous, the OTA update may also be run on a thing when a change is detected in a target. For example, an OTA update will run on a thing when the thing is added to a target group, even after the OTA update was completed by all things originally in the group.
        public var targetSelection: IoTClientTypes.TargetSelection?
        /// The targets of the OTA update.
        public var targets: [Swift.String]?

        public init(
            additionalParameters: [Swift.String:Swift.String]? = nil,
            awsIotJobArn: Swift.String? = nil,
            awsIotJobId: Swift.String? = nil,
            awsJobExecutionsRolloutConfig: IoTClientTypes.AwsJobExecutionsRolloutConfig? = nil,
            awsJobPresignedUrlConfig: IoTClientTypes.AwsJobPresignedUrlConfig? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            errorInfo: IoTClientTypes.ErrorInfo? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            otaUpdateArn: Swift.String? = nil,
            otaUpdateFiles: [IoTClientTypes.OTAUpdateFile]? = nil,
            otaUpdateId: Swift.String? = nil,
            otaUpdateStatus: IoTClientTypes.OTAUpdateStatus? = nil,
            protocols: [IoTClientTypes.ModelProtocol]? = nil,
            targetSelection: IoTClientTypes.TargetSelection? = nil,
            targets: [Swift.String]? = nil
        )
        {
            self.additionalParameters = additionalParameters
            self.awsIotJobArn = awsIotJobArn
            self.awsIotJobId = awsIotJobId
            self.awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfig
            self.awsJobPresignedUrlConfig = awsJobPresignedUrlConfig
            self.creationDate = creationDate
            self.description = description
            self.errorInfo = errorInfo
            self.lastModifiedDate = lastModifiedDate
            self.otaUpdateArn = otaUpdateArn
            self.otaUpdateFiles = otaUpdateFiles
            self.otaUpdateId = otaUpdateId
            self.otaUpdateStatus = otaUpdateStatus
            self.protocols = protocols
            self.targetSelection = targetSelection
            self.targets = targets
        }
    }

}

extension IoTClientTypes {
    public enum OTAUpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createComplete
        case createFailed
        case createInProgress
        case createPending
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [OTAUpdateStatus] {
            return [
                .createComplete,
                .createFailed,
                .createInProgress,
                .createPending,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createPending: return "CREATE_PENDING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OTAUpdateStatus(rawValue: rawValue) ?? OTAUpdateStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.OTAUpdateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case otaUpdateArn
        case otaUpdateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let otaUpdateArn = self.otaUpdateArn {
            try encodeContainer.encode(otaUpdateArn, forKey: .otaUpdateArn)
        }
        if let otaUpdateId = self.otaUpdateId {
            try encodeContainer.encode(otaUpdateId, forKey: .otaUpdateId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otaUpdateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .otaUpdateId)
        otaUpdateId = otaUpdateIdDecoded
        let otaUpdateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .otaUpdateArn)
        otaUpdateArn = otaUpdateArnDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension IoTClientTypes {
    /// An OTA update summary.
    public struct OTAUpdateSummary: Swift.Equatable {
        /// The date when the OTA update was created.
        public var creationDate: ClientRuntime.Date?
        /// The OTA update ARN.
        public var otaUpdateArn: Swift.String?
        /// The OTA update ID.
        public var otaUpdateId: Swift.String?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            otaUpdateArn: Swift.String? = nil,
            otaUpdateId: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.otaUpdateArn = otaUpdateArn
            self.otaUpdateId = otaUpdateId
        }
    }

}

extension IoTClientTypes.OpenSearchAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
        case id
        case index
        case roleArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let index = self.index {
            try encodeContainer.encode(index, forKey: .index)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let indexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .index)
        index = indexDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action that writes data to an Amazon OpenSearch Service domain.
    public struct OpenSearchAction: Swift.Equatable {
        /// The endpoint of your OpenSearch domain.
        /// This member is required.
        public var endpoint: Swift.String?
        /// The unique identifier for the document you are storing.
        /// This member is required.
        public var id: Swift.String?
        /// The OpenSearch index where you want to store your data.
        /// This member is required.
        public var index: Swift.String?
        /// The IAM role ARN that has access to OpenSearch.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The type of document you are storing.
        /// This member is required.
        public var type: Swift.String?

        public init(
            endpoint: Swift.String? = nil,
            id: Swift.String? = nil,
            index: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.id = id
            self.index = index
            self.roleArn = roleArn
            self.type = type
        }
    }

}

extension IoTClientTypes.OutgoingCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateId
        case creationDate
        case transferDate
        case transferMessage
        case transferredTo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateId = self.certificateId {
            try encodeContainer.encode(certificateId, forKey: .certificateId)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let transferDate = self.transferDate {
            try encodeContainer.encodeTimestamp(transferDate, format: .epochSeconds, forKey: .transferDate)
        }
        if let transferMessage = self.transferMessage {
            try encodeContainer.encode(transferMessage, forKey: .transferMessage)
        }
        if let transferredTo = self.transferredTo {
            try encodeContainer.encode(transferredTo, forKey: .transferredTo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
        let transferredToDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transferredTo)
        transferredTo = transferredToDecoded
        let transferDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .transferDate)
        transferDate = transferDateDecoded
        let transferMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transferMessage)
        transferMessage = transferMessageDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension IoTClientTypes {
    /// A certificate that has been transferred but not yet accepted.
    public struct OutgoingCertificate: Swift.Equatable {
        /// The certificate ARN.
        public var certificateArn: Swift.String?
        /// The certificate ID.
        public var certificateId: Swift.String?
        /// The certificate creation date.
        public var creationDate: ClientRuntime.Date?
        /// The date the transfer was initiated.
        public var transferDate: ClientRuntime.Date?
        /// The transfer message.
        public var transferMessage: Swift.String?
        /// The Amazon Web Services account to which the transfer was made.
        public var transferredTo: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            certificateId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            transferDate: ClientRuntime.Date? = nil,
            transferMessage: Swift.String? = nil,
            transferredTo: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateId = certificateId
            self.creationDate = creationDate
            self.transferDate = transferDate
            self.transferMessage = transferMessage
            self.transferredTo = transferredTo
        }
    }

}

extension IoTClientTypes.PackageSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case defaultVersionName
        case lastModifiedDate
        case packageName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let defaultVersionName = self.defaultVersionName {
            try encodeContainer.encode(defaultVersionName, forKey: .defaultVersionName)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let defaultVersionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersionName)
        defaultVersionName = defaultVersionNameDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension IoTClientTypes {
    /// A summary of information about a software package.
    public struct PackageSummary: Swift.Equatable {
        /// The date that the package was created.
        public var creationDate: ClientRuntime.Date?
        /// The name of the default package version.
        public var defaultVersionName: Swift.String?
        /// The date that the package was last updated.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The name for the target software package.
        public var packageName: Swift.String?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            defaultVersionName: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            packageName: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.defaultVersionName = defaultVersionName
            self.lastModifiedDate = lastModifiedDate
            self.packageName = packageName
        }
    }

}

extension IoTClientTypes {
    public enum PackageVersionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deprecate
        case publish
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionAction] {
            return [
                .deprecate,
                .publish,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deprecate: return "DEPRECATE"
            case .publish: return "PUBLISH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionAction(rawValue: rawValue) ?? PackageVersionAction.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes {
    public enum PackageVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deprecated
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionStatus] {
            return [
                .deprecated,
                .draft,
                .published,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deprecated: return "DEPRECATED"
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionStatus(rawValue: rawValue) ?? PackageVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.PackageVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case lastModifiedDate
        case packageName
        case status
        case versionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let versionName = self.versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension IoTClientTypes {
    /// A summary of information about a package version.
    public struct PackageVersionSummary: Swift.Equatable {
        /// The date that the package version was created.
        public var creationDate: ClientRuntime.Date?
        /// The date that the package version was last updated.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The name of the associated software package.
        public var packageName: Swift.String?
        /// The status of the package version. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle).
        public var status: IoTClientTypes.PackageVersionStatus?
        /// The name of the target package version.
        public var versionName: Swift.String?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            packageName: Swift.String? = nil,
            status: IoTClientTypes.PackageVersionStatus? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.packageName = packageName
            self.status = status
            self.versionName = versionName
        }
    }

}

extension IoTClientTypes.PercentPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percent
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if percent != 0.0 {
            try encodeContainer.encode(percent, forKey: .percent)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percent) ?? 0.0
        percent = percentDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value) ?? 0.0
        value = valueDecoded
    }
}

extension IoTClientTypes {
    /// Describes the percentile and percentile value.
    public struct PercentPair: Swift.Equatable {
        /// The percentile.
        public var percent: Swift.Double
        /// The value of the percentile.
        public var value: Swift.Double

        public init(
            percent: Swift.Double = 0.0,
            value: Swift.Double = 0.0
        )
        {
            self.percent = percent
            self.value = value
        }
    }

}

extension IoTClientTypes.Policy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn
        case policyName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension IoTClientTypes {
    /// Describes an IoT policy.
    public struct Policy: Swift.Equatable {
        /// The policy ARN.
        public var policyArn: Swift.String?
        /// The policy name.
        public var policyName: Swift.String?

        public init(
            policyArn: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyArn = policyArn
            self.policyName = policyName
        }
    }

}

extension IoTClientTypes {
    public enum PolicyTemplateName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case blankPolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyTemplateName] {
            return [
                .blankPolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .blankPolicy: return "BLANK_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyTemplateName(rawValue: rawValue) ?? PolicyTemplateName.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.PolicyVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate
        case isDefaultVersion
        case versionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDate = self.createDate {
            try encodeContainer.encodeTimestamp(createDate, format: .epochSeconds, forKey: .createDate)
        }
        if isDefaultVersion != false {
            try encodeContainer.encode(isDefaultVersion, forKey: .isDefaultVersion)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefaultVersion) ?? false
        isDefaultVersion = isDefaultVersionDecoded
        let createDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension IoTClientTypes {
    /// Describes a policy version.
    public struct PolicyVersion: Swift.Equatable {
        /// The date and time the policy was created.
        public var createDate: ClientRuntime.Date?
        /// Specifies whether the policy version is the default.
        public var isDefaultVersion: Swift.Bool
        /// The policy version ID.
        public var versionId: Swift.String?

        public init(
            createDate: ClientRuntime.Date? = nil,
            isDefaultVersion: Swift.Bool = false,
            versionId: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.isDefaultVersion = isDefaultVersion
            self.versionId = versionId
        }
    }

}

extension IoTClientTypes.PolicyVersionIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName
        case policyVersionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyVersionId = self.policyVersionId {
            try encodeContainer.encode(policyVersionId, forKey: .policyVersionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyVersionId)
        policyVersionId = policyVersionIdDecoded
    }
}

extension IoTClientTypes {
    /// Information about the version of the policy associated with the resource.
    public struct PolicyVersionIdentifier: Swift.Equatable {
        /// The name of the policy.
        public var policyName: Swift.String?
        /// The ID of the version of the policy associated with the resource.
        public var policyVersionId: Swift.String?

        public init(
            policyName: Swift.String? = nil,
            policyVersionId: Swift.String? = nil
        )
        {
            self.policyName = policyName
            self.policyVersionId = policyVersionId
        }
    }

}

extension IoTClientTypes.PresignedUrlConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresInSec
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiresInSec = self.expiresInSec {
            try encodeContainer.encode(expiresInSec, forKey: .expiresInSec)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let expiresInSecDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresInSec)
        expiresInSec = expiresInSecDecoded
    }
}

extension IoTClientTypes {
    /// Configuration for pre-signed S3 URLs.
    public struct PresignedUrlConfig: Swift.Equatable {
        /// How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 3600 seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.
        public var expiresInSec: Swift.Int?
        /// The ARN of an IAM role that grants permission to download files from the S3 bucket where the job data/updates are stored. The role must also grant permission for IoT to download the files. For information about addressing the confused deputy problem, see [cross-service confused deputy prevention](https://docs.aws.amazon.com/iot/latest/developerguide/cross-service-confused-deputy-prevention.html) in the Amazon Web Services IoT Core developer guide.
        public var roleArn: Swift.String?

        public init(
            expiresInSec: Swift.Int? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.expiresInSec = expiresInSec
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case mqtt
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .http,
                .mqtt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .mqtt: return "MQTT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.ProvisioningHook: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloadVersion
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payloadVersion = self.payloadVersion {
            try encodeContainer.encode(payloadVersion, forKey: .payloadVersion)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadVersion)
        payloadVersion = payloadVersionDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
    }
}

extension IoTClientTypes {
    /// Structure that contains payloadVersion and targetArn.
    public struct ProvisioningHook: Swift.Equatable {
        /// The payload that was sent to the target function. Note: Only Lambda functions are currently supported.
        public var payloadVersion: Swift.String?
        /// The ARN of the target function. Note: Only Lambda functions are currently supported.
        /// This member is required.
        public var targetArn: Swift.String?

        public init(
            payloadVersion: Swift.String? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.payloadVersion = payloadVersion
            self.targetArn = targetArn
        }
    }

}

extension IoTClientTypes.ProvisioningTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case description
        case enabled
        case lastModifiedDate
        case templateArn
        case templateName
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let templateArn = self.templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TemplateType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTClientTypes {
    /// A summary of information about a provisioning template.
    public struct ProvisioningTemplateSummary: Swift.Equatable {
        /// The date when the provisioning template summary was created.
        public var creationDate: ClientRuntime.Date?
        /// The description of the provisioning template.
        public var description: Swift.String?
        /// True if the fleet provision template is enabled, otherwise false.
        public var enabled: Swift.Bool
        /// The date when the provisioning template summary was last modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The ARN of the provisioning template.
        public var templateArn: Swift.String?
        /// The name of the provisioning template.
        public var templateName: Swift.String?
        /// The type you define in a provisioning template. You can create a template with only one type. You can't change the template type after its creation. The default value is FLEET_PROVISIONING. For more information about provisioning template, see: [Provisioning template](https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html).
        public var type: IoTClientTypes.TemplateType?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            enabled: Swift.Bool = false,
            lastModifiedDate: ClientRuntime.Date? = nil,
            templateArn: Swift.String? = nil,
            templateName: Swift.String? = nil,
            type: IoTClientTypes.TemplateType? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.enabled = enabled
            self.lastModifiedDate = lastModifiedDate
            self.templateArn = templateArn
            self.templateName = templateName
            self.type = type
        }
    }

}

extension IoTClientTypes.ProvisioningTemplateVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case isDefaultVersion
        case versionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if isDefaultVersion != false {
            try encodeContainer.encode(isDefaultVersion, forKey: .isDefaultVersion)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .versionId)
        versionId = versionIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let isDefaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefaultVersion) ?? false
        isDefaultVersion = isDefaultVersionDecoded
    }
}

extension IoTClientTypes {
    /// A summary of information about a fleet provision template version.
    public struct ProvisioningTemplateVersionSummary: Swift.Equatable {
        /// The date when the provisioning template version was created
        public var creationDate: ClientRuntime.Date?
        /// True if the provisioning template version is the default version, otherwise false.
        public var isDefaultVersion: Swift.Bool
        /// The ID of the fleet provisioning template version.
        public var versionId: Swift.Int?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            isDefaultVersion: Swift.Bool = false,
            versionId: Swift.Int? = nil
        )
        {
            self.creationDate = creationDate
            self.isDefaultVersion = isDefaultVersion
            self.versionId = versionId
        }
    }

}

extension IoTClientTypes.PublishFindingToSnsParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = self.topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension IoTClientTypes {
    /// Parameters to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
    public struct PublishFindingToSnsParams: Swift.Equatable {
        /// The ARN of the topic to which you want to publish the findings.
        /// This member is required.
        public var topicArn: Swift.String?

        public init(
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension IoTClientTypes.PutAssetPropertyValueEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case entryId
        case propertyAlias
        case propertyId
        case propertyValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = self.propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let propertyValues = propertyValues {
            var propertyValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyValues)
            for assetpropertyvalue0 in propertyValues {
                try propertyValuesContainer.encode(assetpropertyvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let propertyValuesContainer = try containerValues.decodeIfPresent([IoTClientTypes.AssetPropertyValue?].self, forKey: .propertyValues)
        var propertyValuesDecoded0:[IoTClientTypes.AssetPropertyValue]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [IoTClientTypes.AssetPropertyValue]()
            for structure0 in propertyValuesContainer {
                if let structure0 = structure0 {
                    propertyValuesDecoded0?.append(structure0)
                }
            }
        }
        propertyValues = propertyValuesDecoded0
    }
}

extension IoTClientTypes {
    /// An asset property value entry containing the following information.
    public struct PutAssetPropertyValueEntry: Swift.Equatable {
        /// The ID of the IoT SiteWise asset. You must specify either a propertyAlias or both an aliasId and a propertyId. Accepts substitution templates.
        public var assetId: Swift.String?
        /// Optional. A unique identifier for this entry that you can define to better track which message caused an error in case of failure. Accepts substitution templates. Defaults to a new UUID.
        public var entryId: Swift.String?
        /// The name of the property alias associated with your asset property. You must specify either a propertyAlias or both an aliasId and a propertyId. Accepts substitution templates.
        public var propertyAlias: Swift.String?
        /// The ID of the asset's property. You must specify either a propertyAlias or both an aliasId and a propertyId. Accepts substitution templates.
        public var propertyId: Swift.String?
        /// A list of property values to insert that each contain timestamp, quality, and value (TQV) information.
        /// This member is required.
        public var propertyValues: [IoTClientTypes.AssetPropertyValue]?

        public init(
            assetId: Swift.String? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            propertyValues: [IoTClientTypes.AssetPropertyValue]? = nil
        )
        {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValues = propertyValues
        }
    }

}

extension IoTClientTypes.PutItemInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension IoTClientTypes {
    /// The input for the DynamoActionVS action that specifies the DynamoDB table to which the message data will be written.
    public struct PutItemInput: Swift.Equatable {
        /// The table where the message data will be written.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            tableName: Swift.String? = nil
        )
        {
            self.tableName = tableName
        }
    }

}

extension PutVerificationStateOnViolationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case verificationState
        case verificationStateDescription
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let verificationState = self.verificationState {
            try encodeContainer.encode(verificationState.rawValue, forKey: .verificationState)
        }
        if let verificationStateDescription = self.verificationStateDescription {
            try encodeContainer.encode(verificationStateDescription, forKey: .verificationStateDescription)
        }
    }
}

extension PutVerificationStateOnViolationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let violationId = violationId else {
            return nil
        }
        return "/violations/verification-state/\(violationId.urlPercentEncoding())"
    }
}

public struct PutVerificationStateOnViolationInput: Swift.Equatable {
    /// The verification state of the violation.
    /// This member is required.
    public var verificationState: IoTClientTypes.VerificationState?
    /// The description of the verification state of the violation (detect alarm).
    public var verificationStateDescription: Swift.String?
    /// The violation ID.
    /// This member is required.
    public var violationId: Swift.String?

    public init(
        verificationState: IoTClientTypes.VerificationState? = nil,
        verificationStateDescription: Swift.String? = nil,
        violationId: Swift.String? = nil
    )
    {
        self.verificationState = verificationState
        self.verificationStateDescription = verificationStateDescription
        self.violationId = violationId
    }
}

struct PutVerificationStateOnViolationInputBody: Swift.Equatable {
    let verificationState: IoTClientTypes.VerificationState?
    let verificationStateDescription: Swift.String?
}

extension PutVerificationStateOnViolationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case verificationState
        case verificationStateDescription
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verificationStateDecoded = try containerValues.decodeIfPresent(IoTClientTypes.VerificationState.self, forKey: .verificationState)
        verificationState = verificationStateDecoded
        let verificationStateDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationStateDescription)
        verificationStateDescription = verificationStateDescriptionDecoded
    }
}

extension PutVerificationStateOnViolationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutVerificationStateOnViolationOutput: Swift.Equatable {

    public init() { }
}

enum PutVerificationStateOnViolationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.RateIncreaseCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfNotifiedThings
        case numberOfSucceededThings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfNotifiedThings = self.numberOfNotifiedThings {
            try encodeContainer.encode(numberOfNotifiedThings, forKey: .numberOfNotifiedThings)
        }
        if let numberOfSucceededThings = self.numberOfSucceededThings {
            try encodeContainer.encode(numberOfSucceededThings, forKey: .numberOfSucceededThings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfNotifiedThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfNotifiedThings)
        numberOfNotifiedThings = numberOfNotifiedThingsDecoded
        let numberOfSucceededThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfSucceededThings)
        numberOfSucceededThings = numberOfSucceededThingsDecoded
    }
}

extension IoTClientTypes {
    /// Allows you to define a criteria to initiate the increase in rate of rollout for a job.
    public struct RateIncreaseCriteria: Swift.Equatable {
        /// The threshold for number of notified things that will initiate the increase in rate of rollout.
        public var numberOfNotifiedThings: Swift.Int?
        /// The threshold for number of succeeded things that will initiate the increase in rate of rollout.
        public var numberOfSucceededThings: Swift.Int?

        public init(
            numberOfNotifiedThings: Swift.Int? = nil,
            numberOfSucceededThings: Swift.Int? = nil
        )
        {
            self.numberOfNotifiedThings = numberOfNotifiedThings
            self.numberOfSucceededThings = numberOfSucceededThings
        }
    }

}

extension RegisterCACertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caCertificate
        case certificateMode
        case registrationConfig
        case tags
        case verificationCertificate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caCertificate = self.caCertificate {
            try encodeContainer.encode(caCertificate, forKey: .caCertificate)
        }
        if let certificateMode = self.certificateMode {
            try encodeContainer.encode(certificateMode.rawValue, forKey: .certificateMode)
        }
        if let registrationConfig = self.registrationConfig {
            try encodeContainer.encode(registrationConfig, forKey: .registrationConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let verificationCertificate = self.verificationCertificate {
            try encodeContainer.encode(verificationCertificate, forKey: .verificationCertificate)
        }
    }
}

extension RegisterCACertificateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let allowAutoRegistration = allowAutoRegistration {
                let allowAutoRegistrationQueryItem = ClientRuntime.URLQueryItem(name: "allowAutoRegistration".urlPercentEncoding(), value: Swift.String(allowAutoRegistration).urlPercentEncoding())
                items.append(allowAutoRegistrationQueryItem)
            }
            if let setAsActive = setAsActive {
                let setAsActiveQueryItem = ClientRuntime.URLQueryItem(name: "setAsActive".urlPercentEncoding(), value: Swift.String(setAsActive).urlPercentEncoding())
                items.append(setAsActiveQueryItem)
            }
            return items
        }
    }
}

extension RegisterCACertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cacertificate"
    }
}

/// The input to the RegisterCACertificate operation.
public struct RegisterCACertificateInput: Swift.Equatable {
    /// Allows this CA certificate to be used for auto registration of device certificates.
    public var allowAutoRegistration: Swift.Bool?
    /// The CA certificate.
    /// This member is required.
    public var caCertificate: Swift.String?
    /// Describes the certificate mode in which the Certificate Authority (CA) will be registered. If the verificationCertificate field is not provided, set certificateMode to be SNI_ONLY. If the verificationCertificate field is provided, set certificateMode to be DEFAULT. When certificateMode is not provided, it defaults to DEFAULT. All the device certificates that are registered using this CA will be registered in the same certificate mode as the CA. For more information about certificate mode for device certificates, see [ certificate mode](https://docs.aws.amazon.com/iot/latest/apireference/API_CertificateDescription.html#iot-Type-CertificateDescription-certificateMode).
    public var certificateMode: IoTClientTypes.CertificateMode?
    /// Information about the registration configuration.
    public var registrationConfig: IoTClientTypes.RegistrationConfig?
    /// A boolean value that specifies if the CA certificate is set to active. Valid values: ACTIVE | INACTIVE
    public var setAsActive: Swift.Bool?
    /// Metadata which can be used to manage the CA certificate. For URI Request parameters use format: ...key1=value1&key2=value2... For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..." For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
    public var tags: [IoTClientTypes.Tag]?
    /// The private key verification certificate. If certificateMode is SNI_ONLY, the verificationCertificate field must be empty. If certificateMode is DEFAULT or not provided, the verificationCertificate field must not be empty.
    public var verificationCertificate: Swift.String?

    public init(
        allowAutoRegistration: Swift.Bool? = nil,
        caCertificate: Swift.String? = nil,
        certificateMode: IoTClientTypes.CertificateMode? = nil,
        registrationConfig: IoTClientTypes.RegistrationConfig? = nil,
        setAsActive: Swift.Bool? = nil,
        tags: [IoTClientTypes.Tag]? = nil,
        verificationCertificate: Swift.String? = nil
    )
    {
        self.allowAutoRegistration = allowAutoRegistration
        self.caCertificate = caCertificate
        self.certificateMode = certificateMode
        self.registrationConfig = registrationConfig
        self.setAsActive = setAsActive
        self.tags = tags
        self.verificationCertificate = verificationCertificate
    }
}

struct RegisterCACertificateInputBody: Swift.Equatable {
    let caCertificate: Swift.String?
    let verificationCertificate: Swift.String?
    let registrationConfig: IoTClientTypes.RegistrationConfig?
    let tags: [IoTClientTypes.Tag]?
    let certificateMode: IoTClientTypes.CertificateMode?
}

extension RegisterCACertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caCertificate
        case certificateMode
        case registrationConfig
        case tags
        case verificationCertificate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caCertificate)
        caCertificate = caCertificateDecoded
        let verificationCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationCertificate)
        verificationCertificate = verificationCertificateDecoded
        let registrationConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let certificateModeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CertificateMode.self, forKey: .certificateMode)
        certificateMode = certificateModeDecoded
    }
}

extension RegisterCACertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterCACertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateArn = output.certificateArn
            self.certificateId = output.certificateId
        } else {
            self.certificateArn = nil
            self.certificateId = nil
        }
    }
}

/// The output from the RegisterCACertificateResponse operation.
public struct RegisterCACertificateOutput: Swift.Equatable {
    /// The CA certificate ARN.
    public var certificateArn: Swift.String?
    /// The CA certificate identifier.
    public var certificateId: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        certificateId: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
    }
}

struct RegisterCACertificateOutputBody: Swift.Equatable {
    let certificateArn: Swift.String?
    let certificateId: Swift.String?
}

extension RegisterCACertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

enum RegisterCACertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CertificateValidationException": return try await CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RegistrationCodeValidationException": return try await RegistrationCodeValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caCertificatePem
        case certificatePem
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caCertificatePem = self.caCertificatePem {
            try encodeContainer.encode(caCertificatePem, forKey: .caCertificatePem)
        }
        if let certificatePem = self.certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension RegisterCertificateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let setAsActive = setAsActive {
                let setAsActiveQueryItem = ClientRuntime.URLQueryItem(name: "setAsActive".urlPercentEncoding(), value: Swift.String(setAsActive).urlPercentEncoding())
                items.append(setAsActiveQueryItem)
            }
            return items
        }
    }
}

extension RegisterCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/certificate/register"
    }
}

/// The input to the RegisterCertificate operation.
public struct RegisterCertificateInput: Swift.Equatable {
    /// The CA certificate used to sign the device certificate being registered.
    public var caCertificatePem: Swift.String?
    /// The certificate data, in PEM format.
    /// This member is required.
    public var certificatePem: Swift.String?
    /// A boolean value that specifies if the certificate is set to active. Valid values: ACTIVE | INACTIVE
    @available(*, deprecated)
    public var setAsActive: Swift.Bool?
    /// The status of the register certificate request. Valid values that you can use include ACTIVE, INACTIVE, and REVOKED.
    public var status: IoTClientTypes.CertificateStatus?

    public init(
        caCertificatePem: Swift.String? = nil,
        certificatePem: Swift.String? = nil,
        setAsActive: Swift.Bool? = nil,
        status: IoTClientTypes.CertificateStatus? = nil
    )
    {
        self.caCertificatePem = caCertificatePem
        self.certificatePem = certificatePem
        self.setAsActive = setAsActive
        self.status = status
    }
}

struct RegisterCertificateInputBody: Swift.Equatable {
    let certificatePem: Swift.String?
    let caCertificatePem: Swift.String?
    let status: IoTClientTypes.CertificateStatus?
}

extension RegisterCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caCertificatePem
        case certificatePem
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let caCertificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caCertificatePem)
        caCertificatePem = caCertificatePemDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CertificateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension RegisterCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateArn = output.certificateArn
            self.certificateId = output.certificateId
        } else {
            self.certificateArn = nil
            self.certificateId = nil
        }
    }
}

/// The output from the RegisterCertificate operation.
public struct RegisterCertificateOutput: Swift.Equatable {
    /// The certificate ARN.
    public var certificateArn: Swift.String?
    /// The certificate identifier.
    public var certificateId: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        certificateId: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
    }
}

struct RegisterCertificateOutputBody: Swift.Equatable {
    let certificateArn: Swift.String?
    let certificateId: Swift.String?
}

extension RegisterCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

enum RegisterCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CertificateConflictException": return try await CertificateConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CertificateStateException": return try await CertificateStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CertificateValidationException": return try await CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterCertificateWithoutCAInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificatePem
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificatePem = self.certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension RegisterCertificateWithoutCAInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/certificate/register-no-ca"
    }
}

public struct RegisterCertificateWithoutCAInput: Swift.Equatable {
    /// The certificate data, in PEM format.
    /// This member is required.
    public var certificatePem: Swift.String?
    /// The status of the register certificate request.
    public var status: IoTClientTypes.CertificateStatus?

    public init(
        certificatePem: Swift.String? = nil,
        status: IoTClientTypes.CertificateStatus? = nil
    )
    {
        self.certificatePem = certificatePem
        self.status = status
    }
}

struct RegisterCertificateWithoutCAInputBody: Swift.Equatable {
    let certificatePem: Swift.String?
    let status: IoTClientTypes.CertificateStatus?
}

extension RegisterCertificateWithoutCAInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificatePem
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CertificateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension RegisterCertificateWithoutCAOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterCertificateWithoutCAOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateArn = output.certificateArn
            self.certificateId = output.certificateId
        } else {
            self.certificateArn = nil
            self.certificateId = nil
        }
    }
}

public struct RegisterCertificateWithoutCAOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the registered certificate.
    public var certificateArn: Swift.String?
    /// The ID of the registered certificate. (The last part of the certificate ARN contains the certificate ID.
    public var certificateId: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        certificateId: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateId = certificateId
    }
}

struct RegisterCertificateWithoutCAOutputBody: Swift.Equatable {
    let certificateArn: Swift.String?
    let certificateId: Swift.String?
}

extension RegisterCertificateWithoutCAOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateId)
        certificateId = certificateIdDecoded
    }
}

enum RegisterCertificateWithoutCAOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CertificateStateException": return try await CertificateStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CertificateValidationException": return try await CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters
        case templateBody
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateBody = self.templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
    }
}

extension RegisterThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/things"
    }
}

public struct RegisterThingInput: Swift.Equatable {
    /// The parameters for provisioning a thing. See [Provisioning Templates](https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html) for more information.
    public var parameters: [Swift.String:Swift.String]?
    /// The provisioning template. See [Provisioning Devices That Have Device Certificates](https://docs.aws.amazon.com/iot/latest/developerguide/provision-w-cert.html) for more information.
    /// This member is required.
    public var templateBody: Swift.String?

    public init(
        parameters: [Swift.String:Swift.String]? = nil,
        templateBody: Swift.String? = nil
    )
    {
        self.parameters = parameters
        self.templateBody = templateBody
    }
}

struct RegisterThingInputBody: Swift.Equatable {
    let templateBody: Swift.String?
    let parameters: [Swift.String:Swift.String]?
}

extension RegisterThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters
        case templateBody
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in parametersContainer {
                if let value0 = value0 {
                    parametersDecoded0?[key0] = value0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension RegisterThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterThingOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificatePem = output.certificatePem
            self.resourceArns = output.resourceArns
        } else {
            self.certificatePem = nil
            self.resourceArns = nil
        }
    }
}

public struct RegisterThingOutput: Swift.Equatable {
    /// The certificate data, in PEM format.
    public var certificatePem: Swift.String?
    /// ARNs for the generated resources.
    public var resourceArns: [Swift.String:Swift.String]?

    public init(
        certificatePem: Swift.String? = nil,
        resourceArns: [Swift.String:Swift.String]? = nil
    )
    {
        self.certificatePem = certificatePem
        self.resourceArns = resourceArns
    }
}

struct RegisterThingOutputBody: Swift.Equatable {
    let certificatePem: Swift.String?
    let resourceArns: [Swift.String:Swift.String]?
}

extension RegisterThingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificatePem
        case resourceArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String:Swift.String]()
            for (key0, resourcearn0) in resourceArnsContainer {
                if let resourcearn0 = resourcearn0 {
                    resourceArnsDecoded0?[key0] = resourcearn0
                }
            }
        }
        resourceArns = resourceArnsDecoded0
    }
}

enum RegisterThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceRegistrationFailureException": return try await ResourceRegistrationFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegistrationCodeValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegistrationCodeValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The registration code is invalid.
public struct RegistrationCodeValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Additional information about the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RegistrationCodeValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RegistrationCodeValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RegistrationCodeValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes.RegistrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case templateBody
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let templateBody = self.templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
    }
}

extension IoTClientTypes {
    /// The registration configuration.
    public struct RegistrationConfig: Swift.Equatable {
        /// The ARN of the role.
        public var roleArn: Swift.String?
        /// The template body.
        public var templateBody: Swift.String?
        /// The name of the provisioning template.
        public var templateName: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            templateBody: Swift.String? = nil,
            templateName: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.templateBody = templateBody
            self.templateName = templateName
        }
    }

}

extension RejectCertificateTransferInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rejectReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rejectReason = self.rejectReason {
            try encodeContainer.encode(rejectReason, forKey: .rejectReason)
        }
    }
}

extension RejectCertificateTransferInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let certificateId = certificateId else {
            return nil
        }
        return "/reject-certificate-transfer/\(certificateId.urlPercentEncoding())"
    }
}

/// The input for the RejectCertificateTransfer operation.
public struct RejectCertificateTransferInput: Swift.Equatable {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?
    /// The reason the certificate transfer was rejected.
    public var rejectReason: Swift.String?

    public init(
        certificateId: Swift.String? = nil,
        rejectReason: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.rejectReason = rejectReason
    }
}

struct RejectCertificateTransferInputBody: Swift.Equatable {
    let rejectReason: Swift.String?
}

extension RejectCertificateTransferInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rejectReason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rejectReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rejectReason)
        rejectReason = rejectReasonDecoded
    }
}

extension RejectCertificateTransferOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RejectCertificateTransferOutput: Swift.Equatable {

    public init() { }
}

enum RejectCertificateTransferOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransferAlreadyCompletedException": return try await TransferAlreadyCompletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.RelatedResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case resourceIdentifier
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            var additionalInfoContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalInfo)
            for (dictKey0, stringMap0) in additionalInfo {
                try additionalInfoContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let additionalInfoContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalInfo)
        var additionalInfoDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalInfoContainer = additionalInfoContainer {
            additionalInfoDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in additionalInfoContainer {
                if let string0 = string0 {
                    additionalInfoDecoded0?[key0] = string0
                }
            }
        }
        additionalInfo = additionalInfoDecoded0
    }
}

extension IoTClientTypes {
    /// Information about a related resource.
    public struct RelatedResource: Swift.Equatable {
        /// Other information about the resource.
        public var additionalInfo: [Swift.String:Swift.String]?
        /// Information that identifies the resource.
        public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
        /// The type of resource.
        public var resourceType: IoTClientTypes.ResourceType?

        public init(
            additionalInfo: [Swift.String:Swift.String]? = nil,
            resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
            resourceType: IoTClientTypes.ResourceType? = nil
        )
        {
            self.additionalInfo = additionalInfo
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }
    }

}

extension RemoveThingFromBillingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupArn
        case billingGroupName
        case thingArn
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupArn = self.billingGroupArn {
            try encodeContainer.encode(billingGroupArn, forKey: .billingGroupArn)
        }
        if let billingGroupName = self.billingGroupName {
            try encodeContainer.encode(billingGroupName, forKey: .billingGroupName)
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

extension RemoveThingFromBillingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/billing-groups/removeThingFromBillingGroup"
    }
}

public struct RemoveThingFromBillingGroupInput: Swift.Equatable {
    /// The ARN of the billing group.
    public var billingGroupArn: Swift.String?
    /// The name of the billing group.
    public var billingGroupName: Swift.String?
    /// The ARN of the thing to be removed from the billing group.
    public var thingArn: Swift.String?
    /// The name of the thing to be removed from the billing group.
    public var thingName: Swift.String?

    public init(
        billingGroupArn: Swift.String? = nil,
        billingGroupName: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingGroupName = billingGroupName
        self.thingArn = thingArn
        self.thingName = thingName
    }
}

struct RemoveThingFromBillingGroupInputBody: Swift.Equatable {
    let billingGroupName: Swift.String?
    let billingGroupArn: Swift.String?
    let thingName: Swift.String?
    let thingArn: Swift.String?
}

extension RemoveThingFromBillingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupArn
        case billingGroupName
        case thingArn
        case thingName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupName)
        billingGroupName = billingGroupNameDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension RemoveThingFromBillingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveThingFromBillingGroupOutput: Swift.Equatable {

    public init() { }
}

enum RemoveThingFromBillingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveThingFromThingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn
        case thingGroupArn
        case thingGroupName
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let thingGroupArn = self.thingGroupArn {
            try encodeContainer.encode(thingGroupArn, forKey: .thingGroupArn)
        }
        if let thingGroupName = self.thingGroupName {
            try encodeContainer.encode(thingGroupName, forKey: .thingGroupName)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

extension RemoveThingFromThingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/thing-groups/removeThingFromThingGroup"
    }
}

public struct RemoveThingFromThingGroupInput: Swift.Equatable {
    /// The ARN of the thing to remove from the group.
    public var thingArn: Swift.String?
    /// The group ARN.
    public var thingGroupArn: Swift.String?
    /// The group name.
    public var thingGroupName: Swift.String?
    /// The name of the thing to remove from the group.
    public var thingName: Swift.String?

    public init(
        thingArn: Swift.String? = nil,
        thingGroupArn: Swift.String? = nil,
        thingGroupName: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.thingArn = thingArn
        self.thingGroupArn = thingGroupArn
        self.thingGroupName = thingGroupName
        self.thingName = thingName
    }
}

struct RemoveThingFromThingGroupInputBody: Swift.Equatable {
    let thingGroupName: Swift.String?
    let thingGroupArn: Swift.String?
    let thingName: Swift.String?
    let thingArn: Swift.String?
}

extension RemoveThingFromThingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingArn
        case thingGroupArn
        case thingGroupName
        case thingName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupName)
        thingGroupName = thingGroupNameDecoded
        let thingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupArn)
        thingGroupArn = thingGroupArnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension RemoveThingFromThingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveThingFromThingGroupOutput: Swift.Equatable {

    public init() { }
}

enum RemoveThingFromThingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.ReplaceDefaultPolicyVersionParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName.rawValue, forKey: .templateName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(IoTClientTypes.PolicyTemplateName.self, forKey: .templateName)
        templateName = templateNameDecoded
    }
}

extension IoTClientTypes {
    /// Parameters to define a mitigation action that adds a blank policy to restrict permissions.
    public struct ReplaceDefaultPolicyVersionParams: Swift.Equatable {
        /// The name of the template to be applied. The only supported value is BLANK_POLICY.
        /// This member is required.
        public var templateName: IoTClientTypes.PolicyTemplateName?

        public init(
            templateName: IoTClientTypes.PolicyTemplateName? = nil
        )
        {
            self.templateName = templateName
        }
    }

}

public struct ReplaceTopicRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReplaceTopicRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReplaceTopicRuleInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ReplaceTopicRuleOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let topicRulePayload = input.operationInput.topicRulePayload {
                let topicRulePayloadData = try encoder.encode(topicRulePayload)
                let topicRulePayloadBody = ClientRuntime.HttpBody.data(topicRulePayloadData)
                input.builder.withBody(topicRulePayloadBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let topicRulePayloadData = "{}".data(using: .utf8)!
                    let topicRulePayloadBody = ClientRuntime.HttpBody.data(topicRulePayloadData)
                    input.builder.withBody(topicRulePayloadBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReplaceTopicRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReplaceTopicRuleOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension ReplaceTopicRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicRulePayload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicRulePayload = self.topicRulePayload {
            try encodeContainer.encode(topicRulePayload, forKey: .topicRulePayload)
        }
    }
}

extension ReplaceTopicRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ruleName = ruleName else {
            return nil
        }
        return "/rules/\(ruleName.urlPercentEncoding())"
    }
}

/// The input for the ReplaceTopicRule operation.
public struct ReplaceTopicRuleInput: Swift.Equatable {
    /// The name of the rule.
    /// This member is required.
    public var ruleName: Swift.String?
    /// The rule payload.
    /// This member is required.
    public var topicRulePayload: IoTClientTypes.TopicRulePayload?

    public init(
        ruleName: Swift.String? = nil,
        topicRulePayload: IoTClientTypes.TopicRulePayload? = nil
    )
    {
        self.ruleName = ruleName
        self.topicRulePayload = topicRulePayload
    }
}

struct ReplaceTopicRuleInputBody: Swift.Equatable {
    let topicRulePayload: IoTClientTypes.TopicRulePayload?
}

extension ReplaceTopicRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicRulePayload
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicRulePayloadDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TopicRulePayload.self, forKey: .topicRulePayload)
        topicRulePayload = topicRulePayloadDecoded
    }
}

extension ReplaceTopicRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ReplaceTopicRuleOutput: Swift.Equatable {

    public init() { }
}

enum ReplaceTopicRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SqlParseException": return try await SqlParseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes {
    public enum ReportType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case errors
        case results
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportType] {
            return [
                .errors,
                .results,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .errors: return "ERRORS"
            case .results: return "RESULTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportType(rawValue: rawValue) ?? ReportType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.RepublishAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headers
        case qos
        case roleArn
        case topic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headers = self.headers {
            try encodeContainer.encode(headers, forKey: .headers)
        }
        if let qos = self.qos {
            try encodeContainer.encode(qos, forKey: .qos)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let topic = self.topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let topicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topic)
        topic = topicDecoded
        let qosDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .qos)
        qos = qosDecoded
        let headersDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MqttHeaders.self, forKey: .headers)
        headers = headersDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action to republish to another topic.
    public struct RepublishAction: Swift.Equatable {
        /// MQTT Version 5.0 headers information. For more information, see [ MQTT](https://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html) from the Amazon Web Services IoT Core Developer Guide.
        public var headers: IoTClientTypes.MqttHeaders?
        /// The Quality of Service (QoS) level to use when republishing messages. The default value is 0.
        public var qos: Swift.Int?
        /// The ARN of the IAM role that grants access.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The name of the MQTT topic.
        /// This member is required.
        public var topic: Swift.String?

        public init(
            headers: IoTClientTypes.MqttHeaders? = nil,
            qos: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            topic: Swift.String? = nil
        )
        {
            self.headers = headers
            self.qos = qos
            self.roleArn = roleArn
            self.topic = topic
        }
    }

}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceArn = output.resourceArn
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.message = nil
            self.properties.resourceArn = nil
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
        /// The ARN of the resource that caused the exception.
        public internal(set) var resourceArn: Swift.String? = nil
        /// The ID of the resource that caused the exception.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceArn = resourceArn
        self.properties.resourceId = resourceId
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceArn: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension IoTClientTypes.ResourceIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account
        case caCertificateId
        case clientId
        case cognitoIdentityPoolId
        case deviceCertificateArn
        case deviceCertificateId
        case iamRoleArn
        case issuerCertificateIdentifier
        case policyVersionIdentifier
        case roleAliasArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = self.account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let caCertificateId = self.caCertificateId {
            try encodeContainer.encode(caCertificateId, forKey: .caCertificateId)
        }
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let cognitoIdentityPoolId = self.cognitoIdentityPoolId {
            try encodeContainer.encode(cognitoIdentityPoolId, forKey: .cognitoIdentityPoolId)
        }
        if let deviceCertificateArn = self.deviceCertificateArn {
            try encodeContainer.encode(deviceCertificateArn, forKey: .deviceCertificateArn)
        }
        if let deviceCertificateId = self.deviceCertificateId {
            try encodeContainer.encode(deviceCertificateId, forKey: .deviceCertificateId)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let issuerCertificateIdentifier = self.issuerCertificateIdentifier {
            try encodeContainer.encode(issuerCertificateIdentifier, forKey: .issuerCertificateIdentifier)
        }
        if let policyVersionIdentifier = self.policyVersionIdentifier {
            try encodeContainer.encode(policyVersionIdentifier, forKey: .policyVersionIdentifier)
        }
        if let roleAliasArn = self.roleAliasArn {
            try encodeContainer.encode(roleAliasArn, forKey: .roleAliasArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCertificateId)
        deviceCertificateId = deviceCertificateIdDecoded
        let caCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caCertificateId)
        caCertificateId = caCertificateIdDecoded
        let cognitoIdentityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cognitoIdentityPoolId)
        cognitoIdentityPoolId = cognitoIdentityPoolIdDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let policyVersionIdentifierDecoded = try containerValues.decodeIfPresent(IoTClientTypes.PolicyVersionIdentifier.self, forKey: .policyVersionIdentifier)
        policyVersionIdentifier = policyVersionIdentifierDecoded
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let roleAliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleAliasArn)
        roleAliasArn = roleAliasArnDecoded
        let issuerCertificateIdentifierDecoded = try containerValues.decodeIfPresent(IoTClientTypes.IssuerCertificateIdentifier.self, forKey: .issuerCertificateIdentifier)
        issuerCertificateIdentifier = issuerCertificateIdentifierDecoded
        let deviceCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceCertificateArn)
        deviceCertificateArn = deviceCertificateArnDecoded
    }
}

extension IoTClientTypes {
    /// Information that identifies the noncompliant resource.
    public struct ResourceIdentifier: Swift.Equatable {
        /// The account with which the resource is associated.
        public var account: Swift.String?
        /// The ID of the CA certificate used to authorize the certificate.
        public var caCertificateId: Swift.String?
        /// The client ID.
        public var clientId: Swift.String?
        /// The ID of the Amazon Cognito identity pool.
        public var cognitoIdentityPoolId: Swift.String?
        /// The ARN of the identified device certificate.
        public var deviceCertificateArn: Swift.String?
        /// The ID of the certificate attached to the resource.
        public var deviceCertificateId: Swift.String?
        /// The ARN of the IAM role that has overly permissive actions.
        public var iamRoleArn: Swift.String?
        /// The issuer certificate identifier.
        public var issuerCertificateIdentifier: IoTClientTypes.IssuerCertificateIdentifier?
        /// The version of the policy associated with the resource.
        public var policyVersionIdentifier: IoTClientTypes.PolicyVersionIdentifier?
        /// The ARN of the role alias that has overly permissive actions.
        public var roleAliasArn: Swift.String?

        public init(
            account: Swift.String? = nil,
            caCertificateId: Swift.String? = nil,
            clientId: Swift.String? = nil,
            cognitoIdentityPoolId: Swift.String? = nil,
            deviceCertificateArn: Swift.String? = nil,
            deviceCertificateId: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            issuerCertificateIdentifier: IoTClientTypes.IssuerCertificateIdentifier? = nil,
            policyVersionIdentifier: IoTClientTypes.PolicyVersionIdentifier? = nil,
            roleAliasArn: Swift.String? = nil
        )
        {
            self.account = account
            self.caCertificateId = caCertificateId
            self.clientId = clientId
            self.cognitoIdentityPoolId = cognitoIdentityPoolId
            self.deviceCertificateArn = deviceCertificateArn
            self.deviceCertificateId = deviceCertificateId
            self.iamRoleArn = iamRoleArn
            self.issuerCertificateIdentifier = issuerCertificateIdentifier
            self.policyVersionIdentifier = policyVersionIdentifier
            self.roleAliasArn = roleAliasArn
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceRegistrationFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceRegistrationFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource registration failed.
public struct ResourceRegistrationFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceRegistrationFailureException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceRegistrationFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceRegistrationFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountSettings
        case caCertificate
        case clientId
        case cognitoIdentityPool
        case deviceCertificate
        case iamRole
        case iotPolicy
        case issuerCertificate
        case roleAlias
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .accountSettings,
                .caCertificate,
                .clientId,
                .cognitoIdentityPool,
                .deviceCertificate,
                .iamRole,
                .iotPolicy,
                .issuerCertificate,
                .roleAlias,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountSettings: return "ACCOUNT_SETTINGS"
            case .caCertificate: return "CA_CERTIFICATE"
            case .clientId: return "CLIENT_ID"
            case .cognitoIdentityPool: return "COGNITO_IDENTITY_POOL"
            case .deviceCertificate: return "DEVICE_CERTIFICATE"
            case .iamRole: return "IAM_ROLE"
            case .iotPolicy: return "IOT_POLICY"
            case .issuerCertificate: return "ISSUER_CERTIFICATE"
            case .roleAlias: return "ROLE_ALIAS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.RetryCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureType
        case numberOfRetries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureType = self.failureType {
            try encodeContainer.encode(failureType.rawValue, forKey: .failureType)
        }
        if let numberOfRetries = self.numberOfRetries {
            try encodeContainer.encode(numberOfRetries, forKey: .numberOfRetries)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.RetryableFailureType.self, forKey: .failureType)
        failureType = failureTypeDecoded
        let numberOfRetriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRetries)
        numberOfRetries = numberOfRetriesDecoded
    }
}

extension IoTClientTypes {
    /// The criteria that determines how many retries are allowed for each failure type for a job.
    public struct RetryCriteria: Swift.Equatable {
        /// The type of job execution failures that can initiate a job retry.
        /// This member is required.
        public var failureType: IoTClientTypes.RetryableFailureType?
        /// The number of retries allowed for a failure type for the job.
        /// This member is required.
        public var numberOfRetries: Swift.Int?

        public init(
            failureType: IoTClientTypes.RetryableFailureType? = nil,
            numberOfRetries: Swift.Int? = nil
        )
        {
            self.failureType = failureType
            self.numberOfRetries = numberOfRetries
        }
    }

}

extension IoTClientTypes {
    public enum RetryableFailureType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case failed
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [RetryableFailureType] {
            return [
                .all,
                .failed,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetryableFailureType(rawValue: rawValue) ?? RetryableFailureType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.RoleAliasDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case credentialDurationSeconds
        case lastModifiedDate
        case owner
        case roleAlias
        case roleAliasArn
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let credentialDurationSeconds = self.credentialDurationSeconds {
            try encodeContainer.encode(credentialDurationSeconds, forKey: .credentialDurationSeconds)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encodeTimestamp(lastModifiedDate, format: .epochSeconds, forKey: .lastModifiedDate)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let roleAlias = self.roleAlias {
            try encodeContainer.encode(roleAlias, forKey: .roleAlias)
        }
        if let roleAliasArn = self.roleAliasArn {
            try encodeContainer.encode(roleAliasArn, forKey: .roleAliasArn)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleAlias)
        roleAlias = roleAliasDecoded
        let roleAliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleAliasArn)
        roleAliasArn = roleAliasArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let credentialDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .credentialDurationSeconds)
        credentialDurationSeconds = credentialDurationSecondsDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension IoTClientTypes {
    /// Role alias description.
    public struct RoleAliasDescription: Swift.Equatable {
        /// The UNIX timestamp of when the role alias was created.
        public var creationDate: ClientRuntime.Date?
        /// The number of seconds for which the credential is valid.
        public var credentialDurationSeconds: Swift.Int?
        /// The UNIX timestamp of when the role alias was last modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The role alias owner.
        public var owner: Swift.String?
        /// The role alias.
        public var roleAlias: Swift.String?
        /// The ARN of the role alias.
        public var roleAliasArn: Swift.String?
        /// The role ARN.
        public var roleArn: Swift.String?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            credentialDurationSeconds: Swift.Int? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            owner: Swift.String? = nil,
            roleAlias: Swift.String? = nil,
            roleAliasArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.credentialDurationSeconds = credentialDurationSeconds
            self.lastModifiedDate = lastModifiedDate
            self.owner = owner
            self.roleAlias = roleAlias
            self.roleAliasArn = roleAliasArn
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes.S3Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case cannedAcl
        case key
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let cannedAcl = self.cannedAcl {
            try encodeContainer.encode(cannedAcl.rawValue, forKey: .cannedAcl)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let cannedAclDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CannedAccessControlList.self, forKey: .cannedAcl)
        cannedAcl = cannedAclDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action to write data to an Amazon S3 bucket.
    public struct S3Action: Swift.Equatable {
        /// The Amazon S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see [S3 canned ACLs](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl).
        public var cannedAcl: IoTClientTypes.CannedAccessControlList?
        /// The object key. For more information, see [Actions, resources, and condition keys for Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/dev/list_amazons3.html).
        /// This member is required.
        public var key: Swift.String?
        /// The ARN of the IAM role that grants access.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            cannedAcl: IoTClientTypes.CannedAccessControlList? = nil,
            key: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.cannedAcl = cannedAcl
            self.key = key
            self.roleArn = roleArn
        }
    }

}

extension IoTClientTypes.S3Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension IoTClientTypes {
    /// Describes the location of updated firmware in S3.
    public struct S3Destination: Swift.Equatable {
        /// The S3 bucket that contains the updated firmware.
        public var bucket: Swift.String?
        /// The S3 prefix.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }

}

extension IoTClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension IoTClientTypes {
    /// The S3 location.
    public struct S3Location: Swift.Equatable {
        /// The S3 bucket.
        public var bucket: Swift.String?
        /// The S3 key.
        public var key: Swift.String?
        /// The S3 bucket version.
        public var version: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.version = version
        }
    }

}

extension IoTClientTypes.SalesforceAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case token
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action to write a message to a Salesforce IoT Cloud Input Stream.
    public struct SalesforceAction: Swift.Equatable {
        /// The token used to authenticate access to the Salesforce IoT Cloud Input Stream. The token is available from the Salesforce IoT Cloud platform after creation of the Input Stream.
        /// This member is required.
        public var token: Swift.String?
        /// The URL exposed by the Salesforce IoT Cloud Input Stream. The URL is available from the Salesforce IoT Cloud platform after creation of the Input Stream.
        /// This member is required.
        public var url: Swift.String?

        public init(
            token: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.token = token
            self.url = url
        }
    }

}

extension IoTClientTypes.ScheduledAuditMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth
        case dayOfWeek
        case frequency
        case scheduledAuditArn
        case scheduledAuditName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = self.dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = self.dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
        if let scheduledAuditArn = self.scheduledAuditArn {
            try encodeContainer.encode(scheduledAuditArn, forKey: .scheduledAuditArn)
        }
        if let scheduledAuditName = self.scheduledAuditName {
            try encodeContainer.encode(scheduledAuditName, forKey: .scheduledAuditName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledAuditNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledAuditName)
        scheduledAuditName = scheduledAuditNameDecoded
        let scheduledAuditArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledAuditArn)
        scheduledAuditArn = scheduledAuditArnDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
    }
}

extension IoTClientTypes {
    /// Information about the scheduled audit.
    public struct ScheduledAuditMetadata: Swift.Equatable {
        /// The day of the month on which the scheduled audit is run (if the frequency is "MONTHLY"). If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.
        public var dayOfMonth: Swift.String?
        /// The day of the week on which the scheduled audit is run (if the frequency is "WEEKLY" or "BIWEEKLY").
        public var dayOfWeek: IoTClientTypes.DayOfWeek?
        /// How often the scheduled audit occurs.
        public var frequency: IoTClientTypes.AuditFrequency?
        /// The ARN of the scheduled audit.
        public var scheduledAuditArn: Swift.String?
        /// The name of the scheduled audit.
        public var scheduledAuditName: Swift.String?

        public init(
            dayOfMonth: Swift.String? = nil,
            dayOfWeek: IoTClientTypes.DayOfWeek? = nil,
            frequency: IoTClientTypes.AuditFrequency? = nil,
            scheduledAuditArn: Swift.String? = nil,
            scheduledAuditName: Swift.String? = nil
        )
        {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
            self.frequency = frequency
            self.scheduledAuditArn = scheduledAuditArn
            self.scheduledAuditName = scheduledAuditName
        }
    }

}

extension IoTClientTypes.ScheduledJobRollout: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension IoTClientTypes {
    /// Displays the next seven maintenance window occurrences and their start times.
    public struct ScheduledJobRollout: Swift.Equatable {
        /// Displays the start times of the next seven maintenance window occurrences.
        public var startTime: Swift.String?

        public init(
            startTime: Swift.String? = nil
        )
        {
            self.startTime = startTime
        }
    }

}

extension IoTClientTypes.SchedulingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endBehavior
        case endTime
        case maintenanceWindows
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endBehavior = self.endBehavior {
            try encodeContainer.encode(endBehavior.rawValue, forKey: .endBehavior)
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let maintenanceWindows = maintenanceWindows {
            var maintenanceWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .maintenanceWindows)
            for maintenancewindow0 in maintenanceWindows {
                try maintenanceWindowsContainer.encode(maintenancewindow0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let endBehaviorDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobEndBehavior.self, forKey: .endBehavior)
        endBehavior = endBehaviorDecoded
        let maintenanceWindowsContainer = try containerValues.decodeIfPresent([IoTClientTypes.MaintenanceWindow?].self, forKey: .maintenanceWindows)
        var maintenanceWindowsDecoded0:[IoTClientTypes.MaintenanceWindow]? = nil
        if let maintenanceWindowsContainer = maintenanceWindowsContainer {
            maintenanceWindowsDecoded0 = [IoTClientTypes.MaintenanceWindow]()
            for structure0 in maintenanceWindowsContainer {
                if let structure0 = structure0 {
                    maintenanceWindowsDecoded0?.append(structure0)
                }
            }
        }
        maintenanceWindows = maintenanceWindowsDecoded0
    }
}

extension IoTClientTypes {
    /// Specifies the date and time that a job will begin the rollout of the job document to all devices in the target group. Additionally, you can specify the end behavior for each job execution when it reaches the scheduled end time.
    public struct SchedulingConfig: Swift.Equatable {
        /// Specifies the end behavior for all job executions after a job reaches the selected endTime. If endTime is not selected when creating the job, then endBehavior does not apply.
        public var endBehavior: IoTClientTypes.JobEndBehavior?
        /// The time a job will stop rollout of the job document to all devices in the target group for a job. The endTime must take place no later than two years from the current time and be scheduled a minimum of thirty minutes from the current time. The minimum duration between startTime and endTime is thirty minutes. The maximum duration between startTime and endTime is two years. The date and time format for the endTime is YYYY-MM-DD for the date and HH:MM for the time. For more information on the syntax for endTime when using an API command or the Command Line Interface, see [Timestamp](https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters-types.html#parameter-type-timestamp).
        public var endTime: Swift.String?
        /// An optional configuration within the SchedulingConfig to setup a recurring maintenance window with a predetermined start time and duration for the rollout of a job document to all devices in a target group for a job.
        public var maintenanceWindows: [IoTClientTypes.MaintenanceWindow]?
        /// The time a job will begin rollout of the job document to all devices in the target group for a job. The startTime can be scheduled up to a year in advance and must be scheduled a minimum of thirty minutes from the current time. The date and time format for the startTime is YYYY-MM-DD for the date and HH:MM for the time. For more information on the syntax for startTime when using an API command or the Command Line Interface, see [Timestamp](https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters-types.html#parameter-type-timestamp).
        public var startTime: Swift.String?

        public init(
            endBehavior: IoTClientTypes.JobEndBehavior? = nil,
            endTime: Swift.String? = nil,
            maintenanceWindows: [IoTClientTypes.MaintenanceWindow]? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.endBehavior = endBehavior
            self.endTime = endTime
            self.maintenanceWindows = maintenanceWindows
            self.startTime = startTime
        }
    }

}

extension SearchIndexInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexName
        case maxResults
        case nextToken
        case queryString
        case queryVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = self.queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
    }
}

extension SearchIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/indices/search"
    }
}

public struct SearchIndexInput: Swift.Equatable {
    /// The search index name.
    public var indexName: Swift.String?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The token used to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The search query string. For more information about the search query syntax, see [Query syntax](https://docs.aws.amazon.com/iot/latest/developerguide/query-syntax.html).
    /// This member is required.
    public var queryString: Swift.String?
    /// The query version.
    public var queryVersion: Swift.String?

    public init(
        indexName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil
    )
    {
        self.indexName = indexName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryString = queryString
        self.queryVersion = queryVersion
    }
}

struct SearchIndexInputBody: Swift.Equatable {
    let indexName: Swift.String?
    let queryString: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let queryVersion: Swift.String?
}

extension SearchIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexName
        case maxResults
        case nextToken
        case queryString
        case queryVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
    }
}

extension SearchIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchIndexOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.thingGroups = output.thingGroups
            self.things = output.things
        } else {
            self.nextToken = nil
            self.thingGroups = nil
            self.things = nil
        }
    }
}

public struct SearchIndexOutput: Swift.Equatable {
    /// The token used to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The thing groups that match the search query.
    public var thingGroups: [IoTClientTypes.ThingGroupDocument]?
    /// The things that match the search query.
    public var things: [IoTClientTypes.ThingDocument]?

    public init(
        nextToken: Swift.String? = nil,
        thingGroups: [IoTClientTypes.ThingGroupDocument]? = nil,
        things: [IoTClientTypes.ThingDocument]? = nil
    )
    {
        self.nextToken = nextToken
        self.thingGroups = thingGroups
        self.things = things
    }
}

struct SearchIndexOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let things: [IoTClientTypes.ThingDocument]?
    let thingGroups: [IoTClientTypes.ThingGroupDocument]?
}

extension SearchIndexOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case thingGroups
        case things
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let thingsContainer = try containerValues.decodeIfPresent([IoTClientTypes.ThingDocument?].self, forKey: .things)
        var thingsDecoded0:[IoTClientTypes.ThingDocument]? = nil
        if let thingsContainer = thingsContainer {
            thingsDecoded0 = [IoTClientTypes.ThingDocument]()
            for structure0 in thingsContainer {
                if let structure0 = structure0 {
                    thingsDecoded0?.append(structure0)
                }
            }
        }
        things = thingsDecoded0
        let thingGroupsContainer = try containerValues.decodeIfPresent([IoTClientTypes.ThingGroupDocument?].self, forKey: .thingGroups)
        var thingGroupsDecoded0:[IoTClientTypes.ThingGroupDocument]? = nil
        if let thingGroupsContainer = thingGroupsContainer {
            thingGroupsDecoded0 = [IoTClientTypes.ThingGroupDocument]()
            for structure0 in thingGroupsContainer {
                if let structure0 = structure0 {
                    thingGroupsDecoded0?.append(structure0)
                }
            }
        }
        thingGroups = thingGroupsDecoded0
    }
}

enum SearchIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IndexNotReadyException": return try await IndexNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidQueryException": return try await InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.SecurityProfileIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTClientTypes {
    /// Identifying information for a Device Defender security profile.
    public struct SecurityProfileIdentifier: Swift.Equatable {
        /// The ARN of the security profile.
        /// This member is required.
        public var arn: Swift.String?
        /// The name you've given to the security profile.
        /// This member is required.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension IoTClientTypes.SecurityProfileTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTClientTypes {
    /// A target to which an alert is sent when a security profile behavior is violated.
    public struct SecurityProfileTarget: Swift.Equatable {
        /// The ARN of the security profile.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IoTClientTypes.SecurityProfileTargetMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityProfileIdentifier
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityProfileIdentifier = self.securityProfileIdentifier {
            try encodeContainer.encode(securityProfileIdentifier, forKey: .securityProfileIdentifier)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileIdentifierDecoded = try containerValues.decodeIfPresent(IoTClientTypes.SecurityProfileIdentifier.self, forKey: .securityProfileIdentifier)
        securityProfileIdentifier = securityProfileIdentifierDecoded
        let targetDecoded = try containerValues.decodeIfPresent(IoTClientTypes.SecurityProfileTarget.self, forKey: .target)
        target = targetDecoded
    }
}

extension IoTClientTypes {
    /// Information about a security profile and the target associated with it.
    public struct SecurityProfileTargetMapping: Swift.Equatable {
        /// Information that identifies the security profile.
        public var securityProfileIdentifier: IoTClientTypes.SecurityProfileIdentifier?
        /// Information about the target (thing group) associated with the security profile.
        public var target: IoTClientTypes.SecurityProfileTarget?

        public init(
            securityProfileIdentifier: IoTClientTypes.SecurityProfileIdentifier? = nil,
            target: IoTClientTypes.SecurityProfileTarget? = nil
        )
        {
            self.securityProfileIdentifier = securityProfileIdentifier
            self.target = target
        }
    }

}

extension IoTClientTypes {
    public enum ServerCertificateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalid
        case valid
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerCertificateStatus] {
            return [
                .invalid,
                .valid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalid: return "INVALID"
            case .valid: return "VALID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerCertificateStatus(rawValue: rawValue) ?? ServerCertificateStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.ServerCertificateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverCertificateArn
        case serverCertificateStatus
        case serverCertificateStatusDetail
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverCertificateArn = self.serverCertificateArn {
            try encodeContainer.encode(serverCertificateArn, forKey: .serverCertificateArn)
        }
        if let serverCertificateStatus = self.serverCertificateStatus {
            try encodeContainer.encode(serverCertificateStatus.rawValue, forKey: .serverCertificateStatus)
        }
        if let serverCertificateStatusDetail = self.serverCertificateStatusDetail {
            try encodeContainer.encode(serverCertificateStatusDetail, forKey: .serverCertificateStatusDetail)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateArn)
        serverCertificateArn = serverCertificateArnDecoded
        let serverCertificateStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ServerCertificateStatus.self, forKey: .serverCertificateStatus)
        serverCertificateStatus = serverCertificateStatusDecoded
        let serverCertificateStatusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertificateStatusDetail)
        serverCertificateStatusDetail = serverCertificateStatusDetailDecoded
    }
}

extension IoTClientTypes {
    /// An object that contains information about a server certificate.
    public struct ServerCertificateSummary: Swift.Equatable {
        /// The ARN of the server certificate.
        public var serverCertificateArn: Swift.String?
        /// The status of the server certificate.
        public var serverCertificateStatus: IoTClientTypes.ServerCertificateStatus?
        /// Details that explain the status of the server certificate.
        public var serverCertificateStatusDetail: Swift.String?

        public init(
            serverCertificateArn: Swift.String? = nil,
            serverCertificateStatus: IoTClientTypes.ServerCertificateStatus? = nil,
            serverCertificateStatusDetail: Swift.String? = nil
        )
        {
            self.serverCertificateArn = serverCertificateArn
            self.serverCertificateStatus = serverCertificateStatus
            self.serverCertificateStatusDetail = serverCertificateStatusDetail
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A limit has been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes {
    public enum ServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case credentialProvider
        case data
        case jobs
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .credentialProvider,
                .data,
                .jobs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .credentialProvider: return "CREDENTIAL_PROVIDER"
            case .data: return "DATA"
            case .jobs: return "JOBS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceType(rawValue: rawValue) ?? ServiceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is temporarily unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SetDefaultAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerName = self.authorizerName {
            try encodeContainer.encode(authorizerName, forKey: .authorizerName)
        }
    }
}

extension SetDefaultAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/default-authorizer"
    }
}

public struct SetDefaultAuthorizerInput: Swift.Equatable {
    /// The authorizer name.
    /// This member is required.
    public var authorizerName: Swift.String?

    public init(
        authorizerName: Swift.String? = nil
    )
    {
        self.authorizerName = authorizerName
    }
}

struct SetDefaultAuthorizerInputBody: Swift.Equatable {
    let authorizerName: Swift.String?
}

extension SetDefaultAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerName)
        authorizerName = authorizerNameDecoded
    }
}

extension SetDefaultAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SetDefaultAuthorizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizerArn = output.authorizerArn
            self.authorizerName = output.authorizerName
        } else {
            self.authorizerArn = nil
            self.authorizerName = nil
        }
    }
}

public struct SetDefaultAuthorizerOutput: Swift.Equatable {
    /// The authorizer ARN.
    public var authorizerArn: Swift.String?
    /// The authorizer name.
    public var authorizerName: Swift.String?

    public init(
        authorizerArn: Swift.String? = nil,
        authorizerName: Swift.String? = nil
    )
    {
        self.authorizerArn = authorizerArn
        self.authorizerName = authorizerName
    }
}

struct SetDefaultAuthorizerOutputBody: Swift.Equatable {
    let authorizerName: Swift.String?
    let authorizerArn: Swift.String?
}

extension SetDefaultAuthorizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerArn
        case authorizerName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerName)
        authorizerName = authorizerNameDecoded
        let authorizerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerArn)
        authorizerArn = authorizerArnDecoded
    }
}

enum SetDefaultAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetDefaultPolicyVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let policyName = policyName else {
            return nil
        }
        guard let policyVersionId = policyVersionId else {
            return nil
        }
        return "/policies/\(policyName.urlPercentEncoding())/version/\(policyVersionId.urlPercentEncoding())"
    }
}

/// The input for the SetDefaultPolicyVersion operation.
public struct SetDefaultPolicyVersionInput: Swift.Equatable {
    /// The policy name.
    /// This member is required.
    public var policyName: Swift.String?
    /// The policy version ID.
    /// This member is required.
    public var policyVersionId: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        policyVersionId: Swift.String? = nil
    )
    {
        self.policyName = policyName
        self.policyVersionId = policyVersionId
    }
}

struct SetDefaultPolicyVersionInputBody: Swift.Equatable {
}

extension SetDefaultPolicyVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension SetDefaultPolicyVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SetDefaultPolicyVersionOutput: Swift.Equatable {

    public init() { }
}

enum SetDefaultPolicyVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct SetLoggingOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetLoggingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetLoggingOptionsInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<SetLoggingOptionsOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let loggingOptionsPayload = input.operationInput.loggingOptionsPayload {
                let loggingOptionsPayloadData = try encoder.encode(loggingOptionsPayload)
                let loggingOptionsPayloadBody = ClientRuntime.HttpBody.data(loggingOptionsPayloadData)
                input.builder.withBody(loggingOptionsPayloadBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let loggingOptionsPayloadData = "{}".data(using: .utf8)!
                    let loggingOptionsPayloadBody = ClientRuntime.HttpBody.data(loggingOptionsPayloadData)
                    input.builder.withBody(loggingOptionsPayloadBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetLoggingOptionsOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension SetLoggingOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptionsPayload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingOptionsPayload = self.loggingOptionsPayload {
            try encodeContainer.encode(loggingOptionsPayload, forKey: .loggingOptionsPayload)
        }
    }
}

extension SetLoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/loggingOptions"
    }
}

/// The input for the SetLoggingOptions operation.
public struct SetLoggingOptionsInput: Swift.Equatable {
    /// The logging options payload.
    /// This member is required.
    public var loggingOptionsPayload: IoTClientTypes.LoggingOptionsPayload?

    public init(
        loggingOptionsPayload: IoTClientTypes.LoggingOptionsPayload? = nil
    )
    {
        self.loggingOptionsPayload = loggingOptionsPayload
    }
}

struct SetLoggingOptionsInputBody: Swift.Equatable {
    let loggingOptionsPayload: IoTClientTypes.LoggingOptionsPayload?
}

extension SetLoggingOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptionsPayload
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsPayloadDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LoggingOptionsPayload.self, forKey: .loggingOptionsPayload)
        loggingOptionsPayload = loggingOptionsPayloadDecoded
    }
}

extension SetLoggingOptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SetLoggingOptionsOutput: Swift.Equatable {

    public init() { }
}

enum SetLoggingOptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetV2LoggingLevelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel
        case logTarget
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let logTarget = self.logTarget {
            try encodeContainer.encode(logTarget, forKey: .logTarget)
        }
    }
}

extension SetV2LoggingLevelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2LoggingLevel"
    }
}

public struct SetV2LoggingLevelInput: Swift.Equatable {
    /// The log level.
    /// This member is required.
    public var logLevel: IoTClientTypes.LogLevel?
    /// The log target.
    /// This member is required.
    public var logTarget: IoTClientTypes.LogTarget?

    public init(
        logLevel: IoTClientTypes.LogLevel? = nil,
        logTarget: IoTClientTypes.LogTarget? = nil
    )
    {
        self.logLevel = logLevel
        self.logTarget = logTarget
    }
}

struct SetV2LoggingLevelInputBody: Swift.Equatable {
    let logTarget: IoTClientTypes.LogTarget?
    let logLevel: IoTClientTypes.LogLevel?
}

extension SetV2LoggingLevelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel
        case logTarget
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logTargetDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LogTarget.self, forKey: .logTarget)
        logTarget = logTargetDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension SetV2LoggingLevelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SetV2LoggingLevelOutput: Swift.Equatable {

    public init() { }
}

enum SetV2LoggingLevelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotConfiguredException": return try await NotConfiguredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetV2LoggingOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel
        case disableAllLogs
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultLogLevel = self.defaultLogLevel {
            try encodeContainer.encode(defaultLogLevel.rawValue, forKey: .defaultLogLevel)
        }
        if let disableAllLogs = self.disableAllLogs {
            try encodeContainer.encode(disableAllLogs, forKey: .disableAllLogs)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension SetV2LoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2LoggingOptions"
    }
}

public struct SetV2LoggingOptionsInput: Swift.Equatable {
    /// The default logging level.
    public var defaultLogLevel: IoTClientTypes.LogLevel?
    /// If true all logs are disabled. The default is false.
    public var disableAllLogs: Swift.Bool?
    /// The ARN of the role that allows IoT to write to Cloudwatch logs.
    public var roleArn: Swift.String?

    public init(
        defaultLogLevel: IoTClientTypes.LogLevel? = nil,
        disableAllLogs: Swift.Bool? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.disableAllLogs = disableAllLogs
        self.roleArn = roleArn
    }
}

struct SetV2LoggingOptionsInputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let defaultLogLevel: IoTClientTypes.LogLevel?
    let disableAllLogs: Swift.Bool?
}

extension SetV2LoggingOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLogLevel
        case disableAllLogs
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(IoTClientTypes.LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let disableAllLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableAllLogs)
        disableAllLogs = disableAllLogsDecoded
    }
}

extension SetV2LoggingOptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SetV2LoggingOptionsOutput: Swift.Equatable {

    public init() { }
}

enum SetV2LoggingOptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.SigV4Authorization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case serviceName
        case signingRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let signingRegion = self.signingRegion {
            try encodeContainer.encode(signingRegion, forKey: .signingRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingRegion)
        signingRegion = signingRegionDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTClientTypes {
    /// For more information, see [Signature Version 4 signing process](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html).
    public struct SigV4Authorization: Swift.Equatable {
        /// The ARN of the signing role.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The service name to use while signing with Sig V4.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The signing region.
        /// This member is required.
        public var signingRegion: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            signingRegion: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.serviceName = serviceName
            self.signingRegion = signingRegion
        }
    }

}

extension IoTClientTypes.SigningProfileParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificatePathOnDevice
        case platform
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificatePathOnDevice = self.certificatePathOnDevice {
            try encodeContainer.encode(certificatePathOnDevice, forKey: .certificatePathOnDevice)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let certificatePathOnDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePathOnDevice)
        certificatePathOnDevice = certificatePathOnDeviceDecoded
    }
}

extension IoTClientTypes {
    /// Describes the code-signing profile.
    public struct SigningProfileParameter: Swift.Equatable {
        /// Certificate ARN.
        public var certificateArn: Swift.String?
        /// The location of the code-signing certificate on your device.
        public var certificatePathOnDevice: Swift.String?
        /// The hardware platform of your device.
        public var platform: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            certificatePathOnDevice: Swift.String? = nil,
            platform: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificatePathOnDevice = certificatePathOnDevice
            self.platform = platform
        }
    }

}

extension IoTClientTypes.SnsAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageFormat
        case roleArn
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageFormat = self.messageFormat {
            try encodeContainer.encode(messageFormat.rawValue, forKey: .messageFormat)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MessageFormat.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
    }
}

extension IoTClientTypes {
    /// Describes an action to publish to an Amazon SNS topic.
    public struct SnsAction: Swift.Equatable {
        /// (Optional) The message format of the message to publish. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. To read more about SNS message formats, see [https://docs.aws.amazon.com/sns/latest/dg/json-formats.html](https://docs.aws.amazon.com/sns/latest/dg/json-formats.html) refer to their official documentation.
        public var messageFormat: IoTClientTypes.MessageFormat?
        /// The ARN of the IAM role that grants access.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ARN of the SNS topic.
        /// This member is required.
        public var targetArn: Swift.String?

        public init(
            messageFormat: IoTClientTypes.MessageFormat? = nil,
            roleArn: Swift.String? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.messageFormat = messageFormat
            self.roleArn = roleArn
            self.targetArn = targetArn
        }
    }

}

extension SqlParseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SqlParseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Rule-SQL expression can't be parsed correctly.
public struct SqlParseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SqlParseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SqlParseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SqlParseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes.SqsAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueUrl
        case roleArn
        case useBase64
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queueUrl = self.queueUrl {
            try encodeContainer.encode(queueUrl, forKey: .queueUrl)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let useBase64 = self.useBase64 {
            try encodeContainer.encode(useBase64, forKey: .useBase64)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let queueUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueUrl)
        queueUrl = queueUrlDecoded
        let useBase64Decoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useBase64)
        useBase64 = useBase64Decoded
    }
}

extension IoTClientTypes {
    /// Describes an action to publish data to an Amazon SQS queue.
    public struct SqsAction: Swift.Equatable {
        /// The URL of the Amazon SQS queue.
        /// This member is required.
        public var queueUrl: Swift.String?
        /// The ARN of the IAM role that grants access.
        /// This member is required.
        public var roleArn: Swift.String?
        /// Specifies whether to use Base64 encoding.
        public var useBase64: Swift.Bool?

        public init(
            queueUrl: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            useBase64: Swift.Bool? = nil
        )
        {
            self.queueUrl = queueUrl
            self.roleArn = roleArn
            self.useBase64 = useBase64
        }
    }

}

extension StartAuditMitigationActionsTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditCheckToActionsMapping
        case clientRequestToken
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditCheckToActionsMapping = auditCheckToActionsMapping {
            var auditCheckToActionsMappingContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .auditCheckToActionsMapping)
            for (dictKey0, auditCheckToActionsMapping0) in auditCheckToActionsMapping {
                var auditCheckToActionsMapping0Container = auditCheckToActionsMappingContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for mitigationactionname1 in auditCheckToActionsMapping0 {
                    try auditCheckToActionsMapping0Container.encode(mitigationactionname1)
                }
            }
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension StartAuditMitigationActionsTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/audit/mitigationactions/tasks/\(taskId.urlPercentEncoding())"
    }
}

public struct StartAuditMitigationActionsTaskInput: Swift.Equatable {
    /// For an audit check, specifies which mitigation actions to apply. Those actions must be defined in your Amazon Web Services accounts.
    /// This member is required.
    public var auditCheckToActionsMapping: [Swift.String:[Swift.String]]?
    /// Each audit mitigation task must have a unique client request token. If you try to start a new task with the same token as a task that already exists, an exception occurs. If you omit this value, a unique client request token is generated automatically.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Specifies the audit findings to which the mitigation actions are applied. You can apply them to a type of audit check, to all findings from an audit, or to a specific set of findings.
    /// This member is required.
    public var target: IoTClientTypes.AuditMitigationActionsTaskTarget?
    /// A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        auditCheckToActionsMapping: [Swift.String:[Swift.String]]? = nil,
        clientRequestToken: Swift.String? = nil,
        target: IoTClientTypes.AuditMitigationActionsTaskTarget? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.auditCheckToActionsMapping = auditCheckToActionsMapping
        self.clientRequestToken = clientRequestToken
        self.target = target
        self.taskId = taskId
    }
}

struct StartAuditMitigationActionsTaskInputBody: Swift.Equatable {
    let target: IoTClientTypes.AuditMitigationActionsTaskTarget?
    let auditCheckToActionsMapping: [Swift.String:[Swift.String]]?
    let clientRequestToken: Swift.String?
}

extension StartAuditMitigationActionsTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditCheckToActionsMapping
        case clientRequestToken
        case target
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditMitigationActionsTaskTarget.self, forKey: .target)
        target = targetDecoded
        let auditCheckToActionsMappingContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .auditCheckToActionsMapping)
        var auditCheckToActionsMappingDecoded0: [Swift.String:[Swift.String]]? = nil
        if let auditCheckToActionsMappingContainer = auditCheckToActionsMappingContainer {
            auditCheckToActionsMappingDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, mitigationactionnamelist0) in auditCheckToActionsMappingContainer {
                var mitigationactionnamelist0Decoded0: [Swift.String]? = nil
                if let mitigationactionnamelist0 = mitigationactionnamelist0 {
                    mitigationactionnamelist0Decoded0 = [Swift.String]()
                    for string1 in mitigationactionnamelist0 {
                        if let string1 = string1 {
                            mitigationactionnamelist0Decoded0?.append(string1)
                        }
                    }
                }
                auditCheckToActionsMappingDecoded0?[key0] = mitigationactionnamelist0Decoded0
            }
        }
        auditCheckToActionsMapping = auditCheckToActionsMappingDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartAuditMitigationActionsTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartAuditMitigationActionsTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.taskId = output.taskId
        } else {
            self.taskId = nil
        }
    }
}

public struct StartAuditMitigationActionsTaskOutput: Swift.Equatable {
    /// The unique identifier for the audit mitigation task. This matches the taskId that you specified in the request.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct StartAuditMitigationActionsTaskOutputBody: Swift.Equatable {
    let taskId: Swift.String?
}

extension StartAuditMitigationActionsTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

enum StartAuditMitigationActionsTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TaskAlreadyExistsException": return try await TaskAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartDetectMitigationActionsTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case clientRequestToken
        case includeOnlyActiveViolations
        case includeSuppressedAlerts
        case target
        case violationEventOccurrenceRange
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for mitigationactionname0 in actions {
                try actionsContainer.encode(mitigationactionname0)
            }
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let includeOnlyActiveViolations = self.includeOnlyActiveViolations {
            try encodeContainer.encode(includeOnlyActiveViolations, forKey: .includeOnlyActiveViolations)
        }
        if let includeSuppressedAlerts = self.includeSuppressedAlerts {
            try encodeContainer.encode(includeSuppressedAlerts, forKey: .includeSuppressedAlerts)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let violationEventOccurrenceRange = self.violationEventOccurrenceRange {
            try encodeContainer.encode(violationEventOccurrenceRange, forKey: .violationEventOccurrenceRange)
        }
    }
}

extension StartDetectMitigationActionsTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/detect/mitigationactions/tasks/\(taskId.urlPercentEncoding())"
    }
}

public struct StartDetectMitigationActionsTaskInput: Swift.Equatable {
    /// The actions to be performed when a device has unexpected behavior.
    /// This member is required.
    public var actions: [Swift.String]?
    /// Each mitigation action task must have a unique client request token. If you try to create a new task with the same token as a task that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Specifies to list only active violations.
    public var includeOnlyActiveViolations: Swift.Bool?
    /// Specifies to include suppressed alerts.
    public var includeSuppressedAlerts: Swift.Bool?
    /// Specifies the ML Detect findings to which the mitigation actions are applied.
    /// This member is required.
    public var target: IoTClientTypes.DetectMitigationActionsTaskTarget?
    /// The unique identifier of the task.
    /// This member is required.
    public var taskId: Swift.String?
    /// Specifies the time period of which violation events occurred between.
    public var violationEventOccurrenceRange: IoTClientTypes.ViolationEventOccurrenceRange?

    public init(
        actions: [Swift.String]? = nil,
        clientRequestToken: Swift.String? = nil,
        includeOnlyActiveViolations: Swift.Bool? = nil,
        includeSuppressedAlerts: Swift.Bool? = nil,
        target: IoTClientTypes.DetectMitigationActionsTaskTarget? = nil,
        taskId: Swift.String? = nil,
        violationEventOccurrenceRange: IoTClientTypes.ViolationEventOccurrenceRange? = nil
    )
    {
        self.actions = actions
        self.clientRequestToken = clientRequestToken
        self.includeOnlyActiveViolations = includeOnlyActiveViolations
        self.includeSuppressedAlerts = includeSuppressedAlerts
        self.target = target
        self.taskId = taskId
        self.violationEventOccurrenceRange = violationEventOccurrenceRange
    }
}

struct StartDetectMitigationActionsTaskInputBody: Swift.Equatable {
    let target: IoTClientTypes.DetectMitigationActionsTaskTarget?
    let actions: [Swift.String]?
    let violationEventOccurrenceRange: IoTClientTypes.ViolationEventOccurrenceRange?
    let includeOnlyActiveViolations: Swift.Bool?
    let includeSuppressedAlerts: Swift.Bool?
    let clientRequestToken: Swift.String?
}

extension StartDetectMitigationActionsTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case clientRequestToken
        case includeOnlyActiveViolations
        case includeSuppressedAlerts
        case target
        case violationEventOccurrenceRange
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DetectMitigationActionsTaskTarget.self, forKey: .target)
        target = targetDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let violationEventOccurrenceRangeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ViolationEventOccurrenceRange.self, forKey: .violationEventOccurrenceRange)
        violationEventOccurrenceRange = violationEventOccurrenceRangeDecoded
        let includeOnlyActiveViolationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeOnlyActiveViolations)
        includeOnlyActiveViolations = includeOnlyActiveViolationsDecoded
        let includeSuppressedAlertsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeSuppressedAlerts)
        includeSuppressedAlerts = includeSuppressedAlertsDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartDetectMitigationActionsTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartDetectMitigationActionsTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.taskId = output.taskId
        } else {
            self.taskId = nil
        }
    }
}

public struct StartDetectMitigationActionsTaskOutput: Swift.Equatable {
    /// The unique identifier of the task.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct StartDetectMitigationActionsTaskOutputBody: Swift.Equatable {
    let taskId: Swift.String?
}

extension StartDetectMitigationActionsTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

enum StartDetectMitigationActionsTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TaskAlreadyExistsException": return try await TaskAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartOnDemandAuditTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetCheckNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetCheckNames = targetCheckNames {
            var targetCheckNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetCheckNames)
            for auditcheckname0 in targetCheckNames {
                try targetCheckNamesContainer.encode(auditcheckname0)
            }
        }
    }
}

extension StartOnDemandAuditTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/tasks"
    }
}

public struct StartOnDemandAuditTaskInput: Swift.Equatable {
    /// Which checks are performed during the audit. The checks you specify must be enabled for your account or an exception occurs. Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or UpdateAccountAuditConfiguration to select which checks are enabled.
    /// This member is required.
    public var targetCheckNames: [Swift.String]?

    public init(
        targetCheckNames: [Swift.String]? = nil
    )
    {
        self.targetCheckNames = targetCheckNames
    }
}

struct StartOnDemandAuditTaskInputBody: Swift.Equatable {
    let targetCheckNames: [Swift.String]?
}

extension StartOnDemandAuditTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetCheckNames
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetCheckNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetCheckNames)
        var targetCheckNamesDecoded0:[Swift.String]? = nil
        if let targetCheckNamesContainer = targetCheckNamesContainer {
            targetCheckNamesDecoded0 = [Swift.String]()
            for string0 in targetCheckNamesContainer {
                if let string0 = string0 {
                    targetCheckNamesDecoded0?.append(string0)
                }
            }
        }
        targetCheckNames = targetCheckNamesDecoded0
    }
}

extension StartOnDemandAuditTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartOnDemandAuditTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.taskId = output.taskId
        } else {
            self.taskId = nil
        }
    }
}

public struct StartOnDemandAuditTaskOutput: Swift.Equatable {
    /// The ID of the on-demand audit you started.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct StartOnDemandAuditTaskOutputBody: Swift.Equatable {
    let taskId: Swift.String?
}

extension StartOnDemandAuditTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

enum StartOnDemandAuditTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.StartSigningJobParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case signingProfileName
        case signingProfileParameter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let signingProfileName = self.signingProfileName {
            try encodeContainer.encode(signingProfileName, forKey: .signingProfileName)
        }
        if let signingProfileParameter = self.signingProfileParameter {
            try encodeContainer.encode(signingProfileParameter, forKey: .signingProfileParameter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingProfileParameterDecoded = try containerValues.decodeIfPresent(IoTClientTypes.SigningProfileParameter.self, forKey: .signingProfileParameter)
        signingProfileParameter = signingProfileParameterDecoded
        let signingProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingProfileName)
        signingProfileName = signingProfileNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension IoTClientTypes {
    /// Information required to start a signing job.
    public struct StartSigningJobParameter: Swift.Equatable {
        /// The location to write the code-signed file.
        public var destination: IoTClientTypes.Destination?
        /// The code-signing profile name.
        public var signingProfileName: Swift.String?
        /// Describes the code-signing profile.
        public var signingProfileParameter: IoTClientTypes.SigningProfileParameter?

        public init(
            destination: IoTClientTypes.Destination? = nil,
            signingProfileName: Swift.String? = nil,
            signingProfileParameter: IoTClientTypes.SigningProfileParameter? = nil
        )
        {
            self.destination = destination
            self.signingProfileName = signingProfileName
            self.signingProfileParameter = signingProfileParameter
        }
    }

}

extension StartThingRegistrationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputFileBucket
        case inputFileKey
        case roleArn
        case templateBody
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputFileBucket = self.inputFileBucket {
            try encodeContainer.encode(inputFileBucket, forKey: .inputFileBucket)
        }
        if let inputFileKey = self.inputFileKey {
            try encodeContainer.encode(inputFileKey, forKey: .inputFileKey)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let templateBody = self.templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
    }
}

extension StartThingRegistrationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/thing-registration-tasks"
    }
}

public struct StartThingRegistrationTaskInput: Swift.Equatable {
    /// The S3 bucket that contains the input file.
    /// This member is required.
    public var inputFileBucket: Swift.String?
    /// The name of input file within the S3 bucket. This file contains a newline delimited JSON file. Each line contains the parameter values to provision one device (thing).
    /// This member is required.
    public var inputFileKey: Swift.String?
    /// The IAM role ARN that grants permission the input file.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The provisioning template.
    /// This member is required.
    public var templateBody: Swift.String?

    public init(
        inputFileBucket: Swift.String? = nil,
        inputFileKey: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        templateBody: Swift.String? = nil
    )
    {
        self.inputFileBucket = inputFileBucket
        self.inputFileKey = inputFileKey
        self.roleArn = roleArn
        self.templateBody = templateBody
    }
}

struct StartThingRegistrationTaskInputBody: Swift.Equatable {
    let templateBody: Swift.String?
    let inputFileBucket: Swift.String?
    let inputFileKey: Swift.String?
    let roleArn: Swift.String?
}

extension StartThingRegistrationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputFileBucket
        case inputFileKey
        case roleArn
        case templateBody
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let inputFileBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputFileBucket)
        inputFileBucket = inputFileBucketDecoded
        let inputFileKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputFileKey)
        inputFileKey = inputFileKeyDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension StartThingRegistrationTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartThingRegistrationTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.taskId = output.taskId
        } else {
            self.taskId = nil
        }
    }
}

public struct StartThingRegistrationTaskOutput: Swift.Equatable {
    /// The bulk thing provisioning task ID.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct StartThingRegistrationTaskOutputBody: Swift.Equatable {
    let taskId: Swift.String?
}

extension StartThingRegistrationTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

enum StartThingRegistrationTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.StatisticalThreshold: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statistic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statistic = self.statistic {
            try encodeContainer.encode(statistic, forKey: .statistic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statisticDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statistic)
        statistic = statisticDecoded
    }
}

extension IoTClientTypes {
    /// A statistical ranking (percentile) that indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
    public struct StatisticalThreshold: Swift.Equatable {
        /// The percentile that resolves to a threshold value by which compliance with a behavior is determined. Metrics are collected over the specified period (durationSeconds) from all reporting devices in your account and statistical ranks are calculated. Then, the measurements from a device are collected over the same period. If the accumulated measurements from the device fall above or below (comparisonOperator) the value associated with the percentile specified, then the device is considered to be in compliance with the behavior, otherwise a violation occurs.
        public var statistic: Swift.String?

        public init(
            statistic: Swift.String? = nil
        )
        {
            self.statistic = statistic
        }
    }

}

extension IoTClientTypes.Statistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case average
        case count
        case maximum
        case minimum
        case stdDeviation
        case sum
        case sumOfSquares
        case variance
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let average = self.average {
            try encodeContainer.encode(average, forKey: .average)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let maximum = self.maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let minimum = self.minimum {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
        if let stdDeviation = self.stdDeviation {
            try encodeContainer.encode(stdDeviation, forKey: .stdDeviation)
        }
        if let sum = self.sum {
            try encodeContainer.encode(sum, forKey: .sum)
        }
        if let sumOfSquares = self.sumOfSquares {
            try encodeContainer.encode(sumOfSquares, forKey: .sumOfSquares)
        }
        if let variance = self.variance {
            try encodeContainer.encode(variance, forKey: .variance)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let averageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .average)
        average = averageDecoded
        let sumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .sum)
        sum = sumDecoded
        let minimumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimum)
        minimum = minimumDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maximum)
        maximum = maximumDecoded
        let sumOfSquaresDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .sumOfSquares)
        sumOfSquares = sumOfSquaresDecoded
        let varianceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .variance)
        variance = varianceDecoded
        let stdDeviationDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .stdDeviation)
        stdDeviation = stdDeviationDecoded
    }
}

extension IoTClientTypes {
    /// A map of key-value pairs for all supported statistics. For issues with missing or unexpected values for this API, consult [ Fleet indexing troubleshooting guide](https://docs.aws.amazon.com/iot/latest/developerguide/fleet-indexing-troubleshooting.html).
    public struct Statistics: Swift.Equatable {
        /// The average of the aggregated field values.
        public var average: Swift.Double?
        /// The count of things that match the query string criteria and contain a valid aggregation field value.
        public var count: Swift.Int
        /// The maximum aggregated field value.
        public var maximum: Swift.Double?
        /// The minimum aggregated field value.
        public var minimum: Swift.Double?
        /// The standard deviation of the aggregated field values.
        public var stdDeviation: Swift.Double?
        /// The sum of the aggregated field values.
        public var sum: Swift.Double?
        /// The sum of the squares of the aggregated field values.
        public var sumOfSquares: Swift.Double?
        /// The variance of the aggregated field values.
        public var variance: Swift.Double?

        public init(
            average: Swift.Double? = nil,
            count: Swift.Int = 0,
            maximum: Swift.Double? = nil,
            minimum: Swift.Double? = nil,
            stdDeviation: Swift.Double? = nil,
            sum: Swift.Double? = nil,
            sumOfSquares: Swift.Double? = nil,
            variance: Swift.Double? = nil
        )
        {
            self.average = average
            self.count = count
            self.maximum = maximum
            self.minimum = minimum
            self.stdDeviation = stdDeviation
            self.sum = sum
            self.sumOfSquares = sumOfSquares
            self.variance = variance
        }
    }

}

extension IoTClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case failed
        case inprogress
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .inprogress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.StepFunctionsAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionNamePrefix
        case roleArn
        case stateMachineName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionNamePrefix = self.executionNamePrefix {
            try encodeContainer.encode(executionNamePrefix, forKey: .executionNamePrefix)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stateMachineName = self.stateMachineName {
            try encodeContainer.encode(stateMachineName, forKey: .stateMachineName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionNamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionNamePrefix)
        executionNamePrefix = executionNamePrefixDecoded
        let stateMachineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateMachineName)
        stateMachineName = stateMachineNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTClientTypes {
    /// Starts execution of a Step Functions state machine.
    public struct StepFunctionsAction: Swift.Equatable {
        /// (Optional) A name will be given to the state machine execution consisting of this prefix followed by a UUID. Step Functions automatically creates a unique name for each state machine execution if one is not provided.
        public var executionNamePrefix: Swift.String?
        /// The ARN of the role that grants IoT permission to start execution of a state machine ("Action":"states:StartExecution").
        /// This member is required.
        public var roleArn: Swift.String?
        /// The name of the Step Functions state machine whose execution will be started.
        /// This member is required.
        public var stateMachineName: Swift.String?

        public init(
            executionNamePrefix: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            stateMachineName: Swift.String? = nil
        )
        {
            self.executionNamePrefix = executionNamePrefix
            self.roleArn = roleArn
            self.stateMachineName = stateMachineName
        }
    }

}

extension StopThingRegistrationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/thing-registration-tasks/\(taskId.urlPercentEncoding())/cancel"
    }
}

public struct StopThingRegistrationTaskInput: Swift.Equatable {
    /// The bulk thing provisioning task ID.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct StopThingRegistrationTaskInputBody: Swift.Equatable {
}

extension StopThingRegistrationTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopThingRegistrationTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopThingRegistrationTaskOutput: Swift.Equatable {

    public init() { }
}

enum StopThingRegistrationTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.Stream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileId
        case streamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileId = self.fileId {
            try encodeContainer.encode(fileId, forKey: .fileId)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let fileIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileId)
        fileId = fileIdDecoded
    }
}

extension IoTClientTypes {
    /// Describes a group of files that can be streamed.
    public struct Stream: Swift.Equatable {
        /// The ID of a file associated with a stream.
        public var fileId: Swift.Int?
        /// The stream ID.
        public var streamId: Swift.String?

        public init(
            fileId: Swift.Int? = nil,
            streamId: Swift.String? = nil
        )
        {
            self.fileId = fileId
            self.streamId = streamId
        }
    }

}

extension IoTClientTypes.StreamFile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileId
        case s3Location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileId = self.fileId {
            try encodeContainer.encode(fileId, forKey: .fileId)
        }
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileId)
        fileId = fileIdDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension IoTClientTypes {
    /// Represents a file to stream.
    public struct StreamFile: Swift.Equatable {
        /// The file ID.
        public var fileId: Swift.Int?
        /// The location of the file in S3.
        public var s3Location: IoTClientTypes.S3Location?

        public init(
            fileId: Swift.Int? = nil,
            s3Location: IoTClientTypes.S3Location? = nil
        )
        {
            self.fileId = fileId
            self.s3Location = s3Location
        }
    }

}

extension IoTClientTypes.StreamInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case files
        case lastUpdatedAt
        case roleArn
        case streamArn
        case streamId
        case streamVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let files = files {
            var filesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .files)
            for streamfile0 in files {
                try filesContainer.encode(streamfile0)
            }
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let streamArn = self.streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let streamVersion = self.streamVersion {
            try encodeContainer.encode(streamVersion, forKey: .streamVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let streamVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .streamVersion)
        streamVersion = streamVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let filesContainer = try containerValues.decodeIfPresent([IoTClientTypes.StreamFile?].self, forKey: .files)
        var filesDecoded0:[IoTClientTypes.StreamFile]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [IoTClientTypes.StreamFile]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTClientTypes {
    /// Information about a stream.
    public struct StreamInfo: Swift.Equatable {
        /// The date when the stream was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the stream.
        public var description: Swift.String?
        /// The files to stream.
        public var files: [IoTClientTypes.StreamFile]?
        /// The date when the stream was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// An IAM role IoT assumes to access your S3 files.
        public var roleArn: Swift.String?
        /// The stream ARN.
        public var streamArn: Swift.String?
        /// The stream ID.
        public var streamId: Swift.String?
        /// The stream version.
        public var streamVersion: Swift.Int?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            files: [IoTClientTypes.StreamFile]? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            streamArn: Swift.String? = nil,
            streamId: Swift.String? = nil,
            streamVersion: Swift.Int? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.files = files
            self.lastUpdatedAt = lastUpdatedAt
            self.roleArn = roleArn
            self.streamArn = streamArn
            self.streamId = streamId
            self.streamVersion = streamVersion
        }
    }

}

extension IoTClientTypes.StreamSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case streamArn
        case streamId
        case streamVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let streamArn = self.streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let streamVersion = self.streamVersion {
            try encodeContainer.encode(streamVersion, forKey: .streamVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let streamVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .streamVersion)
        streamVersion = streamVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension IoTClientTypes {
    /// A summary of a stream.
    public struct StreamSummary: Swift.Equatable {
        /// A description of the stream.
        public var description: Swift.String?
        /// The stream ARN.
        public var streamArn: Swift.String?
        /// The stream ID.
        public var streamId: Swift.String?
        /// The stream version.
        public var streamVersion: Swift.Int?

        public init(
            description: Swift.String? = nil,
            streamArn: Swift.String? = nil,
            streamId: Swift.String? = nil,
            streamVersion: Swift.Int? = nil
        )
        {
            self.description = description
            self.streamArn = streamArn
            self.streamId = streamId
            self.streamVersion = streamVersion
        }
    }

}

extension IoTClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTClientTypes {
    /// A set of key/value pairs that are used to manage the resource.
    public struct Tag: Swift.Equatable {
        /// The tag's key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new or modified tags for the resource.
    /// This member is required.
    public var tags: [IoTClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [IoTClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [IoTClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes {
    public enum TargetSelection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case continuous
        case snapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetSelection] {
            return [
                .continuous,
                .snapshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .continuous: return "CONTINUOUS"
            case .snapshot: return "SNAPSHOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetSelection(rawValue: rawValue) ?? TargetSelection.sdkUnknown(rawValue)
        }
    }
}

extension TaskAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TaskAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception occurs if you attempt to start a task with the same task-id as an existing task but with a different clientRequestToken.
public struct TaskAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TaskAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TaskAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TaskAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes.TaskStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canceledChecks
        case compliantChecks
        case failedChecks
        case inProgressChecks
        case nonCompliantChecks
        case totalChecks
        case waitingForDataCollectionChecks
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canceledChecks = self.canceledChecks {
            try encodeContainer.encode(canceledChecks, forKey: .canceledChecks)
        }
        if let compliantChecks = self.compliantChecks {
            try encodeContainer.encode(compliantChecks, forKey: .compliantChecks)
        }
        if let failedChecks = self.failedChecks {
            try encodeContainer.encode(failedChecks, forKey: .failedChecks)
        }
        if let inProgressChecks = self.inProgressChecks {
            try encodeContainer.encode(inProgressChecks, forKey: .inProgressChecks)
        }
        if let nonCompliantChecks = self.nonCompliantChecks {
            try encodeContainer.encode(nonCompliantChecks, forKey: .nonCompliantChecks)
        }
        if let totalChecks = self.totalChecks {
            try encodeContainer.encode(totalChecks, forKey: .totalChecks)
        }
        if let waitingForDataCollectionChecks = self.waitingForDataCollectionChecks {
            try encodeContainer.encode(waitingForDataCollectionChecks, forKey: .waitingForDataCollectionChecks)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalChecksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalChecks)
        totalChecks = totalChecksDecoded
        let inProgressChecksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inProgressChecks)
        inProgressChecks = inProgressChecksDecoded
        let waitingForDataCollectionChecksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .waitingForDataCollectionChecks)
        waitingForDataCollectionChecks = waitingForDataCollectionChecksDecoded
        let compliantChecksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantChecks)
        compliantChecks = compliantChecksDecoded
        let nonCompliantChecksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nonCompliantChecks)
        nonCompliantChecks = nonCompliantChecksDecoded
        let failedChecksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedChecks)
        failedChecks = failedChecksDecoded
        let canceledChecksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .canceledChecks)
        canceledChecks = canceledChecksDecoded
    }
}

extension IoTClientTypes {
    /// Statistics for the checks performed during the audit.
    public struct TaskStatistics: Swift.Equatable {
        /// The number of checks that did not run because the audit was canceled.
        public var canceledChecks: Swift.Int?
        /// The number of checks that found compliant resources.
        public var compliantChecks: Swift.Int?
        /// The number of checks.
        public var failedChecks: Swift.Int?
        /// The number of checks in progress.
        public var inProgressChecks: Swift.Int?
        /// The number of checks that found noncompliant resources.
        public var nonCompliantChecks: Swift.Int?
        /// The number of checks in this audit.
        public var totalChecks: Swift.Int?
        /// The number of checks waiting for data collection.
        public var waitingForDataCollectionChecks: Swift.Int?

        public init(
            canceledChecks: Swift.Int? = nil,
            compliantChecks: Swift.Int? = nil,
            failedChecks: Swift.Int? = nil,
            inProgressChecks: Swift.Int? = nil,
            nonCompliantChecks: Swift.Int? = nil,
            totalChecks: Swift.Int? = nil,
            waitingForDataCollectionChecks: Swift.Int? = nil
        )
        {
            self.canceledChecks = canceledChecks
            self.compliantChecks = compliantChecks
            self.failedChecks = failedChecks
            self.inProgressChecks = inProgressChecks
            self.nonCompliantChecks = nonCompliantChecks
            self.totalChecks = totalChecks
            self.waitingForDataCollectionChecks = waitingForDataCollectionChecks
        }
    }

}

extension IoTClientTypes.TaskStatisticsForAuditCheck: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canceledFindingsCount
        case failedFindingsCount
        case skippedFindingsCount
        case succeededFindingsCount
        case totalFindingsCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canceledFindingsCount = self.canceledFindingsCount {
            try encodeContainer.encode(canceledFindingsCount, forKey: .canceledFindingsCount)
        }
        if let failedFindingsCount = self.failedFindingsCount {
            try encodeContainer.encode(failedFindingsCount, forKey: .failedFindingsCount)
        }
        if let skippedFindingsCount = self.skippedFindingsCount {
            try encodeContainer.encode(skippedFindingsCount, forKey: .skippedFindingsCount)
        }
        if let succeededFindingsCount = self.succeededFindingsCount {
            try encodeContainer.encode(succeededFindingsCount, forKey: .succeededFindingsCount)
        }
        if let totalFindingsCount = self.totalFindingsCount {
            try encodeContainer.encode(totalFindingsCount, forKey: .totalFindingsCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalFindingsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalFindingsCount)
        totalFindingsCount = totalFindingsCountDecoded
        let failedFindingsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedFindingsCount)
        failedFindingsCount = failedFindingsCountDecoded
        let succeededFindingsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .succeededFindingsCount)
        succeededFindingsCount = succeededFindingsCountDecoded
        let skippedFindingsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .skippedFindingsCount)
        skippedFindingsCount = skippedFindingsCountDecoded
        let canceledFindingsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .canceledFindingsCount)
        canceledFindingsCount = canceledFindingsCountDecoded
    }
}

extension IoTClientTypes {
    /// Provides summary counts of how many tasks for findings are in a particular state. This information is included in the response from DescribeAuditMitigationActionsTask.
    public struct TaskStatisticsForAuditCheck: Swift.Equatable {
        /// The number of findings to which the mitigation action task was canceled when applied.
        public var canceledFindingsCount: Swift.Int?
        /// The number of findings for which at least one of the actions failed when applied.
        public var failedFindingsCount: Swift.Int?
        /// The number of findings skipped because of filter conditions provided in the parameters to the command.
        public var skippedFindingsCount: Swift.Int?
        /// The number of findings for which all mitigation actions succeeded when applied.
        public var succeededFindingsCount: Swift.Int?
        /// The total number of findings to which a task is being applied.
        public var totalFindingsCount: Swift.Int?

        public init(
            canceledFindingsCount: Swift.Int? = nil,
            failedFindingsCount: Swift.Int? = nil,
            skippedFindingsCount: Swift.Int? = nil,
            succeededFindingsCount: Swift.Int? = nil,
            totalFindingsCount: Swift.Int? = nil
        )
        {
            self.canceledFindingsCount = canceledFindingsCount
            self.failedFindingsCount = failedFindingsCount
            self.skippedFindingsCount = skippedFindingsCount
            self.succeededFindingsCount = succeededFindingsCount
            self.totalFindingsCount = totalFindingsCount
        }
    }

}

extension IoTClientTypes {
    public enum TemplateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fleetProvisioning
        case jitp
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateType] {
            return [
                .fleetProvisioning,
                .jitp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fleetProvisioning: return "FLEET_PROVISIONING"
            case .jitp: return "JITP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateType(rawValue: rawValue) ?? TemplateType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.TermsAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxBuckets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxBuckets != 0 {
            try encodeContainer.encode(maxBuckets, forKey: .maxBuckets)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxBucketsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBuckets) ?? 0
        maxBuckets = maxBucketsDecoded
    }
}

extension IoTClientTypes {
    /// Performs an aggregation that will return a list of buckets. The list of buckets is a ranked list of the number of occurrences of an aggregation field value.
    public struct TermsAggregation: Swift.Equatable {
        /// The number of buckets to return in the response. Default to 10.
        public var maxBuckets: Swift.Int

        public init(
            maxBuckets: Swift.Int = 0
        )
        {
            self.maxBuckets = maxBuckets
        }
    }

}

extension TestAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authInfos
        case cognitoIdentityPoolId
        case policyNamesToAdd
        case policyNamesToSkip
        case principal
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authInfos = authInfos {
            var authInfosContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authInfos)
            for authinfo0 in authInfos {
                try authInfosContainer.encode(authinfo0)
            }
        }
        if let cognitoIdentityPoolId = self.cognitoIdentityPoolId {
            try encodeContainer.encode(cognitoIdentityPoolId, forKey: .cognitoIdentityPoolId)
        }
        if let policyNamesToAdd = policyNamesToAdd {
            var policyNamesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyNamesToAdd)
            for policyname0 in policyNamesToAdd {
                try policyNamesToAddContainer.encode(policyname0)
            }
        }
        if let policyNamesToSkip = policyNamesToSkip {
            var policyNamesToSkipContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyNamesToSkip)
            for policyname0 in policyNamesToSkip {
                try policyNamesToSkipContainer.encode(policyname0)
            }
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
    }
}

extension TestAuthorizationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientId = clientId {
                let clientIdQueryItem = ClientRuntime.URLQueryItem(name: "clientId".urlPercentEncoding(), value: Swift.String(clientId).urlPercentEncoding())
                items.append(clientIdQueryItem)
            }
            return items
        }
    }
}

extension TestAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/test-authorization"
    }
}

public struct TestAuthorizationInput: Swift.Equatable {
    /// A list of authorization info objects. Simulating authorization will create a response for each authInfo object in the list.
    /// This member is required.
    public var authInfos: [IoTClientTypes.AuthInfo]?
    /// The MQTT client ID.
    public var clientId: Swift.String?
    /// The Cognito identity pool ID.
    public var cognitoIdentityPoolId: Swift.String?
    /// When testing custom authorization, the policies specified here are treated as if they are attached to the principal being authorized.
    public var policyNamesToAdd: [Swift.String]?
    /// When testing custom authorization, the policies specified here are treated as if they are not attached to the principal being authorized.
    public var policyNamesToSkip: [Swift.String]?
    /// The principal. Valid principals are CertificateArn (arn:aws:iot:region:accountId:cert/certificateId), thingGroupArn (arn:aws:iot:region:accountId:thinggroup/groupName) and CognitoId (region:id).
    public var principal: Swift.String?

    public init(
        authInfos: [IoTClientTypes.AuthInfo]? = nil,
        clientId: Swift.String? = nil,
        cognitoIdentityPoolId: Swift.String? = nil,
        policyNamesToAdd: [Swift.String]? = nil,
        policyNamesToSkip: [Swift.String]? = nil,
        principal: Swift.String? = nil
    )
    {
        self.authInfos = authInfos
        self.clientId = clientId
        self.cognitoIdentityPoolId = cognitoIdentityPoolId
        self.policyNamesToAdd = policyNamesToAdd
        self.policyNamesToSkip = policyNamesToSkip
        self.principal = principal
    }
}

struct TestAuthorizationInputBody: Swift.Equatable {
    let principal: Swift.String?
    let cognitoIdentityPoolId: Swift.String?
    let authInfos: [IoTClientTypes.AuthInfo]?
    let policyNamesToAdd: [Swift.String]?
    let policyNamesToSkip: [Swift.String]?
}

extension TestAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authInfos
        case cognitoIdentityPoolId
        case policyNamesToAdd
        case policyNamesToSkip
        case principal
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let cognitoIdentityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cognitoIdentityPoolId)
        cognitoIdentityPoolId = cognitoIdentityPoolIdDecoded
        let authInfosContainer = try containerValues.decodeIfPresent([IoTClientTypes.AuthInfo?].self, forKey: .authInfos)
        var authInfosDecoded0:[IoTClientTypes.AuthInfo]? = nil
        if let authInfosContainer = authInfosContainer {
            authInfosDecoded0 = [IoTClientTypes.AuthInfo]()
            for structure0 in authInfosContainer {
                if let structure0 = structure0 {
                    authInfosDecoded0?.append(structure0)
                }
            }
        }
        authInfos = authInfosDecoded0
        let policyNamesToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .policyNamesToAdd)
        var policyNamesToAddDecoded0:[Swift.String]? = nil
        if let policyNamesToAddContainer = policyNamesToAddContainer {
            policyNamesToAddDecoded0 = [Swift.String]()
            for string0 in policyNamesToAddContainer {
                if let string0 = string0 {
                    policyNamesToAddDecoded0?.append(string0)
                }
            }
        }
        policyNamesToAdd = policyNamesToAddDecoded0
        let policyNamesToSkipContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .policyNamesToSkip)
        var policyNamesToSkipDecoded0:[Swift.String]? = nil
        if let policyNamesToSkipContainer = policyNamesToSkipContainer {
            policyNamesToSkipDecoded0 = [Swift.String]()
            for string0 in policyNamesToSkipContainer {
                if let string0 = string0 {
                    policyNamesToSkipDecoded0?.append(string0)
                }
            }
        }
        policyNamesToSkip = policyNamesToSkipDecoded0
    }
}

extension TestAuthorizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestAuthorizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.authResults = output.authResults
        } else {
            self.authResults = nil
        }
    }
}

public struct TestAuthorizationOutput: Swift.Equatable {
    /// The authentication results.
    public var authResults: [IoTClientTypes.AuthResult]?

    public init(
        authResults: [IoTClientTypes.AuthResult]? = nil
    )
    {
        self.authResults = authResults
    }
}

struct TestAuthorizationOutputBody: Swift.Equatable {
    let authResults: [IoTClientTypes.AuthResult]?
}

extension TestAuthorizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authResults
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authResultsContainer = try containerValues.decodeIfPresent([IoTClientTypes.AuthResult?].self, forKey: .authResults)
        var authResultsDecoded0:[IoTClientTypes.AuthResult]? = nil
        if let authResultsContainer = authResultsContainer {
            authResultsDecoded0 = [IoTClientTypes.AuthResult]()
            for structure0 in authResultsContainer {
                if let structure0 = structure0 {
                    authResultsDecoded0?.append(structure0)
                }
            }
        }
        authResults = authResultsDecoded0
    }
}

enum TestAuthorizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TestInvokeAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpContext
        case mqttContext
        case tlsContext
        case token
        case tokenSignature
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpContext = self.httpContext {
            try encodeContainer.encode(httpContext, forKey: .httpContext)
        }
        if let mqttContext = self.mqttContext {
            try encodeContainer.encode(mqttContext, forKey: .mqttContext)
        }
        if let tlsContext = self.tlsContext {
            try encodeContainer.encode(tlsContext, forKey: .tlsContext)
        }
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let tokenSignature = self.tokenSignature {
            try encodeContainer.encode(tokenSignature, forKey: .tokenSignature)
        }
    }
}

extension TestInvokeAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let authorizerName = authorizerName else {
            return nil
        }
        return "/authorizer/\(authorizerName.urlPercentEncoding())/test"
    }
}

public struct TestInvokeAuthorizerInput: Swift.Equatable {
    /// The custom authorizer name.
    /// This member is required.
    public var authorizerName: Swift.String?
    /// Specifies a test HTTP authorization request.
    public var httpContext: IoTClientTypes.HttpContext?
    /// Specifies a test MQTT authorization request.
    public var mqttContext: IoTClientTypes.MqttContext?
    /// Specifies a test TLS authorization request.
    public var tlsContext: IoTClientTypes.TlsContext?
    /// The token returned by your custom authentication service.
    public var token: Swift.String?
    /// The signature made with the token and your custom authentication service's private key. This value must be Base-64-encoded.
    public var tokenSignature: Swift.String?

    public init(
        authorizerName: Swift.String? = nil,
        httpContext: IoTClientTypes.HttpContext? = nil,
        mqttContext: IoTClientTypes.MqttContext? = nil,
        tlsContext: IoTClientTypes.TlsContext? = nil,
        token: Swift.String? = nil,
        tokenSignature: Swift.String? = nil
    )
    {
        self.authorizerName = authorizerName
        self.httpContext = httpContext
        self.mqttContext = mqttContext
        self.tlsContext = tlsContext
        self.token = token
        self.tokenSignature = tokenSignature
    }
}

struct TestInvokeAuthorizerInputBody: Swift.Equatable {
    let token: Swift.String?
    let tokenSignature: Swift.String?
    let httpContext: IoTClientTypes.HttpContext?
    let mqttContext: IoTClientTypes.MqttContext?
    let tlsContext: IoTClientTypes.TlsContext?
}

extension TestInvokeAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpContext
        case mqttContext
        case tlsContext
        case token
        case tokenSignature
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let tokenSignatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenSignature)
        tokenSignature = tokenSignatureDecoded
        let httpContextDecoded = try containerValues.decodeIfPresent(IoTClientTypes.HttpContext.self, forKey: .httpContext)
        httpContext = httpContextDecoded
        let mqttContextDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MqttContext.self, forKey: .mqttContext)
        mqttContext = mqttContextDecoded
        let tlsContextDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TlsContext.self, forKey: .tlsContext)
        tlsContext = tlsContextDecoded
    }
}

extension TestInvokeAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestInvokeAuthorizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.disconnectAfterInSeconds = output.disconnectAfterInSeconds
            self.isAuthenticated = output.isAuthenticated
            self.policyDocuments = output.policyDocuments
            self.principalId = output.principalId
            self.refreshAfterInSeconds = output.refreshAfterInSeconds
        } else {
            self.disconnectAfterInSeconds = nil
            self.isAuthenticated = nil
            self.policyDocuments = nil
            self.principalId = nil
            self.refreshAfterInSeconds = nil
        }
    }
}

public struct TestInvokeAuthorizerOutput: Swift.Equatable {
    /// The number of seconds after which the connection is terminated.
    public var disconnectAfterInSeconds: Swift.Int?
    /// True if the token is authenticated, otherwise false.
    public var isAuthenticated: Swift.Bool?
    /// IAM policy documents.
    public var policyDocuments: [Swift.String]?
    /// The principal ID.
    public var principalId: Swift.String?
    /// The number of seconds after which the temporary credentials are refreshed.
    public var refreshAfterInSeconds: Swift.Int?

    public init(
        disconnectAfterInSeconds: Swift.Int? = nil,
        isAuthenticated: Swift.Bool? = nil,
        policyDocuments: [Swift.String]? = nil,
        principalId: Swift.String? = nil,
        refreshAfterInSeconds: Swift.Int? = nil
    )
    {
        self.disconnectAfterInSeconds = disconnectAfterInSeconds
        self.isAuthenticated = isAuthenticated
        self.policyDocuments = policyDocuments
        self.principalId = principalId
        self.refreshAfterInSeconds = refreshAfterInSeconds
    }
}

struct TestInvokeAuthorizerOutputBody: Swift.Equatable {
    let isAuthenticated: Swift.Bool?
    let principalId: Swift.String?
    let policyDocuments: [Swift.String]?
    let refreshAfterInSeconds: Swift.Int?
    let disconnectAfterInSeconds: Swift.Int?
}

extension TestInvokeAuthorizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disconnectAfterInSeconds
        case isAuthenticated
        case policyDocuments
        case principalId
        case refreshAfterInSeconds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isAuthenticatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAuthenticated)
        isAuthenticated = isAuthenticatedDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let policyDocumentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .policyDocuments)
        var policyDocumentsDecoded0:[Swift.String]? = nil
        if let policyDocumentsContainer = policyDocumentsContainer {
            policyDocumentsDecoded0 = [Swift.String]()
            for string0 in policyDocumentsContainer {
                if let string0 = string0 {
                    policyDocumentsDecoded0?.append(string0)
                }
            }
        }
        policyDocuments = policyDocumentsDecoded0
        let refreshAfterInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .refreshAfterInSeconds)
        refreshAfterInSeconds = refreshAfterInSecondsDecoded
        let disconnectAfterInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectAfterInSeconds)
        disconnectAfterInSeconds = disconnectAfterInSecondsDecoded
    }
}

enum TestInvokeAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResponseException": return try await InvalidResponseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.ThingAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case thingArn
        case thingName
        case thingTypeName
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
        if let thingTypeName = self.thingTypeName {
            try encodeContainer.encode(thingTypeName, forKey: .thingTypeName)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
    }
}

extension IoTClientTypes {
    /// The properties of the thing, including thing name, thing type name, and a list of thing attributes.
    public struct ThingAttribute: Swift.Equatable {
        /// A list of thing attributes which are name-value pairs.
        public var attributes: [Swift.String:Swift.String]?
        /// The thing ARN.
        public var thingArn: Swift.String?
        /// The name of the thing.
        public var thingName: Swift.String?
        /// The name of the thing type, if the thing has been associated with a type.
        public var thingTypeName: Swift.String?
        /// The version of the thing record in the registry.
        public var version: Swift.Int

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            thingArn: Swift.String? = nil,
            thingName: Swift.String? = nil,
            thingTypeName: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.attributes = attributes
            self.thingArn = thingArn
            self.thingName = thingName
            self.thingTypeName = thingTypeName
            self.version = version
        }
    }

}

extension IoTClientTypes.ThingConnectivity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connected
        case disconnectReason
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if connected != false {
            try encodeContainer.encode(connected, forKey: .connected)
        }
        if let disconnectReason = self.disconnectReason {
            try encodeContainer.encode(disconnectReason, forKey: .disconnectReason)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .connected) ?? false
        connected = connectedDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let disconnectReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disconnectReason)
        disconnectReason = disconnectReasonDecoded
    }
}

extension IoTClientTypes {
    /// The connectivity status of the thing.
    public struct ThingConnectivity: Swift.Equatable {
        /// True if the thing is connected to the Amazon Web Services IoT Core service; false if it is not connected.
        public var connected: Swift.Bool
        /// The reason why the client is disconnected. If the thing has been disconnected for approximately an hour, the disconnectReason value might be missing.
        public var disconnectReason: Swift.String?
        /// The epoch time (in milliseconds) when the thing last connected or disconnected. If the thing has been disconnected for approximately an hour, the time value might be missing.
        public var timestamp: Swift.Int?

        public init(
            connected: Swift.Bool = false,
            disconnectReason: Swift.String? = nil,
            timestamp: Swift.Int? = nil
        )
        {
            self.connected = connected
            self.disconnectReason = disconnectReason
            self.timestamp = timestamp
        }
    }

}

extension IoTClientTypes {
    public enum ThingConnectivityIndexingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [ThingConnectivityIndexingMode] {
            return [
                .off,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThingConnectivityIndexingMode(rawValue: rawValue) ?? ThingConnectivityIndexingMode.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.ThingDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case connectivity
        case deviceDefender
        case shadow
        case thingGroupNames
        case thingId
        case thingName
        case thingTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let connectivity = self.connectivity {
            try encodeContainer.encode(connectivity, forKey: .connectivity)
        }
        if let deviceDefender = self.deviceDefender {
            try encodeContainer.encode(deviceDefender, forKey: .deviceDefender)
        }
        if let shadow = self.shadow {
            try encodeContainer.encode(shadow, forKey: .shadow)
        }
        if let thingGroupNames = thingGroupNames {
            var thingGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .thingGroupNames)
            for thinggroupname0 in thingGroupNames {
                try thingGroupNamesContainer.encode(thinggroupname0)
            }
        }
        if let thingId = self.thingId {
            try encodeContainer.encode(thingId, forKey: .thingId)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
        if let thingTypeName = self.thingTypeName {
            try encodeContainer.encode(thingTypeName, forKey: .thingTypeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingId)
        thingId = thingIdDecoded
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let thingGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .thingGroupNames)
        var thingGroupNamesDecoded0:[Swift.String]? = nil
        if let thingGroupNamesContainer = thingGroupNamesContainer {
            thingGroupNamesDecoded0 = [Swift.String]()
            for string0 in thingGroupNamesContainer {
                if let string0 = string0 {
                    thingGroupNamesDecoded0?.append(string0)
                }
            }
        }
        thingGroupNames = thingGroupNamesDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let shadowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shadow)
        shadow = shadowDecoded
        let deviceDefenderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceDefender)
        deviceDefender = deviceDefenderDecoded
        let connectivityDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingConnectivity.self, forKey: .connectivity)
        connectivity = connectivityDecoded
    }
}

extension IoTClientTypes {
    /// The thing search index document.
    public struct ThingDocument: Swift.Equatable {
        /// The attributes.
        public var attributes: [Swift.String:Swift.String]?
        /// Indicates whether the thing is connected to the Amazon Web Services IoT Core service.
        public var connectivity: IoTClientTypes.ThingConnectivity?
        /// Contains Device Defender data. For more information about Device Defender, see [Device Defender](https://docs.aws.amazon.com/iot/latest/developerguide/device-defender.html).
        public var deviceDefender: Swift.String?
        /// The unnamed shadow and named shadow. For more information about shadows, see [IoT Device Shadow service.](https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html)
        public var shadow: Swift.String?
        /// Thing group names.
        public var thingGroupNames: [Swift.String]?
        /// The thing ID.
        public var thingId: Swift.String?
        /// The thing name.
        public var thingName: Swift.String?
        /// The thing type name.
        public var thingTypeName: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            connectivity: IoTClientTypes.ThingConnectivity? = nil,
            deviceDefender: Swift.String? = nil,
            shadow: Swift.String? = nil,
            thingGroupNames: [Swift.String]? = nil,
            thingId: Swift.String? = nil,
            thingName: Swift.String? = nil,
            thingTypeName: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.connectivity = connectivity
            self.deviceDefender = deviceDefender
            self.shadow = shadow
            self.thingGroupNames = thingGroupNames
            self.thingId = thingId
            self.thingName = thingName
            self.thingTypeName = thingTypeName
        }
    }

}

extension IoTClientTypes.ThingGroupDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case parentGroupNames
        case thingGroupDescription
        case thingGroupId
        case thingGroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let parentGroupNames = parentGroupNames {
            var parentGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parentGroupNames)
            for thinggroupname0 in parentGroupNames {
                try parentGroupNamesContainer.encode(thinggroupname0)
            }
        }
        if let thingGroupDescription = self.thingGroupDescription {
            try encodeContainer.encode(thingGroupDescription, forKey: .thingGroupDescription)
        }
        if let thingGroupId = self.thingGroupId {
            try encodeContainer.encode(thingGroupId, forKey: .thingGroupId)
        }
        if let thingGroupName = self.thingGroupName {
            try encodeContainer.encode(thingGroupName, forKey: .thingGroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupName)
        thingGroupName = thingGroupNameDecoded
        let thingGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupId)
        thingGroupId = thingGroupIdDecoded
        let thingGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupDescription)
        thingGroupDescription = thingGroupDescriptionDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let parentGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentGroupNames)
        var parentGroupNamesDecoded0:[Swift.String]? = nil
        if let parentGroupNamesContainer = parentGroupNamesContainer {
            parentGroupNamesDecoded0 = [Swift.String]()
            for string0 in parentGroupNamesContainer {
                if let string0 = string0 {
                    parentGroupNamesDecoded0?.append(string0)
                }
            }
        }
        parentGroupNames = parentGroupNamesDecoded0
    }
}

extension IoTClientTypes {
    /// The thing group search index document.
    public struct ThingGroupDocument: Swift.Equatable {
        /// The thing group attributes.
        public var attributes: [Swift.String:Swift.String]?
        /// Parent group names.
        public var parentGroupNames: [Swift.String]?
        /// The thing group description.
        public var thingGroupDescription: Swift.String?
        /// The thing group ID.
        public var thingGroupId: Swift.String?
        /// The thing group name.
        public var thingGroupName: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            parentGroupNames: [Swift.String]? = nil,
            thingGroupDescription: Swift.String? = nil,
            thingGroupId: Swift.String? = nil,
            thingGroupName: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.parentGroupNames = parentGroupNames
            self.thingGroupDescription = thingGroupDescription
            self.thingGroupId = thingGroupId
            self.thingGroupName = thingGroupName
        }
    }

}

extension IoTClientTypes.ThingGroupIndexingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customFields
        case managedFields
        case thingGroupIndexingMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customFields = customFields {
            var customFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customFields)
            for field0 in customFields {
                try customFieldsContainer.encode(field0)
            }
        }
        if let managedFields = managedFields {
            var managedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedFields)
            for field0 in managedFields {
                try managedFieldsContainer.encode(field0)
            }
        }
        if let thingGroupIndexingMode = self.thingGroupIndexingMode {
            try encodeContainer.encode(thingGroupIndexingMode.rawValue, forKey: .thingGroupIndexingMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupIndexingModeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingGroupIndexingMode.self, forKey: .thingGroupIndexingMode)
        thingGroupIndexingMode = thingGroupIndexingModeDecoded
        let managedFieldsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Field?].self, forKey: .managedFields)
        var managedFieldsDecoded0:[IoTClientTypes.Field]? = nil
        if let managedFieldsContainer = managedFieldsContainer {
            managedFieldsDecoded0 = [IoTClientTypes.Field]()
            for structure0 in managedFieldsContainer {
                if let structure0 = structure0 {
                    managedFieldsDecoded0?.append(structure0)
                }
            }
        }
        managedFields = managedFieldsDecoded0
        let customFieldsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Field?].self, forKey: .customFields)
        var customFieldsDecoded0:[IoTClientTypes.Field]? = nil
        if let customFieldsContainer = customFieldsContainer {
            customFieldsDecoded0 = [IoTClientTypes.Field]()
            for structure0 in customFieldsContainer {
                if let structure0 = structure0 {
                    customFieldsDecoded0?.append(structure0)
                }
            }
        }
        customFields = customFieldsDecoded0
    }
}

extension IoTClientTypes {
    /// Thing group indexing configuration.
    public struct ThingGroupIndexingConfiguration: Swift.Equatable {
        /// A list of thing group fields to index. This list cannot contain any managed fields. Use the GetIndexingConfiguration API to get a list of managed fields. Contains custom field names and their data type.
        public var customFields: [IoTClientTypes.Field]?
        /// Contains fields that are indexed and whose types are already known by the Fleet Indexing service. This is an optional field. For more information, see [Managed fields](https://docs.aws.amazon.com/iot/latest/developerguide/managing-fleet-index.html#managed-field) in the Amazon Web Services IoT Core Developer Guide.
        public var managedFields: [IoTClientTypes.Field]?
        /// Thing group indexing mode.
        /// This member is required.
        public var thingGroupIndexingMode: IoTClientTypes.ThingGroupIndexingMode?

        public init(
            customFields: [IoTClientTypes.Field]? = nil,
            managedFields: [IoTClientTypes.Field]? = nil,
            thingGroupIndexingMode: IoTClientTypes.ThingGroupIndexingMode? = nil
        )
        {
            self.customFields = customFields
            self.managedFields = managedFields
            self.thingGroupIndexingMode = thingGroupIndexingMode
        }
    }

}

extension IoTClientTypes {
    public enum ThingGroupIndexingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [ThingGroupIndexingMode] {
            return [
                .off,
                .on,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .on: return "ON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThingGroupIndexingMode(rawValue: rawValue) ?? ThingGroupIndexingMode.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.ThingGroupMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case parentGroupName
        case rootToParentThingGroups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let parentGroupName = self.parentGroupName {
            try encodeContainer.encode(parentGroupName, forKey: .parentGroupName)
        }
        if let rootToParentThingGroups = rootToParentThingGroups {
            var rootToParentThingGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rootToParentThingGroups)
            for groupnameandarn0 in rootToParentThingGroups {
                try rootToParentThingGroupsContainer.encode(groupnameandarn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentGroupName)
        parentGroupName = parentGroupNameDecoded
        let rootToParentThingGroupsContainer = try containerValues.decodeIfPresent([IoTClientTypes.GroupNameAndArn?].self, forKey: .rootToParentThingGroups)
        var rootToParentThingGroupsDecoded0:[IoTClientTypes.GroupNameAndArn]? = nil
        if let rootToParentThingGroupsContainer = rootToParentThingGroupsContainer {
            rootToParentThingGroupsDecoded0 = [IoTClientTypes.GroupNameAndArn]()
            for structure0 in rootToParentThingGroupsContainer {
                if let structure0 = structure0 {
                    rootToParentThingGroupsDecoded0?.append(structure0)
                }
            }
        }
        rootToParentThingGroups = rootToParentThingGroupsDecoded0
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension IoTClientTypes {
    /// Thing group metadata.
    public struct ThingGroupMetadata: Swift.Equatable {
        /// The UNIX timestamp of when the thing group was created.
        public var creationDate: ClientRuntime.Date?
        /// The parent thing group name.
        public var parentGroupName: Swift.String?
        /// The root parent thing group.
        public var rootToParentThingGroups: [IoTClientTypes.GroupNameAndArn]?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            parentGroupName: Swift.String? = nil,
            rootToParentThingGroups: [IoTClientTypes.GroupNameAndArn]? = nil
        )
        {
            self.creationDate = creationDate
            self.parentGroupName = parentGroupName
            self.rootToParentThingGroups = rootToParentThingGroups
        }
    }

}

extension IoTClientTypes.ThingGroupProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributePayload
        case thingGroupDescription
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributePayload = self.attributePayload {
            try encodeContainer.encode(attributePayload, forKey: .attributePayload)
        }
        if let thingGroupDescription = self.thingGroupDescription {
            try encodeContainer.encode(thingGroupDescription, forKey: .thingGroupDescription)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingGroupDescription)
        thingGroupDescription = thingGroupDescriptionDecoded
        let attributePayloadDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AttributePayload.self, forKey: .attributePayload)
        attributePayload = attributePayloadDecoded
    }
}

extension IoTClientTypes {
    /// Thing group properties.
    public struct ThingGroupProperties: Swift.Equatable {
        /// The thing group attributes in JSON format.
        public var attributePayload: IoTClientTypes.AttributePayload?
        /// The thing group description.
        public var thingGroupDescription: Swift.String?

        public init(
            attributePayload: IoTClientTypes.AttributePayload? = nil,
            thingGroupDescription: Swift.String? = nil
        )
        {
            self.attributePayload = attributePayload
            self.thingGroupDescription = thingGroupDescription
        }
    }

}

extension IoTClientTypes.ThingIndexingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customFields
        case deviceDefenderIndexingMode
        case filter
        case managedFields
        case namedShadowIndexingMode
        case thingConnectivityIndexingMode
        case thingIndexingMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customFields = customFields {
            var customFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customFields)
            for field0 in customFields {
                try customFieldsContainer.encode(field0)
            }
        }
        if let deviceDefenderIndexingMode = self.deviceDefenderIndexingMode {
            try encodeContainer.encode(deviceDefenderIndexingMode.rawValue, forKey: .deviceDefenderIndexingMode)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let managedFields = managedFields {
            var managedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .managedFields)
            for field0 in managedFields {
                try managedFieldsContainer.encode(field0)
            }
        }
        if let namedShadowIndexingMode = self.namedShadowIndexingMode {
            try encodeContainer.encode(namedShadowIndexingMode.rawValue, forKey: .namedShadowIndexingMode)
        }
        if let thingConnectivityIndexingMode = self.thingConnectivityIndexingMode {
            try encodeContainer.encode(thingConnectivityIndexingMode.rawValue, forKey: .thingConnectivityIndexingMode)
        }
        if let thingIndexingMode = self.thingIndexingMode {
            try encodeContainer.encode(thingIndexingMode.rawValue, forKey: .thingIndexingMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingIndexingModeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingIndexingMode.self, forKey: .thingIndexingMode)
        thingIndexingMode = thingIndexingModeDecoded
        let thingConnectivityIndexingModeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingConnectivityIndexingMode.self, forKey: .thingConnectivityIndexingMode)
        thingConnectivityIndexingMode = thingConnectivityIndexingModeDecoded
        let deviceDefenderIndexingModeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DeviceDefenderIndexingMode.self, forKey: .deviceDefenderIndexingMode)
        deviceDefenderIndexingMode = deviceDefenderIndexingModeDecoded
        let namedShadowIndexingModeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.NamedShadowIndexingMode.self, forKey: .namedShadowIndexingMode)
        namedShadowIndexingMode = namedShadowIndexingModeDecoded
        let managedFieldsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Field?].self, forKey: .managedFields)
        var managedFieldsDecoded0:[IoTClientTypes.Field]? = nil
        if let managedFieldsContainer = managedFieldsContainer {
            managedFieldsDecoded0 = [IoTClientTypes.Field]()
            for structure0 in managedFieldsContainer {
                if let structure0 = structure0 {
                    managedFieldsDecoded0?.append(structure0)
                }
            }
        }
        managedFields = managedFieldsDecoded0
        let customFieldsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Field?].self, forKey: .customFields)
        var customFieldsDecoded0:[IoTClientTypes.Field]? = nil
        if let customFieldsContainer = customFieldsContainer {
            customFieldsDecoded0 = [IoTClientTypes.Field]()
            for structure0 in customFieldsContainer {
                if let structure0 = structure0 {
                    customFieldsDecoded0?.append(structure0)
                }
            }
        }
        customFields = customFieldsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(IoTClientTypes.IndexingFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension IoTClientTypes {
    /// The thing indexing configuration. For more information, see [Managing Thing Indexing](https://docs.aws.amazon.com/iot/latest/developerguide/managing-index.html).
    public struct ThingIndexingConfiguration: Swift.Equatable {
        /// Contains custom field names and their data type.
        public var customFields: [IoTClientTypes.Field]?
        /// Device Defender indexing mode. Valid values are:
        ///
        /// * VIOLATIONS  Your thing index contains Device Defender violations. To enable Device Defender indexing, deviceDefenderIndexingMode must not be set to OFF.
        ///
        /// * OFF - Device Defender indexing is disabled.
        ///
        ///
        /// For more information about Device Defender violations, see [Device Defender Detect.](https://docs.aws.amazon.com/iot/latest/developerguide/device-defender-detect.html)
        public var deviceDefenderIndexingMode: IoTClientTypes.DeviceDefenderIndexingMode?
        /// Provides additional filters for specific data sources. Named shadow is the only data source that currently supports and requires a filter. To add named shadows to your fleet indexing configuration, set namedShadowIndexingMode to be ON and specify your shadow names in filter.
        public var filter: IoTClientTypes.IndexingFilter?
        /// Contains fields that are indexed and whose types are already known by the Fleet Indexing service.
        public var managedFields: [IoTClientTypes.Field]?
        /// Named shadow indexing mode. Valid values are:
        ///
        /// * ON  Your thing index contains named shadow. To enable thing named shadow indexing, namedShadowIndexingMode must not be set to OFF.
        ///
        /// * OFF - Named shadow indexing is disabled.
        ///
        ///
        /// For more information about Shadows, see [IoT Device Shadow service.](https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html)
        public var namedShadowIndexingMode: IoTClientTypes.NamedShadowIndexingMode?
        /// Thing connectivity indexing mode. Valid values are:
        ///
        /// * STATUS  Your thing index contains connectivity status. To enable thing connectivity indexing, thingIndexMode must not be set to OFF.
        ///
        /// * OFF - Thing connectivity status indexing is disabled.
        public var thingConnectivityIndexingMode: IoTClientTypes.ThingConnectivityIndexingMode?
        /// Thing indexing mode. Valid values are:
        ///
        /// * REGISTRY  Your thing index contains registry data only.
        ///
        /// * REGISTRY_AND_SHADOW - Your thing index contains registry and shadow data.
        ///
        /// * OFF - Thing indexing is disabled.
        /// This member is required.
        public var thingIndexingMode: IoTClientTypes.ThingIndexingMode?

        public init(
            customFields: [IoTClientTypes.Field]? = nil,
            deviceDefenderIndexingMode: IoTClientTypes.DeviceDefenderIndexingMode? = nil,
            filter: IoTClientTypes.IndexingFilter? = nil,
            managedFields: [IoTClientTypes.Field]? = nil,
            namedShadowIndexingMode: IoTClientTypes.NamedShadowIndexingMode? = nil,
            thingConnectivityIndexingMode: IoTClientTypes.ThingConnectivityIndexingMode? = nil,
            thingIndexingMode: IoTClientTypes.ThingIndexingMode? = nil
        )
        {
            self.customFields = customFields
            self.deviceDefenderIndexingMode = deviceDefenderIndexingMode
            self.filter = filter
            self.managedFields = managedFields
            self.namedShadowIndexingMode = namedShadowIndexingMode
            self.thingConnectivityIndexingMode = thingConnectivityIndexingMode
            self.thingIndexingMode = thingIndexingMode
        }
    }

}

extension IoTClientTypes {
    public enum ThingIndexingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case registry
        case registryAndShadow
        case sdkUnknown(Swift.String)

        public static var allCases: [ThingIndexingMode] {
            return [
                .off,
                .registry,
                .registryAndShadow,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .registry: return "REGISTRY"
            case .registryAndShadow: return "REGISTRY_AND_SHADOW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThingIndexingMode(rawValue: rawValue) ?? ThingIndexingMode.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.ThingTypeDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingTypeArn
        case thingTypeMetadata
        case thingTypeName
        case thingTypeProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingTypeArn = self.thingTypeArn {
            try encodeContainer.encode(thingTypeArn, forKey: .thingTypeArn)
        }
        if let thingTypeMetadata = self.thingTypeMetadata {
            try encodeContainer.encode(thingTypeMetadata, forKey: .thingTypeMetadata)
        }
        if let thingTypeName = self.thingTypeName {
            try encodeContainer.encode(thingTypeName, forKey: .thingTypeName)
        }
        if let thingTypeProperties = self.thingTypeProperties {
            try encodeContainer.encode(thingTypeProperties, forKey: .thingTypeProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let thingTypeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeArn)
        thingTypeArn = thingTypeArnDecoded
        let thingTypePropertiesDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingTypeProperties.self, forKey: .thingTypeProperties)
        thingTypeProperties = thingTypePropertiesDecoded
        let thingTypeMetadataDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingTypeMetadata.self, forKey: .thingTypeMetadata)
        thingTypeMetadata = thingTypeMetadataDecoded
    }
}

extension IoTClientTypes {
    /// The definition of the thing type, including thing type name and description.
    public struct ThingTypeDefinition: Swift.Equatable {
        /// The thing type ARN.
        public var thingTypeArn: Swift.String?
        /// The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when it was deprecated.
        public var thingTypeMetadata: IoTClientTypes.ThingTypeMetadata?
        /// The name of the thing type.
        public var thingTypeName: Swift.String?
        /// The ThingTypeProperties for the thing type.
        public var thingTypeProperties: IoTClientTypes.ThingTypeProperties?

        public init(
            thingTypeArn: Swift.String? = nil,
            thingTypeMetadata: IoTClientTypes.ThingTypeMetadata? = nil,
            thingTypeName: Swift.String? = nil,
            thingTypeProperties: IoTClientTypes.ThingTypeProperties? = nil
        )
        {
            self.thingTypeArn = thingTypeArn
            self.thingTypeMetadata = thingTypeMetadata
            self.thingTypeName = thingTypeName
            self.thingTypeProperties = thingTypeProperties
        }
    }

}

extension IoTClientTypes.ThingTypeMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case deprecated
        case deprecationDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if deprecated != false {
            try encodeContainer.encode(deprecated, forKey: .deprecated)
        }
        if let deprecationDate = self.deprecationDate {
            try encodeContainer.encodeTimestamp(deprecationDate, format: .epochSeconds, forKey: .deprecationDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deprecatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deprecated) ?? false
        deprecated = deprecatedDecoded
        let deprecationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deprecationDate)
        deprecationDate = deprecationDateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension IoTClientTypes {
    /// The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when time was deprecated.
    public struct ThingTypeMetadata: Swift.Equatable {
        /// The date and time when the thing type was created.
        public var creationDate: ClientRuntime.Date?
        /// Whether the thing type is deprecated. If true, no new things could be associated with this type.
        public var deprecated: Swift.Bool
        /// The date and time when the thing type was deprecated.
        public var deprecationDate: ClientRuntime.Date?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            deprecated: Swift.Bool = false,
            deprecationDate: ClientRuntime.Date? = nil
        )
        {
            self.creationDate = creationDate
            self.deprecated = deprecated
            self.deprecationDate = deprecationDate
        }
    }

}

extension IoTClientTypes.ThingTypeProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchableAttributes
        case thingTypeDescription
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let searchableAttributes = searchableAttributes {
            var searchableAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .searchableAttributes)
            for attributename0 in searchableAttributes {
                try searchableAttributesContainer.encode(attributename0)
            }
        }
        if let thingTypeDescription = self.thingTypeDescription {
            try encodeContainer.encode(thingTypeDescription, forKey: .thingTypeDescription)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeDescription)
        thingTypeDescription = thingTypeDescriptionDecoded
        let searchableAttributesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .searchableAttributes)
        var searchableAttributesDecoded0:[Swift.String]? = nil
        if let searchableAttributesContainer = searchableAttributesContainer {
            searchableAttributesDecoded0 = [Swift.String]()
            for string0 in searchableAttributesContainer {
                if let string0 = string0 {
                    searchableAttributesDecoded0?.append(string0)
                }
            }
        }
        searchableAttributes = searchableAttributesDecoded0
    }
}

extension IoTClientTypes {
    /// The ThingTypeProperties contains information about the thing type including: a thing type description, and a list of searchable thing attribute names.
    public struct ThingTypeProperties: Swift.Equatable {
        /// A list of searchable thing attribute names.
        public var searchableAttributes: [Swift.String]?
        /// The description of the thing type.
        public var thingTypeDescription: Swift.String?

        public init(
            searchableAttributes: [Swift.String]? = nil,
            thingTypeDescription: Swift.String? = nil
        )
        {
            self.searchableAttributes = searchableAttributes
            self.thingTypeDescription = thingTypeDescription
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes.TimeoutConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inProgressTimeoutInMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inProgressTimeoutInMinutes = self.inProgressTimeoutInMinutes {
            try encodeContainer.encode(inProgressTimeoutInMinutes, forKey: .inProgressTimeoutInMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inProgressTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inProgressTimeoutInMinutes)
        inProgressTimeoutInMinutes = inProgressTimeoutInMinutesDecoded
    }
}

extension IoTClientTypes {
    /// Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to TIMED_OUT.
    public struct TimeoutConfig: Swift.Equatable {
        /// Specifies the amount of time, in minutes, this device has to finish execution of this job. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress timer can't be updated and will apply to all job executions for the job. Whenever a job execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and switch to the terminal TIMED_OUT status.
        public var inProgressTimeoutInMinutes: Swift.Int?

        public init(
            inProgressTimeoutInMinutes: Swift.Int? = nil
        )
        {
            self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
        }
    }

}

extension IoTClientTypes.TimestreamAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName
        case dimensions
        case roleArn
        case tableName
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for timestreamdimension0 in dimensions {
                try dimensionsContainer.encode(timestreamdimension0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([IoTClientTypes.TimestreamDimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[IoTClientTypes.TimestreamDimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [IoTClientTypes.TimestreamDimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let timestampDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TimestreamTimestamp.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension IoTClientTypes {
    /// The Timestream rule action writes attributes (measures) from an MQTT message into an Amazon Timestream table. For more information, see the [Timestream](https://docs.aws.amazon.com/iot/latest/developerguide/timestream-rule-action.html) topic rule action documentation.
    public struct TimestreamAction: Swift.Equatable {
        /// The name of an Amazon Timestream database.
        /// This member is required.
        public var databaseName: Swift.String?
        /// Metadata attributes of the time series that are written in each measure record.
        /// This member is required.
        public var dimensions: [IoTClientTypes.TimestreamDimension]?
        /// The ARN of the role that grants permission to write to the Amazon Timestream database table.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The name of the database table into which to write the measure records.
        /// This member is required.
        public var tableName: Swift.String?
        /// Specifies an application-defined value to replace the default value assigned to the Timestream record's timestamp in the time column. You can use this property to specify the value and the precision of the Timestream record's timestamp. You can specify a value from the message payload or a value computed by a substitution template. If omitted, the topic rule action assigns the timestamp, in milliseconds, at the time it processed the rule.
        public var timestamp: IoTClientTypes.TimestreamTimestamp?

        public init(
            databaseName: Swift.String? = nil,
            dimensions: [IoTClientTypes.TimestreamDimension]? = nil,
            roleArn: Swift.String? = nil,
            tableName: Swift.String? = nil,
            timestamp: IoTClientTypes.TimestreamTimestamp? = nil
        )
        {
            self.databaseName = databaseName
            self.dimensions = dimensions
            self.roleArn = roleArn
            self.tableName = tableName
            self.timestamp = timestamp
        }
    }

}

extension IoTClientTypes.TimestreamDimension: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTClientTypes {
    /// Metadata attributes of the time series that are written in each measure record.
    public struct TimestreamDimension: Swift.Equatable {
        /// The metadata dimension name. This is the name of the column in the Amazon Timestream database table record. Dimensions cannot be named: measure_name, measure_value, or time. These names are reserved. Dimension names cannot start with ts_ or measure_value and they cannot contain the colon (:) character.
        /// This member is required.
        public var name: Swift.String?
        /// The value to write in this column of the database record.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTClientTypes.TimestreamTimestamp: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension IoTClientTypes {
    /// Describes how to interpret an application-defined timestamp value from an MQTT message payload and the precision of that value.
    public struct TimestreamTimestamp: Swift.Equatable {
        /// The precision of the timestamp value that results from the expression described in value. Valid values: SECONDS | MILLISECONDS | MICROSECONDS | NANOSECONDS. The default is MILLISECONDS.
        /// This member is required.
        public var unit: Swift.String?
        /// An expression that returns a long epoch time value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            unit: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension IoTClientTypes.TlsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityPolicy = self.securityPolicy {
            try encodeContainer.encode(securityPolicy, forKey: .securityPolicy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
    }
}

extension IoTClientTypes {
    /// An object that specifies the TLS configuration for a domain.
    public struct TlsConfig: Swift.Equatable {
        /// The security policy for a domain configuration. For more information, see [Security policies ](https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html#tls-policy-table) in the Amazon Web Services IoT Core developer guide.
        public var securityPolicy: Swift.String?

        public init(
            securityPolicy: Swift.String? = nil
        )
        {
            self.securityPolicy = securityPolicy
        }
    }

}

extension IoTClientTypes.TlsContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
    }
}

extension IoTClientTypes {
    /// Specifies the TLS context to use for the test authorizer request.
    public struct TlsContext: Swift.Equatable {
        /// The value of the serverName key in a TLS authorization request.
        public var serverName: Swift.String?

        public init(
            serverName: Swift.String? = nil
        )
        {
            self.serverName = serverName
        }
    }

}

extension IoTClientTypes.TopicRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case awsIotSqlVersion
        case createdAt
        case description
        case errorAction
        case ruleDisabled
        case ruleName
        case sql
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for action0 in actions {
                try actionsContainer.encode(action0)
            }
        }
        if let awsIotSqlVersion = self.awsIotSqlVersion {
            try encodeContainer.encode(awsIotSqlVersion, forKey: .awsIotSqlVersion)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errorAction = self.errorAction {
            try encodeContainer.encode(errorAction, forKey: .errorAction)
        }
        if let ruleDisabled = self.ruleDisabled {
            try encodeContainer.encode(ruleDisabled, forKey: .ruleDisabled)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let sql = self.sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let sqlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sql)
        sql = sqlDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let actionsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[IoTClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [IoTClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let ruleDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ruleDisabled)
        ruleDisabled = ruleDisabledDecoded
        let awsIotSqlVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsIotSqlVersion)
        awsIotSqlVersion = awsIotSqlVersionDecoded
        let errorActionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.Action.self, forKey: .errorAction)
        errorAction = errorActionDecoded
    }
}

extension IoTClientTypes {
    /// Describes a rule.
    public struct TopicRule: Swift.Equatable {
        /// The actions associated with the rule.
        public var actions: [IoTClientTypes.Action]?
        /// The version of the SQL rules engine to use when evaluating the rule.
        public var awsIotSqlVersion: Swift.String?
        /// The date and time the rule was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the rule.
        public var description: Swift.String?
        /// The action to perform when an error occurs.
        public var errorAction: IoTClientTypes.Action?
        /// Specifies whether the rule is disabled.
        public var ruleDisabled: Swift.Bool?
        /// The name of the rule.
        public var ruleName: Swift.String?
        /// The SQL statement used to query the topic. When using a SQL query with multiple lines, be sure to escape the newline characters.
        public var sql: Swift.String?

        public init(
            actions: [IoTClientTypes.Action]? = nil,
            awsIotSqlVersion: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            errorAction: IoTClientTypes.Action? = nil,
            ruleDisabled: Swift.Bool? = nil,
            ruleName: Swift.String? = nil,
            sql: Swift.String? = nil
        )
        {
            self.actions = actions
            self.awsIotSqlVersion = awsIotSqlVersion
            self.createdAt = createdAt
            self.description = description
            self.errorAction = errorAction
            self.ruleDisabled = ruleDisabled
            self.ruleName = ruleName
            self.sql = sql
        }
    }

}

extension IoTClientTypes.TopicRuleDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case httpUrlProperties
        case lastUpdatedAt
        case status
        case statusReason
        case vpcProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let httpUrlProperties = self.httpUrlProperties {
            try encodeContainer.encode(httpUrlProperties, forKey: .httpUrlProperties)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let vpcProperties = self.vpcProperties {
            try encodeContainer.encode(vpcProperties, forKey: .vpcProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TopicRuleDestinationStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let httpUrlPropertiesDecoded = try containerValues.decodeIfPresent(IoTClientTypes.HttpUrlDestinationProperties.self, forKey: .httpUrlProperties)
        httpUrlProperties = httpUrlPropertiesDecoded
        let vpcPropertiesDecoded = try containerValues.decodeIfPresent(IoTClientTypes.VpcDestinationProperties.self, forKey: .vpcProperties)
        vpcProperties = vpcPropertiesDecoded
    }
}

extension IoTClientTypes {
    /// A topic rule destination.
    public struct TopicRuleDestination: Swift.Equatable {
        /// The topic rule destination URL.
        public var arn: Swift.String?
        /// The date and time when the topic rule destination was created.
        public var createdAt: ClientRuntime.Date?
        /// Properties of the HTTP URL.
        public var httpUrlProperties: IoTClientTypes.HttpUrlDestinationProperties?
        /// The date and time when the topic rule destination was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The status of the topic rule destination. Valid values are: IN_PROGRESS A topic rule destination was created but has not been confirmed. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint. ENABLED Confirmation was completed, and traffic to this destination is allowed. You can set status to DISABLED by calling UpdateTopicRuleDestination. DISABLED Confirmation was completed, and traffic to this destination is not allowed. You can set status to ENABLED by calling UpdateTopicRuleDestination. ERROR Confirmation could not be completed, for example if the confirmation timed out. You can call GetTopicRuleDestination for details about the error. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint.
        public var status: IoTClientTypes.TopicRuleDestinationStatus?
        /// Additional details or reason why the topic rule destination is in the current status.
        public var statusReason: Swift.String?
        /// Properties of the virtual private cloud (VPC) connection.
        public var vpcProperties: IoTClientTypes.VpcDestinationProperties?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            httpUrlProperties: IoTClientTypes.HttpUrlDestinationProperties? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            status: IoTClientTypes.TopicRuleDestinationStatus? = nil,
            statusReason: Swift.String? = nil,
            vpcProperties: IoTClientTypes.VpcDestinationProperties? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.httpUrlProperties = httpUrlProperties
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.statusReason = statusReason
            self.vpcProperties = vpcProperties
        }
    }

}

extension IoTClientTypes.TopicRuleDestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpUrlConfiguration
        case vpcConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpUrlConfiguration = self.httpUrlConfiguration {
            try encodeContainer.encode(httpUrlConfiguration, forKey: .httpUrlConfiguration)
        }
        if let vpcConfiguration = self.vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpUrlConfigurationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.HttpUrlDestinationConfiguration.self, forKey: .httpUrlConfiguration)
        httpUrlConfiguration = httpUrlConfigurationDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.VpcDestinationConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
    }
}

extension IoTClientTypes {
    /// Configuration of the topic rule destination.
    public struct TopicRuleDestinationConfiguration: Swift.Equatable {
        /// Configuration of the HTTP URL.
        public var httpUrlConfiguration: IoTClientTypes.HttpUrlDestinationConfiguration?
        /// Configuration of the virtual private cloud (VPC) connection.
        public var vpcConfiguration: IoTClientTypes.VpcDestinationConfiguration?

        public init(
            httpUrlConfiguration: IoTClientTypes.HttpUrlDestinationConfiguration? = nil,
            vpcConfiguration: IoTClientTypes.VpcDestinationConfiguration? = nil
        )
        {
            self.httpUrlConfiguration = httpUrlConfiguration
            self.vpcConfiguration = vpcConfiguration
        }
    }

}

extension IoTClientTypes {
    public enum TopicRuleDestinationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case disabled
        case enabled
        case error
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TopicRuleDestinationStatus] {
            return [
                .deleting,
                .disabled,
                .enabled,
                .error,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TopicRuleDestinationStatus(rawValue: rawValue) ?? TopicRuleDestinationStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.TopicRuleDestinationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case httpUrlSummary
        case lastUpdatedAt
        case status
        case statusReason
        case vpcDestinationSummary
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let httpUrlSummary = self.httpUrlSummary {
            try encodeContainer.encode(httpUrlSummary, forKey: .httpUrlSummary)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let vpcDestinationSummary = self.vpcDestinationSummary {
            try encodeContainer.encode(vpcDestinationSummary, forKey: .vpcDestinationSummary)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TopicRuleDestinationStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let httpUrlSummaryDecoded = try containerValues.decodeIfPresent(IoTClientTypes.HttpUrlDestinationSummary.self, forKey: .httpUrlSummary)
        httpUrlSummary = httpUrlSummaryDecoded
        let vpcDestinationSummaryDecoded = try containerValues.decodeIfPresent(IoTClientTypes.VpcDestinationSummary.self, forKey: .vpcDestinationSummary)
        vpcDestinationSummary = vpcDestinationSummaryDecoded
    }
}

extension IoTClientTypes {
    /// Information about the topic rule destination.
    public struct TopicRuleDestinationSummary: Swift.Equatable {
        /// The topic rule destination ARN.
        public var arn: Swift.String?
        /// The date and time when the topic rule destination was created.
        public var createdAt: ClientRuntime.Date?
        /// Information about the HTTP URL.
        public var httpUrlSummary: IoTClientTypes.HttpUrlDestinationSummary?
        /// The date and time when the topic rule destination was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The status of the topic rule destination. Valid values are: IN_PROGRESS A topic rule destination was created but has not been confirmed. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint. ENABLED Confirmation was completed, and traffic to this destination is allowed. You can set status to DISABLED by calling UpdateTopicRuleDestination. DISABLED Confirmation was completed, and traffic to this destination is not allowed. You can set status to ENABLED by calling UpdateTopicRuleDestination. ERROR Confirmation could not be completed, for example if the confirmation timed out. You can call GetTopicRuleDestination for details about the error. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint.
        public var status: IoTClientTypes.TopicRuleDestinationStatus?
        /// The reason the topic rule destination is in the current status.
        public var statusReason: Swift.String?
        /// Information about the virtual private cloud (VPC) connection.
        public var vpcDestinationSummary: IoTClientTypes.VpcDestinationSummary?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            httpUrlSummary: IoTClientTypes.HttpUrlDestinationSummary? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            status: IoTClientTypes.TopicRuleDestinationStatus? = nil,
            statusReason: Swift.String? = nil,
            vpcDestinationSummary: IoTClientTypes.VpcDestinationSummary? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.httpUrlSummary = httpUrlSummary
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.statusReason = statusReason
            self.vpcDestinationSummary = vpcDestinationSummary
        }
    }

}

extension IoTClientTypes.TopicRuleListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case ruleArn
        case ruleDisabled
        case ruleName
        case topicPattern
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let ruleArn = self.ruleArn {
            try encodeContainer.encode(ruleArn, forKey: .ruleArn)
        }
        if let ruleDisabled = self.ruleDisabled {
            try encodeContainer.encode(ruleDisabled, forKey: .ruleDisabled)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let topicPattern = self.topicPattern {
            try encodeContainer.encode(topicPattern, forKey: .topicPattern)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let topicPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicPattern)
        topicPattern = topicPatternDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let ruleDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ruleDisabled)
        ruleDisabled = ruleDisabledDecoded
    }
}

extension IoTClientTypes {
    /// Describes a rule.
    public struct TopicRuleListItem: Swift.Equatable {
        /// The date and time the rule was created.
        public var createdAt: ClientRuntime.Date?
        /// The rule ARN.
        public var ruleArn: Swift.String?
        /// Specifies whether the rule is disabled.
        public var ruleDisabled: Swift.Bool?
        /// The name of the rule.
        public var ruleName: Swift.String?
        /// The pattern for the topic names that apply.
        public var topicPattern: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            ruleArn: Swift.String? = nil,
            ruleDisabled: Swift.Bool? = nil,
            ruleName: Swift.String? = nil,
            topicPattern: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.ruleArn = ruleArn
            self.ruleDisabled = ruleDisabled
            self.ruleName = ruleName
            self.topicPattern = topicPattern
        }
    }

}

extension IoTClientTypes.TopicRulePayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case awsIotSqlVersion
        case description
        case errorAction
        case ruleDisabled
        case sql
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for action0 in actions {
                try actionsContainer.encode(action0)
            }
        }
        if let awsIotSqlVersion = self.awsIotSqlVersion {
            try encodeContainer.encode(awsIotSqlVersion, forKey: .awsIotSqlVersion)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errorAction = self.errorAction {
            try encodeContainer.encode(errorAction, forKey: .errorAction)
        }
        if let ruleDisabled = self.ruleDisabled {
            try encodeContainer.encode(ruleDisabled, forKey: .ruleDisabled)
        }
        if let sql = self.sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sql)
        sql = sqlDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[IoTClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [IoTClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let ruleDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ruleDisabled)
        ruleDisabled = ruleDisabledDecoded
        let awsIotSqlVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsIotSqlVersion)
        awsIotSqlVersion = awsIotSqlVersionDecoded
        let errorActionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.Action.self, forKey: .errorAction)
        errorAction = errorActionDecoded
    }
}

extension IoTClientTypes {
    /// Describes a rule.
    public struct TopicRulePayload: Swift.Equatable {
        /// The actions associated with the rule.
        /// This member is required.
        public var actions: [IoTClientTypes.Action]?
        /// The version of the SQL rules engine to use when evaluating the rule.
        public var awsIotSqlVersion: Swift.String?
        /// The description of the rule.
        public var description: Swift.String?
        /// The action to take when an error occurs.
        public var errorAction: IoTClientTypes.Action?
        /// Specifies whether the rule is disabled.
        public var ruleDisabled: Swift.Bool?
        /// The SQL statement used to query the topic. For more information, see [IoT SQL Reference](https://docs.aws.amazon.com/iot/latest/developerguide/iot-sql-reference.html) in the IoT Developer Guide.
        /// This member is required.
        public var sql: Swift.String?

        public init(
            actions: [IoTClientTypes.Action]? = nil,
            awsIotSqlVersion: Swift.String? = nil,
            description: Swift.String? = nil,
            errorAction: IoTClientTypes.Action? = nil,
            ruleDisabled: Swift.Bool? = nil,
            sql: Swift.String? = nil
        )
        {
            self.actions = actions
            self.awsIotSqlVersion = awsIotSqlVersion
            self.description = description
            self.errorAction = errorAction
            self.ruleDisabled = ruleDisabled
            self.sql = sql
        }
    }

}

extension TransferAlreadyCompletedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TransferAlreadyCompletedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You can't revert the certificate transfer because the transfer is already complete.
public struct TransferAlreadyCompletedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TransferAlreadyCompletedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TransferAlreadyCompletedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TransferAlreadyCompletedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransferCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transferMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transferMessage = self.transferMessage {
            try encodeContainer.encode(transferMessage, forKey: .transferMessage)
        }
    }
}

extension TransferCertificateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let targetAwsAccount = targetAwsAccount else {
                let message = "Creating a URL Query Item failed. targetAwsAccount is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let targetAwsAccountQueryItem = ClientRuntime.URLQueryItem(name: "targetAwsAccount".urlPercentEncoding(), value: Swift.String(targetAwsAccount).urlPercentEncoding())
            items.append(targetAwsAccountQueryItem)
            return items
        }
    }
}

extension TransferCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let certificateId = certificateId else {
            return nil
        }
        return "/transfer-certificate/\(certificateId.urlPercentEncoding())"
    }
}

/// The input for the TransferCertificate operation.
public struct TransferCertificateInput: Swift.Equatable {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?
    /// The Amazon Web Services account.
    /// This member is required.
    public var targetAwsAccount: Swift.String?
    /// The transfer message.
    public var transferMessage: Swift.String?

    public init(
        certificateId: Swift.String? = nil,
        targetAwsAccount: Swift.String? = nil,
        transferMessage: Swift.String? = nil
    )
    {
        self.certificateId = certificateId
        self.targetAwsAccount = targetAwsAccount
        self.transferMessage = transferMessage
    }
}

struct TransferCertificateInputBody: Swift.Equatable {
    let transferMessage: Swift.String?
}

extension TransferCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transferMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transferMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transferMessage)
        transferMessage = transferMessageDecoded
    }
}

extension TransferCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TransferCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.transferredCertificateArn = output.transferredCertificateArn
        } else {
            self.transferredCertificateArn = nil
        }
    }
}

/// The output from the TransferCertificate operation.
public struct TransferCertificateOutput: Swift.Equatable {
    /// The ARN of the certificate.
    public var transferredCertificateArn: Swift.String?

    public init(
        transferredCertificateArn: Swift.String? = nil
    )
    {
        self.transferredCertificateArn = transferredCertificateArn
    }
}

struct TransferCertificateOutputBody: Swift.Equatable {
    let transferredCertificateArn: Swift.String?
}

extension TransferCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transferredCertificateArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transferredCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transferredCertificateArn)
        transferredCertificateArn = transferredCertificateArnDecoded
    }
}

enum TransferCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CertificateStateException": return try await CertificateStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TransferConflictException": return try await TransferConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TransferConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TransferConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You can't transfer the certificate because authorization policies are still attached.
public struct TransferConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TransferConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TransferConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TransferConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes.TransferData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptDate
        case rejectDate
        case rejectReason
        case transferDate
        case transferMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptDate = self.acceptDate {
            try encodeContainer.encodeTimestamp(acceptDate, format: .epochSeconds, forKey: .acceptDate)
        }
        if let rejectDate = self.rejectDate {
            try encodeContainer.encodeTimestamp(rejectDate, format: .epochSeconds, forKey: .rejectDate)
        }
        if let rejectReason = self.rejectReason {
            try encodeContainer.encode(rejectReason, forKey: .rejectReason)
        }
        if let transferDate = self.transferDate {
            try encodeContainer.encodeTimestamp(transferDate, format: .epochSeconds, forKey: .transferDate)
        }
        if let transferMessage = self.transferMessage {
            try encodeContainer.encode(transferMessage, forKey: .transferMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transferMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transferMessage)
        transferMessage = transferMessageDecoded
        let rejectReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rejectReason)
        rejectReason = rejectReasonDecoded
        let transferDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .transferDate)
        transferDate = transferDateDecoded
        let acceptDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .acceptDate)
        acceptDate = acceptDateDecoded
        let rejectDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .rejectDate)
        rejectDate = rejectDateDecoded
    }
}

extension IoTClientTypes {
    /// Data used to transfer a certificate to an Amazon Web Services account.
    public struct TransferData: Swift.Equatable {
        /// The date the transfer was accepted.
        public var acceptDate: ClientRuntime.Date?
        /// The date the transfer was rejected.
        public var rejectDate: ClientRuntime.Date?
        /// The reason why the transfer was rejected.
        public var rejectReason: Swift.String?
        /// The date the transfer took place.
        public var transferDate: ClientRuntime.Date?
        /// The transfer message.
        public var transferMessage: Swift.String?

        public init(
            acceptDate: ClientRuntime.Date? = nil,
            rejectDate: ClientRuntime.Date? = nil,
            rejectReason: Swift.String? = nil,
            transferDate: ClientRuntime.Date? = nil,
            transferMessage: Swift.String? = nil
        )
        {
            self.acceptDate = acceptDate
            self.rejectDate = rejectDate
            self.rejectReason = rejectReason
            self.transferDate = transferDate
            self.transferMessage = transferMessage
        }
    }

}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are not authorized to perform this operation.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/untag"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of the tags to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAccountAuditConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditCheckConfigurations
        case auditNotificationTargetConfigurations
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditCheckConfigurations = auditCheckConfigurations {
            var auditCheckConfigurationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .auditCheckConfigurations)
            for (dictKey0, auditCheckConfigurations0) in auditCheckConfigurations {
                try auditCheckConfigurationsContainer.encode(auditCheckConfigurations0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let auditNotificationTargetConfigurations = auditNotificationTargetConfigurations {
            var auditNotificationTargetConfigurationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .auditNotificationTargetConfigurations)
            for (dictKey0, auditNotificationTargetConfigurations0) in auditNotificationTargetConfigurations {
                try auditNotificationTargetConfigurationsContainer.encode(auditNotificationTargetConfigurations0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateAccountAuditConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/configuration"
    }
}

public struct UpdateAccountAuditConfigurationInput: Swift.Equatable {
    /// Specifies which audit checks are enabled and disabled for this account. Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are currently enabled. Some data collection might start immediately when certain checks are enabled. When a check is disabled, any data collected so far in relation to the check is deleted. You cannot disable a check if it's used by any scheduled audit. You must first delete the check from the scheduled audit or delete the scheduled audit itself. On the first call to UpdateAccountAuditConfiguration, this parameter is required and must specify at least one enabled check.
    public var auditCheckConfigurations: [Swift.String:IoTClientTypes.AuditCheckConfiguration]?
    /// Information about the targets to which audit notifications are sent.
    public var auditNotificationTargetConfigurations: [Swift.String:IoTClientTypes.AuditNotificationTarget]?
    /// The Amazon Resource Name (ARN) of the role that grants permission to IoT to access information about your devices, policies, certificates, and other items as required when performing an audit.
    public var roleArn: Swift.String?

    public init(
        auditCheckConfigurations: [Swift.String:IoTClientTypes.AuditCheckConfiguration]? = nil,
        auditNotificationTargetConfigurations: [Swift.String:IoTClientTypes.AuditNotificationTarget]? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.auditCheckConfigurations = auditCheckConfigurations
        self.auditNotificationTargetConfigurations = auditNotificationTargetConfigurations
        self.roleArn = roleArn
    }
}

struct UpdateAccountAuditConfigurationInputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let auditNotificationTargetConfigurations: [Swift.String:IoTClientTypes.AuditNotificationTarget]?
    let auditCheckConfigurations: [Swift.String:IoTClientTypes.AuditCheckConfiguration]?
}

extension UpdateAccountAuditConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditCheckConfigurations
        case auditNotificationTargetConfigurations
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let auditNotificationTargetConfigurationsContainer = try containerValues.decodeIfPresent([Swift.String: IoTClientTypes.AuditNotificationTarget?].self, forKey: .auditNotificationTargetConfigurations)
        var auditNotificationTargetConfigurationsDecoded0: [Swift.String:IoTClientTypes.AuditNotificationTarget]? = nil
        if let auditNotificationTargetConfigurationsContainer = auditNotificationTargetConfigurationsContainer {
            auditNotificationTargetConfigurationsDecoded0 = [Swift.String:IoTClientTypes.AuditNotificationTarget]()
            for (key0, auditnotificationtarget0) in auditNotificationTargetConfigurationsContainer {
                if let auditnotificationtarget0 = auditnotificationtarget0 {
                    auditNotificationTargetConfigurationsDecoded0?[key0] = auditnotificationtarget0
                }
            }
        }
        auditNotificationTargetConfigurations = auditNotificationTargetConfigurationsDecoded0
        let auditCheckConfigurationsContainer = try containerValues.decodeIfPresent([Swift.String: IoTClientTypes.AuditCheckConfiguration?].self, forKey: .auditCheckConfigurations)
        var auditCheckConfigurationsDecoded0: [Swift.String:IoTClientTypes.AuditCheckConfiguration]? = nil
        if let auditCheckConfigurationsContainer = auditCheckConfigurationsContainer {
            auditCheckConfigurationsDecoded0 = [Swift.String:IoTClientTypes.AuditCheckConfiguration]()
            for (key0, auditcheckconfiguration0) in auditCheckConfigurationsContainer {
                if let auditcheckconfiguration0 = auditcheckconfiguration0 {
                    auditCheckConfigurationsDecoded0?[key0] = auditcheckconfiguration0
                }
            }
        }
        auditCheckConfigurations = auditCheckConfigurationsDecoded0
    }
}

extension UpdateAccountAuditConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAccountAuditConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAccountAuditConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAuditSuppressionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName
        case description
        case expirationDate
        case resourceIdentifier
        case suppressIndefinitely
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = self.checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = self.expirationDate {
            try encodeContainer.encodeTimestamp(expirationDate, format: .epochSeconds, forKey: .expirationDate)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let suppressIndefinitely = self.suppressIndefinitely {
            try encodeContainer.encode(suppressIndefinitely, forKey: .suppressIndefinitely)
        }
    }
}

extension UpdateAuditSuppressionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/audit/suppressions/update"
    }
}

public struct UpdateAuditSuppressionInput: Swift.Equatable {
    /// An audit check name. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    /// This member is required.
    public var checkName: Swift.String?
    /// The description of the audit suppression.
    public var description: Swift.String?
    /// The expiration date (epoch timestamp in seconds) that you want the suppression to adhere to.
    public var expirationDate: ClientRuntime.Date?
    /// Information that identifies the noncompliant resource.
    /// This member is required.
    public var resourceIdentifier: IoTClientTypes.ResourceIdentifier?
    /// Indicates whether a suppression should exist indefinitely or not.
    public var suppressIndefinitely: Swift.Bool?

    public init(
        checkName: Swift.String? = nil,
        description: Swift.String? = nil,
        expirationDate: ClientRuntime.Date? = nil,
        resourceIdentifier: IoTClientTypes.ResourceIdentifier? = nil,
        suppressIndefinitely: Swift.Bool? = nil
    )
    {
        self.checkName = checkName
        self.description = description
        self.expirationDate = expirationDate
        self.resourceIdentifier = resourceIdentifier
        self.suppressIndefinitely = suppressIndefinitely
    }
}

struct UpdateAuditSuppressionInputBody: Swift.Equatable {
    let checkName: Swift.String?
    let resourceIdentifier: IoTClientTypes.ResourceIdentifier?
    let expirationDate: ClientRuntime.Date?
    let suppressIndefinitely: Swift.Bool?
    let description: Swift.String?
}

extension UpdateAuditSuppressionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkName
        case description
        case expirationDate
        case resourceIdentifier
        case suppressIndefinitely
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ResourceIdentifier.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let expirationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let suppressIndefinitelyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .suppressIndefinitely)
        suppressIndefinitely = suppressIndefinitelyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateAuditSuppressionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAuditSuppressionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAuditSuppressionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerFunctionArn
        case enableCachingForHttp
        case status
        case tokenKeyName
        case tokenSigningPublicKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerFunctionArn = self.authorizerFunctionArn {
            try encodeContainer.encode(authorizerFunctionArn, forKey: .authorizerFunctionArn)
        }
        if let enableCachingForHttp = self.enableCachingForHttp {
            try encodeContainer.encode(enableCachingForHttp, forKey: .enableCachingForHttp)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tokenKeyName = self.tokenKeyName {
            try encodeContainer.encode(tokenKeyName, forKey: .tokenKeyName)
        }
        if let tokenSigningPublicKeys = tokenSigningPublicKeys {
            var tokenSigningPublicKeysContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tokenSigningPublicKeys)
            for (dictKey0, publicKeyMap0) in tokenSigningPublicKeys {
                try tokenSigningPublicKeysContainer.encode(publicKeyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let authorizerName = authorizerName else {
            return nil
        }
        return "/authorizer/\(authorizerName.urlPercentEncoding())"
    }
}

public struct UpdateAuthorizerInput: Swift.Equatable {
    /// The ARN of the authorizer's Lambda function.
    public var authorizerFunctionArn: Swift.String?
    /// The authorizer name.
    /// This member is required.
    public var authorizerName: Swift.String?
    /// When true, the result from the authorizers Lambda function is cached for the time specified in refreshAfterInSeconds. The cached result is used while the device reuses the same HTTP connection.
    public var enableCachingForHttp: Swift.Bool?
    /// The status of the update authorizer request.
    public var status: IoTClientTypes.AuthorizerStatus?
    /// The key used to extract the token from the HTTP headers.
    public var tokenKeyName: Swift.String?
    /// The public keys used to verify the token signature.
    public var tokenSigningPublicKeys: [Swift.String:Swift.String]?

    public init(
        authorizerFunctionArn: Swift.String? = nil,
        authorizerName: Swift.String? = nil,
        enableCachingForHttp: Swift.Bool? = nil,
        status: IoTClientTypes.AuthorizerStatus? = nil,
        tokenKeyName: Swift.String? = nil,
        tokenSigningPublicKeys: [Swift.String:Swift.String]? = nil
    )
    {
        self.authorizerFunctionArn = authorizerFunctionArn
        self.authorizerName = authorizerName
        self.enableCachingForHttp = enableCachingForHttp
        self.status = status
        self.tokenKeyName = tokenKeyName
        self.tokenSigningPublicKeys = tokenSigningPublicKeys
    }
}

struct UpdateAuthorizerInputBody: Swift.Equatable {
    let authorizerFunctionArn: Swift.String?
    let tokenKeyName: Swift.String?
    let tokenSigningPublicKeys: [Swift.String:Swift.String]?
    let status: IoTClientTypes.AuthorizerStatus?
    let enableCachingForHttp: Swift.Bool?
}

extension UpdateAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerFunctionArn
        case enableCachingForHttp
        case status
        case tokenKeyName
        case tokenSigningPublicKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerFunctionArn)
        authorizerFunctionArn = authorizerFunctionArnDecoded
        let tokenKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenKeyName)
        tokenKeyName = tokenKeyNameDecoded
        let tokenSigningPublicKeysContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tokenSigningPublicKeys)
        var tokenSigningPublicKeysDecoded0: [Swift.String:Swift.String]? = nil
        if let tokenSigningPublicKeysContainer = tokenSigningPublicKeysContainer {
            tokenSigningPublicKeysDecoded0 = [Swift.String:Swift.String]()
            for (key0, keyvalue0) in tokenSigningPublicKeysContainer {
                if let keyvalue0 = keyvalue0 {
                    tokenSigningPublicKeysDecoded0?[key0] = keyvalue0
                }
            }
        }
        tokenSigningPublicKeys = tokenSigningPublicKeysDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuthorizerStatus.self, forKey: .status)
        status = statusDecoded
        let enableCachingForHttpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableCachingForHttp)
        enableCachingForHttp = enableCachingForHttpDecoded
    }
}

extension UpdateAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAuthorizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizerArn = output.authorizerArn
            self.authorizerName = output.authorizerName
        } else {
            self.authorizerArn = nil
            self.authorizerName = nil
        }
    }
}

public struct UpdateAuthorizerOutput: Swift.Equatable {
    /// The authorizer ARN.
    public var authorizerArn: Swift.String?
    /// The authorizer name.
    public var authorizerName: Swift.String?

    public init(
        authorizerArn: Swift.String? = nil,
        authorizerName: Swift.String? = nil
    )
    {
        self.authorizerArn = authorizerArn
        self.authorizerName = authorizerName
    }
}

struct UpdateAuthorizerOutputBody: Swift.Equatable {
    let authorizerName: Swift.String?
    let authorizerArn: Swift.String?
}

extension UpdateAuthorizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerArn
        case authorizerName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerName)
        authorizerName = authorizerNameDecoded
        let authorizerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerArn)
        authorizerArn = authorizerArnDecoded
    }
}

enum UpdateAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBillingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupProperties
        case expectedVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupProperties = self.billingGroupProperties {
            try encodeContainer.encode(billingGroupProperties, forKey: .billingGroupProperties)
        }
        if let expectedVersion = self.expectedVersion {
            try encodeContainer.encode(expectedVersion, forKey: .expectedVersion)
        }
    }
}

extension UpdateBillingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let billingGroupName = billingGroupName else {
            return nil
        }
        return "/billing-groups/\(billingGroupName.urlPercentEncoding())"
    }
}

public struct UpdateBillingGroupInput: Swift.Equatable {
    /// The name of the billing group.
    /// This member is required.
    public var billingGroupName: Swift.String?
    /// The properties of the billing group.
    /// This member is required.
    public var billingGroupProperties: IoTClientTypes.BillingGroupProperties?
    /// The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the UpdateBillingGroup request is rejected with a VersionConflictException.
    public var expectedVersion: Swift.Int?

    public init(
        billingGroupName: Swift.String? = nil,
        billingGroupProperties: IoTClientTypes.BillingGroupProperties? = nil,
        expectedVersion: Swift.Int? = nil
    )
    {
        self.billingGroupName = billingGroupName
        self.billingGroupProperties = billingGroupProperties
        self.expectedVersion = expectedVersion
    }
}

struct UpdateBillingGroupInputBody: Swift.Equatable {
    let billingGroupProperties: IoTClientTypes.BillingGroupProperties?
    let expectedVersion: Swift.Int?
}

extension UpdateBillingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupProperties
        case expectedVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupPropertiesDecoded = try containerValues.decodeIfPresent(IoTClientTypes.BillingGroupProperties.self, forKey: .billingGroupProperties)
        billingGroupProperties = billingGroupPropertiesDecoded
        let expectedVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedVersion)
        expectedVersion = expectedVersionDecoded
    }
}

extension UpdateBillingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBillingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.version = output.version
        } else {
            self.version = 0
        }
    }
}

public struct UpdateBillingGroupOutput: Swift.Equatable {
    /// The latest version of the billing group.
    public var version: Swift.Int

    public init(
        version: Swift.Int = 0
    )
    {
        self.version = version
    }
}

struct UpdateBillingGroupOutputBody: Swift.Equatable {
    let version: Swift.Int
}

extension UpdateBillingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
    }
}

enum UpdateBillingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCACertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationConfig
        case removeAutoRegistration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registrationConfig = self.registrationConfig {
            try encodeContainer.encode(registrationConfig, forKey: .registrationConfig)
        }
        if let removeAutoRegistration = self.removeAutoRegistration {
            try encodeContainer.encode(removeAutoRegistration, forKey: .removeAutoRegistration)
        }
    }
}

extension UpdateCACertificateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let newAutoRegistrationStatus = newAutoRegistrationStatus {
                let newAutoRegistrationStatusQueryItem = ClientRuntime.URLQueryItem(name: "newAutoRegistrationStatus".urlPercentEncoding(), value: Swift.String(newAutoRegistrationStatus.rawValue).urlPercentEncoding())
                items.append(newAutoRegistrationStatusQueryItem)
            }
            if let newStatus = newStatus {
                let newStatusQueryItem = ClientRuntime.URLQueryItem(name: "newStatus".urlPercentEncoding(), value: Swift.String(newStatus.rawValue).urlPercentEncoding())
                items.append(newStatusQueryItem)
            }
            return items
        }
    }
}

extension UpdateCACertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let certificateId = certificateId else {
            return nil
        }
        return "/cacertificate/\(certificateId.urlPercentEncoding())"
    }
}

/// The input to the UpdateCACertificate operation.
public struct UpdateCACertificateInput: Swift.Equatable {
    /// The CA certificate identifier.
    /// This member is required.
    public var certificateId: Swift.String?
    /// The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
    public var newAutoRegistrationStatus: IoTClientTypes.AutoRegistrationStatus?
    /// The updated status of the CA certificate. Note: The status value REGISTER_INACTIVE is deprecated and should not be used.
    public var newStatus: IoTClientTypes.CACertificateStatus?
    /// Information about the registration configuration.
    public var registrationConfig: IoTClientTypes.RegistrationConfig?
    /// If true, removes auto registration.
    public var removeAutoRegistration: Swift.Bool?

    public init(
        certificateId: Swift.String? = nil,
        newAutoRegistrationStatus: IoTClientTypes.AutoRegistrationStatus? = nil,
        newStatus: IoTClientTypes.CACertificateStatus? = nil,
        registrationConfig: IoTClientTypes.RegistrationConfig? = nil,
        removeAutoRegistration: Swift.Bool? = nil
    )
    {
        self.certificateId = certificateId
        self.newAutoRegistrationStatus = newAutoRegistrationStatus
        self.newStatus = newStatus
        self.registrationConfig = registrationConfig
        self.removeAutoRegistration = removeAutoRegistration
    }
}

struct UpdateCACertificateInputBody: Swift.Equatable {
    let registrationConfig: IoTClientTypes.RegistrationConfig?
    let removeAutoRegistration: Swift.Bool?
}

extension UpdateCACertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registrationConfig
        case removeAutoRegistration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registrationConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
        let removeAutoRegistrationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeAutoRegistration)
        removeAutoRegistration = removeAutoRegistrationDecoded
    }
}

extension UpdateCACertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateCACertificateOutput: Swift.Equatable {

    public init() { }
}

enum UpdateCACertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.UpdateCACertificateParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CACertificateUpdateAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension IoTClientTypes {
    /// Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
    public struct UpdateCACertificateParams: Swift.Equatable {
        /// The action that you want to apply to the CA certificate. The only supported value is DEACTIVATE.
        /// This member is required.
        public var action: IoTClientTypes.CACertificateUpdateAction?

        public init(
            action: IoTClientTypes.CACertificateUpdateAction? = nil
        )
        {
            self.action = action
        }
    }

}

extension UpdateCertificateInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let newStatus = newStatus else {
                let message = "Creating a URL Query Item failed. newStatus is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let newStatusQueryItem = ClientRuntime.URLQueryItem(name: "newStatus".urlPercentEncoding(), value: Swift.String(newStatus.rawValue).urlPercentEncoding())
            items.append(newStatusQueryItem)
            return items
        }
    }
}

extension UpdateCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let certificateId = certificateId else {
            return nil
        }
        return "/certificates/\(certificateId.urlPercentEncoding())"
    }
}

/// The input for the UpdateCertificate operation.
public struct UpdateCertificateInput: Swift.Equatable {
    /// The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)
    /// This member is required.
    public var certificateId: Swift.String?
    /// The new status. Note: Setting the status to PENDING_TRANSFER or PENDING_ACTIVATION will result in an exception being thrown. PENDING_TRANSFER and PENDING_ACTIVATION are statuses used internally by IoT. They are not intended for developer use. Note: The status value REGISTER_INACTIVE is deprecated and should not be used.
    /// This member is required.
    public var newStatus: IoTClientTypes.CertificateStatus?

    public init(
        certificateId: Swift.String? = nil,
        newStatus: IoTClientTypes.CertificateStatus? = nil
    )
    {
        self.certificateId = certificateId
        self.newStatus = newStatus
    }
}

struct UpdateCertificateInputBody: Swift.Equatable {
}

extension UpdateCertificateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UpdateCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateCertificateOutput: Swift.Equatable {

    public init() { }
}

enum UpdateCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CertificateStateException": return try await CertificateStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCustomMetricInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }
}

extension UpdateCustomMetricInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let metricName = metricName else {
            return nil
        }
        return "/custom-metric/\(metricName.urlPercentEncoding())"
    }
}

public struct UpdateCustomMetricInput: Swift.Equatable {
    /// Field represents a friendly name in the console for the custom metric, it doesn't have to be unique. Don't use this name as the metric identifier in the device metric report. Can be updated.
    /// This member is required.
    public var displayName: Swift.String?
    /// The name of the custom metric. Cannot be updated.
    /// This member is required.
    public var metricName: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        metricName: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.metricName = metricName
    }
}

struct UpdateCustomMetricInputBody: Swift.Equatable {
    let displayName: Swift.String?
}

extension UpdateCustomMetricInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension UpdateCustomMetricOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCustomMetricOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.displayName = output.displayName
            self.lastModifiedDate = output.lastModifiedDate
            self.metricArn = output.metricArn
            self.metricName = output.metricName
            self.metricType = output.metricType
        } else {
            self.creationDate = nil
            self.displayName = nil
            self.lastModifiedDate = nil
            self.metricArn = nil
            self.metricName = nil
            self.metricType = nil
        }
    }
}

public struct UpdateCustomMetricOutput: Swift.Equatable {
    /// The creation date of the custom metric in milliseconds since epoch.
    public var creationDate: ClientRuntime.Date?
    /// A friendly name in the console for the custom metric
    public var displayName: Swift.String?
    /// The time the custom metric was last modified in milliseconds since epoch.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The Amazon Resource Number (ARN) of the custom metric.
    public var metricArn: Swift.String?
    /// The name of the custom metric.
    public var metricName: Swift.String?
    /// The type of the custom metric. The type number only takes a single metric value as an input, but while submitting the metrics value in the DeviceMetrics report, it must be passed as an array with a single value.
    public var metricType: IoTClientTypes.CustomMetricType?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        metricArn: Swift.String? = nil,
        metricName: Swift.String? = nil,
        metricType: IoTClientTypes.CustomMetricType? = nil
    )
    {
        self.creationDate = creationDate
        self.displayName = displayName
        self.lastModifiedDate = lastModifiedDate
        self.metricArn = metricArn
        self.metricName = metricName
        self.metricType = metricType
    }
}

struct UpdateCustomMetricOutputBody: Swift.Equatable {
    let metricName: Swift.String?
    let metricArn: Swift.String?
    let metricType: IoTClientTypes.CustomMetricType?
    let displayName: Swift.String?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
}

extension UpdateCustomMetricOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case displayName
        case lastModifiedDate
        case metricArn
        case metricName
        case metricType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricArn)
        metricArn = metricArnDecoded
        let metricTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.CustomMetricType.self, forKey: .metricType)
        metricType = metricTypeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

enum UpdateCustomMetricOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.UpdateDeviceCertificateParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DeviceCertificateUpdateAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension IoTClientTypes {
    /// Parameters to define a mitigation action that changes the state of the device certificate to inactive.
    public struct UpdateDeviceCertificateParams: Swift.Equatable {
        /// The action that you want to apply to the device certificate. The only supported value is DEACTIVATE.
        /// This member is required.
        public var action: IoTClientTypes.DeviceCertificateUpdateAction?

        public init(
            action: IoTClientTypes.DeviceCertificateUpdateAction? = nil
        )
        {
            self.action = action
        }
    }

}

extension UpdateDimensionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stringValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stringValues = stringValues {
            var stringValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringValues)
            for dimensionstringvalue0 in stringValues {
                try stringValuesContainer.encode(dimensionstringvalue0)
            }
        }
    }
}

extension UpdateDimensionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/dimensions/\(name.urlPercentEncoding())"
    }
}

public struct UpdateDimensionInput: Swift.Equatable {
    /// A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the value or list of values for the dimension. For TOPIC_FILTER dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").
    /// This member is required.
    public var stringValues: [Swift.String]?

    public init(
        name: Swift.String? = nil,
        stringValues: [Swift.String]? = nil
    )
    {
        self.name = name
        self.stringValues = stringValues
    }
}

struct UpdateDimensionInputBody: Swift.Equatable {
    let stringValues: [Swift.String]?
}

extension UpdateDimensionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stringValues
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stringValues)
        var stringValuesDecoded0:[Swift.String]? = nil
        if let stringValuesContainer = stringValuesContainer {
            stringValuesDecoded0 = [Swift.String]()
            for string0 in stringValuesContainer {
                if let string0 = string0 {
                    stringValuesDecoded0?.append(string0)
                }
            }
        }
        stringValues = stringValuesDecoded0
    }
}

extension UpdateDimensionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDimensionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDate = output.creationDate
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
            self.stringValues = output.stringValues
            self.type = output.type
        } else {
            self.arn = nil
            self.creationDate = nil
            self.lastModifiedDate = nil
            self.name = nil
            self.stringValues = nil
            self.type = nil
        }
    }
}

public struct UpdateDimensionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN)of the created dimension.
    public var arn: Swift.String?
    /// The date and time, in milliseconds since epoch, when the dimension was initially created.
    public var creationDate: ClientRuntime.Date?
    /// The date and time, in milliseconds since epoch, when the dimension was most recently updated.
    public var lastModifiedDate: ClientRuntime.Date?
    /// A unique identifier for the dimension.
    public var name: Swift.String?
    /// The value or list of values used to scope the dimension. For example, for topic filters, this is the pattern used to match the MQTT topic name.
    public var stringValues: [Swift.String]?
    /// The type of the dimension.
    public var type: IoTClientTypes.DimensionType?

    public init(
        arn: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        stringValues: [Swift.String]? = nil,
        type: IoTClientTypes.DimensionType? = nil
    )
    {
        self.arn = arn
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.stringValues = stringValues
        self.type = type
    }
}

struct UpdateDimensionOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let type: IoTClientTypes.DimensionType?
    let stringValues: [Swift.String]?
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
}

extension UpdateDimensionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDate
        case lastModifiedDate
        case name
        case stringValues
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DimensionType.self, forKey: .type)
        type = typeDecoded
        let stringValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stringValues)
        var stringValuesDecoded0:[Swift.String]? = nil
        if let stringValuesContainer = stringValuesContainer {
            stringValuesDecoded0 = [Swift.String]()
            for string0 in stringValuesContainer {
                if let string0 = string0 {
                    stringValuesDecoded0?.append(string0)
                }
            }
        }
        stringValues = stringValuesDecoded0
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

enum UpdateDimensionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDomainConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerConfig
        case domainConfigurationStatus
        case removeAuthorizerConfig
        case tlsConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerConfig = self.authorizerConfig {
            try encodeContainer.encode(authorizerConfig, forKey: .authorizerConfig)
        }
        if let domainConfigurationStatus = self.domainConfigurationStatus {
            try encodeContainer.encode(domainConfigurationStatus.rawValue, forKey: .domainConfigurationStatus)
        }
        if let removeAuthorizerConfig = self.removeAuthorizerConfig {
            try encodeContainer.encode(removeAuthorizerConfig, forKey: .removeAuthorizerConfig)
        }
        if let tlsConfig = self.tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
    }
}

extension UpdateDomainConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainConfigurationName = domainConfigurationName else {
            return nil
        }
        return "/domainConfigurations/\(domainConfigurationName.urlPercentEncoding())"
    }
}

public struct UpdateDomainConfigurationInput: Swift.Equatable {
    /// An object that specifies the authorization service for a domain.
    public var authorizerConfig: IoTClientTypes.AuthorizerConfig?
    /// The name of the domain configuration to be updated.
    /// This member is required.
    public var domainConfigurationName: Swift.String?
    /// The status to which the domain configuration should be updated.
    public var domainConfigurationStatus: IoTClientTypes.DomainConfigurationStatus?
    /// Removes the authorization configuration from a domain.
    public var removeAuthorizerConfig: Swift.Bool?
    /// An object that specifies the TLS configuration for a domain.
    public var tlsConfig: IoTClientTypes.TlsConfig?

    public init(
        authorizerConfig: IoTClientTypes.AuthorizerConfig? = nil,
        domainConfigurationName: Swift.String? = nil,
        domainConfigurationStatus: IoTClientTypes.DomainConfigurationStatus? = nil,
        removeAuthorizerConfig: Swift.Bool? = nil,
        tlsConfig: IoTClientTypes.TlsConfig? = nil
    )
    {
        self.authorizerConfig = authorizerConfig
        self.domainConfigurationName = domainConfigurationName
        self.domainConfigurationStatus = domainConfigurationStatus
        self.removeAuthorizerConfig = removeAuthorizerConfig
        self.tlsConfig = tlsConfig
    }
}

struct UpdateDomainConfigurationInputBody: Swift.Equatable {
    let authorizerConfig: IoTClientTypes.AuthorizerConfig?
    let domainConfigurationStatus: IoTClientTypes.DomainConfigurationStatus?
    let removeAuthorizerConfig: Swift.Bool?
    let tlsConfig: IoTClientTypes.TlsConfig?
}

extension UpdateDomainConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerConfig
        case domainConfigurationStatus
        case removeAuthorizerConfig
        case tlsConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuthorizerConfig.self, forKey: .authorizerConfig)
        authorizerConfig = authorizerConfigDecoded
        let domainConfigurationStatusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DomainConfigurationStatus.self, forKey: .domainConfigurationStatus)
        domainConfigurationStatus = domainConfigurationStatusDecoded
        let removeAuthorizerConfigDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeAuthorizerConfig)
        removeAuthorizerConfig = removeAuthorizerConfigDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension UpdateDomainConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDomainConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainConfigurationArn = output.domainConfigurationArn
            self.domainConfigurationName = output.domainConfigurationName
        } else {
            self.domainConfigurationArn = nil
            self.domainConfigurationName = nil
        }
    }
}

public struct UpdateDomainConfigurationOutput: Swift.Equatable {
    /// The ARN of the domain configuration that was updated.
    public var domainConfigurationArn: Swift.String?
    /// The name of the domain configuration that was updated.
    public var domainConfigurationName: Swift.String?

    public init(
        domainConfigurationArn: Swift.String? = nil,
        domainConfigurationName: Swift.String? = nil
    )
    {
        self.domainConfigurationArn = domainConfigurationArn
        self.domainConfigurationName = domainConfigurationName
    }
}

struct UpdateDomainConfigurationOutputBody: Swift.Equatable {
    let domainConfigurationName: Swift.String?
    let domainConfigurationArn: Swift.String?
}

extension UpdateDomainConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainConfigurationArn
        case domainConfigurationName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainConfigurationName)
        domainConfigurationName = domainConfigurationNameDecoded
        let domainConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainConfigurationArn)
        domainConfigurationArn = domainConfigurationArnDecoded
    }
}

enum UpdateDomainConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CertificateValidationException": return try await CertificateValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDynamicThingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedVersion
        case indexName
        case queryString
        case queryVersion
        case thingGroupProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedVersion = self.expectedVersion {
            try encodeContainer.encode(expectedVersion, forKey: .expectedVersion)
        }
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = self.queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
        if let thingGroupProperties = self.thingGroupProperties {
            try encodeContainer.encode(thingGroupProperties, forKey: .thingGroupProperties)
        }
    }
}

extension UpdateDynamicThingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingGroupName = thingGroupName else {
            return nil
        }
        return "/dynamic-thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

public struct UpdateDynamicThingGroupInput: Swift.Equatable {
    /// The expected version of the dynamic thing group to update.
    public var expectedVersion: Swift.Int?
    /// The dynamic thing group index to update. Currently one index is supported: AWS_Things.
    public var indexName: Swift.String?
    /// The dynamic thing group search query string to update.
    public var queryString: Swift.String?
    /// The dynamic thing group query version to update. Currently one query version is supported: "2017-09-30". If not specified, the query version defaults to this value.
    public var queryVersion: Swift.String?
    /// The name of the dynamic thing group to update.
    /// This member is required.
    public var thingGroupName: Swift.String?
    /// The dynamic thing group properties to update.
    /// This member is required.
    public var thingGroupProperties: IoTClientTypes.ThingGroupProperties?

    public init(
        expectedVersion: Swift.Int? = nil,
        indexName: Swift.String? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        thingGroupName: Swift.String? = nil,
        thingGroupProperties: IoTClientTypes.ThingGroupProperties? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.indexName = indexName
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
    }
}

struct UpdateDynamicThingGroupInputBody: Swift.Equatable {
    let thingGroupProperties: IoTClientTypes.ThingGroupProperties?
    let expectedVersion: Swift.Int?
    let indexName: Swift.String?
    let queryString: Swift.String?
    let queryVersion: Swift.String?
}

extension UpdateDynamicThingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedVersion
        case indexName
        case queryString
        case queryVersion
        case thingGroupProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupPropertiesDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingGroupProperties.self, forKey: .thingGroupProperties)
        thingGroupProperties = thingGroupPropertiesDecoded
        let expectedVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedVersion)
        expectedVersion = expectedVersionDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
    }
}

extension UpdateDynamicThingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDynamicThingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.version = output.version
        } else {
            self.version = 0
        }
    }
}

public struct UpdateDynamicThingGroupOutput: Swift.Equatable {
    /// The dynamic thing group version.
    public var version: Swift.Int

    public init(
        version: Swift.Int = 0
    )
    {
        self.version = version
    }
}

struct UpdateDynamicThingGroupOutputBody: Swift.Equatable {
    let version: Swift.Int
}

extension UpdateDynamicThingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
    }
}

enum UpdateDynamicThingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidQueryException": return try await InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEventConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventConfigurations = eventConfigurations {
            var eventConfigurationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .eventConfigurations)
            for (dictKey0, eventConfigurations0) in eventConfigurations {
                try eventConfigurationsContainer.encode(eventConfigurations0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateEventConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/event-configurations"
    }
}

public struct UpdateEventConfigurationsInput: Swift.Equatable {
    /// The new event configuration values.
    public var eventConfigurations: [Swift.String:IoTClientTypes.Configuration]?

    public init(
        eventConfigurations: [Swift.String:IoTClientTypes.Configuration]? = nil
    )
    {
        self.eventConfigurations = eventConfigurations
    }
}

struct UpdateEventConfigurationsInputBody: Swift.Equatable {
    let eventConfigurations: [Swift.String:IoTClientTypes.Configuration]?
}

extension UpdateEventConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventConfigurationsContainer = try containerValues.decodeIfPresent([Swift.String: IoTClientTypes.Configuration?].self, forKey: .eventConfigurations)
        var eventConfigurationsDecoded0: [Swift.String:IoTClientTypes.Configuration]? = nil
        if let eventConfigurationsContainer = eventConfigurationsContainer {
            eventConfigurationsDecoded0 = [Swift.String:IoTClientTypes.Configuration]()
            for (key0, configuration0) in eventConfigurationsContainer {
                if let configuration0 = configuration0 {
                    eventConfigurationsDecoded0?[key0] = configuration0
                }
            }
        }
        eventConfigurations = eventConfigurationsDecoded0
    }
}

extension UpdateEventConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateEventConfigurationsOutput: Swift.Equatable {

    public init() { }
}

enum UpdateEventConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFleetMetricInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationField
        case aggregationType
        case description
        case expectedVersion
        case indexName
        case period
        case queryString
        case queryVersion
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationField = self.aggregationField {
            try encodeContainer.encode(aggregationField, forKey: .aggregationField)
        }
        if let aggregationType = self.aggregationType {
            try encodeContainer.encode(aggregationType, forKey: .aggregationType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expectedVersion = self.expectedVersion {
            try encodeContainer.encode(expectedVersion, forKey: .expectedVersion)
        }
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let period = self.period {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let queryVersion = self.queryVersion {
            try encodeContainer.encode(queryVersion, forKey: .queryVersion)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }
}

extension UpdateFleetMetricInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let metricName = metricName else {
            return nil
        }
        return "/fleet-metric/\(metricName.urlPercentEncoding())"
    }
}

public struct UpdateFleetMetricInput: Swift.Equatable {
    /// The field to aggregate.
    public var aggregationField: Swift.String?
    /// The type of the aggregation query.
    public var aggregationType: IoTClientTypes.AggregationType?
    /// The description of the fleet metric.
    public var description: Swift.String?
    /// The expected version of the fleet metric record in the registry.
    public var expectedVersion: Swift.Int?
    /// The name of the index to search.
    /// This member is required.
    public var indexName: Swift.String?
    /// The name of the fleet metric to update.
    /// This member is required.
    public var metricName: Swift.String?
    /// The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.
    public var period: Swift.Int?
    /// The search query string.
    public var queryString: Swift.String?
    /// The version of the query.
    public var queryVersion: Swift.String?
    /// Used to support unit transformation such as milliseconds to seconds. The unit must be supported by [CW metric](https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html).
    public var unit: IoTClientTypes.FleetMetricUnit?

    public init(
        aggregationField: Swift.String? = nil,
        aggregationType: IoTClientTypes.AggregationType? = nil,
        description: Swift.String? = nil,
        expectedVersion: Swift.Int? = nil,
        indexName: Swift.String? = nil,
        metricName: Swift.String? = nil,
        period: Swift.Int? = nil,
        queryString: Swift.String? = nil,
        queryVersion: Swift.String? = nil,
        unit: IoTClientTypes.FleetMetricUnit? = nil
    )
    {
        self.aggregationField = aggregationField
        self.aggregationType = aggregationType
        self.description = description
        self.expectedVersion = expectedVersion
        self.indexName = indexName
        self.metricName = metricName
        self.period = period
        self.queryString = queryString
        self.queryVersion = queryVersion
        self.unit = unit
    }
}

struct UpdateFleetMetricInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let aggregationType: IoTClientTypes.AggregationType?
    let period: Swift.Int?
    let aggregationField: Swift.String?
    let description: Swift.String?
    let queryVersion: Swift.String?
    let indexName: Swift.String?
    let unit: IoTClientTypes.FleetMetricUnit?
    let expectedVersion: Swift.Int?
}

extension UpdateFleetMetricInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationField
        case aggregationType
        case description
        case expectedVersion
        case indexName
        case period
        case queryString
        case queryVersion
        case unit
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let aggregationTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AggregationType.self, forKey: .aggregationType)
        aggregationType = aggregationTypeDecoded
        let periodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .period)
        period = periodDecoded
        let aggregationFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregationField)
        aggregationField = aggregationFieldDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let queryVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryVersion)
        queryVersion = queryVersionDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let unitDecoded = try containerValues.decodeIfPresent(IoTClientTypes.FleetMetricUnit.self, forKey: .unit)
        unit = unitDecoded
        let expectedVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedVersion)
        expectedVersion = expectedVersionDecoded
    }
}

extension UpdateFleetMetricOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateFleetMetricOutput: Swift.Equatable {

    public init() { }
}

enum UpdateFleetMetricOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IndexNotReadyException": return try await IndexNotReadyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAggregationException": return try await InvalidAggregationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidQueryException": return try await InvalidQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIndexingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingGroupIndexingConfiguration
        case thingIndexingConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingGroupIndexingConfiguration = self.thingGroupIndexingConfiguration {
            try encodeContainer.encode(thingGroupIndexingConfiguration, forKey: .thingGroupIndexingConfiguration)
        }
        if let thingIndexingConfiguration = self.thingIndexingConfiguration {
            try encodeContainer.encode(thingIndexingConfiguration, forKey: .thingIndexingConfiguration)
        }
    }
}

extension UpdateIndexingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/indexing/config"
    }
}

public struct UpdateIndexingConfigurationInput: Swift.Equatable {
    /// Thing group indexing configuration.
    public var thingGroupIndexingConfiguration: IoTClientTypes.ThingGroupIndexingConfiguration?
    /// Thing indexing configuration.
    public var thingIndexingConfiguration: IoTClientTypes.ThingIndexingConfiguration?

    public init(
        thingGroupIndexingConfiguration: IoTClientTypes.ThingGroupIndexingConfiguration? = nil,
        thingIndexingConfiguration: IoTClientTypes.ThingIndexingConfiguration? = nil
    )
    {
        self.thingGroupIndexingConfiguration = thingGroupIndexingConfiguration
        self.thingIndexingConfiguration = thingIndexingConfiguration
    }
}

struct UpdateIndexingConfigurationInputBody: Swift.Equatable {
    let thingIndexingConfiguration: IoTClientTypes.ThingIndexingConfiguration?
    let thingGroupIndexingConfiguration: IoTClientTypes.ThingGroupIndexingConfiguration?
}

extension UpdateIndexingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingGroupIndexingConfiguration
        case thingIndexingConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingIndexingConfigurationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingIndexingConfiguration.self, forKey: .thingIndexingConfiguration)
        thingIndexingConfiguration = thingIndexingConfigurationDecoded
        let thingGroupIndexingConfigurationDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingGroupIndexingConfiguration.self, forKey: .thingGroupIndexingConfiguration)
        thingGroupIndexingConfiguration = thingGroupIndexingConfigurationDecoded
    }
}

extension UpdateIndexingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateIndexingConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateIndexingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortConfig
        case description
        case jobExecutionsRetryConfig
        case jobExecutionsRolloutConfig
        case presignedUrlConfig
        case timeoutConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortConfig = self.abortConfig {
            try encodeContainer.encode(abortConfig, forKey: .abortConfig)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let jobExecutionsRetryConfig = self.jobExecutionsRetryConfig {
            try encodeContainer.encode(jobExecutionsRetryConfig, forKey: .jobExecutionsRetryConfig)
        }
        if let jobExecutionsRolloutConfig = self.jobExecutionsRolloutConfig {
            try encodeContainer.encode(jobExecutionsRolloutConfig, forKey: .jobExecutionsRolloutConfig)
        }
        if let presignedUrlConfig = self.presignedUrlConfig {
            try encodeContainer.encode(presignedUrlConfig, forKey: .presignedUrlConfig)
        }
        if let timeoutConfig = self.timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }
}

extension UpdateJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let namespaceId = namespaceId {
                let namespaceIdQueryItem = ClientRuntime.URLQueryItem(name: "namespaceId".urlPercentEncoding(), value: Swift.String(namespaceId).urlPercentEncoding())
                items.append(namespaceIdQueryItem)
            }
            return items
        }
    }
}

extension UpdateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct UpdateJobInput: Swift.Equatable {
    /// Allows you to create criteria to abort a job.
    public var abortConfig: IoTClientTypes.AbortConfig?
    /// A short text description of the job.
    public var description: Swift.String?
    /// Allows you to create the criteria to retry a job.
    public var jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
    /// Allows you to create a staged rollout of the job.
    public var jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
    /// The ID of the job to be updated.
    /// This member is required.
    public var jobId: Swift.String?
    /// The namespace used to indicate that a job is a customer-managed job. When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that contain the value in the following format. $aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/ The namespaceId feature is in public preview.
    public var namespaceId: Swift.String?
    /// Configuration information for pre-signed S3 URLs.
    public var presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
    /// Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to IN_PROGRESS. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to TIMED_OUT.
    public var timeoutConfig: IoTClientTypes.TimeoutConfig?

    public init(
        abortConfig: IoTClientTypes.AbortConfig? = nil,
        description: Swift.String? = nil,
        jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig? = nil,
        jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig? = nil,
        jobId: Swift.String? = nil,
        namespaceId: Swift.String? = nil,
        presignedUrlConfig: IoTClientTypes.PresignedUrlConfig? = nil,
        timeoutConfig: IoTClientTypes.TimeoutConfig? = nil
    )
    {
        self.abortConfig = abortConfig
        self.description = description
        self.jobExecutionsRetryConfig = jobExecutionsRetryConfig
        self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
        self.jobId = jobId
        self.namespaceId = namespaceId
        self.presignedUrlConfig = presignedUrlConfig
        self.timeoutConfig = timeoutConfig
    }
}

struct UpdateJobInputBody: Swift.Equatable {
    let description: Swift.String?
    let presignedUrlConfig: IoTClientTypes.PresignedUrlConfig?
    let jobExecutionsRolloutConfig: IoTClientTypes.JobExecutionsRolloutConfig?
    let abortConfig: IoTClientTypes.AbortConfig?
    let timeoutConfig: IoTClientTypes.TimeoutConfig?
    let jobExecutionsRetryConfig: IoTClientTypes.JobExecutionsRetryConfig?
}

extension UpdateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortConfig
        case description
        case jobExecutionsRetryConfig
        case jobExecutionsRolloutConfig
        case presignedUrlConfig
        case timeoutConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let presignedUrlConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.PresignedUrlConfig.self, forKey: .presignedUrlConfig)
        presignedUrlConfig = presignedUrlConfigDecoded
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
        let jobExecutionsRetryConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.JobExecutionsRetryConfig.self, forKey: .jobExecutionsRetryConfig)
        jobExecutionsRetryConfig = jobExecutionsRetryConfigDecoded
    }
}

extension UpdateJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateJobOutput: Swift.Equatable {

    public init() { }
}

enum UpdateJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMitigationActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionParams
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionParams = self.actionParams {
            try encodeContainer.encode(actionParams, forKey: .actionParams)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateMitigationActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let actionName = actionName else {
            return nil
        }
        return "/mitigationactions/actions/\(actionName.urlPercentEncoding())"
    }
}

public struct UpdateMitigationActionInput: Swift.Equatable {
    /// The friendly name for the mitigation action. You cannot change the name by using UpdateMitigationAction. Instead, you must delete and recreate the mitigation action with the new name.
    /// This member is required.
    public var actionName: Swift.String?
    /// Defines the type of action and the parameters for that action.
    public var actionParams: IoTClientTypes.MitigationActionParams?
    /// The ARN of the IAM role that is used to apply the mitigation action.
    public var roleArn: Swift.String?

    public init(
        actionName: Swift.String? = nil,
        actionParams: IoTClientTypes.MitigationActionParams? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.actionName = actionName
        self.actionParams = actionParams
        self.roleArn = roleArn
    }
}

struct UpdateMitigationActionInputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let actionParams: IoTClientTypes.MitigationActionParams?
}

extension UpdateMitigationActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionParams
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let actionParamsDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MitigationActionParams.self, forKey: .actionParams)
        actionParams = actionParamsDecoded
    }
}

extension UpdateMitigationActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMitigationActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionArn = output.actionArn
            self.actionId = output.actionId
        } else {
            self.actionArn = nil
            self.actionId = nil
        }
    }
}

public struct UpdateMitigationActionOutput: Swift.Equatable {
    /// The ARN for the new mitigation action.
    public var actionArn: Swift.String?
    /// A unique identifier for the mitigation action.
    public var actionId: Swift.String?

    public init(
        actionArn: Swift.String? = nil,
        actionId: Swift.String? = nil
    )
    {
        self.actionArn = actionArn
        self.actionId = actionId
    }
}

struct UpdateMitigationActionOutputBody: Swift.Equatable {
    let actionArn: Swift.String?
    let actionId: Swift.String?
}

extension UpdateMitigationActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionArn
        case actionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionArn)
        actionArn = actionArnDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

enum UpdateMitigationActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePackageConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versionUpdateByJobsConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let versionUpdateByJobsConfig = self.versionUpdateByJobsConfig {
            try encodeContainer.encode(versionUpdateByJobsConfig, forKey: .versionUpdateByJobsConfig)
        }
    }
}

extension UpdatePackageConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension UpdatePackageConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/package-configuration"
    }
}

public struct UpdatePackageConfigurationInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// Configuration to manage job's package version reporting. This updates the thing's reserved named shadow that the job targets.
    public var versionUpdateByJobsConfig: IoTClientTypes.VersionUpdateByJobsConfig?

    public init(
        clientToken: Swift.String? = nil,
        versionUpdateByJobsConfig: IoTClientTypes.VersionUpdateByJobsConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.versionUpdateByJobsConfig = versionUpdateByJobsConfig
    }
}

struct UpdatePackageConfigurationInputBody: Swift.Equatable {
    let versionUpdateByJobsConfig: IoTClientTypes.VersionUpdateByJobsConfig?
}

extension UpdatePackageConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versionUpdateByJobsConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionUpdateByJobsConfigDecoded = try containerValues.decodeIfPresent(IoTClientTypes.VersionUpdateByJobsConfig.self, forKey: .versionUpdateByJobsConfig)
        versionUpdateByJobsConfig = versionUpdateByJobsConfigDecoded
    }
}

extension UpdatePackageConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePackageConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePackageConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePackageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePackageInput(clientToken: \(Swift.String(describing: clientToken)), defaultVersionName: \(Swift.String(describing: defaultVersionName)), packageName: \(Swift.String(describing: packageName)), unsetDefaultVersion: \(Swift.String(describing: unsetDefaultVersion)), description: \"CONTENT_REDACTED\")"}
}

extension UpdatePackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultVersionName
        case description
        case unsetDefaultVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultVersionName = self.defaultVersionName {
            try encodeContainer.encode(defaultVersionName, forKey: .defaultVersionName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let unsetDefaultVersion = self.unsetDefaultVersion {
            try encodeContainer.encode(unsetDefaultVersion, forKey: .unsetDefaultVersion)
        }
    }
}

extension UpdatePackageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension UpdatePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageName = packageName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())"
    }
}

public struct UpdatePackageInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The name of the default package version. Note: You cannot name a defaultVersion and set unsetDefaultVersion equal to true at the same time.
    public var defaultVersionName: Swift.String?
    /// The package description.
    public var description: Swift.String?
    /// The name of the target software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// Indicates whether you want to remove the named default package version from the software package. Set as true to remove the default package version. Note: You cannot name a defaultVersion and set unsetDefaultVersion equal to true at the same time.
    public var unsetDefaultVersion: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        defaultVersionName: Swift.String? = nil,
        description: Swift.String? = nil,
        packageName: Swift.String? = nil,
        unsetDefaultVersion: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.defaultVersionName = defaultVersionName
        self.description = description
        self.packageName = packageName
        self.unsetDefaultVersion = unsetDefaultVersion
    }
}

struct UpdatePackageInputBody: Swift.Equatable {
    let description: Swift.String?
    let defaultVersionName: Swift.String?
    let unsetDefaultVersion: Swift.Bool?
}

extension UpdatePackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultVersionName
        case description
        case unsetDefaultVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultVersionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersionName)
        defaultVersionName = defaultVersionNameDecoded
        let unsetDefaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .unsetDefaultVersion)
        unsetDefaultVersion = unsetDefaultVersionDecoded
    }
}

extension UpdatePackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePackageOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePackageVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePackageVersionInput(action: \(Swift.String(describing: action)), clientToken: \(Swift.String(describing: clientToken)), packageName: \(Swift.String(describing: packageName)), versionName: \(Swift.String(describing: versionName)), attributes: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

extension UpdatePackageVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case attributes
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, resourceAttributes0) in attributes {
                try attributesContainer.encode(resourceAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdatePackageVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension UpdatePackageVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageName = packageName else {
            return nil
        }
        guard let versionName = versionName else {
            return nil
        }
        return "/packages/\(packageName.urlPercentEncoding())/versions/\(versionName.urlPercentEncoding())"
    }
}

public struct UpdatePackageVersionInput: Swift.Equatable {
    /// The status that the package version should be assigned. For more information, see [Package version lifecycle](https://docs.aws.amazon.com/iot/latest/developerguide/preparing-to-use-software-package-catalog.html#package-version-lifecycle).
    public var action: IoTClientTypes.PackageVersionAction?
    /// Metadata that can be used to define a package versions configuration. For example, the Amazon S3 file location, configuration options that are being sent to the device or fleet. Note: Attributes can be updated only when the package version is in a draft state. The combined size of all the attributes on a package version is limited to 3KB.
    public var attributes: [Swift.String:Swift.String]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The package version description.
    public var description: Swift.String?
    /// The name of the associated software package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The name of the target package version.
    /// This member is required.
    public var versionName: Swift.String?

    public init(
        action: IoTClientTypes.PackageVersionAction? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        packageName: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.action = action
        self.attributes = attributes
        self.clientToken = clientToken
        self.description = description
        self.packageName = packageName
        self.versionName = versionName
    }
}

struct UpdatePackageVersionInputBody: Swift.Equatable {
    let description: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let action: IoTClientTypes.PackageVersionAction?
}

extension UpdatePackageVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case attributes
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, resourceattributevalue0) in attributesContainer {
                if let resourceattributevalue0 = resourceattributevalue0 {
                    attributesDecoded0?[key0] = resourceattributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let actionDecoded = try containerValues.decodeIfPresent(IoTClientTypes.PackageVersionAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdatePackageVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePackageVersionOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePackageVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProvisioningTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultVersionId
        case description
        case enabled
        case preProvisioningHook
        case provisioningRoleArn
        case removePreProvisioningHook
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultVersionId = self.defaultVersionId {
            try encodeContainer.encode(defaultVersionId, forKey: .defaultVersionId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let preProvisioningHook = self.preProvisioningHook {
            try encodeContainer.encode(preProvisioningHook, forKey: .preProvisioningHook)
        }
        if let provisioningRoleArn = self.provisioningRoleArn {
            try encodeContainer.encode(provisioningRoleArn, forKey: .provisioningRoleArn)
        }
        if let removePreProvisioningHook = self.removePreProvisioningHook {
            try encodeContainer.encode(removePreProvisioningHook, forKey: .removePreProvisioningHook)
        }
    }
}

extension UpdateProvisioningTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let templateName = templateName else {
            return nil
        }
        return "/provisioning-templates/\(templateName.urlPercentEncoding())"
    }
}

public struct UpdateProvisioningTemplateInput: Swift.Equatable {
    /// The ID of the default provisioning template version.
    public var defaultVersionId: Swift.Int?
    /// The description of the provisioning template.
    public var description: Swift.String?
    /// True to enable the provisioning template, otherwise false.
    public var enabled: Swift.Bool?
    /// Updates the pre-provisioning hook template. Only supports template of type FLEET_PROVISIONING. For more information about provisioning template types, see [type](https://docs.aws.amazon.com/iot/latest/apireference/API_CreateProvisioningTemplate.html#iot-CreateProvisioningTemplate-request-type).
    public var preProvisioningHook: IoTClientTypes.ProvisioningHook?
    /// The ARN of the role associated with the provisioning template. This IoT role grants permission to provision a device.
    public var provisioningRoleArn: Swift.String?
    /// Removes pre-provisioning hook template.
    public var removePreProvisioningHook: Swift.Bool?
    /// The name of the provisioning template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        defaultVersionId: Swift.Int? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        preProvisioningHook: IoTClientTypes.ProvisioningHook? = nil,
        provisioningRoleArn: Swift.String? = nil,
        removePreProvisioningHook: Swift.Bool? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.defaultVersionId = defaultVersionId
        self.description = description
        self.enabled = enabled
        self.preProvisioningHook = preProvisioningHook
        self.provisioningRoleArn = provisioningRoleArn
        self.removePreProvisioningHook = removePreProvisioningHook
        self.templateName = templateName
    }
}

struct UpdateProvisioningTemplateInputBody: Swift.Equatable {
    let description: Swift.String?
    let enabled: Swift.Bool?
    let defaultVersionId: Swift.Int?
    let provisioningRoleArn: Swift.String?
    let preProvisioningHook: IoTClientTypes.ProvisioningHook?
    let removePreProvisioningHook: Swift.Bool?
}

extension UpdateProvisioningTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultVersionId
        case description
        case enabled
        case preProvisioningHook
        case provisioningRoleArn
        case removePreProvisioningHook
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let provisioningRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningRoleArn)
        provisioningRoleArn = provisioningRoleArnDecoded
        let preProvisioningHookDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ProvisioningHook.self, forKey: .preProvisioningHook)
        preProvisioningHook = preProvisioningHookDecoded
        let removePreProvisioningHookDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removePreProvisioningHook)
        removePreProvisioningHook = removePreProvisioningHookDecoded
    }
}

extension UpdateProvisioningTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateProvisioningTemplateOutput: Swift.Equatable {

    public init() { }
}

enum UpdateProvisioningTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRoleAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentialDurationSeconds
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentialDurationSeconds = self.credentialDurationSeconds {
            try encodeContainer.encode(credentialDurationSeconds, forKey: .credentialDurationSeconds)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateRoleAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let roleAlias = roleAlias else {
            return nil
        }
        return "/role-aliases/\(roleAlias.urlPercentEncoding())"
    }
}

public struct UpdateRoleAliasInput: Swift.Equatable {
    /// The number of seconds the credential will be valid. This value must be less than or equal to the maximum session duration of the IAM role that the role alias references.
    public var credentialDurationSeconds: Swift.Int?
    /// The role alias to update.
    /// This member is required.
    public var roleAlias: Swift.String?
    /// The role ARN.
    public var roleArn: Swift.String?

    public init(
        credentialDurationSeconds: Swift.Int? = nil,
        roleAlias: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.credentialDurationSeconds = credentialDurationSeconds
        self.roleAlias = roleAlias
        self.roleArn = roleArn
    }
}

struct UpdateRoleAliasInputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let credentialDurationSeconds: Swift.Int?
}

extension UpdateRoleAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentialDurationSeconds
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let credentialDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .credentialDurationSeconds)
        credentialDurationSeconds = credentialDurationSecondsDecoded
    }
}

extension UpdateRoleAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRoleAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.roleAlias = output.roleAlias
            self.roleAliasArn = output.roleAliasArn
        } else {
            self.roleAlias = nil
            self.roleAliasArn = nil
        }
    }
}

public struct UpdateRoleAliasOutput: Swift.Equatable {
    /// The role alias.
    public var roleAlias: Swift.String?
    /// The role alias ARN.
    public var roleAliasArn: Swift.String?

    public init(
        roleAlias: Swift.String? = nil,
        roleAliasArn: Swift.String? = nil
    )
    {
        self.roleAlias = roleAlias
        self.roleAliasArn = roleAliasArn
    }
}

struct UpdateRoleAliasOutputBody: Swift.Equatable {
    let roleAlias: Swift.String?
    let roleAliasArn: Swift.String?
}

extension UpdateRoleAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleAlias
        case roleAliasArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleAlias)
        roleAlias = roleAliasDecoded
        let roleAliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleAliasArn)
        roleAliasArn = roleAliasArnDecoded
    }
}

enum UpdateRoleAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateScheduledAuditInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth
        case dayOfWeek
        case frequency
        case targetCheckNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = self.dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let dayOfWeek = self.dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
        if let targetCheckNames = targetCheckNames {
            var targetCheckNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetCheckNames)
            for auditcheckname0 in targetCheckNames {
                try targetCheckNamesContainer.encode(auditcheckname0)
            }
        }
    }
}

extension UpdateScheduledAuditInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let scheduledAuditName = scheduledAuditName else {
            return nil
        }
        return "/audit/scheduledaudits/\(scheduledAuditName.urlPercentEncoding())"
    }
}

public struct UpdateScheduledAuditInput: Swift.Equatable {
    /// The day of the month on which the scheduled audit takes place. This can be 1 through 31 or LAST. This field is required if the frequency parameter is set to MONTHLY. If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.
    public var dayOfMonth: Swift.String?
    /// The day of the week on which the scheduled audit takes place. This can be one of SUN, MON, TUE, WED, THU, FRI, or SAT. This field is required if the "frequency" parameter is set to WEEKLY or BIWEEKLY.
    public var dayOfWeek: IoTClientTypes.DayOfWeek?
    /// How often the scheduled audit takes place, either DAILY, WEEKLY, BIWEEKLY, or MONTHLY. The start time of each audit is determined by the system.
    public var frequency: IoTClientTypes.AuditFrequency?
    /// The name of the scheduled audit. (Max. 128 chars)
    /// This member is required.
    public var scheduledAuditName: Swift.String?
    /// Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use DescribeAccountAuditConfiguration to see the list of all checks, including those that are enabled or use UpdateAccountAuditConfiguration to select which checks are enabled.)
    public var targetCheckNames: [Swift.String]?

    public init(
        dayOfMonth: Swift.String? = nil,
        dayOfWeek: IoTClientTypes.DayOfWeek? = nil,
        frequency: IoTClientTypes.AuditFrequency? = nil,
        scheduledAuditName: Swift.String? = nil,
        targetCheckNames: [Swift.String]? = nil
    )
    {
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.frequency = frequency
        self.scheduledAuditName = scheduledAuditName
        self.targetCheckNames = targetCheckNames
    }
}

struct UpdateScheduledAuditInputBody: Swift.Equatable {
    let frequency: IoTClientTypes.AuditFrequency?
    let dayOfMonth: Swift.String?
    let dayOfWeek: IoTClientTypes.DayOfWeek?
    let targetCheckNames: [Swift.String]?
}

extension UpdateScheduledAuditInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth
        case dayOfWeek
        case frequency
        case targetCheckNames
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frequencyDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AuditFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(IoTClientTypes.DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let targetCheckNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetCheckNames)
        var targetCheckNamesDecoded0:[Swift.String]? = nil
        if let targetCheckNamesContainer = targetCheckNamesContainer {
            targetCheckNamesDecoded0 = [Swift.String]()
            for string0 in targetCheckNamesContainer {
                if let string0 = string0 {
                    targetCheckNamesDecoded0?.append(string0)
                }
            }
        }
        targetCheckNames = targetCheckNamesDecoded0
    }
}

extension UpdateScheduledAuditOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateScheduledAuditOutputBody = try responseDecoder.decode(responseBody: data)
            self.scheduledAuditArn = output.scheduledAuditArn
        } else {
            self.scheduledAuditArn = nil
        }
    }
}

public struct UpdateScheduledAuditOutput: Swift.Equatable {
    /// The ARN of the scheduled audit.
    public var scheduledAuditArn: Swift.String?

    public init(
        scheduledAuditArn: Swift.String? = nil
    )
    {
        self.scheduledAuditArn = scheduledAuditArn
    }
}

struct UpdateScheduledAuditOutputBody: Swift.Equatable {
    let scheduledAuditArn: Swift.String?
}

extension UpdateScheduledAuditOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledAuditArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledAuditArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledAuditArn)
        scheduledAuditArn = scheduledAuditArnDecoded
    }
}

enum UpdateScheduledAuditOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSecurityProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetricsToRetain
        case additionalMetricsToRetainV2
        case alertTargets
        case behaviors
        case deleteAdditionalMetricsToRetain
        case deleteAlertTargets
        case deleteBehaviors
        case securityProfileDescription
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetricsToRetain = additionalMetricsToRetain {
            var additionalMetricsToRetainContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalMetricsToRetain)
            for behaviormetric0 in additionalMetricsToRetain {
                try additionalMetricsToRetainContainer.encode(behaviormetric0)
            }
        }
        if let additionalMetricsToRetainV2 = additionalMetricsToRetainV2 {
            var additionalMetricsToRetainV2Container = encodeContainer.nestedUnkeyedContainer(forKey: .additionalMetricsToRetainV2)
            for metrictoretain0 in additionalMetricsToRetainV2 {
                try additionalMetricsToRetainV2Container.encode(metrictoretain0)
            }
        }
        if let alertTargets = alertTargets {
            var alertTargetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .alertTargets)
            for (dictKey0, alertTargets0) in alertTargets {
                try alertTargetsContainer.encode(alertTargets0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let behaviors = behaviors {
            var behaviorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .behaviors)
            for behavior0 in behaviors {
                try behaviorsContainer.encode(behavior0)
            }
        }
        if let deleteAdditionalMetricsToRetain = self.deleteAdditionalMetricsToRetain {
            try encodeContainer.encode(deleteAdditionalMetricsToRetain, forKey: .deleteAdditionalMetricsToRetain)
        }
        if let deleteAlertTargets = self.deleteAlertTargets {
            try encodeContainer.encode(deleteAlertTargets, forKey: .deleteAlertTargets)
        }
        if let deleteBehaviors = self.deleteBehaviors {
            try encodeContainer.encode(deleteBehaviors, forKey: .deleteBehaviors)
        }
        if let securityProfileDescription = self.securityProfileDescription {
            try encodeContainer.encode(securityProfileDescription, forKey: .securityProfileDescription)
        }
    }
}

extension UpdateSecurityProfileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let expectedVersion = expectedVersion {
                let expectedVersionQueryItem = ClientRuntime.URLQueryItem(name: "expectedVersion".urlPercentEncoding(), value: Swift.String(expectedVersion).urlPercentEncoding())
                items.append(expectedVersionQueryItem)
            }
            return items
        }
    }
}

extension UpdateSecurityProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let securityProfileName = securityProfileName else {
            return nil
        }
        return "/security-profiles/\(securityProfileName.urlPercentEncoding())"
    }
}

public struct UpdateSecurityProfileInput: Swift.Equatable {
    /// Please use [UpdateSecurityProfileRequest$additionalMetricsToRetainV2] instead. A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.
    @available(*, deprecated, message: "Use additionalMetricsToRetainV2.")
    public var additionalMetricsToRetain: [Swift.String]?
    /// A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.
    public var additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]?
    /// Where the alerts are sent. (Alerts are always sent to the console.)
    public var alertTargets: [Swift.String:IoTClientTypes.AlertTarget]?
    /// Specifies the behaviors that, when violated by a device (thing), cause an alert.
    public var behaviors: [IoTClientTypes.Behavior]?
    /// If true, delete all additionalMetricsToRetain defined for this security profile. If any additionalMetricsToRetain are defined in the current invocation, an exception occurs.
    public var deleteAdditionalMetricsToRetain: Swift.Bool?
    /// If true, delete all alertTargets defined for this security profile. If any alertTargets are defined in the current invocation, an exception occurs.
    public var deleteAlertTargets: Swift.Bool?
    /// If true, delete all behaviors defined for this security profile. If any behaviors are defined in the current invocation, an exception occurs.
    public var deleteBehaviors: Swift.Bool?
    /// The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a VersionConflictException is thrown.
    public var expectedVersion: Swift.Int?
    /// A description of the security profile.
    public var securityProfileDescription: Swift.String?
    /// The name of the security profile you want to update.
    /// This member is required.
    public var securityProfileName: Swift.String?

    public init(
        additionalMetricsToRetain: [Swift.String]? = nil,
        additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]? = nil,
        alertTargets: [Swift.String:IoTClientTypes.AlertTarget]? = nil,
        behaviors: [IoTClientTypes.Behavior]? = nil,
        deleteAdditionalMetricsToRetain: Swift.Bool? = nil,
        deleteAlertTargets: Swift.Bool? = nil,
        deleteBehaviors: Swift.Bool? = nil,
        expectedVersion: Swift.Int? = nil,
        securityProfileDescription: Swift.String? = nil,
        securityProfileName: Swift.String? = nil
    )
    {
        self.additionalMetricsToRetain = additionalMetricsToRetain
        self.additionalMetricsToRetainV2 = additionalMetricsToRetainV2
        self.alertTargets = alertTargets
        self.behaviors = behaviors
        self.deleteAdditionalMetricsToRetain = deleteAdditionalMetricsToRetain
        self.deleteAlertTargets = deleteAlertTargets
        self.deleteBehaviors = deleteBehaviors
        self.expectedVersion = expectedVersion
        self.securityProfileDescription = securityProfileDescription
        self.securityProfileName = securityProfileName
    }
}

struct UpdateSecurityProfileInputBody: Swift.Equatable {
    let securityProfileDescription: Swift.String?
    let behaviors: [IoTClientTypes.Behavior]?
    let alertTargets: [Swift.String:IoTClientTypes.AlertTarget]?
    let additionalMetricsToRetain: [Swift.String]?
    let additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]?
    let deleteBehaviors: Swift.Bool?
    let deleteAlertTargets: Swift.Bool?
    let deleteAdditionalMetricsToRetain: Swift.Bool?
}

extension UpdateSecurityProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetricsToRetain
        case additionalMetricsToRetainV2
        case alertTargets
        case behaviors
        case deleteAdditionalMetricsToRetain
        case deleteAlertTargets
        case deleteBehaviors
        case securityProfileDescription
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileDescription)
        securityProfileDescription = securityProfileDescriptionDecoded
        let behaviorsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Behavior?].self, forKey: .behaviors)
        var behaviorsDecoded0:[IoTClientTypes.Behavior]? = nil
        if let behaviorsContainer = behaviorsContainer {
            behaviorsDecoded0 = [IoTClientTypes.Behavior]()
            for structure0 in behaviorsContainer {
                if let structure0 = structure0 {
                    behaviorsDecoded0?.append(structure0)
                }
            }
        }
        behaviors = behaviorsDecoded0
        let alertTargetsContainer = try containerValues.decodeIfPresent([Swift.String: IoTClientTypes.AlertTarget?].self, forKey: .alertTargets)
        var alertTargetsDecoded0: [Swift.String:IoTClientTypes.AlertTarget]? = nil
        if let alertTargetsContainer = alertTargetsContainer {
            alertTargetsDecoded0 = [Swift.String:IoTClientTypes.AlertTarget]()
            for (key0, alerttarget0) in alertTargetsContainer {
                if let alerttarget0 = alerttarget0 {
                    alertTargetsDecoded0?[key0] = alerttarget0
                }
            }
        }
        alertTargets = alertTargetsDecoded0
        let additionalMetricsToRetainContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .additionalMetricsToRetain)
        var additionalMetricsToRetainDecoded0:[Swift.String]? = nil
        if let additionalMetricsToRetainContainer = additionalMetricsToRetainContainer {
            additionalMetricsToRetainDecoded0 = [Swift.String]()
            for string0 in additionalMetricsToRetainContainer {
                if let string0 = string0 {
                    additionalMetricsToRetainDecoded0?.append(string0)
                }
            }
        }
        additionalMetricsToRetain = additionalMetricsToRetainDecoded0
        let additionalMetricsToRetainV2Container = try containerValues.decodeIfPresent([IoTClientTypes.MetricToRetain?].self, forKey: .additionalMetricsToRetainV2)
        var additionalMetricsToRetainV2Decoded0:[IoTClientTypes.MetricToRetain]? = nil
        if let additionalMetricsToRetainV2Container = additionalMetricsToRetainV2Container {
            additionalMetricsToRetainV2Decoded0 = [IoTClientTypes.MetricToRetain]()
            for structure0 in additionalMetricsToRetainV2Container {
                if let structure0 = structure0 {
                    additionalMetricsToRetainV2Decoded0?.append(structure0)
                }
            }
        }
        additionalMetricsToRetainV2 = additionalMetricsToRetainV2Decoded0
        let deleteBehaviorsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteBehaviors)
        deleteBehaviors = deleteBehaviorsDecoded
        let deleteAlertTargetsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteAlertTargets)
        deleteAlertTargets = deleteAlertTargetsDecoded
        let deleteAdditionalMetricsToRetainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteAdditionalMetricsToRetain)
        deleteAdditionalMetricsToRetain = deleteAdditionalMetricsToRetainDecoded
    }
}

extension UpdateSecurityProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSecurityProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.additionalMetricsToRetain = output.additionalMetricsToRetain
            self.additionalMetricsToRetainV2 = output.additionalMetricsToRetainV2
            self.alertTargets = output.alertTargets
            self.behaviors = output.behaviors
            self.creationDate = output.creationDate
            self.lastModifiedDate = output.lastModifiedDate
            self.securityProfileArn = output.securityProfileArn
            self.securityProfileDescription = output.securityProfileDescription
            self.securityProfileName = output.securityProfileName
            self.version = output.version
        } else {
            self.additionalMetricsToRetain = nil
            self.additionalMetricsToRetainV2 = nil
            self.alertTargets = nil
            self.behaviors = nil
            self.creationDate = nil
            self.lastModifiedDate = nil
            self.securityProfileArn = nil
            self.securityProfileDescription = nil
            self.securityProfileName = nil
            self.version = 0
        }
    }
}

public struct UpdateSecurityProfileOutput: Swift.Equatable {
    /// Please use [UpdateSecurityProfileResponse$additionalMetricsToRetainV2] instead. A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the security profile's behaviors, but it is also retained for any metric specified here.
    @available(*, deprecated, message: "Use additionalMetricsToRetainV2.")
    public var additionalMetricsToRetain: [Swift.String]?
    /// A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.
    public var additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]?
    /// Where the alerts are sent. (Alerts are always sent to the console.)
    public var alertTargets: [Swift.String:IoTClientTypes.AlertTarget]?
    /// Specifies the behaviors that, when violated by a device (thing), cause an alert.
    public var behaviors: [IoTClientTypes.Behavior]?
    /// The time the security profile was created.
    public var creationDate: ClientRuntime.Date?
    /// The time the security profile was last modified.
    public var lastModifiedDate: ClientRuntime.Date?
    /// The ARN of the security profile that was updated.
    public var securityProfileArn: Swift.String?
    /// The description of the security profile.
    public var securityProfileDescription: Swift.String?
    /// The name of the security profile that was updated.
    public var securityProfileName: Swift.String?
    /// The updated version of the security profile.
    public var version: Swift.Int

    public init(
        additionalMetricsToRetain: [Swift.String]? = nil,
        additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]? = nil,
        alertTargets: [Swift.String:IoTClientTypes.AlertTarget]? = nil,
        behaviors: [IoTClientTypes.Behavior]? = nil,
        creationDate: ClientRuntime.Date? = nil,
        lastModifiedDate: ClientRuntime.Date? = nil,
        securityProfileArn: Swift.String? = nil,
        securityProfileDescription: Swift.String? = nil,
        securityProfileName: Swift.String? = nil,
        version: Swift.Int = 0
    )
    {
        self.additionalMetricsToRetain = additionalMetricsToRetain
        self.additionalMetricsToRetainV2 = additionalMetricsToRetainV2
        self.alertTargets = alertTargets
        self.behaviors = behaviors
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.securityProfileArn = securityProfileArn
        self.securityProfileDescription = securityProfileDescription
        self.securityProfileName = securityProfileName
        self.version = version
    }
}

struct UpdateSecurityProfileOutputBody: Swift.Equatable {
    let securityProfileName: Swift.String?
    let securityProfileArn: Swift.String?
    let securityProfileDescription: Swift.String?
    let behaviors: [IoTClientTypes.Behavior]?
    let alertTargets: [Swift.String:IoTClientTypes.AlertTarget]?
    let additionalMetricsToRetain: [Swift.String]?
    let additionalMetricsToRetainV2: [IoTClientTypes.MetricToRetain]?
    let version: Swift.Int
    let creationDate: ClientRuntime.Date?
    let lastModifiedDate: ClientRuntime.Date?
}

extension UpdateSecurityProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetricsToRetain
        case additionalMetricsToRetainV2
        case alertTargets
        case behaviors
        case creationDate
        case lastModifiedDate
        case securityProfileArn
        case securityProfileDescription
        case securityProfileName
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let securityProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileArn)
        securityProfileArn = securityProfileArnDecoded
        let securityProfileDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileDescription)
        securityProfileDescription = securityProfileDescriptionDecoded
        let behaviorsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Behavior?].self, forKey: .behaviors)
        var behaviorsDecoded0:[IoTClientTypes.Behavior]? = nil
        if let behaviorsContainer = behaviorsContainer {
            behaviorsDecoded0 = [IoTClientTypes.Behavior]()
            for structure0 in behaviorsContainer {
                if let structure0 = structure0 {
                    behaviorsDecoded0?.append(structure0)
                }
            }
        }
        behaviors = behaviorsDecoded0
        let alertTargetsContainer = try containerValues.decodeIfPresent([Swift.String: IoTClientTypes.AlertTarget?].self, forKey: .alertTargets)
        var alertTargetsDecoded0: [Swift.String:IoTClientTypes.AlertTarget]? = nil
        if let alertTargetsContainer = alertTargetsContainer {
            alertTargetsDecoded0 = [Swift.String:IoTClientTypes.AlertTarget]()
            for (key0, alerttarget0) in alertTargetsContainer {
                if let alerttarget0 = alerttarget0 {
                    alertTargetsDecoded0?[key0] = alerttarget0
                }
            }
        }
        alertTargets = alertTargetsDecoded0
        let additionalMetricsToRetainContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .additionalMetricsToRetain)
        var additionalMetricsToRetainDecoded0:[Swift.String]? = nil
        if let additionalMetricsToRetainContainer = additionalMetricsToRetainContainer {
            additionalMetricsToRetainDecoded0 = [Swift.String]()
            for string0 in additionalMetricsToRetainContainer {
                if let string0 = string0 {
                    additionalMetricsToRetainDecoded0?.append(string0)
                }
            }
        }
        additionalMetricsToRetain = additionalMetricsToRetainDecoded0
        let additionalMetricsToRetainV2Container = try containerValues.decodeIfPresent([IoTClientTypes.MetricToRetain?].self, forKey: .additionalMetricsToRetainV2)
        var additionalMetricsToRetainV2Decoded0:[IoTClientTypes.MetricToRetain]? = nil
        if let additionalMetricsToRetainV2Container = additionalMetricsToRetainV2Container {
            additionalMetricsToRetainV2Decoded0 = [IoTClientTypes.MetricToRetain]()
            for structure0 in additionalMetricsToRetainV2Container {
                if let structure0 = structure0 {
                    additionalMetricsToRetainV2Decoded0?.append(structure0)
                }
            }
        }
        additionalMetricsToRetainV2 = additionalMetricsToRetainV2Decoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

enum UpdateSecurityProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case files
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let files = files {
            var filesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .files)
            for streamfile0 in files {
                try filesContainer.encode(streamfile0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let streamId = streamId else {
            return nil
        }
        return "/streams/\(streamId.urlPercentEncoding())"
    }
}

public struct UpdateStreamInput: Swift.Equatable {
    /// The description of the stream.
    public var description: Swift.String?
    /// The files associated with the stream.
    public var files: [IoTClientTypes.StreamFile]?
    /// An IAM role that allows the IoT service principal assumes to access your S3 files.
    public var roleArn: Swift.String?
    /// The stream ID.
    /// This member is required.
    public var streamId: Swift.String?

    public init(
        description: Swift.String? = nil,
        files: [IoTClientTypes.StreamFile]? = nil,
        roleArn: Swift.String? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.description = description
        self.files = files
        self.roleArn = roleArn
        self.streamId = streamId
    }
}

struct UpdateStreamInputBody: Swift.Equatable {
    let description: Swift.String?
    let files: [IoTClientTypes.StreamFile]?
    let roleArn: Swift.String?
}

extension UpdateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case files
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let filesContainer = try containerValues.decodeIfPresent([IoTClientTypes.StreamFile?].self, forKey: .files)
        var filesDecoded0:[IoTClientTypes.StreamFile]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [IoTClientTypes.StreamFile]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.streamArn = output.streamArn
            self.streamId = output.streamId
            self.streamVersion = output.streamVersion
        } else {
            self.description = nil
            self.streamArn = nil
            self.streamId = nil
            self.streamVersion = nil
        }
    }
}

public struct UpdateStreamOutput: Swift.Equatable {
    /// A description of the stream.
    public var description: Swift.String?
    /// The stream ARN.
    public var streamArn: Swift.String?
    /// The stream ID.
    public var streamId: Swift.String?
    /// The stream version.
    public var streamVersion: Swift.Int?

    public init(
        description: Swift.String? = nil,
        streamArn: Swift.String? = nil,
        streamId: Swift.String? = nil,
        streamVersion: Swift.Int? = nil
    )
    {
        self.description = description
        self.streamArn = streamArn
        self.streamId = streamId
        self.streamVersion = streamVersion
    }
}

struct UpdateStreamOutputBody: Swift.Equatable {
    let streamId: Swift.String?
    let streamArn: Swift.String?
    let description: Swift.String?
    let streamVersion: Swift.Int?
}

extension UpdateStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case streamArn
        case streamId
        case streamVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let streamVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .streamVersion)
        streamVersion = streamVersionDecoded
    }
}

enum UpdateStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateThingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedVersion
        case thingGroupProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedVersion = self.expectedVersion {
            try encodeContainer.encode(expectedVersion, forKey: .expectedVersion)
        }
        if let thingGroupProperties = self.thingGroupProperties {
            try encodeContainer.encode(thingGroupProperties, forKey: .thingGroupProperties)
        }
    }
}

extension UpdateThingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingGroupName = thingGroupName else {
            return nil
        }
        return "/thing-groups/\(thingGroupName.urlPercentEncoding())"
    }
}

public struct UpdateThingGroupInput: Swift.Equatable {
    /// The expected version of the thing group. If this does not match the version of the thing group being updated, the update will fail.
    public var expectedVersion: Swift.Int?
    /// The thing group to update.
    /// This member is required.
    public var thingGroupName: Swift.String?
    /// The thing group properties.
    /// This member is required.
    public var thingGroupProperties: IoTClientTypes.ThingGroupProperties?

    public init(
        expectedVersion: Swift.Int? = nil,
        thingGroupName: Swift.String? = nil,
        thingGroupProperties: IoTClientTypes.ThingGroupProperties? = nil
    )
    {
        self.expectedVersion = expectedVersion
        self.thingGroupName = thingGroupName
        self.thingGroupProperties = thingGroupProperties
    }
}

struct UpdateThingGroupInputBody: Swift.Equatable {
    let thingGroupProperties: IoTClientTypes.ThingGroupProperties?
    let expectedVersion: Swift.Int?
}

extension UpdateThingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedVersion
        case thingGroupProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingGroupPropertiesDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ThingGroupProperties.self, forKey: .thingGroupProperties)
        thingGroupProperties = thingGroupPropertiesDecoded
        let expectedVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedVersion)
        expectedVersion = expectedVersionDecoded
    }
}

extension UpdateThingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateThingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.version = output.version
        } else {
            self.version = 0
        }
    }
}

public struct UpdateThingGroupOutput: Swift.Equatable {
    /// The version of the updated thing group.
    public var version: Swift.Int

    public init(
        version: Swift.Int = 0
    )
    {
        self.version = version
    }
}

struct UpdateThingGroupOutputBody: Swift.Equatable {
    let version: Swift.Int
}

extension UpdateThingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
    }
}

enum UpdateThingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateThingGroupsForThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrideDynamicGroups
        case thingGroupsToAdd
        case thingGroupsToRemove
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrideDynamicGroups = self.overrideDynamicGroups {
            try encodeContainer.encode(overrideDynamicGroups, forKey: .overrideDynamicGroups)
        }
        if let thingGroupsToAdd = thingGroupsToAdd {
            var thingGroupsToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .thingGroupsToAdd)
            for thinggroupname0 in thingGroupsToAdd {
                try thingGroupsToAddContainer.encode(thinggroupname0)
            }
        }
        if let thingGroupsToRemove = thingGroupsToRemove {
            var thingGroupsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .thingGroupsToRemove)
            for thinggroupname0 in thingGroupsToRemove {
                try thingGroupsToRemoveContainer.encode(thinggroupname0)
            }
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }
}

extension UpdateThingGroupsForThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/thing-groups/updateThingGroupsForThing"
    }
}

public struct UpdateThingGroupsForThingInput: Swift.Equatable {
    /// Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.
    public var overrideDynamicGroups: Swift.Bool?
    /// The groups to which the thing will be added.
    public var thingGroupsToAdd: [Swift.String]?
    /// The groups from which the thing will be removed.
    public var thingGroupsToRemove: [Swift.String]?
    /// The thing whose group memberships will be updated.
    public var thingName: Swift.String?

    public init(
        overrideDynamicGroups: Swift.Bool? = nil,
        thingGroupsToAdd: [Swift.String]? = nil,
        thingGroupsToRemove: [Swift.String]? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.overrideDynamicGroups = overrideDynamicGroups
        self.thingGroupsToAdd = thingGroupsToAdd
        self.thingGroupsToRemove = thingGroupsToRemove
        self.thingName = thingName
    }
}

struct UpdateThingGroupsForThingInputBody: Swift.Equatable {
    let thingName: Swift.String?
    let thingGroupsToAdd: [Swift.String]?
    let thingGroupsToRemove: [Swift.String]?
    let overrideDynamicGroups: Swift.Bool?
}

extension UpdateThingGroupsForThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrideDynamicGroups
        case thingGroupsToAdd
        case thingGroupsToRemove
        case thingName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingGroupsToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .thingGroupsToAdd)
        var thingGroupsToAddDecoded0:[Swift.String]? = nil
        if let thingGroupsToAddContainer = thingGroupsToAddContainer {
            thingGroupsToAddDecoded0 = [Swift.String]()
            for string0 in thingGroupsToAddContainer {
                if let string0 = string0 {
                    thingGroupsToAddDecoded0?.append(string0)
                }
            }
        }
        thingGroupsToAdd = thingGroupsToAddDecoded0
        let thingGroupsToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .thingGroupsToRemove)
        var thingGroupsToRemoveDecoded0:[Swift.String]? = nil
        if let thingGroupsToRemoveContainer = thingGroupsToRemoveContainer {
            thingGroupsToRemoveDecoded0 = [Swift.String]()
            for string0 in thingGroupsToRemoveContainer {
                if let string0 = string0 {
                    thingGroupsToRemoveDecoded0?.append(string0)
                }
            }
        }
        thingGroupsToRemove = thingGroupsToRemoveDecoded0
        let overrideDynamicGroupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overrideDynamicGroups)
        overrideDynamicGroups = overrideDynamicGroupsDecoded
    }
}

extension UpdateThingGroupsForThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateThingGroupsForThingOutput: Swift.Equatable {

    public init() { }
}

enum UpdateThingGroupsForThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateThingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributePayload
        case expectedVersion
        case removeThingType
        case thingTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributePayload = self.attributePayload {
            try encodeContainer.encode(attributePayload, forKey: .attributePayload)
        }
        if let expectedVersion = self.expectedVersion {
            try encodeContainer.encode(expectedVersion, forKey: .expectedVersion)
        }
        if let removeThingType = self.removeThingType {
            try encodeContainer.encode(removeThingType, forKey: .removeThingType)
        }
        if let thingTypeName = self.thingTypeName {
            try encodeContainer.encode(thingTypeName, forKey: .thingTypeName)
        }
    }
}

extension UpdateThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())"
    }
}

/// The input for the UpdateThing operation.
public struct UpdateThingInput: Swift.Equatable {
    /// A list of thing attributes, a JSON string containing name-value pairs. For example: {\"attributes\":{\"name1\":\"value2\"}} This data is used to add new attributes or update existing attributes.
    public var attributePayload: IoTClientTypes.AttributePayload?
    /// The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the UpdateThing request is rejected with a VersionConflictException.
    public var expectedVersion: Swift.Int?
    /// Remove a thing type association. If true, the association is removed.
    public var removeThingType: Swift.Bool?
    /// The name of the thing to update. You can't change a thing's name. To change a thing's name, you must create a new thing, give it the new name, and then delete the old thing.
    /// This member is required.
    public var thingName: Swift.String?
    /// The name of the thing type.
    public var thingTypeName: Swift.String?

    public init(
        attributePayload: IoTClientTypes.AttributePayload? = nil,
        expectedVersion: Swift.Int? = nil,
        removeThingType: Swift.Bool? = nil,
        thingName: Swift.String? = nil,
        thingTypeName: Swift.String? = nil
    )
    {
        self.attributePayload = attributePayload
        self.expectedVersion = expectedVersion
        self.removeThingType = removeThingType
        self.thingName = thingName
        self.thingTypeName = thingTypeName
    }
}

struct UpdateThingInputBody: Swift.Equatable {
    let thingTypeName: Swift.String?
    let attributePayload: IoTClientTypes.AttributePayload?
    let expectedVersion: Swift.Int?
    let removeThingType: Swift.Bool?
}

extension UpdateThingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributePayload
        case expectedVersion
        case removeThingType
        case thingTypeName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingTypeName)
        thingTypeName = thingTypeNameDecoded
        let attributePayloadDecoded = try containerValues.decodeIfPresent(IoTClientTypes.AttributePayload.self, forKey: .attributePayload)
        attributePayload = attributePayloadDecoded
        let expectedVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedVersion)
        expectedVersion = expectedVersionDecoded
        let removeThingTypeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeThingType)
        removeThingType = removeThingTypeDecoded
    }
}

extension UpdateThingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The output from the UpdateThing operation.
public struct UpdateThingOutput: Swift.Equatable {

    public init() { }
}

enum UpdateThingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionConflictException": return try await VersionConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTopicRuleDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateTopicRuleDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/destinations"
    }
}

public struct UpdateTopicRuleDestinationInput: Swift.Equatable {
    /// The ARN of the topic rule destination.
    /// This member is required.
    public var arn: Swift.String?
    /// The status of the topic rule destination. Valid values are: IN_PROGRESS A topic rule destination was created but has not been confirmed. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint. ENABLED Confirmation was completed, and traffic to this destination is allowed. You can set status to DISABLED by calling UpdateTopicRuleDestination. DISABLED Confirmation was completed, and traffic to this destination is not allowed. You can set status to ENABLED by calling UpdateTopicRuleDestination. ERROR Confirmation could not be completed, for example if the confirmation timed out. You can call GetTopicRuleDestination for details about the error. You can set status to IN_PROGRESS by calling UpdateTopicRuleDestination. Calling UpdateTopicRuleDestination causes a new confirmation challenge to be sent to your confirmation endpoint.
    /// This member is required.
    public var status: IoTClientTypes.TopicRuleDestinationStatus?

    public init(
        arn: Swift.String? = nil,
        status: IoTClientTypes.TopicRuleDestinationStatus? = nil
    )
    {
        self.arn = arn
        self.status = status
    }
}

struct UpdateTopicRuleDestinationInputBody: Swift.Equatable {
    let arn: Swift.String?
    let status: IoTClientTypes.TopicRuleDestinationStatus?
}

extension UpdateTopicRuleDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTClientTypes.TopicRuleDestinationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateTopicRuleDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateTopicRuleDestinationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateTopicRuleDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingResourceUpdateException": return try await ConflictingResourceUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.UserProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTClientTypes {
    /// A key-value pair that you define in the header. Both the key and the value are either literal strings or valid [substitution templates](https://docs.aws.amazon.com/iot/latest/developerguide/iot-substitution-templates.html).
    public struct UserProperty: Swift.Equatable {
        /// A key to be specified in UserProperty.
        /// This member is required.
        public var key: Swift.String?
        /// A value to be specified in UserProperty.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ValidateSecurityProfileBehaviorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case behaviors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behaviors = behaviors {
            var behaviorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .behaviors)
            for behavior0 in behaviors {
                try behaviorsContainer.encode(behavior0)
            }
        }
    }
}

extension ValidateSecurityProfileBehaviorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/security-profile-behaviors/validate"
    }
}

public struct ValidateSecurityProfileBehaviorsInput: Swift.Equatable {
    /// Specifies the behaviors that, when violated by a device (thing), cause an alert.
    /// This member is required.
    public var behaviors: [IoTClientTypes.Behavior]?

    public init(
        behaviors: [IoTClientTypes.Behavior]? = nil
    )
    {
        self.behaviors = behaviors
    }
}

struct ValidateSecurityProfileBehaviorsInputBody: Swift.Equatable {
    let behaviors: [IoTClientTypes.Behavior]?
}

extension ValidateSecurityProfileBehaviorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case behaviors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let behaviorsContainer = try containerValues.decodeIfPresent([IoTClientTypes.Behavior?].self, forKey: .behaviors)
        var behaviorsDecoded0:[IoTClientTypes.Behavior]? = nil
        if let behaviorsContainer = behaviorsContainer {
            behaviorsDecoded0 = [IoTClientTypes.Behavior]()
            for structure0 in behaviorsContainer {
                if let structure0 = structure0 {
                    behaviorsDecoded0?.append(structure0)
                }
            }
        }
        behaviors = behaviorsDecoded0
    }
}

extension ValidateSecurityProfileBehaviorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidateSecurityProfileBehaviorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.valid = output.valid
            self.validationErrors = output.validationErrors
        } else {
            self.valid = false
            self.validationErrors = nil
        }
    }
}

public struct ValidateSecurityProfileBehaviorsOutput: Swift.Equatable {
    /// True if the behaviors were valid.
    public var valid: Swift.Bool
    /// The list of any errors found in the behaviors.
    public var validationErrors: [IoTClientTypes.ValidationError]?

    public init(
        valid: Swift.Bool = false,
        validationErrors: [IoTClientTypes.ValidationError]? = nil
    )
    {
        self.valid = valid
        self.validationErrors = validationErrors
    }
}

struct ValidateSecurityProfileBehaviorsOutputBody: Swift.Equatable {
    let valid: Swift.Bool
    let validationErrors: [IoTClientTypes.ValidationError]?
}

extension ValidateSecurityProfileBehaviorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valid
        case validationErrors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .valid) ?? false
        valid = validDecoded
        let validationErrorsContainer = try containerValues.decodeIfPresent([IoTClientTypes.ValidationError?].self, forKey: .validationErrors)
        var validationErrorsDecoded0:[IoTClientTypes.ValidationError]? = nil
        if let validationErrorsContainer = validationErrorsContainer {
            validationErrorsDecoded0 = [IoTClientTypes.ValidationError]()
            for structure0 in validationErrorsContainer {
                if let structure0 = structure0 {
                    validationErrorsDecoded0?.append(structure0)
                }
            }
        }
        validationErrors = validationErrorsDecoded0
    }
}

enum ValidateSecurityProfileBehaviorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTClientTypes.ValidationError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension IoTClientTypes {
    /// Information about an error found in a behavior specification.
    public struct ValidationError: Swift.Equatable {
        /// The description of an error found in the behaviors.
        public var errorMessage: Swift.String?

        public init(
            errorMessage: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes {
    public enum VerificationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case benignPositive
        case falsePositive
        case truePositive
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [VerificationState] {
            return [
                .benignPositive,
                .falsePositive,
                .truePositive,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .benignPositive: return "BENIGN_POSITIVE"
            case .falsePositive: return "FALSE_POSITIVE"
            case .truePositive: return "TRUE_POSITIVE"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VerificationState(rawValue: rawValue) ?? VerificationState.sdkUnknown(rawValue)
        }
    }
}

extension VersionConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: VersionConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception thrown when the version of an entity specified with the expectedVersion parameter does not match the latest version in the system.
public struct VersionConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "VersionConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct VersionConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension VersionConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes.VersionUpdateByJobsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTClientTypes {
    /// Configuration to manage IoT Job's package version reporting. If configured, Jobs updates the thing's reserved named shadow with the package version information up on successful job completion. Note: For each job, the destinationPackageVersions attribute has to be set with the correct data for Jobs to report to the thing shadow.
    public struct VersionUpdateByJobsConfig: Swift.Equatable {
        /// Indicates whether the Job is enabled or not.
        public var enabled: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the role that grants permission to the IoT jobs service to update the reserved named shadow when the job successfully completes.
        public var roleArn: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.roleArn = roleArn
        }
    }

}

extension VersionsLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: VersionsLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of policy versions exceeds the limit.
public struct VersionsLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "VersionsLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct VersionsLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension VersionsLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTClientTypes.ViolationEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case behavior
        case metricValue
        case securityProfileName
        case thingName
        case verificationState
        case verificationStateDescription
        case violationEventAdditionalInfo
        case violationEventTime
        case violationEventType
        case violationId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behavior = self.behavior {
            try encodeContainer.encode(behavior, forKey: .behavior)
        }
        if let metricValue = self.metricValue {
            try encodeContainer.encode(metricValue, forKey: .metricValue)
        }
        if let securityProfileName = self.securityProfileName {
            try encodeContainer.encode(securityProfileName, forKey: .securityProfileName)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
        if let verificationState = self.verificationState {
            try encodeContainer.encode(verificationState.rawValue, forKey: .verificationState)
        }
        if let verificationStateDescription = self.verificationStateDescription {
            try encodeContainer.encode(verificationStateDescription, forKey: .verificationStateDescription)
        }
        if let violationEventAdditionalInfo = self.violationEventAdditionalInfo {
            try encodeContainer.encode(violationEventAdditionalInfo, forKey: .violationEventAdditionalInfo)
        }
        if let violationEventTime = self.violationEventTime {
            try encodeContainer.encodeTimestamp(violationEventTime, format: .epochSeconds, forKey: .violationEventTime)
        }
        if let violationEventType = self.violationEventType {
            try encodeContainer.encode(violationEventType.rawValue, forKey: .violationEventType)
        }
        if let violationId = self.violationId {
            try encodeContainer.encode(violationId, forKey: .violationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .violationId)
        violationId = violationIdDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let securityProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProfileName)
        securityProfileName = securityProfileNameDecoded
        let behaviorDecoded = try containerValues.decodeIfPresent(IoTClientTypes.Behavior.self, forKey: .behavior)
        behavior = behaviorDecoded
        let metricValueDecoded = try containerValues.decodeIfPresent(IoTClientTypes.MetricValue.self, forKey: .metricValue)
        metricValue = metricValueDecoded
        let violationEventAdditionalInfoDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ViolationEventAdditionalInfo.self, forKey: .violationEventAdditionalInfo)
        violationEventAdditionalInfo = violationEventAdditionalInfoDecoded
        let violationEventTypeDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ViolationEventType.self, forKey: .violationEventType)
        violationEventType = violationEventTypeDecoded
        let verificationStateDecoded = try containerValues.decodeIfPresent(IoTClientTypes.VerificationState.self, forKey: .verificationState)
        verificationState = verificationStateDecoded
        let verificationStateDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verificationStateDescription)
        verificationStateDescription = verificationStateDescriptionDecoded
        let violationEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .violationEventTime)
        violationEventTime = violationEventTimeDecoded
    }
}

extension IoTClientTypes {
    /// Information about a Device Defender security profile behavior violation.
    public struct ViolationEvent: Swift.Equatable {
        /// The behavior that was violated.
        public var behavior: IoTClientTypes.Behavior?
        /// The value of the metric (the measurement).
        public var metricValue: IoTClientTypes.MetricValue?
        /// The name of the security profile whose behavior was violated.
        public var securityProfileName: Swift.String?
        /// The name of the thing responsible for the violation event.
        public var thingName: Swift.String?
        /// The verification state of the violation (detect alarm).
        public var verificationState: IoTClientTypes.VerificationState?
        /// The description of the verification state of the violation.
        public var verificationStateDescription: Swift.String?
        /// The details of a violation event.
        public var violationEventAdditionalInfo: IoTClientTypes.ViolationEventAdditionalInfo?
        /// The time the violation event occurred.
        public var violationEventTime: ClientRuntime.Date?
        /// The type of violation event.
        public var violationEventType: IoTClientTypes.ViolationEventType?
        /// The ID of the violation event.
        public var violationId: Swift.String?

        public init(
            behavior: IoTClientTypes.Behavior? = nil,
            metricValue: IoTClientTypes.MetricValue? = nil,
            securityProfileName: Swift.String? = nil,
            thingName: Swift.String? = nil,
            verificationState: IoTClientTypes.VerificationState? = nil,
            verificationStateDescription: Swift.String? = nil,
            violationEventAdditionalInfo: IoTClientTypes.ViolationEventAdditionalInfo? = nil,
            violationEventTime: ClientRuntime.Date? = nil,
            violationEventType: IoTClientTypes.ViolationEventType? = nil,
            violationId: Swift.String? = nil
        )
        {
            self.behavior = behavior
            self.metricValue = metricValue
            self.securityProfileName = securityProfileName
            self.thingName = thingName
            self.verificationState = verificationState
            self.verificationStateDescription = verificationStateDescription
            self.violationEventAdditionalInfo = violationEventAdditionalInfo
            self.violationEventTime = violationEventTime
            self.violationEventType = violationEventType
            self.violationId = violationId
        }
    }

}

extension IoTClientTypes.ViolationEventAdditionalInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confidenceLevel
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confidenceLevel = self.confidenceLevel {
            try encodeContainer.encode(confidenceLevel.rawValue, forKey: .confidenceLevel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confidenceLevelDecoded = try containerValues.decodeIfPresent(IoTClientTypes.ConfidenceLevel.self, forKey: .confidenceLevel)
        confidenceLevel = confidenceLevelDecoded
    }
}

extension IoTClientTypes {
    /// The details of a violation event.
    public struct ViolationEventAdditionalInfo: Swift.Equatable {
        /// The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
        public var confidenceLevel: IoTClientTypes.ConfidenceLevel?

        public init(
            confidenceLevel: IoTClientTypes.ConfidenceLevel? = nil
        )
        {
            self.confidenceLevel = confidenceLevel
        }
    }

}

extension IoTClientTypes.ViolationEventOccurrenceRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension IoTClientTypes {
    /// Specifies the time period of which violation events occurred between.
    public struct ViolationEventOccurrenceRange: Swift.Equatable {
        /// The end date and time of a time period in which violation events occurred.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// The start date and time of a time period in which violation events occurred.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension IoTClientTypes {
    public enum ViolationEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alarmCleared
        case alarmInvalidated
        case inAlarm
        case sdkUnknown(Swift.String)

        public static var allCases: [ViolationEventType] {
            return [
                .alarmCleared,
                .alarmInvalidated,
                .inAlarm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alarmCleared: return "alarm-cleared"
            case .alarmInvalidated: return "alarm-invalidated"
            case .inAlarm: return "in-alarm"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ViolationEventType(rawValue: rawValue) ?? ViolationEventType.sdkUnknown(rawValue)
        }
    }
}

extension IoTClientTypes.VpcDestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case securityGroups
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroupid0 in securityGroups {
                try securityGroupsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTClientTypes {
    /// The configuration information for a virtual private cloud (VPC) destination.
    public struct VpcDestinationConfiguration: Swift.Equatable {
        /// The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The security groups of the VPC destination.
        public var securityGroups: [Swift.String]?
        /// The subnet IDs of the VPC destination.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.securityGroups = securityGroups
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension IoTClientTypes.VpcDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case securityGroups
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroupid0 in securityGroups {
                try securityGroupsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTClientTypes {
    /// The properties of a virtual private cloud (VPC) destination.
    public struct VpcDestinationProperties: Swift.Equatable {
        /// The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
        public var roleArn: Swift.String?
        /// The security groups of the VPC destination.
        public var securityGroups: [Swift.String]?
        /// The subnet IDs of the VPC destination.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.securityGroups = securityGroups
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension IoTClientTypes.VpcDestinationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case securityGroups
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroupid0 in securityGroups {
                try securityGroupsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTClientTypes {
    /// The summary of a virtual private cloud (VPC) destination.
    public struct VpcDestinationSummary: Swift.Equatable {
        /// The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
        public var roleArn: Swift.String?
        /// The security groups of the VPC destination.
        public var securityGroups: [Swift.String]?
        /// The subnet IDs of the VPC destination.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.securityGroups = securityGroups
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}
