// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[GetBehaviorModelTrainingSummariesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetBehaviorModelTrainingSummariesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetBehaviorModelTrainingSummariesOutputResponse`
extension IoTClient {
    public func getBehaviorModelTrainingSummariesPaginated(input: GetBehaviorModelTrainingSummariesInput) -> ClientRuntime.PaginatorSequence<GetBehaviorModelTrainingSummariesInput, GetBehaviorModelTrainingSummariesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetBehaviorModelTrainingSummariesInput, GetBehaviorModelTrainingSummariesOutputResponse>(input: input, inputKey: \GetBehaviorModelTrainingSummariesInput.nextToken, outputKey: \GetBehaviorModelTrainingSummariesOutputResponse.nextToken, paginationFunction: self.getBehaviorModelTrainingSummaries(input:))
    }
}

extension GetBehaviorModelTrainingSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBehaviorModelTrainingSummariesInput {
        return GetBehaviorModelTrainingSummariesInput(
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getBehaviorModelTrainingSummariesPaginated`
/// to access the nested member `[IoTClientTypes.BehaviorModelTrainingSummary]`
/// - Returns: `[IoTClientTypes.BehaviorModelTrainingSummary]`
extension PaginatorSequence where Input == GetBehaviorModelTrainingSummariesInput, Output == GetBehaviorModelTrainingSummariesOutputResponse {
    public func summaries() async throws -> [IoTClientTypes.BehaviorModelTrainingSummary] {
        return try await self.asyncCompactMap { item in item.summaries }
    }
}

/// Paginate over `[ListActiveViolationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListActiveViolationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListActiveViolationsOutputResponse`
extension IoTClient {
    public func listActiveViolationsPaginated(input: ListActiveViolationsInput) -> ClientRuntime.PaginatorSequence<ListActiveViolationsInput, ListActiveViolationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListActiveViolationsInput, ListActiveViolationsOutputResponse>(input: input, inputKey: \ListActiveViolationsInput.nextToken, outputKey: \ListActiveViolationsOutputResponse.nextToken, paginationFunction: self.listActiveViolations(input:))
    }
}

extension ListActiveViolationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListActiveViolationsInput {
        return ListActiveViolationsInput(
            behaviorCriteriaType: self.behaviorCriteriaType,
            listSuppressedAlerts: self.listSuppressedAlerts,
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName,
            thingName: self.thingName,
            verificationState: self.verificationState
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listActiveViolationsPaginated`
/// to access the nested member `[IoTClientTypes.ActiveViolation]`
/// - Returns: `[IoTClientTypes.ActiveViolation]`
extension PaginatorSequence where Input == ListActiveViolationsInput, Output == ListActiveViolationsOutputResponse {
    public func activeViolations() async throws -> [IoTClientTypes.ActiveViolation] {
        return try await self.asyncCompactMap { item in item.activeViolations }
    }
}

/// Paginate over `[ListAttachedPoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAttachedPoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAttachedPoliciesOutputResponse`
extension IoTClient {
    public func listAttachedPoliciesPaginated(input: ListAttachedPoliciesInput) -> ClientRuntime.PaginatorSequence<ListAttachedPoliciesInput, ListAttachedPoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAttachedPoliciesInput, ListAttachedPoliciesOutputResponse>(input: input, inputKey: \ListAttachedPoliciesInput.marker, outputKey: \ListAttachedPoliciesOutputResponse.nextMarker, paginationFunction: self.listAttachedPolicies(input:))
    }
}

extension ListAttachedPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAttachedPoliciesInput {
        return ListAttachedPoliciesInput(
            marker: token,
            pageSize: self.pageSize,
            recursive: self.recursive,
            target: self.target
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAttachedPoliciesPaginated`
/// to access the nested member `[IoTClientTypes.Policy]`
/// - Returns: `[IoTClientTypes.Policy]`
extension PaginatorSequence where Input == ListAttachedPoliciesInput, Output == ListAttachedPoliciesOutputResponse {
    public func policies() async throws -> [IoTClientTypes.Policy] {
        return try await self.asyncCompactMap { item in item.policies }
    }
}

/// Paginate over `[ListAuditFindingsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAuditFindingsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAuditFindingsOutputResponse`
extension IoTClient {
    public func listAuditFindingsPaginated(input: ListAuditFindingsInput) -> ClientRuntime.PaginatorSequence<ListAuditFindingsInput, ListAuditFindingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAuditFindingsInput, ListAuditFindingsOutputResponse>(input: input, inputKey: \ListAuditFindingsInput.nextToken, outputKey: \ListAuditFindingsOutputResponse.nextToken, paginationFunction: self.listAuditFindings(input:))
    }
}

extension ListAuditFindingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAuditFindingsInput {
        return ListAuditFindingsInput(
            checkName: self.checkName,
            endTime: self.endTime,
            listSuppressedFindings: self.listSuppressedFindings,
            maxResults: self.maxResults,
            nextToken: token,
            resourceIdentifier: self.resourceIdentifier,
            startTime: self.startTime,
            taskId: self.taskId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAuditFindingsPaginated`
/// to access the nested member `[IoTClientTypes.AuditFinding]`
/// - Returns: `[IoTClientTypes.AuditFinding]`
extension PaginatorSequence where Input == ListAuditFindingsInput, Output == ListAuditFindingsOutputResponse {
    public func findings() async throws -> [IoTClientTypes.AuditFinding] {
        return try await self.asyncCompactMap { item in item.findings }
    }
}

/// Paginate over `[ListAuditMitigationActionsExecutionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAuditMitigationActionsExecutionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAuditMitigationActionsExecutionsOutputResponse`
extension IoTClient {
    public func listAuditMitigationActionsExecutionsPaginated(input: ListAuditMitigationActionsExecutionsInput) -> ClientRuntime.PaginatorSequence<ListAuditMitigationActionsExecutionsInput, ListAuditMitigationActionsExecutionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAuditMitigationActionsExecutionsInput, ListAuditMitigationActionsExecutionsOutputResponse>(input: input, inputKey: \ListAuditMitigationActionsExecutionsInput.nextToken, outputKey: \ListAuditMitigationActionsExecutionsOutputResponse.nextToken, paginationFunction: self.listAuditMitigationActionsExecutions(input:))
    }
}

extension ListAuditMitigationActionsExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAuditMitigationActionsExecutionsInput {
        return ListAuditMitigationActionsExecutionsInput(
            actionStatus: self.actionStatus,
            findingId: self.findingId,
            maxResults: self.maxResults,
            nextToken: token,
            taskId: self.taskId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAuditMitigationActionsExecutionsPaginated`
/// to access the nested member `[IoTClientTypes.AuditMitigationActionExecutionMetadata]`
/// - Returns: `[IoTClientTypes.AuditMitigationActionExecutionMetadata]`
extension PaginatorSequence where Input == ListAuditMitigationActionsExecutionsInput, Output == ListAuditMitigationActionsExecutionsOutputResponse {
    public func actionsExecutions() async throws -> [IoTClientTypes.AuditMitigationActionExecutionMetadata] {
        return try await self.asyncCompactMap { item in item.actionsExecutions }
    }
}

/// Paginate over `[ListAuditMitigationActionsTasksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAuditMitigationActionsTasksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAuditMitigationActionsTasksOutputResponse`
extension IoTClient {
    public func listAuditMitigationActionsTasksPaginated(input: ListAuditMitigationActionsTasksInput) -> ClientRuntime.PaginatorSequence<ListAuditMitigationActionsTasksInput, ListAuditMitigationActionsTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAuditMitigationActionsTasksInput, ListAuditMitigationActionsTasksOutputResponse>(input: input, inputKey: \ListAuditMitigationActionsTasksInput.nextToken, outputKey: \ListAuditMitigationActionsTasksOutputResponse.nextToken, paginationFunction: self.listAuditMitigationActionsTasks(input:))
    }
}

extension ListAuditMitigationActionsTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAuditMitigationActionsTasksInput {
        return ListAuditMitigationActionsTasksInput(
            auditTaskId: self.auditTaskId,
            endTime: self.endTime,
            findingId: self.findingId,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            taskStatus: self.taskStatus
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAuditMitigationActionsTasksPaginated`
/// to access the nested member `[IoTClientTypes.AuditMitigationActionsTaskMetadata]`
/// - Returns: `[IoTClientTypes.AuditMitigationActionsTaskMetadata]`
extension PaginatorSequence where Input == ListAuditMitigationActionsTasksInput, Output == ListAuditMitigationActionsTasksOutputResponse {
    public func tasks() async throws -> [IoTClientTypes.AuditMitigationActionsTaskMetadata] {
        return try await self.asyncCompactMap { item in item.tasks }
    }
}

/// Paginate over `[ListAuditSuppressionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAuditSuppressionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAuditSuppressionsOutputResponse`
extension IoTClient {
    public func listAuditSuppressionsPaginated(input: ListAuditSuppressionsInput) -> ClientRuntime.PaginatorSequence<ListAuditSuppressionsInput, ListAuditSuppressionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAuditSuppressionsInput, ListAuditSuppressionsOutputResponse>(input: input, inputKey: \ListAuditSuppressionsInput.nextToken, outputKey: \ListAuditSuppressionsOutputResponse.nextToken, paginationFunction: self.listAuditSuppressions(input:))
    }
}

extension ListAuditSuppressionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAuditSuppressionsInput {
        return ListAuditSuppressionsInput(
            ascendingOrder: self.ascendingOrder,
            checkName: self.checkName,
            maxResults: self.maxResults,
            nextToken: token,
            resourceIdentifier: self.resourceIdentifier
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAuditSuppressionsPaginated`
/// to access the nested member `[IoTClientTypes.AuditSuppression]`
/// - Returns: `[IoTClientTypes.AuditSuppression]`
extension PaginatorSequence where Input == ListAuditSuppressionsInput, Output == ListAuditSuppressionsOutputResponse {
    public func suppressions() async throws -> [IoTClientTypes.AuditSuppression] {
        return try await self.asyncCompactMap { item in item.suppressions }
    }
}

/// Paginate over `[ListAuditTasksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAuditTasksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAuditTasksOutputResponse`
extension IoTClient {
    public func listAuditTasksPaginated(input: ListAuditTasksInput) -> ClientRuntime.PaginatorSequence<ListAuditTasksInput, ListAuditTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAuditTasksInput, ListAuditTasksOutputResponse>(input: input, inputKey: \ListAuditTasksInput.nextToken, outputKey: \ListAuditTasksOutputResponse.nextToken, paginationFunction: self.listAuditTasks(input:))
    }
}

extension ListAuditTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAuditTasksInput {
        return ListAuditTasksInput(
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            taskStatus: self.taskStatus,
            taskType: self.taskType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAuditTasksPaginated`
/// to access the nested member `[IoTClientTypes.AuditTaskMetadata]`
/// - Returns: `[IoTClientTypes.AuditTaskMetadata]`
extension PaginatorSequence where Input == ListAuditTasksInput, Output == ListAuditTasksOutputResponse {
    public func tasks() async throws -> [IoTClientTypes.AuditTaskMetadata] {
        return try await self.asyncCompactMap { item in item.tasks }
    }
}

/// Paginate over `[ListAuthorizersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAuthorizersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAuthorizersOutputResponse`
extension IoTClient {
    public func listAuthorizersPaginated(input: ListAuthorizersInput) -> ClientRuntime.PaginatorSequence<ListAuthorizersInput, ListAuthorizersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAuthorizersInput, ListAuthorizersOutputResponse>(input: input, inputKey: \ListAuthorizersInput.marker, outputKey: \ListAuthorizersOutputResponse.nextMarker, paginationFunction: self.listAuthorizers(input:))
    }
}

extension ListAuthorizersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAuthorizersInput {
        return ListAuthorizersInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            status: self.status
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAuthorizersPaginated`
/// to access the nested member `[IoTClientTypes.AuthorizerSummary]`
/// - Returns: `[IoTClientTypes.AuthorizerSummary]`
extension PaginatorSequence where Input == ListAuthorizersInput, Output == ListAuthorizersOutputResponse {
    public func authorizers() async throws -> [IoTClientTypes.AuthorizerSummary] {
        return try await self.asyncCompactMap { item in item.authorizers }
    }
}

/// Paginate over `[ListBillingGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBillingGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBillingGroupsOutputResponse`
extension IoTClient {
    public func listBillingGroupsPaginated(input: ListBillingGroupsInput) -> ClientRuntime.PaginatorSequence<ListBillingGroupsInput, ListBillingGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBillingGroupsInput, ListBillingGroupsOutputResponse>(input: input, inputKey: \ListBillingGroupsInput.nextToken, outputKey: \ListBillingGroupsOutputResponse.nextToken, paginationFunction: self.listBillingGroups(input:))
    }
}

extension ListBillingGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBillingGroupsInput {
        return ListBillingGroupsInput(
            maxResults: self.maxResults,
            namePrefixFilter: self.namePrefixFilter,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listBillingGroupsPaginated`
/// to access the nested member `[IoTClientTypes.GroupNameAndArn]`
/// - Returns: `[IoTClientTypes.GroupNameAndArn]`
extension PaginatorSequence where Input == ListBillingGroupsInput, Output == ListBillingGroupsOutputResponse {
    public func billingGroups() async throws -> [IoTClientTypes.GroupNameAndArn] {
        return try await self.asyncCompactMap { item in item.billingGroups }
    }
}

/// Paginate over `[ListCACertificatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCACertificatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCACertificatesOutputResponse`
extension IoTClient {
    public func listCACertificatesPaginated(input: ListCACertificatesInput) -> ClientRuntime.PaginatorSequence<ListCACertificatesInput, ListCACertificatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCACertificatesInput, ListCACertificatesOutputResponse>(input: input, inputKey: \ListCACertificatesInput.marker, outputKey: \ListCACertificatesOutputResponse.nextMarker, paginationFunction: self.listCACertificates(input:))
    }
}

extension ListCACertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCACertificatesInput {
        return ListCACertificatesInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            templateName: self.templateName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCACertificatesPaginated`
/// to access the nested member `[IoTClientTypes.CACertificate]`
/// - Returns: `[IoTClientTypes.CACertificate]`
extension PaginatorSequence where Input == ListCACertificatesInput, Output == ListCACertificatesOutputResponse {
    public func certificates() async throws -> [IoTClientTypes.CACertificate] {
        return try await self.asyncCompactMap { item in item.certificates }
    }
}

/// Paginate over `[ListCertificatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCertificatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCertificatesOutputResponse`
extension IoTClient {
    public func listCertificatesPaginated(input: ListCertificatesInput) -> ClientRuntime.PaginatorSequence<ListCertificatesInput, ListCertificatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCertificatesInput, ListCertificatesOutputResponse>(input: input, inputKey: \ListCertificatesInput.marker, outputKey: \ListCertificatesOutputResponse.nextMarker, paginationFunction: self.listCertificates(input:))
    }
}

extension ListCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCertificatesInput {
        return ListCertificatesInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCertificatesPaginated`
/// to access the nested member `[IoTClientTypes.Certificate]`
/// - Returns: `[IoTClientTypes.Certificate]`
extension PaginatorSequence where Input == ListCertificatesInput, Output == ListCertificatesOutputResponse {
    public func certificates() async throws -> [IoTClientTypes.Certificate] {
        return try await self.asyncCompactMap { item in item.certificates }
    }
}

/// Paginate over `[ListCertificatesByCAOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCertificatesByCAInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCertificatesByCAOutputResponse`
extension IoTClient {
    public func listCertificatesByCAPaginated(input: ListCertificatesByCAInput) -> ClientRuntime.PaginatorSequence<ListCertificatesByCAInput, ListCertificatesByCAOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCertificatesByCAInput, ListCertificatesByCAOutputResponse>(input: input, inputKey: \ListCertificatesByCAInput.marker, outputKey: \ListCertificatesByCAOutputResponse.nextMarker, paginationFunction: self.listCertificatesByCA(input:))
    }
}

extension ListCertificatesByCAInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCertificatesByCAInput {
        return ListCertificatesByCAInput(
            ascendingOrder: self.ascendingOrder,
            caCertificateId: self.caCertificateId,
            marker: token,
            pageSize: self.pageSize
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCertificatesByCAPaginated`
/// to access the nested member `[IoTClientTypes.Certificate]`
/// - Returns: `[IoTClientTypes.Certificate]`
extension PaginatorSequence where Input == ListCertificatesByCAInput, Output == ListCertificatesByCAOutputResponse {
    public func certificates() async throws -> [IoTClientTypes.Certificate] {
        return try await self.asyncCompactMap { item in item.certificates }
    }
}

/// Paginate over `[ListCustomMetricsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCustomMetricsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCustomMetricsOutputResponse`
extension IoTClient {
    public func listCustomMetricsPaginated(input: ListCustomMetricsInput) -> ClientRuntime.PaginatorSequence<ListCustomMetricsInput, ListCustomMetricsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCustomMetricsInput, ListCustomMetricsOutputResponse>(input: input, inputKey: \ListCustomMetricsInput.nextToken, outputKey: \ListCustomMetricsOutputResponse.nextToken, paginationFunction: self.listCustomMetrics(input:))
    }
}

extension ListCustomMetricsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCustomMetricsInput {
        return ListCustomMetricsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCustomMetricsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListCustomMetricsInput, Output == ListCustomMetricsOutputResponse {
    public func metricNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.metricNames }
    }
}

/// Paginate over `[ListDetectMitigationActionsExecutionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDetectMitigationActionsExecutionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDetectMitigationActionsExecutionsOutputResponse`
extension IoTClient {
    public func listDetectMitigationActionsExecutionsPaginated(input: ListDetectMitigationActionsExecutionsInput) -> ClientRuntime.PaginatorSequence<ListDetectMitigationActionsExecutionsInput, ListDetectMitigationActionsExecutionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDetectMitigationActionsExecutionsInput, ListDetectMitigationActionsExecutionsOutputResponse>(input: input, inputKey: \ListDetectMitigationActionsExecutionsInput.nextToken, outputKey: \ListDetectMitigationActionsExecutionsOutputResponse.nextToken, paginationFunction: self.listDetectMitigationActionsExecutions(input:))
    }
}

extension ListDetectMitigationActionsExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDetectMitigationActionsExecutionsInput {
        return ListDetectMitigationActionsExecutionsInput(
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            taskId: self.taskId,
            thingName: self.thingName,
            violationId: self.violationId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDetectMitigationActionsExecutionsPaginated`
/// to access the nested member `[IoTClientTypes.DetectMitigationActionExecution]`
/// - Returns: `[IoTClientTypes.DetectMitigationActionExecution]`
extension PaginatorSequence where Input == ListDetectMitigationActionsExecutionsInput, Output == ListDetectMitigationActionsExecutionsOutputResponse {
    public func actionsExecutions() async throws -> [IoTClientTypes.DetectMitigationActionExecution] {
        return try await self.asyncCompactMap { item in item.actionsExecutions }
    }
}

/// Paginate over `[ListDetectMitigationActionsTasksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDetectMitigationActionsTasksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDetectMitigationActionsTasksOutputResponse`
extension IoTClient {
    public func listDetectMitigationActionsTasksPaginated(input: ListDetectMitigationActionsTasksInput) -> ClientRuntime.PaginatorSequence<ListDetectMitigationActionsTasksInput, ListDetectMitigationActionsTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDetectMitigationActionsTasksInput, ListDetectMitigationActionsTasksOutputResponse>(input: input, inputKey: \ListDetectMitigationActionsTasksInput.nextToken, outputKey: \ListDetectMitigationActionsTasksOutputResponse.nextToken, paginationFunction: self.listDetectMitigationActionsTasks(input:))
    }
}

extension ListDetectMitigationActionsTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDetectMitigationActionsTasksInput {
        return ListDetectMitigationActionsTasksInput(
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDetectMitigationActionsTasksPaginated`
/// to access the nested member `[IoTClientTypes.DetectMitigationActionsTaskSummary]`
/// - Returns: `[IoTClientTypes.DetectMitigationActionsTaskSummary]`
extension PaginatorSequence where Input == ListDetectMitigationActionsTasksInput, Output == ListDetectMitigationActionsTasksOutputResponse {
    public func tasks() async throws -> [IoTClientTypes.DetectMitigationActionsTaskSummary] {
        return try await self.asyncCompactMap { item in item.tasks }
    }
}

/// Paginate over `[ListDimensionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDimensionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDimensionsOutputResponse`
extension IoTClient {
    public func listDimensionsPaginated(input: ListDimensionsInput) -> ClientRuntime.PaginatorSequence<ListDimensionsInput, ListDimensionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDimensionsInput, ListDimensionsOutputResponse>(input: input, inputKey: \ListDimensionsInput.nextToken, outputKey: \ListDimensionsOutputResponse.nextToken, paginationFunction: self.listDimensions(input:))
    }
}

extension ListDimensionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDimensionsInput {
        return ListDimensionsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDimensionsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListDimensionsInput, Output == ListDimensionsOutputResponse {
    public func dimensionNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.dimensionNames }
    }
}

/// Paginate over `[ListDomainConfigurationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDomainConfigurationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDomainConfigurationsOutputResponse`
extension IoTClient {
    public func listDomainConfigurationsPaginated(input: ListDomainConfigurationsInput) -> ClientRuntime.PaginatorSequence<ListDomainConfigurationsInput, ListDomainConfigurationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDomainConfigurationsInput, ListDomainConfigurationsOutputResponse>(input: input, inputKey: \ListDomainConfigurationsInput.marker, outputKey: \ListDomainConfigurationsOutputResponse.nextMarker, paginationFunction: self.listDomainConfigurations(input:))
    }
}

extension ListDomainConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDomainConfigurationsInput {
        return ListDomainConfigurationsInput(
            marker: token,
            pageSize: self.pageSize,
            serviceType: self.serviceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDomainConfigurationsPaginated`
/// to access the nested member `[IoTClientTypes.DomainConfigurationSummary]`
/// - Returns: `[IoTClientTypes.DomainConfigurationSummary]`
extension PaginatorSequence where Input == ListDomainConfigurationsInput, Output == ListDomainConfigurationsOutputResponse {
    public func domainConfigurations() async throws -> [IoTClientTypes.DomainConfigurationSummary] {
        return try await self.asyncCompactMap { item in item.domainConfigurations }
    }
}

/// Paginate over `[ListFleetMetricsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListFleetMetricsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListFleetMetricsOutputResponse`
extension IoTClient {
    public func listFleetMetricsPaginated(input: ListFleetMetricsInput) -> ClientRuntime.PaginatorSequence<ListFleetMetricsInput, ListFleetMetricsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFleetMetricsInput, ListFleetMetricsOutputResponse>(input: input, inputKey: \ListFleetMetricsInput.nextToken, outputKey: \ListFleetMetricsOutputResponse.nextToken, paginationFunction: self.listFleetMetrics(input:))
    }
}

extension ListFleetMetricsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFleetMetricsInput {
        return ListFleetMetricsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listFleetMetricsPaginated`
/// to access the nested member `[IoTClientTypes.FleetMetricNameAndArn]`
/// - Returns: `[IoTClientTypes.FleetMetricNameAndArn]`
extension PaginatorSequence where Input == ListFleetMetricsInput, Output == ListFleetMetricsOutputResponse {
    public func fleetMetrics() async throws -> [IoTClientTypes.FleetMetricNameAndArn] {
        return try await self.asyncCompactMap { item in item.fleetMetrics }
    }
}

/// Paginate over `[ListIndicesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListIndicesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListIndicesOutputResponse`
extension IoTClient {
    public func listIndicesPaginated(input: ListIndicesInput) -> ClientRuntime.PaginatorSequence<ListIndicesInput, ListIndicesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIndicesInput, ListIndicesOutputResponse>(input: input, inputKey: \ListIndicesInput.nextToken, outputKey: \ListIndicesOutputResponse.nextToken, paginationFunction: self.listIndices(input:))
    }
}

extension ListIndicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIndicesInput {
        return ListIndicesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listIndicesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListIndicesInput, Output == ListIndicesOutputResponse {
    public func indexNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.indexNames }
    }
}

/// Paginate over `[ListJobExecutionsForJobOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListJobExecutionsForJobInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListJobExecutionsForJobOutputResponse`
extension IoTClient {
    public func listJobExecutionsForJobPaginated(input: ListJobExecutionsForJobInput) -> ClientRuntime.PaginatorSequence<ListJobExecutionsForJobInput, ListJobExecutionsForJobOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListJobExecutionsForJobInput, ListJobExecutionsForJobOutputResponse>(input: input, inputKey: \ListJobExecutionsForJobInput.nextToken, outputKey: \ListJobExecutionsForJobOutputResponse.nextToken, paginationFunction: self.listJobExecutionsForJob(input:))
    }
}

extension ListJobExecutionsForJobInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobExecutionsForJobInput {
        return ListJobExecutionsForJobInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listJobExecutionsForJobPaginated`
/// to access the nested member `[IoTClientTypes.JobExecutionSummaryForJob]`
/// - Returns: `[IoTClientTypes.JobExecutionSummaryForJob]`
extension PaginatorSequence where Input == ListJobExecutionsForJobInput, Output == ListJobExecutionsForJobOutputResponse {
    public func executionSummaries() async throws -> [IoTClientTypes.JobExecutionSummaryForJob] {
        return try await self.asyncCompactMap { item in item.executionSummaries }
    }
}

/// Paginate over `[ListJobExecutionsForThingOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListJobExecutionsForThingInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListJobExecutionsForThingOutputResponse`
extension IoTClient {
    public func listJobExecutionsForThingPaginated(input: ListJobExecutionsForThingInput) -> ClientRuntime.PaginatorSequence<ListJobExecutionsForThingInput, ListJobExecutionsForThingOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListJobExecutionsForThingInput, ListJobExecutionsForThingOutputResponse>(input: input, inputKey: \ListJobExecutionsForThingInput.nextToken, outputKey: \ListJobExecutionsForThingOutputResponse.nextToken, paginationFunction: self.listJobExecutionsForThing(input:))
    }
}

extension ListJobExecutionsForThingInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobExecutionsForThingInput {
        return ListJobExecutionsForThingInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            namespaceId: self.namespaceId,
            nextToken: token,
            status: self.status,
            thingName: self.thingName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listJobExecutionsForThingPaginated`
/// to access the nested member `[IoTClientTypes.JobExecutionSummaryForThing]`
/// - Returns: `[IoTClientTypes.JobExecutionSummaryForThing]`
extension PaginatorSequence where Input == ListJobExecutionsForThingInput, Output == ListJobExecutionsForThingOutputResponse {
    public func executionSummaries() async throws -> [IoTClientTypes.JobExecutionSummaryForThing] {
        return try await self.asyncCompactMap { item in item.executionSummaries }
    }
}

/// Paginate over `[ListJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListJobsOutputResponse`
extension IoTClient {
    public func listJobsPaginated(input: ListJobsInput) -> ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutputResponse>(input: input, inputKey: \ListJobsInput.nextToken, outputKey: \ListJobsOutputResponse.nextToken, paginationFunction: self.listJobs(input:))
    }
}

extension ListJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobsInput {
        return ListJobsInput(
            maxResults: self.maxResults,
            namespaceId: self.namespaceId,
            nextToken: token,
            status: self.status,
            targetSelection: self.targetSelection,
            thingGroupId: self.thingGroupId,
            thingGroupName: self.thingGroupName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listJobsPaginated`
/// to access the nested member `[IoTClientTypes.JobSummary]`
/// - Returns: `[IoTClientTypes.JobSummary]`
extension PaginatorSequence where Input == ListJobsInput, Output == ListJobsOutputResponse {
    public func jobs() async throws -> [IoTClientTypes.JobSummary] {
        return try await self.asyncCompactMap { item in item.jobs }
    }
}

/// Paginate over `[ListJobTemplatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListJobTemplatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListJobTemplatesOutputResponse`
extension IoTClient {
    public func listJobTemplatesPaginated(input: ListJobTemplatesInput) -> ClientRuntime.PaginatorSequence<ListJobTemplatesInput, ListJobTemplatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListJobTemplatesInput, ListJobTemplatesOutputResponse>(input: input, inputKey: \ListJobTemplatesInput.nextToken, outputKey: \ListJobTemplatesOutputResponse.nextToken, paginationFunction: self.listJobTemplates(input:))
    }
}

extension ListJobTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobTemplatesInput {
        return ListJobTemplatesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listJobTemplatesPaginated`
/// to access the nested member `[IoTClientTypes.JobTemplateSummary]`
/// - Returns: `[IoTClientTypes.JobTemplateSummary]`
extension PaginatorSequence where Input == ListJobTemplatesInput, Output == ListJobTemplatesOutputResponse {
    public func jobTemplates() async throws -> [IoTClientTypes.JobTemplateSummary] {
        return try await self.asyncCompactMap { item in item.jobTemplates }
    }
}

/// Paginate over `[ListMetricValuesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListMetricValuesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListMetricValuesOutputResponse`
extension IoTClient {
    public func listMetricValuesPaginated(input: ListMetricValuesInput) -> ClientRuntime.PaginatorSequence<ListMetricValuesInput, ListMetricValuesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListMetricValuesInput, ListMetricValuesOutputResponse>(input: input, inputKey: \ListMetricValuesInput.nextToken, outputKey: \ListMetricValuesOutputResponse.nextToken, paginationFunction: self.listMetricValues(input:))
    }
}

extension ListMetricValuesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMetricValuesInput {
        return ListMetricValuesInput(
            dimensionName: self.dimensionName,
            dimensionValueOperator: self.dimensionValueOperator,
            endTime: self.endTime,
            maxResults: self.maxResults,
            metricName: self.metricName,
            nextToken: token,
            startTime: self.startTime,
            thingName: self.thingName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listMetricValuesPaginated`
/// to access the nested member `[IoTClientTypes.MetricDatum]`
/// - Returns: `[IoTClientTypes.MetricDatum]`
extension PaginatorSequence where Input == ListMetricValuesInput, Output == ListMetricValuesOutputResponse {
    public func metricDatumList() async throws -> [IoTClientTypes.MetricDatum] {
        return try await self.asyncCompactMap { item in item.metricDatumList }
    }
}

/// Paginate over `[ListMitigationActionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListMitigationActionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListMitigationActionsOutputResponse`
extension IoTClient {
    public func listMitigationActionsPaginated(input: ListMitigationActionsInput) -> ClientRuntime.PaginatorSequence<ListMitigationActionsInput, ListMitigationActionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListMitigationActionsInput, ListMitigationActionsOutputResponse>(input: input, inputKey: \ListMitigationActionsInput.nextToken, outputKey: \ListMitigationActionsOutputResponse.nextToken, paginationFunction: self.listMitigationActions(input:))
    }
}

extension ListMitigationActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMitigationActionsInput {
        return ListMitigationActionsInput(
            actionType: self.actionType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listMitigationActionsPaginated`
/// to access the nested member `[IoTClientTypes.MitigationActionIdentifier]`
/// - Returns: `[IoTClientTypes.MitigationActionIdentifier]`
extension PaginatorSequence where Input == ListMitigationActionsInput, Output == ListMitigationActionsOutputResponse {
    public func actionIdentifiers() async throws -> [IoTClientTypes.MitigationActionIdentifier] {
        return try await self.asyncCompactMap { item in item.actionIdentifiers }
    }
}

/// Paginate over `[ListOTAUpdatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListOTAUpdatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListOTAUpdatesOutputResponse`
extension IoTClient {
    public func listOTAUpdatesPaginated(input: ListOTAUpdatesInput) -> ClientRuntime.PaginatorSequence<ListOTAUpdatesInput, ListOTAUpdatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListOTAUpdatesInput, ListOTAUpdatesOutputResponse>(input: input, inputKey: \ListOTAUpdatesInput.nextToken, outputKey: \ListOTAUpdatesOutputResponse.nextToken, paginationFunction: self.listOTAUpdates(input:))
    }
}

extension ListOTAUpdatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOTAUpdatesInput {
        return ListOTAUpdatesInput(
            maxResults: self.maxResults,
            nextToken: token,
            otaUpdateStatus: self.otaUpdateStatus
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listOTAUpdatesPaginated`
/// to access the nested member `[IoTClientTypes.OTAUpdateSummary]`
/// - Returns: `[IoTClientTypes.OTAUpdateSummary]`
extension PaginatorSequence where Input == ListOTAUpdatesInput, Output == ListOTAUpdatesOutputResponse {
    public func otaUpdates() async throws -> [IoTClientTypes.OTAUpdateSummary] {
        return try await self.asyncCompactMap { item in item.otaUpdates }
    }
}

/// Paginate over `[ListOutgoingCertificatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListOutgoingCertificatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListOutgoingCertificatesOutputResponse`
extension IoTClient {
    public func listOutgoingCertificatesPaginated(input: ListOutgoingCertificatesInput) -> ClientRuntime.PaginatorSequence<ListOutgoingCertificatesInput, ListOutgoingCertificatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListOutgoingCertificatesInput, ListOutgoingCertificatesOutputResponse>(input: input, inputKey: \ListOutgoingCertificatesInput.marker, outputKey: \ListOutgoingCertificatesOutputResponse.nextMarker, paginationFunction: self.listOutgoingCertificates(input:))
    }
}

extension ListOutgoingCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOutgoingCertificatesInput {
        return ListOutgoingCertificatesInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listOutgoingCertificatesPaginated`
/// to access the nested member `[IoTClientTypes.OutgoingCertificate]`
/// - Returns: `[IoTClientTypes.OutgoingCertificate]`
extension PaginatorSequence where Input == ListOutgoingCertificatesInput, Output == ListOutgoingCertificatesOutputResponse {
    public func outgoingCertificates() async throws -> [IoTClientTypes.OutgoingCertificate] {
        return try await self.asyncCompactMap { item in item.outgoingCertificates }
    }
}

/// Paginate over `[ListPoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPoliciesOutputResponse`
extension IoTClient {
    public func listPoliciesPaginated(input: ListPoliciesInput) -> ClientRuntime.PaginatorSequence<ListPoliciesInput, ListPoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPoliciesInput, ListPoliciesOutputResponse>(input: input, inputKey: \ListPoliciesInput.marker, outputKey: \ListPoliciesOutputResponse.nextMarker, paginationFunction: self.listPolicies(input:))
    }
}

extension ListPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPoliciesInput {
        return ListPoliciesInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPoliciesPaginated`
/// to access the nested member `[IoTClientTypes.Policy]`
/// - Returns: `[IoTClientTypes.Policy]`
extension PaginatorSequence where Input == ListPoliciesInput, Output == ListPoliciesOutputResponse {
    public func policies() async throws -> [IoTClientTypes.Policy] {
        return try await self.asyncCompactMap { item in item.policies }
    }
}

/// Paginate over `[ListPolicyPrincipalsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPolicyPrincipalsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPolicyPrincipalsOutputResponse`
extension IoTClient {
    public func listPolicyPrincipalsPaginated(input: ListPolicyPrincipalsInput) -> ClientRuntime.PaginatorSequence<ListPolicyPrincipalsInput, ListPolicyPrincipalsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPolicyPrincipalsInput, ListPolicyPrincipalsOutputResponse>(input: input, inputKey: \ListPolicyPrincipalsInput.marker, outputKey: \ListPolicyPrincipalsOutputResponse.nextMarker, paginationFunction: self.listPolicyPrincipals(input:))
    }
}

extension ListPolicyPrincipalsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPolicyPrincipalsInput {
        return ListPolicyPrincipalsInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            policyName: self.policyName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPolicyPrincipalsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListPolicyPrincipalsInput, Output == ListPolicyPrincipalsOutputResponse {
    public func principals() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.principals }
    }
}

/// Paginate over `[ListPrincipalPoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPrincipalPoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPrincipalPoliciesOutputResponse`
extension IoTClient {
    public func listPrincipalPoliciesPaginated(input: ListPrincipalPoliciesInput) -> ClientRuntime.PaginatorSequence<ListPrincipalPoliciesInput, ListPrincipalPoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPrincipalPoliciesInput, ListPrincipalPoliciesOutputResponse>(input: input, inputKey: \ListPrincipalPoliciesInput.marker, outputKey: \ListPrincipalPoliciesOutputResponse.nextMarker, paginationFunction: self.listPrincipalPolicies(input:))
    }
}

extension ListPrincipalPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPrincipalPoliciesInput {
        return ListPrincipalPoliciesInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            principal: self.principal
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPrincipalPoliciesPaginated`
/// to access the nested member `[IoTClientTypes.Policy]`
/// - Returns: `[IoTClientTypes.Policy]`
extension PaginatorSequence where Input == ListPrincipalPoliciesInput, Output == ListPrincipalPoliciesOutputResponse {
    public func policies() async throws -> [IoTClientTypes.Policy] {
        return try await self.asyncCompactMap { item in item.policies }
    }
}

/// Paginate over `[ListPrincipalThingsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPrincipalThingsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPrincipalThingsOutputResponse`
extension IoTClient {
    public func listPrincipalThingsPaginated(input: ListPrincipalThingsInput) -> ClientRuntime.PaginatorSequence<ListPrincipalThingsInput, ListPrincipalThingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPrincipalThingsInput, ListPrincipalThingsOutputResponse>(input: input, inputKey: \ListPrincipalThingsInput.nextToken, outputKey: \ListPrincipalThingsOutputResponse.nextToken, paginationFunction: self.listPrincipalThings(input:))
    }
}

extension ListPrincipalThingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPrincipalThingsInput {
        return ListPrincipalThingsInput(
            maxResults: self.maxResults,
            nextToken: token,
            principal: self.principal
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPrincipalThingsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListPrincipalThingsInput, Output == ListPrincipalThingsOutputResponse {
    public func things() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.things }
    }
}

/// Paginate over `[ListProvisioningTemplatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListProvisioningTemplatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListProvisioningTemplatesOutputResponse`
extension IoTClient {
    public func listProvisioningTemplatesPaginated(input: ListProvisioningTemplatesInput) -> ClientRuntime.PaginatorSequence<ListProvisioningTemplatesInput, ListProvisioningTemplatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListProvisioningTemplatesInput, ListProvisioningTemplatesOutputResponse>(input: input, inputKey: \ListProvisioningTemplatesInput.nextToken, outputKey: \ListProvisioningTemplatesOutputResponse.nextToken, paginationFunction: self.listProvisioningTemplates(input:))
    }
}

extension ListProvisioningTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProvisioningTemplatesInput {
        return ListProvisioningTemplatesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listProvisioningTemplatesPaginated`
/// to access the nested member `[IoTClientTypes.ProvisioningTemplateSummary]`
/// - Returns: `[IoTClientTypes.ProvisioningTemplateSummary]`
extension PaginatorSequence where Input == ListProvisioningTemplatesInput, Output == ListProvisioningTemplatesOutputResponse {
    public func templates() async throws -> [IoTClientTypes.ProvisioningTemplateSummary] {
        return try await self.asyncCompactMap { item in item.templates }
    }
}

/// Paginate over `[ListProvisioningTemplateVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListProvisioningTemplateVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListProvisioningTemplateVersionsOutputResponse`
extension IoTClient {
    public func listProvisioningTemplateVersionsPaginated(input: ListProvisioningTemplateVersionsInput) -> ClientRuntime.PaginatorSequence<ListProvisioningTemplateVersionsInput, ListProvisioningTemplateVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListProvisioningTemplateVersionsInput, ListProvisioningTemplateVersionsOutputResponse>(input: input, inputKey: \ListProvisioningTemplateVersionsInput.nextToken, outputKey: \ListProvisioningTemplateVersionsOutputResponse.nextToken, paginationFunction: self.listProvisioningTemplateVersions(input:))
    }
}

extension ListProvisioningTemplateVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProvisioningTemplateVersionsInput {
        return ListProvisioningTemplateVersionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            templateName: self.templateName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listProvisioningTemplateVersionsPaginated`
/// to access the nested member `[IoTClientTypes.ProvisioningTemplateVersionSummary]`
/// - Returns: `[IoTClientTypes.ProvisioningTemplateVersionSummary]`
extension PaginatorSequence where Input == ListProvisioningTemplateVersionsInput, Output == ListProvisioningTemplateVersionsOutputResponse {
    public func versions() async throws -> [IoTClientTypes.ProvisioningTemplateVersionSummary] {
        return try await self.asyncCompactMap { item in item.versions }
    }
}

/// Paginate over `[ListRoleAliasesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListRoleAliasesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListRoleAliasesOutputResponse`
extension IoTClient {
    public func listRoleAliasesPaginated(input: ListRoleAliasesInput) -> ClientRuntime.PaginatorSequence<ListRoleAliasesInput, ListRoleAliasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRoleAliasesInput, ListRoleAliasesOutputResponse>(input: input, inputKey: \ListRoleAliasesInput.marker, outputKey: \ListRoleAliasesOutputResponse.nextMarker, paginationFunction: self.listRoleAliases(input:))
    }
}

extension ListRoleAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRoleAliasesInput {
        return ListRoleAliasesInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listRoleAliasesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListRoleAliasesInput, Output == ListRoleAliasesOutputResponse {
    public func roleAliases() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.roleAliases }
    }
}

/// Paginate over `[ListScheduledAuditsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListScheduledAuditsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListScheduledAuditsOutputResponse`
extension IoTClient {
    public func listScheduledAuditsPaginated(input: ListScheduledAuditsInput) -> ClientRuntime.PaginatorSequence<ListScheduledAuditsInput, ListScheduledAuditsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListScheduledAuditsInput, ListScheduledAuditsOutputResponse>(input: input, inputKey: \ListScheduledAuditsInput.nextToken, outputKey: \ListScheduledAuditsOutputResponse.nextToken, paginationFunction: self.listScheduledAudits(input:))
    }
}

extension ListScheduledAuditsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListScheduledAuditsInput {
        return ListScheduledAuditsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listScheduledAuditsPaginated`
/// to access the nested member `[IoTClientTypes.ScheduledAuditMetadata]`
/// - Returns: `[IoTClientTypes.ScheduledAuditMetadata]`
extension PaginatorSequence where Input == ListScheduledAuditsInput, Output == ListScheduledAuditsOutputResponse {
    public func scheduledAudits() async throws -> [IoTClientTypes.ScheduledAuditMetadata] {
        return try await self.asyncCompactMap { item in item.scheduledAudits }
    }
}

/// Paginate over `[ListSecurityProfilesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSecurityProfilesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSecurityProfilesOutputResponse`
extension IoTClient {
    public func listSecurityProfilesPaginated(input: ListSecurityProfilesInput) -> ClientRuntime.PaginatorSequence<ListSecurityProfilesInput, ListSecurityProfilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSecurityProfilesInput, ListSecurityProfilesOutputResponse>(input: input, inputKey: \ListSecurityProfilesInput.nextToken, outputKey: \ListSecurityProfilesOutputResponse.nextToken, paginationFunction: self.listSecurityProfiles(input:))
    }
}

extension ListSecurityProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityProfilesInput {
        return ListSecurityProfilesInput(
            dimensionName: self.dimensionName,
            maxResults: self.maxResults,
            metricName: self.metricName,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSecurityProfilesPaginated`
/// to access the nested member `[IoTClientTypes.SecurityProfileIdentifier]`
/// - Returns: `[IoTClientTypes.SecurityProfileIdentifier]`
extension PaginatorSequence where Input == ListSecurityProfilesInput, Output == ListSecurityProfilesOutputResponse {
    public func securityProfileIdentifiers() async throws -> [IoTClientTypes.SecurityProfileIdentifier] {
        return try await self.asyncCompactMap { item in item.securityProfileIdentifiers }
    }
}

/// Paginate over `[ListSecurityProfilesForTargetOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSecurityProfilesForTargetInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSecurityProfilesForTargetOutputResponse`
extension IoTClient {
    public func listSecurityProfilesForTargetPaginated(input: ListSecurityProfilesForTargetInput) -> ClientRuntime.PaginatorSequence<ListSecurityProfilesForTargetInput, ListSecurityProfilesForTargetOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSecurityProfilesForTargetInput, ListSecurityProfilesForTargetOutputResponse>(input: input, inputKey: \ListSecurityProfilesForTargetInput.nextToken, outputKey: \ListSecurityProfilesForTargetOutputResponse.nextToken, paginationFunction: self.listSecurityProfilesForTarget(input:))
    }
}

extension ListSecurityProfilesForTargetInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityProfilesForTargetInput {
        return ListSecurityProfilesForTargetInput(
            maxResults: self.maxResults,
            nextToken: token,
            recursive: self.recursive,
            securityProfileTargetArn: self.securityProfileTargetArn
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSecurityProfilesForTargetPaginated`
/// to access the nested member `[IoTClientTypes.SecurityProfileTargetMapping]`
/// - Returns: `[IoTClientTypes.SecurityProfileTargetMapping]`
extension PaginatorSequence where Input == ListSecurityProfilesForTargetInput, Output == ListSecurityProfilesForTargetOutputResponse {
    public func securityProfileTargetMappings() async throws -> [IoTClientTypes.SecurityProfileTargetMapping] {
        return try await self.asyncCompactMap { item in item.securityProfileTargetMappings }
    }
}

/// Paginate over `[ListStreamsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListStreamsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListStreamsOutputResponse`
extension IoTClient {
    public func listStreamsPaginated(input: ListStreamsInput) -> ClientRuntime.PaginatorSequence<ListStreamsInput, ListStreamsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListStreamsInput, ListStreamsOutputResponse>(input: input, inputKey: \ListStreamsInput.nextToken, outputKey: \ListStreamsOutputResponse.nextToken, paginationFunction: self.listStreams(input:))
    }
}

extension ListStreamsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStreamsInput {
        return ListStreamsInput(
            ascendingOrder: self.ascendingOrder,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listStreamsPaginated`
/// to access the nested member `[IoTClientTypes.StreamSummary]`
/// - Returns: `[IoTClientTypes.StreamSummary]`
extension PaginatorSequence where Input == ListStreamsInput, Output == ListStreamsOutputResponse {
    public func streams() async throws -> [IoTClientTypes.StreamSummary] {
        return try await self.asyncCompactMap { item in item.streams }
    }
}

/// Paginate over `[ListTagsForResourceOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTagsForResourceInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTagsForResourceOutputResponse`
extension IoTClient {
    public func listTagsForResourcePaginated(input: ListTagsForResourceInput) -> ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse>(input: input, inputKey: \ListTagsForResourceInput.nextToken, outputKey: \ListTagsForResourceOutputResponse.nextToken, paginationFunction: self.listTagsForResource(input:))
    }
}

extension ListTagsForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsForResourceInput {
        return ListTagsForResourceInput(
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTagsForResourcePaginated`
/// to access the nested member `[IoTClientTypes.Tag]`
/// - Returns: `[IoTClientTypes.Tag]`
extension PaginatorSequence where Input == ListTagsForResourceInput, Output == ListTagsForResourceOutputResponse {
    public func tags() async throws -> [IoTClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}

/// Paginate over `[ListTargetsForPolicyOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTargetsForPolicyInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTargetsForPolicyOutputResponse`
extension IoTClient {
    public func listTargetsForPolicyPaginated(input: ListTargetsForPolicyInput) -> ClientRuntime.PaginatorSequence<ListTargetsForPolicyInput, ListTargetsForPolicyOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTargetsForPolicyInput, ListTargetsForPolicyOutputResponse>(input: input, inputKey: \ListTargetsForPolicyInput.marker, outputKey: \ListTargetsForPolicyOutputResponse.nextMarker, paginationFunction: self.listTargetsForPolicy(input:))
    }
}

extension ListTargetsForPolicyInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTargetsForPolicyInput {
        return ListTargetsForPolicyInput(
            marker: token,
            pageSize: self.pageSize,
            policyName: self.policyName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTargetsForPolicyPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListTargetsForPolicyInput, Output == ListTargetsForPolicyOutputResponse {
    public func targets() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.targets }
    }
}

/// Paginate over `[ListTargetsForSecurityProfileOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTargetsForSecurityProfileInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTargetsForSecurityProfileOutputResponse`
extension IoTClient {
    public func listTargetsForSecurityProfilePaginated(input: ListTargetsForSecurityProfileInput) -> ClientRuntime.PaginatorSequence<ListTargetsForSecurityProfileInput, ListTargetsForSecurityProfileOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTargetsForSecurityProfileInput, ListTargetsForSecurityProfileOutputResponse>(input: input, inputKey: \ListTargetsForSecurityProfileInput.nextToken, outputKey: \ListTargetsForSecurityProfileOutputResponse.nextToken, paginationFunction: self.listTargetsForSecurityProfile(input:))
    }
}

extension ListTargetsForSecurityProfileInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTargetsForSecurityProfileInput {
        return ListTargetsForSecurityProfileInput(
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTargetsForSecurityProfilePaginated`
/// to access the nested member `[IoTClientTypes.SecurityProfileTarget]`
/// - Returns: `[IoTClientTypes.SecurityProfileTarget]`
extension PaginatorSequence where Input == ListTargetsForSecurityProfileInput, Output == ListTargetsForSecurityProfileOutputResponse {
    public func securityProfileTargets() async throws -> [IoTClientTypes.SecurityProfileTarget] {
        return try await self.asyncCompactMap { item in item.securityProfileTargets }
    }
}

/// Paginate over `[ListThingGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListThingGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListThingGroupsOutputResponse`
extension IoTClient {
    public func listThingGroupsPaginated(input: ListThingGroupsInput) -> ClientRuntime.PaginatorSequence<ListThingGroupsInput, ListThingGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThingGroupsInput, ListThingGroupsOutputResponse>(input: input, inputKey: \ListThingGroupsInput.nextToken, outputKey: \ListThingGroupsOutputResponse.nextToken, paginationFunction: self.listThingGroups(input:))
    }
}

extension ListThingGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingGroupsInput {
        return ListThingGroupsInput(
            maxResults: self.maxResults,
            namePrefixFilter: self.namePrefixFilter,
            nextToken: token,
            parentGroup: self.parentGroup,
            recursive: self.recursive
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listThingGroupsPaginated`
/// to access the nested member `[IoTClientTypes.GroupNameAndArn]`
/// - Returns: `[IoTClientTypes.GroupNameAndArn]`
extension PaginatorSequence where Input == ListThingGroupsInput, Output == ListThingGroupsOutputResponse {
    public func thingGroups() async throws -> [IoTClientTypes.GroupNameAndArn] {
        return try await self.asyncCompactMap { item in item.thingGroups }
    }
}

/// Paginate over `[ListThingGroupsForThingOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListThingGroupsForThingInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListThingGroupsForThingOutputResponse`
extension IoTClient {
    public func listThingGroupsForThingPaginated(input: ListThingGroupsForThingInput) -> ClientRuntime.PaginatorSequence<ListThingGroupsForThingInput, ListThingGroupsForThingOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThingGroupsForThingInput, ListThingGroupsForThingOutputResponse>(input: input, inputKey: \ListThingGroupsForThingInput.nextToken, outputKey: \ListThingGroupsForThingOutputResponse.nextToken, paginationFunction: self.listThingGroupsForThing(input:))
    }
}

extension ListThingGroupsForThingInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingGroupsForThingInput {
        return ListThingGroupsForThingInput(
            maxResults: self.maxResults,
            nextToken: token,
            thingName: self.thingName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listThingGroupsForThingPaginated`
/// to access the nested member `[IoTClientTypes.GroupNameAndArn]`
/// - Returns: `[IoTClientTypes.GroupNameAndArn]`
extension PaginatorSequence where Input == ListThingGroupsForThingInput, Output == ListThingGroupsForThingOutputResponse {
    public func thingGroups() async throws -> [IoTClientTypes.GroupNameAndArn] {
        return try await self.asyncCompactMap { item in item.thingGroups }
    }
}

/// Paginate over `[ListThingPrincipalsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListThingPrincipalsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListThingPrincipalsOutputResponse`
extension IoTClient {
    public func listThingPrincipalsPaginated(input: ListThingPrincipalsInput) -> ClientRuntime.PaginatorSequence<ListThingPrincipalsInput, ListThingPrincipalsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThingPrincipalsInput, ListThingPrincipalsOutputResponse>(input: input, inputKey: \ListThingPrincipalsInput.nextToken, outputKey: \ListThingPrincipalsOutputResponse.nextToken, paginationFunction: self.listThingPrincipals(input:))
    }
}

extension ListThingPrincipalsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingPrincipalsInput {
        return ListThingPrincipalsInput(
            maxResults: self.maxResults,
            nextToken: token,
            thingName: self.thingName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listThingPrincipalsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListThingPrincipalsInput, Output == ListThingPrincipalsOutputResponse {
    public func principals() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.principals }
    }
}

/// Paginate over `[ListThingRegistrationTaskReportsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListThingRegistrationTaskReportsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListThingRegistrationTaskReportsOutputResponse`
extension IoTClient {
    public func listThingRegistrationTaskReportsPaginated(input: ListThingRegistrationTaskReportsInput) -> ClientRuntime.PaginatorSequence<ListThingRegistrationTaskReportsInput, ListThingRegistrationTaskReportsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThingRegistrationTaskReportsInput, ListThingRegistrationTaskReportsOutputResponse>(input: input, inputKey: \ListThingRegistrationTaskReportsInput.nextToken, outputKey: \ListThingRegistrationTaskReportsOutputResponse.nextToken, paginationFunction: self.listThingRegistrationTaskReports(input:))
    }
}

extension ListThingRegistrationTaskReportsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingRegistrationTaskReportsInput {
        return ListThingRegistrationTaskReportsInput(
            maxResults: self.maxResults,
            nextToken: token,
            reportType: self.reportType,
            taskId: self.taskId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listThingRegistrationTaskReportsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListThingRegistrationTaskReportsInput, Output == ListThingRegistrationTaskReportsOutputResponse {
    public func resourceLinks() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.resourceLinks }
    }
}

/// Paginate over `[ListThingRegistrationTasksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListThingRegistrationTasksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListThingRegistrationTasksOutputResponse`
extension IoTClient {
    public func listThingRegistrationTasksPaginated(input: ListThingRegistrationTasksInput) -> ClientRuntime.PaginatorSequence<ListThingRegistrationTasksInput, ListThingRegistrationTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThingRegistrationTasksInput, ListThingRegistrationTasksOutputResponse>(input: input, inputKey: \ListThingRegistrationTasksInput.nextToken, outputKey: \ListThingRegistrationTasksOutputResponse.nextToken, paginationFunction: self.listThingRegistrationTasks(input:))
    }
}

extension ListThingRegistrationTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingRegistrationTasksInput {
        return ListThingRegistrationTasksInput(
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listThingRegistrationTasksPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListThingRegistrationTasksInput, Output == ListThingRegistrationTasksOutputResponse {
    public func taskIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.taskIds }
    }
}

/// Paginate over `[ListThingsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListThingsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListThingsOutputResponse`
extension IoTClient {
    public func listThingsPaginated(input: ListThingsInput) -> ClientRuntime.PaginatorSequence<ListThingsInput, ListThingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThingsInput, ListThingsOutputResponse>(input: input, inputKey: \ListThingsInput.nextToken, outputKey: \ListThingsOutputResponse.nextToken, paginationFunction: self.listThings(input:))
    }
}

extension ListThingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingsInput {
        return ListThingsInput(
            attributeName: self.attributeName,
            attributeValue: self.attributeValue,
            maxResults: self.maxResults,
            nextToken: token,
            thingTypeName: self.thingTypeName,
            usePrefixAttributeValue: self.usePrefixAttributeValue
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listThingsPaginated`
/// to access the nested member `[IoTClientTypes.ThingAttribute]`
/// - Returns: `[IoTClientTypes.ThingAttribute]`
extension PaginatorSequence where Input == ListThingsInput, Output == ListThingsOutputResponse {
    public func things() async throws -> [IoTClientTypes.ThingAttribute] {
        return try await self.asyncCompactMap { item in item.things }
    }
}

/// Paginate over `[ListThingsInBillingGroupOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListThingsInBillingGroupInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListThingsInBillingGroupOutputResponse`
extension IoTClient {
    public func listThingsInBillingGroupPaginated(input: ListThingsInBillingGroupInput) -> ClientRuntime.PaginatorSequence<ListThingsInBillingGroupInput, ListThingsInBillingGroupOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThingsInBillingGroupInput, ListThingsInBillingGroupOutputResponse>(input: input, inputKey: \ListThingsInBillingGroupInput.nextToken, outputKey: \ListThingsInBillingGroupOutputResponse.nextToken, paginationFunction: self.listThingsInBillingGroup(input:))
    }
}

extension ListThingsInBillingGroupInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingsInBillingGroupInput {
        return ListThingsInBillingGroupInput(
            billingGroupName: self.billingGroupName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listThingsInBillingGroupPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListThingsInBillingGroupInput, Output == ListThingsInBillingGroupOutputResponse {
    public func things() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.things }
    }
}

/// Paginate over `[ListThingsInThingGroupOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListThingsInThingGroupInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListThingsInThingGroupOutputResponse`
extension IoTClient {
    public func listThingsInThingGroupPaginated(input: ListThingsInThingGroupInput) -> ClientRuntime.PaginatorSequence<ListThingsInThingGroupInput, ListThingsInThingGroupOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThingsInThingGroupInput, ListThingsInThingGroupOutputResponse>(input: input, inputKey: \ListThingsInThingGroupInput.nextToken, outputKey: \ListThingsInThingGroupOutputResponse.nextToken, paginationFunction: self.listThingsInThingGroup(input:))
    }
}

extension ListThingsInThingGroupInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingsInThingGroupInput {
        return ListThingsInThingGroupInput(
            maxResults: self.maxResults,
            nextToken: token,
            recursive: self.recursive,
            thingGroupName: self.thingGroupName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listThingsInThingGroupPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListThingsInThingGroupInput, Output == ListThingsInThingGroupOutputResponse {
    public func things() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.things }
    }
}

/// Paginate over `[ListThingTypesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListThingTypesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListThingTypesOutputResponse`
extension IoTClient {
    public func listThingTypesPaginated(input: ListThingTypesInput) -> ClientRuntime.PaginatorSequence<ListThingTypesInput, ListThingTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListThingTypesInput, ListThingTypesOutputResponse>(input: input, inputKey: \ListThingTypesInput.nextToken, outputKey: \ListThingTypesOutputResponse.nextToken, paginationFunction: self.listThingTypes(input:))
    }
}

extension ListThingTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingTypesInput {
        return ListThingTypesInput(
            maxResults: self.maxResults,
            nextToken: token,
            thingTypeName: self.thingTypeName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listThingTypesPaginated`
/// to access the nested member `[IoTClientTypes.ThingTypeDefinition]`
/// - Returns: `[IoTClientTypes.ThingTypeDefinition]`
extension PaginatorSequence where Input == ListThingTypesInput, Output == ListThingTypesOutputResponse {
    public func thingTypes() async throws -> [IoTClientTypes.ThingTypeDefinition] {
        return try await self.asyncCompactMap { item in item.thingTypes }
    }
}

/// Paginate over `[ListTopicRuleDestinationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTopicRuleDestinationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTopicRuleDestinationsOutputResponse`
extension IoTClient {
    public func listTopicRuleDestinationsPaginated(input: ListTopicRuleDestinationsInput) -> ClientRuntime.PaginatorSequence<ListTopicRuleDestinationsInput, ListTopicRuleDestinationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTopicRuleDestinationsInput, ListTopicRuleDestinationsOutputResponse>(input: input, inputKey: \ListTopicRuleDestinationsInput.nextToken, outputKey: \ListTopicRuleDestinationsOutputResponse.nextToken, paginationFunction: self.listTopicRuleDestinations(input:))
    }
}

extension ListTopicRuleDestinationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTopicRuleDestinationsInput {
        return ListTopicRuleDestinationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTopicRuleDestinationsPaginated`
/// to access the nested member `[IoTClientTypes.TopicRuleDestinationSummary]`
/// - Returns: `[IoTClientTypes.TopicRuleDestinationSummary]`
extension PaginatorSequence where Input == ListTopicRuleDestinationsInput, Output == ListTopicRuleDestinationsOutputResponse {
    public func destinationSummaries() async throws -> [IoTClientTypes.TopicRuleDestinationSummary] {
        return try await self.asyncCompactMap { item in item.destinationSummaries }
    }
}

/// Paginate over `[ListTopicRulesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTopicRulesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTopicRulesOutputResponse`
extension IoTClient {
    public func listTopicRulesPaginated(input: ListTopicRulesInput) -> ClientRuntime.PaginatorSequence<ListTopicRulesInput, ListTopicRulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTopicRulesInput, ListTopicRulesOutputResponse>(input: input, inputKey: \ListTopicRulesInput.nextToken, outputKey: \ListTopicRulesOutputResponse.nextToken, paginationFunction: self.listTopicRules(input:))
    }
}

extension ListTopicRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTopicRulesInput {
        return ListTopicRulesInput(
            maxResults: self.maxResults,
            nextToken: token,
            ruleDisabled: self.ruleDisabled,
            topic: self.topic
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTopicRulesPaginated`
/// to access the nested member `[IoTClientTypes.TopicRuleListItem]`
/// - Returns: `[IoTClientTypes.TopicRuleListItem]`
extension PaginatorSequence where Input == ListTopicRulesInput, Output == ListTopicRulesOutputResponse {
    public func rules() async throws -> [IoTClientTypes.TopicRuleListItem] {
        return try await self.asyncCompactMap { item in item.rules }
    }
}

/// Paginate over `[ListV2LoggingLevelsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListV2LoggingLevelsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListV2LoggingLevelsOutputResponse`
extension IoTClient {
    public func listV2LoggingLevelsPaginated(input: ListV2LoggingLevelsInput) -> ClientRuntime.PaginatorSequence<ListV2LoggingLevelsInput, ListV2LoggingLevelsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListV2LoggingLevelsInput, ListV2LoggingLevelsOutputResponse>(input: input, inputKey: \ListV2LoggingLevelsInput.nextToken, outputKey: \ListV2LoggingLevelsOutputResponse.nextToken, paginationFunction: self.listV2LoggingLevels(input:))
    }
}

extension ListV2LoggingLevelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListV2LoggingLevelsInput {
        return ListV2LoggingLevelsInput(
            maxResults: self.maxResults,
            nextToken: token,
            targetType: self.targetType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listV2LoggingLevelsPaginated`
/// to access the nested member `[IoTClientTypes.LogTargetConfiguration]`
/// - Returns: `[IoTClientTypes.LogTargetConfiguration]`
extension PaginatorSequence where Input == ListV2LoggingLevelsInput, Output == ListV2LoggingLevelsOutputResponse {
    public func logTargetConfigurations() async throws -> [IoTClientTypes.LogTargetConfiguration] {
        return try await self.asyncCompactMap { item in item.logTargetConfigurations }
    }
}

/// Paginate over `[ListViolationEventsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListViolationEventsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListViolationEventsOutputResponse`
extension IoTClient {
    public func listViolationEventsPaginated(input: ListViolationEventsInput) -> ClientRuntime.PaginatorSequence<ListViolationEventsInput, ListViolationEventsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListViolationEventsInput, ListViolationEventsOutputResponse>(input: input, inputKey: \ListViolationEventsInput.nextToken, outputKey: \ListViolationEventsOutputResponse.nextToken, paginationFunction: self.listViolationEvents(input:))
    }
}

extension ListViolationEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListViolationEventsInput {
        return ListViolationEventsInput(
            behaviorCriteriaType: self.behaviorCriteriaType,
            endTime: self.endTime,
            listSuppressedAlerts: self.listSuppressedAlerts,
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName,
            startTime: self.startTime,
            thingName: self.thingName,
            verificationState: self.verificationState
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listViolationEventsPaginated`
/// to access the nested member `[IoTClientTypes.ViolationEvent]`
/// - Returns: `[IoTClientTypes.ViolationEvent]`
extension PaginatorSequence where Input == ListViolationEventsInput, Output == ListViolationEventsOutputResponse {
    public func violationEvents() async throws -> [IoTClientTypes.ViolationEvent] {
        return try await self.asyncCompactMap { item in item.violationEvents }
    }
}
