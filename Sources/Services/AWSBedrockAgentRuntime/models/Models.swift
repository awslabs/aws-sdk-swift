// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is denied because of missing access permissions. Check your permissions and retry your request.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupName
        case apiPath
        case function
        case parameters
        case requestBody
        case verb
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupName = self.actionGroupName {
            try encodeContainer.encode(actionGroupName, forKey: .actionGroupName)
        }
        if let apiPath = self.apiPath {
            try encodeContainer.encode(apiPath, forKey: .apiPath)
        }
        if let function = self.function {
            try encodeContainer.encode(function, forKey: .function)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for parameter0 in parameters {
                try parametersContainer.encode(parameter0)
            }
        }
        if let requestBody = self.requestBody {
            try encodeContainer.encode(requestBody, forKey: .requestBody)
        }
        if let verb = self.verb {
            try encodeContainer.encode(verb, forKey: .verb)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupName)
        actionGroupName = actionGroupNameDecoded
        let verbDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verb)
        verb = verbDecoded
        let apiPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiPath)
        apiPath = apiPathDecoded
        let parametersContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[BedrockAgentRuntimeClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [BedrockAgentRuntimeClientTypes.Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let requestBodyDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RequestBody.self, forKey: .requestBody)
        requestBody = requestBodyDecoded
        let functionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .function)
        function = functionDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionGroupInvocationInput(parameters: \(Swift.String(describing: parameters)), requestBody: \(Swift.String(describing: requestBody)), actionGroupName: \"CONTENT_REDACTED\", apiPath: \"CONTENT_REDACTED\", function: \"CONTENT_REDACTED\", verb: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the action group being invoked. For more information about the possible structures, see the InvocationInput tab in [OrchestrationTrace](https://docs.aws.amazon.com/bedrock/latest/userguide/trace-orchestration.html) in the Amazon Bedrock User Guide.
    public struct ActionGroupInvocationInput {
        /// The name of the action group.
        public var actionGroupName: Swift.String?
        /// The path to the API to call, based off the action group.
        public var apiPath: Swift.String?
        /// The function in the action group to call.
        public var function: Swift.String?
        /// The parameters in the Lambda input event.
        public var parameters: [BedrockAgentRuntimeClientTypes.Parameter]?
        /// The parameters in the request body for the Lambda input event.
        public var requestBody: BedrockAgentRuntimeClientTypes.RequestBody?
        /// The API method being used, based off the action group.
        public var verb: Swift.String?

        public init(
            actionGroupName: Swift.String? = nil,
            apiPath: Swift.String? = nil,
            function: Swift.String? = nil,
            parameters: [BedrockAgentRuntimeClientTypes.Parameter]? = nil,
            requestBody: BedrockAgentRuntimeClientTypes.RequestBody? = nil,
            verb: Swift.String? = nil
        )
        {
            self.actionGroupName = actionGroupName
            self.apiPath = apiPath
            self.function = function
            self.parameters = parameters
            self.requestBody = requestBody
            self.verb = verb
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionGroupInvocationOutput(text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the JSON-formatted string returned by the API invoked by the action group.
    public struct ActionGroupInvocationOutput {
        /// The JSON-formatted string returned by the API invoked by the action group.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ApiInvocationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroup
        case apiPath
        case httpMethod
        case parameters
        case requestBody
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroup = self.actionGroup {
            try encodeContainer.encode(actionGroup, forKey: .actionGroup)
        }
        if let apiPath = self.apiPath {
            try encodeContainer.encode(apiPath, forKey: .apiPath)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for apiparameter0 in parameters {
                try parametersContainer.encode(apiparameter0)
            }
        }
        if let requestBody = self.requestBody {
            try encodeContainer.encode(requestBody, forKey: .requestBody)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroup)
        actionGroup = actionGroupDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let apiPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiPath)
        apiPath = apiPathDecoded
        let parametersContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.ApiParameter?].self, forKey: .parameters)
        var parametersDecoded0:[BedrockAgentRuntimeClientTypes.ApiParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [BedrockAgentRuntimeClientTypes.ApiParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let requestBodyDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.ApiRequestBody.self, forKey: .requestBody)
        requestBody = requestBodyDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.ApiInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiInvocationInput(actionGroup: \(Swift.String(describing: actionGroup)), httpMethod: \(Swift.String(describing: httpMethod)), parameters: \(Swift.String(describing: parameters)), requestBody: \(Swift.String(describing: requestBody)), apiPath: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the API operation that the agent predicts should be called. This data type is used in the following API operations:
    ///
    /// * In the returnControl field of the [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax)
    public struct ApiInvocationInput {
        /// The action group that the API operation belongs to.
        /// This member is required.
        public var actionGroup: Swift.String?
        /// The path to the API operation.
        public var apiPath: Swift.String?
        /// The HTTP method of the API operation.
        public var httpMethod: Swift.String?
        /// The parameters to provide for the API request, as the agent elicited from the user.
        public var parameters: [BedrockAgentRuntimeClientTypes.ApiParameter]?
        /// The request body to provide for the API request, as the agent elicited from the user.
        public var requestBody: BedrockAgentRuntimeClientTypes.ApiRequestBody?

        public init(
            actionGroup: Swift.String? = nil,
            apiPath: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            parameters: [BedrockAgentRuntimeClientTypes.ApiParameter]? = nil,
            requestBody: BedrockAgentRuntimeClientTypes.ApiRequestBody? = nil
        )
        {
            self.actionGroup = actionGroup
            self.apiPath = apiPath
            self.httpMethod = httpMethod
            self.parameters = parameters
            self.requestBody = requestBody
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ApiParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Information about a parameter to provide to the API request. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax)
    public struct ApiParameter {
        /// The name of the parameter.
        public var name: Swift.String?
        /// The data type for the parameter.
        public var type: Swift.String?
        /// The value of the parameter.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ApiRequestBody: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            var contentContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .content)
            for (dictKey0, apiContentMap0) in content {
                try contentContainer.encode(apiContentMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentContainer = try containerValues.decodeIfPresent([Swift.String: BedrockAgentRuntimeClientTypes.PropertyParameters?].self, forKey: .content)
        var contentDecoded0: [Swift.String:BedrockAgentRuntimeClientTypes.PropertyParameters]? = nil
        if let contentContainer = contentContainer {
            contentDecoded0 = [Swift.String:BedrockAgentRuntimeClientTypes.PropertyParameters]()
            for (key0, propertyparameters0) in contentContainer {
                if let propertyparameters0 = propertyparameters0 {
                    contentDecoded0?[key0] = propertyparameters0
                }
            }
        }
        content = contentDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The request body to provide for the API request, as the agent elicited from the user. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax)
    public struct ApiRequestBody {
        /// The content of the request body. The key of the object in this field is a media type defining the format of the request body.
        public var content: [Swift.String:BedrockAgentRuntimeClientTypes.PropertyParameters]?

        public init(
            content: [Swift.String:BedrockAgentRuntimeClientTypes.PropertyParameters]? = nil
        )
        {
            self.content = content
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ApiResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroup
        case apiPath
        case httpMethod
        case httpStatusCode
        case responseBody
        case responseState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroup = self.actionGroup {
            try encodeContainer.encode(actionGroup, forKey: .actionGroup)
        }
        if let apiPath = self.apiPath {
            try encodeContainer.encode(apiPath, forKey: .apiPath)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let httpStatusCode = self.httpStatusCode {
            try encodeContainer.encode(httpStatusCode, forKey: .httpStatusCode)
        }
        if let responseBody = responseBody {
            var responseBodyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseBody)
            for (dictKey0, responseBody0) in responseBody {
                try responseBodyContainer.encode(responseBody0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseState = self.responseState {
            try encodeContainer.encode(responseState.rawValue, forKey: .responseState)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroup)
        actionGroup = actionGroupDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let apiPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiPath)
        apiPath = apiPathDecoded
        let responseBodyContainer = try containerValues.decodeIfPresent([Swift.String: BedrockAgentRuntimeClientTypes.ContentBody?].self, forKey: .responseBody)
        var responseBodyDecoded0: [Swift.String:BedrockAgentRuntimeClientTypes.ContentBody]? = nil
        if let responseBodyContainer = responseBodyContainer {
            responseBodyDecoded0 = [Swift.String:BedrockAgentRuntimeClientTypes.ContentBody]()
            for (key0, contentbody0) in responseBodyContainer {
                if let contentbody0 = contentbody0 {
                    responseBodyDecoded0?[key0] = contentbody0
                }
            }
        }
        responseBody = responseBodyDecoded0
        let httpStatusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpStatusCode)
        httpStatusCode = httpStatusCodeDecoded
        let responseStateDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.ResponseState.self, forKey: .responseState)
        responseState = responseStateDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.ApiResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiResult(actionGroup: \(Swift.String(describing: actionGroup)), httpMethod: \(Swift.String(describing: httpMethod)), httpStatusCode: \(Swift.String(describing: httpStatusCode)), responseBody: \(Swift.String(describing: responseBody)), responseState: \(Swift.String(describing: responseState)), apiPath: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the API operation that was called from the action group and the response body that was returned. This data type is used in the following API operations:
    ///
    /// * In the returnControlInvocationResults of the [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax)
    public struct ApiResult {
        /// The action group that the API operation belongs to.
        /// This member is required.
        public var actionGroup: Swift.String?
        /// The path to the API operation.
        public var apiPath: Swift.String?
        /// The HTTP method for the API operation.
        public var httpMethod: Swift.String?
        /// http status code from API execution response (for example: 200, 400, 500).
        public var httpStatusCode: Swift.Int?
        /// The response body from the API operation. The key of the object is the content type. The response may be returned directly or from the Lambda function.
        public var responseBody: [Swift.String:BedrockAgentRuntimeClientTypes.ContentBody]?
        /// Controls the final response state returned to end user when API/Function execution failed. When this state is FAILURE, the request would fail with dependency failure exception. When this state is REPROMPT, the API/function response will be sent to model for re-prompt
        public var responseState: BedrockAgentRuntimeClientTypes.ResponseState?

        public init(
            actionGroup: Swift.String? = nil,
            apiPath: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            httpStatusCode: Swift.Int? = nil,
            responseBody: [Swift.String:BedrockAgentRuntimeClientTypes.ContentBody]? = nil,
            responseState: BedrockAgentRuntimeClientTypes.ResponseState? = nil
        )
        {
            self.actionGroup = actionGroup
            self.apiPath = apiPath
            self.httpMethod = httpMethod
            self.httpStatusCode = httpStatusCode
            self.responseBody = responseBody
            self.responseState = responseState
        }
    }

}

extension BedrockAgentRuntimeClientTypes.Attribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case citations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let citations = citations {
            var citationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .citations)
            for citation0 in citations {
                try citationsContainer.encode(citation0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let citationsContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.Citation?].self, forKey: .citations)
        var citationsDecoded0:[BedrockAgentRuntimeClientTypes.Citation]? = nil
        if let citationsContainer = citationsContainer {
            citationsDecoded0 = [BedrockAgentRuntimeClientTypes.Citation]()
            for structure0 in citationsContainer {
                if let structure0 = structure0 {
                    citationsDecoded0?.append(structure0)
                }
            }
        }
        citations = citationsDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains citations for a part of an agent response.
    public struct Attribution {
        /// A list of citations and related information for a part of an agent response.
        public var citations: [BedrockAgentRuntimeClientTypes.Citation]?

        public init(
            citations: [BedrockAgentRuntimeClientTypes.Citation]? = nil
        )
        {
            self.citations = citations
        }
    }

}

extension BadGatewayException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceName = self.properties.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        properties.resourceName = resourceNameDecoded
    }
}

extension BadGatewayException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadGatewayExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an issue with a dependency due to a server issue. Retry your request.
public struct BadGatewayException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the dependency that caused the issue, such as Amazon Bedrock, Lambda, or STS.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadGatewayException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct BadGatewayExceptionBody {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension BadGatewayExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public enum BedrockAgentRuntimeClientTypes {}

extension BedrockAgentRuntimeClientTypes.Citation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedResponsePart
        case retrievedReferences
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedResponsePart = self.generatedResponsePart {
            try encodeContainer.encode(generatedResponsePart, forKey: .generatedResponsePart)
        }
        if let retrievedReferences = retrievedReferences {
            var retrievedReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .retrievedReferences)
            for retrievedreference0 in retrievedReferences {
                try retrievedReferencesContainer.encode(retrievedreference0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatedResponsePartDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.GeneratedResponsePart.self, forKey: .generatedResponsePart)
        generatedResponsePart = generatedResponsePartDecoded
        let retrievedReferencesContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.RetrievedReference?].self, forKey: .retrievedReferences)
        var retrievedReferencesDecoded0:[BedrockAgentRuntimeClientTypes.RetrievedReference]? = nil
        if let retrievedReferencesContainer = retrievedReferencesContainer {
            retrievedReferencesDecoded0 = [BedrockAgentRuntimeClientTypes.RetrievedReference]()
            for structure0 in retrievedReferencesContainer {
                if let structure0 = structure0 {
                    retrievedReferencesDecoded0?.append(structure0)
                }
            }
        }
        retrievedReferences = retrievedReferencesDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// An object containing a segment of the generated response that is based on a source in the knowledge base, alongside information about the source. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the citations field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the citations field
    public struct Citation {
        /// Contains the generated response and metadata
        public var generatedResponsePart: BedrockAgentRuntimeClientTypes.GeneratedResponsePart?
        /// Contains metadata about the sources cited for the generated response.
        public var retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]?

        public init(
            generatedResponsePart: BedrockAgentRuntimeClientTypes.GeneratedResponsePart? = nil,
            retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]? = nil
        )
        {
            self.generatedResponsePart = generatedResponsePart
            self.retrievedReferences = retrievedReferences
        }
    }

}

extension ConflictException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was a conflict performing an operation. Resolve the conflict and retry your request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.ContentBody: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the body of the API response. This data type is used in the following API operations:
    ///
    /// * In the returnControlInvocationResults field of the [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax)
    public struct ContentBody {
        /// The body of the API response.
        public var body: Swift.String?

        public init(
            body: Swift.String? = nil
        )
        {
            self.body = body
        }
    }

}

extension BedrockAgentRuntimeClientTypes {
    public enum CreationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case overridden
        case sdkUnknown(Swift.String)

        public static var allCases: [CreationMode] {
            return [
                .default,
                .overridden,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .overridden: return "OVERRIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CreationMode(rawValue: rawValue) ?? CreationMode.sdkUnknown(rawValue)
        }
    }
}

extension DependencyFailedException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceName = self.properties.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        properties.resourceName = resourceNameDecoded
    }
}

extension DependencyFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DependencyFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an issue with a dependency. Check the resource configurations and retry the request.
public struct DependencyFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the dependency that caused the issue, such as Amazon Bedrock, Lambda, or STS.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct DependencyFailedExceptionBody {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension DependencyFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.FailureTrace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason
        case traceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.FailureTrace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the failure of the interaction.
    public struct FailureTrace {
        /// The reason the interaction failed.
        public var failureReason: Swift.String?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            failureReason: Swift.String? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.failureReason = failureReason
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.FilterAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .value)
        value = valueDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Specifies the name that the metadata attribute must match and the value to which to compare the value of the metadata attribute. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html). This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)
    public struct FilterAttribute {
        /// The name that the metadata attribute must match.
        /// This member is required.
        public var key: Swift.String?
        /// The value to whcih to compare the value of the metadata attribute.
        /// This member is required.
        public var value: ClientRuntime.Document?

        public init(
            key: Swift.String? = nil,
            value: ClientRuntime.Document? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension BedrockAgentRuntimeClientTypes.FinalResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.FinalResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FinalResponse(text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the response to the user.
    public struct FinalResponse {
        /// The text in the response to the user.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.FunctionInvocationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroup
        case function
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroup = self.actionGroup {
            try encodeContainer.encode(actionGroup, forKey: .actionGroup)
        }
        if let function = self.function {
            try encodeContainer.encode(function, forKey: .function)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for functionparameter0 in parameters {
                try parametersContainer.encode(functionparameter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroup)
        actionGroup = actionGroupDecoded
        let parametersContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.FunctionParameter?].self, forKey: .parameters)
        var parametersDecoded0:[BedrockAgentRuntimeClientTypes.FunctionParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [BedrockAgentRuntimeClientTypes.FunctionParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let functionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .function)
        function = functionDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the function that the agent predicts should be called. This data type is used in the following API operations:
    ///
    /// * In the returnControl field of the [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax)
    public struct FunctionInvocationInput {
        /// The action group that the function belongs to.
        /// This member is required.
        public var actionGroup: Swift.String?
        /// The name of the function.
        public var function: Swift.String?
        /// A list of parameters of the function.
        public var parameters: [BedrockAgentRuntimeClientTypes.FunctionParameter]?

        public init(
            actionGroup: Swift.String? = nil,
            function: Swift.String? = nil,
            parameters: [BedrockAgentRuntimeClientTypes.FunctionParameter]? = nil
        )
        {
            self.actionGroup = actionGroup
            self.function = function
            self.parameters = parameters
        }
    }

}

extension BedrockAgentRuntimeClientTypes.FunctionParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about a parameter of the function. This data type is used in the following API operations:
    ///
    /// * In the returnControl field of the [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax)
    public struct FunctionParameter {
        /// The name of the parameter.
        public var name: Swift.String?
        /// The data type of the parameter.
        public var type: Swift.String?
        /// The value of the parameter.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension BedrockAgentRuntimeClientTypes.FunctionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroup
        case function
        case responseBody
        case responseState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroup = self.actionGroup {
            try encodeContainer.encode(actionGroup, forKey: .actionGroup)
        }
        if let function = self.function {
            try encodeContainer.encode(function, forKey: .function)
        }
        if let responseBody = responseBody {
            var responseBodyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseBody)
            for (dictKey0, responseBody0) in responseBody {
                try responseBodyContainer.encode(responseBody0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseState = self.responseState {
            try encodeContainer.encode(responseState.rawValue, forKey: .responseState)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroup)
        actionGroup = actionGroupDecoded
        let functionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .function)
        function = functionDecoded
        let responseBodyContainer = try containerValues.decodeIfPresent([Swift.String: BedrockAgentRuntimeClientTypes.ContentBody?].self, forKey: .responseBody)
        var responseBodyDecoded0: [Swift.String:BedrockAgentRuntimeClientTypes.ContentBody]? = nil
        if let responseBodyContainer = responseBodyContainer {
            responseBodyDecoded0 = [Swift.String:BedrockAgentRuntimeClientTypes.ContentBody]()
            for (key0, contentbody0) in responseBodyContainer {
                if let contentbody0 = contentbody0 {
                    responseBodyDecoded0?[key0] = contentbody0
                }
            }
        }
        responseBody = responseBodyDecoded0
        let responseStateDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.ResponseState.self, forKey: .responseState)
        responseState = responseStateDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the function that was called from the action group and the response that was returned. This data type is used in the following API operations:
    ///
    /// * In the returnControlInvocationResults of the [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax)
    public struct FunctionResult {
        /// The action group that the function belongs to.
        /// This member is required.
        public var actionGroup: Swift.String?
        /// The name of the function that was called.
        public var function: Swift.String?
        /// The response from the function call using the parameters. The response may be returned directly or from the Lambda function.
        public var responseBody: [Swift.String:BedrockAgentRuntimeClientTypes.ContentBody]?
        /// Controls the final response state returned to end user when API/Function execution failed. When this state is FAILURE, the request would fail with dependency failure exception. When this state is REPROMPT, the API/function response will be sent to model for re-prompt
        public var responseState: BedrockAgentRuntimeClientTypes.ResponseState?

        public init(
            actionGroup: Swift.String? = nil,
            function: Swift.String? = nil,
            responseBody: [Swift.String:BedrockAgentRuntimeClientTypes.ContentBody]? = nil,
            responseState: BedrockAgentRuntimeClientTypes.ResponseState? = nil
        )
        {
            self.actionGroup = actionGroup
            self.function = function
            self.responseBody = responseBody
            self.responseState = responseState
        }
    }

}

extension BedrockAgentRuntimeClientTypes.GeneratedResponsePart: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case textResponsePart
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let textResponsePart = self.textResponsePart {
            try encodeContainer.encode(textResponsePart, forKey: .textResponsePart)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textResponsePartDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.TextResponsePart.self, forKey: .textResponsePart)
        textResponsePart = textResponsePartDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.GeneratedResponsePart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeneratedResponsePart(textResponsePart: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains metadata about a part of the generated response that is accompanied by a citation. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the generatedResponsePart field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the generatedResponsePart field
    public struct GeneratedResponsePart {
        /// Contains metadata about a textual part of the generated response that is accompanied by a citation.
        public var textResponsePart: BedrockAgentRuntimeClientTypes.TextResponsePart?

        public init(
            textResponsePart: BedrockAgentRuntimeClientTypes.TextResponsePart? = nil
        )
        {
            self.textResponsePart = textResponsePart
        }
    }

}

extension BedrockAgentRuntimeClientTypes.GenerationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case promptTemplate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let promptTemplate = self.promptTemplate {
            try encodeContainer.encode(promptTemplate, forKey: .promptTemplate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptTemplateDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.PromptTemplate.self, forKey: .promptTemplate)
        promptTemplate = promptTemplateDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains configurations for response generation based on the knowledge base query results. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)
    public struct GenerationConfiguration {
        /// Contains the template for the prompt that's sent to the model for response generation.
        public var promptTemplate: BedrockAgentRuntimeClientTypes.PromptTemplate?

        public init(
            promptTemplate: BedrockAgentRuntimeClientTypes.PromptTemplate? = nil
        )
        {
            self.promptTemplate = promptTemplate
        }
    }

}

extension BedrockAgentRuntimeClientTypes.InferenceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumLength
        case stopSequences
        case temperature
        case topk = "topK"
        case topp = "topP"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximumLength = self.maximumLength {
            try encodeContainer.encode(maximumLength, forKey: .maximumLength)
        }
        if let stopSequences = stopSequences {
            var stopSequencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopSequences)
            for string0 in stopSequences {
                try stopSequencesContainer.encode(string0)
            }
        }
        if let temperature = self.temperature {
            try encodeContainer.encode(temperature, forKey: .temperature)
        }
        if let topk = self.topk {
            try encodeContainer.encode(topk, forKey: .topk)
        }
        if let topp = self.topp {
            try encodeContainer.encode(topp, forKey: .topp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let temperatureDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .temperature)
        temperature = temperatureDecoded
        let toppDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .topp)
        topp = toppDecoded
        let topkDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .topk)
        topk = topkDecoded
        let maximumLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumLength)
        maximumLength = maximumLengthDecoded
        let stopSequencesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stopSequences)
        var stopSequencesDecoded0:[Swift.String]? = nil
        if let stopSequencesContainer = stopSequencesContainer {
            stopSequencesDecoded0 = [Swift.String]()
            for string0 in stopSequencesContainer {
                if let string0 = string0 {
                    stopSequencesDecoded0?.append(string0)
                }
            }
        }
        stopSequences = stopSequencesDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Specifications about the inference parameters that were provided alongside the prompt. These are specified in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    public struct InferenceConfiguration {
        /// The maximum number of tokens allowed in the generated response.
        public var maximumLength: Swift.Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public var stopSequences: [Swift.String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        public var temperature: Swift.Float?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for topK is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topK to 50, the model selects the next token from among the top 50 most likely choices.
        public var topk: Swift.Int?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for Top P determines the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topP to 80, the model only selects the next token from the top 80% of the probability distribution of next tokens.
        public var topp: Swift.Float?

        public init(
            maximumLength: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topk: Swift.Int? = nil,
            topp: Swift.Float? = nil
        )
        {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topk = topk
            self.topp = topp
        }
    }

}

extension InternalServerException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupInvocationInput
        case invocationType
        case knowledgeBaseLookupInput
        case traceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupInvocationInput = self.actionGroupInvocationInput {
            try encodeContainer.encode(actionGroupInvocationInput, forKey: .actionGroupInvocationInput)
        }
        if let invocationType = self.invocationType {
            try encodeContainer.encode(invocationType.rawValue, forKey: .invocationType)
        }
        if let knowledgeBaseLookupInput = self.knowledgeBaseLookupInput {
            try encodeContainer.encode(knowledgeBaseLookupInput, forKey: .knowledgeBaseLookupInput)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let invocationTypeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.InvocationType.self, forKey: .invocationType)
        invocationType = invocationTypeDecoded
        let actionGroupInvocationInputDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput.self, forKey: .actionGroupInvocationInput)
        actionGroupInvocationInput = actionGroupInvocationInputDecoded
        let knowledgeBaseLookupInputDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput.self, forKey: .knowledgeBaseLookupInput)
        knowledgeBaseLookupInput = knowledgeBaseLookupInputDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information pertaining to the action group or knowledge base that is being invoked.
    public struct InvocationInput {
        /// Contains information about the action group to be invoked.
        public var actionGroupInvocationInput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput?
        /// Specifies whether the agent is invoking an action group or a knowledge base.
        public var invocationType: BedrockAgentRuntimeClientTypes.InvocationType?
        /// Contains details about the knowledge base to look up and the query to be made.
        public var knowledgeBaseLookupInput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            actionGroupInvocationInput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput? = nil,
            invocationType: BedrockAgentRuntimeClientTypes.InvocationType? = nil,
            knowledgeBaseLookupInput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.actionGroupInvocationInput = actionGroupInvocationInput
            self.invocationType = invocationType
            self.knowledgeBaseLookupInput = knowledgeBaseLookupInput
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.InvocationInputMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiinvocationinput = "apiInvocationInput"
        case functioninvocationinput = "functionInvocationInput"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .apiinvocationinput(apiinvocationinput):
                try container.encode(apiinvocationinput, forKey: .apiinvocationinput)
            case let .functioninvocationinput(functioninvocationinput):
                try container.encode(functioninvocationinput, forKey: .functioninvocationinput)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let apiinvocationinputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.ApiInvocationInput.self, forKey: .apiinvocationinput)
        if let apiinvocationinput = apiinvocationinputDecoded {
            self = .apiinvocationinput(apiinvocationinput)
            return
        }
        let functioninvocationinputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.FunctionInvocationInput.self, forKey: .functioninvocationinput)
        if let functioninvocationinput = functioninvocationinputDecoded {
            self = .functioninvocationinput(functioninvocationinput)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the API operation or function that the agent predicts should be called. This data type is used in the following API operations:
    ///
    /// * In the returnControl field of the [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax)
    public enum InvocationInputMember {
        /// Contains information about the API operation that the agent predicts should be called.
        case apiinvocationinput(BedrockAgentRuntimeClientTypes.ApiInvocationInput)
        /// Contains information about the function that the agent predicts should be called.
        case functioninvocationinput(BedrockAgentRuntimeClientTypes.FunctionInvocationInput)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.InvocationResultMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiresult = "apiResult"
        case functionresult = "functionResult"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .apiresult(apiresult):
                try container.encode(apiresult, forKey: .apiresult)
            case let .functionresult(functionresult):
                try container.encode(functionresult, forKey: .functionresult)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let apiresultDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.ApiResult.self, forKey: .apiresult)
        if let apiresult = apiresultDecoded {
            self = .apiresult(apiresult)
            return
        }
        let functionresultDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.FunctionResult.self, forKey: .functionresult)
        if let functionresult = functionresultDecoded {
            self = .functionresult(functionresult)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// A result from the action group invocation. This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax)
    public enum InvocationResultMember {
        /// The result from the API response from the action group invocation.
        case apiresult(BedrockAgentRuntimeClientTypes.ApiResult)
        /// The result from the function from the action group invocation.
        case functionresult(BedrockAgentRuntimeClientTypes.FunctionResult)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes {
    public enum InvocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionGroup
        case finish
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [InvocationType] {
            return [
                .actionGroup,
                .finish,
                .knowledgeBase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionGroup: return "ACTION_GROUP"
            case .finish: return "FINISH"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvocationType(rawValue: rawValue) ?? InvocationType.sdkUnknown(rawValue)
        }
    }
}

extension InvokeAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeAgentInput(agentAliasId: \(Swift.String(describing: agentAliasId)), agentId: \(Swift.String(describing: agentId)), enableTrace: \(Swift.String(describing: enableTrace)), endSession: \(Swift.String(describing: endSession)), sessionId: \(Swift.String(describing: sessionId)), sessionState: \(Swift.String(describing: sessionState)), inputText: \"CONTENT_REDACTED\")"}
}

extension InvokeAgentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableTrace
        case endSession
        case inputText
        case sessionState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableTrace = self.enableTrace {
            try encodeContainer.encode(enableTrace, forKey: .enableTrace)
        }
        if let endSession = self.endSession {
            try encodeContainer.encode(endSession, forKey: .endSession)
        }
        if let inputText = self.inputText {
            try encodeContainer.encode(inputText, forKey: .inputText)
        }
        if let sessionState = self.sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
    }
}

extension InvokeAgentInput {

    static func urlPathProvider(_ value: InvokeAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentAliases/\(agentAliasId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/text"
    }
}

public struct InvokeAgentInput {
    /// The alias of the agent to use.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The unique identifier of the agent to use.
    /// This member is required.
    public var agentId: Swift.String?
    /// Specifies whether to turn on the trace or not to track the agent's reasoning process. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-events).
    public var enableTrace: Swift.Bool?
    /// Specifies whether to end the session with the agent or not.
    public var endSession: Swift.Bool?
    /// The prompt text to send the agent.
    public var inputText: Swift.String?
    /// The unique identifier of the session. Use the same value across requests to continue the same conversation.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Contains parameters that specify various attributes of the session. For more information, see [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html).
    public var sessionState: BedrockAgentRuntimeClientTypes.SessionState?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        enableTrace: Swift.Bool? = nil,
        endSession: Swift.Bool? = nil,
        inputText: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionState: BedrockAgentRuntimeClientTypes.SessionState? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
        self.enableTrace = enableTrace
        self.endSession = endSession
        self.inputText = inputText
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct InvokeAgentInputBody {
    let sessionState: BedrockAgentRuntimeClientTypes.SessionState?
    let endSession: Swift.Bool?
    let enableTrace: Swift.Bool?
    let inputText: Swift.String?
}

extension InvokeAgentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableTrace
        case endSession
        case inputText
        case sessionState
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionStateDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let endSessionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .endSession)
        endSession = endSessionDecoded
        let enableTraceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableTrace)
        enableTrace = enableTraceDecoded
        let inputTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputText)
        inputText = inputTextDecoded
    }
}

extension InvokeAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-bedrock-agent-content-type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-bedrock-agent-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if case let .stream(stream) = httpResponse.body, let responseDecoder = decoder {
            let messageDecoder = AWSClientRuntime.AWSEventStream.AWSMessageDecoder()
            let decoderStream = ClientRuntime.EventStream.DefaultMessageDecoderStream<BedrockAgentRuntimeClientTypes.ResponseStream>(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: jsonUnmarshalClosure(responseDecoder: responseDecoder))
            self.completion = decoderStream.toAsyncStream()
        } else {
            self.completion = nil
        }
    }
}

public struct InvokeAgentOutput {
    /// The agent's response to the user prompt.
    /// This member is required.
    public var completion: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.ResponseStream, Swift.Error>?
    /// The MIME type of the input data in the request. The default value is application/json.
    /// This member is required.
    public var contentType: Swift.String?
    /// The unique identifier of the session with the agent.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        completion: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.ResponseStream, Swift.Error>? = nil,
        contentType: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.completion = completion
        self.contentType = contentType
        self.sessionId = sessionId
    }
}

enum InvokeAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadGatewayException": return try await BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyFailedException": return try await DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseId
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseLookupInput(knowledgeBaseId: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the knowledge base to look up and the query to be made.
    public struct KnowledgeBaseLookupInput {
        /// The unique identifier of the knowledge base to look up.
        public var knowledgeBaseId: Swift.String?
        /// The query made to the knowledge base.
        public var text: Swift.String?

        public init(
            knowledgeBaseId: Swift.String? = nil,
            text: Swift.String? = nil
        )
        {
            self.knowledgeBaseId = knowledgeBaseId
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retrievedReferences
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retrievedReferences = retrievedReferences {
            var retrievedReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .retrievedReferences)
            for retrievedreference0 in retrievedReferences {
                try retrievedReferencesContainer.encode(retrievedreference0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retrievedReferencesContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.RetrievedReference?].self, forKey: .retrievedReferences)
        var retrievedReferencesDecoded0:[BedrockAgentRuntimeClientTypes.RetrievedReference]? = nil
        if let retrievedReferencesContainer = retrievedReferencesContainer {
            retrievedReferencesDecoded0 = [BedrockAgentRuntimeClientTypes.RetrievedReference]()
            for structure0 in retrievedReferencesContainer {
                if let structure0 = structure0 {
                    retrievedReferencesDecoded0?.append(structure0)
                }
            }
        }
        retrievedReferences = retrievedReferencesDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the results from looking up the knowledge base.
    public struct KnowledgeBaseLookupOutput {
        /// Contains metadata about the sources cited for the generated response.
        public var retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]?

        public init(
            retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]? = nil
        )
        {
            self.retrievedReferences = retrievedReferences
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the query made to the knowledge base. This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax) – in the retrievalQuery field
    public struct KnowledgeBaseQuery {
        /// The text of the query made to the knowledge base.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vectorSearchConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vectorSearchConfiguration = self.vectorSearchConfiguration {
            try encodeContainer.encode(vectorSearchConfiguration, forKey: .vectorSearchConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains configurations for the knowledge base query and retrieval process. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html). This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax) – in the retrievalConfiguration field
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the retrievalConfiguration field
    public struct KnowledgeBaseRetrievalConfiguration {
        /// Contains details about how the results from the vector search should be returned. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
        /// This member is required.
        public var vectorSearchConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration?

        public init(
            vectorSearchConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration? = nil
        )
        {
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case location
        case metadata
        case score
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, retrievalResultMetadata0) in metadata {
                try metadataContainer.encode(retrievalResultMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrievalResultContent.self, forKey: .content)
        content = contentDecoded
        let locationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrievalResultLocation.self, forKey: .location)
        location = locationDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score)
        score = scoreDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: ClientRuntime.Document?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:ClientRuntime.Document]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:ClientRuntime.Document]()
            for (key0, retrievalresultmetadatavalue0) in metadataContainer {
                if let retrievalresultmetadatavalue0 = retrievalresultmetadatavalue0 {
                    metadataDecoded0?[key0] = retrievalresultmetadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseRetrievalResult(score: \(Swift.String(describing: score)), content: \"CONTENT_REDACTED\", location: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// Details about a result from querying the knowledge base. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the retrievalResults field
    public struct KnowledgeBaseRetrievalResult {
        /// Contains a chunk of text from a data source in the knowledge base.
        /// This member is required.
        public var content: BedrockAgentRuntimeClientTypes.RetrievalResultContent?
        /// Contains information about the location of the data source.
        public var location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation?
        /// Contains metadata attributes and their values for the file in the data source. For more information, see [Metadata and filtering](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-ds.html#kb-ds-metadata).
        public var metadata: [Swift.String:ClientRuntime.Document]?
        /// The level of relevance of the result to the query.
        public var score: Swift.Double?

        public init(
            content: BedrockAgentRuntimeClientTypes.RetrievalResultContent? = nil,
            location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation? = nil,
            metadata: [Swift.String:ClientRuntime.Document]? = nil,
            score: Swift.Double? = nil
        )
        {
            self.content = content
            self.location = location
            self.metadata = metadata
            self.score = score
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationConfiguration
        case knowledgeBaseId
        case modelArn
        case retrievalConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generationConfiguration = self.generationConfiguration {
            try encodeContainer.encode(generationConfiguration, forKey: .generationConfiguration)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let modelArn = self.modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let retrievalConfiguration = self.retrievalConfiguration {
            try encodeContainer.encode(retrievalConfiguration, forKey: .retrievalConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let retrievalConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration.self, forKey: .retrievalConfiguration)
        retrievalConfiguration = retrievalConfigurationDecoded
        let generationConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.GenerationConfiguration.self, forKey: .generationConfiguration)
        generationConfiguration = generationConfigurationDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the resource being queried. This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax) – in the knowledgeBaseConfiguration field
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the knowledgeBaseConfiguration field
    public struct KnowledgeBaseRetrieveAndGenerateConfiguration {
        /// Contains configurations for response generation based on the knowwledge base query results.
        public var generationConfiguration: BedrockAgentRuntimeClientTypes.GenerationConfiguration?
        /// The unique identifier of the knowledge base that is queried and the foundation model used for generation.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The ARN of the foundation model used to generate a response.
        /// This member is required.
        public var modelArn: Swift.String?
        /// Contains configurations for how to retrieve and return the knowledge base query.
        public var retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration?

        public init(
            generationConfiguration: BedrockAgentRuntimeClientTypes.GenerationConfiguration? = nil,
            knowledgeBaseId: Swift.String? = nil,
            modelArn: Swift.String? = nil,
            retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration? = nil
        )
        {
            self.generationConfiguration = generationConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.modelArn = modelArn
            self.retrievalConfiguration = retrievalConfiguration
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case numberOfResults
        case overrideSearchType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let numberOfResults = self.numberOfResults {
            try encodeContainer.encode(numberOfResults, forKey: .numberOfResults)
        }
        if let overrideSearchType = self.overrideSearchType {
            try encodeContainer.encode(overrideSearchType.rawValue, forKey: .overrideSearchType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfResults)
        numberOfResults = numberOfResultsDecoded
        let overrideSearchTypeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.SearchType.self, forKey: .overrideSearchType)
        overrideSearchType = overrideSearchTypeDecoded
        let filterDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrievalFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseVectorSearchConfiguration(numberOfResults: \(Swift.String(describing: numberOfResults)), overrideSearchType: \(Swift.String(describing: overrideSearchType)), filter: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// Configurations for how to perform the search query and return results. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html). This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax) – in the vectorSearchConfiguration field
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the vectorSearchConfiguration field
    public struct KnowledgeBaseVectorSearchConfiguration {
        /// Specifies the filters to use on the metadata in the knowledge base data sources before returning results. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
        public var filter: BedrockAgentRuntimeClientTypes.RetrievalFilter?
        /// The number of source chunks to retrieve.
        public var numberOfResults: Swift.Int?
        /// By default, Amazon Bedrock decides a search strategy for you. If you're using an Amazon OpenSearch Serverless vector store that contains a filterable text field, you can specify whether to query the knowledge base with a HYBRID search using both vector embeddings and raw text, or SEMANTIC search using only vector embeddings. For other vector store configurations, only SEMANTIC search is available. For more information, see [Test a knowledge base](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-test.html).
        public var overrideSearchType: BedrockAgentRuntimeClientTypes.SearchType?

        public init(
            filter: BedrockAgentRuntimeClientTypes.RetrievalFilter? = nil,
            numberOfResults: Swift.Int? = nil,
            overrideSearchType: BedrockAgentRuntimeClientTypes.SearchType? = nil
        )
        {
            self.filter = filter
            self.numberOfResults = numberOfResults
            self.overrideSearchType = overrideSearchType
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ModelInvocationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inferenceConfiguration
        case overrideLambda
        case parserMode
        case promptCreationMode
        case text
        case traceId
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inferenceConfiguration = self.inferenceConfiguration {
            try encodeContainer.encode(inferenceConfiguration, forKey: .inferenceConfiguration)
        }
        if let overrideLambda = self.overrideLambda {
            try encodeContainer.encode(overrideLambda, forKey: .overrideLambda)
        }
        if let parserMode = self.parserMode {
            try encodeContainer.encode(parserMode.rawValue, forKey: .parserMode)
        }
        if let promptCreationMode = self.promptCreationMode {
            try encodeContainer.encode(promptCreationMode.rawValue, forKey: .promptCreationMode)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.PromptType.self, forKey: .type)
        type = typeDecoded
        let inferenceConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.InferenceConfiguration.self, forKey: .inferenceConfiguration)
        inferenceConfiguration = inferenceConfigurationDecoded
        let overrideLambdaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overrideLambda)
        overrideLambda = overrideLambdaDecoded
        let promptCreationModeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.CreationMode.self, forKey: .promptCreationMode)
        promptCreationMode = promptCreationModeDecoded
        let parserModeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.CreationMode.self, forKey: .parserMode)
        parserMode = parserModeDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.ModelInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The input for the pre-processing step.
    ///
    /// * The type matches the agent step.
    ///
    /// * The text contains the prompt.
    ///
    /// * The inferenceConfiguration, parserMode, and overrideLambda values are set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated.
    public struct ModelInvocationInput {
        /// Specifications about the inference parameters that were provided alongside the prompt. These are specified in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var inferenceConfiguration: BedrockAgentRuntimeClientTypes.InferenceConfiguration?
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence.
        public var overrideLambda: Swift.String?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType.
        public var parserMode: BedrockAgentRuntimeClientTypes.CreationMode?
        /// Specifies whether the default prompt template was OVERRIDDEN. If it was, the basePromptTemplate that was set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object when the agent was created or updated is used instead.
        public var promptCreationMode: BedrockAgentRuntimeClientTypes.CreationMode?
        /// The text that prompted the agent at this step.
        public var text: Swift.String?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?
        /// The step in the agent sequence.
        public var type: BedrockAgentRuntimeClientTypes.PromptType?

        public init(
            inferenceConfiguration: BedrockAgentRuntimeClientTypes.InferenceConfiguration? = nil,
            overrideLambda: Swift.String? = nil,
            parserMode: BedrockAgentRuntimeClientTypes.CreationMode? = nil,
            promptCreationMode: BedrockAgentRuntimeClientTypes.CreationMode? = nil,
            text: Swift.String? = nil,
            traceId: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.PromptType? = nil
        )
        {
            self.inferenceConfiguration = inferenceConfiguration
            self.overrideLambda = overrideLambda
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.text = text
            self.traceId = traceId
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes.Observation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupInvocationOutput
        case finalResponse
        case knowledgeBaseLookupOutput
        case repromptResponse
        case traceId
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupInvocationOutput = self.actionGroupInvocationOutput {
            try encodeContainer.encode(actionGroupInvocationOutput, forKey: .actionGroupInvocationOutput)
        }
        if let finalResponse = self.finalResponse {
            try encodeContainer.encode(finalResponse, forKey: .finalResponse)
        }
        if let knowledgeBaseLookupOutput = self.knowledgeBaseLookupOutput {
            try encodeContainer.encode(knowledgeBaseLookupOutput, forKey: .knowledgeBaseLookupOutput)
        }
        if let repromptResponse = self.repromptResponse {
            try encodeContainer.encode(repromptResponse, forKey: .repromptResponse)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let actionGroupInvocationOutputDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput.self, forKey: .actionGroupInvocationOutput)
        actionGroupInvocationOutput = actionGroupInvocationOutputDecoded
        let knowledgeBaseLookupOutputDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput.self, forKey: .knowledgeBaseLookupOutput)
        knowledgeBaseLookupOutput = knowledgeBaseLookupOutputDecoded
        let finalResponseDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.FinalResponse.self, forKey: .finalResponse)
        finalResponse = finalResponseDecoded
        let repromptResponseDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RepromptResponse.self, forKey: .repromptResponse)
        repromptResponse = repromptResponseDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.Observation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the result or output of an action group or knowledge base, or the response to the user.
    public struct Observation {
        /// Contains the JSON-formatted string returned by the API invoked by the action group.
        public var actionGroupInvocationOutput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput?
        /// Contains details about the response to the user.
        public var finalResponse: BedrockAgentRuntimeClientTypes.FinalResponse?
        /// Contains details about the results from looking up the knowledge base.
        public var knowledgeBaseLookupOutput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput?
        /// Contains details about the response to reprompt the input.
        public var repromptResponse: BedrockAgentRuntimeClientTypes.RepromptResponse?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?
        /// Specifies what kind of information the agent returns in the observation. The following values are possible.
        ///
        /// * ACTION_GROUP – The agent returns the result of an action group.
        ///
        /// * KNOWLEDGE_BASE – The agent returns information from a knowledge base.
        ///
        /// * FINISH – The agent returns a final response to the user with no follow-up.
        ///
        /// * ASK_USER – The agent asks the user a question.
        ///
        /// * REPROMPT – The agent prompts the user again for the same information.
        public var type: BedrockAgentRuntimeClientTypes.ModelType?

        public init(
            actionGroupInvocationOutput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput? = nil,
            finalResponse: BedrockAgentRuntimeClientTypes.FinalResponse? = nil,
            knowledgeBaseLookupOutput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput? = nil,
            repromptResponse: BedrockAgentRuntimeClientTypes.RepromptResponse? = nil,
            traceId: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.ModelType? = nil
        )
        {
            self.actionGroupInvocationOutput = actionGroupInvocationOutput
            self.finalResponse = finalResponse
            self.knowledgeBaseLookupOutput = knowledgeBaseLookupOutput
            self.repromptResponse = repromptResponse
            self.traceId = traceId
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes.OrchestrationTrace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invocationinput = "invocationInput"
        case modelinvocationinput = "modelInvocationInput"
        case observation
        case rationale
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .invocationinput(invocationinput):
                try container.encode(invocationinput, forKey: .invocationinput)
            case let .modelinvocationinput(modelinvocationinput):
                try container.encode(modelinvocationinput, forKey: .modelinvocationinput)
            case let .observation(observation):
                try container.encode(observation, forKey: .observation)
            case let .rationale(rationale):
                try container.encode(rationale, forKey: .rationale)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let rationaleDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.Rationale.self, forKey: .rationale)
        if let rationale = rationaleDecoded {
            self = .rationale(rationale)
            return
        }
        let invocationinputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.InvocationInput.self, forKey: .invocationinput)
        if let invocationinput = invocationinputDecoded {
            self = .invocationinput(invocationinput)
            return
        }
        let observationDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.Observation.self, forKey: .observation)
        if let observation = observationDecoded {
            self = .observation(observation)
            return
        }
        let modelinvocationinputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.ModelInvocationInput.self, forKey: .modelinvocationinput)
        if let modelinvocationinput = modelinvocationinputDecoded {
            self = .modelinvocationinput(modelinvocationinput)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Details about the orchestration step, in which the agent determines the order in which actions are executed and which knowledge bases are retrieved.
    public enum OrchestrationTrace {
        /// Details about the reasoning, based on the input, that the agent uses to justify carrying out an action group or getting information from a knowledge base.
        case rationale(BedrockAgentRuntimeClientTypes.Rationale)
        /// Contains information pertaining to the action group or knowledge base that is being invoked.
        case invocationinput(BedrockAgentRuntimeClientTypes.InvocationInput)
        /// Details about the observation (the output of the action group Lambda or knowledge base) made by the agent.
        case observation(BedrockAgentRuntimeClientTypes.Observation)
        /// The input for the orchestration step.
        ///
        /// * The type is ORCHESTRATION.
        ///
        /// * The text contains the prompt.
        ///
        /// * The inferenceConfiguration, parserMode, and overrideLambda values are set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated.
        case modelinvocationinput(BedrockAgentRuntimeClientTypes.ModelInvocationInput)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.Parameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// A parameter for the API request or function.
    public struct Parameter {
        /// The name of the parameter.
        public var name: Swift.String?
        /// The type of the parameter.
        public var type: Swift.String?
        /// The value of the parameter.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PayloadPart: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribution
        case bytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribution = self.attribution {
            try encodeContainer.encode(attribution, forKey: .attribution)
        }
        if let bytes = self.bytes {
            try encodeContainer.encode(bytes.base64EncodedString(), forKey: .bytes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bytesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .bytes)
        bytes = bytesDecoded
        let attributionDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.Attribution.self, forKey: .attribution)
        attribution = attributionDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.PayloadPart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains a part of an agent response and citations for it.
    public struct PayloadPart {
        /// Contains citations for a part of an agent response.
        public var attribution: BedrockAgentRuntimeClientTypes.Attribution?
        /// A part of the agent response in bytes.
        public var bytes: ClientRuntime.Data?

        public init(
            attribution: BedrockAgentRuntimeClientTypes.Attribution? = nil,
            bytes: ClientRuntime.Data? = nil
        )
        {
            self.attribution = attribution
            self.bytes = bytes
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parsedResponse
        case traceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parsedResponse = self.parsedResponse {
            try encodeContainer.encode(parsedResponse, forKey: .parsedResponse)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let parsedResponseDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse.self, forKey: .parsedResponse)
        parsedResponse = parsedResponseDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The foundation model output from the post-processing step.
    public struct PostProcessingModelInvocationOutput {
        /// Details about the response from the Lambda parsing of the output of the post-processing step.
        public var parsedResponse: BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            parsedResponse: BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.parsedResponse = parsedResponse
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Details about the response from the Lambda parsing of the output from the post-processing step.
    public struct PostProcessingParsedResponse {
        /// The text returned by the parser.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PostProcessingTrace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelinvocationinput = "modelInvocationInput"
        case modelinvocationoutput = "modelInvocationOutput"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .modelinvocationinput(modelinvocationinput):
                try container.encode(modelinvocationinput, forKey: .modelinvocationinput)
            case let .modelinvocationoutput(modelinvocationoutput):
                try container.encode(modelinvocationoutput, forKey: .modelinvocationoutput)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let modelinvocationinputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.ModelInvocationInput.self, forKey: .modelinvocationinput)
        if let modelinvocationinput = modelinvocationinputDecoded {
            self = .modelinvocationinput(modelinvocationinput)
            return
        }
        let modelinvocationoutputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput.self, forKey: .modelinvocationoutput)
        if let modelinvocationoutput = modelinvocationoutputDecoded {
            self = .modelinvocationoutput(modelinvocationoutput)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Details about the post-processing step, in which the agent shapes the response.
    public enum PostProcessingTrace {
        /// The input for the post-processing step.
        ///
        /// * The type is POST_PROCESSING.
        ///
        /// * The text contains the prompt.
        ///
        /// * The inferenceConfiguration, parserMode, and overrideLambda values are set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated.
        case modelinvocationinput(BedrockAgentRuntimeClientTypes.ModelInvocationInput)
        /// The foundation model output from the post-processing step.
        case modelinvocationoutput(BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parsedResponse
        case traceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parsedResponse = self.parsedResponse {
            try encodeContainer.encode(parsedResponse, forKey: .parsedResponse)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let parsedResponseDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse.self, forKey: .parsedResponse)
        parsedResponse = parsedResponseDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The foundation model output from the pre-processing step.
    public struct PreProcessingModelInvocationOutput {
        /// Details about the response from the Lambda parsing of the output of the pre-processing step.
        public var parsedResponse: BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            parsedResponse: BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.parsedResponse = parsedResponse
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isValid
        case rationale
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isValid = self.isValid {
            try encodeContainer.encode(isValid, forKey: .isValid)
        }
        if let rationale = self.rationale {
            try encodeContainer.encode(rationale, forKey: .rationale)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rationaleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rationale)
        rationale = rationaleDecoded
        let isValidDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isValid)
        isValid = isValidDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Details about the response from the Lambda parsing of the output from the pre-processing step.
    public struct PreProcessingParsedResponse {
        /// Whether the user input is valid or not. If false, the agent doesn't proceed to orchestration.
        public var isValid: Swift.Bool?
        /// The text returned by the parsing of the pre-processing step, explaining the steps that the agent plans to take in orchestration, if the user input is valid.
        public var rationale: Swift.String?

        public init(
            isValid: Swift.Bool? = nil,
            rationale: Swift.String? = nil
        )
        {
            self.isValid = isValid
            self.rationale = rationale
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PreProcessingTrace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelinvocationinput = "modelInvocationInput"
        case modelinvocationoutput = "modelInvocationOutput"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .modelinvocationinput(modelinvocationinput):
                try container.encode(modelinvocationinput, forKey: .modelinvocationinput)
            case let .modelinvocationoutput(modelinvocationoutput):
                try container.encode(modelinvocationoutput, forKey: .modelinvocationoutput)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let modelinvocationinputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.ModelInvocationInput.self, forKey: .modelinvocationinput)
        if let modelinvocationinput = modelinvocationinputDecoded {
            self = .modelinvocationinput(modelinvocationinput)
            return
        }
        let modelinvocationoutputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput.self, forKey: .modelinvocationoutput)
        if let modelinvocationoutput = modelinvocationoutputDecoded {
            self = .modelinvocationoutput(modelinvocationoutput)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Details about the pre-processing step, in which the agent contextualizes and categorizes user inputs.
    public enum PreProcessingTrace {
        /// The input for the pre-processing step.
        ///
        /// * The type is PRE_PROCESSING.
        ///
        /// * The text contains the prompt.
        ///
        /// * The inferenceConfiguration, parserMode, and overrideLambda values are set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated.
        case modelinvocationinput(BedrockAgentRuntimeClientTypes.ModelInvocationInput)
        /// The foundation model output from the pre-processing step.
        case modelinvocationoutput(BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.PromptTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case textPromptTemplate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let textPromptTemplate = self.textPromptTemplate {
            try encodeContainer.encode(textPromptTemplate, forKey: .textPromptTemplate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textPromptTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textPromptTemplate)
        textPromptTemplate = textPromptTemplateDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.PromptTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromptTemplate(textPromptTemplate: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the template for the prompt that's sent to the model for response generation. For more information, see [Knowledge base prompt templates](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html#kb-test-config-sysprompt). This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the filter field
    public struct PromptTemplate {
        /// The template for the prompt that's sent to the model for response generation. You can include prompt placeholders, which become replaced before the prompt is sent to the model to provide instructions and context to the model. In addition, you can include XML tags to delineate meaningful sections of the prompt template. For more information, see the following resources:
        ///
        /// * [Knowledge base prompt templates](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html#kb-test-config-sysprompt)
        ///
        /// * [Use XML tags with Anthropic Claude models](https://docs.anthropic.com/claude/docs/use-xml-tags)
        public var textPromptTemplate: Swift.String?

        public init(
            textPromptTemplate: Swift.String? = nil
        )
        {
            self.textPromptTemplate = textPromptTemplate
        }
    }

}

extension BedrockAgentRuntimeClientTypes {
    public enum PromptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knowledgeBaseResponseGeneration
        case orchestration
        case postProcessing
        case preProcessing
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptType] {
            return [
                .knowledgeBaseResponseGeneration,
                .orchestration,
                .postProcessing,
                .preProcessing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBaseResponseGeneration: return "KNOWLEDGE_BASE_RESPONSE_GENERATION"
            case .orchestration: return "ORCHESTRATION"
            case .postProcessing: return "POST_PROCESSING"
            case .preProcessing: return "PRE_PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PromptType(rawValue: rawValue) ?? PromptType.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.PropertyParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for parameter0 in properties {
                try propertiesContainer.encode(parameter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertiesContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.Parameter?].self, forKey: .properties)
        var propertiesDecoded0:[BedrockAgentRuntimeClientTypes.Parameter]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [BedrockAgentRuntimeClientTypes.Parameter]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the parameters in the request body.
    public struct PropertyParameters {
        /// A list of parameters in the request body.
        public var properties: [BedrockAgentRuntimeClientTypes.Parameter]?

        public init(
            properties: [BedrockAgentRuntimeClientTypes.Parameter]? = nil
        )
        {
            self.properties = properties
        }
    }

}

extension BedrockAgentRuntimeClientTypes.Rationale: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
        case traceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.Rationale: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the reasoning, based on the input, that the agent uses to justify carrying out an action group or getting information from a knowledge base.
    public struct Rationale {
        /// The reasoning or thought process of the agent, based on the input.
        public var text: Swift.String?
        /// The unique identifier of the trace step.
        public var traceId: Swift.String?

        public init(
            text: Swift.String? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.text = text
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RepromptResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.RepromptResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the agent's response to reprompt the input.
    public struct RepromptResponse {
        /// Specifies what output is prompting the agent to reprompt the input.
        public var source: BedrockAgentRuntimeClientTypes.Source?
        /// The text reprompting the input.
        public var text: Swift.String?

        public init(
            source: BedrockAgentRuntimeClientTypes.Source? = nil,
            text: Swift.String? = nil
        )
        {
            self.source = source
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RequestBody: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            var contentContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .content)
            for (dictKey0, contentMap0) in content {
                var contentMap0Container = contentContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for parameter1 in contentMap0 {
                    try contentMap0Container.encode(parameter1)
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentContainer = try containerValues.decodeIfPresent([Swift.String: [BedrockAgentRuntimeClientTypes.Parameter?]?].self, forKey: .content)
        var contentDecoded0: [Swift.String:[BedrockAgentRuntimeClientTypes.Parameter]]? = nil
        if let contentContainer = contentContainer {
            contentDecoded0 = [Swift.String:[BedrockAgentRuntimeClientTypes.Parameter]]()
            for (key0, parameters0) in contentContainer {
                var parameters0Decoded0: [BedrockAgentRuntimeClientTypes.Parameter]? = nil
                if let parameters0 = parameters0 {
                    parameters0Decoded0 = [BedrockAgentRuntimeClientTypes.Parameter]()
                    for structure1 in parameters0 {
                        if let structure1 = structure1 {
                            parameters0Decoded0?.append(structure1)
                        }
                    }
                }
                contentDecoded0?[key0] = parameters0Decoded0
            }
        }
        content = contentDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The parameters in the API request body.
    public struct RequestBody {
        /// The content in the request body.
        public var content: [Swift.String:[BedrockAgentRuntimeClientTypes.Parameter]]?

        public init(
            content: [Swift.String:[BedrockAgentRuntimeClientTypes.Parameter]]? = nil
        )
        {
            self.content = content
        }
    }

}

extension ResourceNotFoundException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    public enum ResponseState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failure
        case reprompt
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseState] {
            return [
                .failure,
                .reprompt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failure: return "FAILURE"
            case .reprompt: return "REPROMPT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResponseState(rawValue: rawValue) ?? ResponseState.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ResponseStream: ClientRuntime.MessageUnmarshallable {
    public init(message: ClientRuntime.EventStream.Message, decoder: ClientRuntime.ResponseDecoder) throws {
        switch try message.type() {
        case .event(let params):
            switch params.eventType {
            case "chunk":
                self = .chunk(try decoder.decode(responseBody: message.payload))
            case "trace":
                self = .trace(try decoder.decode(responseBody: message.payload))
            case "returnControl":
                self = .returncontrol(try decoder.decode(responseBody: message.payload))
            default:
                self = .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
            }
        case .exception(let params):
            let makeError: (ClientRuntime.EventStream.Message, ClientRuntime.EventStream.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                switch params.exceptionType {
                case "internalServerException":
                    return try decoder.decode(responseBody: message.payload) as InternalServerException
                case "validationException":
                    return try decoder.decode(responseBody: message.payload) as ValidationException
                case "resourceNotFoundException":
                    return try decoder.decode(responseBody: message.payload) as ResourceNotFoundException
                case "serviceQuotaExceededException":
                    return try decoder.decode(responseBody: message.payload) as ServiceQuotaExceededException
                case "throttlingException":
                    return try decoder.decode(responseBody: message.payload) as ThrottlingException
                case "accessDeniedException":
                    return try decoder.decode(responseBody: message.payload) as AccessDeniedException
                case "conflictException":
                    return try decoder.decode(responseBody: message.payload) as ConflictException
                case "dependencyFailedException":
                    return try decoder.decode(responseBody: message.payload) as DependencyFailedException
                case "badGatewayException":
                    return try decoder.decode(responseBody: message.payload) as BadGatewayException
                default:
                    let httpResponse = HttpResponse(body: .data(message.payload), statusCode: .ok)
                    return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                }
            }
            let error = try makeError(message, params)
            throw error
        case .error(let params):
            let httpResponse = HttpResponse(body: .data(message.payload), statusCode: .ok)
            throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
        case .unknown(messageType: let messageType):
            throw ClientRuntime.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
        }
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The response from invoking the agent and associated citations and trace information.
    public enum ResponseStream {
        /// Contains a part of an agent response and citations for it.
        case chunk(BedrockAgentRuntimeClientTypes.PayloadPart)
        /// Contains information about the agent and session, alongside the agent's reasoning process and results from calling actions and querying knowledge bases and metadata about the trace. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace events](https://docs.aws.amazon.com/bedrock/latest/userguide/trace-events.html).
        case trace(BedrockAgentRuntimeClientTypes.TracePart)
        /// Contains the parameters and information that the agent elicited from the customer to carry out an action. This information is returned to the system and can be used in your own setup for fulfilling the action.
        case returncontrol(BedrockAgentRuntimeClientTypes.ReturnControlPayload)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.RetrievalFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case andall = "andAll"
        case equals
        case greaterthan = "greaterThan"
        case greaterthanorequals = "greaterThanOrEquals"
        case `in` = "in"
        case lessthan = "lessThan"
        case lessthanorequals = "lessThanOrEquals"
        case notequals = "notEquals"
        case notin = "notIn"
        case orall = "orAll"
        case sdkUnknown
        case startswith = "startsWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .andall(andall):
                var andallContainer = container.nestedUnkeyedContainer(forKey: .andall)
                for retrievalfilter0 in andall {
                    try andallContainer.encode(retrievalfilter0)
                }
            case let .equals(equals):
                try container.encode(equals, forKey: .equals)
            case let .greaterthan(greaterthan):
                try container.encode(greaterthan, forKey: .greaterthan)
            case let .greaterthanorequals(greaterthanorequals):
                try container.encode(greaterthanorequals, forKey: .greaterthanorequals)
            case let .`in`(`in`):
                try container.encode(`in`, forKey: .`in`)
            case let .lessthan(lessthan):
                try container.encode(lessthan, forKey: .lessthan)
            case let .lessthanorequals(lessthanorequals):
                try container.encode(lessthanorequals, forKey: .lessthanorequals)
            case let .notequals(notequals):
                try container.encode(notequals, forKey: .notequals)
            case let .notin(notin):
                try container.encode(notin, forKey: .notin)
            case let .orall(orall):
                var orallContainer = container.nestedUnkeyedContainer(forKey: .orall)
                for retrievalfilter0 in orall {
                    try orallContainer.encode(retrievalfilter0)
                }
            case let .startswith(startswith):
                try container.encode(startswith, forKey: .startswith)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let equalsDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.FilterAttribute.self, forKey: .equals)
        if let equals = equalsDecoded {
            self = .equals(equals)
            return
        }
        let notequalsDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.FilterAttribute.self, forKey: .notequals)
        if let notequals = notequalsDecoded {
            self = .notequals(notequals)
            return
        }
        let greaterthanDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.FilterAttribute.self, forKey: .greaterthan)
        if let greaterthan = greaterthanDecoded {
            self = .greaterthan(greaterthan)
            return
        }
        let greaterthanorequalsDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.FilterAttribute.self, forKey: .greaterthanorequals)
        if let greaterthanorequals = greaterthanorequalsDecoded {
            self = .greaterthanorequals(greaterthanorequals)
            return
        }
        let lessthanDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.FilterAttribute.self, forKey: .lessthan)
        if let lessthan = lessthanDecoded {
            self = .lessthan(lessthan)
            return
        }
        let lessthanorequalsDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.FilterAttribute.self, forKey: .lessthanorequals)
        if let lessthanorequals = lessthanorequalsDecoded {
            self = .lessthanorequals(lessthanorequals)
            return
        }
        let inDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.FilterAttribute.self, forKey: .in)
        if let `in` = inDecoded {
            self = .`in`(`in`)
            return
        }
        let notinDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.FilterAttribute.self, forKey: .notin)
        if let notin = notinDecoded {
            self = .notin(notin)
            return
        }
        let startswithDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.FilterAttribute.self, forKey: .startswith)
        if let startswith = startswithDecoded {
            self = .startswith(startswith)
            return
        }
        let andallContainer = try values.decodeIfPresent([BedrockAgentRuntimeClientTypes.RetrievalFilter?].self, forKey: .andall)
        var andallDecoded0:[BedrockAgentRuntimeClientTypes.RetrievalFilter]? = nil
        if let andallContainer = andallContainer {
            andallDecoded0 = [BedrockAgentRuntimeClientTypes.RetrievalFilter]()
            for union0 in andallContainer {
                if let union0 = union0 {
                    andallDecoded0?.append(union0)
                }
            }
        }
        if let andall = andallDecoded0 {
            self = .andall(andall)
            return
        }
        let orallContainer = try values.decodeIfPresent([BedrockAgentRuntimeClientTypes.RetrievalFilter?].self, forKey: .orall)
        var orallDecoded0:[BedrockAgentRuntimeClientTypes.RetrievalFilter]? = nil
        if let orallContainer = orallContainer {
            orallDecoded0 = [BedrockAgentRuntimeClientTypes.RetrievalFilter]()
            for union0 in orallContainer {
                if let union0 = union0 {
                    orallDecoded0?.append(union0)
                }
            }
        }
        if let orall = orallDecoded0 {
            self = .orall(orall)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Specifies the filters to use on the metadata attributes in the knowledge base data sources before returning results. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html). This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax) – in the filter field
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the filter field
    public indirect enum RetrievalFilter {
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value matches the value in this object are returned.
        case equals(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value doesn't match the value in this object are returned.
        case notequals(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value is greater than the value in this object are returned.
        case greaterthan(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value is greater than or equal to the value in this object are returned.
        case greaterthanorequals(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value is less than the value in this object are returned.
        case lessthan(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value is less than or equal to the value in this object are returned.
        case lessthanorequals(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value is in the list specified in the value in this object are returned.
        case `in`(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value isn't in the list specified in the value in this object are returned.
        case notin(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value starts with the value in this object are returned. This filter is currently only supported for Amazon OpenSearch Serverless vector stores.
        case startswith(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources whose metadata attributes fulfill all the filter conditions inside this list are returned.
        case andall([BedrockAgentRuntimeClientTypes.RetrievalFilter])
        /// Knowledge base data sources whose metadata attributes fulfill at least one of the filter conditions inside this list are returned.
        case orall([BedrockAgentRuntimeClientTypes.RetrievalFilter])
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.RetrievalResultContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the cited text from the data source. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the content field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the content field
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the content field
    public struct RetrievalResultContent {
        /// The cited text from the data source.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RetrievalResultLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrievalResultLocationType.self, forKey: .type)
        type = typeDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrievalResultS3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the location of the data source. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the location field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the location field
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the locatino field
    public struct RetrievalResultLocation {
        /// Contains the S3 location of the data source.
        public var s3Location: BedrockAgentRuntimeClientTypes.RetrievalResultS3Location?
        /// The type of the location of the data source.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.RetrievalResultLocationType?

        public init(
            s3Location: BedrockAgentRuntimeClientTypes.RetrievalResultS3Location? = nil,
            type: BedrockAgentRuntimeClientTypes.RetrievalResultLocationType? = nil
        )
        {
            self.s3Location = s3Location
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes {
    public enum RetrievalResultLocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrievalResultLocationType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetrievalResultLocationType(rawValue: rawValue) ?? RetrievalResultLocationType.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultS3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the S3 location of the data source. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the s3Location field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the s3Location field
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the s3Location field
    public struct RetrievalResultS3Location {
        /// The S3 URI of the data source.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseConfiguration
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let knowledgeBaseConfiguration = self.knowledgeBaseConfiguration {
            try encodeContainer.encode(knowledgeBaseConfiguration, forKey: .knowledgeBaseConfiguration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrieveAndGenerateType.self, forKey: .type)
        type = typeDecoded
        let knowledgeBaseConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration.self, forKey: .knowledgeBaseConfiguration)
        knowledgeBaseConfiguration = knowledgeBaseConfigurationDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the resource being queried. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the retrieveAndGenerateConfiguration field
    public struct RetrieveAndGenerateConfiguration {
        /// Contains details about the resource being queried.
        public var knowledgeBaseConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration?
        /// The type of resource that is queried by the request.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateType?

        public init(
            knowledgeBaseConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration? = nil,
            type: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateType? = nil
        )
        {
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension RetrieveAndGenerateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveAndGenerateInput(retrieveAndGenerateConfiguration: \(Swift.String(describing: retrieveAndGenerateConfiguration)), sessionConfiguration: \(Swift.String(describing: sessionConfiguration)), sessionId: \(Swift.String(describing: sessionId)), input: \"CONTENT_REDACTED\")"}
}

extension RetrieveAndGenerateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
        case retrieveAndGenerateConfiguration
        case sessionConfiguration
        case sessionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = self.input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let retrieveAndGenerateConfiguration = self.retrieveAndGenerateConfiguration {
            try encodeContainer.encode(retrieveAndGenerateConfiguration, forKey: .retrieveAndGenerateConfiguration)
        }
        if let sessionConfiguration = self.sessionConfiguration {
            try encodeContainer.encode(sessionConfiguration, forKey: .sessionConfiguration)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension RetrieveAndGenerateInput {

    static func urlPathProvider(_ value: RetrieveAndGenerateInput) -> Swift.String? {
        return "/retrieveAndGenerate"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the query made to the knowledge base. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the input field
    public struct RetrieveAndGenerateInput {
        /// The query made to the knowledge base.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

public struct RetrieveAndGenerateInput {
    /// Contains the query to be made to the knowledge base.
    /// This member is required.
    public var input: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput?
    /// Contains configurations for the knowledge base query and retrieval process. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
    public var retrieveAndGenerateConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration?
    /// Contains details about the session with the knowledge base.
    public var sessionConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration?
    /// The unique identifier of the session. Reuse the same value to continue the same session with the knowledge base.
    public var sessionId: Swift.String?

    public init(
        input: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput? = nil,
        retrieveAndGenerateConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration? = nil,
        sessionConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.input = input
        self.retrieveAndGenerateConfiguration = retrieveAndGenerateConfiguration
        self.sessionConfiguration = sessionConfiguration
        self.sessionId = sessionId
    }
}

struct RetrieveAndGenerateInputBody {
    let sessionId: Swift.String?
    let input: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput?
    let retrieveAndGenerateConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration?
    let sessionConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration?
}

extension RetrieveAndGenerateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
        case retrieveAndGenerateConfiguration
        case sessionConfiguration
        case sessionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let inputDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput.self, forKey: .input)
        input = inputDecoded
        let retrieveAndGenerateConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration.self, forKey: .retrieveAndGenerateConfiguration)
        retrieveAndGenerateConfiguration = retrieveAndGenerateConfigurationDecoded
        let sessionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration.self, forKey: .sessionConfiguration)
        sessionConfiguration = sessionConfigurationDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension RetrieveAndGenerateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveAndGenerateOutput(citations: \(Swift.String(describing: citations)), sessionId: \(Swift.String(describing: sessionId)), output: \"CONTENT_REDACTED\")"}
}

extension RetrieveAndGenerateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RetrieveAndGenerateOutputBody = try responseDecoder.decode(responseBody: data)
            self.citations = output.citations
            self.output = output.output
            self.sessionId = output.sessionId
        } else {
            self.citations = nil
            self.output = nil
            self.sessionId = nil
        }
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the response generated from querying the knowledge base. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the output field
    public struct RetrieveAndGenerateOutput {
        /// The response generated from querying the knowledge base.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

public struct RetrieveAndGenerateOutput {
    /// A list of segments of the generated response that are based on sources in the knowledge base, alongside information about the sources.
    public var citations: [BedrockAgentRuntimeClientTypes.Citation]?
    /// Contains the response generated from querying the knowledge base.
    /// This member is required.
    public var output: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput?
    /// The unique identifier of the session. Reuse the same value to continue the same session with the knowledge base.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        citations: [BedrockAgentRuntimeClientTypes.Citation]? = nil,
        output: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.citations = citations
        self.output = output
        self.sessionId = sessionId
    }
}

struct RetrieveAndGenerateOutputBody {
    let sessionId: Swift.String?
    let output: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput?
    let citations: [BedrockAgentRuntimeClientTypes.Citation]?
}

extension RetrieveAndGenerateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case citations
        case output
        case sessionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let outputDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput.self, forKey: .output)
        output = outputDecoded
        let citationsContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.Citation?].self, forKey: .citations)
        var citationsDecoded0:[BedrockAgentRuntimeClientTypes.Citation]? = nil
        if let citationsContainer = citationsContainer {
            citationsDecoded0 = [BedrockAgentRuntimeClientTypes.Citation]()
            for structure0 in citationsContainer {
                if let structure0 = structure0 {
                    citationsDecoded0?.append(structure0)
                }
            }
        }
        citations = citationsDecoded0
    }
}

enum RetrieveAndGenerateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadGatewayException": return try await BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyFailedException": return try await DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains configuration about the session with the knowledge base. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the sessionConfiguration field
    public struct RetrieveAndGenerateSessionConfiguration {
        /// The ARN of the KMS key encrypting the session.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension BedrockAgentRuntimeClientTypes {
    public enum RetrieveAndGenerateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrieveAndGenerateType] {
            return [
                .knowledgeBase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetrieveAndGenerateType(rawValue: rawValue) ?? RetrieveAndGenerateType.sdkUnknown(rawValue)
        }
    }
}

extension RetrieveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveInput(knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), nextToken: \(Swift.String(describing: nextToken)), retrievalConfiguration: \(Swift.String(describing: retrievalConfiguration)), retrievalQuery: \"CONTENT_REDACTED\")"}
}

extension RetrieveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case retrievalConfiguration
        case retrievalQuery
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let retrievalConfiguration = self.retrievalConfiguration {
            try encodeContainer.encode(retrievalConfiguration, forKey: .retrievalConfiguration)
        }
        if let retrievalQuery = self.retrievalQuery {
            try encodeContainer.encode(retrievalQuery, forKey: .retrievalQuery)
        }
    }
}

extension RetrieveInput {

    static func urlPathProvider(_ value: RetrieveInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/retrieve"
    }
}

public struct RetrieveInput {
    /// The unique identifier of the knowledge base to query.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// If there are more results than can fit in the response, the response returns a nextToken. Use this token in the nextToken field of another request to retrieve the next batch of results.
    public var nextToken: Swift.String?
    /// Contains configurations for the knowledge base query and retrieval process. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
    public var retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration?
    /// Contains the query to send the knowledge base.
    /// This member is required.
    public var retrievalQuery: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration? = nil,
        retrievalQuery: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.nextToken = nextToken
        self.retrievalConfiguration = retrievalConfiguration
        self.retrievalQuery = retrievalQuery
    }
}

struct RetrieveInputBody {
    let retrievalQuery: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery?
    let retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration?
    let nextToken: Swift.String?
}

extension RetrieveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case retrievalConfiguration
        case retrievalQuery
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retrievalQueryDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery.self, forKey: .retrievalQuery)
        retrievalQuery = retrievalQueryDecoded
        let retrievalConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration.self, forKey: .retrievalConfiguration)
        retrievalConfiguration = retrievalConfigurationDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension RetrieveOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveOutput(nextToken: \(Swift.String(describing: nextToken)), retrievalResults: \"CONTENT_REDACTED\")"}
}

extension RetrieveOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RetrieveOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.retrievalResults = output.retrievalResults
        } else {
            self.nextToken = nil
            self.retrievalResults = nil
        }
    }
}

public struct RetrieveOutput {
    /// If there are more results than can fit in the response, the response returns a nextToken. Use this token in the nextToken field of another request to retrieve the next batch of results.
    public var nextToken: Swift.String?
    /// A list of results from querying the knowledge base.
    /// This member is required.
    public var retrievalResults: [BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]?

    public init(
        nextToken: Swift.String? = nil,
        retrievalResults: [BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]? = nil
    )
    {
        self.nextToken = nextToken
        self.retrievalResults = retrievalResults
    }
}

struct RetrieveOutputBody {
    let retrievalResults: [BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]?
    let nextToken: Swift.String?
}

extension RetrieveOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case retrievalResults
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retrievalResultsContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult?].self, forKey: .retrievalResults)
        var retrievalResultsDecoded0:[BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]? = nil
        if let retrievalResultsContainer = retrievalResultsContainer {
            retrievalResultsDecoded0 = [BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]()
            for structure0 in retrievalResultsContainer {
                if let structure0 = structure0 {
                    retrievalResultsDecoded0?.append(structure0)
                }
            }
        }
        retrievalResults = retrievalResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum RetrieveOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadGatewayException": return try await BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyFailedException": return try await DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievedReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case location
        case metadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, retrievalResultMetadata0) in metadata {
                try metadataContainer.encode(retrievalResultMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrievalResultContent.self, forKey: .content)
        content = contentDecoded
        let locationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrievalResultLocation.self, forKey: .location)
        location = locationDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: ClientRuntime.Document?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:ClientRuntime.Document]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:ClientRuntime.Document]()
            for (key0, retrievalresultmetadatavalue0) in metadataContainer {
                if let retrievalresultmetadatavalue0 = retrievalresultmetadatavalue0 {
                    metadataDecoded0?[key0] = retrievalresultmetadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievedReference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrievedReference(content: \"CONTENT_REDACTED\", location: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains metadata about a source cited for the generated response. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the retrievedReferences field
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the retrievedReferences field
    public struct RetrievedReference {
        /// Contains the cited text from the data source.
        public var content: BedrockAgentRuntimeClientTypes.RetrievalResultContent?
        /// Contains information about the location of the data source.
        public var location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation?
        /// Contains metadata attributes and their values for the file in the data source. For more information, see [Metadata and filtering](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-ds.html#kb-ds-metadata).
        public var metadata: [Swift.String:ClientRuntime.Document]?

        public init(
            content: BedrockAgentRuntimeClientTypes.RetrievalResultContent? = nil,
            location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation? = nil,
            metadata: [Swift.String:ClientRuntime.Document]? = nil
        )
        {
            self.content = content
            self.location = location
            self.metadata = metadata
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ReturnControlPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invocationId
        case invocationInputs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invocationId = self.invocationId {
            try encodeContainer.encode(invocationId, forKey: .invocationId)
        }
        if let invocationInputs = invocationInputs {
            var invocationInputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .invocationInputs)
            for invocationinputmember0 in invocationInputs {
                try invocationInputsContainer.encode(invocationinputmember0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invocationInputsContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.InvocationInputMember?].self, forKey: .invocationInputs)
        var invocationInputsDecoded0:[BedrockAgentRuntimeClientTypes.InvocationInputMember]? = nil
        if let invocationInputsContainer = invocationInputsContainer {
            invocationInputsDecoded0 = [BedrockAgentRuntimeClientTypes.InvocationInputMember]()
            for union0 in invocationInputsContainer {
                if let union0 = union0 {
                    invocationInputsDecoded0?.append(union0)
                }
            }
        }
        invocationInputs = invocationInputsDecoded0
        let invocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationId)
        invocationId = invocationIdDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.ReturnControlPayload: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information to return from the action group that the agent has predicted to invoke. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax)
    public struct ReturnControlPayload {
        /// The identifier of the action group invocation.
        public var invocationId: Swift.String?
        /// A list of objects that contain information about the parameters and inputs that need to be sent into the API operation or function, based on what the agent determines from its session with the user.
        public var invocationInputs: [BedrockAgentRuntimeClientTypes.InvocationInputMember]?

        public init(
            invocationId: Swift.String? = nil,
            invocationInputs: [BedrockAgentRuntimeClientTypes.InvocationInputMember]? = nil
        )
        {
            self.invocationId = invocationId
            self.invocationInputs = invocationInputs
        }
    }

}

extension BedrockAgentRuntimeClientTypes {
    public enum SearchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hybrid
        case semantic
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchType] {
            return [
                .hybrid,
                .semantic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hybrid: return "HYBRID"
            case .semantic: return "SEMANTIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchType(rawValue: rawValue) ?? SearchType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of requests exceeds the service quota. Resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.SessionState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invocationId
        case promptSessionAttributes
        case returnControlInvocationResults
        case sessionAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invocationId = self.invocationId {
            try encodeContainer.encode(invocationId, forKey: .invocationId)
        }
        if let promptSessionAttributes = promptSessionAttributes {
            var promptSessionAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .promptSessionAttributes)
            for (dictKey0, promptSessionAttributesMap0) in promptSessionAttributes {
                try promptSessionAttributesContainer.encode(promptSessionAttributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let returnControlInvocationResults = returnControlInvocationResults {
            var returnControlInvocationResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .returnControlInvocationResults)
            for invocationresultmember0 in returnControlInvocationResults {
                try returnControlInvocationResultsContainer.encode(invocationresultmember0)
            }
        }
        if let sessionAttributes = sessionAttributes {
            var sessionAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sessionAttributes)
            for (dictKey0, sessionAttributesMap0) in sessionAttributes {
                try sessionAttributesContainer.encode(sessionAttributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let promptSessionAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .promptSessionAttributes)
        var promptSessionAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let promptSessionAttributesContainer = promptSessionAttributesContainer {
            promptSessionAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in promptSessionAttributesContainer {
                if let string0 = string0 {
                    promptSessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        promptSessionAttributes = promptSessionAttributesDecoded0
        let returnControlInvocationResultsContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.InvocationResultMember?].self, forKey: .returnControlInvocationResults)
        var returnControlInvocationResultsDecoded0:[BedrockAgentRuntimeClientTypes.InvocationResultMember]? = nil
        if let returnControlInvocationResultsContainer = returnControlInvocationResultsContainer {
            returnControlInvocationResultsDecoded0 = [BedrockAgentRuntimeClientTypes.InvocationResultMember]()
            for union0 in returnControlInvocationResultsContainer {
                if let union0 = union0 {
                    returnControlInvocationResultsDecoded0?.append(union0)
                }
            }
        }
        returnControlInvocationResults = returnControlInvocationResultsDecoded0
        let invocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationId)
        invocationId = invocationIdDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains parameters that specify various attributes that persist across a session or prompt. You can define session state attributes as key-value pairs when writing a [Lambda function](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-lambda.html) for an action group or pass them when making an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request. Use session state attributes to control and provide conversational context for your agent and to help customize your agent's behavior. For more information, see [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html).
    public struct SessionState {
        /// The identifier of the invocation.
        public var invocationId: Swift.String?
        /// Contains attributes that persist across a prompt and the values of those attributes. These attributes replace the $prompt_session_attributes$ placeholder variable in the orchestration prompt template. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        public var promptSessionAttributes: [Swift.String:Swift.String]?
        /// Contains information about the results from the action group invocation.
        public var returnControlInvocationResults: [BedrockAgentRuntimeClientTypes.InvocationResultMember]?
        /// Contains attributes that persist across a session and the values of those attributes.
        public var sessionAttributes: [Swift.String:Swift.String]?

        public init(
            invocationId: Swift.String? = nil,
            promptSessionAttributes: [Swift.String:Swift.String]? = nil,
            returnControlInvocationResults: [BedrockAgentRuntimeClientTypes.InvocationResultMember]? = nil,
            sessionAttributes: [Swift.String:Swift.String]? = nil
        )
        {
            self.invocationId = invocationId
            self.promptSessionAttributes = promptSessionAttributes
            self.returnControlInvocationResults = returnControlInvocationResults
            self.sessionAttributes = sessionAttributes
        }
    }

}

extension BedrockAgentRuntimeClientTypes {
    public enum Source: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionGroup
        case knowledgeBase
        case parser
        case sdkUnknown(Swift.String)

        public static var allCases: [Source] {
            return [
                .actionGroup,
                .knowledgeBase,
                .parser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionGroup: return "ACTION_GROUP"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case .parser: return "PARSER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Source(rawValue: rawValue) ?? Source.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.Span: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end
        case start
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = self.end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = self.start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .end)
        end = endDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about where the text with a citation begins and ends in the generated output. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the span field
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the span field
    public struct Span {
        /// Where the text with a citation ends in the generated output.
        public var end: Swift.Int?
        /// Where the text with a citation starts in the generated output.
        public var start: Swift.Int?

        public init(
            end: Swift.Int? = nil,
            start: Swift.Int? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension BedrockAgentRuntimeClientTypes.TextResponsePart: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case span
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let span = self.span {
            try encodeContainer.encode(span, forKey: .span)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let spanDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.Span.self, forKey: .span)
        span = spanDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.TextResponsePart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the part of the generated text that contains a citation, alongside where it begins and ends. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the textResponsePart field
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the textResponsePart field
    public struct TextResponsePart {
        /// Contains information about where the text with a citation begins and ends in the generated output.
        public var span: BedrockAgentRuntimeClientTypes.Span?
        /// The part of the generated text that contains a citation.
        public var text: Swift.String?

        public init(
            span: BedrockAgentRuntimeClientTypes.Span? = nil,
            text: Swift.String? = nil
        )
        {
            self.span = span
            self.text = text
        }
    }

}

extension ThrottlingException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of requests exceeds the limit. Resubmit your request later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.Trace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failuretrace = "failureTrace"
        case orchestrationtrace = "orchestrationTrace"
        case postprocessingtrace = "postProcessingTrace"
        case preprocessingtrace = "preProcessingTrace"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .failuretrace(failuretrace):
                try container.encode(failuretrace, forKey: .failuretrace)
            case let .orchestrationtrace(orchestrationtrace):
                try container.encode(orchestrationtrace, forKey: .orchestrationtrace)
            case let .postprocessingtrace(postprocessingtrace):
                try container.encode(postprocessingtrace, forKey: .postprocessingtrace)
            case let .preprocessingtrace(preprocessingtrace):
                try container.encode(preprocessingtrace, forKey: .preprocessingtrace)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let preprocessingtraceDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.PreProcessingTrace.self, forKey: .preprocessingtrace)
        if let preprocessingtrace = preprocessingtraceDecoded {
            self = .preprocessingtrace(preprocessingtrace)
            return
        }
        let orchestrationtraceDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.OrchestrationTrace.self, forKey: .orchestrationtrace)
        if let orchestrationtrace = orchestrationtraceDecoded {
            self = .orchestrationtrace(orchestrationtrace)
            return
        }
        let postprocessingtraceDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.PostProcessingTrace.self, forKey: .postprocessingtrace)
        if let postprocessingtrace = postprocessingtraceDecoded {
            self = .postprocessingtrace(postprocessingtrace)
            return
        }
        let failuretraceDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.FailureTrace.self, forKey: .failuretrace)
        if let failuretrace = failuretraceDecoded {
            self = .failuretrace(failuretrace)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains one part of the agent's reasoning process and results from calling API actions and querying knowledge bases. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-enablement).
    public enum Trace {
        /// Details about the pre-processing step, in which the agent contextualizes and categorizes user inputs.
        case preprocessingtrace(BedrockAgentRuntimeClientTypes.PreProcessingTrace)
        /// Details about the orchestration step, in which the agent determines the order in which actions are executed and which knowledge bases are retrieved.
        case orchestrationtrace(BedrockAgentRuntimeClientTypes.OrchestrationTrace)
        /// Details about the post-processing step, in which the agent shapes the response..
        case postprocessingtrace(BedrockAgentRuntimeClientTypes.PostProcessingTrace)
        /// Contains information about the failure of the interaction.
        case failuretrace(BedrockAgentRuntimeClientTypes.FailureTrace)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.TracePart: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasId
        case agentId
        case agentVersion
        case sessionId
        case trace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentAliasId = self.agentAliasId {
            try encodeContainer.encode(agentAliasId, forKey: .agentAliasId)
        }
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let trace = self.trace {
            try encodeContainer.encode(trace, forKey: .trace)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasId)
        agentAliasId = agentAliasIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let traceDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.Trace.self, forKey: .trace)
        trace = traceDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.TracePart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the agent and session, alongside the agent's reasoning process and results from calling API actions and querying knowledge bases and metadata about the trace. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-enablement).
    public struct TracePart {
        /// The unique identifier of the alias of the agent.
        public var agentAliasId: Swift.String?
        /// The unique identifier of the agent.
        public var agentId: Swift.String?
        /// The version of the agent.
        public var agentVersion: Swift.String?
        /// The unique identifier of the session with the agent.
        public var sessionId: Swift.String?
        /// Contains one part of the agent's reasoning process and results from calling API actions and querying knowledge bases. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-enablement).
        public var trace: BedrockAgentRuntimeClientTypes.Trace?

        public init(
            agentAliasId: Swift.String? = nil,
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            trace: BedrockAgentRuntimeClientTypes.Trace? = nil
        )
        {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.sessionId = sessionId
            self.trace = trace
        }
    }

}

extension BedrockAgentRuntimeClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionGroup
        case askUser
        case finish
        case knowledgeBase
        case reprompt
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .actionGroup,
                .askUser,
                .finish,
                .knowledgeBase,
                .reprompt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionGroup: return "ACTION_GROUP"
            case .askUser: return "ASK_USER"
            case .finish: return "FINISH"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case .reprompt: return "REPROMPT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
