// Code generated by smithy-swift-codegen. DO NOT EDIT!
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessDeniedException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

/// The request is denied because of missing access permissions. Check your permissions and retry your request.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionGroupInvocationInput(parameters: \(Swift.String(describing: parameters)), requestBody: \(Swift.String(describing: requestBody)), actionGroupName: \"CONTENT_REDACTED\", apiPath: \"CONTENT_REDACTED\", function: \"CONTENT_REDACTED\", verb: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput()
        value.actionGroupName = try reader["actionGroupName"].readIfPresent()
        value.verb = try reader["verb"].readIfPresent()
        value.apiPath = try reader["apiPath"].readIfPresent()
        value.parameters = try reader["parameters"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.Parameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestBody = try reader["requestBody"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RequestBody.read(from:))
        value.function = try reader["function"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the action group being invoked. For more information about the possible structures, see the InvocationInput tab in [OrchestrationTrace](https://docs.aws.amazon.com/bedrock/latest/userguide/trace-orchestration.html) in the Amazon Bedrock User Guide.
    public struct ActionGroupInvocationInput {
        /// The name of the action group.
        public var actionGroupName: Swift.String?
        /// The path to the API to call, based off the action group.
        public var apiPath: Swift.String?
        /// The function in the action group to call.
        public var function: Swift.String?
        /// The parameters in the Lambda input event.
        public var parameters: [BedrockAgentRuntimeClientTypes.Parameter]?
        /// The parameters in the request body for the Lambda input event.
        public var requestBody: BedrockAgentRuntimeClientTypes.RequestBody?
        /// The API method being used, based off the action group.
        public var verb: Swift.String?

        public init(
            actionGroupName: Swift.String? = nil,
            apiPath: Swift.String? = nil,
            function: Swift.String? = nil,
            parameters: [BedrockAgentRuntimeClientTypes.Parameter]? = nil,
            requestBody: BedrockAgentRuntimeClientTypes.RequestBody? = nil,
            verb: Swift.String? = nil
        )
        {
            self.actionGroupName = actionGroupName
            self.apiPath = apiPath
            self.function = function
            self.parameters = parameters
            self.requestBody = requestBody
            self.verb = verb
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionGroupInvocationOutput(text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the JSON-formatted string returned by the API invoked by the action group.
    public struct ActionGroupInvocationOutput {
        /// The JSON-formatted string returned by the API invoked by the action group.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ApiInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiInvocationInput(actionGroup: \(Swift.String(describing: actionGroup)), httpMethod: \(Swift.String(describing: httpMethod)), parameters: \(Swift.String(describing: parameters)), requestBody: \(Swift.String(describing: requestBody)), apiPath: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.ApiInvocationInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ApiInvocationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ApiInvocationInput()
        value.actionGroup = try reader["actionGroup"].readIfPresent()
        value.httpMethod = try reader["httpMethod"].readIfPresent()
        value.apiPath = try reader["apiPath"].readIfPresent()
        value.parameters = try reader["parameters"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.ApiParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestBody = try reader["requestBody"].readIfPresent(with: BedrockAgentRuntimeClientTypes.ApiRequestBody.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the API operation that the agent predicts should be called. This data type is used in the following API operations:
    ///
    /// * In the returnControl field of the [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public struct ApiInvocationInput {
        /// The action group that the API operation belongs to.
        /// This member is required.
        public var actionGroup: Swift.String?
        /// The path to the API operation.
        public var apiPath: Swift.String?
        /// The HTTP method of the API operation.
        public var httpMethod: Swift.String?
        /// The parameters to provide for the API request, as the agent elicited from the user.
        public var parameters: [BedrockAgentRuntimeClientTypes.ApiParameter]?
        /// The request body to provide for the API request, as the agent elicited from the user.
        public var requestBody: BedrockAgentRuntimeClientTypes.ApiRequestBody?

        public init(
            actionGroup: Swift.String? = nil,
            apiPath: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            parameters: [BedrockAgentRuntimeClientTypes.ApiParameter]? = nil,
            requestBody: BedrockAgentRuntimeClientTypes.ApiRequestBody? = nil
        )
        {
            self.actionGroup = actionGroup
            self.apiPath = apiPath
            self.httpMethod = httpMethod
            self.parameters = parameters
            self.requestBody = requestBody
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ApiParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ApiParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ApiParameter()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Information about a parameter to provide to the API request. This data type is used in the following API operations:
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public struct ApiParameter {
        /// The name of the parameter.
        public var name: Swift.String?
        /// The data type for the parameter.
        public var type: Swift.String?
        /// The value of the parameter.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ApiRequestBody {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ApiRequestBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ApiRequestBody()
        value.content = try reader["content"].readMapIfPresent(valueReadingClosure: BedrockAgentRuntimeClientTypes.PropertyParameters.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The request body to provide for the API request, as the agent elicited from the user. This data type is used in the following API operations:
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public struct ApiRequestBody {
        /// The content of the request body. The key of the object in this field is a media type defining the format of the request body.
        public var content: [Swift.String:BedrockAgentRuntimeClientTypes.PropertyParameters]?

        public init(
            content: [Swift.String:BedrockAgentRuntimeClientTypes.PropertyParameters]? = nil
        )
        {
            self.content = content
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ApiResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiResult(actionGroup: \(Swift.String(describing: actionGroup)), httpMethod: \(Swift.String(describing: httpMethod)), httpStatusCode: \(Swift.String(describing: httpStatusCode)), responseBody: \(Swift.String(describing: responseBody)), responseState: \(Swift.String(describing: responseState)), apiPath: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.ApiResult {

    static func write(value: BedrockAgentRuntimeClientTypes.ApiResult?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionGroup"].write(value.actionGroup)
        try writer["apiPath"].write(value.apiPath)
        try writer["httpMethod"].write(value.httpMethod)
        try writer["httpStatusCode"].write(value.httpStatusCode)
        try writer["responseBody"].writeMap(value.responseBody, valueWritingClosure: BedrockAgentRuntimeClientTypes.ContentBody.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseState"].write(value.responseState)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the API operation that was called from the action group and the response body that was returned. This data type is used in the following API operations:
    ///
    /// * In the returnControlInvocationResults of the [InvokeAgent request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_RequestSyntax)
    public struct ApiResult {
        /// The action group that the API operation belongs to.
        /// This member is required.
        public var actionGroup: Swift.String?
        /// The path to the API operation.
        public var apiPath: Swift.String?
        /// The HTTP method for the API operation.
        public var httpMethod: Swift.String?
        /// http status code from API execution response (for example: 200, 400, 500).
        public var httpStatusCode: Swift.Int?
        /// The response body from the API operation. The key of the object is the content type (currently, only TEXT is supported). The response may be returned directly or from the Lambda function.
        public var responseBody: [Swift.String:BedrockAgentRuntimeClientTypes.ContentBody]?
        /// Controls the final response state returned to end user when API/Function execution failed. When this state is FAILURE, the request would fail with dependency failure exception. When this state is REPROMPT, the API/function response will be sent to model for re-prompt
        public var responseState: BedrockAgentRuntimeClientTypes.ResponseState?

        public init(
            actionGroup: Swift.String? = nil,
            apiPath: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            httpStatusCode: Swift.Int? = nil,
            responseBody: [Swift.String:BedrockAgentRuntimeClientTypes.ContentBody]? = nil,
            responseState: BedrockAgentRuntimeClientTypes.ResponseState? = nil
        )
        {
            self.actionGroup = actionGroup
            self.apiPath = apiPath
            self.httpMethod = httpMethod
            self.httpStatusCode = httpStatusCode
            self.responseBody = responseBody
            self.responseState = responseState
        }
    }

}

extension BedrockAgentRuntimeClientTypes.Attribution {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Attribution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Attribution()
        value.citations = try reader["citations"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.Citation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains citations for a part of an agent response.
    public struct Attribution {
        /// A list of citations and related information for a part of an agent response.
        public var citations: [BedrockAgentRuntimeClientTypes.Citation]?

        public init(
            citations: [BedrockAgentRuntimeClientTypes.Citation]? = nil
        )
        {
            self.citations = citations
        }
    }

}

extension BadGatewayException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadGatewayException {
        let reader = baseError.errorBodyReader
        var value = BadGatewayException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadGatewayException {

    static func read(from reader: SmithyJSON.Reader) throws -> BadGatewayException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BadGatewayException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        return value
    }
}

/// There was an issue with a dependency due to a server issue. Retry your request.
public struct BadGatewayException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the dependency that caused the issue, such as Amazon Bedrock, Lambda, or STS.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadGatewayException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

public enum BedrockAgentRuntimeClientTypes {}

extension BedrockAgentRuntimeClientTypes.ByteContentDoc: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ByteContentDoc(contentType: \(Swift.String(describing: contentType)), data: \"CONTENT_REDACTED\", identifier: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.ByteContentDoc {

    static func write(value: BedrockAgentRuntimeClientTypes.ByteContentDoc?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["data"].write(value.data)
        try writer["identifier"].write(value.identifier)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// This property contains the document to chat with, along with its attributes.
    public struct ByteContentDoc {
        /// The MIME type of the document contained in the wrapper object.
        /// This member is required.
        public var contentType: Swift.String?
        /// The byte value of the file to upload, encoded as a Base-64 string.
        /// This member is required.
        public var data: ClientRuntime.Data?
        /// The file name of the document contained in the wrapper object.
        /// This member is required.
        public var identifier: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            data: ClientRuntime.Data? = nil,
            identifier: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.data = data
            self.identifier = identifier
        }
    }

}

extension BedrockAgentRuntimeClientTypes.Citation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Citation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Citation()
        value.generatedResponsePart = try reader["generatedResponsePart"].readIfPresent(with: BedrockAgentRuntimeClientTypes.GeneratedResponsePart.read(from:))
        value.retrievedReferences = try reader["retrievedReferences"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.RetrievedReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// An object containing a segment of the generated response that is based on a source in the knowledge base, alongside information about the source. This data type is used in the following API operations:
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax) – in the citations field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the citations field
    public struct Citation {
        /// Contains the generated response and metadata
        public var generatedResponsePart: BedrockAgentRuntimeClientTypes.GeneratedResponsePart?
        /// Contains metadata about the sources cited for the generated response.
        public var retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]?

        public init(
            generatedResponsePart: BedrockAgentRuntimeClientTypes.GeneratedResponsePart? = nil,
            retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]? = nil
        )
        {
            self.generatedResponsePart = generatedResponsePart
            self.retrievedReferences = retrievedReferences
        }
    }

}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func read(from reader: SmithyJSON.Reader) throws -> ConflictException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

/// There was a conflict performing an operation. Resolve the conflict and retry your request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockAgentRuntimeClientTypes.ContentBody {

    static func write(value: BedrockAgentRuntimeClientTypes.ContentBody?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the body of the API response. This data type is used in the following API operations:
    ///
    /// * In the returnControlInvocationResults field of the [InvokeAgent request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_RequestSyntax)
    public struct ContentBody {
        /// The body of the API response.
        public var body: Swift.String?

        public init(
            body: Swift.String? = nil
        )
        {
            self.body = body
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum CreationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case overridden
        case sdkUnknown(Swift.String)

        public static var allCases: [CreationMode] {
            return [
                .default,
                .overridden,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .overridden: return "OVERRIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DependencyFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DependencyFailedException {
        let reader = baseError.errorBodyReader
        var value = DependencyFailedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DependencyFailedException {

    static func read(from reader: SmithyJSON.Reader) throws -> DependencyFailedException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DependencyFailedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        return value
    }
}

/// There was an issue with a dependency. Check the resource configurations and retry the request.
public struct DependencyFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the dependency that caused the issue, such as Amazon Bedrock, Lambda, or STS.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

extension BedrockAgentRuntimeClientTypes.ExternalSource {

    static func write(value: BedrockAgentRuntimeClientTypes.ExternalSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["byteContent"].write(value.byteContent, with: BedrockAgentRuntimeClientTypes.ByteContentDoc.write(value:to:))
        try writer["s3Location"].write(value.s3Location, with: BedrockAgentRuntimeClientTypes.S3ObjectDoc.write(value:to:))
        try writer["sourceType"].write(value.sourceType)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The unique external source of the content contained in the wrapper object.
    public struct ExternalSource {
        /// The identifier, contentType, and data of the external source wrapper object.
        public var byteContent: BedrockAgentRuntimeClientTypes.ByteContentDoc?
        /// The S3 location of the external source wrapper object.
        public var s3Location: BedrockAgentRuntimeClientTypes.S3ObjectDoc?
        /// The source type of the external source wrapper object.
        /// This member is required.
        public var sourceType: BedrockAgentRuntimeClientTypes.ExternalSourceType?

        public init(
            byteContent: BedrockAgentRuntimeClientTypes.ByteContentDoc? = nil,
            s3Location: BedrockAgentRuntimeClientTypes.S3ObjectDoc? = nil,
            sourceType: BedrockAgentRuntimeClientTypes.ExternalSourceType? = nil
        )
        {
            self.byteContent = byteContent
            self.s3Location = s3Location
            self.sourceType = sourceType
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum ExternalSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case byteContent
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalSourceType] {
            return [
                .byteContent,
                .s3,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .byteContent: return "BYTE_CONTENT"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ExternalSourcesGenerationConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.ExternalSourcesGenerationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].writeMap(value.additionalModelRequestFields, valueWritingClosure: SmithyReadWrite.Document.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockAgentRuntimeClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["inferenceConfig"].write(value.inferenceConfig, with: BedrockAgentRuntimeClientTypes.InferenceConfig.write(value:to:))
        try writer["promptTemplate"].write(value.promptTemplate, with: BedrockAgentRuntimeClientTypes.PromptTemplate.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the generation configuration of the external source wrapper object.
    public struct ExternalSourcesGenerationConfiguration {
        /// Additional model parameters and their corresponding values not included in the textInferenceConfig structure for an external source. Takes in custom model parameters specific to the language model being used.
        public var additionalModelRequestFields: [Swift.String:SmithyReadWrite.Document]?
        /// The configuration details for the guardrail.
        public var guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfiguration?
        /// Configuration settings for inference when using RetrieveAndGenerate to generate responses while using an external source.
        public var inferenceConfig: BedrockAgentRuntimeClientTypes.InferenceConfig?
        /// Contain the textPromptTemplate string for the external source wrapper object.
        public var promptTemplate: BedrockAgentRuntimeClientTypes.PromptTemplate?

        public init(
            additionalModelRequestFields: [Swift.String:SmithyReadWrite.Document]? = nil,
            guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfiguration? = nil,
            inferenceConfig: BedrockAgentRuntimeClientTypes.InferenceConfig? = nil,
            promptTemplate: BedrockAgentRuntimeClientTypes.PromptTemplate? = nil
        )
        {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.inferenceConfig = inferenceConfig
            self.promptTemplate = promptTemplate
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["generationConfiguration"].write(value.generationConfiguration, with: BedrockAgentRuntimeClientTypes.ExternalSourcesGenerationConfiguration.write(value:to:))
        try writer["modelArn"].write(value.modelArn)
        try writer["sources"].writeList(value.sources, memberWritingClosure: BedrockAgentRuntimeClientTypes.ExternalSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The configurations of the external source wrapper object in the retrieveAndGenerate function.
    public struct ExternalSourcesRetrieveAndGenerateConfiguration {
        /// The prompt used with the external source wrapper object with the retrieveAndGenerate function.
        public var generationConfiguration: BedrockAgentRuntimeClientTypes.ExternalSourcesGenerationConfiguration?
        /// The modelArn used with the external source wrapper object in the retrieveAndGenerate function.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The document used with the external source wrapper object in the retrieveAndGenerate function.
        /// This member is required.
        public var sources: [BedrockAgentRuntimeClientTypes.ExternalSource]?

        public init(
            generationConfiguration: BedrockAgentRuntimeClientTypes.ExternalSourcesGenerationConfiguration? = nil,
            modelArn: Swift.String? = nil,
            sources: [BedrockAgentRuntimeClientTypes.ExternalSource]? = nil
        )
        {
            self.generationConfiguration = generationConfiguration
            self.modelArn = modelArn
            self.sources = sources
        }
    }

}

extension BedrockAgentRuntimeClientTypes.FailureTrace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.FailureTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FailureTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FailureTrace()
        value.traceId = try reader["traceId"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the failure of the interaction.
    public struct FailureTrace {
        /// The reason the interaction failed.
        public var failureReason: Swift.String?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            failureReason: Swift.String? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.failureReason = failureReason
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.FilterAttribute {

    static func write(value: BedrockAgentRuntimeClientTypes.FilterAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Specifies the name that the metadata attribute must match and the value to which to compare the value of the metadata attribute. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html). This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)
    public struct FilterAttribute {
        /// The name that the metadata attribute must match.
        /// This member is required.
        public var key: Swift.String?
        /// The value to whcih to compare the value of the metadata attribute.
        /// This member is required.
        public var value: SmithyReadWrite.Document?

        public init(
            key: Swift.String? = nil,
            value: SmithyReadWrite.Document? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension BedrockAgentRuntimeClientTypes.FinalResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FinalResponse(text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.FinalResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FinalResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FinalResponse()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the response to the user.
    public struct FinalResponse {
        /// The text in the response to the user.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.FunctionInvocationInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FunctionInvocationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FunctionInvocationInput()
        value.actionGroup = try reader["actionGroup"].readIfPresent()
        value.parameters = try reader["parameters"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.FunctionParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.function = try reader["function"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the function that the agent predicts should be called. This data type is used in the following API operations:
    ///
    /// * In the returnControl field of the [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public struct FunctionInvocationInput {
        /// The action group that the function belongs to.
        /// This member is required.
        public var actionGroup: Swift.String?
        /// The name of the function.
        public var function: Swift.String?
        /// A list of parameters of the function.
        public var parameters: [BedrockAgentRuntimeClientTypes.FunctionParameter]?

        public init(
            actionGroup: Swift.String? = nil,
            function: Swift.String? = nil,
            parameters: [BedrockAgentRuntimeClientTypes.FunctionParameter]? = nil
        )
        {
            self.actionGroup = actionGroup
            self.function = function
            self.parameters = parameters
        }
    }

}

extension BedrockAgentRuntimeClientTypes.FunctionParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FunctionParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FunctionParameter()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about a parameter of the function. This data type is used in the following API operations:
    ///
    /// * In the returnControl field of the [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public struct FunctionParameter {
        /// The name of the parameter.
        public var name: Swift.String?
        /// The data type of the parameter.
        public var type: Swift.String?
        /// The value of the parameter.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension BedrockAgentRuntimeClientTypes.FunctionResult {

    static func write(value: BedrockAgentRuntimeClientTypes.FunctionResult?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionGroup"].write(value.actionGroup)
        try writer["function"].write(value.function)
        try writer["responseBody"].writeMap(value.responseBody, valueWritingClosure: BedrockAgentRuntimeClientTypes.ContentBody.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseState"].write(value.responseState)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the function that was called from the action group and the response that was returned. This data type is used in the following API operations:
    ///
    /// * In the returnControlInvocationResults of the [InvokeAgent request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_RequestSyntax)
    public struct FunctionResult {
        /// The action group that the function belongs to.
        /// This member is required.
        public var actionGroup: Swift.String?
        /// The name of the function that was called.
        public var function: Swift.String?
        /// The response from the function call using the parameters. The key of the object is the content type (currently, only TEXT is supported). The response may be returned directly or from the Lambda function.
        public var responseBody: [Swift.String:BedrockAgentRuntimeClientTypes.ContentBody]?
        /// Controls the final response state returned to end user when API/Function execution failed. When this state is FAILURE, the request would fail with dependency failure exception. When this state is REPROMPT, the API/function response will be sent to model for re-prompt
        public var responseState: BedrockAgentRuntimeClientTypes.ResponseState?

        public init(
            actionGroup: Swift.String? = nil,
            function: Swift.String? = nil,
            responseBody: [Swift.String:BedrockAgentRuntimeClientTypes.ContentBody]? = nil,
            responseState: BedrockAgentRuntimeClientTypes.ResponseState? = nil
        )
        {
            self.actionGroup = actionGroup
            self.function = function
            self.responseBody = responseBody
            self.responseState = responseState
        }
    }

}

extension BedrockAgentRuntimeClientTypes.GeneratedResponsePart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeneratedResponsePart(textResponsePart: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.GeneratedResponsePart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GeneratedResponsePart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GeneratedResponsePart()
        value.textResponsePart = try reader["textResponsePart"].readIfPresent(with: BedrockAgentRuntimeClientTypes.TextResponsePart.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains metadata about a part of the generated response that is accompanied by a citation. This data type is used in the following API operations:
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax) – in the generatedResponsePart field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the generatedResponsePart field
    public struct GeneratedResponsePart {
        /// Contains metadata about a textual part of the generated response that is accompanied by a citation.
        public var textResponsePart: BedrockAgentRuntimeClientTypes.TextResponsePart?

        public init(
            textResponsePart: BedrockAgentRuntimeClientTypes.TextResponsePart? = nil
        )
        {
            self.textResponsePart = textResponsePart
        }
    }

}

extension BedrockAgentRuntimeClientTypes.GenerationConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.GenerationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].writeMap(value.additionalModelRequestFields, valueWritingClosure: SmithyReadWrite.Document.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockAgentRuntimeClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["inferenceConfig"].write(value.inferenceConfig, with: BedrockAgentRuntimeClientTypes.InferenceConfig.write(value:to:))
        try writer["promptTemplate"].write(value.promptTemplate, with: BedrockAgentRuntimeClientTypes.PromptTemplate.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains configurations for response generation based on the knowledge base query results. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)
    public struct GenerationConfiguration {
        /// Additional model parameters and corresponding values not included in the textInferenceConfig structure for a knowledge base. This allows users to provide custom model parameters specific to the language model being used.
        public var additionalModelRequestFields: [Swift.String:SmithyReadWrite.Document]?
        /// The configuration details for the guardrail.
        public var guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfiguration?
        /// Configuration settings for inference when using RetrieveAndGenerate to generate responses while using a knowledge base as a source.
        public var inferenceConfig: BedrockAgentRuntimeClientTypes.InferenceConfig?
        /// Contains the template for the prompt that's sent to the model for response generation.
        public var promptTemplate: BedrockAgentRuntimeClientTypes.PromptTemplate?

        public init(
            additionalModelRequestFields: [Swift.String:SmithyReadWrite.Document]? = nil,
            guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfiguration? = nil,
            inferenceConfig: BedrockAgentRuntimeClientTypes.InferenceConfig? = nil,
            promptTemplate: BedrockAgentRuntimeClientTypes.PromptTemplate? = nil
        )
        {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.inferenceConfig = inferenceConfig
            self.promptTemplate = promptTemplate
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum GuadrailAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case intervened
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuadrailAction] {
            return [
                .intervened,
                .none,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .intervened: return "INTERVENED"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case intervened
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailAction] {
            return [
                .intervened,
                .none,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .intervened: return "INTERVENED"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailAssessment()
        value.topicPolicy = try reader["topicPolicy"].readIfPresent(with: BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment.read(from:))
        value.contentPolicy = try reader["contentPolicy"].readIfPresent(with: BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment.read(from:))
        value.wordPolicy = try reader["wordPolicy"].readIfPresent(with: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment.read(from:))
        value.sensitiveInformationPolicy = try reader["sensitiveInformationPolicy"].readIfPresent(with: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Assessment details of the content analyzed by Guardrails.
    public struct GuardrailAssessment {
        /// Content policy details of the Guardrail.
        public var contentPolicy: BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment?
        /// Sensitive Information policy details of Guardrail.
        public var sensitiveInformationPolicy: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment?
        /// Topic policy details of the Guardrail.
        public var topicPolicy: BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment?
        /// Word policy details of the Guardrail.
        public var wordPolicy: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment?

        public init(
            contentPolicy: BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment? = nil,
            sensitiveInformationPolicy: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment? = nil,
            topicPolicy: BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment? = nil,
            wordPolicy: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment? = nil
        )
        {
            self.contentPolicy = contentPolicy
            self.sensitiveInformationPolicy = sensitiveInformationPolicy
            self.topicPolicy = topicPolicy
            self.wordPolicy = wordPolicy
        }
    }

}

extension BedrockAgentRuntimeClientTypes.GuardrailConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.GuardrailConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["guardrailId"].write(value.guardrailId)
        try writer["guardrailVersion"].write(value.guardrailVersion)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The configuration details for the guardrail.
    public struct GuardrailConfiguration {
        /// The unique identifier for the guardrail.
        /// This member is required.
        public var guardrailId: Swift.String?
        /// The version of the guardrail.
        /// This member is required.
        public var guardrailVersion: Swift.String?

        public init(
            guardrailId: Swift.String? = nil,
            guardrailVersion: Swift.String? = nil
        )
        {
            self.guardrailId = guardrailId
            self.guardrailVersion = guardrailVersion
        }
    }

}

extension BedrockAgentRuntimeClientTypes.GuardrailContentFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailContentFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailContentFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailContentFilter()
        value.type = try reader["type"].readIfPresent()
        value.confidence = try reader["confidence"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Details of the content filter used in the Guardrail.
    public struct GuardrailContentFilter {
        /// The action placed on the content by the Guardrail filter.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAction?
        /// The confidence level regarding the content detected in the filter by the Guardrail.
        public var confidence: BedrockAgentRuntimeClientTypes.GuardrailContentFilterConfidence?
        /// The type of content detected in the filter by the Guardrail.
        public var type: BedrockAgentRuntimeClientTypes.GuardrailContentFilterType?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAction? = nil,
            confidence: BedrockAgentRuntimeClientTypes.GuardrailContentFilterConfidence? = nil,
            type: BedrockAgentRuntimeClientTypes.GuardrailContentFilterType? = nil
        )
        {
            self.action = action
            self.confidence = confidence
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailContentFilterConfidence: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFilterConfidence] {
            return [
                .high,
                .low,
                .medium,
                .none,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailContentFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hate
        case insults
        case misconduct
        case promptAttack
        case sexual
        case violence
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFilterType] {
            return [
                .hate,
                .insults,
                .misconduct,
                .promptAttack,
                .sexual,
                .violence,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hate: return "HATE"
            case .insults: return "INSULTS"
            case .misconduct: return "MISCONDUCT"
            case .promptAttack: return "PROMPT_ATTACK"
            case .sexual: return "SEXUAL"
            case .violence: return "VIOLENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailContentPolicyAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blocked
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentPolicyAction] {
            return [
                .blocked,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blocked: return "BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailContentFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The details of the policy assessment in the Guardrails filter.
    public struct GuardrailContentPolicyAssessment {
        /// The filter details of the policy assessment used in the Guardrails filter.
        public var filters: [BedrockAgentRuntimeClientTypes.GuardrailContentFilter]?

        public init(
            filters: [BedrockAgentRuntimeClientTypes.GuardrailContentFilter]? = nil
        )
        {
            self.filters = filters
        }
    }

}

extension BedrockAgentRuntimeClientTypes.GuardrailCustomWord: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailCustomWord {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailCustomWord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailCustomWord()
        value.match = try reader["match"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The custom word details for the filter in the Guardrail.
    public struct GuardrailCustomWord {
        /// The action details for the custom word filter in the Guardrail.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAction?
        /// The match details for the custom word filter in the Guardrail.
        public var match: Swift.String?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAction? = nil,
            match: Swift.String? = nil
        )
        {
            self.action = action
            self.match = match
        }
    }

}

extension BedrockAgentRuntimeClientTypes.GuardrailManagedWord: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailManagedWord {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailManagedWord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailManagedWord()
        value.match = try reader["match"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The managed word details for the filter in the Guardrail.
    public struct GuardrailManagedWord {
        /// The action details for the managed word filter in the Guardrail.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAction?
        /// The match details for the managed word filter in the Guardrail.
        public var match: Swift.String?
        /// The type details for the managed word filter in the Guardrail.
        public var type: BedrockAgentRuntimeClientTypes.GuardrailManagedWordType?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAction? = nil,
            match: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.GuardrailManagedWordType? = nil
        )
        {
            self.action = action
            self.match = match
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailManagedWordType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case profanity
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailManagedWordType] {
            return [
                .profanity,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .profanity: return "PROFANITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter()
        value.type = try reader["type"].readIfPresent()
        value.match = try reader["match"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The Guardrail filter to identify and remove personally identifiable information (PII).
    public struct GuardrailPiiEntityFilter {
        /// The action of the Guardrail filter to identify and remove PII.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAction?
        /// The match to settings in the Guardrail filter to identify and remove PII.
        public var match: Swift.String?
        /// The type of PII the Guardrail filter has identified and removed.
        public var type: BedrockAgentRuntimeClientTypes.GuardrailPiiEntityType?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAction? = nil,
            match: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.GuardrailPiiEntityType? = nil
        )
        {
            self.action = action
            self.match = match
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailPiiEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case address
        case age
        case awsAccessKey
        case awsSecretKey
        case caHealthNumber
        case caSocialInsuranceNumber
        case creditDebitCardCvv
        case creditDebitCardExpiry
        case creditDebitCardNumber
        case driverId
        case email
        case internationalBankAccountNumber
        case ipAddress
        case licensePlate
        case macAddress
        case name
        case password
        case phone
        case pin
        case swiftCode
        case ukNationalHealthServiceNumber
        case ukNationalInsuranceNumber
        case ukUniqueTaxpayerReferenceNumber
        case url
        case username
        case usBankAccountNumber
        case usBankRoutingNumber
        case usIndividualTaxIdentificationNumber
        case usPassportNumber
        case usSocialSecurityNumber
        case vehicleIdentificationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailPiiEntityType] {
            return [
                .address,
                .age,
                .awsAccessKey,
                .awsSecretKey,
                .caHealthNumber,
                .caSocialInsuranceNumber,
                .creditDebitCardCvv,
                .creditDebitCardExpiry,
                .creditDebitCardNumber,
                .driverId,
                .email,
                .internationalBankAccountNumber,
                .ipAddress,
                .licensePlate,
                .macAddress,
                .name,
                .password,
                .phone,
                .pin,
                .swiftCode,
                .ukNationalHealthServiceNumber,
                .ukNationalInsuranceNumber,
                .ukUniqueTaxpayerReferenceNumber,
                .url,
                .username,
                .usBankAccountNumber,
                .usBankRoutingNumber,
                .usIndividualTaxIdentificationNumber,
                .usPassportNumber,
                .usSocialSecurityNumber,
                .vehicleIdentificationNumber,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .age: return "AGE"
            case .awsAccessKey: return "AWS_ACCESS_KEY"
            case .awsSecretKey: return "AWS_SECRET_KEY"
            case .caHealthNumber: return "CA_HEALTH_NUMBER"
            case .caSocialInsuranceNumber: return "CA_SOCIAL_INSURANCE_NUMBER"
            case .creditDebitCardCvv: return "CREDIT_DEBIT_CARD_CVV"
            case .creditDebitCardExpiry: return "CREDIT_DEBIT_CARD_EXPIRY"
            case .creditDebitCardNumber: return "CREDIT_DEBIT_CARD_NUMBER"
            case .driverId: return "DRIVER_ID"
            case .email: return "EMAIL"
            case .internationalBankAccountNumber: return "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
            case .ipAddress: return "IP_ADDRESS"
            case .licensePlate: return "LICENSE_PLATE"
            case .macAddress: return "MAC_ADDRESS"
            case .name: return "NAME"
            case .password: return "PASSWORD"
            case .phone: return "PHONE"
            case .pin: return "PIN"
            case .swiftCode: return "SWIFT_CODE"
            case .ukNationalHealthServiceNumber: return "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
            case .ukNationalInsuranceNumber: return "UK_NATIONAL_INSURANCE_NUMBER"
            case .ukUniqueTaxpayerReferenceNumber: return "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
            case .url: return "URL"
            case .username: return "USERNAME"
            case .usBankAccountNumber: return "US_BANK_ACCOUNT_NUMBER"
            case .usBankRoutingNumber: return "US_BANK_ROUTING_NUMBER"
            case .usIndividualTaxIdentificationNumber: return "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
            case .usPassportNumber: return "US_PASSPORT_NUMBER"
            case .usSocialSecurityNumber: return "US_SOCIAL_SECURITY_NUMBER"
            case .vehicleIdentificationNumber: return "VEHICLE_IDENTIFICATION_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailRegexFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailRegexFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailRegexFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailRegexFilter()
        value.name = try reader["name"].readIfPresent()
        value.regex = try reader["regex"].readIfPresent()
        value.match = try reader["match"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The details for the regex filter used in the Guardrail.
    public struct GuardrailRegexFilter {
        /// The action details for the regex filter used in the Guardrail.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAction?
        /// The match details for the regex filter used in the Guardrail.
        public var match: Swift.String?
        /// The name details for the regex filter used in the Guardrail.
        public var name: Swift.String?
        /// The regex details for the regex filter used in the Guardrail.
        public var regex: Swift.String?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAction? = nil,
            match: Swift.String? = nil,
            name: Swift.String? = nil,
            regex: Swift.String? = nil
        )
        {
            self.action = action
            self.match = match
            self.name = name
            self.regex = regex
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailSensitiveInformationPolicyAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anonymized
        case blocked
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailSensitiveInformationPolicyAction] {
            return [
                .anonymized,
                .blocked,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anonymized: return "ANONYMIZED"
            case .blocked: return "BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment()
        value.piiEntities = try reader["piiEntities"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.regexes = try reader["regexes"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailRegexFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The details of the sensitive policy assessment used in the Guardrail.
    public struct GuardrailSensitiveInformationPolicyAssessment {
        /// The details of the PII entities used in the sensitive policy assessment for the Guardrail.
        public var piiEntities: [BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter]?
        /// The details of the regexes used in the sensitive policy assessment for the Guardrail.
        public var regexes: [BedrockAgentRuntimeClientTypes.GuardrailRegexFilter]?

        public init(
            piiEntities: [BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter]? = nil,
            regexes: [BedrockAgentRuntimeClientTypes.GuardrailRegexFilter]? = nil
        )
        {
            self.piiEntities = piiEntities
            self.regexes = regexes
        }
    }

}

extension BedrockAgentRuntimeClientTypes.GuardrailTopic: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailTopic {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailTopic {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailTopic()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The details for a specific topic defined in the Guardrail.
    public struct GuardrailTopic {
        /// The action details on a specific topic in the Guardrail.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAction?
        /// The name details on a specific topic in the Guardrail.
        public var name: Swift.String?
        /// The type details on a specific topic in the Guardrail.
        public var type: BedrockAgentRuntimeClientTypes.GuardrailTopicType?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAction? = nil,
            name: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.GuardrailTopicType? = nil
        )
        {
            self.action = action
            self.name = name
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailTopicPolicyAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blocked
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTopicPolicyAction] {
            return [
                .blocked,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blocked: return "BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment()
        value.topics = try reader["topics"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailTopic.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The details of the policy assessment used in the Guardrail.
    public struct GuardrailTopicPolicyAssessment {
        /// The topic details of the policy assessment used in the Guardrail.
        public var topics: [BedrockAgentRuntimeClientTypes.GuardrailTopic]?

        public init(
            topics: [BedrockAgentRuntimeClientTypes.GuardrailTopic]? = nil
        )
        {
            self.topics = topics
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailTopicType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTopicType] {
            return [
                .deny,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailTrace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailTrace()
        value.action = try reader["action"].readIfPresent()
        value.traceId = try reader["traceId"].readIfPresent()
        value.inputAssessments = try reader["inputAssessments"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailAssessment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputAssessments = try reader["outputAssessments"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailAssessment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The trace details used in the Guardrail.
    public struct GuardrailTrace {
        /// The trace action details used with the Guardrail.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailAction?
        /// The details of the input assessments used in the Guardrail Trace.
        public var inputAssessments: [BedrockAgentRuntimeClientTypes.GuardrailAssessment]?
        /// The details of the output assessments used in the Guardrail Trace.
        public var outputAssessments: [BedrockAgentRuntimeClientTypes.GuardrailAssessment]?
        /// The details of the trace Id used in the Guardrail Trace.
        public var traceId: Swift.String?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailAction? = nil,
            inputAssessments: [BedrockAgentRuntimeClientTypes.GuardrailAssessment]? = nil,
            outputAssessments: [BedrockAgentRuntimeClientTypes.GuardrailAssessment]? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.action = action
            self.inputAssessments = inputAssessments
            self.outputAssessments = outputAssessments
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailWordPolicyAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blocked
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailWordPolicyAction] {
            return [
                .blocked,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blocked: return "BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment()
        value.customWords = try reader["customWords"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailCustomWord.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.managedWordLists = try reader["managedWordLists"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailManagedWord.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The assessment details for words defined in the Guardrail filter.
    public struct GuardrailWordPolicyAssessment {
        /// The custom word details for words defined in the Guardrail filter.
        public var customWords: [BedrockAgentRuntimeClientTypes.GuardrailCustomWord]?
        /// The managed word lists for words defined in the Guardrail filter.
        public var managedWordLists: [BedrockAgentRuntimeClientTypes.GuardrailManagedWord]?

        public init(
            customWords: [BedrockAgentRuntimeClientTypes.GuardrailCustomWord]? = nil,
            managedWordLists: [BedrockAgentRuntimeClientTypes.GuardrailManagedWord]? = nil
        )
        {
            self.customWords = customWords
            self.managedWordLists = managedWordLists
        }
    }

}

extension BedrockAgentRuntimeClientTypes.InferenceConfig {

    static func write(value: BedrockAgentRuntimeClientTypes.InferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["textInferenceConfig"].write(value.textInferenceConfig, with: BedrockAgentRuntimeClientTypes.TextInferenceConfig.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The configuration for inference settings when generating responses using RetrieveAndGenerate.
    public struct InferenceConfig {
        /// Configuration settings specific to text generation while generating responses using RetrieveAndGenerate.
        public var textInferenceConfig: BedrockAgentRuntimeClientTypes.TextInferenceConfig?

        public init(
            textInferenceConfig: BedrockAgentRuntimeClientTypes.TextInferenceConfig? = nil
        )
        {
            self.textInferenceConfig = textInferenceConfig
        }
    }

}

extension BedrockAgentRuntimeClientTypes.InferenceConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InferenceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.InferenceConfiguration()
        value.temperature = try reader["temperature"].readIfPresent()
        value.topp = try reader["topP"].readIfPresent()
        value.topk = try reader["topK"].readIfPresent()
        value.maximumLength = try reader["maximumLength"].readIfPresent()
        value.stopSequences = try reader["stopSequences"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Specifications about the inference parameters that were provided alongside the prompt. These are specified in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    public struct InferenceConfiguration {
        /// The maximum number of tokens allowed in the generated response.
        public var maximumLength: Swift.Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public var stopSequences: [Swift.String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        public var temperature: Swift.Float?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for topK is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topK to 50, the model selects the next token from among the top 50 most likely choices.
        public var topk: Swift.Int?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for Top P determines the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topP to 80, the model only selects the next token from the top 80% of the probability distribution of next tokens.
        public var topp: Swift.Float?

        public init(
            maximumLength: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topk: Swift.Int? = nil,
            topp: Swift.Float? = nil
        )
        {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topk = topk
            self.topp = topp
        }
    }

}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func read(from reader: SmithyJSON.Reader) throws -> InternalServerException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InvocationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.InvocationInput()
        value.traceId = try reader["traceId"].readIfPresent()
        value.invocationType = try reader["invocationType"].readIfPresent()
        value.actionGroupInvocationInput = try reader["actionGroupInvocationInput"].readIfPresent(with: BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput.read(from:))
        value.knowledgeBaseLookupInput = try reader["knowledgeBaseLookupInput"].readIfPresent(with: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information pertaining to the action group or knowledge base that is being invoked.
    public struct InvocationInput {
        /// Contains information about the action group to be invoked.
        public var actionGroupInvocationInput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput?
        /// Specifies whether the agent is invoking an action group or a knowledge base.
        public var invocationType: BedrockAgentRuntimeClientTypes.InvocationType?
        /// Contains details about the knowledge base to look up and the query to be made.
        public var knowledgeBaseLookupInput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            actionGroupInvocationInput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput? = nil,
            invocationType: BedrockAgentRuntimeClientTypes.InvocationType? = nil,
            knowledgeBaseLookupInput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.actionGroupInvocationInput = actionGroupInvocationInput
            self.invocationType = invocationType
            self.knowledgeBaseLookupInput = knowledgeBaseLookupInput
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.InvocationInputMember {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InvocationInputMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "apiInvocationInput":
                return .apiinvocationinput(try reader["apiInvocationInput"].read(with: BedrockAgentRuntimeClientTypes.ApiInvocationInput.read(from:)))
            case "functionInvocationInput":
                return .functioninvocationinput(try reader["functionInvocationInput"].read(with: BedrockAgentRuntimeClientTypes.FunctionInvocationInput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the API operation or function that the agent predicts should be called. This data type is used in the following API operations:
    ///
    /// * In the returnControl field of the [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public enum InvocationInputMember {
        /// Contains information about the API operation that the agent predicts should be called.
        case apiinvocationinput(BedrockAgentRuntimeClientTypes.ApiInvocationInput)
        /// Contains information about the function that the agent predicts should be called.
        case functioninvocationinput(BedrockAgentRuntimeClientTypes.FunctionInvocationInput)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.InvocationResultMember {

    static func write(value: BedrockAgentRuntimeClientTypes.InvocationResultMember?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .apiresult(apiresult):
                try writer["apiResult"].write(apiresult, with: BedrockAgentRuntimeClientTypes.ApiResult.write(value:to:))
            case let .functionresult(functionresult):
                try writer["functionResult"].write(functionresult, with: BedrockAgentRuntimeClientTypes.FunctionResult.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// A result from the invocation of an action. For more information, see [Return control to the agent developer](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-returncontrol.html) and [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html). This data type is used in the following API operations:
    ///
    /// * [InvokeAgent request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_RequestSyntax)
    public enum InvocationResultMember {
        /// The result from the API response from the action group invocation.
        case apiresult(BedrockAgentRuntimeClientTypes.ApiResult)
        /// The result from the function from the action group invocation.
        case functionresult(BedrockAgentRuntimeClientTypes.FunctionResult)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum InvocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionGroup
        case finish
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [InvocationType] {
            return [
                .actionGroup,
                .finish,
                .knowledgeBase,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionGroup: return "ACTION_GROUP"
            case .finish: return "FINISH"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InvokeAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeAgentInput(agentAliasId: \(Swift.String(describing: agentAliasId)), agentId: \(Swift.String(describing: agentId)), enableTrace: \(Swift.String(describing: enableTrace)), endSession: \(Swift.String(describing: endSession)), sessionId: \(Swift.String(describing: sessionId)), sessionState: \(Swift.String(describing: sessionState)), inputText: \"CONTENT_REDACTED\")"}
}

extension InvokeAgentInput {

    static func urlPathProvider(_ value: InvokeAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentAliases/\(agentAliasId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/text"
    }
}

extension InvokeAgentInput {

    static func write(value: InvokeAgentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enableTrace"].write(value.enableTrace)
        try writer["endSession"].write(value.endSession)
        try writer["inputText"].write(value.inputText)
        try writer["sessionState"].write(value.sessionState, with: BedrockAgentRuntimeClientTypes.SessionState.write(value:to:))
    }
}

public struct InvokeAgentInput {
    /// The alias of the agent to use.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The unique identifier of the agent to use.
    /// This member is required.
    public var agentId: Swift.String?
    /// Specifies whether to turn on the trace or not to track the agent's reasoning process. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-events).
    public var enableTrace: Swift.Bool?
    /// Specifies whether to end the session with the agent or not.
    public var endSession: Swift.Bool?
    /// The prompt text to send the agent. If you include returnControlInvocationResults in the sessionState field, the inputText field will be ignored.
    public var inputText: Swift.String?
    /// The unique identifier of the session. Use the same value across requests to continue the same conversation.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Contains parameters that specify various attributes of the session. For more information, see [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html). If you include returnControlInvocationResults in the sessionState field, the inputText field will be ignored.
    public var sessionState: BedrockAgentRuntimeClientTypes.SessionState?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        enableTrace: Swift.Bool? = nil,
        endSession: Swift.Bool? = nil,
        inputText: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionState: BedrockAgentRuntimeClientTypes.SessionState? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
        self.enableTrace = enableTrace
        self.endSession = endSession
        self.inputText = inputText
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

extension InvokeAgentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> InvokeAgentOutput {
        var value = InvokeAgentOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-bedrock-agent-content-type") {
            value.contentType = contentTypeHeaderValue
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-bedrock-agent-session-id") {
            value.sessionId = sessionIdHeaderValue
        }
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = AWSClientRuntime.AWSEventStream.AWSMessageDecoder()
            let decoderStream = ClientRuntime.EventStream.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: BedrockAgentRuntimeClientTypes.ResponseStream.unmarshal)
            value.completion = decoderStream.toAsyncStream()
        }
        return value
    }
}

public struct InvokeAgentOutput {
    /// The agent's response to the user prompt.
    /// This member is required.
    public var completion: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.ResponseStream, Swift.Error>?
    /// The MIME type of the input data in the request. The default value is application/json.
    /// This member is required.
    public var contentType: Swift.String?
    /// The unique identifier of the session with the agent.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        completion: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.ResponseStream, Swift.Error>? = nil,
        contentType: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.completion = completion
        self.contentType = contentType
        self.sessionId = sessionId
    }
}

enum InvokeAgentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseLookupInput(knowledgeBaseId: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput()
        value.text = try reader["text"].readIfPresent()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the knowledge base to look up and the query to be made.
    public struct KnowledgeBaseLookupInput {
        /// The unique identifier of the knowledge base to look up.
        public var knowledgeBaseId: Swift.String?
        /// The query made to the knowledge base.
        public var text: Swift.String?

        public init(
            knowledgeBaseId: Swift.String? = nil,
            text: Swift.String? = nil
        )
        {
            self.knowledgeBaseId = knowledgeBaseId
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput()
        value.retrievedReferences = try reader["retrievedReferences"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.RetrievedReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the results from looking up the knowledge base.
    public struct KnowledgeBaseLookupOutput {
        /// Contains metadata about the sources cited for the generated response.
        public var retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]?

        public init(
            retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]? = nil
        )
        {
            self.retrievedReferences = retrievedReferences
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery {

    static func write(value: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["text"].write(value.text)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the query made to the knowledge base. This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax) – in the retrievalQuery field
    public struct KnowledgeBaseQuery {
        /// The text of the query made to the knowledge base.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vectorSearchConfiguration"].write(value.vectorSearchConfiguration, with: BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains configurations for the knowledge base query and retrieval process. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html). This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax) – in the retrievalConfiguration field
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the retrievalConfiguration field
    public struct KnowledgeBaseRetrievalConfiguration {
        /// Contains details about how the results from the vector search should be returned. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
        /// This member is required.
        public var vectorSearchConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration?

        public init(
            vectorSearchConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration? = nil
        )
        {
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseRetrievalResult(score: \(Swift.String(describing: score)), content: \"CONTENT_REDACTED\", location: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult()
        value.content = try reader["content"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultContent.read(from:))
        value.location = try reader["location"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultLocation.read(from:))
        value.score = try reader["score"].readIfPresent()
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.Document.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Details about a result from querying the knowledge base. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the retrievalResults field
    public struct KnowledgeBaseRetrievalResult {
        /// Contains a chunk of text from a data source in the knowledge base.
        /// This member is required.
        public var content: BedrockAgentRuntimeClientTypes.RetrievalResultContent?
        /// Contains information about the location of the data source.
        public var location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation?
        /// Contains metadata attributes and their values for the file in the data source. For more information, see [Metadata and filtering](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-ds.html#kb-ds-metadata).
        public var metadata: [Swift.String:SmithyReadWrite.Document]?
        /// The level of relevance of the result to the query.
        public var score: Swift.Double?

        public init(
            content: BedrockAgentRuntimeClientTypes.RetrievalResultContent? = nil,
            location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation? = nil,
            metadata: [Swift.String:SmithyReadWrite.Document]? = nil,
            score: Swift.Double? = nil
        )
        {
            self.content = content
            self.location = location
            self.metadata = metadata
            self.score = score
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["generationConfiguration"].write(value.generationConfiguration, with: BedrockAgentRuntimeClientTypes.GenerationConfiguration.write(value:to:))
        try writer["knowledgeBaseId"].write(value.knowledgeBaseId)
        try writer["modelArn"].write(value.modelArn)
        try writer["retrievalConfiguration"].write(value.retrievalConfiguration, with: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the resource being queried. This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax) – in the knowledgeBaseConfiguration field
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the knowledgeBaseConfiguration field
    public struct KnowledgeBaseRetrieveAndGenerateConfiguration {
        /// Contains configurations for response generation based on the knowwledge base query results.
        public var generationConfiguration: BedrockAgentRuntimeClientTypes.GenerationConfiguration?
        /// The unique identifier of the knowledge base that is queried and the foundation model used for generation.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The ARN of the foundation model used to generate a response.
        /// This member is required.
        public var modelArn: Swift.String?
        /// Contains configurations for how to retrieve and return the knowledge base query.
        public var retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration?

        public init(
            generationConfiguration: BedrockAgentRuntimeClientTypes.GenerationConfiguration? = nil,
            knowledgeBaseId: Swift.String? = nil,
            modelArn: Swift.String? = nil,
            retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration? = nil
        )
        {
            self.generationConfiguration = generationConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.modelArn = modelArn
            self.retrievalConfiguration = retrievalConfiguration
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseVectorSearchConfiguration(numberOfResults: \(Swift.String(describing: numberOfResults)), overrideSearchType: \(Swift.String(describing: overrideSearchType)), filter: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: BedrockAgentRuntimeClientTypes.RetrievalFilter.write(value:to:))
        try writer["numberOfResults"].write(value.numberOfResults)
        try writer["overrideSearchType"].write(value.overrideSearchType)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Configurations for how to perform the search query and return results. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html). This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax) – in the vectorSearchConfiguration field
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the vectorSearchConfiguration field
    public struct KnowledgeBaseVectorSearchConfiguration {
        /// Specifies the filters to use on the metadata in the knowledge base data sources before returning results. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
        public var filter: BedrockAgentRuntimeClientTypes.RetrievalFilter?
        /// The number of source chunks to retrieve.
        public var numberOfResults: Swift.Int?
        /// By default, Amazon Bedrock decides a search strategy for you. If you're using an Amazon OpenSearch Serverless vector store that contains a filterable text field, you can specify whether to query the knowledge base with a HYBRID search using both vector embeddings and raw text, or SEMANTIC search using only vector embeddings. For other vector store configurations, only SEMANTIC search is available. For more information, see [Test a knowledge base](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-test.html).
        public var overrideSearchType: BedrockAgentRuntimeClientTypes.SearchType?

        public init(
            filter: BedrockAgentRuntimeClientTypes.RetrievalFilter? = nil,
            numberOfResults: Swift.Int? = nil,
            overrideSearchType: BedrockAgentRuntimeClientTypes.SearchType? = nil
        )
        {
            self.filter = filter
            self.numberOfResults = numberOfResults
            self.overrideSearchType = overrideSearchType
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ModelInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.ModelInvocationInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ModelInvocationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ModelInvocationInput()
        value.traceId = try reader["traceId"].readIfPresent()
        value.text = try reader["text"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.inferenceConfiguration = try reader["inferenceConfiguration"].readIfPresent(with: BedrockAgentRuntimeClientTypes.InferenceConfiguration.read(from:))
        value.overrideLambda = try reader["overrideLambda"].readIfPresent()
        value.promptCreationMode = try reader["promptCreationMode"].readIfPresent()
        value.parserMode = try reader["parserMode"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The input for the pre-processing step.
    ///
    /// * The type matches the agent step.
    ///
    /// * The text contains the prompt.
    ///
    /// * The inferenceConfiguration, parserMode, and overrideLambda values are set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated.
    public struct ModelInvocationInput {
        /// Specifications about the inference parameters that were provided alongside the prompt. These are specified in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var inferenceConfiguration: BedrockAgentRuntimeClientTypes.InferenceConfiguration?
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence.
        public var overrideLambda: Swift.String?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType.
        public var parserMode: BedrockAgentRuntimeClientTypes.CreationMode?
        /// Specifies whether the default prompt template was OVERRIDDEN. If it was, the basePromptTemplate that was set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object when the agent was created or updated is used instead.
        public var promptCreationMode: BedrockAgentRuntimeClientTypes.CreationMode?
        /// The text that prompted the agent at this step.
        public var text: Swift.String?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?
        /// The step in the agent sequence.
        public var type: BedrockAgentRuntimeClientTypes.PromptType?

        public init(
            inferenceConfiguration: BedrockAgentRuntimeClientTypes.InferenceConfiguration? = nil,
            overrideLambda: Swift.String? = nil,
            parserMode: BedrockAgentRuntimeClientTypes.CreationMode? = nil,
            promptCreationMode: BedrockAgentRuntimeClientTypes.CreationMode? = nil,
            text: Swift.String? = nil,
            traceId: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.PromptType? = nil
        )
        {
            self.inferenceConfiguration = inferenceConfiguration
            self.overrideLambda = overrideLambda
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.text = text
            self.traceId = traceId
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes.Observation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.Observation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Observation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Observation()
        value.traceId = try reader["traceId"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.actionGroupInvocationOutput = try reader["actionGroupInvocationOutput"].readIfPresent(with: BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput.read(from:))
        value.knowledgeBaseLookupOutput = try reader["knowledgeBaseLookupOutput"].readIfPresent(with: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput.read(from:))
        value.finalResponse = try reader["finalResponse"].readIfPresent(with: BedrockAgentRuntimeClientTypes.FinalResponse.read(from:))
        value.repromptResponse = try reader["repromptResponse"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RepromptResponse.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the result or output of an action group or knowledge base, or the response to the user.
    public struct Observation {
        /// Contains the JSON-formatted string returned by the API invoked by the action group.
        public var actionGroupInvocationOutput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput?
        /// Contains details about the response to the user.
        public var finalResponse: BedrockAgentRuntimeClientTypes.FinalResponse?
        /// Contains details about the results from looking up the knowledge base.
        public var knowledgeBaseLookupOutput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput?
        /// Contains details about the response to reprompt the input.
        public var repromptResponse: BedrockAgentRuntimeClientTypes.RepromptResponse?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?
        /// Specifies what kind of information the agent returns in the observation. The following values are possible.
        ///
        /// * ACTION_GROUP – The agent returns the result of an action group.
        ///
        /// * KNOWLEDGE_BASE – The agent returns information from a knowledge base.
        ///
        /// * FINISH – The agent returns a final response to the user with no follow-up.
        ///
        /// * ASK_USER – The agent asks the user a question.
        ///
        /// * REPROMPT – The agent prompts the user again for the same information.
        public var type: BedrockAgentRuntimeClientTypes.ModelType?

        public init(
            actionGroupInvocationOutput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput? = nil,
            finalResponse: BedrockAgentRuntimeClientTypes.FinalResponse? = nil,
            knowledgeBaseLookupOutput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput? = nil,
            repromptResponse: BedrockAgentRuntimeClientTypes.RepromptResponse? = nil,
            traceId: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.ModelType? = nil
        )
        {
            self.actionGroupInvocationOutput = actionGroupInvocationOutput
            self.finalResponse = finalResponse
            self.knowledgeBaseLookupOutput = knowledgeBaseLookupOutput
            self.repromptResponse = repromptResponse
            self.traceId = traceId
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes.OrchestrationTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.OrchestrationTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "rationale":
                return .rationale(try reader["rationale"].read(with: BedrockAgentRuntimeClientTypes.Rationale.read(from:)))
            case "invocationInput":
                return .invocationinput(try reader["invocationInput"].read(with: BedrockAgentRuntimeClientTypes.InvocationInput.read(from:)))
            case "observation":
                return .observation(try reader["observation"].read(with: BedrockAgentRuntimeClientTypes.Observation.read(from:)))
            case "modelInvocationInput":
                return .modelinvocationinput(try reader["modelInvocationInput"].read(with: BedrockAgentRuntimeClientTypes.ModelInvocationInput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Details about the orchestration step, in which the agent determines the order in which actions are executed and which knowledge bases are retrieved.
    public enum OrchestrationTrace {
        /// Details about the reasoning, based on the input, that the agent uses to justify carrying out an action group or getting information from a knowledge base.
        case rationale(BedrockAgentRuntimeClientTypes.Rationale)
        /// Contains information pertaining to the action group or knowledge base that is being invoked.
        case invocationinput(BedrockAgentRuntimeClientTypes.InvocationInput)
        /// Details about the observation (the output of the action group Lambda or knowledge base) made by the agent.
        case observation(BedrockAgentRuntimeClientTypes.Observation)
        /// The input for the orchestration step.
        ///
        /// * The type is ORCHESTRATION.
        ///
        /// * The text contains the prompt.
        ///
        /// * The inferenceConfiguration, parserMode, and overrideLambda values are set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated.
        case modelinvocationinput(BedrockAgentRuntimeClientTypes.ModelInvocationInput)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.Parameter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Parameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Parameter()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// A parameter for the API request or function.
    public struct Parameter {
        /// The name of the parameter.
        public var name: Swift.String?
        /// The type of the parameter.
        public var type: Swift.String?
        /// The value of the parameter.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PayloadPart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.PayloadPart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PayloadPart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.PayloadPart()
        value.bytes = try reader["bytes"].readIfPresent()
        value.attribution = try reader["attribution"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Attribution.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains a part of an agent response and citations for it.
    public struct PayloadPart {
        /// Contains citations for a part of an agent response.
        public var attribution: BedrockAgentRuntimeClientTypes.Attribution?
        /// A part of the agent response in bytes.
        public var bytes: ClientRuntime.Data?

        public init(
            attribution: BedrockAgentRuntimeClientTypes.Attribution? = nil,
            bytes: ClientRuntime.Data? = nil
        )
        {
            self.attribution = attribution
            self.bytes = bytes
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput()
        value.traceId = try reader["traceId"].readIfPresent()
        value.parsedResponse = try reader["parsedResponse"].readIfPresent(with: BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The foundation model output from the post-processing step.
    public struct PostProcessingModelInvocationOutput {
        /// Details about the response from the Lambda parsing of the output of the post-processing step.
        public var parsedResponse: BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            parsedResponse: BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.parsedResponse = parsedResponse
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Details about the response from the Lambda parsing of the output from the post-processing step.
    public struct PostProcessingParsedResponse {
        /// The text returned by the parser.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PostProcessingTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PostProcessingTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "modelInvocationInput":
                return .modelinvocationinput(try reader["modelInvocationInput"].read(with: BedrockAgentRuntimeClientTypes.ModelInvocationInput.read(from:)))
            case "modelInvocationOutput":
                return .modelinvocationoutput(try reader["modelInvocationOutput"].read(with: BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Details about the post-processing step, in which the agent shapes the response.
    public enum PostProcessingTrace {
        /// The input for the post-processing step.
        ///
        /// * The type is POST_PROCESSING.
        ///
        /// * The text contains the prompt.
        ///
        /// * The inferenceConfiguration, parserMode, and overrideLambda values are set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated.
        case modelinvocationinput(BedrockAgentRuntimeClientTypes.ModelInvocationInput)
        /// The foundation model output from the post-processing step.
        case modelinvocationoutput(BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput()
        value.traceId = try reader["traceId"].readIfPresent()
        value.parsedResponse = try reader["parsedResponse"].readIfPresent(with: BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The foundation model output from the pre-processing step.
    public struct PreProcessingModelInvocationOutput {
        /// Details about the response from the Lambda parsing of the output of the pre-processing step.
        public var parsedResponse: BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            parsedResponse: BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.parsedResponse = parsedResponse
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse()
        value.rationale = try reader["rationale"].readIfPresent()
        value.isValid = try reader["isValid"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Details about the response from the Lambda parsing of the output from the pre-processing step.
    public struct PreProcessingParsedResponse {
        /// Whether the user input is valid or not. If false, the agent doesn't proceed to orchestration.
        public var isValid: Swift.Bool?
        /// The text returned by the parsing of the pre-processing step, explaining the steps that the agent plans to take in orchestration, if the user input is valid.
        public var rationale: Swift.String?

        public init(
            isValid: Swift.Bool? = nil,
            rationale: Swift.String? = nil
        )
        {
            self.isValid = isValid
            self.rationale = rationale
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PreProcessingTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PreProcessingTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "modelInvocationInput":
                return .modelinvocationinput(try reader["modelInvocationInput"].read(with: BedrockAgentRuntimeClientTypes.ModelInvocationInput.read(from:)))
            case "modelInvocationOutput":
                return .modelinvocationoutput(try reader["modelInvocationOutput"].read(with: BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Details about the pre-processing step, in which the agent contextualizes and categorizes user inputs.
    public enum PreProcessingTrace {
        /// The input for the pre-processing step.
        ///
        /// * The type is PRE_PROCESSING.
        ///
        /// * The text contains the prompt.
        ///
        /// * The inferenceConfiguration, parserMode, and overrideLambda values are set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated.
        case modelinvocationinput(BedrockAgentRuntimeClientTypes.ModelInvocationInput)
        /// The foundation model output from the pre-processing step.
        case modelinvocationoutput(BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.PromptTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromptTemplate(textPromptTemplate: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.PromptTemplate {

    static func write(value: BedrockAgentRuntimeClientTypes.PromptTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["textPromptTemplate"].write(value.textPromptTemplate)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the template for the prompt that's sent to the model for response generation. For more information, see [Knowledge base prompt templates](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html#kb-test-config-sysprompt). This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the filter field
    public struct PromptTemplate {
        /// The template for the prompt that's sent to the model for response generation. You can include prompt placeholders, which become replaced before the prompt is sent to the model to provide instructions and context to the model. In addition, you can include XML tags to delineate meaningful sections of the prompt template. For more information, see the following resources:
        ///
        /// * [Knowledge base prompt templates](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html#kb-test-config-sysprompt)
        ///
        /// * [Use XML tags with Anthropic Claude models](https://docs.anthropic.com/claude/docs/use-xml-tags)
        public var textPromptTemplate: Swift.String?

        public init(
            textPromptTemplate: Swift.String? = nil
        )
        {
            self.textPromptTemplate = textPromptTemplate
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum PromptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case knowledgeBaseResponseGeneration
        case orchestration
        case postProcessing
        case preProcessing
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptType] {
            return [
                .knowledgeBaseResponseGeneration,
                .orchestration,
                .postProcessing,
                .preProcessing,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBaseResponseGeneration: return "KNOWLEDGE_BASE_RESPONSE_GENERATION"
            case .orchestration: return "ORCHESTRATION"
            case .postProcessing: return "POST_PROCESSING"
            case .preProcessing: return "PRE_PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.PropertyParameters {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PropertyParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.PropertyParameters()
        value.properties = try reader["properties"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.Parameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the parameters in the request body.
    public struct PropertyParameters {
        /// A list of parameters in the request body.
        public var properties: [BedrockAgentRuntimeClientTypes.Parameter]?

        public init(
            properties: [BedrockAgentRuntimeClientTypes.Parameter]? = nil
        )
        {
            self.properties = properties
        }
    }

}

extension BedrockAgentRuntimeClientTypes.Rationale: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.Rationale {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Rationale {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Rationale()
        value.traceId = try reader["traceId"].readIfPresent()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the reasoning, based on the input, that the agent uses to justify carrying out an action group or getting information from a knowledge base.
    public struct Rationale {
        /// The reasoning or thought process of the agent, based on the input.
        public var text: Swift.String?
        /// The unique identifier of the trace step.
        public var traceId: Swift.String?

        public init(
            text: Swift.String? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.text = text
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RepromptResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.RepromptResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RepromptResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RepromptResponse()
        value.text = try reader["text"].readIfPresent()
        value.source = try reader["source"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the agent's response to reprompt the input.
    public struct RepromptResponse {
        /// Specifies what output is prompting the agent to reprompt the input.
        public var source: BedrockAgentRuntimeClientTypes.Source?
        /// The text reprompting the input.
        public var text: Swift.String?

        public init(
            source: BedrockAgentRuntimeClientTypes.Source? = nil,
            text: Swift.String? = nil
        )
        {
            self.source = source
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RequestBody {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RequestBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RequestBody()
        value.content = try reader["content"].readMapIfPresent(valueReadingClosure: listReadingClosure(memberReadingClosure: BedrockAgentRuntimeClientTypes.Parameter.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The parameters in the API request body.
    public struct RequestBody {
        /// The content in the request body.
        public var content: [Swift.String:[BedrockAgentRuntimeClientTypes.Parameter]]?

        public init(
            content: [Swift.String:[BedrockAgentRuntimeClientTypes.Parameter]]? = nil
        )
        {
            self.content = content
        }
    }

}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceNotFoundException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

/// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum ResponseState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failure
        case reprompt
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseState] {
            return [
                .failure,
                .reprompt,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failure: return "FAILURE"
            case .reprompt: return "REPROMPT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ResponseStream {
    static var unmarshal: ClientRuntime.UnmarshalClosure<BedrockAgentRuntimeClientTypes.ResponseStream> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "chunk":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.PayloadPart.read(from:))
                    return .chunk(value)
                case "trace":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.TracePart.read(from:))
                    return .trace(value)
                case "returnControl":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.ReturnControlPayload.read(from:))
                    return .returncontrol(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (ClientRuntime.EventStream.Message, ClientRuntime.EventStream.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "internalServerException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalServerException.read(from:))
                        return value
                    case "validationException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ValidationException.read(from:))
                        return value
                    case "resourceNotFoundException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ResourceNotFoundException.read(from:))
                        return value
                    case "serviceQuotaExceededException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ServiceQuotaExceededException.read(from:))
                        return value
                    case "throttlingException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ThrottlingException.read(from:))
                        return value
                    case "accessDeniedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: AccessDeniedException.read(from:))
                        return value
                    case "conflictException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ConflictException.read(from:))
                        return value
                    case "dependencyFailedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: DependencyFailedException.read(from:))
                        return value
                    case "badGatewayException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: BadGatewayException.read(from:))
                        return value
                    default:
                        let httpResponse = HttpResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = HttpResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw ClientRuntime.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The response from invoking the agent and associated citations and trace information.
    public enum ResponseStream {
        /// Contains a part of an agent response and citations for it.
        case chunk(BedrockAgentRuntimeClientTypes.PayloadPart)
        /// Contains information about the agent and session, alongside the agent's reasoning process and results from calling actions and querying knowledge bases and metadata about the trace. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace events](https://docs.aws.amazon.com/bedrock/latest/userguide/trace-events.html).
        case trace(BedrockAgentRuntimeClientTypes.TracePart)
        /// Contains the parameters and information that the agent elicited from the customer to carry out an action. This information is returned to the system and can be used in your own setup for fulfilling the action.
        case returncontrol(BedrockAgentRuntimeClientTypes.ReturnControlPayload)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.RetrievalFilter {

    static func write(value: BedrockAgentRuntimeClientTypes.RetrievalFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .andall(andall):
                try writer["andAll"].writeList(andall, memberWritingClosure: BedrockAgentRuntimeClientTypes.RetrievalFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .equals(equals):
                try writer["equals"].write(equals, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .greaterthan(greaterthan):
                try writer["greaterThan"].write(greaterthan, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .greaterthanorequals(greaterthanorequals):
                try writer["greaterThanOrEquals"].write(greaterthanorequals, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .`in`(`in`):
                try writer["in"].write(`in`, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .lessthan(lessthan):
                try writer["lessThan"].write(lessthan, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .lessthanorequals(lessthanorequals):
                try writer["lessThanOrEquals"].write(lessthanorequals, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .listcontains(listcontains):
                try writer["listContains"].write(listcontains, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .notequals(notequals):
                try writer["notEquals"].write(notequals, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .notin(notin):
                try writer["notIn"].write(notin, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .orall(orall):
                try writer["orAll"].writeList(orall, memberWritingClosure: BedrockAgentRuntimeClientTypes.RetrievalFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .startswith(startswith):
                try writer["startsWith"].write(startswith, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .stringcontains(stringcontains):
                try writer["stringContains"].write(stringcontains, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Specifies the filters to use on the metadata attributes in the knowledge base data sources before returning results. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html). See the examples below to see how to use these filters. This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax) – in the filter field
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the filter field
    public indirect enum RetrievalFilter {
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value matches the value in this object. The following example would return data sources with an animal attribute whose value is cat: "equals": { "key": "animal", "value": "cat" }
        case equals(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value doesn't match the value in this object are returned. The following example would return data sources that don't contain an animal attribute whose value is cat. "notEquals": { "key": "animal", "value": "cat" }
        case notequals(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is greater than the value in this object. The following example would return data sources with an year attribute whose value is greater than 1989: "greaterThan": { "key": "year", "value": 1989 }
        case greaterthan(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is greater than or equal to the value in this object. The following example would return data sources with an year attribute whose value is greater than or equal to 1989: "greaterThanOrEquals": { "key": "year", "value": 1989 }
        case greaterthanorequals(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is less than the value in this object. The following example would return data sources with an year attribute whose value is less than to 1989. "lessThan": { "key": "year", "value": 1989 }
        case lessthan(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is less than or equal to the value in this object. The following example would return data sources with an year attribute whose value is less than or equal to 1989. "lessThanOrEquals": { "key": "year", "value": 1989 }
        case lessthanorequals(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is in the list specified in the value in this object. The following example would return data sources with an animal attribute that is either cat or dog: "in": { "key": "animal", "value": ["cat", "dog"] }
        case `in`(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value isn't in the list specified in the value in this object. The following example would return data sources whose animal attribute is neither cat nor dog. "notIn": { "key": "animal", "value": ["cat", "dog"] }
        case notin(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value starts with the value in this object. This filter is currently only supported for Amazon OpenSearch Serverless vector stores. The following example would return data sources with an animal attribute starts with ca (for example, cat or camel). "startsWith": { "key": "animal", "value": "ca" }
        case startswith(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is a list that contains the value as one of its members. The following example would return data sources with an animals attribute that is a list containing a cat member (for example ["dog", "cat"]). "listContains": { "key": "animals", "value": "cat" }
        case listcontains(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is one of the following:
        ///
        /// * A string that contains the value as a substring. The following example would return data sources with an animal attribute that contains the substring at (for example cat). "stringContains": { "key": "animal", "value": "at" }
        ///
        /// * A list with a member that contains the value as a substring. The following example would return data sources with an animals attribute that is a list containing a member that contains the substring at (for example ["dog", "cat"]). "stringContains": { "key": "animals", "value": "at" }
        case stringcontains(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if their metadata attributes fulfill all the filter conditions inside this list.
        case andall([BedrockAgentRuntimeClientTypes.RetrievalFilter])
        /// Knowledge base data sources are returned if their metadata attributes fulfill at least one of the filter conditions inside this list.
        case orall([BedrockAgentRuntimeClientTypes.RetrievalFilter])
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.RetrievalResultContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultContent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultContent()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the cited text from the data source. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the content field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the content field
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax) – in the content field
    public struct RetrievalResultContent {
        /// The cited text from the data source.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RetrievalResultLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultLocation()
        value.type = try reader["type"].readIfPresent()
        value.s3Location = try reader["s3Location"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultS3Location.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the location of the data source. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the location field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the location field
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax) – in the locatino field
    public struct RetrievalResultLocation {
        /// Contains the S3 location of the data source.
        public var s3Location: BedrockAgentRuntimeClientTypes.RetrievalResultS3Location?
        /// The type of the location of the data source.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.RetrievalResultLocationType?

        public init(
            s3Location: BedrockAgentRuntimeClientTypes.RetrievalResultS3Location? = nil,
            type: BedrockAgentRuntimeClientTypes.RetrievalResultLocationType? = nil
        )
        {
            self.s3Location = s3Location
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum RetrievalResultLocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrievalResultLocationType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultS3Location {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultS3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultS3Location()
        value.uri = try reader["uri"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the S3 location of the data source. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax) – in the s3Location field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the s3Location field
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax) – in the s3Location field
    public struct RetrievalResultS3Location {
        /// The S3 URI of the data source.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["externalSourcesConfiguration"].write(value.externalSourcesConfiguration, with: BedrockAgentRuntimeClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration.write(value:to:))
        try writer["knowledgeBaseConfiguration"].write(value.knowledgeBaseConfiguration, with: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains details about the resource being queried. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the retrieveAndGenerateConfiguration field
    public struct RetrieveAndGenerateConfiguration {
        /// The configuration used with the external source wrapper object in the retrieveAndGenerate function.
        public var externalSourcesConfiguration: BedrockAgentRuntimeClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration?
        /// Contains details about the resource being queried.
        public var knowledgeBaseConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration?
        /// The type of resource that is queried by the request.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateType?

        public init(
            externalSourcesConfiguration: BedrockAgentRuntimeClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration? = nil,
            knowledgeBaseConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration? = nil,
            type: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateType? = nil
        )
        {
            self.externalSourcesConfiguration = externalSourcesConfiguration
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension RetrieveAndGenerateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveAndGenerateInput(retrieveAndGenerateConfiguration: \(Swift.String(describing: retrieveAndGenerateConfiguration)), sessionConfiguration: \(Swift.String(describing: sessionConfiguration)), sessionId: \(Swift.String(describing: sessionId)), input: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput {

    static func write(value: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["text"].write(value.text)
    }
}

extension RetrieveAndGenerateInput {

    static func urlPathProvider(_ value: RetrieveAndGenerateInput) -> Swift.String? {
        return "/retrieveAndGenerate"
    }
}

extension RetrieveAndGenerateInput {

    static func write(value: RetrieveAndGenerateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["input"].write(value.input, with: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput.write(value:to:))
        try writer["retrieveAndGenerateConfiguration"].write(value.retrieveAndGenerateConfiguration, with: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration.write(value:to:))
        try writer["sessionConfiguration"].write(value.sessionConfiguration, with: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration.write(value:to:))
        try writer["sessionId"].write(value.sessionId)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the query made to the knowledge base. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the input field
    public struct RetrieveAndGenerateInput {
        /// The query made to the knowledge base.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

public struct RetrieveAndGenerateInput {
    /// Contains the query to be made to the knowledge base.
    /// This member is required.
    public var input: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput?
    /// Contains configurations for the knowledge base query and retrieval process. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
    public var retrieveAndGenerateConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration?
    /// Contains details about the session with the knowledge base.
    public var sessionConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration?
    /// The unique identifier of the session. Reuse the same value to continue the same session with the knowledge base.
    public var sessionId: Swift.String?

    public init(
        input: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput? = nil,
        retrieveAndGenerateConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration? = nil,
        sessionConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.input = input
        self.retrieveAndGenerateConfiguration = retrieveAndGenerateConfiguration
        self.sessionConfiguration = sessionConfiguration
        self.sessionId = sessionId
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension RetrieveAndGenerateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveAndGenerateOutput(citations: \(Swift.String(describing: citations)), guardrailAction: \(Swift.String(describing: guardrailAction)), sessionId: \(Swift.String(describing: sessionId)), output: \"CONTENT_REDACTED\")"}
}

extension RetrieveAndGenerateOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> RetrieveAndGenerateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RetrieveAndGenerateOutput()
        value.citations = try reader["citations"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.Citation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.guardrailAction = try reader["guardrailAction"].readIfPresent()
        value.output = try reader["output"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput.read(from:))
        value.sessionId = try reader["sessionId"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the response generated from querying the knowledge base. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the output field
    public struct RetrieveAndGenerateOutput {
        /// The response generated from querying the knowledge base.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

public struct RetrieveAndGenerateOutput {
    /// A list of segments of the generated response that are based on sources in the knowledge base, alongside information about the sources.
    public var citations: [BedrockAgentRuntimeClientTypes.Citation]?
    /// Specifies if there is a guardrail intervention in the response.
    public var guardrailAction: BedrockAgentRuntimeClientTypes.GuadrailAction?
    /// Contains the response generated from querying the knowledge base.
    /// This member is required.
    public var output: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput?
    /// The unique identifier of the session. Reuse the same value to continue the same session with the knowledge base.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        citations: [BedrockAgentRuntimeClientTypes.Citation]? = nil,
        guardrailAction: BedrockAgentRuntimeClientTypes.GuadrailAction? = nil,
        output: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.citations = citations
        self.guardrailAction = guardrailAction
        self.output = output
        self.sessionId = sessionId
    }
}

enum RetrieveAndGenerateOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains configuration about the session with the knowledge base. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax) – in the sessionConfiguration field
    public struct RetrieveAndGenerateSessionConfiguration {
        /// The ARN of the KMS key encrypting the session.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum RetrieveAndGenerateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case externalSources
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrieveAndGenerateType] {
            return [
                .externalSources,
                .knowledgeBase,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .externalSources: return "EXTERNAL_SOURCES"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RetrieveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveInput(knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), nextToken: \(Swift.String(describing: nextToken)), retrievalConfiguration: \(Swift.String(describing: retrievalConfiguration)), retrievalQuery: \"CONTENT_REDACTED\")"}
}

extension RetrieveInput {

    static func urlPathProvider(_ value: RetrieveInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/retrieve"
    }
}

extension RetrieveInput {

    static func write(value: RetrieveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nextToken"].write(value.nextToken)
        try writer["retrievalConfiguration"].write(value.retrievalConfiguration, with: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration.write(value:to:))
        try writer["retrievalQuery"].write(value.retrievalQuery, with: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery.write(value:to:))
    }
}

public struct RetrieveInput {
    /// The unique identifier of the knowledge base to query.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// If there are more results than can fit in the response, the response returns a nextToken. Use this token in the nextToken field of another request to retrieve the next batch of results.
    public var nextToken: Swift.String?
    /// Contains configurations for the knowledge base query and retrieval process. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
    public var retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration?
    /// Contains the query to send the knowledge base.
    /// This member is required.
    public var retrievalQuery: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration? = nil,
        retrievalQuery: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.nextToken = nextToken
        self.retrievalConfiguration = retrievalConfiguration
        self.retrievalQuery = retrievalQuery
    }
}

extension RetrieveOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveOutput(nextToken: \(Swift.String(describing: nextToken)), retrievalResults: \"CONTENT_REDACTED\")"}
}

extension RetrieveOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> RetrieveOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RetrieveOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.retrievalResults = try reader["retrievalResults"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct RetrieveOutput {
    /// If there are more results than can fit in the response, the response returns a nextToken. Use this token in the nextToken field of another request to retrieve the next batch of results.
    public var nextToken: Swift.String?
    /// A list of results from querying the knowledge base.
    /// This member is required.
    public var retrievalResults: [BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]?

    public init(
        nextToken: Swift.String? = nil,
        retrievalResults: [BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]? = nil
    )
    {
        self.nextToken = nextToken
        self.retrievalResults = retrievalResults
    }
}

enum RetrieveOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievedReference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrievedReference(content: \"CONTENT_REDACTED\", location: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.RetrievedReference {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievedReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievedReference()
        value.content = try reader["content"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultContent.read(from:))
        value.location = try reader["location"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultLocation.read(from:))
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.Document.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains metadata about a source cited for the generated response. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the retrievedReferences field
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax) – in the retrievedReferences field
    public struct RetrievedReference {
        /// Contains the cited text from the data source.
        public var content: BedrockAgentRuntimeClientTypes.RetrievalResultContent?
        /// Contains information about the location of the data source.
        public var location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation?
        /// Contains metadata attributes and their values for the file in the data source. For more information, see [Metadata and filtering](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-ds.html#kb-ds-metadata).
        public var metadata: [Swift.String:SmithyReadWrite.Document]?

        public init(
            content: BedrockAgentRuntimeClientTypes.RetrievalResultContent? = nil,
            location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation? = nil,
            metadata: [Swift.String:SmithyReadWrite.Document]? = nil
        )
        {
            self.content = content
            self.location = location
            self.metadata = metadata
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ReturnControlPayload: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.ReturnControlPayload {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ReturnControlPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ReturnControlPayload()
        value.invocationInputs = try reader["invocationInputs"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.InvocationInputMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.invocationId = try reader["invocationId"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information to return from the action group that the agent has predicted to invoke. This data type is used in the following API operations:
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public struct ReturnControlPayload {
        /// The identifier of the action group invocation.
        public var invocationId: Swift.String?
        /// A list of objects that contain information about the parameters and inputs that need to be sent into the API operation or function, based on what the agent determines from its session with the user.
        public var invocationInputs: [BedrockAgentRuntimeClientTypes.InvocationInputMember]?

        public init(
            invocationId: Swift.String? = nil,
            invocationInputs: [BedrockAgentRuntimeClientTypes.InvocationInputMember]? = nil
        )
        {
            self.invocationId = invocationId
            self.invocationInputs = invocationInputs
        }
    }

}

extension BedrockAgentRuntimeClientTypes.S3ObjectDoc {

    static func write(value: BedrockAgentRuntimeClientTypes.S3ObjectDoc?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uri"].write(value.uri)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The unique wrapper object of the document from the S3 location.
    public struct S3ObjectDoc {
        /// The file location of the S3 wrapper object.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum SearchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hybrid
        case semantic
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchType] {
            return [
                .hybrid,
                .semantic,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hybrid: return "HYBRID"
            case .semantic: return "SEMANTIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotaExceededException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

/// The number of requests exceeds the service quota. Resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockAgentRuntimeClientTypes.SessionState {

    static func write(value: BedrockAgentRuntimeClientTypes.SessionState?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invocationId"].write(value.invocationId)
        try writer["promptSessionAttributes"].writeMap(value.promptSessionAttributes, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["returnControlInvocationResults"].writeList(value.returnControlInvocationResults, memberWritingClosure: BedrockAgentRuntimeClientTypes.InvocationResultMember.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sessionAttributes"].writeMap(value.sessionAttributes, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains parameters that specify various attributes that persist across a session or prompt. You can define session state attributes as key-value pairs when writing a [Lambda function](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-lambda.html) for an action group or pass them when making an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request. Use session state attributes to control and provide conversational context for your agent and to help customize your agent's behavior. For more information, see [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html).
    public struct SessionState {
        /// The identifier of the invocation of an action. This value must match the invocationId returned in the InvokeAgent response for the action whose results are provided in the returnControlInvocationResults field. For more information, see [Return control to the agent developer](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-returncontrol.html) and [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html).
        public var invocationId: Swift.String?
        /// Contains attributes that persist across a prompt and the values of those attributes. These attributes replace the $prompt_session_attributes$ placeholder variable in the orchestration prompt template. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        public var promptSessionAttributes: [Swift.String:Swift.String]?
        /// Contains information about the results from the action group invocation. For more information, see [Return control to the agent developer](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-returncontrol.html) and [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html). If you include this field, the inputText field will be ignored.
        public var returnControlInvocationResults: [BedrockAgentRuntimeClientTypes.InvocationResultMember]?
        /// Contains attributes that persist across a session and the values of those attributes.
        public var sessionAttributes: [Swift.String:Swift.String]?

        public init(
            invocationId: Swift.String? = nil,
            promptSessionAttributes: [Swift.String:Swift.String]? = nil,
            returnControlInvocationResults: [BedrockAgentRuntimeClientTypes.InvocationResultMember]? = nil,
            sessionAttributes: [Swift.String:Swift.String]? = nil
        )
        {
            self.invocationId = invocationId
            self.promptSessionAttributes = promptSessionAttributes
            self.returnControlInvocationResults = returnControlInvocationResults
            self.sessionAttributes = sessionAttributes
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum Source: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionGroup
        case knowledgeBase
        case parser
        case sdkUnknown(Swift.String)

        public static var allCases: [Source] {
            return [
                .actionGroup,
                .knowledgeBase,
                .parser,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionGroup: return "ACTION_GROUP"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case .parser: return "PARSER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.Span {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Span {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Span()
        value.start = try reader["start"].readIfPresent()
        value.end = try reader["end"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about where the text with a citation begins and ends in the generated output. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the span field
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax) – in the span field
    public struct Span {
        /// Where the text with a citation ends in the generated output.
        public var end: Swift.Int?
        /// Where the text with a citation starts in the generated output.
        public var start: Swift.Int?

        public init(
            end: Swift.Int? = nil,
            start: Swift.Int? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension BedrockAgentRuntimeClientTypes.TextInferenceConfig {

    static func write(value: BedrockAgentRuntimeClientTypes.TextInferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxTokens"].write(value.maxTokens)
        try writer["stopSequences"].writeList(value.stopSequences, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["temperature"].write(value.temperature)
        try writer["topP"].write(value.topp)
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Configuration settings for text generation using a language model via the RetrieveAndGenerate operation. Includes parameters like temperature, top-p, maximum token count, and stop sequences. The valid range of maxTokens depends on the accepted values for your chosen model's inference parameters. To see the inference parameters for your model, see [Inference parameters for foundation models.](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html)
    public struct TextInferenceConfig {
        /// The maximum number of tokens to generate in the output text. Do not use the minimum of 0 or the maximum of 65536. The limit values described here are arbitary values, for actual values consult the limits defined by your specific model.
        public var maxTokens: Swift.Int?
        /// A list of sequences of characters that, if generated, will cause the model to stop generating further tokens. Do not use a minimum length of 1 or a maximum length of 1000. The limit values described here are arbitary values, for actual values consult the limits defined by your specific model.
        public var stopSequences: [Swift.String]?
        /// Controls the random-ness of text generated by the language model, influencing how much the model sticks to the most predictable next words versus exploring more surprising options. A lower temperature value (e.g. 0.2 or 0.3) makes model outputs more deterministic or predictable, while a higher temperature (e.g. 0.8 or 0.9) makes the outputs more creative or unpredictable.
        public var temperature: Swift.Float?
        /// A probability distribution threshold which controls what the model considers for the set of possible next tokens. The model will only consider the top p% of the probability distribution when generating the next token.
        public var topp: Swift.Float?

        public init(
            maxTokens: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topp: Swift.Float? = nil
        )
        {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topp = topp
        }
    }

}

extension BedrockAgentRuntimeClientTypes.TextResponsePart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.TextResponsePart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.TextResponsePart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.TextResponsePart()
        value.text = try reader["text"].readIfPresent()
        value.span = try reader["span"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Span.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains the part of the generated text that contains a citation, alongside where it begins and ends. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax) – in the textResponsePart field
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax) – in the textResponsePart field
    public struct TextResponsePart {
        /// Contains information about where the text with a citation begins and ends in the generated output.
        public var span: BedrockAgentRuntimeClientTypes.Span?
        /// The part of the generated text that contains a citation.
        public var text: Swift.String?

        public init(
            span: BedrockAgentRuntimeClientTypes.Span? = nil,
            text: Swift.String? = nil
        )
        {
            self.span = span
            self.text = text
        }
    }

}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func read(from reader: SmithyJSON.Reader) throws -> ThrottlingException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

/// The number of requests exceeds the limit. Resubmit your request later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockAgentRuntimeClientTypes.Trace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Trace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "guardrailTrace":
                return .guardrailtrace(try reader["guardrailTrace"].read(with: BedrockAgentRuntimeClientTypes.GuardrailTrace.read(from:)))
            case "preProcessingTrace":
                return .preprocessingtrace(try reader["preProcessingTrace"].read(with: BedrockAgentRuntimeClientTypes.PreProcessingTrace.read(from:)))
            case "orchestrationTrace":
                return .orchestrationtrace(try reader["orchestrationTrace"].read(with: BedrockAgentRuntimeClientTypes.OrchestrationTrace.read(from:)))
            case "postProcessingTrace":
                return .postprocessingtrace(try reader["postProcessingTrace"].read(with: BedrockAgentRuntimeClientTypes.PostProcessingTrace.read(from:)))
            case "failureTrace":
                return .failuretrace(try reader["failureTrace"].read(with: BedrockAgentRuntimeClientTypes.FailureTrace.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains one part of the agent's reasoning process and results from calling API actions and querying knowledge bases. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-enablement).
    public enum Trace {
        /// The trace details for a trace defined in the Guardrail filter.
        case guardrailtrace(BedrockAgentRuntimeClientTypes.GuardrailTrace)
        /// Details about the pre-processing step, in which the agent contextualizes and categorizes user inputs.
        case preprocessingtrace(BedrockAgentRuntimeClientTypes.PreProcessingTrace)
        /// Details about the orchestration step, in which the agent determines the order in which actions are executed and which knowledge bases are retrieved.
        case orchestrationtrace(BedrockAgentRuntimeClientTypes.OrchestrationTrace)
        /// Details about the post-processing step, in which the agent shapes the response..
        case postprocessingtrace(BedrockAgentRuntimeClientTypes.PostProcessingTrace)
        /// Contains information about the failure of the interaction.
        case failuretrace(BedrockAgentRuntimeClientTypes.FailureTrace)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.TracePart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes.TracePart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.TracePart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.TracePart()
        value.agentId = try reader["agentId"].readIfPresent()
        value.agentAliasId = try reader["agentAliasId"].readIfPresent()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.agentVersion = try reader["agentVersion"].readIfPresent()
        value.trace = try reader["trace"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Trace.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Contains information about the agent and session, alongside the agent's reasoning process and results from calling API actions and querying knowledge bases and metadata about the trace. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-enablement).
    public struct TracePart {
        /// The unique identifier of the alias of the agent.
        public var agentAliasId: Swift.String?
        /// The unique identifier of the agent.
        public var agentId: Swift.String?
        /// The version of the agent.
        public var agentVersion: Swift.String?
        /// The unique identifier of the session with the agent.
        public var sessionId: Swift.String?
        /// Contains one part of the agent's reasoning process and results from calling API actions and querying knowledge bases. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-enablement).
        public var trace: BedrockAgentRuntimeClientTypes.Trace?

        public init(
            agentAliasId: Swift.String? = nil,
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            trace: BedrockAgentRuntimeClientTypes.Trace? = nil
        )
        {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.sessionId = sessionId
            self.trace = trace
        }
    }

}

extension BedrockAgentRuntimeClientTypes {

    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionGroup
        case askUser
        case finish
        case knowledgeBase
        case reprompt
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .actionGroup,
                .askUser,
                .finish,
                .knowledgeBase,
                .reprompt,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionGroup: return "ACTION_GROUP"
            case .askUser: return "ASK_USER"
            case .finish: return "FINISH"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case .reprompt: return "REPROMPT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func read(from reader: SmithyJSON.Reader) throws -> ValidationException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}
