// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when a request is denied per access permissions
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupName
        case apiPath
        case parameters
        case requestBody
        case verb
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupName = self.actionGroupName {
            try encodeContainer.encode(actionGroupName, forKey: .actionGroupName)
        }
        if let apiPath = self.apiPath {
            try encodeContainer.encode(apiPath, forKey: .apiPath)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for parameter0 in parameters {
                try parametersContainer.encode(parameter0)
            }
        }
        if let requestBody = self.requestBody {
            try encodeContainer.encode(requestBody, forKey: .requestBody)
        }
        if let verb = self.verb {
            try encodeContainer.encode(verb, forKey: .verb)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupName)
        actionGroupName = actionGroupNameDecoded
        let verbDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verb)
        verb = verbDecoded
        let apiPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiPath)
        apiPath = apiPathDecoded
        let parametersContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[BedrockAgentRuntimeClientTypes.Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [BedrockAgentRuntimeClientTypes.Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let requestBodyDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RequestBody.self, forKey: .requestBody)
        requestBody = requestBodyDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionGroupInvocationInput(parameters: \(Swift.String(describing: parameters)), requestBody: \(Swift.String(describing: requestBody)), actionGroupName: \"CONTENT_REDACTED\", apiPath: \"CONTENT_REDACTED\", verb: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// input to lambda used in action group
    public struct ActionGroupInvocationInput: Swift.Equatable {
        /// Agent Trace Action Group Name
        public var actionGroupName: Swift.String?
        /// Agent Trace Action Group API path
        public var apiPath: Swift.String?
        /// list of parameters included in action group invocation
        public var parameters: [BedrockAgentRuntimeClientTypes.Parameter]?
        /// Request Body Content Map
        public var requestBody: BedrockAgentRuntimeClientTypes.RequestBody?
        /// Agent Trace Action Group Action verb
        public var verb: Swift.String?

        public init(
            actionGroupName: Swift.String? = nil,
            apiPath: Swift.String? = nil,
            parameters: [BedrockAgentRuntimeClientTypes.Parameter]? = nil,
            requestBody: BedrockAgentRuntimeClientTypes.RequestBody? = nil,
            verb: Swift.String? = nil
        )
        {
            self.actionGroupName = actionGroupName
            self.apiPath = apiPath
            self.parameters = parameters
            self.requestBody = requestBody
            self.verb = verb
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionGroupInvocationOutput(text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// output from lambda used in action group
    public struct ActionGroupInvocationOutput: Swift.Equatable {
        /// Agent Trace Action Group Lambda Invocation Output String
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.Attribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case citations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let citations = citations {
            var citationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .citations)
            for citation0 in citations {
                try citationsContainer.encode(citation0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let citationsContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.Citation?].self, forKey: .citations)
        var citationsDecoded0:[BedrockAgentRuntimeClientTypes.Citation]? = nil
        if let citationsContainer = citationsContainer {
            citationsDecoded0 = [BedrockAgentRuntimeClientTypes.Citation]()
            for structure0 in citationsContainer {
                if let structure0 = structure0 {
                    citationsDecoded0?.append(structure0)
                }
            }
        }
        citations = citationsDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Citations associated with final agent response
    public struct Attribution: Swift.Equatable {
        /// List of citations
        public var citations: [BedrockAgentRuntimeClientTypes.Citation]?

        public init(
            citations: [BedrockAgentRuntimeClientTypes.Citation]? = nil
        )
        {
            self.citations = citations
        }
    }

}

extension BadGatewayException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceName = self.properties.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        properties.resourceName = resourceNameDecoded
    }
}

extension BadGatewayException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadGatewayExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when a request fails due to dependency like Lambda, Bedrock, STS resource
public struct BadGatewayException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
        /// Non Blank String
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadGatewayException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct BadGatewayExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension BadGatewayExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.Citation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedResponsePart
        case retrievedReferences
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedResponsePart = self.generatedResponsePart {
            try encodeContainer.encode(generatedResponsePart, forKey: .generatedResponsePart)
        }
        if let retrievedReferences = retrievedReferences {
            var retrievedReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .retrievedReferences)
            for retrievedreference0 in retrievedReferences {
                try retrievedReferencesContainer.encode(retrievedreference0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatedResponsePartDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.GeneratedResponsePart.self, forKey: .generatedResponsePart)
        generatedResponsePart = generatedResponsePartDecoded
        let retrievedReferencesContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.RetrievedReference?].self, forKey: .retrievedReferences)
        var retrievedReferencesDecoded0:[BedrockAgentRuntimeClientTypes.RetrievedReference]? = nil
        if let retrievedReferencesContainer = retrievedReferencesContainer {
            retrievedReferencesDecoded0 = [BedrockAgentRuntimeClientTypes.RetrievedReference]()
            for structure0 in retrievedReferencesContainer {
                if let structure0 = structure0 {
                    retrievedReferencesDecoded0?.append(structure0)
                }
            }
        }
        retrievedReferences = retrievedReferencesDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Citation associated with the agent response
    public struct Citation: Swift.Equatable {
        /// Generate response part
        public var generatedResponsePart: BedrockAgentRuntimeClientTypes.GeneratedResponsePart?
        /// list of retrieved references
        public var retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]?

        public init(
            generatedResponsePart: BedrockAgentRuntimeClientTypes.GeneratedResponsePart? = nil,
            retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]? = nil
        )
        {
            self.generatedResponsePart = generatedResponsePart
            self.retrievedReferences = retrievedReferences
        }
    }

}

extension ConflictException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when there is a conflict performing an operation
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// indicates if agent uses default prompt or overriden prompt
    public enum CreationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case overridden
        case sdkUnknown(Swift.String)

        public static var allCases: [CreationMode] {
            return [
                .default,
                .overridden,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .overridden: return "OVERRIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CreationMode(rawValue: rawValue) ?? CreationMode.sdkUnknown(rawValue)
        }
    }
}

extension DependencyFailedException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceName = self.properties.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        properties.resourceName = resourceNameDecoded
    }
}

extension DependencyFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DependencyFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when a request fails due to dependency like Lambda, Bedrock, STS resource due to a customer fault (i.e. bad configuration)
public struct DependencyFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
        /// Non Blank String
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct DependencyFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension DependencyFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.FailureTrace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason
        case traceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.FailureTrace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace Part which is emitted when agent trace could not be generated
    public struct FailureTrace: Swift.Equatable {
        /// Agent Trace Failed Reason String
        public var failureReason: Swift.String?
        /// Identifier for trace
        public var traceId: Swift.String?

        public init(
            failureReason: Swift.String? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.failureReason = failureReason
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.FinalResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.FinalResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FinalResponse(text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// Agent finish output
    public struct FinalResponse: Swift.Equatable {
        /// Agent Trace Action Group Lambda Invocation Output String
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.GeneratedResponsePart: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case textResponsePart
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let textResponsePart = self.textResponsePart {
            try encodeContainer.encode(textResponsePart, forKey: .textResponsePart)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textResponsePartDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.TextResponsePart.self, forKey: .textResponsePart)
        textResponsePart = textResponsePartDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Generate response part
    public struct GeneratedResponsePart: Swift.Equatable {
        /// Text response part
        public var textResponsePart: BedrockAgentRuntimeClientTypes.TextResponsePart?

        public init(
            textResponsePart: BedrockAgentRuntimeClientTypes.TextResponsePart? = nil
        )
        {
            self.textResponsePart = textResponsePart
        }
    }

}

extension BedrockAgentRuntimeClientTypes.InferenceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumLength
        case stopSequences
        case temperature
        case topk = "topK"
        case topp = "topP"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximumLength = self.maximumLength {
            try encodeContainer.encode(maximumLength, forKey: .maximumLength)
        }
        if let stopSequences = stopSequences {
            var stopSequencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopSequences)
            for string0 in stopSequences {
                try stopSequencesContainer.encode(string0)
            }
        }
        if let temperature = self.temperature {
            try encodeContainer.encode(temperature, forKey: .temperature)
        }
        if let topk = self.topk {
            try encodeContainer.encode(topk, forKey: .topk)
        }
        if let topp = self.topp {
            try encodeContainer.encode(topp, forKey: .topp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let temperatureDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .temperature)
        temperature = temperatureDecoded
        let toppDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .topp)
        topp = toppDecoded
        let topkDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .topk)
        topk = topkDecoded
        let maximumLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumLength)
        maximumLength = maximumLengthDecoded
        let stopSequencesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stopSequences)
        var stopSequencesDecoded0:[Swift.String]? = nil
        if let stopSequencesContainer = stopSequencesContainer {
            stopSequencesDecoded0 = [Swift.String]()
            for string0 in stopSequencesContainer {
                if let string0 = string0 {
                    stopSequencesDecoded0?.append(string0)
                }
            }
        }
        stopSequences = stopSequencesDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Configurations for controlling the inference response of an InvokeAgent API call
    public struct InferenceConfiguration: Swift.Equatable {
        /// Maximum length of output
        public var maximumLength: Swift.Int?
        /// List of stop sequences
        public var stopSequences: [Swift.String]?
        /// Controls randomness, higher values increase diversity
        public var temperature: Swift.Float?
        /// Sample from the k most likely next tokens
        public var topk: Swift.Int?
        /// Cumulative probability cutoff for token selection
        public var topp: Swift.Float?

        public init(
            maximumLength: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topk: Swift.Int? = nil,
            topp: Swift.Float? = nil
        )
        {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topk = topk
            self.topp = topp
        }
    }

}

extension InternalServerException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown if there was an unexpected error during processing of request
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupInvocationInput
        case invocationType
        case knowledgeBaseLookupInput
        case traceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupInvocationInput = self.actionGroupInvocationInput {
            try encodeContainer.encode(actionGroupInvocationInput, forKey: .actionGroupInvocationInput)
        }
        if let invocationType = self.invocationType {
            try encodeContainer.encode(invocationType.rawValue, forKey: .invocationType)
        }
        if let knowledgeBaseLookupInput = self.knowledgeBaseLookupInput {
            try encodeContainer.encode(knowledgeBaseLookupInput, forKey: .knowledgeBaseLookupInput)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let invocationTypeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.InvocationType.self, forKey: .invocationType)
        invocationType = invocationTypeDecoded
        let actionGroupInvocationInputDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput.self, forKey: .actionGroupInvocationInput)
        actionGroupInvocationInput = actionGroupInvocationInputDecoded
        let knowledgeBaseLookupInputDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput.self, forKey: .knowledgeBaseLookupInput)
        knowledgeBaseLookupInput = knowledgeBaseLookupInputDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace Part which contains input details for action group or knowledge base
    public struct InvocationInput: Swift.Equatable {
        /// input to lambda used in action group
        public var actionGroupInvocationInput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput?
        /// types of invocations
        public var invocationType: BedrockAgentRuntimeClientTypes.InvocationType?
        /// Input to lambda used in action group
        public var knowledgeBaseLookupInput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput?
        /// Identifier for trace
        public var traceId: Swift.String?

        public init(
            actionGroupInvocationInput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput? = nil,
            invocationType: BedrockAgentRuntimeClientTypes.InvocationType? = nil,
            knowledgeBaseLookupInput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.actionGroupInvocationInput = actionGroupInvocationInput
            self.invocationType = invocationType
            self.knowledgeBaseLookupInput = knowledgeBaseLookupInput
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes {
    /// types of invocations
    public enum InvocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionGroup
        case finish
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [InvocationType] {
            return [
                .actionGroup,
                .finish,
                .knowledgeBase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionGroup: return "ACTION_GROUP"
            case .finish: return "FINISH"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvocationType(rawValue: rawValue) ?? InvocationType.sdkUnknown(rawValue)
        }
    }
}

extension InvokeAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeAgentInput(agentAliasId: \(Swift.String(describing: agentAliasId)), agentId: \(Swift.String(describing: agentId)), enableTrace: \(Swift.String(describing: enableTrace)), endSession: \(Swift.String(describing: endSession)), sessionId: \(Swift.String(describing: sessionId)), sessionState: \(Swift.String(describing: sessionState)), inputText: \"CONTENT_REDACTED\")"}
}

extension InvokeAgentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableTrace
        case endSession
        case inputText
        case sessionState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableTrace = self.enableTrace {
            try encodeContainer.encode(enableTrace, forKey: .enableTrace)
        }
        if let endSession = self.endSession {
            try encodeContainer.encode(endSession, forKey: .endSession)
        }
        if let inputText = self.inputText {
            try encodeContainer.encode(inputText, forKey: .inputText)
        }
        if let sessionState = self.sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
    }
}

extension InvokeAgentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let agentId = agentId else {
            return nil
        }
        guard let agentAliasId = agentAliasId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentAliases/\(agentAliasId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/text"
    }
}

/// InvokeAgent Request
public struct InvokeAgentInput: Swift.Equatable {
    /// Identifier for Agent Alias
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// Identifier for Agent
    /// This member is required.
    public var agentId: Swift.String?
    /// Enable agent trace events for improved debugging
    public var enableTrace: Swift.Bool?
    /// End current session
    public var endSession: Swift.Bool?
    /// Input data in the format specified in the Content-Type request header.
    /// This member is required.
    public var inputText: Swift.String?
    /// Identifier used for the current session
    /// This member is required.
    public var sessionId: Swift.String?
    /// Session state passed by customer. Base64 encoded json string representation of SessionState.
    public var sessionState: BedrockAgentRuntimeClientTypes.SessionState?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        enableTrace: Swift.Bool? = nil,
        endSession: Swift.Bool? = nil,
        inputText: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionState: BedrockAgentRuntimeClientTypes.SessionState? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
        self.enableTrace = enableTrace
        self.endSession = endSession
        self.inputText = inputText
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct InvokeAgentInputBody: Swift.Equatable {
    let sessionState: BedrockAgentRuntimeClientTypes.SessionState?
    let endSession: Swift.Bool?
    let enableTrace: Swift.Bool?
    let inputText: Swift.String?
}

extension InvokeAgentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableTrace
        case endSession
        case inputText
        case sessionState
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionStateDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let endSessionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .endSession)
        endSession = endSessionDecoded
        let enableTraceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableTrace)
        enableTrace = enableTraceDecoded
        let inputTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputText)
        inputText = inputTextDecoded
    }
}

extension InvokeAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-bedrock-agent-content-type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-bedrock-agent-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if case let .stream(stream) = httpResponse.body, let responseDecoder = decoder {
            let messageDecoder = AWSClientRuntime.AWSEventStream.AWSMessageDecoder()
            let decoderStream = ClientRuntime.EventStream.DefaultMessageDecoderStream<BedrockAgentRuntimeClientTypes.ResponseStream>(stream: stream, messageDecoder: messageDecoder, responseDecoder: responseDecoder)
            self.completion = decoderStream.toAsyncStream()
        } else {
            self.completion = nil
        }
    }
}

/// InvokeAgent Response
public struct InvokeAgentOutput: Swift.Equatable {
    /// Inference response from the model in the format specified in the Content-Type response header.
    /// This member is required.
    public var completion: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.ResponseStream, Swift.Error>?
    /// streaming response mimetype of the model
    /// This member is required.
    public var contentType: Swift.String?
    /// streaming response mimetype of the model
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        completion: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.ResponseStream, Swift.Error>? = nil,
        contentType: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.completion = completion
        self.contentType = contentType
        self.sessionId = sessionId
    }
}

enum InvokeAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadGatewayException": return try await BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyFailedException": return try await DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseId
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseLookupInput(knowledgeBaseId: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {
    /// Input to lambda used in action group
    public struct KnowledgeBaseLookupInput: Swift.Equatable {
        /// Agent Trace Action Group Knowledge Base Id
        public var knowledgeBaseId: Swift.String?
        /// Agent Trace Action Group Lambda Invocation Output String
        public var text: Swift.String?

        public init(
            knowledgeBaseId: Swift.String? = nil,
            text: Swift.String? = nil
        )
        {
            self.knowledgeBaseId = knowledgeBaseId
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retrievedReferences
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retrievedReferences = retrievedReferences {
            var retrievedReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .retrievedReferences)
            for retrievedreference0 in retrievedReferences {
                try retrievedReferencesContainer.encode(retrievedreference0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retrievedReferencesContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.RetrievedReference?].self, forKey: .retrievedReferences)
        var retrievedReferencesDecoded0:[BedrockAgentRuntimeClientTypes.RetrievedReference]? = nil
        if let retrievedReferencesContainer = retrievedReferencesContainer {
            retrievedReferencesDecoded0 = [BedrockAgentRuntimeClientTypes.RetrievedReference]()
            for structure0 in retrievedReferencesContainer {
                if let structure0 = structure0 {
                    retrievedReferencesDecoded0?.append(structure0)
                }
            }
        }
        retrievedReferences = retrievedReferencesDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Input to lambda used in action group
    public struct KnowledgeBaseLookupOutput: Swift.Equatable {
        /// list of retrieved references
        public var retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]?

        public init(
            retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]? = nil
        )
        {
            self.retrievedReferences = retrievedReferences
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Knowledge base input query.
    public struct KnowledgeBaseQuery: Swift.Equatable {
        /// Knowledge base input query in text
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vectorSearchConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vectorSearchConfiguration = self.vectorSearchConfiguration {
            try encodeContainer.encode(vectorSearchConfiguration, forKey: .vectorSearchConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorSearchConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration.self, forKey: .vectorSearchConfiguration)
        vectorSearchConfiguration = vectorSearchConfigurationDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Search parameters for retrieving from knowledge base.
    public struct KnowledgeBaseRetrievalConfiguration: Swift.Equatable {
        /// Knowledge base vector search configuration
        /// This member is required.
        public var vectorSearchConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration?

        public init(
            vectorSearchConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration? = nil
        )
        {
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case location
        case score
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrievalResultContent.self, forKey: .content)
        content = contentDecoded
        let locationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrievalResultLocation.self, forKey: .location)
        location = locationDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score)
        score = scoreDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Result item returned from a knowledge base retrieval.
    public struct KnowledgeBaseRetrievalResult: Swift.Equatable {
        /// Content of a retrieval result.
        /// This member is required.
        public var content: BedrockAgentRuntimeClientTypes.RetrievalResultContent?
        /// The source location of a retrieval result.
        public var location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation?
        /// The relevance score of a result.
        public var score: Swift.Double?

        public init(
            content: BedrockAgentRuntimeClientTypes.RetrievalResultContent? = nil,
            location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation? = nil,
            score: Swift.Double? = nil
        )
        {
            self.content = content
            self.location = location
            self.score = score
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseId
        case modelArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let modelArn = self.modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Configurations for retrieval and generation for knowledge base.
    public struct KnowledgeBaseRetrieveAndGenerateConfiguration: Swift.Equatable {
        /// Identifier of the KnowledgeBase
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Arn of a Bedrock model.
        /// This member is required.
        public var modelArn: Swift.String?

        public init(
            knowledgeBaseId: Swift.String? = nil,
            modelArn: Swift.String? = nil
        )
        {
            self.knowledgeBaseId = knowledgeBaseId
            self.modelArn = modelArn
        }
    }

}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfResults
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfResults = self.numberOfResults {
            try encodeContainer.encode(numberOfResults, forKey: .numberOfResults)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfResults)
        numberOfResults = numberOfResultsDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Knowledge base vector search configuration
    public struct KnowledgeBaseVectorSearchConfiguration: Swift.Equatable {
        /// Top-K results to retrieve from knowledge base.
        /// This member is required.
        public var numberOfResults: Swift.Int?

        public init(
            numberOfResults: Swift.Int? = nil
        )
        {
            self.numberOfResults = numberOfResults
        }
    }

}

extension BedrockAgentRuntimeClientTypes.ModelInvocationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inferenceConfiguration
        case overrideLambda
        case parserMode
        case promptCreationMode
        case text
        case traceId
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inferenceConfiguration = self.inferenceConfiguration {
            try encodeContainer.encode(inferenceConfiguration, forKey: .inferenceConfiguration)
        }
        if let overrideLambda = self.overrideLambda {
            try encodeContainer.encode(overrideLambda, forKey: .overrideLambda)
        }
        if let parserMode = self.parserMode {
            try encodeContainer.encode(parserMode.rawValue, forKey: .parserMode)
        }
        if let promptCreationMode = self.promptCreationMode {
            try encodeContainer.encode(promptCreationMode.rawValue, forKey: .promptCreationMode)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.PromptType.self, forKey: .type)
        type = typeDecoded
        let inferenceConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.InferenceConfiguration.self, forKey: .inferenceConfiguration)
        inferenceConfiguration = inferenceConfigurationDecoded
        let overrideLambdaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overrideLambda)
        overrideLambda = overrideLambdaDecoded
        let promptCreationModeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.CreationMode.self, forKey: .promptCreationMode)
        promptCreationMode = promptCreationModeDecoded
        let parserModeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.CreationMode.self, forKey: .parserMode)
        parserMode = parserModeDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.ModelInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace Part which contains information used to call Invoke Model
    public struct ModelInvocationInput: Swift.Equatable {
        /// Configurations for controlling the inference response of an InvokeAgent API call
        public var inferenceConfiguration: BedrockAgentRuntimeClientTypes.InferenceConfiguration?
        /// ARN of a Lambda.
        public var overrideLambda: Swift.String?
        /// indicates if agent uses default prompt or overriden prompt
        public var parserMode: BedrockAgentRuntimeClientTypes.CreationMode?
        /// indicates if agent uses default prompt or overriden prompt
        public var promptCreationMode: BedrockAgentRuntimeClientTypes.CreationMode?
        /// Prompt Message
        public var text: Swift.String?
        /// Identifier for trace
        public var traceId: Swift.String?
        /// types of prompts
        public var type: BedrockAgentRuntimeClientTypes.PromptType?

        public init(
            inferenceConfiguration: BedrockAgentRuntimeClientTypes.InferenceConfiguration? = nil,
            overrideLambda: Swift.String? = nil,
            parserMode: BedrockAgentRuntimeClientTypes.CreationMode? = nil,
            promptCreationMode: BedrockAgentRuntimeClientTypes.CreationMode? = nil,
            text: Swift.String? = nil,
            traceId: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.PromptType? = nil
        )
        {
            self.inferenceConfiguration = inferenceConfiguration
            self.overrideLambda = overrideLambda
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.text = text
            self.traceId = traceId
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes.Observation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupInvocationOutput
        case finalResponse
        case knowledgeBaseLookupOutput
        case repromptResponse
        case traceId
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupInvocationOutput = self.actionGroupInvocationOutput {
            try encodeContainer.encode(actionGroupInvocationOutput, forKey: .actionGroupInvocationOutput)
        }
        if let finalResponse = self.finalResponse {
            try encodeContainer.encode(finalResponse, forKey: .finalResponse)
        }
        if let knowledgeBaseLookupOutput = self.knowledgeBaseLookupOutput {
            try encodeContainer.encode(knowledgeBaseLookupOutput, forKey: .knowledgeBaseLookupOutput)
        }
        if let repromptResponse = self.repromptResponse {
            try encodeContainer.encode(repromptResponse, forKey: .repromptResponse)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let actionGroupInvocationOutputDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput.self, forKey: .actionGroupInvocationOutput)
        actionGroupInvocationOutput = actionGroupInvocationOutputDecoded
        let knowledgeBaseLookupOutputDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput.self, forKey: .knowledgeBaseLookupOutput)
        knowledgeBaseLookupOutput = knowledgeBaseLookupOutputDecoded
        let finalResponseDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.FinalResponse.self, forKey: .finalResponse)
        finalResponse = finalResponseDecoded
        let repromptResponseDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RepromptResponse.self, forKey: .repromptResponse)
        repromptResponse = repromptResponseDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.Observation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace Part which contains output details for action group or knowledge base or final response
    public struct Observation: Swift.Equatable {
        /// output from lambda used in action group
        public var actionGroupInvocationOutput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput?
        /// Agent finish output
        public var finalResponse: BedrockAgentRuntimeClientTypes.FinalResponse?
        /// Input to lambda used in action group
        public var knowledgeBaseLookupOutput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput?
        /// Observation information if there were reprompts
        public var repromptResponse: BedrockAgentRuntimeClientTypes.RepromptResponse?
        /// Identifier for trace
        public var traceId: Swift.String?
        /// types of observations
        public var type: BedrockAgentRuntimeClientTypes.ModelType?

        public init(
            actionGroupInvocationOutput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput? = nil,
            finalResponse: BedrockAgentRuntimeClientTypes.FinalResponse? = nil,
            knowledgeBaseLookupOutput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput? = nil,
            repromptResponse: BedrockAgentRuntimeClientTypes.RepromptResponse? = nil,
            traceId: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.ModelType? = nil
        )
        {
            self.actionGroupInvocationOutput = actionGroupInvocationOutput
            self.finalResponse = finalResponse
            self.knowledgeBaseLookupOutput = knowledgeBaseLookupOutput
            self.repromptResponse = repromptResponse
            self.traceId = traceId
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes.OrchestrationTrace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invocationinput = "invocationInput"
        case modelinvocationinput = "modelInvocationInput"
        case observation
        case rationale
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .invocationinput(invocationinput):
                try container.encode(invocationinput, forKey: .invocationinput)
            case let .modelinvocationinput(modelinvocationinput):
                try container.encode(modelinvocationinput, forKey: .modelinvocationinput)
            case let .observation(observation):
                try container.encode(observation, forKey: .observation)
            case let .rationale(rationale):
                try container.encode(rationale, forKey: .rationale)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let rationaleDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.Rationale.self, forKey: .rationale)
        if let rationale = rationaleDecoded {
            self = .rationale(rationale)
            return
        }
        let invocationinputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.InvocationInput.self, forKey: .invocationinput)
        if let invocationinput = invocationinputDecoded {
            self = .invocationinput(invocationinput)
            return
        }
        let observationDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.Observation.self, forKey: .observation)
        if let observation = observationDecoded {
            self = .observation(observation)
            return
        }
        let modelinvocationinputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.ModelInvocationInput.self, forKey: .modelinvocationinput)
        if let modelinvocationinput = modelinvocationinputDecoded {
            self = .modelinvocationinput(modelinvocationinput)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace contains intermidate response during orchestration
    public enum OrchestrationTrace: Swift.Equatable {
        /// Trace Part which contains information related to reasoning
        case rationale(BedrockAgentRuntimeClientTypes.Rationale)
        /// Trace Part which contains input details for action group or knowledge base
        case invocationinput(BedrockAgentRuntimeClientTypes.InvocationInput)
        /// Trace Part which contains output details for action group or knowledge base or final response
        case observation(BedrockAgentRuntimeClientTypes.Observation)
        /// Trace Part which contains information used to call Invoke Model
        case modelinvocationinput(BedrockAgentRuntimeClientTypes.ModelInvocationInput)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.Parameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// parameters included in action group invocation
    public struct Parameter: Swift.Equatable {
        /// Name of parameter
        public var name: Swift.String?
        /// Type of parameter
        public var type: Swift.String?
        /// Value of parameter
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PayloadPart: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribution
        case bytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribution = self.attribution {
            try encodeContainer.encode(attribution, forKey: .attribution)
        }
        if let bytes = self.bytes {
            try encodeContainer.encode(bytes.base64EncodedString(), forKey: .bytes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bytesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .bytes)
        bytes = bytesDecoded
        let attributionDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.Attribution.self, forKey: .attribution)
        attribution = attributionDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.PayloadPart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Base 64 endoded byte response
    public struct PayloadPart: Swift.Equatable {
        /// Citations associated with final agent response
        public var attribution: BedrockAgentRuntimeClientTypes.Attribution?
        /// PartBody of the payload in bytes
        public var bytes: ClientRuntime.Data?

        public init(
            attribution: BedrockAgentRuntimeClientTypes.Attribution? = nil,
            bytes: ClientRuntime.Data? = nil
        )
        {
            self.attribution = attribution
            self.bytes = bytes
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parsedResponse
        case traceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parsedResponse = self.parsedResponse {
            try encodeContainer.encode(parsedResponse, forKey: .parsedResponse)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let parsedResponseDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse.self, forKey: .parsedResponse)
        parsedResponse = parsedResponseDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace Part which contains information related to postprocessing
    public struct PostProcessingModelInvocationOutput: Swift.Equatable {
        /// Trace Part which contains information if preprocessing was successful
        public var parsedResponse: BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse?
        /// Identifier for trace
        public var traceId: Swift.String?

        public init(
            parsedResponse: BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.parsedResponse = parsedResponse
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace Part which contains information if preprocessing was successful
    public struct PostProcessingParsedResponse: Swift.Equatable {
        /// Agent Trace Output String
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PostProcessingTrace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelinvocationinput = "modelInvocationInput"
        case modelinvocationoutput = "modelInvocationOutput"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .modelinvocationinput(modelinvocationinput):
                try container.encode(modelinvocationinput, forKey: .modelinvocationinput)
            case let .modelinvocationoutput(modelinvocationoutput):
                try container.encode(modelinvocationoutput, forKey: .modelinvocationoutput)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let modelinvocationinputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.ModelInvocationInput.self, forKey: .modelinvocationinput)
        if let modelinvocationinput = modelinvocationinputDecoded {
            self = .modelinvocationinput(modelinvocationinput)
            return
        }
        let modelinvocationoutputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput.self, forKey: .modelinvocationoutput)
        if let modelinvocationoutput = modelinvocationoutputDecoded {
            self = .modelinvocationoutput(modelinvocationoutput)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace Part which contains information related to post processing step
    public enum PostProcessingTrace: Swift.Equatable {
        /// Trace Part which contains information used to call Invoke Model
        case modelinvocationinput(BedrockAgentRuntimeClientTypes.ModelInvocationInput)
        /// Trace Part which contains information related to postprocessing
        case modelinvocationoutput(BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parsedResponse
        case traceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parsedResponse = self.parsedResponse {
            try encodeContainer.encode(parsedResponse, forKey: .parsedResponse)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let parsedResponseDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse.self, forKey: .parsedResponse)
        parsedResponse = parsedResponseDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace Part which contains information related to preprocessing
    public struct PreProcessingModelInvocationOutput: Swift.Equatable {
        /// Trace Part which contains information if preprocessing was successful
        public var parsedResponse: BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse?
        /// Identifier for trace
        public var traceId: Swift.String?

        public init(
            parsedResponse: BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.parsedResponse = parsedResponse
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isValid
        case rationale
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isValid = self.isValid {
            try encodeContainer.encode(isValid, forKey: .isValid)
        }
        if let rationale = self.rationale {
            try encodeContainer.encode(rationale, forKey: .rationale)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rationaleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rationale)
        rationale = rationaleDecoded
        let isValidDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isValid)
        isValid = isValidDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace Part which contains information if preprocessing was successful
    public struct PreProcessingParsedResponse: Swift.Equatable {
        /// Boolean value
        public var isValid: Swift.Bool?
        /// Agent Trace Rationale String
        public var rationale: Swift.String?

        public init(
            isValid: Swift.Bool? = nil,
            rationale: Swift.String? = nil
        )
        {
            self.isValid = isValid
            self.rationale = rationale
        }
    }

}

extension BedrockAgentRuntimeClientTypes.PreProcessingTrace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelinvocationinput = "modelInvocationInput"
        case modelinvocationoutput = "modelInvocationOutput"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .modelinvocationinput(modelinvocationinput):
                try container.encode(modelinvocationinput, forKey: .modelinvocationinput)
            case let .modelinvocationoutput(modelinvocationoutput):
                try container.encode(modelinvocationoutput, forKey: .modelinvocationoutput)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let modelinvocationinputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.ModelInvocationInput.self, forKey: .modelinvocationinput)
        if let modelinvocationinput = modelinvocationinputDecoded {
            self = .modelinvocationinput(modelinvocationinput)
            return
        }
        let modelinvocationoutputDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput.self, forKey: .modelinvocationoutput)
        if let modelinvocationoutput = modelinvocationoutputDecoded {
            self = .modelinvocationoutput(modelinvocationoutput)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace Part which contains information related to preprocessing step
    public enum PreProcessingTrace: Swift.Equatable {
        /// Trace Part which contains information used to call Invoke Model
        case modelinvocationinput(BedrockAgentRuntimeClientTypes.ModelInvocationInput)
        /// Trace Part which contains information related to preprocessing
        case modelinvocationoutput(BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes {
    /// types of prompts
    public enum PromptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knowledgeBaseResponseGeneration
        case orchestration
        case postProcessing
        case preProcessing
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptType] {
            return [
                .knowledgeBaseResponseGeneration,
                .orchestration,
                .postProcessing,
                .preProcessing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBaseResponseGeneration: return "KNOWLEDGE_BASE_RESPONSE_GENERATION"
            case .orchestration: return "ORCHESTRATION"
            case .postProcessing: return "POST_PROCESSING"
            case .preProcessing: return "PRE_PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PromptType(rawValue: rawValue) ?? PromptType.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.Rationale: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
        case traceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traceId = self.traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.Rationale: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace Part which contains information related to reasoning
    public struct Rationale: Swift.Equatable {
        /// Agent Trace Rationale String
        public var text: Swift.String?
        /// Identifier for trace
        public var traceId: Swift.String?

        public init(
            text: Swift.String? = nil,
            traceId: Swift.String? = nil
        )
        {
            self.text = text
            self.traceId = traceId
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RepromptResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.RepromptResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Observation information if there were reprompts
    public struct RepromptResponse: Swift.Equatable {
        /// Parsing error source
        public var source: BedrockAgentRuntimeClientTypes.Source?
        /// Reprompt response text
        public var text: Swift.String?

        public init(
            source: BedrockAgentRuntimeClientTypes.Source? = nil,
            text: Swift.String? = nil
        )
        {
            self.source = source
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RequestBody: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            var contentContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .content)
            for (dictKey0, contentMap0) in content {
                var contentMap0Container = contentContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for parameter1 in contentMap0 {
                    try contentMap0Container.encode(parameter1)
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentContainer = try containerValues.decodeIfPresent([Swift.String: [BedrockAgentRuntimeClientTypes.Parameter?]?].self, forKey: .content)
        var contentDecoded0: [Swift.String:[BedrockAgentRuntimeClientTypes.Parameter]]? = nil
        if let contentContainer = contentContainer {
            contentDecoded0 = [Swift.String:[BedrockAgentRuntimeClientTypes.Parameter]]()
            for (key0, parameters0) in contentContainer {
                var parameters0Decoded0: [BedrockAgentRuntimeClientTypes.Parameter]? = nil
                if let parameters0 = parameters0 {
                    parameters0Decoded0 = [BedrockAgentRuntimeClientTypes.Parameter]()
                    for structure1 in parameters0 {
                        if let structure1 = structure1 {
                            parameters0Decoded0?.append(structure1)
                        }
                    }
                }
                contentDecoded0?[key0] = parameters0Decoded0
            }
        }
        content = contentDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Request Body Content Map
    public struct RequestBody: Swift.Equatable {
        /// Content type paramter map
        public var content: [Swift.String:[BedrockAgentRuntimeClientTypes.Parameter]]?

        public init(
            content: [Swift.String:[BedrockAgentRuntimeClientTypes.Parameter]]? = nil
        )
        {
            self.content = content
        }
    }

}

extension ResourceNotFoundException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when a resource referenced by the operation does not exist
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.ResponseStream: ClientRuntime.MessageUnmarshallable {
    public init(message: ClientRuntime.EventStream.Message, decoder: ClientRuntime.ResponseDecoder) throws {
        switch try message.type() {
        case .event(let params):
            switch params.eventType {
            case "chunk":
                self = .chunk(try decoder.decode(responseBody: message.payload))
            case "trace":
                self = .trace(try decoder.decode(responseBody: message.payload))
            default:
                self = .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
            }
        case .exception(let params):
            let makeError: (ClientRuntime.EventStream.Message, ClientRuntime.EventStream.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                switch params.exceptionType {
                case "internalServerException":
                    return try decoder.decode(responseBody: message.payload) as InternalServerException
                case "validationException":
                    return try decoder.decode(responseBody: message.payload) as ValidationException
                case "resourceNotFoundException":
                    return try decoder.decode(responseBody: message.payload) as ResourceNotFoundException
                case "serviceQuotaExceededException":
                    return try decoder.decode(responseBody: message.payload) as ServiceQuotaExceededException
                case "throttlingException":
                    return try decoder.decode(responseBody: message.payload) as ThrottlingException
                case "accessDeniedException":
                    return try decoder.decode(responseBody: message.payload) as AccessDeniedException
                case "conflictException":
                    return try decoder.decode(responseBody: message.payload) as ConflictException
                case "dependencyFailedException":
                    return try decoder.decode(responseBody: message.payload) as DependencyFailedException
                case "badGatewayException":
                    return try decoder.decode(responseBody: message.payload) as BadGatewayException
                default:
                    let httpResponse = HttpResponse(body: .data(message.payload), statusCode: .ok)
                    return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                }
            }
            let error = try makeError(message, params)
            throw error
        case .error(let params):
            let httpResponse = HttpResponse(body: .data(message.payload), statusCode: .ok)
            throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
        case .unknown(messageType: let messageType):
            throw ClientRuntime.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
        }
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Response body of is a stream
    public enum ResponseStream: Swift.Equatable {
        /// Base 64 endoded byte response
        case chunk(BedrockAgentRuntimeClientTypes.PayloadPart)
        /// Trace Part which contains intermidate response for customer
        case trace(BedrockAgentRuntimeClientTypes.TracePart)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.RetrievalResultContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Content of a retrieval result.
    public struct RetrievalResultContent: Swift.Equatable {
        /// Content of a retrieval result in text
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RetrievalResultLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrievalResultLocationType.self, forKey: .type)
        type = typeDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrievalResultS3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The source location of a retrieval result.
    public struct RetrievalResultLocation: Swift.Equatable {
        /// The S3 location of a retrieval result.
        public var s3Location: BedrockAgentRuntimeClientTypes.RetrievalResultS3Location?
        /// The location type of a retrieval result.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.RetrievalResultLocationType?

        public init(
            s3Location: BedrockAgentRuntimeClientTypes.RetrievalResultS3Location? = nil,
            type: BedrockAgentRuntimeClientTypes.RetrievalResultLocationType? = nil
        )
        {
            self.s3Location = s3Location
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes {
    /// The location type of a retrieval result.
    public enum RetrievalResultLocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrievalResultLocationType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetrievalResultLocationType(rawValue: rawValue) ?? RetrievalResultLocationType.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultS3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// The S3 location of a retrieval result.
    public struct RetrievalResultS3Location: Swift.Equatable {
        /// URI of S3 location
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseConfiguration
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let knowledgeBaseConfiguration = self.knowledgeBaseConfiguration {
            try encodeContainer.encode(knowledgeBaseConfiguration, forKey: .knowledgeBaseConfiguration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrieveAndGenerateType.self, forKey: .type)
        type = typeDecoded
        let knowledgeBaseConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration.self, forKey: .knowledgeBaseConfiguration)
        knowledgeBaseConfiguration = knowledgeBaseConfigurationDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Configures the retrieval and generation for the session.
    public struct RetrieveAndGenerateConfiguration: Swift.Equatable {
        /// Configurations for retrieval and generation for knowledge base.
        public var knowledgeBaseConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration?
        /// The type of RetrieveAndGenerate.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateType?

        public init(
            knowledgeBaseConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration? = nil,
            type: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateType? = nil
        )
        {
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.type = type
        }
    }

}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension RetrieveAndGenerateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveAndGenerateInput(retrieveAndGenerateConfiguration: \(Swift.String(describing: retrieveAndGenerateConfiguration)), sessionConfiguration: \(Swift.String(describing: sessionConfiguration)), sessionId: \(Swift.String(describing: sessionId)), input: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension RetrieveAndGenerateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
        case retrieveAndGenerateConfiguration
        case sessionConfiguration
        case sessionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = self.input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let retrieveAndGenerateConfiguration = self.retrieveAndGenerateConfiguration {
            try encodeContainer.encode(retrieveAndGenerateConfiguration, forKey: .retrieveAndGenerateConfiguration)
        }
        if let sessionConfiguration = self.sessionConfiguration {
            try encodeContainer.encode(sessionConfiguration, forKey: .sessionConfiguration)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension RetrieveAndGenerateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/retrieveAndGenerate"
    }
}

public struct RetrieveAndGenerateInput: Swift.Equatable {
    /// Customer input of the turn
    /// This member is required.
    public var input: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput?
    /// Configures the retrieval and generation for the session.
    public var retrieveAndGenerateConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration?
    /// Configures common parameters of the session.
    public var sessionConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration?
    /// Identifier of the session.
    public var sessionId: Swift.String?

    public init(
        input: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput? = nil,
        retrieveAndGenerateConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration? = nil,
        sessionConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.input = input
        self.retrieveAndGenerateConfiguration = retrieveAndGenerateConfiguration
        self.sessionConfiguration = sessionConfiguration
        self.sessionId = sessionId
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Customer input of the turn
    public struct RetrieveAndGenerateInput: Swift.Equatable {
        /// Customer input of the turn in text
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

struct RetrieveAndGenerateInputBody: Swift.Equatable {
    let sessionId: Swift.String?
    let input: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput?
    let retrieveAndGenerateConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration?
    let sessionConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration?
}

extension RetrieveAndGenerateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input
        case retrieveAndGenerateConfiguration
        case sessionConfiguration
        case sessionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let inputDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput.self, forKey: .input)
        input = inputDecoded
        let retrieveAndGenerateConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration.self, forKey: .retrieveAndGenerateConfiguration)
        retrieveAndGenerateConfiguration = retrieveAndGenerateConfigurationDecoded
        let sessionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration.self, forKey: .sessionConfiguration)
        sessionConfiguration = sessionConfigurationDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension RetrieveAndGenerateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveAndGenerateOutput(citations: \(Swift.String(describing: citations)), sessionId: \(Swift.String(describing: sessionId)), output: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension RetrieveAndGenerateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RetrieveAndGenerateOutputBody = try responseDecoder.decode(responseBody: data)
            self.citations = output.citations
            self.output = output.output
            self.sessionId = output.sessionId
        } else {
            self.citations = nil
            self.output = nil
            self.sessionId = nil
        }
    }
}

public struct RetrieveAndGenerateOutput: Swift.Equatable {
    /// List of citations
    public var citations: [BedrockAgentRuntimeClientTypes.Citation]?
    /// Service response of the turn
    /// This member is required.
    public var output: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput?
    /// Identifier of the session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        citations: [BedrockAgentRuntimeClientTypes.Citation]? = nil,
        output: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.citations = citations
        self.output = output
        self.sessionId = sessionId
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Service response of the turn
    public struct RetrieveAndGenerateOutput: Swift.Equatable {
        /// Service response of the turn in text
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

struct RetrieveAndGenerateOutputBody: Swift.Equatable {
    let sessionId: Swift.String?
    let output: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput?
    let citations: [BedrockAgentRuntimeClientTypes.Citation]?
}

extension RetrieveAndGenerateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case citations
        case output
        case sessionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let outputDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput.self, forKey: .output)
        output = outputDecoded
        let citationsContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.Citation?].self, forKey: .citations)
        var citationsDecoded0:[BedrockAgentRuntimeClientTypes.Citation]? = nil
        if let citationsContainer = citationsContainer {
            citationsDecoded0 = [BedrockAgentRuntimeClientTypes.Citation]()
            for structure0 in citationsContainer {
                if let structure0 = structure0 {
                    citationsDecoded0?.append(structure0)
                }
            }
        }
        citations = citationsDecoded0
    }
}

enum RetrieveAndGenerateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadGatewayException": return try await BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyFailedException": return try await DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Configures common parameters of the session.
    public struct RetrieveAndGenerateSessionConfiguration: Swift.Equatable {
        /// The KMS key arn to encrypt the customer data of the session.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension BedrockAgentRuntimeClientTypes {
    /// The type of RetrieveAndGenerate.
    public enum RetrieveAndGenerateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrieveAndGenerateType] {
            return [
                .knowledgeBase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetrieveAndGenerateType(rawValue: rawValue) ?? RetrieveAndGenerateType.sdkUnknown(rawValue)
        }
    }
}

extension RetrieveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveInput(knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), nextToken: \(Swift.String(describing: nextToken)), retrievalConfiguration: \(Swift.String(describing: retrievalConfiguration)), retrievalQuery: \"CONTENT_REDACTED\")"}
}

extension RetrieveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case retrievalConfiguration
        case retrievalQuery
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let retrievalConfiguration = self.retrievalConfiguration {
            try encodeContainer.encode(retrievalConfiguration, forKey: .retrievalConfiguration)
        }
        if let retrievalQuery = self.retrievalQuery {
            try encodeContainer.encode(retrievalQuery, forKey: .retrievalQuery)
        }
    }
}

extension RetrieveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let knowledgeBaseId = knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/retrieve"
    }
}

public struct RetrieveInput: Swift.Equatable {
    /// Identifier of the KnowledgeBase
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?
    /// Search parameters for retrieving from knowledge base.
    public var retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration?
    /// Knowledge base input query.
    /// This member is required.
    public var retrievalQuery: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration? = nil,
        retrievalQuery: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.nextToken = nextToken
        self.retrievalConfiguration = retrievalConfiguration
        self.retrievalQuery = retrievalQuery
    }
}

struct RetrieveInputBody: Swift.Equatable {
    let retrievalQuery: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery?
    let retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration?
    let nextToken: Swift.String?
}

extension RetrieveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case retrievalConfiguration
        case retrievalQuery
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retrievalQueryDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery.self, forKey: .retrievalQuery)
        retrievalQuery = retrievalQueryDecoded
        let retrievalConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration.self, forKey: .retrievalConfiguration)
        retrievalConfiguration = retrievalConfigurationDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension RetrieveOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveOutput(nextToken: \(Swift.String(describing: nextToken)), retrievalResults: \"CONTENT_REDACTED\")"}
}

extension RetrieveOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RetrieveOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.retrievalResults = output.retrievalResults
        } else {
            self.nextToken = nil
            self.retrievalResults = nil
        }
    }
}

public struct RetrieveOutput: Swift.Equatable {
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?
    /// List of knowledge base retrieval results
    /// This member is required.
    public var retrievalResults: [BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]?

    public init(
        nextToken: Swift.String? = nil,
        retrievalResults: [BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]? = nil
    )
    {
        self.nextToken = nextToken
        self.retrievalResults = retrievalResults
    }
}

struct RetrieveOutputBody: Swift.Equatable {
    let retrievalResults: [BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]?
    let nextToken: Swift.String?
}

extension RetrieveOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case retrievalResults
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retrievalResultsContainer = try containerValues.decodeIfPresent([BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult?].self, forKey: .retrievalResults)
        var retrievalResultsDecoded0:[BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]? = nil
        if let retrievalResultsContainer = retrievalResultsContainer {
            retrievalResultsDecoded0 = [BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]()
            for structure0 in retrievalResultsContainer {
                if let structure0 = structure0 {
                    retrievalResultsDecoded0?.append(structure0)
                }
            }
        }
        retrievalResults = retrievalResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum RetrieveOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadGatewayException": return try await BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyFailedException": return try await DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievedReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrievalResultContent.self, forKey: .content)
        content = contentDecoded
        let locationDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.RetrievalResultLocation.self, forKey: .location)
        location = locationDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Retrieved reference
    public struct RetrievedReference: Swift.Equatable {
        /// Content of a retrieval result.
        public var content: BedrockAgentRuntimeClientTypes.RetrievalResultContent?
        /// The source location of a retrieval result.
        public var location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation?

        public init(
            content: BedrockAgentRuntimeClientTypes.RetrievalResultContent? = nil,
            location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation? = nil
        )
        {
            self.content = content
            self.location = location
        }
    }

}

extension ServiceQuotaExceededException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when a request is made beyond the service quota
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.SessionState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case promptSessionAttributes
        case sessionAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let promptSessionAttributes = promptSessionAttributes {
            var promptSessionAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .promptSessionAttributes)
            for (dictKey0, promptSessionAttributesMap0) in promptSessionAttributes {
                try promptSessionAttributesContainer.encode(promptSessionAttributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sessionAttributes = sessionAttributes {
            var sessionAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sessionAttributes)
            for (dictKey0, sessionAttributesMap0) in sessionAttributes {
                try sessionAttributesContainer.encode(sessionAttributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let promptSessionAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .promptSessionAttributes)
        var promptSessionAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let promptSessionAttributesContainer = promptSessionAttributesContainer {
            promptSessionAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in promptSessionAttributesContainer {
                if let string0 = string0 {
                    promptSessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        promptSessionAttributes = promptSessionAttributesDecoded0
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Session state provided
    public struct SessionState: Swift.Equatable {
        /// Prompt Session Attributes
        public var promptSessionAttributes: [Swift.String:Swift.String]?
        /// Session Attributes
        public var sessionAttributes: [Swift.String:Swift.String]?

        public init(
            promptSessionAttributes: [Swift.String:Swift.String]? = nil,
            sessionAttributes: [Swift.String:Swift.String]? = nil
        )
        {
            self.promptSessionAttributes = promptSessionAttributes
            self.sessionAttributes = sessionAttributes
        }
    }

}

extension BedrockAgentRuntimeClientTypes {
    /// Parsing error source
    public enum Source: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionGroup
        case knowledgeBase
        case parser
        case sdkUnknown(Swift.String)

        public static var allCases: [Source] {
            return [
                .actionGroup,
                .knowledgeBase,
                .parser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionGroup: return "ACTION_GROUP"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case .parser: return "PARSER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Source(rawValue: rawValue) ?? Source.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.Span: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end
        case start
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = self.end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = self.start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .end)
        end = endDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Span of text
    public struct Span: Swift.Equatable {
        /// End of span
        public var end: Swift.Int?
        /// Start of span
        public var start: Swift.Int?

        public init(
            end: Swift.Int? = nil,
            start: Swift.Int? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension BedrockAgentRuntimeClientTypes.TextResponsePart: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case span
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let span = self.span {
            try encodeContainer.encode(span, forKey: .span)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let spanDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.Span.self, forKey: .span)
        span = spanDecoded
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Text response part
    public struct TextResponsePart: Swift.Equatable {
        /// Span of text
        public var span: BedrockAgentRuntimeClientTypes.Span?
        /// Response part in text
        public var text: Swift.String?

        public init(
            span: BedrockAgentRuntimeClientTypes.Span? = nil,
            text: Swift.String? = nil
        )
        {
            self.span = span
            self.text = text
        }
    }

}

extension ThrottlingException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the number of requests exceeds the limit
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.Trace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failuretrace = "failureTrace"
        case orchestrationtrace = "orchestrationTrace"
        case postprocessingtrace = "postProcessingTrace"
        case preprocessingtrace = "preProcessingTrace"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .failuretrace(failuretrace):
                try container.encode(failuretrace, forKey: .failuretrace)
            case let .orchestrationtrace(orchestrationtrace):
                try container.encode(orchestrationtrace, forKey: .orchestrationtrace)
            case let .postprocessingtrace(postprocessingtrace):
                try container.encode(postprocessingtrace, forKey: .postprocessingtrace)
            case let .preprocessingtrace(preprocessingtrace):
                try container.encode(preprocessingtrace, forKey: .preprocessingtrace)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let preprocessingtraceDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.PreProcessingTrace.self, forKey: .preprocessingtrace)
        if let preprocessingtrace = preprocessingtraceDecoded {
            self = .preprocessingtrace(preprocessingtrace)
            return
        }
        let orchestrationtraceDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.OrchestrationTrace.self, forKey: .orchestrationtrace)
        if let orchestrationtrace = orchestrationtraceDecoded {
            self = .orchestrationtrace(orchestrationtrace)
            return
        }
        let postprocessingtraceDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.PostProcessingTrace.self, forKey: .postprocessingtrace)
        if let postprocessingtrace = postprocessingtraceDecoded {
            self = .postprocessingtrace(postprocessingtrace)
            return
        }
        let failuretraceDecoded = try values.decodeIfPresent(BedrockAgentRuntimeClientTypes.FailureTrace.self, forKey: .failuretrace)
        if let failuretrace = failuretraceDecoded {
            self = .failuretrace(failuretrace)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace contains intermidate response for customer
    public enum Trace: Swift.Equatable {
        /// Trace Part which contains information related to preprocessing step
        case preprocessingtrace(BedrockAgentRuntimeClientTypes.PreProcessingTrace)
        /// Trace contains intermidate response during orchestration
        case orchestrationtrace(BedrockAgentRuntimeClientTypes.OrchestrationTrace)
        /// Trace Part which contains information related to post processing step
        case postprocessingtrace(BedrockAgentRuntimeClientTypes.PostProcessingTrace)
        /// Trace Part which is emitted when agent trace could not be generated
        case failuretrace(BedrockAgentRuntimeClientTypes.FailureTrace)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentRuntimeClientTypes.TracePart: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasId
        case agentId
        case sessionId
        case trace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentAliasId = self.agentAliasId {
            try encodeContainer.encode(agentAliasId, forKey: .agentAliasId)
        }
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let trace = self.trace {
            try encodeContainer.encode(trace, forKey: .trace)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasId)
        agentAliasId = agentAliasIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let traceDecoded = try containerValues.decodeIfPresent(BedrockAgentRuntimeClientTypes.Trace.self, forKey: .trace)
        trace = traceDecoded
    }
}

extension BedrockAgentRuntimeClientTypes.TracePart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {
    /// Trace Part which contains intermidate response for customer
    public struct TracePart: Swift.Equatable {
        /// Identifier of the agent alias.
        public var agentAliasId: Swift.String?
        /// Identifier of the agent.
        public var agentId: Swift.String?
        /// Identifier of the session.
        public var sessionId: Swift.String?
        /// Trace contains intermidate response for customer
        public var trace: BedrockAgentRuntimeClientTypes.Trace?

        public init(
            agentAliasId: Swift.String? = nil,
            agentId: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            trace: BedrockAgentRuntimeClientTypes.Trace? = nil
        )
        {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.sessionId = sessionId
            self.trace = trace
        }
    }

}

extension BedrockAgentRuntimeClientTypes {
    /// types of observations
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionGroup
        case askUser
        case finish
        case knowledgeBase
        case reprompt
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .actionGroup,
                .askUser,
                .finish,
                .knowledgeBase,
                .reprompt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionGroup: return "ACTION_GROUP"
            case .askUser: return "ASK_USER"
            case .finish: return "FINISH"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case .reprompt: return "REPROMPT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.properties.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        properties.message = messageDecoded
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the request's input validation fails
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
