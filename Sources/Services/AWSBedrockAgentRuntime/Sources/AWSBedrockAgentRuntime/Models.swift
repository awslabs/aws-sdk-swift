//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyEventStreams.DefaultMessageDecoder
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyEventStreamsAPI.MessageType
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
import struct SmithyEventStreams.DefaultMessageDecoderStream
import struct SmithyEventStreamsAPI.Message
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter
import typealias SmithyEventStreamsAPI.UnmarshalClosure

/// The request is denied because of missing access permissions. Check your permissions and retry your request.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum CustomControlMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case returnControl
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomControlMethod] {
            return [
                .returnControl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .returnControl: return "RETURN_CONTROL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
    public enum ActionGroupExecutor: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
        case lambda(Swift.String)
        /// To return the action group invocation results directly in the InvokeInlineAgent response, specify RETURN_CONTROL.
        case customcontrol(BedrockAgentRuntimeClientTypes.CustomControlMethod)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum ExecutionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lambda
        case returnControl
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionType] {
            return [
                .lambda,
                .returnControl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lambda: return "LAMBDA"
            case .returnControl: return "RETURN_CONTROL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// A parameter for the API request or function.
    public struct Parameter: Swift.Sendable {
        /// The name of the parameter.
        public var name: Swift.String?
        /// The type of the parameter.
        public var type: Swift.String?
        /// The value of the parameter.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.name = name
            self.type = type
            self.value = value
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The parameters in the API request body.
    public struct RequestBody: Swift.Sendable {
        /// The content in the request body.
        public var content: [Swift.String: [BedrockAgentRuntimeClientTypes.Parameter]]?

        public init(
            content: [Swift.String: [BedrockAgentRuntimeClientTypes.Parameter]]? = nil
        ) {
            self.content = content
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the action group being invoked. For more information about the possible structures, see the InvocationInput tab in [OrchestrationTrace](https://docs.aws.amazon.com/bedrock/latest/userguide/trace-orchestration.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    public struct ActionGroupInvocationInput: Swift.Sendable {
        /// The name of the action group.
        public var actionGroupName: Swift.String?
        /// The path to the API to call, based off the action group.
        public var apiPath: Swift.String?
        /// How fulfillment of the action is handled. For more information, see [Handling fulfillment of the action](https://docs.aws.amazon.com/bedrock/latest/userguide/action-handle.html).
        public var executionType: BedrockAgentRuntimeClientTypes.ExecutionType?
        /// The function in the action group to call.
        public var function: Swift.String?
        /// The unique identifier of the invocation. Only returned if the executionType is RETURN_CONTROL.
        public var invocationId: Swift.String?
        /// The parameters in the Lambda input event.
        public var parameters: [BedrockAgentRuntimeClientTypes.Parameter]?
        /// The parameters in the request body for the Lambda input event.
        public var requestBody: BedrockAgentRuntimeClientTypes.RequestBody?
        /// The API method being used, based off the action group.
        public var verb: Swift.String?

        public init(
            actionGroupName: Swift.String? = nil,
            apiPath: Swift.String? = nil,
            executionType: BedrockAgentRuntimeClientTypes.ExecutionType? = nil,
            function: Swift.String? = nil,
            invocationId: Swift.String? = nil,
            parameters: [BedrockAgentRuntimeClientTypes.Parameter]? = nil,
            requestBody: BedrockAgentRuntimeClientTypes.RequestBody? = nil,
            verb: Swift.String? = nil
        ) {
            self.actionGroupName = actionGroupName
            self.apiPath = apiPath
            self.executionType = executionType
            self.function = function
            self.invocationId = invocationId
            self.parameters = parameters
            self.requestBody = requestBody
            self.verb = verb
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionGroupInvocationInput(executionType: \(Swift.String(describing: executionType)), invocationId: \(Swift.String(describing: invocationId)), parameters: \(Swift.String(describing: parameters)), requestBody: \(Swift.String(describing: requestBody)), actionGroupName: \"CONTENT_REDACTED\", apiPath: \"CONTENT_REDACTED\", function: \"CONTENT_REDACTED\", verb: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the JSON-formatted string returned by the API invoked by the action group.
    public struct ActionGroupInvocationOutput: Swift.Sendable {
        /// The JSON-formatted string returned by the API invoked by the action group.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionGroupInvocationOutput(text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    public enum ActionGroupSignature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonCodeinterpreter
        case amazonUserinput
        case anthropicBash
        case anthropicComputer
        case anthropicTexteditor
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionGroupSignature] {
            return [
                .amazonCodeinterpreter,
                .amazonUserinput,
                .anthropicBash,
                .anthropicComputer,
                .anthropicTexteditor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonCodeinterpreter: return "AMAZON.CodeInterpreter"
            case .amazonUserinput: return "AMAZON.UserInput"
            case .anthropicBash: return "ANTHROPIC.Bash"
            case .anthropicComputer: return "ANTHROPIC.Computer"
            case .anthropicTexteditor: return "ANTHROPIC.TextEditor"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum ActionInvocationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case result
        case userConfirmation
        case userConfirmationAndResult
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionInvocationType] {
            return [
                .result,
                .userConfirmation,
                .userConfirmationAndResult
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .result: return "RESULT"
            case .userConfirmation: return "USER_CONFIRMATION"
            case .userConfirmationAndResult: return "USER_CONFIRMATION_AND_RESULT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The identifier information for an Amazon S3 bucket.
    public struct S3Identifier: Swift.Sendable {
        /// The name of the S3 bucket.
        public var s3BucketName: Swift.String?
        /// The S3 object key for the S3 resource.
        public var s3ObjectKey: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3ObjectKey: Swift.String? = nil
        ) {
            self.s3BucketName = s3BucketName
            self.s3ObjectKey = s3ObjectKey
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about the OpenAPI schema for the action group. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html). You can either include the schema directly in the payload field or you can upload it to an S3 bucket and specify the S3 bucket location in the s3 field.
    public enum APISchema: Swift.Sendable {
        /// Contains details about the S3 object containing the OpenAPI schema for the action group.
        case s3(BedrockAgentRuntimeClientTypes.S3Identifier)
        /// The JSON or YAML-formatted payload defining the OpenAPI schema for the action group.
        case payload(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum ParameterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case array
        case boolean
        case integer
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterType] {
            return [
                .array,
                .boolean,
                .integer,
                .number,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .array: return "array"
            case .boolean: return "boolean"
            case .integer: return "integer"
            case .number: return "number"
            case .string: return "string"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about a parameter in a function for an action group.
    public struct ParameterDetail: Swift.Sendable {
        /// A description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        public var description: Swift.String?
        /// Whether the parameter is required for the agent to complete the function for action group invocation.
        public var `required`: Swift.Bool?
        /// The data type of the parameter.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.ParameterType?

        public init(
            description: Swift.String? = nil,
            `required`: Swift.Bool? = nil,
            type: BedrockAgentRuntimeClientTypes.ParameterType? = nil
        ) {
            self.description = description
            self.`required` = `required`
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum RequireConfirmation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [RequireConfirmation] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Defines parameters that the agent needs to invoke from the user to complete the function. Corresponds to an action in an action group.
    public struct FunctionDefinition: Swift.Sendable {
        /// A description of the function and its purpose.
        public var description: Swift.String?
        /// A name for the function.
        /// This member is required.
        public var name: Swift.String?
        /// The parameters that the agent elicits from the user to fulfill the function.
        public var parameters: [Swift.String: BedrockAgentRuntimeClientTypes.ParameterDetail]?
        /// Contains information if user confirmation is required to invoke the function.
        public var requireConfirmation: BedrockAgentRuntimeClientTypes.RequireConfirmation?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String: BedrockAgentRuntimeClientTypes.ParameterDetail]? = nil,
            requireConfirmation: BedrockAgentRuntimeClientTypes.RequireConfirmation? = nil
        ) {
            self.description = description
            self.name = name
            self.parameters = parameters
            self.requireConfirmation = requireConfirmation
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FunctionDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionDefinition(description: \(Swift.String(describing: description)), parameters: \(Swift.String(describing: parameters)), requireConfirmation: \(Swift.String(describing: requireConfirmation)), name: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
    public enum FunctionSchema: Swift.Sendable {
        /// A list of functions that each define an action in the action group.
        case functions([BedrockAgentRuntimeClientTypes.FunctionDefinition])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details of the inline agent's action group.
    public struct AgentActionGroup: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        public var actionGroupExecutor: BedrockAgentRuntimeClientTypes.ActionGroupExecutor?
        /// The name of the action group.
        /// This member is required.
        public var actionGroupName: Swift.String?
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
        public var apiSchema: BedrockAgentRuntimeClientTypes.APISchema?
        /// A description of the action group.
        public var description: Swift.String?
        /// Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
        public var functionSchema: BedrockAgentRuntimeClientTypes.FunctionSchema?
        /// Specify a built-in or computer use action for this action group. If you specify a value, you must leave the description, apiSchema, and actionGroupExecutor fields empty for this action group.
        ///
        /// * To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput.
        ///
        /// * To allow your agent to generate, run, and troubleshoot code when trying to complete a task, set this field to AMAZON.CodeInterpreter.
        ///
        /// * To allow your agent to use an Anthropic computer use tool, specify one of the following values. Computer use is a new Anthropic Claude model capability (in beta) available with Anthropic Claude 3.7 Sonnet and Claude 3.5 Sonnet v2 only. When operating computer use functionality, we recommend taking additional security precautions, such as executing computer actions in virtual environments with restricted data access and limited internet connectivity. For more information, see [Configure an Amazon Bedrock Agent to complete tasks with computer use tools](https://docs.aws.amazon.com/bedrock/latest/userguide/agent-computer-use.html).
        ///
        /// * ANTHROPIC.Computer - Gives the agent permission to use the mouse and keyboard and take screenshots.
        ///
        /// * ANTHROPIC.TextEditor - Gives the agent permission to view, create and edit files.
        ///
        /// * ANTHROPIC.Bash - Gives the agent permission to run commands in a bash shell.
        public var parentActionGroupSignature: BedrockAgentRuntimeClientTypes.ActionGroupSignature?
        /// The configuration settings for a computer use action. Computer use is a new Anthropic Claude model capability (in beta) available with Claude 3.7 Sonnet and Claude 3.5 Sonnet v2 only. For more information, see [Configure an Amazon Bedrock Agent to complete tasks with computer use tools](https://docs.aws.amazon.com/bedrock/latest/userguide/agent-computer-use.html).
        public var parentActionGroupSignatureParams: [Swift.String: Swift.String]?

        public init(
            actionGroupExecutor: BedrockAgentRuntimeClientTypes.ActionGroupExecutor? = nil,
            actionGroupName: Swift.String? = nil,
            apiSchema: BedrockAgentRuntimeClientTypes.APISchema? = nil,
            description: Swift.String? = nil,
            functionSchema: BedrockAgentRuntimeClientTypes.FunctionSchema? = nil,
            parentActionGroupSignature: BedrockAgentRuntimeClientTypes.ActionGroupSignature? = nil,
            parentActionGroupSignatureParams: [Swift.String: Swift.String]? = nil
        ) {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupName = actionGroupName
            self.apiSchema = apiSchema
            self.description = description
            self.functionSchema = functionSchema
            self.parentActionGroupSignature = parentActionGroupSignature
            self.parentActionGroupSignatureParams = parentActionGroupSignatureParams
        }
    }
}

extension BedrockAgentRuntimeClientTypes.AgentActionGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentActionGroup(actionGroupExecutor: \(Swift.String(describing: actionGroupExecutor)), apiSchema: \(Swift.String(describing: apiSchema)), functionSchema: \(Swift.String(describing: functionSchema)), parentActionGroupSignature: \(Swift.String(describing: parentActionGroupSignature)), parentActionGroupSignatureParams: \(Swift.String(describing: parentActionGroupSignatureParams)), actionGroupName: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    public enum AgentCollaboration: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case supervisor
        case supervisorRouter
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentCollaboration] {
            return [
                .disabled,
                .supervisor,
                .supervisorRouter
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .supervisor: return "SUPERVISOR"
            case .supervisorRouter: return "SUPERVISOR_ROUTER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum ConfirmationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case confirm
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfirmationState] {
            return [
                .confirm,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .confirm: return "CONFIRM"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum ImageInputFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gif
        case jpeg
        case png
        case webp
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageInputFormat] {
            return [
                .gif,
                .jpeg,
                .png,
                .webp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gif: return "gif"
            case .jpeg: return "jpeg"
            case .png: return "png"
            case .webp: return "webp"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Details about the source of an input image in the result from a function in the action group invocation.
    public enum ImageInputSource: Swift.Sendable {
        /// The raw image bytes for the image. If you use an Amazon Web Services SDK, you don't need to encode the image bytes in base64.
        case bytes(Foundation.Data)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Details about an image in the result from a function in the action group invocation. You can specify images only when the function is a computer use action. For more information, see [Configure an Amazon Bedrock Agent to complete tasks with computer use tools](https://docs.aws.amazon.com/bedrock/latest/userguide/agent-computer-use.html).
    public struct ImageInput: Swift.Sendable {
        /// The type of image in the result.
        /// This member is required.
        public var format: BedrockAgentRuntimeClientTypes.ImageInputFormat?
        /// The source of the image in the result.
        /// This member is required.
        public var source: BedrockAgentRuntimeClientTypes.ImageInputSource?

        public init(
            format: BedrockAgentRuntimeClientTypes.ImageInputFormat? = nil,
            source: BedrockAgentRuntimeClientTypes.ImageInputSource? = nil
        ) {
            self.format = format
            self.source = source
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the body of the API response. This data type is used in the following API operations:
    ///
    /// * In the returnControlInvocationResults field of the [InvokeAgent request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_RequestSyntax)
    public struct ContentBody: Swift.Sendable {
        /// The body of the API response.
        public var body: Swift.String?
        /// Lists details, including format and source, for the image in the response from the function call. You can specify only one image and the function in the returnControlInvocationResults must be a computer use action. For more information, see [Configure an Amazon Bedrock Agent to complete tasks with computer use tools](https://docs.aws.amazon.com/bedrock/latest/userguide/agent-computer-use.html).
        public var images: [BedrockAgentRuntimeClientTypes.ImageInput]?

        public init(
            body: Swift.String? = nil,
            images: [BedrockAgentRuntimeClientTypes.ImageInput]? = nil
        ) {
            self.body = body
            self.images = images
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum ResponseState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failure
        case reprompt
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseState] {
            return [
                .failure,
                .reprompt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failure: return "FAILURE"
            case .reprompt: return "REPROMPT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the API operation that was called from the action group and the response body that was returned. This data type is used in the following API operations:
    ///
    /// * In the returnControlInvocationResults of the [InvokeAgent request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_RequestSyntax)
    public struct ApiResult: Swift.Sendable {
        /// The action group that the API operation belongs to.
        /// This member is required.
        public var actionGroup: Swift.String?
        /// The agent's ID.
        public var agentId: Swift.String?
        /// The path to the API operation.
        public var apiPath: Swift.String?
        /// Controls the API operations or functions to invoke based on the user confirmation.
        public var confirmationState: BedrockAgentRuntimeClientTypes.ConfirmationState?
        /// The HTTP method for the API operation.
        public var httpMethod: Swift.String?
        /// http status code from API execution response (for example: 200, 400, 500).
        public var httpStatusCode: Swift.Int?
        /// The response body from the API operation. The key of the object is the content type (currently, only TEXT is supported). The response may be returned directly or from the Lambda function.
        public var responseBody: [Swift.String: BedrockAgentRuntimeClientTypes.ContentBody]?
        /// Controls the final response state returned to end user when API/Function execution failed. When this state is FAILURE, the request would fail with dependency failure exception. When this state is REPROMPT, the API/function response will be sent to model for re-prompt
        public var responseState: BedrockAgentRuntimeClientTypes.ResponseState?

        public init(
            actionGroup: Swift.String? = nil,
            agentId: Swift.String? = nil,
            apiPath: Swift.String? = nil,
            confirmationState: BedrockAgentRuntimeClientTypes.ConfirmationState? = nil,
            httpMethod: Swift.String? = nil,
            httpStatusCode: Swift.Int? = nil,
            responseBody: [Swift.String: BedrockAgentRuntimeClientTypes.ContentBody]? = nil,
            responseState: BedrockAgentRuntimeClientTypes.ResponseState? = nil
        ) {
            self.actionGroup = actionGroup
            self.agentId = agentId
            self.apiPath = apiPath
            self.confirmationState = confirmationState
            self.httpMethod = httpMethod
            self.httpStatusCode = httpStatusCode
            self.responseBody = responseBody
            self.responseState = responseState
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ApiResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiResult(actionGroup: \(Swift.String(describing: actionGroup)), agentId: \(Swift.String(describing: agentId)), confirmationState: \(Swift.String(describing: confirmationState)), httpMethod: \(Swift.String(describing: httpMethod)), httpStatusCode: \(Swift.String(describing: httpStatusCode)), responseBody: \(Swift.String(describing: responseBody)), responseState: \(Swift.String(describing: responseState)), apiPath: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the function that was called from the action group and the response that was returned. This data type is used in the following API operations:
    ///
    /// * In the returnControlInvocationResults of the [InvokeAgent request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_RequestSyntax)
    public struct FunctionResult: Swift.Sendable {
        /// The action group that the function belongs to.
        /// This member is required.
        public var actionGroup: Swift.String?
        /// The agent's ID.
        public var agentId: Swift.String?
        /// Contains the user confirmation information about the function that was called.
        public var confirmationState: BedrockAgentRuntimeClientTypes.ConfirmationState?
        /// The name of the function that was called.
        public var function: Swift.String?
        /// The response from the function call using the parameters. The response might be returned directly or from the Lambda function. Specify TEXT or IMAGES. The key of the object is the content type. You can only specify one type. If you specify IMAGES, you can specify only one image. You can specify images only when the function in the returnControlInvocationResults is a computer use action. For more information, see [Configure an Amazon Bedrock Agent to complete tasks with computer use tools](https://docs.aws.amazon.com/bedrock/latest/userguide/agent-computer-use.html).
        public var responseBody: [Swift.String: BedrockAgentRuntimeClientTypes.ContentBody]?
        /// Controls the final response state returned to end user when API/Function execution failed. When this state is FAILURE, the request would fail with dependency failure exception. When this state is REPROMPT, the API/function response will be sent to model for re-prompt
        public var responseState: BedrockAgentRuntimeClientTypes.ResponseState?

        public init(
            actionGroup: Swift.String? = nil,
            agentId: Swift.String? = nil,
            confirmationState: BedrockAgentRuntimeClientTypes.ConfirmationState? = nil,
            function: Swift.String? = nil,
            responseBody: [Swift.String: BedrockAgentRuntimeClientTypes.ContentBody]? = nil,
            responseState: BedrockAgentRuntimeClientTypes.ResponseState? = nil
        ) {
            self.actionGroup = actionGroup
            self.agentId = agentId
            self.confirmationState = confirmationState
            self.function = function
            self.responseBody = responseBody
            self.responseState = responseState
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// A result from the invocation of an action. For more information, see [Return control to the agent developer](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-returncontrol.html) and [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html). This data type is used in the following API operations:
    ///
    /// * [InvokeAgent request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_RequestSyntax)
    public enum InvocationResultMember: Swift.Sendable {
        /// The result from the API response from the action group invocation.
        case apiresult(BedrockAgentRuntimeClientTypes.ApiResult)
        /// The result from the function from the action group invocation.
        case functionresult(BedrockAgentRuntimeClientTypes.FunctionResult)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// An action invocation result.
    public struct ReturnControlResults: Swift.Sendable {
        /// The action's invocation ID.
        public var invocationId: Swift.String?
        /// The action invocation result.
        public var returnControlInvocationResults: [BedrockAgentRuntimeClientTypes.InvocationResultMember]?

        public init(
            invocationId: Swift.String? = nil,
            returnControlInvocationResults: [BedrockAgentRuntimeClientTypes.InvocationResultMember]? = nil
        ) {
            self.invocationId = invocationId
            self.returnControlInvocationResults = returnControlInvocationResults
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum PayloadType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case returnControl
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [PayloadType] {
            return [
                .returnControl,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .returnControl: return "RETURN_CONTROL"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Input for an agent collaborator. The input can be text or an action invocation result.
    public struct AgentCollaboratorInputPayload: Swift.Sendable {
        /// An action invocation result.
        public var returnControlResults: BedrockAgentRuntimeClientTypes.ReturnControlResults?
        /// Input text.
        public var text: Swift.String?
        /// The input type.
        public var type: BedrockAgentRuntimeClientTypes.PayloadType?

        public init(
            returnControlResults: BedrockAgentRuntimeClientTypes.ReturnControlResults? = nil,
            text: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.PayloadType? = nil
        ) {
            self.returnControlResults = returnControlResults
            self.text = text
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.AgentCollaboratorInputPayload: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentCollaboratorInputPayload(returnControlResults: \(Swift.String(describing: returnControlResults)), type: \(Swift.String(describing: type)), text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// An agent collaborator invocation input.
    public struct AgentCollaboratorInvocationInput: Swift.Sendable {
        /// The collaborator's alias ARN.
        public var agentCollaboratorAliasArn: Swift.String?
        /// The collaborator's name.
        public var agentCollaboratorName: Swift.String?
        /// Text or action invocation result input for the collaborator.
        public var input: BedrockAgentRuntimeClientTypes.AgentCollaboratorInputPayload?

        public init(
            agentCollaboratorAliasArn: Swift.String? = nil,
            agentCollaboratorName: Swift.String? = nil,
            input: BedrockAgentRuntimeClientTypes.AgentCollaboratorInputPayload? = nil
        ) {
            self.agentCollaboratorAliasArn = agentCollaboratorAliasArn
            self.agentCollaboratorName = agentCollaboratorName
            self.input = input
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Information about a parameter to provide to the API request. This data type is used in the following API operations:
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public struct ApiParameter: Swift.Sendable {
        /// The name of the parameter.
        public var name: Swift.String?
        /// The data type for the parameter.
        public var type: Swift.String?
        /// The value of the parameter.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.name = name
            self.type = type
            self.value = value
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the parameters in the request body.
    public struct PropertyParameters: Swift.Sendable {
        /// A list of parameters in the request body.
        public var properties: [BedrockAgentRuntimeClientTypes.Parameter]?

        public init(
            properties: [BedrockAgentRuntimeClientTypes.Parameter]? = nil
        ) {
            self.properties = properties
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The request body to provide for the API request, as the agent elicited from the user. This data type is used in the following API operations:
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public struct ApiRequestBody: Swift.Sendable {
        /// The content of the request body. The key of the object in this field is a media type defining the format of the request body.
        public var content: [Swift.String: BedrockAgentRuntimeClientTypes.PropertyParameters]?

        public init(
            content: [Swift.String: BedrockAgentRuntimeClientTypes.PropertyParameters]? = nil
        ) {
            self.content = content
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the API operation that the agent predicts should be called. This data type is used in the following API operations:
    ///
    /// * In the returnControl field of the [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public struct ApiInvocationInput: Swift.Sendable {
        /// The action group that the API operation belongs to.
        /// This member is required.
        public var actionGroup: Swift.String?
        /// Contains information about the API operation to invoke.
        public var actionInvocationType: BedrockAgentRuntimeClientTypes.ActionInvocationType?
        /// The agent's ID.
        public var agentId: Swift.String?
        /// The path to the API operation.
        public var apiPath: Swift.String?
        /// The agent collaborator's name.
        public var collaboratorName: Swift.String?
        /// The HTTP method of the API operation.
        public var httpMethod: Swift.String?
        /// The parameters to provide for the API request, as the agent elicited from the user.
        public var parameters: [BedrockAgentRuntimeClientTypes.ApiParameter]?
        /// The request body to provide for the API request, as the agent elicited from the user.
        public var requestBody: BedrockAgentRuntimeClientTypes.ApiRequestBody?

        public init(
            actionGroup: Swift.String? = nil,
            actionInvocationType: BedrockAgentRuntimeClientTypes.ActionInvocationType? = nil,
            agentId: Swift.String? = nil,
            apiPath: Swift.String? = nil,
            collaboratorName: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            parameters: [BedrockAgentRuntimeClientTypes.ApiParameter]? = nil,
            requestBody: BedrockAgentRuntimeClientTypes.ApiRequestBody? = nil
        ) {
            self.actionGroup = actionGroup
            self.actionInvocationType = actionInvocationType
            self.agentId = agentId
            self.apiPath = apiPath
            self.collaboratorName = collaboratorName
            self.httpMethod = httpMethod
            self.parameters = parameters
            self.requestBody = requestBody
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ApiInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiInvocationInput(actionGroup: \(Swift.String(describing: actionGroup)), actionInvocationType: \(Swift.String(describing: actionInvocationType)), agentId: \(Swift.String(describing: agentId)), httpMethod: \(Swift.String(describing: httpMethod)), parameters: \(Swift.String(describing: parameters)), requestBody: \(Swift.String(describing: requestBody)), apiPath: \"CONTENT_REDACTED\", collaboratorName: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a parameter of the function. This data type is used in the following API operations:
    ///
    /// * In the returnControl field of the [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public struct FunctionParameter: Swift.Sendable {
        /// The name of the parameter.
        public var name: Swift.String?
        /// The data type of the parameter.
        public var type: Swift.String?
        /// The value of the parameter.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.name = name
            self.type = type
            self.value = value
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the function that the agent predicts should be called. This data type is used in the following API operations:
    ///
    /// * In the returnControl field of the [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public struct FunctionInvocationInput: Swift.Sendable {
        /// The action group that the function belongs to.
        /// This member is required.
        public var actionGroup: Swift.String?
        /// Contains information about the function to invoke,
        public var actionInvocationType: BedrockAgentRuntimeClientTypes.ActionInvocationType?
        /// The agent's ID.
        public var agentId: Swift.String?
        /// The collaborator's name.
        public var collaboratorName: Swift.String?
        /// The name of the function.
        public var function: Swift.String?
        /// A list of parameters of the function.
        public var parameters: [BedrockAgentRuntimeClientTypes.FunctionParameter]?

        public init(
            actionGroup: Swift.String? = nil,
            actionInvocationType: BedrockAgentRuntimeClientTypes.ActionInvocationType? = nil,
            agentId: Swift.String? = nil,
            collaboratorName: Swift.String? = nil,
            function: Swift.String? = nil,
            parameters: [BedrockAgentRuntimeClientTypes.FunctionParameter]? = nil
        ) {
            self.actionGroup = actionGroup
            self.actionInvocationType = actionInvocationType
            self.agentId = agentId
            self.collaboratorName = collaboratorName
            self.function = function
            self.parameters = parameters
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FunctionInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionInvocationInput(actionGroup: \(Swift.String(describing: actionGroup)), actionInvocationType: \(Swift.String(describing: actionInvocationType)), agentId: \(Swift.String(describing: agentId)), function: \(Swift.String(describing: function)), parameters: \(Swift.String(describing: parameters)), collaboratorName: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about the API operation or function that the agent predicts should be called. This data type is used in the following API operations:
    ///
    /// * In the returnControl field of the [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public enum InvocationInputMember: Swift.Sendable {
        /// Contains information about the API operation that the agent predicts should be called.
        case apiinvocationinput(BedrockAgentRuntimeClientTypes.ApiInvocationInput)
        /// Contains information about the function that the agent predicts should be called.
        case functioninvocationinput(BedrockAgentRuntimeClientTypes.FunctionInvocationInput)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information to return from the action group that the agent has predicted to invoke. This data type is used in the following API operations:
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)
    public struct ReturnControlPayload: Swift.Sendable {
        /// The identifier of the action group invocation.
        public var invocationId: Swift.String?
        /// A list of objects that contain information about the parameters and inputs that need to be sent into the API operation or function, based on what the agent determines from its session with the user.
        public var invocationInputs: [BedrockAgentRuntimeClientTypes.InvocationInputMember]?

        public init(
            invocationId: Swift.String? = nil,
            invocationInputs: [BedrockAgentRuntimeClientTypes.InvocationInputMember]? = nil
        ) {
            self.invocationId = invocationId
            self.invocationInputs = invocationInputs
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ReturnControlPayload: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Output from an agent collaborator. The output can be text or an action invocation result.
    public struct AgentCollaboratorOutputPayload: Swift.Sendable {
        /// An action invocation result.
        public var returnControlPayload: BedrockAgentRuntimeClientTypes.ReturnControlPayload?
        /// Text output.
        public var text: Swift.String?
        /// The type of output.
        public var type: BedrockAgentRuntimeClientTypes.PayloadType?

        public init(
            returnControlPayload: BedrockAgentRuntimeClientTypes.ReturnControlPayload? = nil,
            text: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.PayloadType? = nil
        ) {
            self.returnControlPayload = returnControlPayload
            self.text = text
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.AgentCollaboratorOutputPayload: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentCollaboratorOutputPayload(type: \(Swift.String(describing: type)), returnControlPayload: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Output from an agent collaborator.
    public struct AgentCollaboratorInvocationOutput: Swift.Sendable {
        /// The output's agent collaborator alias ARN.
        public var agentCollaboratorAliasArn: Swift.String?
        /// The output's agent collaborator name.
        public var agentCollaboratorName: Swift.String?
        /// The output's output.
        public var output: BedrockAgentRuntimeClientTypes.AgentCollaboratorOutputPayload?

        public init(
            agentCollaboratorAliasArn: Swift.String? = nil,
            agentCollaboratorName: Swift.String? = nil,
            output: BedrockAgentRuntimeClientTypes.AgentCollaboratorOutputPayload? = nil
        ) {
            self.agentCollaboratorAliasArn = agentCollaboratorAliasArn
            self.agentCollaboratorName = agentCollaboratorName
            self.output = output
        }
    }
}

/// There was an issue with a dependency due to a server issue. Retry your request.
public struct BadGatewayException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The name of the dependency that caused the issue, such as Amazon Bedrock, Lambda, or STS.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadGatewayException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

/// There was a conflict performing an operation. Resolve the conflict and retry your request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// There was an issue with a dependency. Check the resource configurations and retry the request.
public struct DependencyFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The name of the dependency that caused the issue, such as Amazon Bedrock, Lambda, or STS.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception. If the reason is BEDROCK_MODEL_INVOCATION_SERVICE_UNAVAILABLE, the model invocation service is unavailable. Retry your request.
        public internal(set) var reason: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The number of requests exceeds the service quota. Resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The number of requests exceeds the limit. Resubmit your request later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about an input into the flow.
    public enum FlowInputContent: Swift.Sendable {
        /// The input to send to the prompt flow input node.
        case document(Smithy.Document)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about an input into the prompt flow and where to send it.
    public struct FlowInput: Swift.Sendable {
        /// Contains information about an input into the prompt flow.
        /// This member is required.
        public var content: BedrockAgentRuntimeClientTypes.FlowInputContent?
        /// The name of the input from the flow input node.
        public var nodeInputName: Swift.String?
        /// The name of the flow input node that begins the prompt flow.
        /// This member is required.
        public var nodeName: Swift.String?
        /// The name of the output from the flow input node that begins the prompt flow.
        public var nodeOutputName: Swift.String?

        public init(
            content: BedrockAgentRuntimeClientTypes.FlowInputContent? = nil,
            nodeInputName: Swift.String? = nil,
            nodeName: Swift.String? = nil,
            nodeOutputName: Swift.String? = nil
        ) {
            self.content = content
            self.nodeInputName = nodeInputName
            self.nodeName = nodeName
            self.nodeOutputName = nodeOutputName
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FlowInput(nodeInputName: \(Swift.String(describing: nodeInputName)), nodeName: \(Swift.String(describing: nodeName)), nodeOutputName: \(Swift.String(describing: nodeOutputName)), content: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    public enum PerformanceConfigLatency: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case optimized
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [PerformanceConfigLatency] {
            return [
                .optimized,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .optimized: return "optimized"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Performance settings for a model.
    public struct PerformanceConfiguration: Swift.Sendable {
        /// To use a latency-optimized version of the model, set to optimized.
        public var latency: BedrockAgentRuntimeClientTypes.PerformanceConfigLatency?

        public init(
            latency: BedrockAgentRuntimeClientTypes.PerformanceConfigLatency? = .standard
        ) {
            self.latency = latency
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The performance configuration for a model called with [InvokeFlow].
    public struct ModelPerformanceConfiguration: Swift.Sendable {
        /// The latency configuration for the model.
        public var performanceConfig: BedrockAgentRuntimeClientTypes.PerformanceConfiguration?

        public init(
            performanceConfig: BedrockAgentRuntimeClientTypes.PerformanceConfiguration? = nil
        ) {
            self.performanceConfig = performanceConfig
        }
    }
}

public struct InvokeFlowInput: Swift.Sendable {
    /// Specifies whether to return the trace for the flow or not. Traces track inputs and outputs for nodes in the flow. For more information, see [Track each step in your prompt flow by viewing its trace in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-trace.html).
    public var enableTrace: Swift.Bool?
    /// The unique identifier for the current flow execution. If you don't provide a value, Amazon Bedrock creates the identifier for you.
    public var executionId: Swift.String?
    /// The unique identifier of the flow alias.
    /// This member is required.
    public var flowAliasIdentifier: Swift.String?
    /// The unique identifier of the flow.
    /// This member is required.
    public var flowIdentifier: Swift.String?
    /// A list of objects, each containing information about an input into the flow.
    /// This member is required.
    public var inputs: [BedrockAgentRuntimeClientTypes.FlowInput]?
    /// Model performance settings for the request.
    public var modelPerformanceConfiguration: BedrockAgentRuntimeClientTypes.ModelPerformanceConfiguration?

    public init(
        enableTrace: Swift.Bool? = nil,
        executionId: Swift.String? = nil,
        flowAliasIdentifier: Swift.String? = nil,
        flowIdentifier: Swift.String? = nil,
        inputs: [BedrockAgentRuntimeClientTypes.FlowInput]? = nil,
        modelPerformanceConfiguration: BedrockAgentRuntimeClientTypes.ModelPerformanceConfiguration? = nil
    ) {
        self.enableTrace = enableTrace
        self.executionId = executionId
        self.flowAliasIdentifier = flowAliasIdentifier
        self.flowIdentifier = flowIdentifier
        self.inputs = inputs
        self.modelPerformanceConfiguration = modelPerformanceConfiguration
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum FlowCompletionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inputRequired
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowCompletionReason] {
            return [
                .inputRequired,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inputRequired: return "INPUT_REQUIRED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about why a flow completed.
    public struct FlowCompletionEvent: Swift.Sendable {
        /// The reason that the flow completed.
        /// This member is required.
        public var completionReason: BedrockAgentRuntimeClientTypes.FlowCompletionReason?

        public init(
            completionReason: BedrockAgentRuntimeClientTypes.FlowCompletionReason? = nil
        ) {
            self.completionReason = completionReason
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowCompletionEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The content structure containing input information for multi-turn flow interactions.
    public enum FlowMultiTurnInputContent: Swift.Sendable {
        /// The requested additional input to send back to the multi-turn flow node.
        case document(Smithy.Document)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum NodeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case conditionNode
        case flowInputNode
        case flowOutputNode
        case knowledgeBaseNode
        case lambdaFunctionNode
        case lexNode
        case promptNode
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeType] {
            return [
                .conditionNode,
                .flowInputNode,
                .flowOutputNode,
                .knowledgeBaseNode,
                .lambdaFunctionNode,
                .lexNode,
                .promptNode
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .conditionNode: return "ConditionNode"
            case .flowInputNode: return "FlowInputNode"
            case .flowOutputNode: return "FlowOutputNode"
            case .knowledgeBaseNode: return "KnowledgeBaseNode"
            case .lambdaFunctionNode: return "LambdaFunctionNode"
            case .lexNode: return "LexNode"
            case .promptNode: return "PromptNode"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Response object from the flow multi-turn node requesting additional information.
    public struct FlowMultiTurnInputRequestEvent: Swift.Sendable {
        /// The content payload containing the input request details for the multi-turn interaction.
        /// This member is required.
        public var content: BedrockAgentRuntimeClientTypes.FlowMultiTurnInputContent?
        /// The name of the node in the flow that is requesting the input.
        /// This member is required.
        public var nodeName: Swift.String?
        /// The type of the node in the flow that is requesting the input.
        /// This member is required.
        public var nodeType: BedrockAgentRuntimeClientTypes.NodeType?

        public init(
            content: BedrockAgentRuntimeClientTypes.FlowMultiTurnInputContent? = nil,
            nodeName: Swift.String? = nil,
            nodeType: BedrockAgentRuntimeClientTypes.NodeType? = nil
        ) {
            self.content = content
            self.nodeName = nodeName
            self.nodeType = nodeType
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowMultiTurnInputRequestEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the content in an output from prompt flow invocation.
    public enum FlowOutputContent: Swift.Sendable {
        /// The content in the output.
        case document(Smithy.Document)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about an output from prompt flow invoction.
    public struct FlowOutputEvent: Swift.Sendable {
        /// The content in the output.
        /// This member is required.
        public var content: BedrockAgentRuntimeClientTypes.FlowOutputContent?
        /// The name of the flow output node that the output is from.
        /// This member is required.
        public var nodeName: Swift.String?
        /// The type of the node that the output is from.
        /// This member is required.
        public var nodeType: BedrockAgentRuntimeClientTypes.NodeType?

        public init(
            content: BedrockAgentRuntimeClientTypes.FlowOutputContent? = nil,
            nodeName: Swift.String? = nil,
            nodeType: BedrockAgentRuntimeClientTypes.NodeType? = nil
        ) {
            self.content = content
            self.nodeName = nodeName
            self.nodeType = nodeType
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowOutputEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a condition that was satisfied. For more information, see [Track each step in your prompt flow by viewing its trace in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-trace.html).
    public struct FlowTraceCondition: Swift.Sendable {
        /// The name of the condition.
        /// This member is required.
        public var conditionName: Swift.String?

        public init(
            conditionName: Swift.String? = nil
        ) {
            self.conditionName = conditionName
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceCondition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about an output from a condition node. For more information, see [Track each step in your prompt flow by viewing its trace in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-trace.html).
    public struct FlowTraceConditionNodeResultEvent: Swift.Sendable {
        /// The name of the condition node.
        /// This member is required.
        public var nodeName: Swift.String?
        /// An array of objects containing information about the conditions that were satisfied.
        /// This member is required.
        public var satisfiedConditions: [BedrockAgentRuntimeClientTypes.FlowTraceCondition]?
        /// The date and time that the trace was returned.
        /// This member is required.
        public var timestamp: Foundation.Date?

        public init(
            nodeName: Swift.String? = nil,
            satisfiedConditions: [BedrockAgentRuntimeClientTypes.FlowTraceCondition]? = nil,
            timestamp: Foundation.Date? = nil
        ) {
            self.nodeName = nodeName
            self.satisfiedConditions = satisfiedConditions
            self.timestamp = timestamp
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceConditionNodeResultEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about an action (operation) called by a node in an Amazon Bedrock flow. The service generates action events for calls made by prompt nodes, agent nodes, and Amazon Web Services Lambda nodes.
    public struct FlowTraceNodeActionEvent: Swift.Sendable {
        /// The name of the node that called the operation.
        /// This member is required.
        public var nodeName: Swift.String?
        /// The name of the operation that the node called.
        /// This member is required.
        public var operationName: Swift.String?
        /// The ID of the request that the node made to the operation.
        /// This member is required.
        public var requestId: Swift.String?
        /// The name of the service that the node called.
        /// This member is required.
        public var serviceName: Swift.String?
        /// The date and time that the operation was called.
        /// This member is required.
        public var timestamp: Foundation.Date?

        public init(
            nodeName: Swift.String? = nil,
            operationName: Swift.String? = nil,
            requestId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        ) {
            self.nodeName = nodeName
            self.operationName = operationName
            self.requestId = requestId
            self.serviceName = serviceName
            self.timestamp = timestamp
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceNodeActionEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the content of the node input. For more information, see [Track each step in your prompt flow by viewing its trace in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-trace.html).
    public enum FlowTraceNodeInputContent: Swift.Sendable {
        /// The content of the node input.
        case document(Smithy.Document)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a field in the input into a node. For more information, see [Track each step in your prompt flow by viewing its trace in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-trace.html).
    public struct FlowTraceNodeInputField: Swift.Sendable {
        /// The content of the node input.
        /// This member is required.
        public var content: BedrockAgentRuntimeClientTypes.FlowTraceNodeInputContent?
        /// The name of the node input.
        /// This member is required.
        public var nodeInputName: Swift.String?

        public init(
            content: BedrockAgentRuntimeClientTypes.FlowTraceNodeInputContent? = nil,
            nodeInputName: Swift.String? = nil
        ) {
            self.content = content
            self.nodeInputName = nodeInputName
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceNodeInputField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the input into a node. For more information, see [Track each step in your prompt flow by viewing its trace in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-trace.html).
    public struct FlowTraceNodeInputEvent: Swift.Sendable {
        /// An array of objects containing information about each field in the input.
        /// This member is required.
        public var fields: [BedrockAgentRuntimeClientTypes.FlowTraceNodeInputField]?
        /// The name of the node that received the input.
        /// This member is required.
        public var nodeName: Swift.String?
        /// The date and time that the trace was returned.
        /// This member is required.
        public var timestamp: Foundation.Date?

        public init(
            fields: [BedrockAgentRuntimeClientTypes.FlowTraceNodeInputField]? = nil,
            nodeName: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        ) {
            self.fields = fields
            self.nodeName = nodeName
            self.timestamp = timestamp
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceNodeInputEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the content of the node output. For more information, see [Track each step in your prompt flow by viewing its trace in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-trace.html).
    public enum FlowTraceNodeOutputContent: Swift.Sendable {
        /// The content of the node output.
        case document(Smithy.Document)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a field in the output from a node. For more information, see [Track each step in your prompt flow by viewing its trace in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-trace.html).
    public struct FlowTraceNodeOutputField: Swift.Sendable {
        /// The content of the node output.
        /// This member is required.
        public var content: BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputContent?
        /// The name of the node output.
        /// This member is required.
        public var nodeOutputName: Swift.String?

        public init(
            content: BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputContent? = nil,
            nodeOutputName: Swift.String? = nil
        ) {
            self.content = content
            self.nodeOutputName = nodeOutputName
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the output from a node. For more information, see [Track each step in your prompt flow by viewing its trace in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-trace.html).
    public struct FlowTraceNodeOutputEvent: Swift.Sendable {
        /// An array of objects containing information about each field in the output.
        /// This member is required.
        public var fields: [BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputField]?
        /// The name of the node that yielded the output.
        /// This member is required.
        public var nodeName: Swift.String?
        /// The date and time that the trace was returned.
        /// This member is required.
        public var timestamp: Foundation.Date?

        public init(
            fields: [BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputField]? = nil,
            nodeName: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        ) {
            self.fields = fields
            self.nodeName = nodeName
            self.timestamp = timestamp
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about an input or output for a node in the flow. For more information, see [Track each step in your prompt flow by viewing its trace in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-trace.html).
    public enum FlowTrace: Swift.Sendable {
        /// Contains information about the input into a node.
        case nodeinputtrace(BedrockAgentRuntimeClientTypes.FlowTraceNodeInputEvent)
        /// Contains information about the output from a node.
        case nodeoutputtrace(BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputEvent)
        /// Contains information about an output from a condition node.
        case conditionnoderesulttrace(BedrockAgentRuntimeClientTypes.FlowTraceConditionNodeResultEvent)
        /// Contains information about an action (operation) called by a node. For more information, see [Track each step in your prompt flow by viewing its trace in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-trace.html).
        case nodeactiontrace(BedrockAgentRuntimeClientTypes.FlowTraceNodeActionEvent)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a trace, which tracks an input or output for a node in the flow. For more information, see [Track each step in your prompt flow by viewing its trace in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-trace.html).
    public struct FlowTraceEvent: Swift.Sendable {
        /// The trace object containing information about an input or output for a node in the flow.
        /// This member is required.
        public var trace: BedrockAgentRuntimeClientTypes.FlowTrace?

        public init(
            trace: BedrockAgentRuntimeClientTypes.FlowTrace? = nil
        ) {
            self.trace = trace
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FlowTraceEvent(trace: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// The output of the flow.
    public enum FlowResponseStream: Swift.Sendable {
        /// Contains information about an output from flow invocation.
        case flowoutputevent(BedrockAgentRuntimeClientTypes.FlowOutputEvent)
        /// Contains information about why the flow completed.
        case flowcompletionevent(BedrockAgentRuntimeClientTypes.FlowCompletionEvent)
        /// Contains information about a trace, which tracks an input or output for a node in the flow.
        case flowtraceevent(BedrockAgentRuntimeClientTypes.FlowTraceEvent)
        /// The event stream containing the multi-turn input request information from the flow.
        case flowmultiturninputrequestevent(BedrockAgentRuntimeClientTypes.FlowMultiTurnInputRequestEvent)
        case sdkUnknown(Swift.String)
    }
}

public struct InvokeFlowOutput: Swift.Sendable {
    /// The unique identifier for the current flow execution.
    public var executionId: Swift.String?
    /// The output of the flow, returned as a stream. If there's an error, the error is returned.
    /// This member is required.
    public var responseStream: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.FlowResponseStream, Swift.Error>?

    public init(
        executionId: Swift.String? = nil,
        responseStream: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.FlowResponseStream, Swift.Error>? = nil
    ) {
        self.executionId = executionId
        self.responseStream = responseStream
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum InputQueryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [InputQueryType] {
            return [
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a natural language query to transform into SQL.
    public struct QueryGenerationInput: Swift.Sendable {
        /// The text of the query.
        /// This member is required.
        public var text: Swift.String?
        /// The type of the query.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.InputQueryType?

        public init(
            text: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.InputQueryType? = nil
        ) {
            self.text = text
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.QueryGenerationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum QueryTransformationMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case textToSql
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryTransformationMode] {
            return [
                .textToSql
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .textToSql: return "TEXT_TO_SQL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations for a knowledge base to use in transformation.
    public struct TextToSqlKnowledgeBaseConfiguration: Swift.Sendable {
        /// The ARN of the knowledge base
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?

        public init(
            knowledgeBaseArn: Swift.String? = nil
        ) {
            self.knowledgeBaseArn = knowledgeBaseArn
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum TextToSqlConfigurationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [TextToSqlConfigurationType] {
            return [
                .knowledgeBase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations for transforming text to SQL.
    public struct TextToSqlConfiguration: Swift.Sendable {
        /// Specifies configurations for a knowledge base to use in transformation.
        public var knowledgeBaseConfiguration: BedrockAgentRuntimeClientTypes.TextToSqlKnowledgeBaseConfiguration?
        /// The type of resource to use in transformation.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.TextToSqlConfigurationType?

        public init(
            knowledgeBaseConfiguration: BedrockAgentRuntimeClientTypes.TextToSqlKnowledgeBaseConfiguration? = nil,
            type: BedrockAgentRuntimeClientTypes.TextToSqlConfigurationType? = nil
        ) {
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations for transforming the natural language query into SQL.
    public struct TransformationConfiguration: Swift.Sendable {
        /// The mode of the transformation.
        /// This member is required.
        public var mode: BedrockAgentRuntimeClientTypes.QueryTransformationMode?
        /// Specifies configurations for transforming text to SQL.
        public var textToSqlConfiguration: BedrockAgentRuntimeClientTypes.TextToSqlConfiguration?

        public init(
            mode: BedrockAgentRuntimeClientTypes.QueryTransformationMode? = nil,
            textToSqlConfiguration: BedrockAgentRuntimeClientTypes.TextToSqlConfiguration? = nil
        ) {
            self.mode = mode
            self.textToSqlConfiguration = textToSqlConfiguration
        }
    }
}

public struct GenerateQueryInput: Swift.Sendable {
    /// Specifies information about a natural language query to transform into SQL.
    /// This member is required.
    public var queryGenerationInput: BedrockAgentRuntimeClientTypes.QueryGenerationInput?
    /// Specifies configurations for transforming the natural language query into SQL.
    /// This member is required.
    public var transformationConfiguration: BedrockAgentRuntimeClientTypes.TransformationConfiguration?

    public init(
        queryGenerationInput: BedrockAgentRuntimeClientTypes.QueryGenerationInput? = nil,
        transformationConfiguration: BedrockAgentRuntimeClientTypes.TransformationConfiguration? = nil
    ) {
        self.queryGenerationInput = queryGenerationInput
        self.transformationConfiguration = transformationConfiguration
    }
}

extension GenerateQueryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateQueryInput(transformationConfiguration: \(Swift.String(describing: transformationConfiguration)), queryGenerationInput: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    public enum GeneratedQueryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case redshiftSql
        case sdkUnknown(Swift.String)

        public static var allCases: [GeneratedQueryType] {
            return [
                .redshiftSql
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .redshiftSql: return "REDSHIFT_SQL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a query generated for a natural language query.
    public struct GeneratedQuery: Swift.Sendable {
        /// An SQL query that corresponds to the natural language query.
        public var sql: Swift.String?
        /// The type of transformed query.
        public var type: BedrockAgentRuntimeClientTypes.GeneratedQueryType?

        public init(
            sql: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.GeneratedQueryType? = nil
        ) {
            self.sql = sql
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GeneratedQuery: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct GenerateQueryOutput: Swift.Sendable {
    /// A list of objects, each of which defines a generated query that can correspond to the natural language queries.
    public var queries: [BedrockAgentRuntimeClientTypes.GeneratedQuery]?

    public init(
        queries: [BedrockAgentRuntimeClientTypes.GeneratedQuery]? = nil
    ) {
        self.queries = queries
    }
}

extension GenerateQueryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateQueryOutput(queries: \"CONTENT_REDACTED\")"}
}

/// The model specified in the request is not ready to serve inference requests. The AWS SDK will automatically retry the operation up to 5 times. For information about configuring automatic retries, see [Retry behavior](https://docs.aws.amazon.com/sdkref/latest/guide/feature-retry-behavior.html) in the AWS SDKs and Tools reference guide.
public struct ModelNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelNotReadyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Settings for a model called with [InvokeAgent].
    public struct BedrockModelConfigurations: Swift.Sendable {
        /// The performance configuration for the model.
        public var performanceConfig: BedrockAgentRuntimeClientTypes.PerformanceConfiguration?

        public init(
            performanceConfig: BedrockAgentRuntimeClientTypes.PerformanceConfiguration? = nil
        ) {
            self.performanceConfig = performanceConfig
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// A content block.
    public enum ContentBlock: Swift.Sendable {
        /// The block's text.
        case text(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum ConversationRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assistant
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [ConversationRole] {
            return [
                .assistant,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assistant: return "assistant"
            case .user: return "user"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Details about a message.
    public struct Message: Swift.Sendable {
        /// The message's content.
        /// This member is required.
        public var content: [BedrockAgentRuntimeClientTypes.ContentBlock]?
        /// The message's role.
        /// This member is required.
        public var role: BedrockAgentRuntimeClientTypes.ConversationRole?

        public init(
            content: [BedrockAgentRuntimeClientTypes.ContentBlock]? = nil,
            role: BedrockAgentRuntimeClientTypes.ConversationRole? = nil
        ) {
            self.content = content
            self.role = role
        }
    }
}

extension BedrockAgentRuntimeClientTypes.Message: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Message(role: \(Swift.String(describing: role)), content: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// A conversation history.
    public struct ConversationHistory: Swift.Sendable {
        /// The conversation's messages.
        public var messages: [BedrockAgentRuntimeClientTypes.Message]?

        public init(
            messages: [BedrockAgentRuntimeClientTypes.Message]? = nil
        ) {
            self.messages = messages
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The property contains the file to chat with, along with its attributes.
    public struct ByteContentFile: Swift.Sendable {
        /// The raw bytes of the file to attach. The maximum size of all files that is attached is 10MB. You can attach a maximum of 5 files.
        /// This member is required.
        public var data: Foundation.Data?
        /// The MIME type of data contained in the file used for chat.
        /// This member is required.
        public var mediaType: Swift.String?

        public init(
            data: Foundation.Data? = nil,
            mediaType: Swift.String? = nil
        ) {
            self.data = data
            self.mediaType = mediaType
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ByteContentFile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ByteContentFile(mediaType: \(Swift.String(describing: mediaType)), data: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details of the s3 object where the source file is located.
    public struct S3ObjectFile: Swift.Sendable {
        /// The uri of the s3 object.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        ) {
            self.uri = uri
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum FileSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case byteContent
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [FileSourceType] {
            return [
                .byteContent,
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .byteContent: return "BYTE_CONTENT"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The source file of the content contained in the wrapper object.
    public struct FileSource: Swift.Sendable {
        /// The data and the text of the attached files.
        public var byteContent: BedrockAgentRuntimeClientTypes.ByteContentFile?
        /// The s3 location of the files to attach.
        public var s3Location: BedrockAgentRuntimeClientTypes.S3ObjectFile?
        /// The source type of the files to attach.
        /// This member is required.
        public var sourceType: BedrockAgentRuntimeClientTypes.FileSourceType?

        public init(
            byteContent: BedrockAgentRuntimeClientTypes.ByteContentFile? = nil,
            s3Location: BedrockAgentRuntimeClientTypes.S3ObjectFile? = nil,
            sourceType: BedrockAgentRuntimeClientTypes.FileSourceType? = nil
        ) {
            self.byteContent = byteContent
            self.s3Location = s3Location
            self.sourceType = sourceType
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum FileUseCase: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case chat
        case codeInterpreter
        case sdkUnknown(Swift.String)

        public static var allCases: [FileUseCase] {
            return [
                .chat,
                .codeInterpreter
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .chat: return "CHAT"
            case .codeInterpreter: return "CODE_INTERPRETER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details of the source files.
    public struct InputFile: Swift.Sendable {
        /// The name of the source file.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies where the files are located.
        /// This member is required.
        public var source: BedrockAgentRuntimeClientTypes.FileSource?
        /// Specifies how the source files will be used by the code interpreter.
        /// This member is required.
        public var useCase: BedrockAgentRuntimeClientTypes.FileUseCase?

        public init(
            name: Swift.String? = nil,
            source: BedrockAgentRuntimeClientTypes.FileSource? = nil,
            useCase: BedrockAgentRuntimeClientTypes.FileUseCase? = nil
        ) {
            self.name = name
            self.source = source
            self.useCase = useCase
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Specifies the name that the metadata attribute must match and the value to which to compare the value of the metadata attribute. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html). This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)
    public struct FilterAttribute: Swift.Sendable {
        /// The name that the metadata attribute must match.
        /// This member is required.
        public var key: Swift.String?
        /// The value to whcih to compare the value of the metadata attribute.
        /// This member is required.
        public var value: Smithy.Document?

        public init(
            key: Swift.String? = nil,
            value: Smithy.Document? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum AttributeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case boolean
        case number
        case string
        case stringList
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeType] {
            return [
                .boolean,
                .number,
                .string,
                .stringList
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .number: return "NUMBER"
            case .string: return "STRING"
            case .stringList: return "STRING_LIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Details about a metadata attribute.
    public struct MetadataAttributeSchema: Swift.Sendable {
        /// The attribute's description.
        /// This member is required.
        public var description: Swift.String?
        /// The attribute's key.
        /// This member is required.
        public var key: Swift.String?
        /// The attribute's type.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.AttributeType?

        public init(
            description: Swift.String? = nil,
            key: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.AttributeType? = nil
        ) {
            self.description = description
            self.key = key
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.MetadataAttributeSchema: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Settings for implicit filtering, where a model generates a metadata filter based on the prompt.
    public struct ImplicitFilterConfiguration: Swift.Sendable {
        /// Metadata that can be used in a filter.
        /// This member is required.
        public var metadataAttributes: [BedrockAgentRuntimeClientTypes.MetadataAttributeSchema]?
        /// The model that generates the filter.
        /// This member is required.
        public var modelArn: Swift.String?

        public init(
            metadataAttributes: [BedrockAgentRuntimeClientTypes.MetadataAttributeSchema]? = nil,
            modelArn: Swift.String? = nil
        ) {
            self.metadataAttributes = metadataAttributes
            self.modelArn = modelArn
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ImplicitFilterConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImplicitFilterConfiguration(modelArn: \(Swift.String(describing: modelArn)), metadataAttributes: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    public enum SearchType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hybrid
        case semantic
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchType] {
            return [
                .hybrid,
                .semantic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hybrid: return "HYBRID"
            case .semantic: return "SEMANTIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum RerankingMetadataSelectionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case selective
        case sdkUnknown(Swift.String)

        public static var allCases: [RerankingMetadataSelectionMode] {
            return [
                .all,
                .selective
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .selective: return "SELECTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information for a metadata field to include in or exclude from consideration when reranking.
    public struct FieldForReranking: Swift.Sendable {
        /// The name of a metadata field to include in or exclude from consideration when reranking.
        /// This member is required.
        public var fieldName: Swift.String?

        public init(
            fieldName: Swift.String? = nil
        ) {
            self.fieldName = fieldName
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations for the metadata fields to include or exclude when considering reranking. If you include the fieldsToExclude field, the reranker ignores all the metadata fields that you specify. If you include the fieldsToInclude field, the reranker uses only the metadata fields that you specify and ignores all others. You can include only one of these fields.
    public enum RerankingMetadataSelectiveModeConfiguration: Swift.Sendable {
        /// An array of objects, each of which specifies a metadata field to include in consideration when reranking. The remaining metadata fields are ignored.
        case fieldstoinclude([BedrockAgentRuntimeClientTypes.FieldForReranking])
        /// An array of objects, each of which specifies a metadata field to exclude from consideration when reranking.
        case fieldstoexclude([BedrockAgentRuntimeClientTypes.FieldForReranking])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations for the metadata to use in reranking.
    public struct MetadataConfigurationForReranking: Swift.Sendable {
        /// Specifies whether to consider all metadata when reranking, or only the metadata that you select. If you specify SELECTIVE, include the selectiveModeConfiguration field.
        /// This member is required.
        public var selectionMode: BedrockAgentRuntimeClientTypes.RerankingMetadataSelectionMode?
        /// Contains configurations for the metadata fields to include or exclude when considering reranking.
        public var selectiveModeConfiguration: BedrockAgentRuntimeClientTypes.RerankingMetadataSelectiveModeConfiguration?

        public init(
            selectionMode: BedrockAgentRuntimeClientTypes.RerankingMetadataSelectionMode? = nil,
            selectiveModeConfiguration: BedrockAgentRuntimeClientTypes.RerankingMetadataSelectiveModeConfiguration? = nil
        ) {
            self.selectionMode = selectionMode
            self.selectiveModeConfiguration = selectiveModeConfiguration
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations for an Amazon Bedrock reranker model.
    public struct VectorSearchBedrockRerankingModelConfiguration: Swift.Sendable {
        /// A JSON object whose keys are request fields for the model and whose values are values for those fields.
        public var additionalModelRequestFields: [Swift.String: Smithy.Document]?
        /// The ARN of the reranker model to use.
        /// This member is required.
        public var modelArn: Swift.String?

        public init(
            additionalModelRequestFields: [Swift.String: Smithy.Document]? = nil,
            modelArn: Swift.String? = nil
        ) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.modelArn = modelArn
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations for reranking with an Amazon Bedrock reranker model.
    public struct VectorSearchBedrockRerankingConfiguration: Swift.Sendable {
        /// Contains configurations for the metadata to use in reranking.
        public var metadataConfiguration: BedrockAgentRuntimeClientTypes.MetadataConfigurationForReranking?
        /// Contains configurations for the reranker model.
        /// This member is required.
        public var modelConfiguration: BedrockAgentRuntimeClientTypes.VectorSearchBedrockRerankingModelConfiguration?
        /// The number of results to return after reranking.
        public var numberOfRerankedResults: Swift.Int?

        public init(
            metadataConfiguration: BedrockAgentRuntimeClientTypes.MetadataConfigurationForReranking? = nil,
            modelConfiguration: BedrockAgentRuntimeClientTypes.VectorSearchBedrockRerankingModelConfiguration? = nil,
            numberOfRerankedResults: Swift.Int? = nil
        ) {
            self.metadataConfiguration = metadataConfiguration
            self.modelConfiguration = modelConfiguration
            self.numberOfRerankedResults = numberOfRerankedResults
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum VectorSearchRerankingConfigurationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bedrockRerankingModel
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorSearchRerankingConfigurationType] {
            return [
                .bedrockRerankingModel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bedrockRerankingModel: return "BEDROCK_RERANKING_MODEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations for reranking the retrieved results.
    public struct VectorSearchRerankingConfiguration: Swift.Sendable {
        /// Contains configurations for an Amazon Bedrock reranker model.
        public var bedrockRerankingConfiguration: BedrockAgentRuntimeClientTypes.VectorSearchBedrockRerankingConfiguration?
        /// The type of reranker model.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.VectorSearchRerankingConfigurationType?

        public init(
            bedrockRerankingConfiguration: BedrockAgentRuntimeClientTypes.VectorSearchBedrockRerankingConfiguration? = nil,
            type: BedrockAgentRuntimeClientTypes.VectorSearchRerankingConfigurationType? = nil
        ) {
            self.bedrockRerankingConfiguration = bedrockRerankingConfiguration
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Configurations for streaming.
    public struct StreamingConfigurations: Swift.Sendable {
        /// The guardrail interval to apply as response is generated. By default, the guardrail interval is set to 50 characters. If a larger interval is specified, the response will be generated in larger chunks with fewer ApplyGuardrail calls. The following examples show the response generated for Hello, I am an agent input string. Example response in chunks: Interval set to 3 characters 'Hel', 'lo, ','I am', ' an', ' Age', 'nt' Each chunk has at least 3 characters except for the last chunk Example response in chunks: Interval set to 20 or more characters Hello, I am an Agent
        public var applyGuardrailInterval: Swift.Int?
        /// Specifies whether to enable streaming for the final response. This is set to false by default.
        public var streamFinalResponse: Swift.Bool

        public init(
            applyGuardrailInterval: Swift.Int? = nil,
            streamFinalResponse: Swift.Bool = false
        ) {
            self.applyGuardrailInterval = applyGuardrailInterval
            self.streamFinalResponse = streamFinalResponse
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about where the text with a citation begins and ends in the generated output. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax)  in the span field
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)  in the span field
    public struct Span: Swift.Sendable {
        /// Where the text with a citation ends in the generated output.
        public var end: Swift.Int?
        /// Where the text with a citation starts in the generated output.
        public var start: Swift.Int?

        public init(
            end: Swift.Int? = nil,
            start: Swift.Int? = nil
        ) {
            self.end = end
            self.start = start
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the part of the generated text that contains a citation, alongside where it begins and ends. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax)  in the textResponsePart field
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)  in the textResponsePart field
    public struct TextResponsePart: Swift.Sendable {
        /// Contains information about where the text with a citation begins and ends in the generated output.
        public var span: BedrockAgentRuntimeClientTypes.Span?
        /// The part of the generated text that contains a citation.
        public var text: Swift.String?

        public init(
            span: BedrockAgentRuntimeClientTypes.Span? = nil,
            text: Swift.String? = nil
        ) {
            self.span = span
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.TextResponsePart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains metadata about a part of the generated response that is accompanied by a citation. This data type is used in the following API operations:
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)  in the generatedResponsePart field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax)  in the generatedResponsePart field
    public struct GeneratedResponsePart: Swift.Sendable {
        /// Contains metadata about a textual part of the generated response that is accompanied by a citation.
        public var textResponsePart: BedrockAgentRuntimeClientTypes.TextResponsePart?

        public init(
            textResponsePart: BedrockAgentRuntimeClientTypes.TextResponsePart? = nil
        ) {
            self.textResponsePart = textResponsePart
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GeneratedResponsePart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeneratedResponsePart(textResponsePart: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    public enum RetrievalResultContentColumnType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blob
        case boolean
        case double
        case long
        case null
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrievalResultContentColumnType] {
            return [
                .blob,
                .boolean,
                .double,
                .long,
                .null,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blob: return "BLOB"
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .long: return "LONG"
            case .null: return "NULL"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a column with a cell to return in retrieval.
    public struct RetrievalResultContentColumn: Swift.Sendable {
        /// The name of the column.
        public var columnName: Swift.String?
        /// The value in the column.
        public var columnValue: Swift.String?
        /// The data type of the value.
        public var type: BedrockAgentRuntimeClientTypes.RetrievalResultContentColumnType?

        public init(
            columnName: Swift.String? = nil,
            columnValue: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.RetrievalResultContentColumnType? = nil
        ) {
            self.columnName = columnName
            self.columnValue = columnValue
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultContentColumn: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum RetrievalResultContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case image
        case row
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrievalResultContentType] {
            return [
                .image,
                .row,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .image: return "IMAGE"
            case .row: return "ROW"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a chunk of text from a data source in the knowledge base. If the result is from a structured data source, the cell in the database and the type of the value is also identified. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax)  in the content field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax)  in the content field
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)  in the content field
    public struct RetrievalResultContent: Swift.Sendable {
        /// A data URI with base64-encoded content from the data source. The URI is in the following format: returned in the following format: data:image/jpeg;base64,${base64-encoded string}.
        public var byteContent: Swift.String?
        /// Specifies information about the rows with the cells to return in retrieval.
        public var row: [BedrockAgentRuntimeClientTypes.RetrievalResultContentColumn]?
        /// The cited text from the data source.
        public var text: Swift.String?
        /// The type of content in the retrieval result.
        public var type: BedrockAgentRuntimeClientTypes.RetrievalResultContentType?

        public init(
            byteContent: Swift.String? = nil,
            row: [BedrockAgentRuntimeClientTypes.RetrievalResultContentColumn]? = nil,
            text: Swift.String? = "",
            type: BedrockAgentRuntimeClientTypes.RetrievalResultContentType? = nil
        ) {
            self.byteContent = byteContent
            self.row = row
            self.text = text
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The Confluence data source location.
    public struct RetrievalResultConfluenceLocation: Swift.Sendable {
        /// The Confluence host URL for the data source location.
        public var url: Swift.String?

        public init(
            url: Swift.String? = nil
        ) {
            self.url = url
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the location of a document in a custom data source.
    public struct RetrievalResultCustomDocumentLocation: Swift.Sendable {
        /// The ID of the document.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        ) {
            self.id = id
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The location of a result in Amazon Kendra.
    public struct RetrievalResultKendraDocumentLocation: Swift.Sendable {
        /// The document's uri.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        ) {
            self.uri = uri
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The S3 data source location. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax)  in the s3Location field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax)  in the s3Location field
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)  in the s3Location field
    public struct RetrievalResultS3Location: Swift.Sendable {
        /// The S3 URI for the data source location.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        ) {
            self.uri = uri
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The Salesforce data source location.
    public struct RetrievalResultSalesforceLocation: Swift.Sendable {
        /// The Salesforce host URL for the data source location.
        public var url: Swift.String?

        public init(
            url: Swift.String? = nil
        ) {
            self.url = url
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The SharePoint data source location.
    public struct RetrievalResultSharePointLocation: Swift.Sendable {
        /// The SharePoint site URL for the data source location.
        public var url: Swift.String?

        public init(
            url: Swift.String? = nil
        ) {
            self.url = url
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the SQL query used to retrieve the result.
    public struct RetrievalResultSqlLocation: Swift.Sendable {
        /// The SQL query used to retrieve the result.
        public var query: Swift.String?

        public init(
            query: Swift.String? = nil
        ) {
            self.query = query
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum RetrievalResultLocationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case confluence
        case custom
        case kendra
        case s3
        case salesforce
        case sharepoint
        case sql
        case web
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrievalResultLocationType] {
            return [
                .confluence,
                .custom,
                .kendra,
                .s3,
                .salesforce,
                .sharepoint,
                .sql,
                .web
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .confluence: return "CONFLUENCE"
            case .custom: return "CUSTOM"
            case .kendra: return "KENDRA"
            case .s3: return "S3"
            case .salesforce: return "SALESFORCE"
            case .sharepoint: return "SHAREPOINT"
            case .sql: return "SQL"
            case .web: return "WEB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The web URL/URLs data source location.
    public struct RetrievalResultWebLocation: Swift.Sendable {
        /// The web URL/URLs for the data source location.
        public var url: Swift.String?

        public init(
            url: Swift.String? = nil
        ) {
            self.url = url
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the data source location. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax)  in the location field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax)  in the location field
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)  in the location field
    public struct RetrievalResultLocation: Swift.Sendable {
        /// The Confluence data source location.
        public var confluenceLocation: BedrockAgentRuntimeClientTypes.RetrievalResultConfluenceLocation?
        /// Specifies the location of a document in a custom data source.
        public var customDocumentLocation: BedrockAgentRuntimeClientTypes.RetrievalResultCustomDocumentLocation?
        /// The location of a document in Amazon Kendra.
        public var kendraDocumentLocation: BedrockAgentRuntimeClientTypes.RetrievalResultKendraDocumentLocation?
        /// The S3 data source location.
        public var s3Location: BedrockAgentRuntimeClientTypes.RetrievalResultS3Location?
        /// The Salesforce data source location.
        public var salesforceLocation: BedrockAgentRuntimeClientTypes.RetrievalResultSalesforceLocation?
        /// The SharePoint data source location.
        public var sharePointLocation: BedrockAgentRuntimeClientTypes.RetrievalResultSharePointLocation?
        /// Specifies information about the SQL query used to retrieve the result.
        public var sqlLocation: BedrockAgentRuntimeClientTypes.RetrievalResultSqlLocation?
        /// The type of data source location.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.RetrievalResultLocationType?
        /// The web URL/URLs data source location.
        public var webLocation: BedrockAgentRuntimeClientTypes.RetrievalResultWebLocation?

        public init(
            confluenceLocation: BedrockAgentRuntimeClientTypes.RetrievalResultConfluenceLocation? = nil,
            customDocumentLocation: BedrockAgentRuntimeClientTypes.RetrievalResultCustomDocumentLocation? = nil,
            kendraDocumentLocation: BedrockAgentRuntimeClientTypes.RetrievalResultKendraDocumentLocation? = nil,
            s3Location: BedrockAgentRuntimeClientTypes.RetrievalResultS3Location? = nil,
            salesforceLocation: BedrockAgentRuntimeClientTypes.RetrievalResultSalesforceLocation? = nil,
            sharePointLocation: BedrockAgentRuntimeClientTypes.RetrievalResultSharePointLocation? = nil,
            sqlLocation: BedrockAgentRuntimeClientTypes.RetrievalResultSqlLocation? = nil,
            type: BedrockAgentRuntimeClientTypes.RetrievalResultLocationType? = nil,
            webLocation: BedrockAgentRuntimeClientTypes.RetrievalResultWebLocation? = nil
        ) {
            self.confluenceLocation = confluenceLocation
            self.customDocumentLocation = customDocumentLocation
            self.kendraDocumentLocation = kendraDocumentLocation
            self.s3Location = s3Location
            self.salesforceLocation = salesforceLocation
            self.sharePointLocation = sharePointLocation
            self.sqlLocation = sqlLocation
            self.type = type
            self.webLocation = webLocation
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains metadata about a source cited for the generated response. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax)  in the retrievedReferences field
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)  in the retrievedReferences field
    public struct RetrievedReference: Swift.Sendable {
        /// Contains the cited text from the data source.
        public var content: BedrockAgentRuntimeClientTypes.RetrievalResultContent?
        /// Contains information about the location of the data source.
        public var location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation?
        /// Contains metadata attributes and their values for the file in the data source. For more information, see [Metadata and filtering](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-ds.html#kb-ds-metadata).
        public var metadata: [Swift.String: Smithy.Document]?

        public init(
            content: BedrockAgentRuntimeClientTypes.RetrievalResultContent? = nil,
            location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation? = nil,
            metadata: [Swift.String: Smithy.Document]? = nil
        ) {
            self.content = content
            self.location = location
            self.metadata = metadata
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievedReference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrievedReference(content: \"CONTENT_REDACTED\", location: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// An object containing a segment of the generated response that is based on a source in the knowledge base, alongside information about the source. This data type is used in the following API operations:
    ///
    /// * [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax)  in the citations field
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax)  in the citations field
    public struct Citation: Swift.Sendable {
        /// Contains the generated response and metadata
        public var generatedResponsePart: BedrockAgentRuntimeClientTypes.GeneratedResponsePart?
        /// Contains metadata about the sources cited for the generated response.
        public var retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]?

        public init(
            generatedResponsePart: BedrockAgentRuntimeClientTypes.GeneratedResponsePart? = nil,
            retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]? = nil
        ) {
            self.generatedResponsePart = generatedResponsePart
            self.retrievedReferences = retrievedReferences
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains citations for a part of an agent response.
    public struct Attribution: Swift.Sendable {
        /// A list of citations and related information for a part of an agent response.
        public var citations: [BedrockAgentRuntimeClientTypes.Citation]?

        public init(
            citations: [BedrockAgentRuntimeClientTypes.Citation]? = nil
        ) {
            self.citations = citations
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains a part of an agent response and citations for it.
    public struct PayloadPart: Swift.Sendable {
        /// Contains citations for a part of an agent response.
        public var attribution: BedrockAgentRuntimeClientTypes.Attribution?
        /// A part of the agent response in bytes.
        public var bytes: Foundation.Data?

        public init(
            attribution: BedrockAgentRuntimeClientTypes.Attribution? = nil,
            bytes: Foundation.Data? = nil
        ) {
            self.attribution = attribution
            self.bytes = bytes
        }
    }
}

extension BedrockAgentRuntimeClientTypes.PayloadPart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details of the response from code interpreter.
    public struct OutputFile: Swift.Sendable {
        /// The byte count of files that contains response from code interpreter.
        public var bytes: Foundation.Data?
        /// The name of the file containing response from code interpreter.
        public var name: Swift.String?
        /// The type of file that contains response from the code interpreter.
        public var type: Swift.String?

        public init(
            bytes: Foundation.Data? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        ) {
            self.bytes = bytes
            self.name = name
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.OutputFile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains intermediate response for code interpreter if any files have been generated.
    public struct FilePart: Swift.Sendable {
        /// Files containing intermediate response for the user.
        public var files: [BedrockAgentRuntimeClientTypes.OutputFile]?

        public init(
            files: [BedrockAgentRuntimeClientTypes.OutputFile]? = nil
        ) {
            self.files = files
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FilePart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FilePart(files: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Details about a caller.
    public enum Caller: Swift.Sendable {
        /// The caller's agent alias ARN.
        case agentaliasarn(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The event in the custom orchestration sequence. Events are the responses which the custom orchestration Lambda function sends as response to the agent.
    public struct CustomOrchestrationTraceEvent: Swift.Sendable {
        /// The text that prompted the event at this step.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.CustomOrchestrationTraceEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The trace behavior for the custom orchestration.
    public struct CustomOrchestrationTrace: Swift.Sendable {
        /// The event details used with the custom orchestration.
        public var event: BedrockAgentRuntimeClientTypes.CustomOrchestrationTraceEvent?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            event: BedrockAgentRuntimeClientTypes.CustomOrchestrationTraceEvent? = nil,
            traceId: Swift.String? = nil
        ) {
            self.event = event
            self.traceId = traceId
        }
    }
}

extension BedrockAgentRuntimeClientTypes.CustomOrchestrationTrace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the failure of the interaction.
    public struct FailureTrace: Swift.Sendable {
        /// The reason the interaction failed.
        public var failureReason: Swift.String?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            failureReason: Swift.String? = nil,
            traceId: Swift.String? = nil
        ) {
            self.failureReason = failureReason
            self.traceId = traceId
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FailureTrace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case intervened
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailAction] {
            return [
                .intervened,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .intervened: return "INTERVENED"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailContentPolicyAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blocked
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentPolicyAction] {
            return [
                .blocked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blocked: return "BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailContentFilterConfidence: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFilterConfidence] {
            return [
                .high,
                .low,
                .medium,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailContentFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hate
        case insults
        case misconduct
        case promptAttack
        case sexual
        case violence
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFilterType] {
            return [
                .hate,
                .insults,
                .misconduct,
                .promptAttack,
                .sexual,
                .violence
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hate: return "HATE"
            case .insults: return "INSULTS"
            case .misconduct: return "MISCONDUCT"
            case .promptAttack: return "PROMPT_ATTACK"
            case .sexual: return "SEXUAL"
            case .violence: return "VIOLENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Details of the content filter used in the Guardrail.
    public struct GuardrailContentFilter: Swift.Sendable {
        /// The action placed on the content by the Guardrail filter.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAction?
        /// The confidence level regarding the content detected in the filter by the Guardrail.
        public var confidence: BedrockAgentRuntimeClientTypes.GuardrailContentFilterConfidence?
        /// The type of content detected in the filter by the Guardrail.
        public var type: BedrockAgentRuntimeClientTypes.GuardrailContentFilterType?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAction? = nil,
            confidence: BedrockAgentRuntimeClientTypes.GuardrailContentFilterConfidence? = nil,
            type: BedrockAgentRuntimeClientTypes.GuardrailContentFilterType? = nil
        ) {
            self.action = action
            self.confidence = confidence
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailContentFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The details of the policy assessment in the Guardrails filter.
    public struct GuardrailContentPolicyAssessment: Swift.Sendable {
        /// The filter details of the policy assessment used in the Guardrails filter.
        public var filters: [BedrockAgentRuntimeClientTypes.GuardrailContentFilter]?

        public init(
            filters: [BedrockAgentRuntimeClientTypes.GuardrailContentFilter]? = nil
        ) {
            self.filters = filters
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailSensitiveInformationPolicyAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anonymized
        case blocked
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailSensitiveInformationPolicyAction] {
            return [
                .anonymized,
                .blocked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anonymized: return "ANONYMIZED"
            case .blocked: return "BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailPiiEntityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case address
        case age
        case awsAccessKey
        case awsSecretKey
        case caHealthNumber
        case caSocialInsuranceNumber
        case creditDebitCardCvv
        case creditDebitCardExpiry
        case creditDebitCardNumber
        case driverId
        case email
        case internationalBankAccountNumber
        case ipAddress
        case licensePlate
        case macAddress
        case name
        case password
        case phone
        case pin
        case swiftCode
        case ukNationalHealthServiceNumber
        case ukNationalInsuranceNumber
        case ukUniqueTaxpayerReferenceNumber
        case url
        case username
        case usBankAccountNumber
        case usBankRoutingNumber
        case usIndividualTaxIdentificationNumber
        case usPassportNumber
        case usSocialSecurityNumber
        case vehicleIdentificationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailPiiEntityType] {
            return [
                .address,
                .age,
                .awsAccessKey,
                .awsSecretKey,
                .caHealthNumber,
                .caSocialInsuranceNumber,
                .creditDebitCardCvv,
                .creditDebitCardExpiry,
                .creditDebitCardNumber,
                .driverId,
                .email,
                .internationalBankAccountNumber,
                .ipAddress,
                .licensePlate,
                .macAddress,
                .name,
                .password,
                .phone,
                .pin,
                .swiftCode,
                .ukNationalHealthServiceNumber,
                .ukNationalInsuranceNumber,
                .ukUniqueTaxpayerReferenceNumber,
                .url,
                .username,
                .usBankAccountNumber,
                .usBankRoutingNumber,
                .usIndividualTaxIdentificationNumber,
                .usPassportNumber,
                .usSocialSecurityNumber,
                .vehicleIdentificationNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .age: return "AGE"
            case .awsAccessKey: return "AWS_ACCESS_KEY"
            case .awsSecretKey: return "AWS_SECRET_KEY"
            case .caHealthNumber: return "CA_HEALTH_NUMBER"
            case .caSocialInsuranceNumber: return "CA_SOCIAL_INSURANCE_NUMBER"
            case .creditDebitCardCvv: return "CREDIT_DEBIT_CARD_CVV"
            case .creditDebitCardExpiry: return "CREDIT_DEBIT_CARD_EXPIRY"
            case .creditDebitCardNumber: return "CREDIT_DEBIT_CARD_NUMBER"
            case .driverId: return "DRIVER_ID"
            case .email: return "EMAIL"
            case .internationalBankAccountNumber: return "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
            case .ipAddress: return "IP_ADDRESS"
            case .licensePlate: return "LICENSE_PLATE"
            case .macAddress: return "MAC_ADDRESS"
            case .name: return "NAME"
            case .password: return "PASSWORD"
            case .phone: return "PHONE"
            case .pin: return "PIN"
            case .swiftCode: return "SWIFT_CODE"
            case .ukNationalHealthServiceNumber: return "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
            case .ukNationalInsuranceNumber: return "UK_NATIONAL_INSURANCE_NUMBER"
            case .ukUniqueTaxpayerReferenceNumber: return "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
            case .url: return "URL"
            case .username: return "USERNAME"
            case .usBankAccountNumber: return "US_BANK_ACCOUNT_NUMBER"
            case .usBankRoutingNumber: return "US_BANK_ROUTING_NUMBER"
            case .usIndividualTaxIdentificationNumber: return "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
            case .usPassportNumber: return "US_PASSPORT_NUMBER"
            case .usSocialSecurityNumber: return "US_SOCIAL_SECURITY_NUMBER"
            case .vehicleIdentificationNumber: return "VEHICLE_IDENTIFICATION_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The Guardrail filter to identify and remove personally identifiable information (PII).
    public struct GuardrailPiiEntityFilter: Swift.Sendable {
        /// The action of the Guardrail filter to identify and remove PII.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAction?
        /// The match to settings in the Guardrail filter to identify and remove PII.
        public var match: Swift.String?
        /// The type of PII the Guardrail filter has identified and removed.
        public var type: BedrockAgentRuntimeClientTypes.GuardrailPiiEntityType?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAction? = nil,
            match: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.GuardrailPiiEntityType? = nil
        ) {
            self.action = action
            self.match = match
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The details for the regex filter used in the Guardrail.
    public struct GuardrailRegexFilter: Swift.Sendable {
        /// The action details for the regex filter used in the Guardrail.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAction?
        /// The match details for the regex filter used in the Guardrail.
        public var match: Swift.String?
        /// The name details for the regex filter used in the Guardrail.
        public var name: Swift.String?
        /// The regex details for the regex filter used in the Guardrail.
        public var regex: Swift.String?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAction? = nil,
            match: Swift.String? = nil,
            name: Swift.String? = nil,
            regex: Swift.String? = nil
        ) {
            self.action = action
            self.match = match
            self.name = name
            self.regex = regex
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailRegexFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The details of the sensitive policy assessment used in the Guardrail.
    public struct GuardrailSensitiveInformationPolicyAssessment: Swift.Sendable {
        /// The details of the PII entities used in the sensitive policy assessment for the Guardrail.
        public var piiEntities: [BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter]?
        /// The details of the regexes used in the sensitive policy assessment for the Guardrail.
        public var regexes: [BedrockAgentRuntimeClientTypes.GuardrailRegexFilter]?

        public init(
            piiEntities: [BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter]? = nil,
            regexes: [BedrockAgentRuntimeClientTypes.GuardrailRegexFilter]? = nil
        ) {
            self.piiEntities = piiEntities
            self.regexes = regexes
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailTopicPolicyAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blocked
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTopicPolicyAction] {
            return [
                .blocked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blocked: return "BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailTopicType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTopicType] {
            return [
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The details for a specific topic defined in the Guardrail.
    public struct GuardrailTopic: Swift.Sendable {
        /// The action details on a specific topic in the Guardrail.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAction?
        /// The name details on a specific topic in the Guardrail.
        public var name: Swift.String?
        /// The type details on a specific topic in the Guardrail.
        public var type: BedrockAgentRuntimeClientTypes.GuardrailTopicType?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAction? = nil,
            name: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.GuardrailTopicType? = nil
        ) {
            self.action = action
            self.name = name
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailTopic: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The details of the policy assessment used in the Guardrail.
    public struct GuardrailTopicPolicyAssessment: Swift.Sendable {
        /// The topic details of the policy assessment used in the Guardrail.
        public var topics: [BedrockAgentRuntimeClientTypes.GuardrailTopic]?

        public init(
            topics: [BedrockAgentRuntimeClientTypes.GuardrailTopic]? = nil
        ) {
            self.topics = topics
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailWordPolicyAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blocked
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailWordPolicyAction] {
            return [
                .blocked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blocked: return "BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The custom word details for the filter in the Guardrail.
    public struct GuardrailCustomWord: Swift.Sendable {
        /// The action details for the custom word filter in the Guardrail.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAction?
        /// The match details for the custom word filter in the Guardrail.
        public var match: Swift.String?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAction? = nil,
            match: Swift.String? = nil
        ) {
            self.action = action
            self.match = match
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailCustomWord: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuardrailManagedWordType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case profanity
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailManagedWordType] {
            return [
                .profanity
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .profanity: return "PROFANITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The managed word details for the filter in the Guardrail.
    public struct GuardrailManagedWord: Swift.Sendable {
        /// The action details for the managed word filter in the Guardrail.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAction?
        /// The match details for the managed word filter in the Guardrail.
        public var match: Swift.String?
        /// The type details for the managed word filter in the Guardrail.
        public var type: BedrockAgentRuntimeClientTypes.GuardrailManagedWordType?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAction? = nil,
            match: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.GuardrailManagedWordType? = nil
        ) {
            self.action = action
            self.match = match
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailManagedWord: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The assessment details for words defined in the Guardrail filter.
    public struct GuardrailWordPolicyAssessment: Swift.Sendable {
        /// The custom word details for words defined in the Guardrail filter.
        public var customWords: [BedrockAgentRuntimeClientTypes.GuardrailCustomWord]?
        /// The managed word lists for words defined in the Guardrail filter.
        public var managedWordLists: [BedrockAgentRuntimeClientTypes.GuardrailManagedWord]?

        public init(
            customWords: [BedrockAgentRuntimeClientTypes.GuardrailCustomWord]? = nil,
            managedWordLists: [BedrockAgentRuntimeClientTypes.GuardrailManagedWord]? = nil
        ) {
            self.customWords = customWords
            self.managedWordLists = managedWordLists
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Assessment details of the content analyzed by Guardrails.
    public struct GuardrailAssessment: Swift.Sendable {
        /// Content policy details of the Guardrail.
        public var contentPolicy: BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment?
        /// Sensitive Information policy details of Guardrail.
        public var sensitiveInformationPolicy: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment?
        /// Topic policy details of the Guardrail.
        public var topicPolicy: BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment?
        /// Word policy details of the Guardrail.
        public var wordPolicy: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment?

        public init(
            contentPolicy: BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment? = nil,
            sensitiveInformationPolicy: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment? = nil,
            topicPolicy: BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment? = nil,
            wordPolicy: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment? = nil
        ) {
            self.contentPolicy = contentPolicy
            self.sensitiveInformationPolicy = sensitiveInformationPolicy
            self.topicPolicy = topicPolicy
            self.wordPolicy = wordPolicy
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The trace details used in the Guardrail.
    public struct GuardrailTrace: Swift.Sendable {
        /// The trace action details used with the Guardrail.
        public var action: BedrockAgentRuntimeClientTypes.GuardrailAction?
        /// The details of the input assessments used in the Guardrail Trace.
        public var inputAssessments: [BedrockAgentRuntimeClientTypes.GuardrailAssessment]?
        /// The details of the output assessments used in the Guardrail Trace.
        public var outputAssessments: [BedrockAgentRuntimeClientTypes.GuardrailAssessment]?
        /// The details of the trace Id used in the Guardrail Trace.
        public var traceId: Swift.String?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuardrailAction? = nil,
            inputAssessments: [BedrockAgentRuntimeClientTypes.GuardrailAssessment]? = nil,
            outputAssessments: [BedrockAgentRuntimeClientTypes.GuardrailAssessment]? = nil,
            traceId: Swift.String? = nil
        ) {
            self.action = action
            self.inputAssessments = inputAssessments
            self.outputAssessments = outputAssessments
            self.traceId = traceId
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailTrace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the code interpreter being invoked.
    public struct CodeInterpreterInvocationInput: Swift.Sendable {
        /// The code for the code interpreter to use.
        public var code: Swift.String?
        /// Files that are uploaded for code interpreter to use.
        public var files: [Swift.String]?

        public init(
            code: Swift.String? = nil,
            files: [Swift.String]? = nil
        ) {
            self.code = code
            self.files = files
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum InvocationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionGroup
        case actionGroupCodeInterpreter
        case agentCollaborator
        case finish
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [InvocationType] {
            return [
                .actionGroup,
                .actionGroupCodeInterpreter,
                .agentCollaborator,
                .finish,
                .knowledgeBase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionGroup: return "ACTION_GROUP"
            case .actionGroupCodeInterpreter: return "ACTION_GROUP_CODE_INTERPRETER"
            case .agentCollaborator: return "AGENT_COLLABORATOR"
            case .finish: return "FINISH"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about the knowledge base to look up and the query to be made.
    public struct KnowledgeBaseLookupInput: Swift.Sendable {
        /// The unique identifier of the knowledge base to look up.
        public var knowledgeBaseId: Swift.String?
        /// The query made to the knowledge base.
        public var text: Swift.String?

        public init(
            knowledgeBaseId: Swift.String? = nil,
            text: Swift.String? = nil
        ) {
            self.knowledgeBaseId = knowledgeBaseId
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseLookupInput(knowledgeBaseId: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information pertaining to the action group or knowledge base that is being invoked.
    public struct InvocationInput: Swift.Sendable {
        /// Contains information about the action group to be invoked.
        public var actionGroupInvocationInput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput?
        /// The collaborator's invocation input.
        public var agentCollaboratorInvocationInput: BedrockAgentRuntimeClientTypes.AgentCollaboratorInvocationInput?
        /// Contains information about the code interpreter to be invoked.
        public var codeInterpreterInvocationInput: BedrockAgentRuntimeClientTypes.CodeInterpreterInvocationInput?
        /// Specifies whether the agent is invoking an action group or a knowledge base.
        public var invocationType: BedrockAgentRuntimeClientTypes.InvocationType?
        /// Contains details about the knowledge base to look up and the query to be made.
        public var knowledgeBaseLookupInput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            actionGroupInvocationInput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput? = nil,
            agentCollaboratorInvocationInput: BedrockAgentRuntimeClientTypes.AgentCollaboratorInvocationInput? = nil,
            codeInterpreterInvocationInput: BedrockAgentRuntimeClientTypes.CodeInterpreterInvocationInput? = nil,
            invocationType: BedrockAgentRuntimeClientTypes.InvocationType? = nil,
            knowledgeBaseLookupInput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput? = nil,
            traceId: Swift.String? = nil
        ) {
            self.actionGroupInvocationInput = actionGroupInvocationInput
            self.agentCollaboratorInvocationInput = agentCollaboratorInvocationInput
            self.codeInterpreterInvocationInput = codeInterpreterInvocationInput
            self.invocationType = invocationType
            self.knowledgeBaseLookupInput = knowledgeBaseLookupInput
            self.traceId = traceId
        }
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Specifications about the inference parameters that were provided alongside the prompt. These are specified in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    public struct InferenceConfiguration: Swift.Sendable {
        /// The maximum number of tokens allowed in the generated response.
        public var maximumLength: Swift.Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public var stopSequences: [Swift.String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        public var temperature: Swift.Float?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for topK is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topK to 50, the model selects the next token from among the top 50 most likely choices.
        public var topk: Swift.Int?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for Top P determines the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topP to 0.8, the model only selects the next token from the top 80% of the probability distribution of next tokens.
        public var topp: Swift.Float?

        public init(
            maximumLength: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topk: Swift.Int? = nil,
            topp: Swift.Float? = nil
        ) {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topk = topk
            self.topp = topp
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum CreationMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case overridden
        case sdkUnknown(Swift.String)

        public static var allCases: [CreationMode] {
            return [
                .default,
                .overridden
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .overridden: return "OVERRIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum PromptType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case knowledgeBaseResponseGeneration
        case orchestration
        case postProcessing
        case preProcessing
        case routingClassifier
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptType] {
            return [
                .knowledgeBaseResponseGeneration,
                .orchestration,
                .postProcessing,
                .preProcessing,
                .routingClassifier
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBaseResponseGeneration: return "KNOWLEDGE_BASE_RESPONSE_GENERATION"
            case .orchestration: return "ORCHESTRATION"
            case .postProcessing: return "POST_PROCESSING"
            case .preProcessing: return "PRE_PROCESSING"
            case .routingClassifier: return "ROUTING_CLASSIFIER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The input for the pre-processing step.
    ///
    /// * The type matches the agent step.
    ///
    /// * The text contains the prompt.
    ///
    /// * The inferenceConfiguration, parserMode, and overrideLambda values are set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated.
    public struct ModelInvocationInput: Swift.Sendable {
        /// The identifier of a foundation model.
        public var foundationModel: Swift.String?
        /// Specifications about the inference parameters that were provided alongside the prompt. These are specified in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var inferenceConfiguration: BedrockAgentRuntimeClientTypes.InferenceConfiguration?
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence.
        public var overrideLambda: Swift.String?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType.
        public var parserMode: BedrockAgentRuntimeClientTypes.CreationMode?
        /// Specifies whether the default prompt template was OVERRIDDEN. If it was, the basePromptTemplate that was set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object when the agent was created or updated is used instead.
        public var promptCreationMode: BedrockAgentRuntimeClientTypes.CreationMode?
        /// The text that prompted the agent at this step.
        public var text: Swift.String?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?
        /// The step in the agent sequence.
        public var type: BedrockAgentRuntimeClientTypes.PromptType?

        public init(
            foundationModel: Swift.String? = nil,
            inferenceConfiguration: BedrockAgentRuntimeClientTypes.InferenceConfiguration? = nil,
            overrideLambda: Swift.String? = nil,
            parserMode: BedrockAgentRuntimeClientTypes.CreationMode? = nil,
            promptCreationMode: BedrockAgentRuntimeClientTypes.CreationMode? = nil,
            text: Swift.String? = nil,
            traceId: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.PromptType? = nil
        ) {
            self.foundationModel = foundationModel
            self.inferenceConfiguration = inferenceConfiguration
            self.overrideLambda = overrideLambda
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.text = text
            self.traceId = traceId
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ModelInvocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information of the usage of the foundation model.
    public struct Usage: Swift.Sendable {
        /// Contains information about the input tokens from the foundation model usage.
        public var inputTokens: Swift.Int?
        /// Contains information about the output tokens from the foundation model usage.
        public var outputTokens: Swift.Int?

        public init(
            inputTokens: Swift.Int? = nil,
            outputTokens: Swift.Int? = nil
        ) {
            self.inputTokens = inputTokens
            self.outputTokens = outputTokens
        }
    }
}

extension BedrockAgentRuntimeClientTypes.Usage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Provides details of the foundation model.
    public struct Metadata: Swift.Sendable {
        /// Contains details of the foundation model usage.
        public var usage: BedrockAgentRuntimeClientTypes.Usage?

        public init(
            usage: BedrockAgentRuntimeClientTypes.Usage? = nil
        ) {
            self.usage = usage
        }
    }
}

extension BedrockAgentRuntimeClientTypes.Metadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the raw output from the foundation model.
    public struct RawResponse: Swift.Sendable {
        /// The foundation model's raw output content.
        public var content: Swift.String?

        public init(
            content: Swift.String? = nil
        ) {
            self.content = content
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RawResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the reasoning that the model used to return the content in the content block.
    public struct ReasoningTextBlock: Swift.Sendable {
        /// A hash of all the messages in the conversation to ensure that the content in the reasoning text block isn't tampered with. You must submit the signature in subsequent Converse requests, in addition to the previous messages. If the previous messages are tampered with, the response throws an error.
        public var signature: Swift.String?
        /// Text describing the reasoning that the model used to return the content in the content block.
        /// This member is required.
        public var text: Swift.String?

        public init(
            signature: Swift.String? = nil,
            text: Swift.String? = nil
        ) {
            self.signature = signature
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ReasoningTextBlock: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains content regarding the reasoning that the foundation model made with respect to the content in the content block. Reasoning refers to a Chain of Thought (CoT) that the model generates to enhance the accuracy of its final response.
    public enum ReasoningContentBlock: Swift.Sendable {
        /// Contains information about the reasoning that the model used to return the content in the content block.
        case reasoningtext(BedrockAgentRuntimeClientTypes.ReasoningTextBlock)
        /// The content in the reasoning that was encrypted by the model provider for trust and safety reasons.
        case redactedcontent(Foundation.Data)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The foundation model output from the orchestration step.
    public struct OrchestrationModelInvocationOutput: Swift.Sendable {
        /// Contains information about the foundation model output from the orchestration step.
        public var metadata: BedrockAgentRuntimeClientTypes.Metadata?
        /// Contains details of the raw response from the foundation model output.
        public var rawResponse: BedrockAgentRuntimeClientTypes.RawResponse?
        /// Contains content about the reasoning that the model made during the orchestration step.
        public var reasoningContent: BedrockAgentRuntimeClientTypes.ReasoningContentBlock?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            metadata: BedrockAgentRuntimeClientTypes.Metadata? = nil,
            rawResponse: BedrockAgentRuntimeClientTypes.RawResponse? = nil,
            reasoningContent: BedrockAgentRuntimeClientTypes.ReasoningContentBlock? = nil,
            traceId: Swift.String? = nil
        ) {
            self.metadata = metadata
            self.rawResponse = rawResponse
            self.reasoningContent = reasoningContent
            self.traceId = traceId
        }
    }
}

extension BedrockAgentRuntimeClientTypes.OrchestrationModelInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the JSON-formatted string returned by the API invoked by the code interpreter.
    public struct CodeInterpreterInvocationOutput: Swift.Sendable {
        /// Contains the error returned from code execution.
        public var executionError: Swift.String?
        /// Contains the successful output returned from code execution
        public var executionOutput: Swift.String?
        /// Indicates if the execution of the code timed out.
        public var executionTimeout: Swift.Bool?
        /// Contains output files, if generated by code execution.
        public var files: [Swift.String]?

        public init(
            executionError: Swift.String? = nil,
            executionOutput: Swift.String? = nil,
            executionTimeout: Swift.Bool? = nil,
            files: [Swift.String]? = nil
        ) {
            self.executionError = executionError
            self.executionOutput = executionOutput
            self.executionTimeout = executionTimeout
            self.files = files
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about the response to the user.
    public struct FinalResponse: Swift.Sendable {
        /// The text in the response to the user.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FinalResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FinalResponse(text: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about the results from looking up the knowledge base.
    public struct KnowledgeBaseLookupOutput: Swift.Sendable {
        /// Contains metadata about the sources cited for the generated response.
        public var retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]?

        public init(
            retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]? = nil
        ) {
            self.retrievedReferences = retrievedReferences
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum Source: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionGroup
        case knowledgeBase
        case parser
        case sdkUnknown(Swift.String)

        public static var allCases: [Source] {
            return [
                .actionGroup,
                .knowledgeBase,
                .parser
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionGroup: return "ACTION_GROUP"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case .parser: return "PARSER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about the agent's response to reprompt the input.
    public struct RepromptResponse: Swift.Sendable {
        /// Specifies what output is prompting the agent to reprompt the input.
        public var source: BedrockAgentRuntimeClientTypes.Source?
        /// The text reprompting the input.
        public var text: Swift.String?

        public init(
            source: BedrockAgentRuntimeClientTypes.Source? = nil,
            text: Swift.String? = nil
        ) {
            self.source = source
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RepromptResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum ModelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionGroup
        case agentCollaborator
        case askUser
        case finish
        case knowledgeBase
        case reprompt
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .actionGroup,
                .agentCollaborator,
                .askUser,
                .finish,
                .knowledgeBase,
                .reprompt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionGroup: return "ACTION_GROUP"
            case .agentCollaborator: return "AGENT_COLLABORATOR"
            case .askUser: return "ASK_USER"
            case .finish: return "FINISH"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case .reprompt: return "REPROMPT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the result or output of an action group or knowledge base, or the response to the user.
    public struct Observation: Swift.Sendable {
        /// Contains the JSON-formatted string returned by the API invoked by the action group.
        public var actionGroupInvocationOutput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput?
        /// A collaborator's invocation output.
        public var agentCollaboratorInvocationOutput: BedrockAgentRuntimeClientTypes.AgentCollaboratorInvocationOutput?
        /// Contains the JSON-formatted string returned by the API invoked by the code interpreter.
        public var codeInterpreterInvocationOutput: BedrockAgentRuntimeClientTypes.CodeInterpreterInvocationOutput?
        /// Contains details about the response to the user.
        public var finalResponse: BedrockAgentRuntimeClientTypes.FinalResponse?
        /// Contains details about the results from looking up the knowledge base.
        public var knowledgeBaseLookupOutput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput?
        /// Contains details about the response to reprompt the input.
        public var repromptResponse: BedrockAgentRuntimeClientTypes.RepromptResponse?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?
        /// Specifies what kind of information the agent returns in the observation. The following values are possible.
        ///
        /// * ACTION_GROUP  The agent returns the result of an action group.
        ///
        /// * KNOWLEDGE_BASE  The agent returns information from a knowledge base.
        ///
        /// * FINISH  The agent returns a final response to the user with no follow-up.
        ///
        /// * ASK_USER  The agent asks the user a question.
        ///
        /// * REPROMPT  The agent prompts the user again for the same information.
        public var type: BedrockAgentRuntimeClientTypes.ModelType?

        public init(
            actionGroupInvocationOutput: BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput? = nil,
            agentCollaboratorInvocationOutput: BedrockAgentRuntimeClientTypes.AgentCollaboratorInvocationOutput? = nil,
            codeInterpreterInvocationOutput: BedrockAgentRuntimeClientTypes.CodeInterpreterInvocationOutput? = nil,
            finalResponse: BedrockAgentRuntimeClientTypes.FinalResponse? = nil,
            knowledgeBaseLookupOutput: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput? = nil,
            repromptResponse: BedrockAgentRuntimeClientTypes.RepromptResponse? = nil,
            traceId: Swift.String? = nil,
            type: BedrockAgentRuntimeClientTypes.ModelType? = nil
        ) {
            self.actionGroupInvocationOutput = actionGroupInvocationOutput
            self.agentCollaboratorInvocationOutput = agentCollaboratorInvocationOutput
            self.codeInterpreterInvocationOutput = codeInterpreterInvocationOutput
            self.finalResponse = finalResponse
            self.knowledgeBaseLookupOutput = knowledgeBaseLookupOutput
            self.repromptResponse = repromptResponse
            self.traceId = traceId
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.Observation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the reasoning, based on the input, that the agent uses to justify carrying out an action group or getting information from a knowledge base.
    public struct Rationale: Swift.Sendable {
        /// The reasoning or thought process of the agent, based on the input.
        public var text: Swift.String?
        /// The unique identifier of the trace step.
        public var traceId: Swift.String?

        public init(
            text: Swift.String? = nil,
            traceId: Swift.String? = nil
        ) {
            self.text = text
            self.traceId = traceId
        }
    }
}

extension BedrockAgentRuntimeClientTypes.Rationale: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Details about the orchestration step, in which the agent determines the order in which actions are executed and which knowledge bases are retrieved.
    public enum OrchestrationTrace: Swift.Sendable {
        /// Details about the reasoning, based on the input, that the agent uses to justify carrying out an action group or getting information from a knowledge base.
        case rationale(BedrockAgentRuntimeClientTypes.Rationale)
        /// Contains information pertaining to the action group or knowledge base that is being invoked.
        case invocationinput(BedrockAgentRuntimeClientTypes.InvocationInput)
        /// Details about the observation (the output of the action group Lambda or knowledge base) made by the agent.
        case observation(BedrockAgentRuntimeClientTypes.Observation)
        /// The input for the orchestration step.
        ///
        /// * The type is ORCHESTRATION.
        ///
        /// * The text contains the prompt.
        ///
        /// * The inferenceConfiguration, parserMode, and overrideLambda values are set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated.
        case modelinvocationinput(BedrockAgentRuntimeClientTypes.ModelInvocationInput)
        /// Contains information pertaining to the output from the foundation model that is being invoked.
        case modelinvocationoutput(BedrockAgentRuntimeClientTypes.OrchestrationModelInvocationOutput)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Details about the response from the Lambda parsing of the output from the post-processing step.
    public struct PostProcessingParsedResponse: Swift.Sendable {
        /// The text returned by the parser.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The foundation model output from the post-processing step.
    public struct PostProcessingModelInvocationOutput: Swift.Sendable {
        /// Contains information about the foundation model output from the post-processing step.
        public var metadata: BedrockAgentRuntimeClientTypes.Metadata?
        /// Details about the response from the Lambda parsing of the output of the post-processing step.
        public var parsedResponse: BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse?
        /// Details of the raw response from the foundation model output.
        public var rawResponse: BedrockAgentRuntimeClientTypes.RawResponse?
        /// Contains content about the reasoning that the model made during the post-processing step.
        public var reasoningContent: BedrockAgentRuntimeClientTypes.ReasoningContentBlock?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            metadata: BedrockAgentRuntimeClientTypes.Metadata? = nil,
            parsedResponse: BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse? = nil,
            rawResponse: BedrockAgentRuntimeClientTypes.RawResponse? = nil,
            reasoningContent: BedrockAgentRuntimeClientTypes.ReasoningContentBlock? = nil,
            traceId: Swift.String? = nil
        ) {
            self.metadata = metadata
            self.parsedResponse = parsedResponse
            self.rawResponse = rawResponse
            self.reasoningContent = reasoningContent
            self.traceId = traceId
        }
    }
}

extension BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Details about the post-processing step, in which the agent shapes the response.
    public enum PostProcessingTrace: Swift.Sendable {
        /// The input for the post-processing step.
        ///
        /// * The type is POST_PROCESSING.
        ///
        /// * The text contains the prompt.
        ///
        /// * The inferenceConfiguration, parserMode, and overrideLambda values are set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated.
        case modelinvocationinput(BedrockAgentRuntimeClientTypes.ModelInvocationInput)
        /// The foundation model output from the post-processing step.
        case modelinvocationoutput(BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Details about the response from the Lambda parsing of the output from the pre-processing step.
    public struct PreProcessingParsedResponse: Swift.Sendable {
        /// Whether the user input is valid or not. If false, the agent doesn't proceed to orchestration.
        public var isValid: Swift.Bool?
        /// The text returned by the parsing of the pre-processing step, explaining the steps that the agent plans to take in orchestration, if the user input is valid.
        public var rationale: Swift.String?

        public init(
            isValid: Swift.Bool? = nil,
            rationale: Swift.String? = nil
        ) {
            self.isValid = isValid
            self.rationale = rationale
        }
    }
}

extension BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The foundation model output from the pre-processing step.
    public struct PreProcessingModelInvocationOutput: Swift.Sendable {
        /// Contains information about the foundation model output from the pre-processing step.
        public var metadata: BedrockAgentRuntimeClientTypes.Metadata?
        /// Details about the response from the Lambda parsing of the output of the pre-processing step.
        public var parsedResponse: BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse?
        /// Details of the raw response from the foundation model output.
        public var rawResponse: BedrockAgentRuntimeClientTypes.RawResponse?
        /// Contains content about the reasoning that the model made during the pre-processing step.
        public var reasoningContent: BedrockAgentRuntimeClientTypes.ReasoningContentBlock?
        /// The unique identifier of the trace.
        public var traceId: Swift.String?

        public init(
            metadata: BedrockAgentRuntimeClientTypes.Metadata? = nil,
            parsedResponse: BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse? = nil,
            rawResponse: BedrockAgentRuntimeClientTypes.RawResponse? = nil,
            reasoningContent: BedrockAgentRuntimeClientTypes.ReasoningContentBlock? = nil,
            traceId: Swift.String? = nil
        ) {
            self.metadata = metadata
            self.parsedResponse = parsedResponse
            self.rawResponse = rawResponse
            self.reasoningContent = reasoningContent
            self.traceId = traceId
        }
    }
}

extension BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Details about the pre-processing step, in which the agent contextualizes and categorizes user inputs.
    public enum PreProcessingTrace: Swift.Sendable {
        /// The input for the pre-processing step.
        ///
        /// * The type is PRE_PROCESSING.
        ///
        /// * The text contains the prompt.
        ///
        /// * The inferenceConfiguration, parserMode, and overrideLambda values are set in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) object that was set when the agent was created or updated.
        case modelinvocationinput(BedrockAgentRuntimeClientTypes.ModelInvocationInput)
        /// The foundation model output from the pre-processing step.
        case modelinvocationoutput(BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Invocation output from a routing classifier model.
    public struct RoutingClassifierModelInvocationOutput: Swift.Sendable {
        /// The invocation's metadata.
        public var metadata: BedrockAgentRuntimeClientTypes.Metadata?
        /// The invocation's raw response.
        public var rawResponse: BedrockAgentRuntimeClientTypes.RawResponse?
        /// The invocation's trace ID.
        public var traceId: Swift.String?

        public init(
            metadata: BedrockAgentRuntimeClientTypes.Metadata? = nil,
            rawResponse: BedrockAgentRuntimeClientTypes.RawResponse? = nil,
            traceId: Swift.String? = nil
        ) {
            self.metadata = metadata
            self.rawResponse = rawResponse
            self.traceId = traceId
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RoutingClassifierModelInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// A trace for a routing classifier.
    public enum RoutingClassifierTrace: Swift.Sendable {
        /// The classifier's invocation input.
        case invocationinput(BedrockAgentRuntimeClientTypes.InvocationInput)
        /// The classifier's observation.
        case observation(BedrockAgentRuntimeClientTypes.Observation)
        /// The classifier's model invocation input.
        case modelinvocationinput(BedrockAgentRuntimeClientTypes.ModelInvocationInput)
        /// The classifier's model invocation output.
        case modelinvocationoutput(BedrockAgentRuntimeClientTypes.RoutingClassifierModelInvocationOutput)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains one part of the agent's reasoning process and results from calling API actions and querying knowledge bases. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-enablement).
    public enum Trace: Swift.Sendable {
        /// The trace details for a trace defined in the Guardrail filter.
        case guardrailtrace(BedrockAgentRuntimeClientTypes.GuardrailTrace)
        /// Details about the pre-processing step, in which the agent contextualizes and categorizes user inputs.
        case preprocessingtrace(BedrockAgentRuntimeClientTypes.PreProcessingTrace)
        /// Details about the orchestration step, in which the agent determines the order in which actions are executed and which knowledge bases are retrieved.
        case orchestrationtrace(BedrockAgentRuntimeClientTypes.OrchestrationTrace)
        /// Details about the post-processing step, in which the agent shapes the response..
        case postprocessingtrace(BedrockAgentRuntimeClientTypes.PostProcessingTrace)
        /// A routing classifier's trace.
        case routingclassifiertrace(BedrockAgentRuntimeClientTypes.RoutingClassifierTrace)
        /// Contains information about the failure of the interaction.
        case failuretrace(BedrockAgentRuntimeClientTypes.FailureTrace)
        /// Details about the custom orchestration step in which the agent determines the order in which actions are executed.
        case customorchestrationtrace(BedrockAgentRuntimeClientTypes.CustomOrchestrationTrace)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the agent and session, alongside the agent's reasoning process and results from calling API actions and querying knowledge bases and metadata about the trace. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-enablement).
    public struct TracePart: Swift.Sendable {
        /// The unique identifier of the alias of the agent.
        public var agentAliasId: Swift.String?
        /// The unique identifier of the agent.
        public var agentId: Swift.String?
        /// The version of the agent.
        public var agentVersion: Swift.String?
        /// The part's caller chain.
        public var callerChain: [BedrockAgentRuntimeClientTypes.Caller]?
        /// The part's collaborator name.
        public var collaboratorName: Swift.String?
        /// The time of the trace.
        public var eventTime: Foundation.Date?
        /// The unique identifier of the session with the agent.
        public var sessionId: Swift.String?
        /// Contains one part of the agent's reasoning process and results from calling API actions and querying knowledge bases. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-enablement).
        public var trace: BedrockAgentRuntimeClientTypes.Trace?

        public init(
            agentAliasId: Swift.String? = nil,
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            callerChain: [BedrockAgentRuntimeClientTypes.Caller]? = nil,
            collaboratorName: Swift.String? = nil,
            eventTime: Foundation.Date? = nil,
            sessionId: Swift.String? = nil,
            trace: BedrockAgentRuntimeClientTypes.Trace? = nil
        ) {
            self.agentAliasId = agentAliasId
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.callerChain = callerChain
            self.collaboratorName = collaboratorName
            self.eventTime = eventTime
            self.sessionId = sessionId
            self.trace = trace
        }
    }
}

extension BedrockAgentRuntimeClientTypes.TracePart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The response from invoking the agent and associated citations and trace information.
    public enum ResponseStream: Swift.Sendable {
        /// Contains a part of an agent response and citations for it.
        case chunk(BedrockAgentRuntimeClientTypes.PayloadPart)
        /// Contains information about the agent and session, alongside the agent's reasoning process and results from calling actions and querying knowledge bases and metadata about the trace. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace events](https://docs.aws.amazon.com/bedrock/latest/userguide/trace-events.html).
        case trace(BedrockAgentRuntimeClientTypes.TracePart)
        /// Contains the parameters and information that the agent elicited from the customer to carry out an action. This information is returned to the system and can be used in your own setup for fulfilling the action.
        case returncontrol(BedrockAgentRuntimeClientTypes.ReturnControlPayload)
        /// Contains intermediate response for code interpreter if any files have been generated.
        case files(BedrockAgentRuntimeClientTypes.FilePart)
        case sdkUnknown(Swift.String)
    }
}

public struct InvokeAgentOutput: Swift.Sendable {
    /// The agent's response to the user prompt.
    /// This member is required.
    public var completion: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.ResponseStream, Swift.Error>?
    /// The MIME type of the input data in the request. The default value is application/json.
    /// This member is required.
    public var contentType: Swift.String?
    /// The unique identifier of the agent memory.
    public var memoryId: Swift.String?
    /// The unique identifier of the session with the agent.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        completion: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.ResponseStream, Swift.Error>? = nil,
        contentType: Swift.String? = nil,
        memoryId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.completion = completion
        self.contentType = contentType
        self.memoryId = memoryId
        self.sessionId = sessionId
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Settings for a model called with [InvokeInlineAgent].
    public struct InlineBedrockModelConfigurations: Swift.Sendable {
        /// The latency configuration for the model.
        public var performanceConfig: BedrockAgentRuntimeClientTypes.PerformanceConfiguration?

        public init(
            performanceConfig: BedrockAgentRuntimeClientTypes.PerformanceConfiguration? = nil
        ) {
            self.performanceConfig = performanceConfig
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum RelayConversationHistory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case toCollaborator
        case sdkUnknown(Swift.String)

        public static var allCases: [RelayConversationHistory] {
            return [
                .disabled,
                .toCollaborator
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .toCollaborator: return "TO_COLLABORATOR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Settings of an inline collaborator agent.
    public struct CollaboratorConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the inline collaborator agent.
        public var agentAliasArn: Swift.String?
        /// Instructions that tell the inline collaborator agent what it should do and how it should interact with users.
        /// This member is required.
        public var collaboratorInstruction: Swift.String?
        /// Name of the inline collaborator agent which must be the same name as specified for agentName.
        /// This member is required.
        public var collaboratorName: Swift.String?
        /// A relay conversation history for the inline collaborator agent.
        public var relayConversationHistory: BedrockAgentRuntimeClientTypes.RelayConversationHistory?

        public init(
            agentAliasArn: Swift.String? = nil,
            collaboratorInstruction: Swift.String? = nil,
            collaboratorName: Swift.String? = nil,
            relayConversationHistory: BedrockAgentRuntimeClientTypes.RelayConversationHistory? = nil
        ) {
            self.agentAliasArn = agentAliasArn
            self.collaboratorInstruction = collaboratorInstruction
            self.collaboratorName = collaboratorName
            self.relayConversationHistory = relayConversationHistory
        }
    }
}

extension BedrockAgentRuntimeClientTypes.CollaboratorConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CollaboratorConfiguration(agentAliasArn: \(Swift.String(describing: agentAliasArn)), relayConversationHistory: \(Swift.String(describing: relayConversationHistory)), collaboratorInstruction: \"CONTENT_REDACTED\", collaboratorName: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// The configuration details for the guardrail.
    public struct GuardrailConfigurationWithArn: Swift.Sendable {
        /// The unique identifier for the guardrail.
        /// This member is required.
        public var guardrailIdentifier: Swift.String?
        /// The version of the guardrail.
        /// This member is required.
        public var guardrailVersion: Swift.String?

        public init(
            guardrailIdentifier: Swift.String? = nil,
            guardrailVersion: Swift.String? = nil
        ) {
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum PromptState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations to override a prompt template in one part of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public struct PromptConfiguration: Swift.Sendable {
        /// If the Converse or ConverseStream operations support the model, additionalModelRequestFields contains additional inference parameters, beyond the base set of inference parameters in the inferenceConfiguration field. For more information, see Inference request parameters and response fields for foundation models in the Amazon Bedrock user guide.
        public var additionalModelRequestFields: Smithy.Document?
        /// Defines the prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html). For more information, see [Configure the prompt templates](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts-configure.html).
        public var basePromptTemplate: Swift.String?
        /// The foundation model to use.
        public var foundationModel: Swift.String?
        /// Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the promptType. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var inferenceConfiguration: BedrockAgentRuntimeClientTypes.InferenceConfiguration?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType. If you set the field as OVERRIDDEN, the overrideLambda field in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) must be specified with the ARN of a Lambda function.
        public var parserMode: BedrockAgentRuntimeClientTypes.CreationMode?
        /// Specifies whether to override the default prompt template for this promptType. Set this value to OVERRIDDEN to use the prompt that you provide in the basePromptTemplate. If you leave it as DEFAULT, the agent uses a default prompt template.
        public var promptCreationMode: BedrockAgentRuntimeClientTypes.CreationMode?
        /// Specifies whether to allow the inline agent to carry out the step specified in the promptType. If you set this value to DISABLED, the agent skips that step. The default state for each promptType is as follows.
        ///
        /// * PRE_PROCESSING  ENABLED
        ///
        /// * ORCHESTRATION  ENABLED
        ///
        /// * KNOWLEDGE_BASE_RESPONSE_GENERATION  ENABLED
        ///
        /// * POST_PROCESSING  DISABLED
        public var promptState: BedrockAgentRuntimeClientTypes.PromptState?
        /// The step in the agent sequence that this prompt configuration applies to.
        public var promptType: BedrockAgentRuntimeClientTypes.PromptType?

        public init(
            additionalModelRequestFields: Smithy.Document? = nil,
            basePromptTemplate: Swift.String? = nil,
            foundationModel: Swift.String? = nil,
            inferenceConfiguration: BedrockAgentRuntimeClientTypes.InferenceConfiguration? = nil,
            parserMode: BedrockAgentRuntimeClientTypes.CreationMode? = nil,
            promptCreationMode: BedrockAgentRuntimeClientTypes.CreationMode? = nil,
            promptState: BedrockAgentRuntimeClientTypes.PromptState? = nil,
            promptType: BedrockAgentRuntimeClientTypes.PromptType? = nil
        ) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.basePromptTemplate = basePromptTemplate
            self.foundationModel = foundationModel
            self.inferenceConfiguration = inferenceConfiguration
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.promptState = promptState
            self.promptType = promptType
        }
    }
}

extension BedrockAgentRuntimeClientTypes.PromptConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromptConfiguration(additionalModelRequestFields: \(Swift.String(describing: additionalModelRequestFields)), foundationModel: \(Swift.String(describing: foundationModel)), inferenceConfiguration: \(Swift.String(describing: inferenceConfiguration)), parserMode: \(Swift.String(describing: parserMode)), promptCreationMode: \(Swift.String(describing: promptCreationMode)), promptState: \(Swift.String(describing: promptState)), promptType: \(Swift.String(describing: promptType)), basePromptTemplate: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public struct PromptOverrideConfiguration: Swift.Sendable {
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the promptConfigurations must contain a parserMode value that is set to OVERRIDDEN. For more information, see [Parser Lambda function in Amazon Bedrock Agents](https://docs.aws.amazon.com/bedrock/latest/userguide/lambda-parser.html).
        public var overrideLambda: Swift.String?
        /// Contains configurations to override a prompt template in one part of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
        /// This member is required.
        public var promptConfigurations: [BedrockAgentRuntimeClientTypes.PromptConfiguration]?

        public init(
            overrideLambda: Swift.String? = nil,
            promptConfigurations: [BedrockAgentRuntimeClientTypes.PromptConfiguration]? = nil
        ) {
            self.overrideLambda = overrideLambda
            self.promptConfigurations = promptConfigurations
        }
    }
}

extension BedrockAgentRuntimeClientTypes.PromptOverrideConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains parameters that specify various attributes that persist across a session or prompt. You can define session state attributes as key-value pairs when writing a [Lambda function](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-lambda.html) for an action group or pass them when making an InvokeInlineAgent request. Use session state attributes to control and provide conversational context for your inline agent and to help customize your agent's behavior. For more information, see [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html)
    public struct InlineSessionState: Swift.Sendable {
        /// Contains the conversation history that persist across sessions.
        public var conversationHistory: BedrockAgentRuntimeClientTypes.ConversationHistory?
        /// Contains information about the files used by code interpreter.
        public var files: [BedrockAgentRuntimeClientTypes.InputFile]?
        /// The identifier of the invocation of an action. This value must match the invocationId returned in the InvokeInlineAgent response for the action whose results are provided in the returnControlInvocationResults field. For more information, see [Return control to the agent developer](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-returncontrol.html).
        public var invocationId: Swift.String?
        /// Contains attributes that persist across a session and the values of those attributes.
        public var promptSessionAttributes: [Swift.String: Swift.String]?
        /// Contains information about the results from the action group invocation. For more information, see [Return control to the agent developer](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-returncontrol.html). If you include this field in the sessionState field, the inputText field will be ignored.
        public var returnControlInvocationResults: [BedrockAgentRuntimeClientTypes.InvocationResultMember]?
        /// Contains attributes that persist across a session and the values of those attributes.
        public var sessionAttributes: [Swift.String: Swift.String]?

        public init(
            conversationHistory: BedrockAgentRuntimeClientTypes.ConversationHistory? = nil,
            files: [BedrockAgentRuntimeClientTypes.InputFile]? = nil,
            invocationId: Swift.String? = nil,
            promptSessionAttributes: [Swift.String: Swift.String]? = nil,
            returnControlInvocationResults: [BedrockAgentRuntimeClientTypes.InvocationResultMember]? = nil,
            sessionAttributes: [Swift.String: Swift.String]? = nil
        ) {
            self.conversationHistory = conversationHistory
            self.files = files
            self.invocationId = invocationId
            self.promptSessionAttributes = promptSessionAttributes
            self.returnControlInvocationResults = returnControlInvocationResults
            self.sessionAttributes = sessionAttributes
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains a part of an agent response and citations for it.
    public struct InlineAgentPayloadPart: Swift.Sendable {
        /// Contains citations for a part of an agent response.
        public var attribution: BedrockAgentRuntimeClientTypes.Attribution?
        /// A part of the agent response in bytes.
        public var bytes: Foundation.Data?

        public init(
            attribution: BedrockAgentRuntimeClientTypes.Attribution? = nil,
            bytes: Foundation.Data? = nil
        ) {
            self.attribution = attribution
            self.bytes = bytes
        }
    }
}

extension BedrockAgentRuntimeClientTypes.InlineAgentPayloadPart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains intermediate response for code interpreter if any files have been generated.
    public struct InlineAgentFilePart: Swift.Sendable {
        /// Files containing intermediate response for the user.
        public var files: [BedrockAgentRuntimeClientTypes.OutputFile]?

        public init(
            files: [BedrockAgentRuntimeClientTypes.OutputFile]? = nil
        ) {
            self.files = files
        }
    }
}

extension BedrockAgentRuntimeClientTypes.InlineAgentFilePart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InlineAgentFilePart(files: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information to return from the action group that the agent has predicted to invoke. This data type is used in the [InvokeAgent response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html#API_agent-runtime_InvokeAgent_ResponseSyntax) API operation.
    public struct InlineAgentReturnControlPayload: Swift.Sendable {
        /// The identifier of the action group invocation.
        public var invocationId: Swift.String?
        /// A list of objects that contain information about the parameters and inputs that need to be sent into the API operation or function, based on what the agent determines from its session with the user.
        public var invocationInputs: [BedrockAgentRuntimeClientTypes.InvocationInputMember]?

        public init(
            invocationId: Swift.String? = nil,
            invocationInputs: [BedrockAgentRuntimeClientTypes.InvocationInputMember]? = nil
        ) {
            self.invocationId = invocationId
            self.invocationInputs = invocationInputs
        }
    }
}

extension BedrockAgentRuntimeClientTypes.InlineAgentReturnControlPayload: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the agent and session, alongside the agent's reasoning process and results from calling API actions and querying knowledge bases and metadata about the trace. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-enablement).
    public struct InlineAgentTracePart: Swift.Sendable {
        /// The unique identifier of the session with the agent.
        public var sessionId: Swift.String?
        /// Contains one part of the agent's reasoning process and results from calling API actions and querying knowledge bases. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-enablement).
        public var trace: BedrockAgentRuntimeClientTypes.Trace?

        public init(
            sessionId: Swift.String? = nil,
            trace: BedrockAgentRuntimeClientTypes.Trace? = nil
        ) {
            self.sessionId = sessionId
            self.trace = trace
        }
    }
}

extension BedrockAgentRuntimeClientTypes.InlineAgentTracePart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The response from invoking the agent and associated citations and trace information.
    public enum InlineAgentResponseStream: Swift.Sendable {
        /// Contains a part of an agent response and citations for it.
        case chunk(BedrockAgentRuntimeClientTypes.InlineAgentPayloadPart)
        /// Contains information about the agent and session, alongside the agent's reasoning process and results from calling actions and querying knowledge bases and metadata about the trace. You can use the trace to understand how the agent arrived at the response it provided the customer. For more information, see [Trace events](https://docs.aws.amazon.com/bedrock/latest/userguide/trace-events.html).
        case trace(BedrockAgentRuntimeClientTypes.InlineAgentTracePart)
        /// Contains the parameters and information that the agent elicited from the customer to carry out an action. This information is returned to the system and can be used in your own setup for fulfilling the action.
        case returncontrol(BedrockAgentRuntimeClientTypes.InlineAgentReturnControlPayload)
        /// Contains intermediate response for code interpreter if any files have been generated.
        case files(BedrockAgentRuntimeClientTypes.InlineAgentFilePart)
        case sdkUnknown(Swift.String)
    }
}

public struct InvokeInlineAgentOutput: Swift.Sendable {
    ///
    /// This member is required.
    public var completion: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.InlineAgentResponseStream, Swift.Error>?
    /// The MIME type of the input data in the request. The default value is application/json.
    /// This member is required.
    public var contentType: Swift.String?
    /// The unique identifier of the session with the agent.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        completion: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.InlineAgentResponseStream, Swift.Error>? = nil,
        contentType: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.completion = completion
        self.contentType = contentType
        self.sessionId = sessionId
    }
}

public struct DeleteAgentMemoryInput: Swift.Sendable {
    /// The unique identifier of an alias of an agent.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The unique identifier of the agent to which the alias belongs.
    /// This member is required.
    public var agentId: Swift.String?
    /// The unique identifier of the memory.
    public var memoryId: Swift.String?
    /// The unique session identifier of the memory.
    public var sessionId: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        memoryId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
        self.memoryId = memoryId
        self.sessionId = sessionId
    }
}

public struct DeleteAgentMemoryOutput: Swift.Sendable {

    public init() { }
}

extension BedrockAgentRuntimeClientTypes {

    public enum MemoryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sessionSummary
        case sdkUnknown(Swift.String)

        public static var allCases: [MemoryType] {
            return [
                .sessionSummary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sessionSummary: return "SESSION_SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetAgentMemoryInput: Swift.Sendable {
    /// The unique identifier of an alias of an agent.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The unique identifier of the agent to which the alias belongs.
    /// This member is required.
    public var agentId: Swift.String?
    /// The maximum number of items to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxItems: Swift.Int?
    /// The unique identifier of the memory.
    /// This member is required.
    public var memoryId: Swift.String?
    /// The type of memory.
    /// This member is required.
    public var memoryType: BedrockAgentRuntimeClientTypes.MemoryType?
    /// If the total number of results is greater than the maxItems value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        memoryId: Swift.String? = nil,
        memoryType: BedrockAgentRuntimeClientTypes.MemoryType? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
        self.maxItems = maxItems
        self.memoryId = memoryId
        self.memoryType = memoryType
        self.nextToken = nextToken
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details of a session summary.
    public struct MemorySessionSummary: Swift.Sendable {
        /// The unique identifier of the memory where the session summary is stored.
        public var memoryId: Swift.String?
        /// The time when the memory duration for the session is set to end.
        public var sessionExpiryTime: Foundation.Date?
        /// The identifier for this session.
        public var sessionId: Swift.String?
        /// The start time for this session.
        public var sessionStartTime: Foundation.Date?
        /// The summarized text for this session.
        public var summaryText: Swift.String?

        public init(
            memoryId: Swift.String? = nil,
            sessionExpiryTime: Foundation.Date? = nil,
            sessionId: Swift.String? = nil,
            sessionStartTime: Foundation.Date? = nil,
            summaryText: Swift.String? = nil
        ) {
            self.memoryId = memoryId
            self.sessionExpiryTime = sessionExpiryTime
            self.sessionId = sessionId
            self.sessionStartTime = sessionStartTime
            self.summaryText = summaryText
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains sessions summaries.
    public enum Memory: Swift.Sendable {
        /// Contains summary of a session.
        case sessionsummary(BedrockAgentRuntimeClientTypes.MemorySessionSummary)
        case sdkUnknown(Swift.String)
    }
}

public struct GetAgentMemoryOutput: Swift.Sendable {
    /// Contains details of the sessions stored in the memory
    public var memoryContents: [BedrockAgentRuntimeClientTypes.Memory]?
    /// If the total number of results is greater than the maxItems value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        memoryContents: [BedrockAgentRuntimeClientTypes.Memory]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.memoryContents = memoryContents
        self.nextToken = nextToken
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the text prompt to optimize.
    public struct TextPrompt: Swift.Sendable {
        /// The text in the text prompt to optimize.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.TextPrompt: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the prompt to optimize.
    public enum InputPrompt: Swift.Sendable {
        /// Contains information about the text prompt to optimize.
        case textprompt(BedrockAgentRuntimeClientTypes.TextPrompt)
        case sdkUnknown(Swift.String)
    }
}

public struct OptimizePromptInput: Swift.Sendable {
    /// Contains the prompt to optimize.
    /// This member is required.
    public var input: BedrockAgentRuntimeClientTypes.InputPrompt?
    /// The unique identifier of the model that you want to optimize the prompt for.
    /// This member is required.
    public var targetModelId: Swift.String?

    public init(
        input: BedrockAgentRuntimeClientTypes.InputPrompt? = nil,
        targetModelId: Swift.String? = nil
    ) {
        self.input = input
        self.targetModelId = targetModelId
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// An event in which the prompt was analyzed in preparation for optimization.
    public struct AnalyzePromptEvent: Swift.Sendable {
        /// A message describing the analysis of the prompt.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        ) {
            self.message = message
        }
    }
}

extension BedrockAgentRuntimeClientTypes.AnalyzePromptEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about the optimized prompt.
    public enum OptimizedPrompt: Swift.Sendable {
        /// Contains information about the text in the prompt that was optimized.
        case textprompt(BedrockAgentRuntimeClientTypes.TextPrompt)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// An event in which the prompt was optimized.
    public struct OptimizedPromptEvent: Swift.Sendable {
        /// Contains information about the optimized prompt.
        public var optimizedPrompt: BedrockAgentRuntimeClientTypes.OptimizedPrompt?

        public init(
            optimizedPrompt: BedrockAgentRuntimeClientTypes.OptimizedPrompt? = nil
        ) {
            self.optimizedPrompt = optimizedPrompt
        }
    }
}

extension BedrockAgentRuntimeClientTypes.OptimizedPromptEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The stream containing events in the prompt optimization process.
    public enum OptimizedPromptStream: Swift.Sendable {
        /// An event in which the prompt was optimized.
        case optimizedpromptevent(BedrockAgentRuntimeClientTypes.OptimizedPromptEvent)
        /// An event in which the prompt was analyzed in preparation for optimization.
        case analyzepromptevent(BedrockAgentRuntimeClientTypes.AnalyzePromptEvent)
        case sdkUnknown(Swift.String)
    }
}

public struct OptimizePromptOutput: Swift.Sendable {
    /// The prompt after being optimized for the task.
    /// This member is required.
    public var optimizedPrompt: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.OptimizedPromptStream, Swift.Error>?

    public init(
        optimizedPrompt: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.OptimizedPromptStream, Swift.Error>? = nil
    ) {
        self.optimizedPrompt = optimizedPrompt
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a text document to rerank.
    public struct RerankTextDocument: Swift.Sendable {
        /// The text of the document.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RerankTextDocument: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum RerankQueryContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [RerankQueryContentType] {
            return [
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a query to submit to the reranker model.
    public struct RerankQuery: Swift.Sendable {
        /// Contains information about a text query.
        /// This member is required.
        public var textQuery: BedrockAgentRuntimeClientTypes.RerankTextDocument?
        /// The type of the query.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.RerankQueryContentType?

        public init(
            textQuery: BedrockAgentRuntimeClientTypes.RerankTextDocument? = nil,
            type: BedrockAgentRuntimeClientTypes.RerankQueryContentType? = nil
        ) {
            self.textQuery = textQuery
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RerankQuery: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations for a reranker model.
    public struct BedrockRerankingModelConfiguration: Swift.Sendable {
        /// A JSON object whose keys are request fields for the model and whose values are values for those fields.
        public var additionalModelRequestFields: [Swift.String: Smithy.Document]?
        /// The ARN of the reranker model.
        /// This member is required.
        public var modelArn: Swift.String?

        public init(
            additionalModelRequestFields: [Swift.String: Smithy.Document]? = nil,
            modelArn: Swift.String? = nil
        ) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.modelArn = modelArn
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations for an Amazon Bedrock reranker model.
    public struct BedrockRerankingConfiguration: Swift.Sendable {
        /// Contains configurations for a reranker model.
        /// This member is required.
        public var modelConfiguration: BedrockAgentRuntimeClientTypes.BedrockRerankingModelConfiguration?
        /// The number of results to return after reranking.
        public var numberOfResults: Swift.Int?

        public init(
            modelConfiguration: BedrockAgentRuntimeClientTypes.BedrockRerankingModelConfiguration? = nil,
            numberOfResults: Swift.Int? = nil
        ) {
            self.modelConfiguration = modelConfiguration
            self.numberOfResults = numberOfResults
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum RerankingConfigurationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bedrockRerankingModel
        case sdkUnknown(Swift.String)

        public static var allCases: [RerankingConfigurationType] {
            return [
                .bedrockRerankingModel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bedrockRerankingModel: return "BEDROCK_RERANKING_MODEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations for reranking.
    public struct RerankingConfiguration: Swift.Sendable {
        /// Contains configurations for an Amazon Bedrock reranker.
        /// This member is required.
        public var bedrockRerankingConfiguration: BedrockAgentRuntimeClientTypes.BedrockRerankingConfiguration?
        /// The type of reranker that the configurations apply to.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.RerankingConfigurationType?

        public init(
            bedrockRerankingConfiguration: BedrockAgentRuntimeClientTypes.BedrockRerankingConfiguration? = nil,
            type: BedrockAgentRuntimeClientTypes.RerankingConfigurationType? = nil
        ) {
            self.bedrockRerankingConfiguration = bedrockRerankingConfiguration
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum RerankDocumentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [RerankDocumentType] {
            return [
                .json,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a document to rerank. Choose the type to define and include the field that corresponds to the type.
    public struct RerankDocument: Swift.Sendable {
        /// Contains a JSON document to rerank.
        public var jsonDocument: Smithy.Document?
        /// Contains information about a text document to rerank.
        public var textDocument: BedrockAgentRuntimeClientTypes.RerankTextDocument?
        /// The type of document to rerank.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.RerankDocumentType?

        public init(
            jsonDocument: Smithy.Document? = nil,
            textDocument: BedrockAgentRuntimeClientTypes.RerankTextDocument? = nil,
            type: BedrockAgentRuntimeClientTypes.RerankDocumentType? = nil
        ) {
            self.jsonDocument = jsonDocument
            self.textDocument = textDocument
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RerankDocument: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum RerankSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inline
        case sdkUnknown(Swift.String)

        public static var allCases: [RerankSourceType] {
            return [
                .inline
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inline: return "INLINE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a source for reranking.
    public struct RerankSource: Swift.Sendable {
        /// Contains an inline definition of a source for reranking.
        /// This member is required.
        public var inlineDocumentSource: BedrockAgentRuntimeClientTypes.RerankDocument?
        /// The type of the source.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.RerankSourceType?

        public init(
            inlineDocumentSource: BedrockAgentRuntimeClientTypes.RerankDocument? = nil,
            type: BedrockAgentRuntimeClientTypes.RerankSourceType? = nil
        ) {
            self.inlineDocumentSource = inlineDocumentSource
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RerankSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct RerankInput: Swift.Sendable {
    /// If the total number of results was greater than could fit in a response, a token is returned in the nextToken field. You can enter that token in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// An array of objects, each of which contains information about a query to submit to the reranker model.
    /// This member is required.
    public var queries: [BedrockAgentRuntimeClientTypes.RerankQuery]?
    /// Contains configurations for reranking.
    /// This member is required.
    public var rerankingConfiguration: BedrockAgentRuntimeClientTypes.RerankingConfiguration?
    /// An array of objects, each of which contains information about the sources to rerank.
    /// This member is required.
    public var sources: [BedrockAgentRuntimeClientTypes.RerankSource]?

    public init(
        nextToken: Swift.String? = nil,
        queries: [BedrockAgentRuntimeClientTypes.RerankQuery]? = nil,
        rerankingConfiguration: BedrockAgentRuntimeClientTypes.RerankingConfiguration? = nil,
        sources: [BedrockAgentRuntimeClientTypes.RerankSource]? = nil
    ) {
        self.nextToken = nextToken
        self.queries = queries
        self.rerankingConfiguration = rerankingConfiguration
        self.sources = sources
    }
}

extension RerankInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RerankInput(nextToken: \(Swift.String(describing: nextToken)), rerankingConfiguration: \(Swift.String(describing: rerankingConfiguration)), queries: \"CONTENT_REDACTED\", sources: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains information about a document that was reranked.
    public struct RerankResult: Swift.Sendable {
        /// Contains information about the document.
        public var document: BedrockAgentRuntimeClientTypes.RerankDocument?
        /// The ranking of the document. The lower a number, the higher the document is ranked.
        /// This member is required.
        public var index: Swift.Int?
        /// The relevance score of the document.
        /// This member is required.
        public var relevanceScore: Swift.Float?

        public init(
            document: BedrockAgentRuntimeClientTypes.RerankDocument? = nil,
            index: Swift.Int? = nil,
            relevanceScore: Swift.Float? = nil
        ) {
            self.document = document
            self.index = index
            self.relevanceScore = relevanceScore
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RerankResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RerankResult(index: \(Swift.String(describing: index)), relevanceScore: \(Swift.String(describing: relevanceScore)), document: \"CONTENT_REDACTED\")"}
}

public struct RerankOutput: Swift.Sendable {
    /// If the total number of results is greater than can fit in the response, use this token in the nextToken field when making another request to return the next batch of results.
    public var nextToken: Swift.String?
    /// An array of objects, each of which contains information about the results of reranking.
    /// This member is required.
    public var results: [BedrockAgentRuntimeClientTypes.RerankResult]?

    public init(
        nextToken: Swift.String? = nil,
        results: [BedrockAgentRuntimeClientTypes.RerankResult]? = nil
    ) {
        self.nextToken = nextToken
        self.results = results
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the query made to the knowledge base. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)  in the input field
    public struct RetrieveAndGenerateInput: Swift.Sendable {
        /// The query made to the knowledge base.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The configuration details for the guardrail.
    public struct GuardrailConfiguration: Swift.Sendable {
        /// The unique identifier for the guardrail.
        /// This member is required.
        public var guardrailId: Swift.String?
        /// The version of the guardrail.
        /// This member is required.
        public var guardrailVersion: Swift.String?

        public init(
            guardrailId: Swift.String? = nil,
            guardrailVersion: Swift.String? = nil
        ) {
            self.guardrailId = guardrailId
            self.guardrailVersion = guardrailVersion
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Configuration settings for text generation using a language model via the RetrieveAndGenerate operation. Includes parameters like temperature, top-p, maximum token count, and stop sequences. The valid range of maxTokens depends on the accepted values for your chosen model's inference parameters. To see the inference parameters for your model, see [Inference parameters for foundation models.](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html)
    public struct TextInferenceConfig: Swift.Sendable {
        /// The maximum number of tokens to generate in the output text. Do not use the minimum of 0 or the maximum of 65536. The limit values described here are arbitary values, for actual values consult the limits defined by your specific model.
        public var maxTokens: Swift.Int?
        /// A list of sequences of characters that, if generated, will cause the model to stop generating further tokens. Do not use a minimum length of 1 or a maximum length of 1000. The limit values described here are arbitary values, for actual values consult the limits defined by your specific model.
        public var stopSequences: [Swift.String]?
        /// Controls the random-ness of text generated by the language model, influencing how much the model sticks to the most predictable next words versus exploring more surprising options. A lower temperature value (e.g. 0.2 or 0.3) makes model outputs more deterministic or predictable, while a higher temperature (e.g. 0.8 or 0.9) makes the outputs more creative or unpredictable.
        public var temperature: Swift.Float?
        /// A probability distribution threshold which controls what the model considers for the set of possible next tokens. The model will only consider the top p% of the probability distribution when generating the next token.
        public var topp: Swift.Float?

        public init(
            maxTokens: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topp: Swift.Float? = nil
        ) {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topp = topp
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The configuration for inference settings when generating responses using RetrieveAndGenerate.
    public struct InferenceConfig: Swift.Sendable {
        /// Configuration settings specific to text generation while generating responses using RetrieveAndGenerate.
        public var textInferenceConfig: BedrockAgentRuntimeClientTypes.TextInferenceConfig?

        public init(
            textInferenceConfig: BedrockAgentRuntimeClientTypes.TextInferenceConfig? = nil
        ) {
            self.textInferenceConfig = textInferenceConfig
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the template for the prompt that's sent to the model for response generation. For more information, see [Knowledge base prompt templates](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html#kb-test-config-sysprompt). This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)  in the filter field
    public struct PromptTemplate: Swift.Sendable {
        /// The template for the prompt that's sent to the model for response generation. You can include prompt placeholders, which become replaced before the prompt is sent to the model to provide instructions and context to the model. In addition, you can include XML tags to delineate meaningful sections of the prompt template. For more information, see the following resources:
        ///
        /// * [Knowledge base prompt templates](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html#kb-test-config-sysprompt)
        ///
        /// * [Use XML tags with Anthropic Claude models](https://docs.anthropic.com/claude/docs/use-xml-tags)
        public var textPromptTemplate: Swift.String?

        public init(
            textPromptTemplate: Swift.String? = nil
        ) {
            self.textPromptTemplate = textPromptTemplate
        }
    }
}

extension BedrockAgentRuntimeClientTypes.PromptTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromptTemplate(textPromptTemplate: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the generation configuration of the external source wrapper object.
    public struct ExternalSourcesGenerationConfiguration: Swift.Sendable {
        /// Additional model parameters and their corresponding values not included in the textInferenceConfig structure for an external source. Takes in custom model parameters specific to the language model being used.
        public var additionalModelRequestFields: [Swift.String: Smithy.Document]?
        /// The configuration details for the guardrail.
        public var guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfiguration?
        /// Configuration settings for inference when using RetrieveAndGenerate to generate responses while using an external source.
        public var inferenceConfig: BedrockAgentRuntimeClientTypes.InferenceConfig?
        /// The latency configuration for the model.
        public var performanceConfig: BedrockAgentRuntimeClientTypes.PerformanceConfiguration?
        /// Contain the textPromptTemplate string for the external source wrapper object.
        public var promptTemplate: BedrockAgentRuntimeClientTypes.PromptTemplate?

        public init(
            additionalModelRequestFields: [Swift.String: Smithy.Document]? = nil,
            guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfiguration? = nil,
            inferenceConfig: BedrockAgentRuntimeClientTypes.InferenceConfig? = nil,
            performanceConfig: BedrockAgentRuntimeClientTypes.PerformanceConfiguration? = nil,
            promptTemplate: BedrockAgentRuntimeClientTypes.PromptTemplate? = nil
        ) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.inferenceConfig = inferenceConfig
            self.performanceConfig = performanceConfig
            self.promptTemplate = promptTemplate
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// This property contains the document to chat with, along with its attributes.
    public struct ByteContentDoc: Swift.Sendable {
        /// The MIME type of the document contained in the wrapper object.
        /// This member is required.
        public var contentType: Swift.String?
        /// The byte value of the file to upload, encoded as a Base-64 string.
        /// This member is required.
        public var data: Foundation.Data?
        /// The file name of the document contained in the wrapper object.
        /// This member is required.
        public var identifier: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            data: Foundation.Data? = nil,
            identifier: Swift.String? = nil
        ) {
            self.contentType = contentType
            self.data = data
            self.identifier = identifier
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ByteContentDoc: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ByteContentDoc(contentType: \(Swift.String(describing: contentType)), data: \"CONTENT_REDACTED\", identifier: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// The unique wrapper object of the document from the S3 location.
    public struct S3ObjectDoc: Swift.Sendable {
        /// The file location of the S3 wrapper object.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        ) {
            self.uri = uri
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum ExternalSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case byteContent
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalSourceType] {
            return [
                .byteContent,
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .byteContent: return "BYTE_CONTENT"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The unique external source of the content contained in the wrapper object.
    public struct ExternalSource: Swift.Sendable {
        /// The identifier, contentType, and data of the external source wrapper object.
        public var byteContent: BedrockAgentRuntimeClientTypes.ByteContentDoc?
        /// The S3 location of the external source wrapper object.
        public var s3Location: BedrockAgentRuntimeClientTypes.S3ObjectDoc?
        /// The source type of the external source wrapper object.
        /// This member is required.
        public var sourceType: BedrockAgentRuntimeClientTypes.ExternalSourceType?

        public init(
            byteContent: BedrockAgentRuntimeClientTypes.ByteContentDoc? = nil,
            s3Location: BedrockAgentRuntimeClientTypes.S3ObjectDoc? = nil,
            sourceType: BedrockAgentRuntimeClientTypes.ExternalSourceType? = nil
        ) {
            self.byteContent = byteContent
            self.s3Location = s3Location
            self.sourceType = sourceType
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The configurations of the external source wrapper object in the retrieveAndGenerate function.
    public struct ExternalSourcesRetrieveAndGenerateConfiguration: Swift.Sendable {
        /// The prompt used with the external source wrapper object with the retrieveAndGenerate function.
        public var generationConfiguration: BedrockAgentRuntimeClientTypes.ExternalSourcesGenerationConfiguration?
        /// The model Amazon Resource Name (ARN) for the external source wrapper object in the retrieveAndGenerate function.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The document for the external source wrapper object in the retrieveAndGenerate function.
        /// This member is required.
        public var sources: [BedrockAgentRuntimeClientTypes.ExternalSource]?

        public init(
            generationConfiguration: BedrockAgentRuntimeClientTypes.ExternalSourcesGenerationConfiguration? = nil,
            modelArn: Swift.String? = nil,
            sources: [BedrockAgentRuntimeClientTypes.ExternalSource]? = nil
        ) {
            self.generationConfiguration = generationConfiguration
            self.modelArn = modelArn
            self.sources = sources
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations for response generation based on the knowledge base query results. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)
    public struct GenerationConfiguration: Swift.Sendable {
        /// Additional model parameters and corresponding values not included in the textInferenceConfig structure for a knowledge base. This allows users to provide custom model parameters specific to the language model being used.
        public var additionalModelRequestFields: [Swift.String: Smithy.Document]?
        /// The configuration details for the guardrail.
        public var guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfiguration?
        /// Configuration settings for inference when using RetrieveAndGenerate to generate responses while using a knowledge base as a source.
        public var inferenceConfig: BedrockAgentRuntimeClientTypes.InferenceConfig?
        /// The latency configuration for the model.
        public var performanceConfig: BedrockAgentRuntimeClientTypes.PerformanceConfiguration?
        /// Contains the template for the prompt that's sent to the model for response generation. Generation prompts must include the $search_results$ variable. For more information, see [Use placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html) in the user guide.
        public var promptTemplate: BedrockAgentRuntimeClientTypes.PromptTemplate?

        public init(
            additionalModelRequestFields: [Swift.String: Smithy.Document]? = nil,
            guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfiguration? = nil,
            inferenceConfig: BedrockAgentRuntimeClientTypes.InferenceConfig? = nil,
            performanceConfig: BedrockAgentRuntimeClientTypes.PerformanceConfiguration? = nil,
            promptTemplate: BedrockAgentRuntimeClientTypes.PromptTemplate? = nil
        ) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.inferenceConfig = inferenceConfig
            self.performanceConfig = performanceConfig
            self.promptTemplate = promptTemplate
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum QueryTransformationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case queryDecomposition
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryTransformationType] {
            return [
                .queryDecomposition
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .queryDecomposition: return "QUERY_DECOMPOSITION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// To split up the prompt and retrieve multiple sources, set the transformation type to QUERY_DECOMPOSITION.
    public struct QueryTransformationConfiguration: Swift.Sendable {
        /// The type of transformation to apply to the prompt.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.QueryTransformationType?

        public init(
            type: BedrockAgentRuntimeClientTypes.QueryTransformationType? = nil
        ) {
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Settings for how the model processes the prompt prior to retrieval and generation.
    public struct OrchestrationConfiguration: Swift.Sendable {
        /// Additional model parameters and corresponding values not included in the textInferenceConfig structure for a knowledge base. This allows users to provide custom model parameters specific to the language model being used.
        public var additionalModelRequestFields: [Swift.String: Smithy.Document]?
        /// Configuration settings for inference when using RetrieveAndGenerate to generate responses while using a knowledge base as a source.
        public var inferenceConfig: BedrockAgentRuntimeClientTypes.InferenceConfig?
        /// The latency configuration for the model.
        public var performanceConfig: BedrockAgentRuntimeClientTypes.PerformanceConfiguration?
        /// Contains the template for the prompt that's sent to the model. Orchestration prompts must include the $conversation_history$ and $output_format_instructions$ variables. For more information, see [Use placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html) in the user guide.
        public var promptTemplate: BedrockAgentRuntimeClientTypes.PromptTemplate?
        /// To split up the prompt and retrieve multiple sources, set the transformation type to QUERY_DECOMPOSITION.
        public var queryTransformationConfiguration: BedrockAgentRuntimeClientTypes.QueryTransformationConfiguration?

        public init(
            additionalModelRequestFields: [Swift.String: Smithy.Document]? = nil,
            inferenceConfig: BedrockAgentRuntimeClientTypes.InferenceConfig? = nil,
            performanceConfig: BedrockAgentRuntimeClientTypes.PerformanceConfiguration? = nil,
            promptTemplate: BedrockAgentRuntimeClientTypes.PromptTemplate? = nil,
            queryTransformationConfiguration: BedrockAgentRuntimeClientTypes.QueryTransformationConfiguration? = nil
        ) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.inferenceConfig = inferenceConfig
            self.performanceConfig = performanceConfig
            self.promptTemplate = promptTemplate
            self.queryTransformationConfiguration = queryTransformationConfiguration
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum RetrieveAndGenerateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case externalSources
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrieveAndGenerateType] {
            return [
                .externalSources,
                .knowledgeBase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .externalSources: return "EXTERNAL_SOURCES"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configuration about the session with the knowledge base. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)  in the sessionConfiguration field
    public struct RetrieveAndGenerateSessionConfiguration: Swift.Sendable {
        /// The ARN of the KMS key encrypting the session.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        ) {
            self.kmsKeyArn = kmsKeyArn
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum GuadrailAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case intervened
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuadrailAction] {
            return [
                .intervened,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .intervened: return "INTERVENED"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the response generated from querying the knowledge base. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_ResponseSyntax)  in the output field
    public struct RetrieveAndGenerateOutput: Swift.Sendable {
        /// The response generated from querying the knowledge base.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct RetrieveAndGenerateOutput: Swift.Sendable {
    /// A list of segments of the generated response that are based on sources in the knowledge base, alongside information about the sources.
    public var citations: [BedrockAgentRuntimeClientTypes.Citation]?
    /// Specifies if there is a guardrail intervention in the response.
    public var guardrailAction: BedrockAgentRuntimeClientTypes.GuadrailAction?
    /// Contains the response generated from querying the knowledge base.
    /// This member is required.
    public var output: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput?
    /// The unique identifier of the session. When you first make a RetrieveAndGenerate request, Amazon Bedrock automatically generates this value. You must reuse this value for all subsequent requests in the same conversational session. This value allows Amazon Bedrock to maintain context and knowledge from previous interactions. You can't explicitly set the sessionId yourself.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        citations: [BedrockAgentRuntimeClientTypes.Citation]? = nil,
        guardrailAction: BedrockAgentRuntimeClientTypes.GuadrailAction? = nil,
        output: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.citations = citations
        self.guardrailAction = guardrailAction
        self.output = output
        self.sessionId = sessionId
    }
}

extension RetrieveAndGenerateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveAndGenerateOutput(citations: \(Swift.String(describing: citations)), guardrailAction: \(Swift.String(describing: guardrailAction)), sessionId: \(Swift.String(describing: sessionId)), output: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// A citation event.
    public struct CitationEvent: Swift.Sendable {
        /// The citation.
        @available(*, deprecated, message: "Citation is deprecated. Please use GeneratedResponsePart and RetrievedReferences for citation event. API deprecated since 2024-12-17")
        public var citation: BedrockAgentRuntimeClientTypes.Citation?
        /// The generated response to the citation event.
        public var generatedResponsePart: BedrockAgentRuntimeClientTypes.GeneratedResponsePart?
        /// The retrieved references of the citation event.
        public var retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]?

        public init(
            citation: BedrockAgentRuntimeClientTypes.Citation? = nil,
            generatedResponsePart: BedrockAgentRuntimeClientTypes.GeneratedResponsePart? = nil,
            retrievedReferences: [BedrockAgentRuntimeClientTypes.RetrievedReference]? = nil
        ) {
            self.citation = citation
            self.generatedResponsePart = generatedResponsePart
            self.retrievedReferences = retrievedReferences
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// A guardrail event.
    public struct GuardrailEvent: Swift.Sendable {
        /// The guardrail action.
        public var action: BedrockAgentRuntimeClientTypes.GuadrailAction?

        public init(
            action: BedrockAgentRuntimeClientTypes.GuadrailAction? = nil
        ) {
            self.action = action
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// A retrieve and generate output event.
    public struct RetrieveAndGenerateOutputEvent: Swift.Sendable {
        /// A text response.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutputEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// A retrieve and generate stream response output.
    public enum RetrieveAndGenerateStreamResponseOutput: Swift.Sendable {
        /// An output event.
        case output(BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutputEvent)
        /// A citation event.
        case citation(BedrockAgentRuntimeClientTypes.CitationEvent)
        /// A guardrail event.
        case guardrail(BedrockAgentRuntimeClientTypes.GuardrailEvent)
        case sdkUnknown(Swift.String)
    }
}

public struct RetrieveAndGenerateStreamOutput: Swift.Sendable {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// A stream of events from the model.
    /// This member is required.
    public var stream: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.RetrieveAndGenerateStreamResponseOutput, Swift.Error>?

    public init(
        sessionId: Swift.String? = nil,
        stream: AsyncThrowingStream<BedrockAgentRuntimeClientTypes.RetrieveAndGenerateStreamResponseOutput, Swift.Error>? = nil
    ) {
        self.sessionId = sessionId
        self.stream = stream
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains the query made to the knowledge base. This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax)  in the retrievalQuery field
    public struct KnowledgeBaseQuery: Swift.Sendable {
        /// The text of the query made to the knowledge base.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Details about a result from querying the knowledge base. This data type is used in the following API operations:
    ///
    /// * [Retrieve response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_ResponseSyntax)  in the retrievalResults field
    public struct KnowledgeBaseRetrievalResult: Swift.Sendable {
        /// Contains information about the content of the chunk.
        /// This member is required.
        public var content: BedrockAgentRuntimeClientTypes.RetrievalResultContent?
        /// Contains information about the location of the data source.
        public var location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation?
        /// Contains metadata attributes and their values for the file in the data source. For more information, see [Metadata and filtering](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-ds.html#kb-ds-metadata).
        public var metadata: [Swift.String: Smithy.Document]?
        /// The level of relevance of the result to the query.
        public var score: Swift.Double?

        public init(
            content: BedrockAgentRuntimeClientTypes.RetrievalResultContent? = nil,
            location: BedrockAgentRuntimeClientTypes.RetrievalResultLocation? = nil,
            metadata: [Swift.String: Smithy.Document]? = nil,
            score: Swift.Double? = nil
        ) {
            self.content = content
            self.location = location
            self.metadata = metadata
            self.score = score
        }
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseRetrievalResult(score: \(Swift.String(describing: score)), content: \"CONTENT_REDACTED\", location: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

public struct RetrieveOutput: Swift.Sendable {
    /// Specifies if there is a guardrail intervention in the response.
    public var guardrailAction: BedrockAgentRuntimeClientTypes.GuadrailAction?
    /// If there are more results than can fit in the response, the response returns a nextToken. Use this token in the nextToken field of another request to retrieve the next batch of results.
    public var nextToken: Swift.String?
    /// A list of results from querying the knowledge base.
    /// This member is required.
    public var retrievalResults: [BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]?

    public init(
        guardrailAction: BedrockAgentRuntimeClientTypes.GuadrailAction? = nil,
        nextToken: Swift.String? = nil,
        retrievalResults: [BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult]? = nil
    ) {
        self.guardrailAction = guardrailAction
        self.nextToken = nextToken
        self.retrievalResults = retrievalResults
    }
}

extension RetrieveOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveOutput(guardrailAction: \(Swift.String(describing: guardrailAction)), nextToken: \(Swift.String(describing: nextToken)), retrievalResults: \"CONTENT_REDACTED\")"}
}

public struct CreateSessionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the KMS key to use to encrypt the session data. The user or role creating the session must have permission to use the key. For more information, see [Amazon Bedrock session encryption](https://docs.aws.amazon.com/bedrock/latest/userguide/session-encryption.html).
    public var encryptionKeyArn: Swift.String?
    /// A map of key-value pairs containing attributes to be persisted across the session. For example, the user's ID, their language preference, and the type of device they are using.
    public var sessionMetadata: [Swift.String: Swift.String]?
    /// Specify the key-value pairs for the tags that you want to attach to the session.
    public var tags: [Swift.String: Swift.String]?

    public init(
        encryptionKeyArn: Swift.String? = nil,
        sessionMetadata: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.encryptionKeyArn = encryptionKeyArn
        self.sessionMetadata = sessionMetadata
        self.tags = tags
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum SessionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case ended
        case expired
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionStatus] {
            return [
                .active,
                .ended,
                .expired
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .ended: return "ENDED"
            case .expired: return "EXPIRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSessionOutput: Swift.Sendable {
    /// The timestamp for when the session was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the created session.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The unique identifier for the session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The current status of the session.
    /// This member is required.
    public var sessionStatus: BedrockAgentRuntimeClientTypes.SessionStatus?

    public init(
        createdAt: Foundation.Date? = nil,
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionStatus: BedrockAgentRuntimeClientTypes.SessionStatus? = nil
    ) {
        self.createdAt = createdAt
        self.sessionArn = sessionArn
        self.sessionId = sessionId
        self.sessionStatus = sessionStatus
    }
}

public struct DeleteSessionInput: Swift.Sendable {
    /// The unique identifier for the session to be deleted. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
    /// This member is required.
    public var sessionIdentifier: Swift.String?

    public init(
        sessionIdentifier: Swift.String? = nil
    ) {
        self.sessionIdentifier = sessionIdentifier
    }
}

public struct DeleteSessionOutput: Swift.Sendable {

    public init() { }
}

public struct EndSessionInput: Swift.Sendable {
    /// The unique identifier for the session to end. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
    /// This member is required.
    public var sessionIdentifier: Swift.String?

    public init(
        sessionIdentifier: Swift.String? = nil
    ) {
        self.sessionIdentifier = sessionIdentifier
    }
}

public struct EndSessionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the session you ended.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The unique identifier of the session you ended.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The current status of the session you ended.
    /// This member is required.
    public var sessionStatus: BedrockAgentRuntimeClientTypes.SessionStatus?

    public init(
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionStatus: BedrockAgentRuntimeClientTypes.SessionStatus? = nil
    ) {
        self.sessionArn = sessionArn
        self.sessionId = sessionId
        self.sessionStatus = sessionStatus
    }
}

public struct GetSessionInput: Swift.Sendable {
    /// A unique identifier for the session to retrieve. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
    /// This member is required.
    public var sessionIdentifier: Swift.String?

    public init(
        sessionIdentifier: Swift.String? = nil
    ) {
        self.sessionIdentifier = sessionIdentifier
    }
}

public struct GetSessionOutput: Swift.Sendable {
    /// The timestamp for when the session was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the Key Management Service key used to encrypt the session data. For more information, see [Amazon Bedrock session encryption](https://docs.aws.amazon.com/bedrock/latest/userguide/session-encryption.html).
    public var encryptionKeyArn: Swift.String?
    /// The timestamp for when the session was last modified.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the session.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The unique identifier for the session in UUID format.
    /// This member is required.
    public var sessionId: Swift.String?
    /// A map of key-value pairs containing attributes persisted across the session.
    public var sessionMetadata: [Swift.String: Swift.String]?
    /// The current status of the session.
    /// This member is required.
    public var sessionStatus: BedrockAgentRuntimeClientTypes.SessionStatus?

    public init(
        createdAt: Foundation.Date? = nil,
        encryptionKeyArn: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionMetadata: [Swift.String: Swift.String]? = nil,
        sessionStatus: BedrockAgentRuntimeClientTypes.SessionStatus? = nil
    ) {
        self.createdAt = createdAt
        self.encryptionKeyArn = encryptionKeyArn
        self.lastUpdatedAt = lastUpdatedAt
        self.sessionArn = sessionArn
        self.sessionId = sessionId
        self.sessionMetadata = sessionMetadata
        self.sessionStatus = sessionStatus
    }
}

public struct CreateInvocationInput: Swift.Sendable {
    /// A description for the interactions in the invocation. For example, "User asking about weather in Seattle".
    public var description: Swift.String?
    /// A unique identifier for the invocation in UUID format.
    public var invocationId: Swift.String?
    /// The unique identifier for the associated session for the invocation. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
    /// This member is required.
    public var sessionIdentifier: Swift.String?

    public init(
        description: Swift.String? = nil,
        invocationId: Swift.String? = nil,
        sessionIdentifier: Swift.String? = nil
    ) {
        self.description = description
        self.invocationId = invocationId
        self.sessionIdentifier = sessionIdentifier
    }
}

public struct CreateInvocationOutput: Swift.Sendable {
    /// The timestamp for when the invocation was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The unique identifier for the invocation.
    /// This member is required.
    public var invocationId: Swift.String?
    /// The unique identifier for the session associated with the invocation.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        invocationId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.invocationId = invocationId
        self.sessionId = sessionId
    }
}

public struct ListInvocationsInput: Swift.Sendable {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The unique identifier for the session to list invocations for. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
    /// This member is required.
    public var sessionIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionIdentifier: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionIdentifier = sessionIdentifier
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about an invocation in a session. For more information about sessions, see [Store and retrieve conversation history and context with Amazon Bedrock sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
    public struct InvocationSummary: Swift.Sendable {
        /// The timestamp for when the invocation was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// A unique identifier for the invocation in UUID format.
        /// This member is required.
        public var invocationId: Swift.String?
        /// The unique identifier for the session associated with the invocation.
        /// This member is required.
        public var sessionId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            invocationId: Swift.String? = nil,
            sessionId: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.invocationId = invocationId
            self.sessionId = sessionId
        }
    }
}

public struct ListInvocationsOutput: Swift.Sendable {
    /// A list of invocation summaries associated with the session.
    /// This member is required.
    public var invocationSummaries: [BedrockAgentRuntimeClientTypes.InvocationSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        invocationSummaries: [BedrockAgentRuntimeClientTypes.InvocationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.invocationSummaries = invocationSummaries
        self.nextToken = nextToken
    }
}

public struct GetInvocationStepInput: Swift.Sendable {
    /// The unique identifier for the invocation in UUID format.
    /// This member is required.
    public var invocationIdentifier: Swift.String?
    /// The unique identifier (in UUID format) for the specific invocation step to retrieve.
    /// This member is required.
    public var invocationStepId: Swift.String?
    /// The unique identifier for the invocation step's associated session. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
    /// This member is required.
    public var sessionIdentifier: Swift.String?

    public init(
        invocationIdentifier: Swift.String? = nil,
        invocationStepId: Swift.String? = nil,
        sessionIdentifier: Swift.String? = nil
    ) {
        self.invocationIdentifier = invocationIdentifier
        self.invocationStepId = invocationStepId
        self.sessionIdentifier = sessionIdentifier
    }
}

extension BedrockAgentRuntimeClientTypes {

    public enum ImageFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gif
        case jpeg
        case png
        case webp
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFormat] {
            return [
                .gif,
                .jpeg,
                .png,
                .webp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gif: return "gif"
            case .jpeg: return "jpeg"
            case .png: return "png"
            case .webp: return "webp"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Information about the Amazon S3 bucket where the image is stored.
    public struct S3Location: Swift.Sendable {
        /// The path to the Amazon S3 bucket where the image is stored.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        ) {
            self.uri = uri
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// The source for an image.
    public enum ImageSource: Swift.Sendable {
        /// The raw image bytes for the image. If you use an Amazon Web Services SDK, you don't need to encode the image bytes in base64.
        case bytes(Foundation.Data)
        /// The path to the Amazon S3 bucket where the image is stored.
        case s3location(BedrockAgentRuntimeClientTypes.S3Location)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Image content for an invocation step.
    public struct ImageBlock: Swift.Sendable {
        /// The format of the image.
        /// This member is required.
        public var format: BedrockAgentRuntimeClientTypes.ImageFormat?
        /// The source for the image.
        /// This member is required.
        public var source: BedrockAgentRuntimeClientTypes.ImageSource?

        public init(
            format: BedrockAgentRuntimeClientTypes.ImageFormat? = nil,
            source: BedrockAgentRuntimeClientTypes.ImageSource? = nil
        ) {
            self.format = format
            self.source = source
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// A block of content that you pass to, or receive from, a Amazon Bedrock session in an invocation step. You pass the content to a session in the payLoad of the [PutInvocationStep](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_PutInvocationStep.html) API operation. You retrieve the content with the [GetInvocationStep](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_GetInvocationStep.html) API operation. For more information about sessions, see [Store and retrieve conversation history and context with Amazon Bedrock sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
    public enum BedrockSessionContentBlock: Swift.Sendable {
        /// The text in the invocation step.
        case text(Swift.String)
        /// The image in the invocation step.
        case image(BedrockAgentRuntimeClientTypes.ImageBlock)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Payload content, such as text and images, for the invocation step.
    public enum InvocationStepPayload: Swift.Sendable {
        /// The content for the invocation step.
        case contentblocks([BedrockAgentRuntimeClientTypes.BedrockSessionContentBlock])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Stores fine-grained state checkpoints, including text and images, for each interaction in an invocation in a session. For more information about sessions, see [Store and retrieve conversation history and context with Amazon Bedrock sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
    public struct InvocationStep: Swift.Sendable {
        /// The unique identifier (in UUID format) for the invocation that includes the invocation step.
        /// This member is required.
        public var invocationId: Swift.String?
        /// The unique identifier (in UUID format) for the invocation step.
        /// This member is required.
        public var invocationStepId: Swift.String?
        /// The timestamp for when the invocation step was created.
        /// This member is required.
        public var invocationStepTime: Foundation.Date?
        /// Payload content, such as text and images, for the invocation step.
        /// This member is required.
        public var payload: BedrockAgentRuntimeClientTypes.InvocationStepPayload?
        /// The unique identifier of the session containing the invocation step.
        /// This member is required.
        public var sessionId: Swift.String?

        public init(
            invocationId: Swift.String? = nil,
            invocationStepId: Swift.String? = nil,
            invocationStepTime: Foundation.Date? = nil,
            payload: BedrockAgentRuntimeClientTypes.InvocationStepPayload? = nil,
            sessionId: Swift.String? = nil
        ) {
            self.invocationId = invocationId
            self.invocationStepId = invocationStepId
            self.invocationStepTime = invocationStepTime
            self.payload = payload
            self.sessionId = sessionId
        }
    }
}

public struct GetInvocationStepOutput: Swift.Sendable {
    /// The complete details of the requested invocation step.
    /// This member is required.
    public var invocationStep: BedrockAgentRuntimeClientTypes.InvocationStep?

    public init(
        invocationStep: BedrockAgentRuntimeClientTypes.InvocationStep? = nil
    ) {
        self.invocationStep = invocationStep
    }
}

public struct ListInvocationStepsInput: Swift.Sendable {
    /// The unique identifier (in UUID format) for the invocation to list invocation steps for.
    public var invocationIdentifier: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The unique identifier for the session associated with the invocation steps. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
    /// This member is required.
    public var sessionIdentifier: Swift.String?

    public init(
        invocationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionIdentifier: Swift.String? = nil
    ) {
        self.invocationIdentifier = invocationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionIdentifier = sessionIdentifier
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about an invocation step within an invocation in a session. For more information about sessions, see [Store and retrieve conversation history and context with Amazon Bedrock sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
    public struct InvocationStepSummary: Swift.Sendable {
        /// A unique identifier for the invocation in UUID format.
        /// This member is required.
        public var invocationId: Swift.String?
        /// The unique identifier (in UUID format) for the invocation step.
        /// This member is required.
        public var invocationStepId: Swift.String?
        /// The timestamp for when the invocation step was created.
        /// This member is required.
        public var invocationStepTime: Foundation.Date?
        /// The unique identifier for the session associated with the invocation step.
        /// This member is required.
        public var sessionId: Swift.String?

        public init(
            invocationId: Swift.String? = nil,
            invocationStepId: Swift.String? = nil,
            invocationStepTime: Foundation.Date? = nil,
            sessionId: Swift.String? = nil
        ) {
            self.invocationId = invocationId
            self.invocationStepId = invocationStepId
            self.invocationStepTime = invocationStepTime
            self.sessionId = sessionId
        }
    }
}

public struct ListInvocationStepsOutput: Swift.Sendable {
    /// A list of summaries for each invocation step associated with a session and if you specified it, an invocation within the session.
    /// This member is required.
    public var invocationStepSummaries: [BedrockAgentRuntimeClientTypes.InvocationStepSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        invocationStepSummaries: [BedrockAgentRuntimeClientTypes.InvocationStepSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.invocationStepSummaries = invocationStepSummaries
        self.nextToken = nextToken
    }
}

public struct PutInvocationStepInput: Swift.Sendable {
    /// The unique identifier (in UUID format) of the invocation to add the invocation step to.
    /// This member is required.
    public var invocationIdentifier: Swift.String?
    /// The unique identifier of the invocation step in UUID format.
    public var invocationStepId: Swift.String?
    /// The timestamp for when the invocation step occurred.
    /// This member is required.
    public var invocationStepTime: Foundation.Date?
    /// The payload for the invocation step, including text and images for the interaction.
    /// This member is required.
    public var payload: BedrockAgentRuntimeClientTypes.InvocationStepPayload?
    /// The unique identifier for the session to add the invocation step to. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
    /// This member is required.
    public var sessionIdentifier: Swift.String?

    public init(
        invocationIdentifier: Swift.String? = nil,
        invocationStepId: Swift.String? = nil,
        invocationStepTime: Foundation.Date? = nil,
        payload: BedrockAgentRuntimeClientTypes.InvocationStepPayload? = nil,
        sessionIdentifier: Swift.String? = nil
    ) {
        self.invocationIdentifier = invocationIdentifier
        self.invocationStepId = invocationStepId
        self.invocationStepTime = invocationStepTime
        self.payload = payload
        self.sessionIdentifier = sessionIdentifier
    }
}

public struct PutInvocationStepOutput: Swift.Sendable {
    /// The unique identifier of the invocation step in UUID format.
    /// This member is required.
    public var invocationStepId: Swift.String?

    public init(
        invocationStepId: Swift.String? = nil
    ) {
        self.invocationStepId = invocationStepId
    }
}

public struct ListSessionsInput: Swift.Sendable {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about a session. For more information about sessions, see [Store and retrieve conversation history and context with Amazon Bedrock sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
    public struct SessionSummary: Swift.Sendable {
        /// The timestamp for when the session was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The timestamp for when the session was last modified.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the session.
        /// This member is required.
        public var sessionArn: Swift.String?
        /// The unique identifier for the session.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The current status of the session.
        /// This member is required.
        public var sessionStatus: BedrockAgentRuntimeClientTypes.SessionStatus?

        public init(
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            sessionArn: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            sessionStatus: BedrockAgentRuntimeClientTypes.SessionStatus? = nil
        ) {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.sessionStatus = sessionStatus
        }
    }
}

public struct ListSessionsOutput: Swift.Sendable {
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?
    /// A list of summaries for each session in your Amazon Web Services account.
    /// This member is required.
    public var sessionSummaries: [BedrockAgentRuntimeClientTypes.SessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessionSummaries: [BedrockAgentRuntimeClientTypes.SessionSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.sessionSummaries = sessionSummaries
    }
}

public struct UpdateSessionInput: Swift.Sendable {
    /// The unique identifier of the session to modify. You can specify either the session's sessionId or its Amazon Resource Name (ARN).
    /// This member is required.
    public var sessionIdentifier: Swift.String?
    /// A map of key-value pairs containing attributes to be persisted across the session. For example the user's ID, their language preference, and the type of device they are using.
    public var sessionMetadata: [Swift.String: Swift.String]?

    public init(
        sessionIdentifier: Swift.String? = nil,
        sessionMetadata: [Swift.String: Swift.String]? = nil
    ) {
        self.sessionIdentifier = sessionIdentifier
        self.sessionMetadata = sessionMetadata
    }
}

public struct UpdateSessionOutput: Swift.Sendable {
    /// The timestamp for when the session was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The timestamp for when the session was last modified.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the session that was updated.
    /// This member is required.
    public var sessionArn: Swift.String?
    /// The unique identifier of the session you updated.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The status of the session you updated.
    /// This member is required.
    public var sessionStatus: BedrockAgentRuntimeClientTypes.SessionStatus?

    public init(
        createdAt: Foundation.Date? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionStatus: BedrockAgentRuntimeClientTypes.SessionStatus? = nil
    ) {
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.sessionArn = sessionArn
        self.sessionId = sessionId
        self.sessionStatus = sessionStatus
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource for which to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The key-value pairs for the tags associated with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An object containing key-value pairs that define the tags to attach to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource from which to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension BedrockAgentRuntimeClientTypes {

    /// Specifies the filters to use on the metadata attributes in the knowledge base data sources before returning results. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html). See the examples below to see how to use these filters. This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax)  in the filter field
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)  in the filter field
    public indirect enum RetrievalFilter: Swift.Sendable {
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value matches the value in this object. The following example would return data sources with an animal attribute whose value is cat: "equals": { "key": "animal", "value": "cat" }
        case equals(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned when:
        ///
        /// * It contains a metadata attribute whose name matches the key and whose value doesn't match the value in this object.
        ///
        /// * The key is not present in the document.
        ///
        ///
        /// The following example would return data sources that don't contain an animal attribute whose value is cat. "notEquals": { "key": "animal", "value": "cat" }
        case notequals(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is greater than the value in this object. The following example would return data sources with an year attribute whose value is greater than 1989: "greaterThan": { "key": "year", "value": 1989 }
        case greaterthan(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is greater than or equal to the value in this object. The following example would return data sources with an year attribute whose value is greater than or equal to 1989: "greaterThanOrEquals": { "key": "year", "value": 1989 }
        case greaterthanorequals(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is less than the value in this object. The following example would return data sources with an year attribute whose value is less than to 1989. "lessThan": { "key": "year", "value": 1989 }
        case lessthan(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is less than or equal to the value in this object. The following example would return data sources with an year attribute whose value is less than or equal to 1989. "lessThanOrEquals": { "key": "year", "value": 1989 }
        case lessthanorequals(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is in the list specified in the value in this object. The following example would return data sources with an animal attribute that is either cat or dog: "in": { "key": "animal", "value": ["cat", "dog"] }
        case `in`(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value isn't in the list specified in the value in this object. The following example would return data sources whose animal attribute is neither cat nor dog. "notIn": { "key": "animal", "value": ["cat", "dog"] }
        case notin(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value starts with the value in this object. This filter is currently only supported for Amazon OpenSearch Serverless vector stores. The following example would return data sources with an animal attribute starts with ca (for example, cat or camel). "startsWith": { "key": "animal", "value": "ca" }
        case startswith(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is a list that contains the value as one of its members. The following example would return data sources with an animals attribute that is a list containing a cat member (for example ["dog", "cat"]). "listContains": { "key": "animals", "value": "cat" }
        case listcontains(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is one of the following:
        ///
        /// * A string that contains the value as a substring. The following example would return data sources with an animal attribute that contains the substring at (for example cat). "stringContains": { "key": "animal", "value": "at" }
        ///
        /// * A list with a member that contains the value as a substring. The following example would return data sources with an animals attribute that is a list containing a member that contains the substring at (for example ["dog", "cat"]). "stringContains": { "key": "animals", "value": "at" }
        case stringcontains(BedrockAgentRuntimeClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if their metadata attributes fulfill all the filter conditions inside this list.
        case andall([BedrockAgentRuntimeClientTypes.RetrievalFilter])
        /// Knowledge base data sources are returned if their metadata attributes fulfill at least one of the filter conditions inside this list.
        case orall([BedrockAgentRuntimeClientTypes.RetrievalFilter])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Configurations for how to perform the search query and return results. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html). This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax)  in the vectorSearchConfiguration field
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)  in the vectorSearchConfiguration field
    public struct KnowledgeBaseVectorSearchConfiguration: Swift.Sendable {
        /// Specifies the filters to use on the metadata in the knowledge base data sources before returning results. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
        public var filter: BedrockAgentRuntimeClientTypes.RetrievalFilter?
        /// Settings for implicit filtering.
        public var implicitFilterConfiguration: BedrockAgentRuntimeClientTypes.ImplicitFilterConfiguration?
        /// The number of source chunks to retrieve.
        public var numberOfResults: Swift.Int?
        /// By default, Amazon Bedrock decides a search strategy for you. If you're using an Amazon OpenSearch Serverless vector store that contains a filterable text field, you can specify whether to query the knowledge base with a HYBRID search using both vector embeddings and raw text, or SEMANTIC search using only vector embeddings. For other vector store configurations, only SEMANTIC search is available. For more information, see [Test a knowledge base](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-test.html).
        public var overrideSearchType: BedrockAgentRuntimeClientTypes.SearchType?
        /// Contains configurations for reranking the retrieved results. For more information, see [Improve the relevance of query responses with a reranker model](https://docs.aws.amazon.com/bedrock/latest/userguide/rerank.html).
        public var rerankingConfiguration: BedrockAgentRuntimeClientTypes.VectorSearchRerankingConfiguration?

        public init(
            filter: BedrockAgentRuntimeClientTypes.RetrievalFilter? = nil,
            implicitFilterConfiguration: BedrockAgentRuntimeClientTypes.ImplicitFilterConfiguration? = nil,
            numberOfResults: Swift.Int? = 5,
            overrideSearchType: BedrockAgentRuntimeClientTypes.SearchType? = nil,
            rerankingConfiguration: BedrockAgentRuntimeClientTypes.VectorSearchRerankingConfiguration? = nil
        ) {
            self.filter = filter
            self.implicitFilterConfiguration = implicitFilterConfiguration
            self.numberOfResults = numberOfResults
            self.overrideSearchType = overrideSearchType
            self.rerankingConfiguration = rerankingConfiguration
        }
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseVectorSearchConfiguration(implicitFilterConfiguration: \(Swift.String(describing: implicitFilterConfiguration)), numberOfResults: \(Swift.String(describing: numberOfResults)), overrideSearchType: \(Swift.String(describing: overrideSearchType)), rerankingConfiguration: \(Swift.String(describing: rerankingConfiguration)), filter: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains configurations for knowledge base query. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html). This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax)  in the retrievalConfiguration field
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)  in the retrievalConfiguration field
    public struct KnowledgeBaseRetrievalConfiguration: Swift.Sendable {
        /// Contains details about how the results from the vector search should be returned. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
        /// This member is required.
        public var vectorSearchConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration?

        public init(
            vectorSearchConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration? = nil
        ) {
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Details of the knowledge base associated withe inline agent.
    public struct KnowledgeBase: Swift.Sendable {
        /// The description of the knowledge base associated with the inline agent.
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier for a knowledge base associated with the inline agent.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The configurations to apply to the knowledge base during query. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
        public var retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration? = nil
        ) {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.retrievalConfiguration = retrievalConfiguration
        }
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBase: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBase(knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), retrievalConfiguration: \(Swift.String(describing: retrievalConfiguration)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Configurations to apply to a knowledge base attached to the agent during query. For more information, see [Knowledge base retrieval configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html#session-state-kb).
    public struct KnowledgeBaseConfiguration: Swift.Sendable {
        /// The unique identifier for a knowledge base attached to the agent.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The configurations to apply to the knowledge base during query. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
        /// This member is required.
        public var retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration?

        public init(
            knowledgeBaseId: Swift.String? = nil,
            retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration? = nil
        ) {
            self.knowledgeBaseId = knowledgeBaseId
            self.retrievalConfiguration = retrievalConfiguration
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about the resource being queried. This data type is used in the following API operations:
    ///
    /// * [Retrieve request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Retrieve.html#API_agent-runtime_Retrieve_RequestSyntax)  in the knowledgeBaseConfiguration field
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)  in the knowledgeBaseConfiguration field
    public struct KnowledgeBaseRetrieveAndGenerateConfiguration: Swift.Sendable {
        /// Contains configurations for response generation based on the knowledge base query results.
        public var generationConfiguration: BedrockAgentRuntimeClientTypes.GenerationConfiguration?
        /// The unique identifier of the knowledge base that is queried.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The ARN of the foundation model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) used to generate a response.
        /// This member is required.
        public var modelArn: Swift.String?
        /// Settings for how the model processes the prompt prior to retrieval and generation.
        public var orchestrationConfiguration: BedrockAgentRuntimeClientTypes.OrchestrationConfiguration?
        /// Contains configurations for how to retrieve and return the knowledge base query.
        public var retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration?

        public init(
            generationConfiguration: BedrockAgentRuntimeClientTypes.GenerationConfiguration? = nil,
            knowledgeBaseId: Swift.String? = nil,
            modelArn: Swift.String? = nil,
            orchestrationConfiguration: BedrockAgentRuntimeClientTypes.OrchestrationConfiguration? = nil,
            retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration? = nil
        ) {
            self.generationConfiguration = generationConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.modelArn = modelArn
            self.orchestrationConfiguration = orchestrationConfiguration
            self.retrievalConfiguration = retrievalConfiguration
        }
    }
}

public struct RetrieveInput: Swift.Sendable {
    /// Guardrail settings.
    public var guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfiguration?
    /// The unique identifier of the knowledge base to query.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// If there are more results than can fit in the response, the response returns a nextToken. Use this token in the nextToken field of another request to retrieve the next batch of results.
    public var nextToken: Swift.String?
    /// Contains configurations for the knowledge base query and retrieval process. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
    public var retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration?
    /// Contains the query to send the knowledge base.
    /// This member is required.
    public var retrievalQuery: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery?

    public init(
        guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfiguration? = nil,
        knowledgeBaseId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        retrievalConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration? = nil,
        retrievalQuery: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery? = nil
    ) {
        self.guardrailConfiguration = guardrailConfiguration
        self.knowledgeBaseId = knowledgeBaseId
        self.nextToken = nextToken
        self.retrievalConfiguration = retrievalConfiguration
        self.retrievalQuery = retrievalQuery
    }
}

extension RetrieveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveInput(guardrailConfiguration: \(Swift.String(describing: guardrailConfiguration)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), nextToken: \(Swift.String(describing: nextToken)), retrievalConfiguration: \(Swift.String(describing: retrievalConfiguration)), retrievalQuery: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains details about the resource being queried. This data type is used in the following API operations:
    ///
    /// * [RetrieveAndGenerate request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html#API_agent-runtime_RetrieveAndGenerate_RequestSyntax)  in the retrieveAndGenerateConfiguration field
    public struct RetrieveAndGenerateConfiguration: Swift.Sendable {
        /// The configuration for the external source wrapper object in the retrieveAndGenerate function.
        public var externalSourcesConfiguration: BedrockAgentRuntimeClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration?
        /// Contains details about the knowledge base for retrieving information and generating responses.
        public var knowledgeBaseConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration?
        /// The type of resource that contains your data for retrieving information and generating responses. If you choose to use EXTERNAL_SOURCES, then currently only Anthropic Claude 3 Sonnet models for knowledge bases are supported.
        /// This member is required.
        public var type: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateType?

        public init(
            externalSourcesConfiguration: BedrockAgentRuntimeClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration? = nil,
            knowledgeBaseConfiguration: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration? = nil,
            type: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateType? = nil
        ) {
            self.externalSourcesConfiguration = externalSourcesConfiguration
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.type = type
        }
    }
}

extension BedrockAgentRuntimeClientTypes {

    /// List of inline collaborators.
    public struct Collaborator: Swift.Sendable {
        /// List of action groups with each action group defining tasks the inline collaborator agent needs to carry out.
        public var actionGroups: [BedrockAgentRuntimeClientTypes.AgentActionGroup]?
        /// Defines how the inline supervisor agent handles information across multiple collaborator agents to coordinate a final response.
        public var agentCollaboration: BedrockAgentRuntimeClientTypes.AgentCollaboration?
        /// Name of the inline collaborator agent which must be the same name as specified for collaboratorName.
        public var agentName: Swift.String?
        /// Settings of the collaborator agent.
        public var collaboratorConfigurations: [BedrockAgentRuntimeClientTypes.CollaboratorConfiguration]?
        /// The Amazon Resource Name (ARN) of the AWS KMS key that encrypts the inline collaborator.
        public var customerEncryptionKeyArn: Swift.String?
        /// The foundation model used by the inline collaborator agent.
        /// This member is required.
        public var foundationModel: Swift.String?
        /// Details of the guardwrail associated with the inline collaborator.
        public var guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfigurationWithArn?
        /// The number of seconds for which the Amazon Bedrock keeps information about the user's conversation with the inline collaborator agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        public var idleSessionTTLInSeconds: Swift.Int?
        /// Instruction that tell the inline collaborator agent what it should do and how it should interact with users.
        /// This member is required.
        public var instruction: Swift.String?
        /// Knowledge base associated with the inline collaborator agent.
        public var knowledgeBases: [BedrockAgentRuntimeClientTypes.KnowledgeBase]?
        /// Contains configurations to override prompt templates in different parts of an inline collaborator sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
        public var promptOverrideConfiguration: BedrockAgentRuntimeClientTypes.PromptOverrideConfiguration?

        public init(
            actionGroups: [BedrockAgentRuntimeClientTypes.AgentActionGroup]? = nil,
            agentCollaboration: BedrockAgentRuntimeClientTypes.AgentCollaboration? = nil,
            agentName: Swift.String? = nil,
            collaboratorConfigurations: [BedrockAgentRuntimeClientTypes.CollaboratorConfiguration]? = nil,
            customerEncryptionKeyArn: Swift.String? = nil,
            foundationModel: Swift.String? = nil,
            guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfigurationWithArn? = nil,
            idleSessionTTLInSeconds: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            knowledgeBases: [BedrockAgentRuntimeClientTypes.KnowledgeBase]? = nil,
            promptOverrideConfiguration: BedrockAgentRuntimeClientTypes.PromptOverrideConfiguration? = nil
        ) {
            self.actionGroups = actionGroups
            self.agentCollaboration = agentCollaboration
            self.agentName = agentName
            self.collaboratorConfigurations = collaboratorConfigurations
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.foundationModel = foundationModel
            self.guardrailConfiguration = guardrailConfiguration
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.knowledgeBases = knowledgeBases
            self.promptOverrideConfiguration = promptOverrideConfiguration
        }
    }
}

extension BedrockAgentRuntimeClientTypes.Collaborator: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Collaborator(actionGroups: \(Swift.String(describing: actionGroups)), agentCollaboration: \(Swift.String(describing: agentCollaboration)), collaboratorConfigurations: \(Swift.String(describing: collaboratorConfigurations)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), foundationModel: \(Swift.String(describing: foundationModel)), guardrailConfiguration: \(Swift.String(describing: guardrailConfiguration)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), knowledgeBases: \(Swift.String(describing: knowledgeBases)), agentName: \"CONTENT_REDACTED\", instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentRuntimeClientTypes {

    /// Contains parameters that specify various attributes that persist across a session or prompt. You can define session state attributes as key-value pairs when writing a [Lambda function](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-lambda.html) for an action group or pass them when making an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request. Use session state attributes to control and provide conversational context for your agent and to help customize your agent's behavior. For more information, see [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html).
    public struct SessionState: Swift.Sendable {
        /// The state's conversation history.
        public var conversationHistory: BedrockAgentRuntimeClientTypes.ConversationHistory?
        /// Contains information about the files used by code interpreter.
        public var files: [BedrockAgentRuntimeClientTypes.InputFile]?
        /// The identifier of the invocation of an action. This value must match the invocationId returned in the InvokeAgent response for the action whose results are provided in the returnControlInvocationResults field. For more information, see [Return control to the agent developer](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-returncontrol.html) and [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html).
        public var invocationId: Swift.String?
        /// An array of configurations, each of which applies to a knowledge base attached to the agent.
        public var knowledgeBaseConfigurations: [BedrockAgentRuntimeClientTypes.KnowledgeBaseConfiguration]?
        /// Contains attributes that persist across a prompt and the values of those attributes.
        ///
        /// * In orchestration prompt template, these attributes replace the $prompt_session_attributes$ placeholder variable. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        ///
        /// * In [multi-agent collaboration](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-multi-agent-collaboration.html), the promptSessionAttributes will only be used by supervisor agent when $prompt_session_attributes$ is present in prompt template.
        public var promptSessionAttributes: [Swift.String: Swift.String]?
        /// Contains information about the results from the action group invocation. For more information, see [Return control to the agent developer](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-returncontrol.html) and [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html). If you include this field, the inputText field will be ignored.
        public var returnControlInvocationResults: [BedrockAgentRuntimeClientTypes.InvocationResultMember]?
        /// Contains attributes that persist across a session and the values of those attributes. If sessionAttributes are passed to a supervisor agent in [multi-agent collaboration](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-multi-agent-collaboration.html), it will be forwarded to all agent collaborators.
        public var sessionAttributes: [Swift.String: Swift.String]?

        public init(
            conversationHistory: BedrockAgentRuntimeClientTypes.ConversationHistory? = nil,
            files: [BedrockAgentRuntimeClientTypes.InputFile]? = nil,
            invocationId: Swift.String? = nil,
            knowledgeBaseConfigurations: [BedrockAgentRuntimeClientTypes.KnowledgeBaseConfiguration]? = nil,
            promptSessionAttributes: [Swift.String: Swift.String]? = nil,
            returnControlInvocationResults: [BedrockAgentRuntimeClientTypes.InvocationResultMember]? = nil,
            sessionAttributes: [Swift.String: Swift.String]? = nil
        ) {
            self.conversationHistory = conversationHistory
            self.files = files
            self.invocationId = invocationId
            self.knowledgeBaseConfigurations = knowledgeBaseConfigurations
            self.promptSessionAttributes = promptSessionAttributes
            self.returnControlInvocationResults = returnControlInvocationResults
            self.sessionAttributes = sessionAttributes
        }
    }
}

public struct RetrieveAndGenerateInput: Swift.Sendable {
    /// Contains the query to be made to the knowledge base.
    /// This member is required.
    public var input: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput?
    /// Contains configurations for the knowledge base query and retrieval process. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
    public var retrieveAndGenerateConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration?
    /// Contains details about the session with the knowledge base.
    public var sessionConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration?
    /// The unique identifier of the session. When you first make a RetrieveAndGenerate request, Amazon Bedrock automatically generates this value. You must reuse this value for all subsequent requests in the same conversational session. This value allows Amazon Bedrock to maintain context and knowledge from previous interactions. You can't explicitly set the sessionId yourself.
    public var sessionId: Swift.String?

    public init(
        input: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput? = nil,
        retrieveAndGenerateConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration? = nil,
        sessionConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.input = input
        self.retrieveAndGenerateConfiguration = retrieveAndGenerateConfiguration
        self.sessionConfiguration = sessionConfiguration
        self.sessionId = sessionId
    }
}

extension RetrieveAndGenerateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveAndGenerateInput(retrieveAndGenerateConfiguration: \(Swift.String(describing: retrieveAndGenerateConfiguration)), sessionConfiguration: \(Swift.String(describing: sessionConfiguration)), sessionId: \(Swift.String(describing: sessionId)), input: \"CONTENT_REDACTED\")"}
}

public struct RetrieveAndGenerateStreamInput: Swift.Sendable {
    /// Contains the query to be made to the knowledge base.
    /// This member is required.
    public var input: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput?
    /// Contains configurations for the knowledge base query and retrieval process. For more information, see [Query configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
    public var retrieveAndGenerateConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration?
    /// Contains details about the session with the knowledge base.
    public var sessionConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration?
    /// The unique identifier of the session. When you first make a RetrieveAndGenerate request, Amazon Bedrock automatically generates this value. You must reuse this value for all subsequent requests in the same conversational session. This value allows Amazon Bedrock to maintain context and knowledge from previous interactions. You can't explicitly set the sessionId yourself.
    public var sessionId: Swift.String?

    public init(
        input: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput? = nil,
        retrieveAndGenerateConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration? = nil,
        sessionConfiguration: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration? = nil,
        sessionId: Swift.String? = nil
    ) {
        self.input = input
        self.retrieveAndGenerateConfiguration = retrieveAndGenerateConfiguration
        self.sessionConfiguration = sessionConfiguration
        self.sessionId = sessionId
    }
}

extension RetrieveAndGenerateStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetrieveAndGenerateStreamInput(retrieveAndGenerateConfiguration: \(Swift.String(describing: retrieveAndGenerateConfiguration)), sessionConfiguration: \(Swift.String(describing: sessionConfiguration)), sessionId: \(Swift.String(describing: sessionId)), input: \"CONTENT_REDACTED\")"}
}

public struct InvokeAgentInput: Swift.Sendable {
    /// The alias of the agent to use.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The unique identifier of the agent to use.
    /// This member is required.
    public var agentId: Swift.String?
    /// Model performance settings for the request.
    public var bedrockModelConfigurations: BedrockAgentRuntimeClientTypes.BedrockModelConfigurations?
    /// Specifies whether to turn on the trace or not to track the agent's reasoning process. For more information, see [Trace enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-events).
    public var enableTrace: Swift.Bool?
    /// Specifies whether to end the session with the agent or not.
    public var endSession: Swift.Bool?
    /// The prompt text to send the agent. If you include returnControlInvocationResults in the sessionState field, the inputText field will be ignored.
    public var inputText: Swift.String?
    /// The unique identifier of the agent memory.
    public var memoryId: Swift.String?
    /// The unique identifier of the session. Use the same value across requests to continue the same conversation.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Contains parameters that specify various attributes of the session. For more information, see [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html). If you include returnControlInvocationResults in the sessionState field, the inputText field will be ignored.
    public var sessionState: BedrockAgentRuntimeClientTypes.SessionState?
    /// The ARN of the resource making the request.
    public var sourceArn: Swift.String?
    /// Specifies the configurations for streaming. To use agent streaming, you need permissions to perform the bedrock:InvokeModelWithResponseStream action.
    public var streamingConfigurations: BedrockAgentRuntimeClientTypes.StreamingConfigurations?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        bedrockModelConfigurations: BedrockAgentRuntimeClientTypes.BedrockModelConfigurations? = nil,
        enableTrace: Swift.Bool? = nil,
        endSession: Swift.Bool? = nil,
        inputText: Swift.String? = nil,
        memoryId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionState: BedrockAgentRuntimeClientTypes.SessionState? = nil,
        sourceArn: Swift.String? = nil,
        streamingConfigurations: BedrockAgentRuntimeClientTypes.StreamingConfigurations? = nil
    ) {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
        self.bedrockModelConfigurations = bedrockModelConfigurations
        self.enableTrace = enableTrace
        self.endSession = endSession
        self.inputText = inputText
        self.memoryId = memoryId
        self.sessionId = sessionId
        self.sessionState = sessionState
        self.sourceArn = sourceArn
        self.streamingConfigurations = streamingConfigurations
    }
}

extension InvokeAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeAgentInput(agentAliasId: \(Swift.String(describing: agentAliasId)), agentId: \(Swift.String(describing: agentId)), bedrockModelConfigurations: \(Swift.String(describing: bedrockModelConfigurations)), enableTrace: \(Swift.String(describing: enableTrace)), endSession: \(Swift.String(describing: endSession)), memoryId: \(Swift.String(describing: memoryId)), sessionId: \(Swift.String(describing: sessionId)), sessionState: \(Swift.String(describing: sessionState)), sourceArn: \(Swift.String(describing: sourceArn)), streamingConfigurations: \(Swift.String(describing: streamingConfigurations)), inputText: \"CONTENT_REDACTED\")"}
}

public struct InvokeInlineAgentInput: Swift.Sendable {
    /// A list of action groups with each action group defining the action the inline agent needs to carry out.
    public var actionGroups: [BedrockAgentRuntimeClientTypes.AgentActionGroup]?
    /// Defines how the inline collaborator agent handles information across multiple collaborator agents to coordinate a final response. The inline collaborator agent can also be the supervisor.
    public var agentCollaboration: BedrockAgentRuntimeClientTypes.AgentCollaboration?
    /// Model settings for the request.
    public var bedrockModelConfigurations: BedrockAgentRuntimeClientTypes.InlineBedrockModelConfigurations?
    /// Settings for an inline agent collaborator called with [InvokeInlineAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeInlineAgent.html).
    public var collaboratorConfigurations: [BedrockAgentRuntimeClientTypes.CollaboratorConfiguration]?
    /// List of collaborator inline agents.
    public var collaborators: [BedrockAgentRuntimeClientTypes.Collaborator]?
    /// The Amazon Resource Name (ARN) of the Amazon Web Services KMS key to use to encrypt your inline agent.
    public var customerEncryptionKeyArn: Swift.String?
    /// Specifies whether to turn on the trace or not to track the agent's reasoning process. For more information, see [Using trace](https://docs.aws.amazon.com/bedrock/latest/userguide/trace-events.html).
    public var enableTrace: Swift.Bool?
    /// Specifies whether to end the session with the inline agent or not.
    public var endSession: Swift.Bool?
    /// The [model identifier (ID)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#model-ids-arns) of the model to use for orchestration by the inline agent. For example, meta.llama3-1-70b-instruct-v1:0.
    /// This member is required.
    public var foundationModel: Swift.String?
    /// The [guardrails](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails.html) to assign to the inline agent.
    public var guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfigurationWithArn?
    /// The number of seconds for which the inline agent should maintain session information. After this time expires, the subsequent InvokeInlineAgent request begins a new session. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and the data provided before the timeout is deleted.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// Parameters that specify the various attributes of a sessions. You can include attributes for the session or prompt or, if you configured an action group to return control, results from invocation of the action group. For more information, see [Control session context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html). If you include returnControlInvocationResults in the sessionState field, the inputText field will be ignored.
    public var inlineSessionState: BedrockAgentRuntimeClientTypes.InlineSessionState?
    /// The prompt text to send to the agent. If you include returnControlInvocationResults in the sessionState field, the inputText field will be ignored.
    public var inputText: Swift.String?
    /// The instructions that tell the inline agent what it should do and how it should interact with users.
    /// This member is required.
    public var instruction: Swift.String?
    /// Contains information of the knowledge bases to associate with.
    public var knowledgeBases: [BedrockAgentRuntimeClientTypes.KnowledgeBase]?
    /// Configurations for advanced prompts used to override the default prompts to enhance the accuracy of the inline agent.
    public var promptOverrideConfiguration: BedrockAgentRuntimeClientTypes.PromptOverrideConfiguration?
    /// The unique identifier of the session. Use the same value across requests to continue the same conversation.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Specifies the configurations for streaming. To use agent streaming, you need permissions to perform the bedrock:InvokeModelWithResponseStream action.
    public var streamingConfigurations: BedrockAgentRuntimeClientTypes.StreamingConfigurations?

    public init(
        actionGroups: [BedrockAgentRuntimeClientTypes.AgentActionGroup]? = nil,
        agentCollaboration: BedrockAgentRuntimeClientTypes.AgentCollaboration? = nil,
        bedrockModelConfigurations: BedrockAgentRuntimeClientTypes.InlineBedrockModelConfigurations? = nil,
        collaboratorConfigurations: [BedrockAgentRuntimeClientTypes.CollaboratorConfiguration]? = nil,
        collaborators: [BedrockAgentRuntimeClientTypes.Collaborator]? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        enableTrace: Swift.Bool? = nil,
        endSession: Swift.Bool? = nil,
        foundationModel: Swift.String? = nil,
        guardrailConfiguration: BedrockAgentRuntimeClientTypes.GuardrailConfigurationWithArn? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        inlineSessionState: BedrockAgentRuntimeClientTypes.InlineSessionState? = nil,
        inputText: Swift.String? = nil,
        instruction: Swift.String? = nil,
        knowledgeBases: [BedrockAgentRuntimeClientTypes.KnowledgeBase]? = nil,
        promptOverrideConfiguration: BedrockAgentRuntimeClientTypes.PromptOverrideConfiguration? = nil,
        sessionId: Swift.String? = nil,
        streamingConfigurations: BedrockAgentRuntimeClientTypes.StreamingConfigurations? = nil
    ) {
        self.actionGroups = actionGroups
        self.agentCollaboration = agentCollaboration
        self.bedrockModelConfigurations = bedrockModelConfigurations
        self.collaboratorConfigurations = collaboratorConfigurations
        self.collaborators = collaborators
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.enableTrace = enableTrace
        self.endSession = endSession
        self.foundationModel = foundationModel
        self.guardrailConfiguration = guardrailConfiguration
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.inlineSessionState = inlineSessionState
        self.inputText = inputText
        self.instruction = instruction
        self.knowledgeBases = knowledgeBases
        self.promptOverrideConfiguration = promptOverrideConfiguration
        self.sessionId = sessionId
        self.streamingConfigurations = streamingConfigurations
    }
}

extension InvokeInlineAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeInlineAgentInput(actionGroups: \(Swift.String(describing: actionGroups)), agentCollaboration: \(Swift.String(describing: agentCollaboration)), bedrockModelConfigurations: \(Swift.String(describing: bedrockModelConfigurations)), collaboratorConfigurations: \(Swift.String(describing: collaboratorConfigurations)), collaborators: \(Swift.String(describing: collaborators)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), enableTrace: \(Swift.String(describing: enableTrace)), endSession: \(Swift.String(describing: endSession)), foundationModel: \(Swift.String(describing: foundationModel)), guardrailConfiguration: \(Swift.String(describing: guardrailConfiguration)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), inlineSessionState: \(Swift.String(describing: inlineSessionState)), knowledgeBases: \(Swift.String(describing: knowledgeBases)), sessionId: \(Swift.String(describing: sessionId)), streamingConfigurations: \(Swift.String(describing: streamingConfigurations)), inputText: \"CONTENT_REDACTED\", instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension CreateInvocationInput {

    static func urlPathProvider(_ value: CreateInvocationInput) -> Swift.String? {
        guard let sessionIdentifier = value.sessionIdentifier else {
            return nil
        }
        return "/sessions/\(sessionIdentifier.urlPercentEncoding())/invocations"
    }
}

extension CreateSessionInput {

    static func urlPathProvider(_ value: CreateSessionInput) -> Swift.String? {
        return "/sessions"
    }
}

extension DeleteAgentMemoryInput {

    static func urlPathProvider(_ value: DeleteAgentMemoryInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentAliases/\(agentAliasId.urlPercentEncoding())/memories"
    }
}

extension DeleteAgentMemoryInput {

    static func queryItemProvider(_ value: DeleteAgentMemoryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let memoryId = value.memoryId {
            let memoryIdQueryItem = Smithy.URIQueryItem(name: "memoryId".urlPercentEncoding(), value: Swift.String(memoryId).urlPercentEncoding())
            items.append(memoryIdQueryItem)
        }
        if let sessionId = value.sessionId {
            let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
            items.append(sessionIdQueryItem)
        }
        return items
    }
}

extension DeleteSessionInput {

    static func urlPathProvider(_ value: DeleteSessionInput) -> Swift.String? {
        guard let sessionIdentifier = value.sessionIdentifier else {
            return nil
        }
        return "/sessions/\(sessionIdentifier.urlPercentEncoding())"
    }
}

extension EndSessionInput {

    static func urlPathProvider(_ value: EndSessionInput) -> Swift.String? {
        guard let sessionIdentifier = value.sessionIdentifier else {
            return nil
        }
        return "/sessions/\(sessionIdentifier.urlPercentEncoding())"
    }
}

extension GenerateQueryInput {

    static func urlPathProvider(_ value: GenerateQueryInput) -> Swift.String? {
        return "/generateQuery"
    }
}

extension GetAgentMemoryInput {

    static func urlPathProvider(_ value: GetAgentMemoryInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentAliases/\(agentAliasId.urlPercentEncoding())/memories"
    }
}

extension GetAgentMemoryInput {

    static func queryItemProvider(_ value: GetAgentMemoryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let memoryType = value.memoryType else {
            let message = "Creating a URL Query Item failed. memoryType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let memoryTypeQueryItem = Smithy.URIQueryItem(name: "memoryType".urlPercentEncoding(), value: Swift.String(memoryType.rawValue).urlPercentEncoding())
        items.append(memoryTypeQueryItem)
        guard let memoryId = value.memoryId else {
            let message = "Creating a URL Query Item failed. memoryId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let memoryIdQueryItem = Smithy.URIQueryItem(name: "memoryId".urlPercentEncoding(), value: Swift.String(memoryId).urlPercentEncoding())
        items.append(memoryIdQueryItem)
        return items
    }
}

extension GetInvocationStepInput {

    static func urlPathProvider(_ value: GetInvocationStepInput) -> Swift.String? {
        guard let sessionIdentifier = value.sessionIdentifier else {
            return nil
        }
        guard let invocationStepId = value.invocationStepId else {
            return nil
        }
        return "/sessions/\(sessionIdentifier.urlPercentEncoding())/invocationSteps/\(invocationStepId.urlPercentEncoding())"
    }
}

extension GetSessionInput {

    static func urlPathProvider(_ value: GetSessionInput) -> Swift.String? {
        guard let sessionIdentifier = value.sessionIdentifier else {
            return nil
        }
        return "/sessions/\(sessionIdentifier.urlPercentEncoding())"
    }
}

extension InvokeAgentInput {

    static func urlPathProvider(_ value: InvokeAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentAliases/\(agentAliasId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/text"
    }
}

extension InvokeAgentInput {

    static func headerProvider(_ value: InvokeAgentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let sourceArn = value.sourceArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-source-arn", value: Swift.String(sourceArn)))
        }
        return items
    }
}

extension InvokeFlowInput {

    static func urlPathProvider(_ value: InvokeFlowInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        guard let flowAliasIdentifier = value.flowAliasIdentifier else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())/aliases/\(flowAliasIdentifier.urlPercentEncoding())"
    }
}

extension InvokeInlineAgentInput {

    static func urlPathProvider(_ value: InvokeInlineAgentInput) -> Swift.String? {
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/agents/\(sessionId.urlPercentEncoding())"
    }
}

extension ListInvocationsInput {

    static func urlPathProvider(_ value: ListInvocationsInput) -> Swift.String? {
        guard let sessionIdentifier = value.sessionIdentifier else {
            return nil
        }
        return "/sessions/\(sessionIdentifier.urlPercentEncoding())/invocations"
    }
}

extension ListInvocationsInput {

    static func queryItemProvider(_ value: ListInvocationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListInvocationStepsInput {

    static func urlPathProvider(_ value: ListInvocationStepsInput) -> Swift.String? {
        guard let sessionIdentifier = value.sessionIdentifier else {
            return nil
        }
        return "/sessions/\(sessionIdentifier.urlPercentEncoding())/invocationSteps"
    }
}

extension ListInvocationStepsInput {

    static func queryItemProvider(_ value: ListInvocationStepsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSessionsInput {

    static func urlPathProvider(_ value: ListSessionsInput) -> Swift.String? {
        return "/sessions"
    }
}

extension ListSessionsInput {

    static func queryItemProvider(_ value: ListSessionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension OptimizePromptInput {

    static func urlPathProvider(_ value: OptimizePromptInput) -> Swift.String? {
        return "/optimize-prompt"
    }
}

extension PutInvocationStepInput {

    static func urlPathProvider(_ value: PutInvocationStepInput) -> Swift.String? {
        guard let sessionIdentifier = value.sessionIdentifier else {
            return nil
        }
        return "/sessions/\(sessionIdentifier.urlPercentEncoding())/invocationSteps"
    }
}

extension RerankInput {

    static func urlPathProvider(_ value: RerankInput) -> Swift.String? {
        return "/rerank"
    }
}

extension RetrieveInput {

    static func urlPathProvider(_ value: RetrieveInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/retrieve"
    }
}

extension RetrieveAndGenerateInput {

    static func urlPathProvider(_ value: RetrieveAndGenerateInput) -> Swift.String? {
        return "/retrieveAndGenerate"
    }
}

extension RetrieveAndGenerateStreamInput {

    static func urlPathProvider(_ value: RetrieveAndGenerateStreamInput) -> Swift.String? {
        return "/retrieveAndGenerateStream"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateSessionInput {

    static func urlPathProvider(_ value: UpdateSessionInput) -> Swift.String? {
        guard let sessionIdentifier = value.sessionIdentifier else {
            return nil
        }
        return "/sessions/\(sessionIdentifier.urlPercentEncoding())"
    }
}

extension CreateInvocationInput {

    static func write(value: CreateInvocationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["invocationId"].write(value.invocationId)
    }
}

extension CreateSessionInput {

    static func write(value: CreateSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionKeyArn"].write(value.encryptionKeyArn)
        try writer["sessionMetadata"].writeMap(value.sessionMetadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension GenerateQueryInput {

    static func write(value: GenerateQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["queryGenerationInput"].write(value.queryGenerationInput, with: BedrockAgentRuntimeClientTypes.QueryGenerationInput.write(value:to:))
        try writer["transformationConfiguration"].write(value.transformationConfiguration, with: BedrockAgentRuntimeClientTypes.TransformationConfiguration.write(value:to:))
    }
}

extension GetInvocationStepInput {

    static func write(value: GetInvocationStepInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invocationIdentifier"].write(value.invocationIdentifier)
    }
}

extension InvokeAgentInput {

    static func write(value: InvokeAgentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bedrockModelConfigurations"].write(value.bedrockModelConfigurations, with: BedrockAgentRuntimeClientTypes.BedrockModelConfigurations.write(value:to:))
        try writer["enableTrace"].write(value.enableTrace)
        try writer["endSession"].write(value.endSession)
        try writer["inputText"].write(value.inputText)
        try writer["memoryId"].write(value.memoryId)
        try writer["sessionState"].write(value.sessionState, with: BedrockAgentRuntimeClientTypes.SessionState.write(value:to:))
        try writer["streamingConfigurations"].write(value.streamingConfigurations, with: BedrockAgentRuntimeClientTypes.StreamingConfigurations.write(value:to:))
    }
}

extension InvokeFlowInput {

    static func write(value: InvokeFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enableTrace"].write(value.enableTrace)
        try writer["executionId"].write(value.executionId)
        try writer["inputs"].writeList(value.inputs, memberWritingClosure: BedrockAgentRuntimeClientTypes.FlowInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["modelPerformanceConfiguration"].write(value.modelPerformanceConfiguration, with: BedrockAgentRuntimeClientTypes.ModelPerformanceConfiguration.write(value:to:))
    }
}

extension InvokeInlineAgentInput {

    static func write(value: InvokeInlineAgentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionGroups"].writeList(value.actionGroups, memberWritingClosure: BedrockAgentRuntimeClientTypes.AgentActionGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["agentCollaboration"].write(value.agentCollaboration)
        try writer["bedrockModelConfigurations"].write(value.bedrockModelConfigurations, with: BedrockAgentRuntimeClientTypes.InlineBedrockModelConfigurations.write(value:to:))
        try writer["collaboratorConfigurations"].writeList(value.collaboratorConfigurations, memberWritingClosure: BedrockAgentRuntimeClientTypes.CollaboratorConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["collaborators"].writeList(value.collaborators, memberWritingClosure: BedrockAgentRuntimeClientTypes.Collaborator.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["customerEncryptionKeyArn"].write(value.customerEncryptionKeyArn)
        try writer["enableTrace"].write(value.enableTrace)
        try writer["endSession"].write(value.endSession)
        try writer["foundationModel"].write(value.foundationModel)
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockAgentRuntimeClientTypes.GuardrailConfigurationWithArn.write(value:to:))
        try writer["idleSessionTTLInSeconds"].write(value.idleSessionTTLInSeconds)
        try writer["inlineSessionState"].write(value.inlineSessionState, with: BedrockAgentRuntimeClientTypes.InlineSessionState.write(value:to:))
        try writer["inputText"].write(value.inputText)
        try writer["instruction"].write(value.instruction)
        try writer["knowledgeBases"].writeList(value.knowledgeBases, memberWritingClosure: BedrockAgentRuntimeClientTypes.KnowledgeBase.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["promptOverrideConfiguration"].write(value.promptOverrideConfiguration, with: BedrockAgentRuntimeClientTypes.PromptOverrideConfiguration.write(value:to:))
        try writer["streamingConfigurations"].write(value.streamingConfigurations, with: BedrockAgentRuntimeClientTypes.StreamingConfigurations.write(value:to:))
    }
}

extension ListInvocationStepsInput {

    static func write(value: ListInvocationStepsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invocationIdentifier"].write(value.invocationIdentifier)
    }
}

extension OptimizePromptInput {

    static func write(value: OptimizePromptInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["input"].write(value.input, with: BedrockAgentRuntimeClientTypes.InputPrompt.write(value:to:))
        try writer["targetModelId"].write(value.targetModelId)
    }
}

extension PutInvocationStepInput {

    static func write(value: PutInvocationStepInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invocationIdentifier"].write(value.invocationIdentifier)
        try writer["invocationStepId"].write(value.invocationStepId)
        try writer["invocationStepTime"].writeTimestamp(value.invocationStepTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["payload"].write(value.payload, with: BedrockAgentRuntimeClientTypes.InvocationStepPayload.write(value:to:))
    }
}

extension RerankInput {

    static func write(value: RerankInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nextToken"].write(value.nextToken)
        try writer["queries"].writeList(value.queries, memberWritingClosure: BedrockAgentRuntimeClientTypes.RerankQuery.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["rerankingConfiguration"].write(value.rerankingConfiguration, with: BedrockAgentRuntimeClientTypes.RerankingConfiguration.write(value:to:))
        try writer["sources"].writeList(value.sources, memberWritingClosure: BedrockAgentRuntimeClientTypes.RerankSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RetrieveInput {

    static func write(value: RetrieveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockAgentRuntimeClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["nextToken"].write(value.nextToken)
        try writer["retrievalConfiguration"].write(value.retrievalConfiguration, with: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration.write(value:to:))
        try writer["retrievalQuery"].write(value.retrievalQuery, with: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery.write(value:to:))
    }
}

extension RetrieveAndGenerateInput {

    static func write(value: RetrieveAndGenerateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["input"].write(value.input, with: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput.write(value:to:))
        try writer["retrieveAndGenerateConfiguration"].write(value.retrieveAndGenerateConfiguration, with: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration.write(value:to:))
        try writer["sessionConfiguration"].write(value.sessionConfiguration, with: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration.write(value:to:))
        try writer["sessionId"].write(value.sessionId)
    }
}

extension RetrieveAndGenerateStreamInput {

    static func write(value: RetrieveAndGenerateStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["input"].write(value.input, with: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput.write(value:to:))
        try writer["retrieveAndGenerateConfiguration"].write(value.retrieveAndGenerateConfiguration, with: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration.write(value:to:))
        try writer["sessionConfiguration"].write(value.sessionConfiguration, with: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration.write(value:to:))
        try writer["sessionId"].write(value.sessionId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateSessionInput {

    static func write(value: UpdateSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sessionMetadata"].writeMap(value.sessionMetadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateInvocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInvocationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInvocationOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.invocationId = try reader["invocationId"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSessionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionStatus = try reader["sessionStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteAgentMemoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAgentMemoryOutput {
        return DeleteAgentMemoryOutput()
    }
}

extension DeleteSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSessionOutput {
        return DeleteSessionOutput()
    }
}

extension EndSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EndSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EndSessionOutput()
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionStatus = try reader["sessionStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GenerateQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GenerateQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GenerateQueryOutput()
        value.queries = try reader["queries"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GeneratedQuery.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAgentMemoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAgentMemoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentMemoryOutput()
        value.memoryContents = try reader["memoryContents"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.Memory.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetInvocationStepOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInvocationStepOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInvocationStepOutput()
        value.invocationStep = try reader["invocationStep"].readIfPresent(with: BedrockAgentRuntimeClientTypes.InvocationStep.read(from:))
        return value
    }
}

extension GetSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSessionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.encryptionKeyArn = try reader["encryptionKeyArn"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionMetadata = try reader["sessionMetadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.sessionStatus = try reader["sessionStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension InvokeAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeAgentOutput {
        var value = InvokeAgentOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-bedrock-agent-content-type") {
            value.contentType = contentTypeHeaderValue
        }
        if let memoryIdHeaderValue = httpResponse.headers.value(for: "x-amz-bedrock-agent-memory-id") {
            value.memoryId = memoryIdHeaderValue
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-bedrock-agent-session-id") {
            value.sessionId = sessionIdHeaderValue
        }
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: BedrockAgentRuntimeClientTypes.ResponseStream.unmarshal)
            value.completion = decoderStream.toAsyncStream()
        }
        return value
    }
}

extension InvokeFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeFlowOutput {
        var value = InvokeFlowOutput()
        if let executionIdHeaderValue = httpResponse.headers.value(for: "x-amz-bedrock-flow-execution-id") {
            value.executionId = executionIdHeaderValue
        }
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: BedrockAgentRuntimeClientTypes.FlowResponseStream.unmarshal)
            value.responseStream = decoderStream.toAsyncStream()
        }
        return value
    }
}

extension InvokeInlineAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeInlineAgentOutput {
        var value = InvokeInlineAgentOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-bedrock-agent-content-type") {
            value.contentType = contentTypeHeaderValue
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-bedrock-agent-session-id") {
            value.sessionId = sessionIdHeaderValue
        }
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: BedrockAgentRuntimeClientTypes.InlineAgentResponseStream.unmarshal)
            value.completion = decoderStream.toAsyncStream()
        }
        return value
    }
}

extension ListInvocationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInvocationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInvocationsOutput()
        value.invocationSummaries = try reader["invocationSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.InvocationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListInvocationStepsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInvocationStepsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInvocationStepsOutput()
        value.invocationStepSummaries = try reader["invocationStepSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.InvocationStepSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sessionSummaries = try reader["sessionSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.SessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension OptimizePromptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> OptimizePromptOutput {
        var value = OptimizePromptOutput()
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: BedrockAgentRuntimeClientTypes.OptimizedPromptStream.unmarshal)
            value.optimizedPrompt = decoderStream.toAsyncStream()
        }
        return value
    }
}

extension PutInvocationStepOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutInvocationStepOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutInvocationStepOutput()
        value.invocationStepId = try reader["invocationStepId"].readIfPresent() ?? ""
        return value
    }
}

extension RerankOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RerankOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RerankOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.results = try reader["results"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.RerankResult.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension RetrieveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RetrieveOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RetrieveOutput()
        value.guardrailAction = try reader["guardrailAction"].readIfPresent()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.retrievalResults = try reader["retrievalResults"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension RetrieveAndGenerateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RetrieveAndGenerateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RetrieveAndGenerateOutput()
        value.citations = try reader["citations"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.Citation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.guardrailAction = try reader["guardrailAction"].readIfPresent()
        value.output = try reader["output"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput.read(from:))
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        return value
    }
}

extension RetrieveAndGenerateStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RetrieveAndGenerateStreamOutput {
        var value = RetrieveAndGenerateStreamOutput()
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amzn-bedrock-knowledge-base-session-id") {
            value.sessionId = sessionIdHeaderValue
        }
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateStreamResponseOutput.unmarshal)
            value.stream = decoderStream.toAsyncStream()
        }
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSessionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionStatus = try reader["sessionStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

enum CreateInvocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAgentMemoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EndSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GenerateQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAgentMemoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInvocationStepOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ModelNotReadyException": return try ModelNotReadyException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeInlineAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInvocationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInvocationStepsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum OptimizePromptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutInvocationStepOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RerankOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RetrieveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RetrieveAndGenerateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RetrieveAndGenerateStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DependencyFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DependencyFailedException {
        let reader = baseError.errorBodyReader
        var value = DependencyFailedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadGatewayException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadGatewayException {
        let reader = baseError.errorBodyReader
        var value = BadGatewayException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ModelNotReadyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelNotReadyException {
        let reader = baseError.errorBodyReader
        var value = ModelNotReadyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ResponseStream {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<BedrockAgentRuntimeClientTypes.ResponseStream> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "chunk":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.PayloadPart.read(from:))
                    return .chunk(value)
                case "trace":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.TracePart.read(from:))
                    return .trace(value)
                case "returnControl":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.ReturnControlPayload.read(from:))
                    return .returncontrol(value)
                case "files":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.FilePart.read(from:))
                    return .files(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "internalServerException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalServerException.read(from:))
                        return value
                    case "validationException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ValidationException.read(from:))
                        return value
                    case "resourceNotFoundException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ResourceNotFoundException.read(from:))
                        return value
                    case "serviceQuotaExceededException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ServiceQuotaExceededException.read(from:))
                        return value
                    case "throttlingException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ThrottlingException.read(from:))
                        return value
                    case "accessDeniedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: AccessDeniedException.read(from:))
                        return value
                    case "conflictException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ConflictException.read(from:))
                        return value
                    case "dependencyFailedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: DependencyFailedException.read(from:))
                        return value
                    case "badGatewayException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: BadGatewayException.read(from:))
                        return value
                    case "modelNotReadyException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ModelNotReadyException.read(from:))
                        return value
                    default:
                        let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowResponseStream {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<BedrockAgentRuntimeClientTypes.FlowResponseStream> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "flowOutputEvent":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.FlowOutputEvent.read(from:))
                    return .flowoutputevent(value)
                case "flowCompletionEvent":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.FlowCompletionEvent.read(from:))
                    return .flowcompletionevent(value)
                case "flowTraceEvent":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.FlowTraceEvent.read(from:))
                    return .flowtraceevent(value)
                case "flowMultiTurnInputRequestEvent":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.FlowMultiTurnInputRequestEvent.read(from:))
                    return .flowmultiturninputrequestevent(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "internalServerException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalServerException.read(from:))
                        return value
                    case "validationException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ValidationException.read(from:))
                        return value
                    case "resourceNotFoundException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ResourceNotFoundException.read(from:))
                        return value
                    case "serviceQuotaExceededException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ServiceQuotaExceededException.read(from:))
                        return value
                    case "throttlingException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ThrottlingException.read(from:))
                        return value
                    case "accessDeniedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: AccessDeniedException.read(from:))
                        return value
                    case "conflictException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ConflictException.read(from:))
                        return value
                    case "dependencyFailedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: DependencyFailedException.read(from:))
                        return value
                    case "badGatewayException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: BadGatewayException.read(from:))
                        return value
                    default:
                        let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.InlineAgentResponseStream {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<BedrockAgentRuntimeClientTypes.InlineAgentResponseStream> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "chunk":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.InlineAgentPayloadPart.read(from:))
                    return .chunk(value)
                case "trace":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.InlineAgentTracePart.read(from:))
                    return .trace(value)
                case "returnControl":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.InlineAgentReturnControlPayload.read(from:))
                    return .returncontrol(value)
                case "files":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.InlineAgentFilePart.read(from:))
                    return .files(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "internalServerException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalServerException.read(from:))
                        return value
                    case "validationException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ValidationException.read(from:))
                        return value
                    case "resourceNotFoundException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ResourceNotFoundException.read(from:))
                        return value
                    case "serviceQuotaExceededException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ServiceQuotaExceededException.read(from:))
                        return value
                    case "throttlingException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ThrottlingException.read(from:))
                        return value
                    case "accessDeniedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: AccessDeniedException.read(from:))
                        return value
                    case "conflictException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ConflictException.read(from:))
                        return value
                    case "dependencyFailedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: DependencyFailedException.read(from:))
                        return value
                    case "badGatewayException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: BadGatewayException.read(from:))
                        return value
                    default:
                        let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.OptimizedPromptStream {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<BedrockAgentRuntimeClientTypes.OptimizedPromptStream> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "optimizedPromptEvent":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.OptimizedPromptEvent.read(from:))
                    return .optimizedpromptevent(value)
                case "analyzePromptEvent":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.AnalyzePromptEvent.read(from:))
                    return .analyzepromptevent(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "internalServerException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalServerException.read(from:))
                        return value
                    case "throttlingException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ThrottlingException.read(from:))
                        return value
                    case "validationException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ValidationException.read(from:))
                        return value
                    case "dependencyFailedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: DependencyFailedException.read(from:))
                        return value
                    case "accessDeniedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: AccessDeniedException.read(from:))
                        return value
                    case "badGatewayException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: BadGatewayException.read(from:))
                        return value
                    default:
                        let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateStreamResponseOutput {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<BedrockAgentRuntimeClientTypes.RetrieveAndGenerateStreamResponseOutput> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "output":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutputEvent.read(from:))
                    return .output(value)
                case "citation":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.CitationEvent.read(from:))
                    return .citation(value)
                case "guardrail":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockAgentRuntimeClientTypes.GuardrailEvent.read(from:))
                    return .guardrail(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "internalServerException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalServerException.read(from:))
                        return value
                    case "validationException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ValidationException.read(from:))
                        return value
                    case "resourceNotFoundException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ResourceNotFoundException.read(from:))
                        return value
                    case "serviceQuotaExceededException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ServiceQuotaExceededException.read(from:))
                        return value
                    case "throttlingException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ThrottlingException.read(from:))
                        return value
                    case "accessDeniedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: AccessDeniedException.read(from:))
                        return value
                    case "conflictException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ConflictException.read(from:))
                        return value
                    case "dependencyFailedException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: DependencyFailedException.read(from:))
                        return value
                    case "badGatewayException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: BadGatewayException.read(from:))
                        return value
                    default:
                        let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension BedrockAgentRuntimeClientTypes.GeneratedQuery {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GeneratedQuery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GeneratedQuery()
        value.type = try reader["type"].readIfPresent()
        value.sql = try reader["sql"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.Memory {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Memory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "sessionSummary":
                return .sessionsummary(try reader["sessionSummary"].read(with: BedrockAgentRuntimeClientTypes.MemorySessionSummary.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.MemorySessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.MemorySessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.MemorySessionSummary()
        value.memoryId = try reader["memoryId"].readIfPresent()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.sessionStartTime = try reader["sessionStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.sessionExpiryTime = try reader["sessionExpiryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.summaryText = try reader["summaryText"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationStep {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InvocationStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.InvocationStep()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.invocationId = try reader["invocationId"].readIfPresent() ?? ""
        value.invocationStepId = try reader["invocationStepId"].readIfPresent() ?? ""
        value.invocationStepTime = try reader["invocationStepTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.payload = try reader["payload"].readIfPresent(with: BedrockAgentRuntimeClientTypes.InvocationStepPayload.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationStepPayload {

    static func write(value: BedrockAgentRuntimeClientTypes.InvocationStepPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .contentblocks(contentblocks):
                try writer["contentBlocks"].writeList(contentblocks, memberWritingClosure: BedrockAgentRuntimeClientTypes.BedrockSessionContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InvocationStepPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "contentBlocks":
                return .contentblocks(try reader["contentBlocks"].readList(memberReadingClosure: BedrockAgentRuntimeClientTypes.BedrockSessionContentBlock.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.BedrockSessionContentBlock {

    static func write(value: BedrockAgentRuntimeClientTypes.BedrockSessionContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .image(image):
                try writer["image"].write(image, with: BedrockAgentRuntimeClientTypes.ImageBlock.write(value:to:))
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.BedrockSessionContentBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read())
            case "image":
                return .image(try reader["image"].read(with: BedrockAgentRuntimeClientTypes.ImageBlock.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ImageBlock {

    static func write(value: BedrockAgentRuntimeClientTypes.ImageBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["format"].write(value.format)
        try writer["source"].write(value.source, with: BedrockAgentRuntimeClientTypes.ImageSource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ImageBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ImageBlock()
        value.format = try reader["format"].readIfPresent() ?? .sdkUnknown("")
        value.source = try reader["source"].readIfPresent(with: BedrockAgentRuntimeClientTypes.ImageSource.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ImageSource {

    static func write(value: BedrockAgentRuntimeClientTypes.ImageSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .bytes(bytes):
                try writer["bytes"].write(bytes)
            case let .s3location(s3location):
                try writer["s3Location"].write(s3location, with: BedrockAgentRuntimeClientTypes.S3Location.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ImageSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "bytes":
                return .bytes(try reader["bytes"].read())
            case "s3Location":
                return .s3location(try reader["s3Location"].read(with: BedrockAgentRuntimeClientTypes.S3Location.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.S3Location {

    static func write(value: BedrockAgentRuntimeClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.S3Location()
        value.uri = try reader["uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FilePart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FilePart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FilePart()
        value.files = try reader["files"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.OutputFile.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.OutputFile {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.OutputFile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.OutputFile()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.bytes = try reader["bytes"].readIfPresent()
        return value
    }
}

extension ModelNotReadyException {

    static func read(from reader: SmithyJSON.Reader) throws -> ModelNotReadyException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ModelNotReadyException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BadGatewayException {

    static func read(from reader: SmithyJSON.Reader) throws -> BadGatewayException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BadGatewayException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        return value
    }
}

extension DependencyFailedException {

    static func read(from reader: SmithyJSON.Reader) throws -> DependencyFailedException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DependencyFailedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        return value
    }
}

extension ConflictException {

    static func read(from reader: SmithyJSON.Reader) throws -> ConflictException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension AccessDeniedException {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessDeniedException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ThrottlingException {

    static func read(from reader: SmithyJSON.Reader) throws -> ThrottlingException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ServiceQuotaExceededException {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceQuotaExceededException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ResourceNotFoundException {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceNotFoundException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ValidationException {

    static func read(from reader: SmithyJSON.Reader) throws -> ValidationException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension InternalServerException {

    static func read(from reader: SmithyJSON.Reader) throws -> InternalServerException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ReturnControlPayload {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ReturnControlPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ReturnControlPayload()
        value.invocationInputs = try reader["invocationInputs"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.InvocationInputMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.invocationId = try reader["invocationId"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationInputMember {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InvocationInputMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "apiInvocationInput":
                return .apiinvocationinput(try reader["apiInvocationInput"].read(with: BedrockAgentRuntimeClientTypes.ApiInvocationInput.read(from:)))
            case "functionInvocationInput":
                return .functioninvocationinput(try reader["functionInvocationInput"].read(with: BedrockAgentRuntimeClientTypes.FunctionInvocationInput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FunctionInvocationInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FunctionInvocationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FunctionInvocationInput()
        value.actionGroup = try reader["actionGroup"].readIfPresent() ?? ""
        value.parameters = try reader["parameters"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.FunctionParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.function = try reader["function"].readIfPresent()
        value.actionInvocationType = try reader["actionInvocationType"].readIfPresent()
        value.agentId = try reader["agentId"].readIfPresent()
        value.collaboratorName = try reader["collaboratorName"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FunctionParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FunctionParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FunctionParameter()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ApiInvocationInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ApiInvocationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ApiInvocationInput()
        value.actionGroup = try reader["actionGroup"].readIfPresent() ?? ""
        value.httpMethod = try reader["httpMethod"].readIfPresent()
        value.apiPath = try reader["apiPath"].readIfPresent()
        value.parameters = try reader["parameters"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.ApiParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestBody = try reader["requestBody"].readIfPresent(with: BedrockAgentRuntimeClientTypes.ApiRequestBody.read(from:))
        value.actionInvocationType = try reader["actionInvocationType"].readIfPresent()
        value.agentId = try reader["agentId"].readIfPresent()
        value.collaboratorName = try reader["collaboratorName"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ApiRequestBody {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ApiRequestBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ApiRequestBody()
        value.content = try reader["content"].readMapIfPresent(valueReadingClosure: BedrockAgentRuntimeClientTypes.PropertyParameters.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.PropertyParameters {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PropertyParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.PropertyParameters()
        value.properties = try reader["properties"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.Parameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.Parameter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Parameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Parameter()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ApiParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ApiParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ApiParameter()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.TracePart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.TracePart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.TracePart()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.trace = try reader["trace"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Trace.read(from:))
        value.agentId = try reader["agentId"].readIfPresent()
        value.agentAliasId = try reader["agentAliasId"].readIfPresent()
        value.agentVersion = try reader["agentVersion"].readIfPresent()
        value.callerChain = try reader["callerChain"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.Caller.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.eventTime = try reader["eventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.collaboratorName = try reader["collaboratorName"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.Caller {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Caller {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "agentAliasArn":
                return .agentaliasarn(try reader["agentAliasArn"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.Trace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Trace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "guardrailTrace":
                return .guardrailtrace(try reader["guardrailTrace"].read(with: BedrockAgentRuntimeClientTypes.GuardrailTrace.read(from:)))
            case "preProcessingTrace":
                return .preprocessingtrace(try reader["preProcessingTrace"].read(with: BedrockAgentRuntimeClientTypes.PreProcessingTrace.read(from:)))
            case "orchestrationTrace":
                return .orchestrationtrace(try reader["orchestrationTrace"].read(with: BedrockAgentRuntimeClientTypes.OrchestrationTrace.read(from:)))
            case "postProcessingTrace":
                return .postprocessingtrace(try reader["postProcessingTrace"].read(with: BedrockAgentRuntimeClientTypes.PostProcessingTrace.read(from:)))
            case "routingClassifierTrace":
                return .routingclassifiertrace(try reader["routingClassifierTrace"].read(with: BedrockAgentRuntimeClientTypes.RoutingClassifierTrace.read(from:)))
            case "failureTrace":
                return .failuretrace(try reader["failureTrace"].read(with: BedrockAgentRuntimeClientTypes.FailureTrace.read(from:)))
            case "customOrchestrationTrace":
                return .customorchestrationtrace(try reader["customOrchestrationTrace"].read(with: BedrockAgentRuntimeClientTypes.CustomOrchestrationTrace.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.CustomOrchestrationTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.CustomOrchestrationTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.CustomOrchestrationTrace()
        value.traceId = try reader["traceId"].readIfPresent()
        value.event = try reader["event"].readIfPresent(with: BedrockAgentRuntimeClientTypes.CustomOrchestrationTraceEvent.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.CustomOrchestrationTraceEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.CustomOrchestrationTraceEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.CustomOrchestrationTraceEvent()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FailureTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FailureTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FailureTrace()
        value.traceId = try reader["traceId"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RoutingClassifierTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RoutingClassifierTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "invocationInput":
                return .invocationinput(try reader["invocationInput"].read(with: BedrockAgentRuntimeClientTypes.InvocationInput.read(from:)))
            case "observation":
                return .observation(try reader["observation"].read(with: BedrockAgentRuntimeClientTypes.Observation.read(from:)))
            case "modelInvocationInput":
                return .modelinvocationinput(try reader["modelInvocationInput"].read(with: BedrockAgentRuntimeClientTypes.ModelInvocationInput.read(from:)))
            case "modelInvocationOutput":
                return .modelinvocationoutput(try reader["modelInvocationOutput"].read(with: BedrockAgentRuntimeClientTypes.RoutingClassifierModelInvocationOutput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RoutingClassifierModelInvocationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RoutingClassifierModelInvocationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RoutingClassifierModelInvocationOutput()
        value.traceId = try reader["traceId"].readIfPresent()
        value.rawResponse = try reader["rawResponse"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RawResponse.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Metadata.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.Metadata {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Metadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Metadata()
        value.usage = try reader["usage"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Usage.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.Usage {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Usage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Usage()
        value.inputTokens = try reader["inputTokens"].readIfPresent()
        value.outputTokens = try reader["outputTokens"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RawResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RawResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RawResponse()
        value.content = try reader["content"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ModelInvocationInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ModelInvocationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ModelInvocationInput()
        value.traceId = try reader["traceId"].readIfPresent()
        value.text = try reader["text"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.overrideLambda = try reader["overrideLambda"].readIfPresent()
        value.promptCreationMode = try reader["promptCreationMode"].readIfPresent()
        value.inferenceConfiguration = try reader["inferenceConfiguration"].readIfPresent(with: BedrockAgentRuntimeClientTypes.InferenceConfiguration.read(from:))
        value.parserMode = try reader["parserMode"].readIfPresent()
        value.foundationModel = try reader["foundationModel"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.InferenceConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.InferenceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maximumLength"].write(value.maximumLength)
        try writer["stopSequences"].writeList(value.stopSequences, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["temperature"].write(value.temperature)
        try writer["topK"].write(value.topk)
        try writer["topP"].write(value.topp)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InferenceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.InferenceConfiguration()
        value.temperature = try reader["temperature"].readIfPresent()
        value.topp = try reader["topP"].readIfPresent()
        value.topk = try reader["topK"].readIfPresent()
        value.maximumLength = try reader["maximumLength"].readIfPresent()
        value.stopSequences = try reader["stopSequences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.Observation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Observation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Observation()
        value.traceId = try reader["traceId"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.actionGroupInvocationOutput = try reader["actionGroupInvocationOutput"].readIfPresent(with: BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput.read(from:))
        value.agentCollaboratorInvocationOutput = try reader["agentCollaboratorInvocationOutput"].readIfPresent(with: BedrockAgentRuntimeClientTypes.AgentCollaboratorInvocationOutput.read(from:))
        value.knowledgeBaseLookupOutput = try reader["knowledgeBaseLookupOutput"].readIfPresent(with: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput.read(from:))
        value.finalResponse = try reader["finalResponse"].readIfPresent(with: BedrockAgentRuntimeClientTypes.FinalResponse.read(from:))
        value.repromptResponse = try reader["repromptResponse"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RepromptResponse.read(from:))
        value.codeInterpreterInvocationOutput = try reader["codeInterpreterInvocationOutput"].readIfPresent(with: BedrockAgentRuntimeClientTypes.CodeInterpreterInvocationOutput.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.CodeInterpreterInvocationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.CodeInterpreterInvocationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.CodeInterpreterInvocationOutput()
        value.executionOutput = try reader["executionOutput"].readIfPresent()
        value.executionError = try reader["executionError"].readIfPresent()
        value.files = try reader["files"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.executionTimeout = try reader["executionTimeout"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RepromptResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RepromptResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RepromptResponse()
        value.text = try reader["text"].readIfPresent()
        value.source = try reader["source"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FinalResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FinalResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FinalResponse()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupOutput()
        value.retrievedReferences = try reader["retrievedReferences"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.RetrievedReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievedReference {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievedReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievedReference()
        value.content = try reader["content"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultContent.read(from:))
        value.location = try reader["location"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultLocation.read(from:))
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDocument(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultLocation()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.s3Location = try reader["s3Location"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultS3Location.read(from:))
        value.webLocation = try reader["webLocation"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultWebLocation.read(from:))
        value.confluenceLocation = try reader["confluenceLocation"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultConfluenceLocation.read(from:))
        value.salesforceLocation = try reader["salesforceLocation"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultSalesforceLocation.read(from:))
        value.sharePointLocation = try reader["sharePointLocation"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultSharePointLocation.read(from:))
        value.customDocumentLocation = try reader["customDocumentLocation"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultCustomDocumentLocation.read(from:))
        value.kendraDocumentLocation = try reader["kendraDocumentLocation"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultKendraDocumentLocation.read(from:))
        value.sqlLocation = try reader["sqlLocation"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultSqlLocation.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultSqlLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultSqlLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultSqlLocation()
        value.query = try reader["query"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultKendraDocumentLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultKendraDocumentLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultKendraDocumentLocation()
        value.uri = try reader["uri"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultCustomDocumentLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultCustomDocumentLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultCustomDocumentLocation()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultSharePointLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultSharePointLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultSharePointLocation()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultSalesforceLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultSalesforceLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultSalesforceLocation()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultConfluenceLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultConfluenceLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultConfluenceLocation()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultWebLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultWebLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultWebLocation()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultS3Location {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultS3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultS3Location()
        value.uri = try reader["uri"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultContent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultContent()
        value.type = try reader["type"].readIfPresent()
        value.text = try reader["text"].readIfPresent() ?? ""
        value.byteContent = try reader["byteContent"].readIfPresent()
        value.row = try reader["row"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.RetrievalResultContentColumn.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalResultContentColumn {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrievalResultContentColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrievalResultContentColumn()
        value.columnName = try reader["columnName"].readIfPresent()
        value.columnValue = try reader["columnValue"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.AgentCollaboratorInvocationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.AgentCollaboratorInvocationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.AgentCollaboratorInvocationOutput()
        value.agentCollaboratorName = try reader["agentCollaboratorName"].readIfPresent()
        value.agentCollaboratorAliasArn = try reader["agentCollaboratorAliasArn"].readIfPresent()
        value.output = try reader["output"].readIfPresent(with: BedrockAgentRuntimeClientTypes.AgentCollaboratorOutputPayload.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.AgentCollaboratorOutputPayload {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.AgentCollaboratorOutputPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.AgentCollaboratorOutputPayload()
        value.type = try reader["type"].readIfPresent()
        value.text = try reader["text"].readIfPresent()
        value.returnControlPayload = try reader["returnControlPayload"].readIfPresent(with: BedrockAgentRuntimeClientTypes.ReturnControlPayload.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ActionGroupInvocationOutput()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InvocationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.InvocationInput()
        value.traceId = try reader["traceId"].readIfPresent()
        value.invocationType = try reader["invocationType"].readIfPresent()
        value.actionGroupInvocationInput = try reader["actionGroupInvocationInput"].readIfPresent(with: BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput.read(from:))
        value.knowledgeBaseLookupInput = try reader["knowledgeBaseLookupInput"].readIfPresent(with: BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput.read(from:))
        value.codeInterpreterInvocationInput = try reader["codeInterpreterInvocationInput"].readIfPresent(with: BedrockAgentRuntimeClientTypes.CodeInterpreterInvocationInput.read(from:))
        value.agentCollaboratorInvocationInput = try reader["agentCollaboratorInvocationInput"].readIfPresent(with: BedrockAgentRuntimeClientTypes.AgentCollaboratorInvocationInput.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.AgentCollaboratorInvocationInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.AgentCollaboratorInvocationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.AgentCollaboratorInvocationInput()
        value.agentCollaboratorName = try reader["agentCollaboratorName"].readIfPresent()
        value.agentCollaboratorAliasArn = try reader["agentCollaboratorAliasArn"].readIfPresent()
        value.input = try reader["input"].readIfPresent(with: BedrockAgentRuntimeClientTypes.AgentCollaboratorInputPayload.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.AgentCollaboratorInputPayload {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.AgentCollaboratorInputPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.AgentCollaboratorInputPayload()
        value.type = try reader["type"].readIfPresent()
        value.text = try reader["text"].readIfPresent()
        value.returnControlResults = try reader["returnControlResults"].readIfPresent(with: BedrockAgentRuntimeClientTypes.ReturnControlResults.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ReturnControlResults {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ReturnControlResults {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ReturnControlResults()
        value.invocationId = try reader["invocationId"].readIfPresent()
        value.returnControlInvocationResults = try reader["returnControlInvocationResults"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.InvocationResultMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationResultMember {

    static func write(value: BedrockAgentRuntimeClientTypes.InvocationResultMember?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .apiresult(apiresult):
                try writer["apiResult"].write(apiresult, with: BedrockAgentRuntimeClientTypes.ApiResult.write(value:to:))
            case let .functionresult(functionresult):
                try writer["functionResult"].write(functionresult, with: BedrockAgentRuntimeClientTypes.FunctionResult.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InvocationResultMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "apiResult":
                return .apiresult(try reader["apiResult"].read(with: BedrockAgentRuntimeClientTypes.ApiResult.read(from:)))
            case "functionResult":
                return .functionresult(try reader["functionResult"].read(with: BedrockAgentRuntimeClientTypes.FunctionResult.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FunctionResult {

    static func write(value: BedrockAgentRuntimeClientTypes.FunctionResult?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionGroup"].write(value.actionGroup)
        try writer["agentId"].write(value.agentId)
        try writer["confirmationState"].write(value.confirmationState)
        try writer["function"].write(value.function)
        try writer["responseBody"].writeMap(value.responseBody, valueWritingClosure: BedrockAgentRuntimeClientTypes.ContentBody.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseState"].write(value.responseState)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FunctionResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FunctionResult()
        value.actionGroup = try reader["actionGroup"].readIfPresent() ?? ""
        value.confirmationState = try reader["confirmationState"].readIfPresent()
        value.function = try reader["function"].readIfPresent()
        value.responseBody = try reader["responseBody"].readMapIfPresent(valueReadingClosure: BedrockAgentRuntimeClientTypes.ContentBody.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseState = try reader["responseState"].readIfPresent()
        value.agentId = try reader["agentId"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ContentBody {

    static func write(value: BedrockAgentRuntimeClientTypes.ContentBody?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
        try writer["images"].writeList(value.images, memberWritingClosure: BedrockAgentRuntimeClientTypes.ImageInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ContentBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ContentBody()
        value.body = try reader["body"].readIfPresent()
        value.images = try reader["images"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.ImageInput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ImageInput {

    static func write(value: BedrockAgentRuntimeClientTypes.ImageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["format"].write(value.format)
        try writer["source"].write(value.source, with: BedrockAgentRuntimeClientTypes.ImageInputSource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ImageInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ImageInput()
        value.format = try reader["format"].readIfPresent() ?? .sdkUnknown("")
        value.source = try reader["source"].readIfPresent(with: BedrockAgentRuntimeClientTypes.ImageInputSource.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ImageInputSource {

    static func write(value: BedrockAgentRuntimeClientTypes.ImageInputSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .bytes(bytes):
                try writer["bytes"].write(bytes)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ImageInputSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "bytes":
                return .bytes(try reader["bytes"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ApiResult {

    static func write(value: BedrockAgentRuntimeClientTypes.ApiResult?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionGroup"].write(value.actionGroup)
        try writer["agentId"].write(value.agentId)
        try writer["apiPath"].write(value.apiPath)
        try writer["confirmationState"].write(value.confirmationState)
        try writer["httpMethod"].write(value.httpMethod)
        try writer["httpStatusCode"].write(value.httpStatusCode)
        try writer["responseBody"].writeMap(value.responseBody, valueWritingClosure: BedrockAgentRuntimeClientTypes.ContentBody.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseState"].write(value.responseState)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ApiResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ApiResult()
        value.actionGroup = try reader["actionGroup"].readIfPresent() ?? ""
        value.httpMethod = try reader["httpMethod"].readIfPresent()
        value.apiPath = try reader["apiPath"].readIfPresent()
        value.confirmationState = try reader["confirmationState"].readIfPresent()
        value.responseState = try reader["responseState"].readIfPresent()
        value.httpStatusCode = try reader["httpStatusCode"].readIfPresent()
        value.responseBody = try reader["responseBody"].readMapIfPresent(valueReadingClosure: BedrockAgentRuntimeClientTypes.ContentBody.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.agentId = try reader["agentId"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.CodeInterpreterInvocationInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.CodeInterpreterInvocationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.CodeInterpreterInvocationInput()
        value.code = try reader["code"].readIfPresent()
        value.files = try reader["files"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.KnowledgeBaseLookupInput()
        value.text = try reader["text"].readIfPresent()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ActionGroupInvocationInput()
        value.actionGroupName = try reader["actionGroupName"].readIfPresent()
        value.verb = try reader["verb"].readIfPresent()
        value.apiPath = try reader["apiPath"].readIfPresent()
        value.parameters = try reader["parameters"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.Parameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestBody = try reader["requestBody"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RequestBody.read(from:))
        value.function = try reader["function"].readIfPresent()
        value.executionType = try reader["executionType"].readIfPresent()
        value.invocationId = try reader["invocationId"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RequestBody {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RequestBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RequestBody()
        value.content = try reader["content"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: BedrockAgentRuntimeClientTypes.Parameter.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.PostProcessingTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PostProcessingTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "modelInvocationInput":
                return .modelinvocationinput(try reader["modelInvocationInput"].read(with: BedrockAgentRuntimeClientTypes.ModelInvocationInput.read(from:)))
            case "modelInvocationOutput":
                return .modelinvocationoutput(try reader["modelInvocationOutput"].read(with: BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.PostProcessingModelInvocationOutput()
        value.traceId = try reader["traceId"].readIfPresent()
        value.parsedResponse = try reader["parsedResponse"].readIfPresent(with: BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse.read(from:))
        value.rawResponse = try reader["rawResponse"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RawResponse.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Metadata.read(from:))
        value.reasoningContent = try reader["reasoningContent"].readIfPresent(with: BedrockAgentRuntimeClientTypes.ReasoningContentBlock.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.ReasoningContentBlock {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ReasoningContentBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "reasoningText":
                return .reasoningtext(try reader["reasoningText"].read(with: BedrockAgentRuntimeClientTypes.ReasoningTextBlock.read(from:)))
            case "redactedContent":
                return .redactedcontent(try reader["redactedContent"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ReasoningTextBlock {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.ReasoningTextBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.ReasoningTextBlock()
        value.text = try reader["text"].readIfPresent() ?? ""
        value.signature = try reader["signature"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.PostProcessingParsedResponse()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.OrchestrationTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.OrchestrationTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "rationale":
                return .rationale(try reader["rationale"].read(with: BedrockAgentRuntimeClientTypes.Rationale.read(from:)))
            case "invocationInput":
                return .invocationinput(try reader["invocationInput"].read(with: BedrockAgentRuntimeClientTypes.InvocationInput.read(from:)))
            case "observation":
                return .observation(try reader["observation"].read(with: BedrockAgentRuntimeClientTypes.Observation.read(from:)))
            case "modelInvocationInput":
                return .modelinvocationinput(try reader["modelInvocationInput"].read(with: BedrockAgentRuntimeClientTypes.ModelInvocationInput.read(from:)))
            case "modelInvocationOutput":
                return .modelinvocationoutput(try reader["modelInvocationOutput"].read(with: BedrockAgentRuntimeClientTypes.OrchestrationModelInvocationOutput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.OrchestrationModelInvocationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.OrchestrationModelInvocationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.OrchestrationModelInvocationOutput()
        value.traceId = try reader["traceId"].readIfPresent()
        value.rawResponse = try reader["rawResponse"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RawResponse.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Metadata.read(from:))
        value.reasoningContent = try reader["reasoningContent"].readIfPresent(with: BedrockAgentRuntimeClientTypes.ReasoningContentBlock.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.Rationale {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Rationale {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Rationale()
        value.traceId = try reader["traceId"].readIfPresent()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.PreProcessingTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PreProcessingTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "modelInvocationInput":
                return .modelinvocationinput(try reader["modelInvocationInput"].read(with: BedrockAgentRuntimeClientTypes.ModelInvocationInput.read(from:)))
            case "modelInvocationOutput":
                return .modelinvocationoutput(try reader["modelInvocationOutput"].read(with: BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.PreProcessingModelInvocationOutput()
        value.traceId = try reader["traceId"].readIfPresent()
        value.parsedResponse = try reader["parsedResponse"].readIfPresent(with: BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse.read(from:))
        value.rawResponse = try reader["rawResponse"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RawResponse.read(from:))
        value.metadata = try reader["metadata"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Metadata.read(from:))
        value.reasoningContent = try reader["reasoningContent"].readIfPresent(with: BedrockAgentRuntimeClientTypes.ReasoningContentBlock.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.PreProcessingParsedResponse()
        value.rationale = try reader["rationale"].readIfPresent()
        value.isValid = try reader["isValid"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailTrace()
        value.action = try reader["action"].readIfPresent()
        value.traceId = try reader["traceId"].readIfPresent()
        value.inputAssessments = try reader["inputAssessments"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailAssessment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputAssessments = try reader["outputAssessments"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailAssessment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailAssessment()
        value.topicPolicy = try reader["topicPolicy"].readIfPresent(with: BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment.read(from:))
        value.contentPolicy = try reader["contentPolicy"].readIfPresent(with: BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment.read(from:))
        value.wordPolicy = try reader["wordPolicy"].readIfPresent(with: BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment.read(from:))
        value.sensitiveInformationPolicy = try reader["sensitiveInformationPolicy"].readIfPresent(with: BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment()
        value.piiEntities = try reader["piiEntities"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.regexes = try reader["regexes"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailRegexFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailRegexFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailRegexFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailRegexFilter()
        value.name = try reader["name"].readIfPresent()
        value.regex = try reader["regex"].readIfPresent()
        value.match = try reader["match"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailPiiEntityFilter()
        value.type = try reader["type"].readIfPresent()
        value.match = try reader["match"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailWordPolicyAssessment()
        value.customWords = try reader["customWords"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailCustomWord.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.managedWordLists = try reader["managedWordLists"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailManagedWord.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailManagedWord {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailManagedWord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailManagedWord()
        value.match = try reader["match"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailCustomWord {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailCustomWord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailCustomWord()
        value.match = try reader["match"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailContentPolicyAssessment()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailContentFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailContentFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailContentFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailContentFilter()
        value.type = try reader["type"].readIfPresent()
        value.confidence = try reader["confidence"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailTopicPolicyAssessment()
        value.topics = try reader["topics"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.GuardrailTopic.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailTopic {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailTopic {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailTopic()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.PayloadPart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.PayloadPart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.PayloadPart()
        value.bytes = try reader["bytes"].readIfPresent()
        value.attribution = try reader["attribution"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Attribution.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.Attribution {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Attribution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Attribution()
        value.citations = try reader["citations"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.Citation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.Citation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Citation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Citation()
        value.generatedResponsePart = try reader["generatedResponsePart"].readIfPresent(with: BedrockAgentRuntimeClientTypes.GeneratedResponsePart.read(from:))
        value.retrievedReferences = try reader["retrievedReferences"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.RetrievedReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GeneratedResponsePart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GeneratedResponsePart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GeneratedResponsePart()
        value.textResponsePart = try reader["textResponsePart"].readIfPresent(with: BedrockAgentRuntimeClientTypes.TextResponsePart.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.TextResponsePart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.TextResponsePart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.TextResponsePart()
        value.text = try reader["text"].readIfPresent()
        value.span = try reader["span"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Span.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.Span {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.Span {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.Span()
        value.start = try reader["start"].readIfPresent()
        value.end = try reader["end"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FlowMultiTurnInputRequestEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowMultiTurnInputRequestEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FlowMultiTurnInputRequestEvent()
        value.nodeName = try reader["nodeName"].readIfPresent() ?? ""
        value.nodeType = try reader["nodeType"].readIfPresent() ?? .sdkUnknown("")
        value.content = try reader["content"].readIfPresent(with: BedrockAgentRuntimeClientTypes.FlowMultiTurnInputContent.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FlowMultiTurnInputContent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowMultiTurnInputContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "document":
                return .document(try reader["document"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowTraceEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FlowTraceEvent()
        value.trace = try reader["trace"].readIfPresent(with: BedrockAgentRuntimeClientTypes.FlowTrace.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "nodeInputTrace":
                return .nodeinputtrace(try reader["nodeInputTrace"].read(with: BedrockAgentRuntimeClientTypes.FlowTraceNodeInputEvent.read(from:)))
            case "nodeOutputTrace":
                return .nodeoutputtrace(try reader["nodeOutputTrace"].read(with: BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputEvent.read(from:)))
            case "conditionNodeResultTrace":
                return .conditionnoderesulttrace(try reader["conditionNodeResultTrace"].read(with: BedrockAgentRuntimeClientTypes.FlowTraceConditionNodeResultEvent.read(from:)))
            case "nodeActionTrace":
                return .nodeactiontrace(try reader["nodeActionTrace"].read(with: BedrockAgentRuntimeClientTypes.FlowTraceNodeActionEvent.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceNodeActionEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowTraceNodeActionEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FlowTraceNodeActionEvent()
        value.nodeName = try reader["nodeName"].readIfPresent() ?? ""
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.requestId = try reader["requestId"].readIfPresent() ?? ""
        value.serviceName = try reader["serviceName"].readIfPresent() ?? ""
        value.operationName = try reader["operationName"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceConditionNodeResultEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowTraceConditionNodeResultEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FlowTraceConditionNodeResultEvent()
        value.nodeName = try reader["nodeName"].readIfPresent() ?? ""
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.satisfiedConditions = try reader["satisfiedConditions"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.FlowTraceCondition.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceCondition {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowTraceCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FlowTraceCondition()
        value.conditionName = try reader["conditionName"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputEvent()
        value.nodeName = try reader["nodeName"].readIfPresent() ?? ""
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputField.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputField {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputField()
        value.nodeOutputName = try reader["nodeOutputName"].readIfPresent() ?? ""
        value.content = try reader["content"].readIfPresent(with: BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputContent.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputContent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowTraceNodeOutputContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "document":
                return .document(try reader["document"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceNodeInputEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowTraceNodeInputEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FlowTraceNodeInputEvent()
        value.nodeName = try reader["nodeName"].readIfPresent() ?? ""
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.FlowTraceNodeInputField.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceNodeInputField {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowTraceNodeInputField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FlowTraceNodeInputField()
        value.nodeInputName = try reader["nodeInputName"].readIfPresent() ?? ""
        value.content = try reader["content"].readIfPresent(with: BedrockAgentRuntimeClientTypes.FlowTraceNodeInputContent.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FlowTraceNodeInputContent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowTraceNodeInputContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "document":
                return .document(try reader["document"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FlowCompletionEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowCompletionEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FlowCompletionEvent()
        value.completionReason = try reader["completionReason"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FlowOutputEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowOutputEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.FlowOutputEvent()
        value.nodeName = try reader["nodeName"].readIfPresent() ?? ""
        value.nodeType = try reader["nodeType"].readIfPresent() ?? .sdkUnknown("")
        value.content = try reader["content"].readIfPresent(with: BedrockAgentRuntimeClientTypes.FlowOutputContent.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.FlowOutputContent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.FlowOutputContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "document":
                return .document(try reader["document"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.InlineAgentFilePart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InlineAgentFilePart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.InlineAgentFilePart()
        value.files = try reader["files"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.OutputFile.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.InlineAgentReturnControlPayload {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InlineAgentReturnControlPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.InlineAgentReturnControlPayload()
        value.invocationInputs = try reader["invocationInputs"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.InvocationInputMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.invocationId = try reader["invocationId"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.InlineAgentTracePart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InlineAgentTracePart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.InlineAgentTracePart()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.trace = try reader["trace"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Trace.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.InlineAgentPayloadPart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InlineAgentPayloadPart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.InlineAgentPayloadPart()
        value.bytes = try reader["bytes"].readIfPresent()
        value.attribution = try reader["attribution"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Attribution.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InvocationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.InvocationSummary()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.invocationId = try reader["invocationId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.InvocationStepSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.InvocationStepSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.InvocationStepSummary()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.invocationId = try reader["invocationId"].readIfPresent() ?? ""
        value.invocationStepId = try reader["invocationStepId"].readIfPresent() ?? ""
        value.invocationStepTime = try reader["invocationStepTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.SessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.SessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.SessionSummary()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.sessionArn = try reader["sessionArn"].readIfPresent() ?? ""
        value.sessionStatus = try reader["sessionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.AnalyzePromptEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.AnalyzePromptEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.AnalyzePromptEvent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.OptimizedPromptEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.OptimizedPromptEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.OptimizedPromptEvent()
        value.optimizedPrompt = try reader["optimizedPrompt"].readIfPresent(with: BedrockAgentRuntimeClientTypes.OptimizedPrompt.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.OptimizedPrompt {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.OptimizedPrompt {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "textPrompt":
                return .textprompt(try reader["textPrompt"].read(with: BedrockAgentRuntimeClientTypes.TextPrompt.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentRuntimeClientTypes.TextPrompt {

    static func write(value: BedrockAgentRuntimeClientTypes.TextPrompt?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["text"].write(value.text)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.TextPrompt {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.TextPrompt()
        value.text = try reader["text"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RerankResult {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RerankResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RerankResult()
        value.index = try reader["index"].readIfPresent() ?? 0
        value.relevanceScore = try reader["relevanceScore"].readIfPresent() ?? 0.0
        value.document = try reader["document"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RerankDocument.read(from:))
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RerankDocument {

    static func write(value: BedrockAgentRuntimeClientTypes.RerankDocument?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jsonDocument"].write(value.jsonDocument)
        try writer["textDocument"].write(value.textDocument, with: BedrockAgentRuntimeClientTypes.RerankTextDocument.write(value:to:))
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RerankDocument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RerankDocument()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.textDocument = try reader["textDocument"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RerankTextDocument.read(from:))
        value.jsonDocument = try reader["jsonDocument"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RerankTextDocument {

    static func write(value: BedrockAgentRuntimeClientTypes.RerankTextDocument?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["text"].write(value.text)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RerankTextDocument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RerankTextDocument()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalResult()
        value.content = try reader["content"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultContent.read(from:))
        value.location = try reader["location"].readIfPresent(with: BedrockAgentRuntimeClientTypes.RetrievalResultLocation.read(from:))
        value.score = try reader["score"].readIfPresent()
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDocument(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutput()
        value.text = try reader["text"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.GuardrailEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.GuardrailEvent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.CitationEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.CitationEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.CitationEvent()
        value.citation = try reader["citation"].readIfPresent(with: BedrockAgentRuntimeClientTypes.Citation.read(from:))
        value.generatedResponsePart = try reader["generatedResponsePart"].readIfPresent(with: BedrockAgentRuntimeClientTypes.GeneratedResponsePart.read(from:))
        value.retrievedReferences = try reader["retrievedReferences"].readListIfPresent(memberReadingClosure: BedrockAgentRuntimeClientTypes.RetrievedReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutputEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutputEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentRuntimeClientTypes.RetrieveAndGenerateOutputEvent()
        value.text = try reader["text"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentRuntimeClientTypes.QueryGenerationInput {

    static func write(value: BedrockAgentRuntimeClientTypes.QueryGenerationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["text"].write(value.text)
        try writer["type"].write(value.type)
    }
}

extension BedrockAgentRuntimeClientTypes.TransformationConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.TransformationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mode"].write(value.mode)
        try writer["textToSqlConfiguration"].write(value.textToSqlConfiguration, with: BedrockAgentRuntimeClientTypes.TextToSqlConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.TextToSqlConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.TextToSqlConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["knowledgeBaseConfiguration"].write(value.knowledgeBaseConfiguration, with: BedrockAgentRuntimeClientTypes.TextToSqlKnowledgeBaseConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }
}

extension BedrockAgentRuntimeClientTypes.TextToSqlKnowledgeBaseConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.TextToSqlKnowledgeBaseConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["knowledgeBaseArn"].write(value.knowledgeBaseArn)
    }
}

extension BedrockAgentRuntimeClientTypes.SessionState {

    static func write(value: BedrockAgentRuntimeClientTypes.SessionState?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["conversationHistory"].write(value.conversationHistory, with: BedrockAgentRuntimeClientTypes.ConversationHistory.write(value:to:))
        try writer["files"].writeList(value.files, memberWritingClosure: BedrockAgentRuntimeClientTypes.InputFile.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["invocationId"].write(value.invocationId)
        try writer["knowledgeBaseConfigurations"].writeList(value.knowledgeBaseConfigurations, memberWritingClosure: BedrockAgentRuntimeClientTypes.KnowledgeBaseConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["promptSessionAttributes"].writeMap(value.promptSessionAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["returnControlInvocationResults"].writeList(value.returnControlInvocationResults, memberWritingClosure: BedrockAgentRuntimeClientTypes.InvocationResultMember.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sessionAttributes"].writeMap(value.sessionAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension BedrockAgentRuntimeClientTypes.ConversationHistory {

    static func write(value: BedrockAgentRuntimeClientTypes.ConversationHistory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["messages"].writeList(value.messages, memberWritingClosure: BedrockAgentRuntimeClientTypes.Message.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentRuntimeClientTypes.Message {

    static func write(value: BedrockAgentRuntimeClientTypes.Message?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].writeList(value.content, memberWritingClosure: BedrockAgentRuntimeClientTypes.ContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["role"].write(value.role)
    }
}

extension BedrockAgentRuntimeClientTypes.ContentBlock {

    static func write(value: BedrockAgentRuntimeClientTypes.ContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.KnowledgeBaseConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["knowledgeBaseId"].write(value.knowledgeBaseId)
        try writer["retrievalConfiguration"].write(value.retrievalConfiguration, with: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vectorSearchConfiguration"].write(value.vectorSearchConfiguration, with: BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.KnowledgeBaseVectorSearchConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: BedrockAgentRuntimeClientTypes.RetrievalFilter.write(value:to:))
        try writer["implicitFilterConfiguration"].write(value.implicitFilterConfiguration, with: BedrockAgentRuntimeClientTypes.ImplicitFilterConfiguration.write(value:to:))
        try writer["numberOfResults"].write(value.numberOfResults)
        try writer["overrideSearchType"].write(value.overrideSearchType)
        try writer["rerankingConfiguration"].write(value.rerankingConfiguration, with: BedrockAgentRuntimeClientTypes.VectorSearchRerankingConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.ImplicitFilterConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.ImplicitFilterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataAttributes"].writeList(value.metadataAttributes, memberWritingClosure: BedrockAgentRuntimeClientTypes.MetadataAttributeSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["modelArn"].write(value.modelArn)
    }
}

extension BedrockAgentRuntimeClientTypes.MetadataAttributeSchema {

    static func write(value: BedrockAgentRuntimeClientTypes.MetadataAttributeSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["key"].write(value.key)
        try writer["type"].write(value.type)
    }
}

extension BedrockAgentRuntimeClientTypes.VectorSearchRerankingConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.VectorSearchRerankingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bedrockRerankingConfiguration"].write(value.bedrockRerankingConfiguration, with: BedrockAgentRuntimeClientTypes.VectorSearchBedrockRerankingConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }
}

extension BedrockAgentRuntimeClientTypes.VectorSearchBedrockRerankingConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.VectorSearchBedrockRerankingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataConfiguration"].write(value.metadataConfiguration, with: BedrockAgentRuntimeClientTypes.MetadataConfigurationForReranking.write(value:to:))
        try writer["modelConfiguration"].write(value.modelConfiguration, with: BedrockAgentRuntimeClientTypes.VectorSearchBedrockRerankingModelConfiguration.write(value:to:))
        try writer["numberOfRerankedResults"].write(value.numberOfRerankedResults)
    }
}

extension BedrockAgentRuntimeClientTypes.MetadataConfigurationForReranking {

    static func write(value: BedrockAgentRuntimeClientTypes.MetadataConfigurationForReranking?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["selectionMode"].write(value.selectionMode)
        try writer["selectiveModeConfiguration"].write(value.selectiveModeConfiguration, with: BedrockAgentRuntimeClientTypes.RerankingMetadataSelectiveModeConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.RerankingMetadataSelectiveModeConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.RerankingMetadataSelectiveModeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .fieldstoexclude(fieldstoexclude):
                try writer["fieldsToExclude"].writeList(fieldstoexclude, memberWritingClosure: BedrockAgentRuntimeClientTypes.FieldForReranking.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .fieldstoinclude(fieldstoinclude):
                try writer["fieldsToInclude"].writeList(fieldstoinclude, memberWritingClosure: BedrockAgentRuntimeClientTypes.FieldForReranking.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FieldForReranking {

    static func write(value: BedrockAgentRuntimeClientTypes.FieldForReranking?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fieldName"].write(value.fieldName)
    }
}

extension BedrockAgentRuntimeClientTypes.VectorSearchBedrockRerankingModelConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.VectorSearchBedrockRerankingModelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].writeMap(value.additionalModelRequestFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["modelArn"].write(value.modelArn)
    }
}

extension BedrockAgentRuntimeClientTypes.RetrievalFilter {

    static func write(value: BedrockAgentRuntimeClientTypes.RetrievalFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .andall(andall):
                try writer["andAll"].writeList(andall, memberWritingClosure: BedrockAgentRuntimeClientTypes.RetrievalFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .equals(equals):
                try writer["equals"].write(equals, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .greaterthan(greaterthan):
                try writer["greaterThan"].write(greaterthan, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .greaterthanorequals(greaterthanorequals):
                try writer["greaterThanOrEquals"].write(greaterthanorequals, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .`in`(`in`):
                try writer["in"].write(`in`, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .lessthan(lessthan):
                try writer["lessThan"].write(lessthan, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .lessthanorequals(lessthanorequals):
                try writer["lessThanOrEquals"].write(lessthanorequals, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .listcontains(listcontains):
                try writer["listContains"].write(listcontains, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .notequals(notequals):
                try writer["notEquals"].write(notequals, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .notin(notin):
                try writer["notIn"].write(notin, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .orall(orall):
                try writer["orAll"].writeList(orall, memberWritingClosure: BedrockAgentRuntimeClientTypes.RetrievalFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .startswith(startswith):
                try writer["startsWith"].write(startswith, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .stringcontains(stringcontains):
                try writer["stringContains"].write(stringcontains, with: BedrockAgentRuntimeClientTypes.FilterAttribute.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FilterAttribute {

    static func write(value: BedrockAgentRuntimeClientTypes.FilterAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }
}

extension BedrockAgentRuntimeClientTypes.InputFile {

    static func write(value: BedrockAgentRuntimeClientTypes.InputFile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["source"].write(value.source, with: BedrockAgentRuntimeClientTypes.FileSource.write(value:to:))
        try writer["useCase"].write(value.useCase)
    }
}

extension BedrockAgentRuntimeClientTypes.FileSource {

    static func write(value: BedrockAgentRuntimeClientTypes.FileSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["byteContent"].write(value.byteContent, with: BedrockAgentRuntimeClientTypes.ByteContentFile.write(value:to:))
        try writer["s3Location"].write(value.s3Location, with: BedrockAgentRuntimeClientTypes.S3ObjectFile.write(value:to:))
        try writer["sourceType"].write(value.sourceType)
    }
}

extension BedrockAgentRuntimeClientTypes.ByteContentFile {

    static func write(value: BedrockAgentRuntimeClientTypes.ByteContentFile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["data"].write(value.data)
        try writer["mediaType"].write(value.mediaType)
    }
}

extension BedrockAgentRuntimeClientTypes.S3ObjectFile {

    static func write(value: BedrockAgentRuntimeClientTypes.S3ObjectFile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uri"].write(value.uri)
    }
}

extension BedrockAgentRuntimeClientTypes.BedrockModelConfigurations {

    static func write(value: BedrockAgentRuntimeClientTypes.BedrockModelConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["performanceConfig"].write(value.performanceConfig, with: BedrockAgentRuntimeClientTypes.PerformanceConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.PerformanceConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.PerformanceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["latency"].write(value.latency)
    }
}

extension BedrockAgentRuntimeClientTypes.StreamingConfigurations {

    static func write(value: BedrockAgentRuntimeClientTypes.StreamingConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applyGuardrailInterval"].write(value.applyGuardrailInterval)
        try writer["streamFinalResponse"].write(value.streamFinalResponse)
    }
}

extension BedrockAgentRuntimeClientTypes.FlowInput {

    static func write(value: BedrockAgentRuntimeClientTypes.FlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content, with: BedrockAgentRuntimeClientTypes.FlowInputContent.write(value:to:))
        try writer["nodeInputName"].write(value.nodeInputName)
        try writer["nodeName"].write(value.nodeName)
        try writer["nodeOutputName"].write(value.nodeOutputName)
    }
}

extension BedrockAgentRuntimeClientTypes.FlowInputContent {

    static func write(value: BedrockAgentRuntimeClientTypes.FlowInputContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .document(document):
                try writer["document"].write(document)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.ModelPerformanceConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.ModelPerformanceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["performanceConfig"].write(value.performanceConfig, with: BedrockAgentRuntimeClientTypes.PerformanceConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.AgentActionGroup {

    static func write(value: BedrockAgentRuntimeClientTypes.AgentActionGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionGroupExecutor"].write(value.actionGroupExecutor, with: BedrockAgentRuntimeClientTypes.ActionGroupExecutor.write(value:to:))
        try writer["actionGroupName"].write(value.actionGroupName)
        try writer["apiSchema"].write(value.apiSchema, with: BedrockAgentRuntimeClientTypes.APISchema.write(value:to:))
        try writer["description"].write(value.description)
        try writer["functionSchema"].write(value.functionSchema, with: BedrockAgentRuntimeClientTypes.FunctionSchema.write(value:to:))
        try writer["parentActionGroupSignature"].write(value.parentActionGroupSignature)
        try writer["parentActionGroupSignatureParams"].writeMap(value.parentActionGroupSignatureParams, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension BedrockAgentRuntimeClientTypes.FunctionSchema {

    static func write(value: BedrockAgentRuntimeClientTypes.FunctionSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .functions(functions):
                try writer["functions"].writeList(functions, memberWritingClosure: BedrockAgentRuntimeClientTypes.FunctionDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.FunctionDefinition {

    static func write(value: BedrockAgentRuntimeClientTypes.FunctionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: BedrockAgentRuntimeClientTypes.ParameterDetail.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requireConfirmation"].write(value.requireConfirmation)
    }
}

extension BedrockAgentRuntimeClientTypes.ParameterDetail {

    static func write(value: BedrockAgentRuntimeClientTypes.ParameterDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["required"].write(value.`required`)
        try writer["type"].write(value.type)
    }
}

extension BedrockAgentRuntimeClientTypes.APISchema {

    static func write(value: BedrockAgentRuntimeClientTypes.APISchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .payload(payload):
                try writer["payload"].write(payload)
            case let .s3(s3):
                try writer["s3"].write(s3, with: BedrockAgentRuntimeClientTypes.S3Identifier.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.S3Identifier {

    static func write(value: BedrockAgentRuntimeClientTypes.S3Identifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3BucketName"].write(value.s3BucketName)
        try writer["s3ObjectKey"].write(value.s3ObjectKey)
    }
}

extension BedrockAgentRuntimeClientTypes.ActionGroupExecutor {

    static func write(value: BedrockAgentRuntimeClientTypes.ActionGroupExecutor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .customcontrol(customcontrol):
                try writer["customControl"].write(customcontrol)
            case let .lambda(lambda):
                try writer["lambda"].write(lambda)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBase {

    static func write(value: BedrockAgentRuntimeClientTypes.KnowledgeBase?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["knowledgeBaseId"].write(value.knowledgeBaseId)
        try writer["retrievalConfiguration"].write(value.retrievalConfiguration, with: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailConfigurationWithArn {

    static func write(value: BedrockAgentRuntimeClientTypes.GuardrailConfigurationWithArn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["guardrailIdentifier"].write(value.guardrailIdentifier)
        try writer["guardrailVersion"].write(value.guardrailVersion)
    }
}

extension BedrockAgentRuntimeClientTypes.PromptOverrideConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.PromptOverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["overrideLambda"].write(value.overrideLambda)
        try writer["promptConfigurations"].writeList(value.promptConfigurations, memberWritingClosure: BedrockAgentRuntimeClientTypes.PromptConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentRuntimeClientTypes.PromptConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.PromptConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].write(value.additionalModelRequestFields)
        try writer["basePromptTemplate"].write(value.basePromptTemplate)
        try writer["foundationModel"].write(value.foundationModel)
        try writer["inferenceConfiguration"].write(value.inferenceConfiguration, with: BedrockAgentRuntimeClientTypes.InferenceConfiguration.write(value:to:))
        try writer["parserMode"].write(value.parserMode)
        try writer["promptCreationMode"].write(value.promptCreationMode)
        try writer["promptState"].write(value.promptState)
        try writer["promptType"].write(value.promptType)
    }
}

extension BedrockAgentRuntimeClientTypes.CollaboratorConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.CollaboratorConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentAliasArn"].write(value.agentAliasArn)
        try writer["collaboratorInstruction"].write(value.collaboratorInstruction)
        try writer["collaboratorName"].write(value.collaboratorName)
        try writer["relayConversationHistory"].write(value.relayConversationHistory)
    }
}

extension BedrockAgentRuntimeClientTypes.InlineSessionState {

    static func write(value: BedrockAgentRuntimeClientTypes.InlineSessionState?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["conversationHistory"].write(value.conversationHistory, with: BedrockAgentRuntimeClientTypes.ConversationHistory.write(value:to:))
        try writer["files"].writeList(value.files, memberWritingClosure: BedrockAgentRuntimeClientTypes.InputFile.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["invocationId"].write(value.invocationId)
        try writer["promptSessionAttributes"].writeMap(value.promptSessionAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["returnControlInvocationResults"].writeList(value.returnControlInvocationResults, memberWritingClosure: BedrockAgentRuntimeClientTypes.InvocationResultMember.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sessionAttributes"].writeMap(value.sessionAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension BedrockAgentRuntimeClientTypes.Collaborator {

    static func write(value: BedrockAgentRuntimeClientTypes.Collaborator?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionGroups"].writeList(value.actionGroups, memberWritingClosure: BedrockAgentRuntimeClientTypes.AgentActionGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["agentCollaboration"].write(value.agentCollaboration)
        try writer["agentName"].write(value.agentName)
        try writer["collaboratorConfigurations"].writeList(value.collaboratorConfigurations, memberWritingClosure: BedrockAgentRuntimeClientTypes.CollaboratorConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["customerEncryptionKeyArn"].write(value.customerEncryptionKeyArn)
        try writer["foundationModel"].write(value.foundationModel)
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockAgentRuntimeClientTypes.GuardrailConfigurationWithArn.write(value:to:))
        try writer["idleSessionTTLInSeconds"].write(value.idleSessionTTLInSeconds)
        try writer["instruction"].write(value.instruction)
        try writer["knowledgeBases"].writeList(value.knowledgeBases, memberWritingClosure: BedrockAgentRuntimeClientTypes.KnowledgeBase.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["promptOverrideConfiguration"].write(value.promptOverrideConfiguration, with: BedrockAgentRuntimeClientTypes.PromptOverrideConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.InlineBedrockModelConfigurations {

    static func write(value: BedrockAgentRuntimeClientTypes.InlineBedrockModelConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["performanceConfig"].write(value.performanceConfig, with: BedrockAgentRuntimeClientTypes.PerformanceConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.InputPrompt {

    static func write(value: BedrockAgentRuntimeClientTypes.InputPrompt?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .textprompt(textprompt):
                try writer["textPrompt"].write(textprompt, with: BedrockAgentRuntimeClientTypes.TextPrompt.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockAgentRuntimeClientTypes.RerankQuery {

    static func write(value: BedrockAgentRuntimeClientTypes.RerankQuery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["textQuery"].write(value.textQuery, with: BedrockAgentRuntimeClientTypes.RerankTextDocument.write(value:to:))
        try writer["type"].write(value.type)
    }
}

extension BedrockAgentRuntimeClientTypes.RerankSource {

    static func write(value: BedrockAgentRuntimeClientTypes.RerankSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inlineDocumentSource"].write(value.inlineDocumentSource, with: BedrockAgentRuntimeClientTypes.RerankDocument.write(value:to:))
        try writer["type"].write(value.type)
    }
}

extension BedrockAgentRuntimeClientTypes.RerankingConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.RerankingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bedrockRerankingConfiguration"].write(value.bedrockRerankingConfiguration, with: BedrockAgentRuntimeClientTypes.BedrockRerankingConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }
}

extension BedrockAgentRuntimeClientTypes.BedrockRerankingConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.BedrockRerankingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelConfiguration"].write(value.modelConfiguration, with: BedrockAgentRuntimeClientTypes.BedrockRerankingModelConfiguration.write(value:to:))
        try writer["numberOfResults"].write(value.numberOfResults)
    }
}

extension BedrockAgentRuntimeClientTypes.BedrockRerankingModelConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.BedrockRerankingModelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].writeMap(value.additionalModelRequestFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["modelArn"].write(value.modelArn)
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery {

    static func write(value: BedrockAgentRuntimeClientTypes.KnowledgeBaseQuery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["text"].write(value.text)
    }
}

extension BedrockAgentRuntimeClientTypes.GuardrailConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.GuardrailConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["guardrailId"].write(value.guardrailId)
        try writer["guardrailVersion"].write(value.guardrailVersion)
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput {

    static func write(value: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["text"].write(value.text)
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["externalSourcesConfiguration"].write(value.externalSourcesConfiguration, with: BedrockAgentRuntimeClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration.write(value:to:))
        try writer["knowledgeBaseConfiguration"].write(value.knowledgeBaseConfiguration, with: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }
}

extension BedrockAgentRuntimeClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["generationConfiguration"].write(value.generationConfiguration, with: BedrockAgentRuntimeClientTypes.ExternalSourcesGenerationConfiguration.write(value:to:))
        try writer["modelArn"].write(value.modelArn)
        try writer["sources"].writeList(value.sources, memberWritingClosure: BedrockAgentRuntimeClientTypes.ExternalSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentRuntimeClientTypes.ExternalSourcesGenerationConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.ExternalSourcesGenerationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].writeMap(value.additionalModelRequestFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockAgentRuntimeClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["inferenceConfig"].write(value.inferenceConfig, with: BedrockAgentRuntimeClientTypes.InferenceConfig.write(value:to:))
        try writer["performanceConfig"].write(value.performanceConfig, with: BedrockAgentRuntimeClientTypes.PerformanceConfiguration.write(value:to:))
        try writer["promptTemplate"].write(value.promptTemplate, with: BedrockAgentRuntimeClientTypes.PromptTemplate.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.InferenceConfig {

    static func write(value: BedrockAgentRuntimeClientTypes.InferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["textInferenceConfig"].write(value.textInferenceConfig, with: BedrockAgentRuntimeClientTypes.TextInferenceConfig.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.TextInferenceConfig {

    static func write(value: BedrockAgentRuntimeClientTypes.TextInferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxTokens"].write(value.maxTokens)
        try writer["stopSequences"].writeList(value.stopSequences, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["temperature"].write(value.temperature)
        try writer["topP"].write(value.topp)
    }
}

extension BedrockAgentRuntimeClientTypes.PromptTemplate {

    static func write(value: BedrockAgentRuntimeClientTypes.PromptTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["textPromptTemplate"].write(value.textPromptTemplate)
    }
}

extension BedrockAgentRuntimeClientTypes.ExternalSource {

    static func write(value: BedrockAgentRuntimeClientTypes.ExternalSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["byteContent"].write(value.byteContent, with: BedrockAgentRuntimeClientTypes.ByteContentDoc.write(value:to:))
        try writer["s3Location"].write(value.s3Location, with: BedrockAgentRuntimeClientTypes.S3ObjectDoc.write(value:to:))
        try writer["sourceType"].write(value.sourceType)
    }
}

extension BedrockAgentRuntimeClientTypes.ByteContentDoc {

    static func write(value: BedrockAgentRuntimeClientTypes.ByteContentDoc?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["data"].write(value.data)
        try writer["identifier"].write(value.identifier)
    }
}

extension BedrockAgentRuntimeClientTypes.S3ObjectDoc {

    static func write(value: BedrockAgentRuntimeClientTypes.S3ObjectDoc?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uri"].write(value.uri)
    }
}

extension BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["generationConfiguration"].write(value.generationConfiguration, with: BedrockAgentRuntimeClientTypes.GenerationConfiguration.write(value:to:))
        try writer["knowledgeBaseId"].write(value.knowledgeBaseId)
        try writer["modelArn"].write(value.modelArn)
        try writer["orchestrationConfiguration"].write(value.orchestrationConfiguration, with: BedrockAgentRuntimeClientTypes.OrchestrationConfiguration.write(value:to:))
        try writer["retrievalConfiguration"].write(value.retrievalConfiguration, with: BedrockAgentRuntimeClientTypes.KnowledgeBaseRetrievalConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.OrchestrationConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.OrchestrationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].writeMap(value.additionalModelRequestFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["inferenceConfig"].write(value.inferenceConfig, with: BedrockAgentRuntimeClientTypes.InferenceConfig.write(value:to:))
        try writer["performanceConfig"].write(value.performanceConfig, with: BedrockAgentRuntimeClientTypes.PerformanceConfiguration.write(value:to:))
        try writer["promptTemplate"].write(value.promptTemplate, with: BedrockAgentRuntimeClientTypes.PromptTemplate.write(value:to:))
        try writer["queryTransformationConfiguration"].write(value.queryTransformationConfiguration, with: BedrockAgentRuntimeClientTypes.QueryTransformationConfiguration.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.QueryTransformationConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.QueryTransformationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }
}

extension BedrockAgentRuntimeClientTypes.GenerationConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.GenerationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].writeMap(value.additionalModelRequestFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockAgentRuntimeClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["inferenceConfig"].write(value.inferenceConfig, with: BedrockAgentRuntimeClientTypes.InferenceConfig.write(value:to:))
        try writer["performanceConfig"].write(value.performanceConfig, with: BedrockAgentRuntimeClientTypes.PerformanceConfiguration.write(value:to:))
        try writer["promptTemplate"].write(value.promptTemplate, with: BedrockAgentRuntimeClientTypes.PromptTemplate.write(value:to:))
    }
}

extension BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration {

    static func write(value: BedrockAgentRuntimeClientTypes.RetrieveAndGenerateSessionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
    }
}

public enum BedrockAgentRuntimeClientTypes {}
