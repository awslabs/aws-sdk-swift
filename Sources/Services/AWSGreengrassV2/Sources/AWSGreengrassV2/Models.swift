//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteComponentOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCoreDeviceOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDeploymentOutput: Swift.Sendable {

    public init() { }
}

/// You don't have permission to perform the action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GreengrassV2ClientTypes {

    /// Contains a request to associate a client device with a core device. The [BatchAssociateClientDeviceWithCoreDevice](https://docs.aws.amazon.com/greengrass/v2/APIReference/API_BatchAssociateClientDeviceWithCoreDevice.html) operation consumes a list of these requests.
    public struct AssociateClientDeviceWithCoreDeviceEntry: Swift.Sendable {
        /// The name of the IoT thing that represents the client device to associate.
        /// This member is required.
        public var thingName: Swift.String?

        public init(
            thingName: Swift.String? = nil
        )
        {
            self.thingName = thingName
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains an error that occurs from a request to associate a client device with a core device. The [BatchAssociateClientDeviceWithCoreDevice](https://docs.aws.amazon.com/greengrass/v2/APIReference/API_BatchAssociateClientDeviceWithCoreDevice.html) operation returns a list of these errors.
    public struct AssociateClientDeviceWithCoreDeviceErrorEntry: Swift.Sendable {
        /// The error code for the request.
        public var code: Swift.String?
        /// A message that provides additional information about the error.
        public var message: Swift.String?
        /// The name of the IoT thing whose associate request failed.
        public var thingName: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.thingName = thingName
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a client device that is associated to a core device for cloud discovery.
    public struct AssociatedClientDevice: Swift.Sendable {
        /// The time that the client device was associated, expressed in ISO 8601 format.
        public var associationTimestamp: Foundation.Date?
        /// The name of the IoT thing that represents the associated client device.
        public var thingName: Swift.String?

        public init(
            associationTimestamp: Foundation.Date? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.associationTimestamp = associationTimestamp
            self.thingName = thingName
        }
    }
}

/// IoT Greengrass can't process your request right now. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The amount of time to wait before you retry the request.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a validation exception field.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The message of the exception field.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the exception field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request isn't valid. This can occur if your request contains malformed JSON or unsupported characters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that failed to validate.
        public internal(set) var fields: [GreengrassV2ClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation exception.
        public internal(set) var reason: GreengrassV2ClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [GreengrassV2ClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: GreengrassV2ClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AssociateServiceRoleToAccountInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the service role to associate with IoT Greengrass for your Amazon Web Services account in this Amazon Web Services Region.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        roleArn: Swift.String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

public struct AssociateServiceRoleToAccountOutput: Swift.Sendable {
    /// The time when the service role was associated with IoT Greengrass for your Amazon Web Services account in this Amazon Web Services Region.
    public var associatedAt: Swift.String?

    public init(
        associatedAt: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
    }
}

/// The requested resource can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that isn't found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that isn't found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Your request exceeded a request rate quota. For example, you might have exceeded the amount of times that you can retrieve device or deployment status per second.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var quotaCode: Swift.String? = nil
        /// The amount of time to wait before you retry the request.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// The code for the service in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

public struct BatchAssociateClientDeviceWithCoreDeviceInput: Swift.Sendable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The list of client devices to associate.
    public var entries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry]?

    public init(
        coreDeviceThingName: Swift.String? = nil,
        entries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry]? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.entries = entries
    }
}

public struct BatchAssociateClientDeviceWithCoreDeviceOutput: Swift.Sendable {
    /// The list of any errors for the entries in the request. Each error entry contains the name of the IoT thing that failed to associate.
    public var errorEntries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry]?

    public init(
        errorEntries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

extension GreengrassV2ClientTypes {

    /// Contains a request to disassociate a client device from a core device. The [BatchDisassociateClientDeviceWithCoreDevice](https://docs.aws.amazon.com/greengrass/v2/APIReference/API_BatchDisassociateClientDeviceWithCoreDevice.html) operation consumes a list of these requests.
    public struct DisassociateClientDeviceFromCoreDeviceEntry: Swift.Sendable {
        /// The name of the IoT thing that represents the client device to disassociate.
        /// This member is required.
        public var thingName: Swift.String?

        public init(
            thingName: Swift.String? = nil
        )
        {
            self.thingName = thingName
        }
    }
}

public struct BatchDisassociateClientDeviceFromCoreDeviceInput: Swift.Sendable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The list of client devices to disassociate.
    public var entries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry]?

    public init(
        coreDeviceThingName: Swift.String? = nil,
        entries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry]? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.entries = entries
    }
}

extension GreengrassV2ClientTypes {

    /// Contains an error that occurs from a request to disassociate a client device from a core device. The [BatchDisassociateClientDeviceWithCoreDevice](https://docs.aws.amazon.com/greengrass/v2/APIReference/API_BatchDisassociateClientDeviceWithCoreDevice.html) operation returns a list of these errors.
    public struct DisassociateClientDeviceFromCoreDeviceErrorEntry: Swift.Sendable {
        /// The error code for the request.
        public var code: Swift.String?
        /// A message that provides additional information about the error.
        public var message: Swift.String?
        /// The name of the IoT thing whose disassociate request failed.
        public var thingName: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.thingName = thingName
        }
    }
}

public struct BatchDisassociateClientDeviceFromCoreDeviceOutput: Swift.Sendable {
    /// The list of any errors for the entries in the request. Each error entry contains the name of the IoT thing that failed to disassociate.
    public var errorEntries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry]?

    public init(
        errorEntries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

/// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that conflicts with the request.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that conflicts with the request.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

public struct CancelDeploymentInput: Swift.Sendable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

public struct CancelDeploymentOutput: Swift.Sendable {
    /// A message that communicates if the cancel was successful.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension GreengrassV2ClientTypes {

    public enum CloudComponentState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deployable
        case deprecated
        case failed
        case initiated
        case requested
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudComponentState] {
            return [
                .deployable,
                .deprecated,
                .failed,
                .initiated,
                .requested
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deployable: return "DEPLOYABLE"
            case .deprecated: return "DEPRECATED"
            case .failed: return "FAILED"
            case .initiated: return "INITIATED"
            case .requested: return "REQUESTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum VendorGuidance: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case discontinued
        case sdkUnknown(Swift.String)

        public static var allCases: [VendorGuidance] {
            return [
                .active,
                .deleted,
                .discontinued
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .discontinued: return "DISCONTINUED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains the status of a component version in the IoT Greengrass service.
    public struct CloudComponentStatus: Swift.Sendable {
        /// The state of the component version.
        public var componentState: GreengrassV2ClientTypes.CloudComponentState?
        /// A dictionary of errors that communicate why the component version is in an error state. For example, if IoT Greengrass can't access an artifact for the component version, then errors contains the artifact's URI as a key, and the error message as the value for that key.
        public var errors: [Swift.String: Swift.String]?
        /// A message that communicates details, such as errors, about the status of the component version.
        public var message: Swift.String?
        /// The vendor guidance state for the component version. This state indicates whether the component version has any issues that you should consider before you deploy it. The vendor guidance state can be:
        ///
        /// * ACTIVE – This component version is available and recommended for use.
        ///
        /// * DISCONTINUED – This component version has been discontinued by its publisher. You can deploy this component version, but we recommend that you use a different version of this component.
        ///
        /// * DELETED – This component version has been deleted by its publisher, so you can't deploy it. If you have any existing deployments that specify this component version, those deployments will fail.
        public var vendorGuidance: GreengrassV2ClientTypes.VendorGuidance?
        /// A message that communicates details about the vendor guidance state of the component version. This message communicates why a component version is discontinued or deleted.
        public var vendorGuidanceMessage: Swift.String?

        public init(
            componentState: GreengrassV2ClientTypes.CloudComponentState? = nil,
            errors: [Swift.String: Swift.String]? = nil,
            message: Swift.String? = nil,
            vendorGuidance: GreengrassV2ClientTypes.VendorGuidance? = nil,
            vendorGuidanceMessage: Swift.String? = nil
        )
        {
            self.componentState = componentState
            self.errors = errors
            self.message = message
            self.vendorGuidance = vendorGuidance
            self.vendorGuidanceMessage = vendorGuidanceMessage
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a platform that a component supports.
    public struct ComponentPlatform: Swift.Sendable {
        /// A dictionary of attributes for the platform. The IoT Greengrass Core software defines the os and architecture by default. You can specify additional platform attributes for a core device when you deploy the Greengrass nucleus component. For more information, see the [Greengrass nucleus component](https://docs.aws.amazon.com/greengrass/v2/developerguide/greengrass-nucleus-component.html) in the IoT Greengrass V2 Developer Guide.
        public var attributes: [Swift.String: Swift.String]?
        /// The friendly name of the platform. This name helps you identify the platform. If you omit this parameter, IoT Greengrass creates a friendly name from the os and architecture of the platform.
        public var name: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.name = name
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about the latest version of a component.
    public struct ComponentLatestVersion: Swift.Sendable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
        public var arn: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// The time at which the component was created, expressed in ISO 8601 format.
        public var creationTimestamp: Foundation.Date?
        /// The description of the component version.
        public var description: Swift.String?
        /// The platforms that the component version supports.
        public var platforms: [GreengrassV2ClientTypes.ComponentPlatform]?
        /// The publisher of the component version.
        public var publisher: Swift.String?

        public init(
            arn: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            creationTimestamp: Foundation.Date? = nil,
            description: Swift.String? = nil,
            platforms: [GreengrassV2ClientTypes.ComponentPlatform]? = nil,
            publisher: Swift.String? = nil
        )
        {
            self.arn = arn
            self.componentVersion = componentVersion
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.platforms = platforms
            self.publisher = publisher
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a component.
    public struct Component: Swift.Sendable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
        public var arn: Swift.String?
        /// The name of the component.
        public var componentName: Swift.String?
        /// The latest version of the component and its details.
        public var latestVersion: GreengrassV2ClientTypes.ComponentLatestVersion?

        public init(
            arn: Swift.String? = nil,
            componentName: Swift.String? = nil,
            latestVersion: GreengrassV2ClientTypes.ComponentLatestVersion? = nil
        )
        {
            self.arn = arn
            self.componentName = componentName
            self.latestVersion = latestVersion
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a component that is a candidate to deploy to a Greengrass core device.
    public struct ComponentCandidate: Swift.Sendable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// The version requirements for the component's dependencies. Greengrass core devices get the version requirements from component recipes. IoT Greengrass V2 uses semantic version constraints. For more information, see [Semantic Versioning](https://semver.org/).
        public var versionRequirements: [Swift.String: Swift.String]?

        public init(
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            versionRequirements: [Swift.String: Swift.String]? = nil
        )
        {
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.versionRequirements = versionRequirements
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a deployment's update to a component's configuration on Greengrass core devices. For more information, see [Update component configurations](https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html) in the IoT Greengrass V2 Developer Guide.
    public struct ComponentConfigurationUpdate: Swift.Sendable {
        /// A serialized JSON string that contains the configuration object to merge to target devices. The core device merges this configuration with the component's existing configuration. If this is the first time a component deploys on a device, the core device merges this configuration with the component's default configuration. This means that the core device keeps it's existing configuration for keys and values that you don't specify in this object. For more information, see [Merge configuration updates](https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html#merge-configuration-update) in the IoT Greengrass V2 Developer Guide.
        public var merge: Swift.String?
        /// The list of configuration nodes to reset to default values on target devices. Use JSON pointers to specify each node to reset. JSON pointers start with a forward slash (/) and use forward slashes to separate the key for each level in the object. For more information, see the [JSON pointer specification](https://tools.ietf.org/html/rfc6901) and [Reset configuration updates](https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html#reset-configuration-update) in the IoT Greengrass V2 Developer Guide.
        public var reset: [Swift.String]?

        public init(
            merge: Swift.String? = nil,
            reset: [Swift.String]? = nil
        )
        {
            self.merge = merge
            self.reset = reset
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum ComponentDependencyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hard
        case soft
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentDependencyType] {
            return [
                .hard,
                .soft
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hard: return "HARD"
            case .soft: return "SOFT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a component dependency for a Lambda function component.
    public struct ComponentDependencyRequirement: Swift.Sendable {
        /// The type of this dependency. Choose from the following options:
        ///
        /// * SOFT – The component doesn't restart if the dependency changes state.
        ///
        /// * HARD – The component restarts if the dependency changes state.
        ///
        ///
        /// Default: HARD
        public var dependencyType: GreengrassV2ClientTypes.ComponentDependencyType?
        /// The component version requirement for the component dependency. IoT Greengrass V2 uses semantic version constraints. For more information, see [Semantic Versioning](https://semver.org/).
        public var versionRequirement: Swift.String?

        public init(
            dependencyType: GreengrassV2ClientTypes.ComponentDependencyType? = nil,
            versionRequirement: Swift.String? = nil
        )
        {
            self.dependencyType = dependencyType
            self.versionRequirement = versionRequirement
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about system resource limits that the IoT Greengrass Core software applies to a component's processes. For more information, see [Configure system resource limits for components](https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-system-resource-limits).
    public struct SystemResourceLimits: Swift.Sendable {
        /// The maximum amount of CPU time that a component's processes can use on the core device. A core device's total CPU time is equivalent to the device's number of CPU cores. For example, on a core device with 4 CPU cores, you can set this value to 2 to limit the component's processes to 50 percent usage of each CPU core. On a device with 1 CPU core, you can set this value to 0.25 to limit the component's processes to 25 percent usage of the CPU. If you set this value to a number greater than the number of CPU cores, the IoT Greengrass Core software doesn't limit the component's CPU usage.
        public var cpus: Swift.Double
        /// The maximum amount of RAM, expressed in kilobytes, that a component's processes can use on the core device.
        public var memory: Swift.Int

        public init(
            cpus: Swift.Double = 0.0,
            memory: Swift.Int = 0
        )
        {
            self.cpus = cpus
            self.memory = memory
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information system user and group that the IoT Greengrass Core software uses to run component processes on the core device. For more information, see [Configure the user and group that run components](https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-user) in the IoT Greengrass V2 Developer Guide.
    public struct ComponentRunWith: Swift.Sendable {
        /// The POSIX system user and, optionally, group to use to run this component on Linux core devices. The user, and group if specified, must exist on each Linux core device. Specify the user and group separated by a colon (:) in the following format: user:group. The group is optional. If you don't specify a group, the IoT Greengrass Core software uses the primary user for the group. If you omit this parameter, the IoT Greengrass Core software uses the default system user and group that you configure on the Greengrass nucleus component. For more information, see [Configure the user and group that run components](https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-user).
        public var posixUser: Swift.String?
        /// The system resource limits to apply to this component's process on the core device. IoT Greengrass currently supports this feature on only Linux core devices. If you omit this parameter, the IoT Greengrass Core software uses the default system resource limits that you configure on the Greengrass nucleus component. For more information, see [Configure system resource limits for components](https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-system-resource-limits).
        public var systemResourceLimits: GreengrassV2ClientTypes.SystemResourceLimits?
        /// The Windows user to use to run this component on Windows core devices. The user must exist on each Windows core device, and its name and password must be in the LocalSystem account's Credentials Manager instance. If you omit this parameter, the IoT Greengrass Core software uses the default Windows user that you configure on the Greengrass nucleus component. For more information, see [Configure the user and group that run components](https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-user).
        public var windowsUser: Swift.String?

        public init(
            posixUser: Swift.String? = nil,
            systemResourceLimits: GreengrassV2ClientTypes.SystemResourceLimits? = nil,
            windowsUser: Swift.String? = nil
        )
        {
            self.posixUser = posixUser
            self.systemResourceLimits = systemResourceLimits
            self.windowsUser = windowsUser
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a component to deploy.
    public struct ComponentDeploymentSpecification: Swift.Sendable {
        /// The version of the component.
        /// This member is required.
        public var componentVersion: Swift.String?
        /// The configuration updates to deploy for the component. You can define reset updates and merge updates. A reset updates the keys that you specify to the default configuration for the component. A merge updates the core device's component configuration with the keys and values that you specify. The IoT Greengrass Core software applies reset updates before it applies merge updates. For more information, see [Update component configurations](https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html) in the IoT Greengrass V2 Developer Guide.
        public var configurationUpdate: GreengrassV2ClientTypes.ComponentConfigurationUpdate?
        /// The system user and group that the IoT Greengrass Core software uses to run component processes on the core device. If you omit this parameter, the IoT Greengrass Core software uses the system user and group that you configure for the core device. For more information, see [Configure the user and group that run components](https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-user) in the IoT Greengrass V2 Developer Guide.
        public var runWith: GreengrassV2ClientTypes.ComponentRunWith?

        public init(
            componentVersion: Swift.String? = nil,
            configurationUpdate: GreengrassV2ClientTypes.ComponentConfigurationUpdate? = nil,
            runWith: GreengrassV2ClientTypes.ComponentRunWith? = nil
        )
        {
            self.componentVersion = componentVersion
            self.configurationUpdate = configurationUpdate
            self.runWith = runWith
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a component version in a list.
    public struct ComponentVersionListItem: Swift.Sendable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
        public var arn: Swift.String?
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.componentName = componentName
            self.componentVersion = componentVersion
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum ComponentVisibilityScope: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentVisibilityScope] {
            return [
                .private,
                .public
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about an endpoint and port where client devices can connect to an MQTT broker on a Greengrass core device.
    public struct ConnectivityInfo: Swift.Sendable {
        /// The IP address or DNS address where client devices can connect to an MQTT broker on the Greengrass core device.
        public var hostAddress: Swift.String?
        /// An ID for the connectivity information.
        public var id: Swift.String?
        /// Additional metadata to provide to client devices that connect to this core device.
        public var metadata: Swift.String?
        /// The port where the MQTT broker operates on the core device. This port is typically 8883, which is the default port for the MQTT broker component that runs on core devices.
        public var portNumber: Swift.Int

        public init(
            hostAddress: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: Swift.String? = nil,
            portNumber: Swift.Int = 0
        )
        {
            self.hostAddress = hostAddress
            self.id = id
            self.metadata = metadata
            self.portNumber = portNumber
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum CoreDeviceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [CoreDeviceStatus] {
            return [
                .healthy,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a Greengrass core device, which is an IoT thing that runs the IoT Greengrass Core software.
    public struct CoreDevice: Swift.Sendable {
        /// The name of the core device. This is also the name of the IoT thing.
        public var coreDeviceThingName: Swift.String?
        /// The time at which the core device's status last updated, expressed in ISO 8601 format.
        public var lastStatusUpdateTimestamp: Foundation.Date?
        /// The status of the core device. Core devices can have the following statuses:
        ///
        /// * HEALTHY – The IoT Greengrass Core software and all components run on the core device without issue.
        ///
        /// * UNHEALTHY – The IoT Greengrass Core software or a component is in a failed state on the core device.
        public var status: GreengrassV2ClientTypes.CoreDeviceStatus?

        public init(
            coreDeviceThingName: Swift.String? = nil,
            lastStatusUpdateTimestamp: Foundation.Date? = nil,
            status: GreengrassV2ClientTypes.CoreDeviceStatus? = nil
        )
        {
            self.coreDeviceThingName = coreDeviceThingName
            self.lastStatusUpdateTimestamp = lastStatusUpdateTimestamp
            self.status = status
        }
    }
}

/// The request is already in progress. This exception occurs when you use a client token for multiple requests while IoT Greengrass is still processing an earlier request that uses the same client token.
public struct RequestAlreadyInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestAlreadyInProgressException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request exceeds a service quota. For example, you might have the maximum number of components that you can create.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource that exceeds the service quota.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that exceeds the service quota.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code for the service in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension GreengrassV2ClientTypes {

    public enum LambdaEventSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iotCore
        case pubSub
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaEventSourceType] {
            return [
                .iotCore,
                .pubSub
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iotCore: return "IOT_CORE"
            case .pubSub: return "PUB_SUB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about an event source for an Lambda function. The event source defines the topics on which this Lambda function subscribes to receive messages that run the function.
    public struct LambdaEventSource: Swift.Sendable {
        /// The topic to which to subscribe to receive event messages.
        /// This member is required.
        public var topic: Swift.String?
        /// The type of event source. Choose from the following options:
        ///
        /// * PUB_SUB – Subscribe to local publish/subscribe messages. This event source type doesn't support MQTT wildcards (+ and #) in the event source topic.
        ///
        /// * IOT_CORE – Subscribe to Amazon Web Services IoT Core MQTT messages. This event source type supports MQTT wildcards (+ and #) in the event source topic.
        /// This member is required.
        public var type: GreengrassV2ClientTypes.LambdaEventSourceType?

        public init(
            topic: Swift.String? = nil,
            type: GreengrassV2ClientTypes.LambdaEventSourceType? = nil
        )
        {
            self.topic = topic
            self.type = type
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum LambdaInputPayloadEncodingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case binary
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaInputPayloadEncodingType] {
            return [
                .binary,
                .json
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .binary: return "binary"
            case .json: return "json"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum LambdaFilesystemPermission: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ro
        case rw
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaFilesystemPermission] {
            return [
                .ro,
                .rw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ro: return "ro"
            case .rw: return "rw"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a device that Linux processes in a container can access.
    public struct LambdaDeviceMount: Swift.Sendable {
        /// Whether or not to add the component's system user as an owner of the device. Default: false
        public var addGroupOwner: Swift.Bool?
        /// The mount path for the device in the file system.
        /// This member is required.
        public var path: Swift.String?
        /// The permission to access the device: read/only (ro) or read/write (rw). Default: ro
        public var permission: GreengrassV2ClientTypes.LambdaFilesystemPermission?

        public init(
            addGroupOwner: Swift.Bool? = false,
            path: Swift.String? = nil,
            permission: GreengrassV2ClientTypes.LambdaFilesystemPermission? = nil
        )
        {
            self.addGroupOwner = addGroupOwner
            self.path = path
            self.permission = permission
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a volume that Linux processes in a container can access. When you define a volume, the IoT Greengrass Core software mounts the source files to the destination inside the container.
    public struct LambdaVolumeMount: Swift.Sendable {
        /// Whether or not to add the IoT Greengrass user group as an owner of the volume. Default: false
        public var addGroupOwner: Swift.Bool?
        /// The path to the logical volume in the file system.
        /// This member is required.
        public var destinationPath: Swift.String?
        /// The permission to access the volume: read/only (ro) or read/write (rw). Default: ro
        public var permission: GreengrassV2ClientTypes.LambdaFilesystemPermission?
        /// The path to the physical volume in the file system.
        /// This member is required.
        public var sourcePath: Swift.String?

        public init(
            addGroupOwner: Swift.Bool? = false,
            destinationPath: Swift.String? = nil,
            permission: GreengrassV2ClientTypes.LambdaFilesystemPermission? = nil,
            sourcePath: Swift.String? = nil
        )
        {
            self.addGroupOwner = addGroupOwner
            self.destinationPath = destinationPath
            self.permission = permission
            self.sourcePath = sourcePath
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a container in which Lambda functions run on Greengrass core devices.
    public struct LambdaContainerParams: Swift.Sendable {
        /// The list of system devices that the container can access.
        public var devices: [GreengrassV2ClientTypes.LambdaDeviceMount]?
        /// The memory size of the container, expressed in kilobytes. Default: 16384 (16 MB)
        public var memorySizeInKB: Swift.Int?
        /// Whether or not the container can read information from the device's /sys folder. Default: false
        public var mountROSysfs: Swift.Bool?
        /// The list of volumes that the container can access.
        public var volumes: [GreengrassV2ClientTypes.LambdaVolumeMount]?

        public init(
            devices: [GreengrassV2ClientTypes.LambdaDeviceMount]? = nil,
            memorySizeInKB: Swift.Int? = 0,
            mountROSysfs: Swift.Bool? = false,
            volumes: [GreengrassV2ClientTypes.LambdaVolumeMount]? = nil
        )
        {
            self.devices = devices
            self.memorySizeInKB = memorySizeInKB
            self.mountROSysfs = mountROSysfs
            self.volumes = volumes
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum LambdaIsolationMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case greengrassContainer
        case noContainer
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaIsolationMode] {
            return [
                .greengrassContainer,
                .noContainer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .greengrassContainer: return "GreengrassContainer"
            case .noContainer: return "NoContainer"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains parameters for a Linux process that contains an Lambda function.
    public struct LambdaLinuxProcessParams: Swift.Sendable {
        /// The parameters for the container in which the Lambda function runs.
        public var containerParams: GreengrassV2ClientTypes.LambdaContainerParams?
        /// The isolation mode for the process that contains the Lambda function. The process can run in an isolated runtime environment inside the IoT Greengrass container, or as a regular process outside any container. Default: GreengrassContainer
        public var isolationMode: GreengrassV2ClientTypes.LambdaIsolationMode?

        public init(
            containerParams: GreengrassV2ClientTypes.LambdaContainerParams? = nil,
            isolationMode: GreengrassV2ClientTypes.LambdaIsolationMode? = nil
        )
        {
            self.containerParams = containerParams
            self.isolationMode = isolationMode
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains parameters for a Lambda function that runs on IoT Greengrass.
    public struct LambdaExecutionParameters: Swift.Sendable {
        /// The map of environment variables that are available to the Lambda function when it runs.
        public var environmentVariables: [Swift.String: Swift.String]?
        /// The list of event sources to which to subscribe to receive work messages. The Lambda function runs when it receives a message from an event source. You can subscribe this function to local publish/subscribe messages and Amazon Web Services IoT Core MQTT messages.
        public var eventSources: [GreengrassV2ClientTypes.LambdaEventSource]?
        /// The list of arguments to pass to the Lambda function when it runs.
        public var execArgs: [Swift.String]?
        /// The encoding type that the Lambda function supports. Default: json
        public var inputPayloadEncodingType: GreengrassV2ClientTypes.LambdaInputPayloadEncodingType?
        /// The parameters for the Linux process that contains the Lambda function.
        public var linuxProcessParams: GreengrassV2ClientTypes.LambdaLinuxProcessParams?
        /// The maximum amount of time in seconds that a non-pinned Lambda function can idle before the IoT Greengrass Core software stops its process.
        public var maxIdleTimeInSeconds: Swift.Int?
        /// The maximum number of instances that a non-pinned Lambda function can run at the same time.
        public var maxInstancesCount: Swift.Int?
        /// The maximum size of the message queue for the Lambda function component. The IoT Greengrass core stores messages in a FIFO (first-in-first-out) queue until it can run the Lambda function to consume each message.
        public var maxQueueSize: Swift.Int?
        /// Whether or not the Lambda function is pinned, or long-lived.
        ///
        /// * A pinned Lambda function starts when IoT Greengrass starts and keeps running in its own container.
        ///
        /// * A non-pinned Lambda function starts only when it receives a work item and exists after it idles for maxIdleTimeInSeconds. If the function has multiple work items, the IoT Greengrass Core software creates multiple instances of the function.
        ///
        ///
        /// Default: true
        public var pinned: Swift.Bool?
        /// The interval in seconds at which a pinned (also known as long-lived) Lambda function component sends status updates to the Lambda manager component.
        public var statusTimeoutInSeconds: Swift.Int?
        /// The maximum amount of time in seconds that the Lambda function can process a work item.
        public var timeoutInSeconds: Swift.Int?

        public init(
            environmentVariables: [Swift.String: Swift.String]? = nil,
            eventSources: [GreengrassV2ClientTypes.LambdaEventSource]? = nil,
            execArgs: [Swift.String]? = nil,
            inputPayloadEncodingType: GreengrassV2ClientTypes.LambdaInputPayloadEncodingType? = nil,
            linuxProcessParams: GreengrassV2ClientTypes.LambdaLinuxProcessParams? = nil,
            maxIdleTimeInSeconds: Swift.Int? = 0,
            maxInstancesCount: Swift.Int? = 0,
            maxQueueSize: Swift.Int? = 0,
            pinned: Swift.Bool? = false,
            statusTimeoutInSeconds: Swift.Int? = 0,
            timeoutInSeconds: Swift.Int? = 0
        )
        {
            self.environmentVariables = environmentVariables
            self.eventSources = eventSources
            self.execArgs = execArgs
            self.inputPayloadEncodingType = inputPayloadEncodingType
            self.linuxProcessParams = linuxProcessParams
            self.maxIdleTimeInSeconds = maxIdleTimeInSeconds
            self.maxInstancesCount = maxInstancesCount
            self.maxQueueSize = maxQueueSize
            self.pinned = pinned
            self.statusTimeoutInSeconds = statusTimeoutInSeconds
            self.timeoutInSeconds = timeoutInSeconds
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about an Lambda function to import to create a component.
    public struct LambdaFunctionRecipeSource: Swift.Sendable {
        /// The component versions on which this Lambda function component depends.
        public var componentDependencies: [Swift.String: GreengrassV2ClientTypes.ComponentDependencyRequirement]?
        /// The system and runtime parameters for the Lambda function as it runs on the Greengrass core device.
        public var componentLambdaParameters: GreengrassV2ClientTypes.LambdaExecutionParameters?
        /// The name of the component. Defaults to the name of the Lambda function.
        public var componentName: Swift.String?
        /// The platforms that the component version supports.
        public var componentPlatforms: [GreengrassV2ClientTypes.ComponentPlatform]?
        /// The version of the component. Defaults to the version of the Lambda function as a semantic version. For example, if your function version is 3, the component version becomes 3.0.0.
        public var componentVersion: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Lambda function. The ARN must include the version of the function to import. You can't use version aliases like $LATEST.
        /// This member is required.
        public var lambdaArn: Swift.String?

        public init(
            componentDependencies: [Swift.String: GreengrassV2ClientTypes.ComponentDependencyRequirement]? = nil,
            componentLambdaParameters: GreengrassV2ClientTypes.LambdaExecutionParameters? = nil,
            componentName: Swift.String? = nil,
            componentPlatforms: [GreengrassV2ClientTypes.ComponentPlatform]? = nil,
            componentVersion: Swift.String? = nil,
            lambdaArn: Swift.String? = nil
        )
        {
            self.componentDependencies = componentDependencies
            self.componentLambdaParameters = componentLambdaParameters
            self.componentName = componentName
            self.componentPlatforms = componentPlatforms
            self.componentVersion = componentVersion
            self.lambdaArn = lambdaArn
        }
    }
}

public struct CreateComponentVersionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you can provide to ensure that the request is idempotent. Idempotency means that the request is successfully processed only once, even if you send the request multiple times. When a request succeeds, and you specify the same client token for subsequent successful requests, the IoT Greengrass V2 service returns the successful response that it caches from the previous request. IoT Greengrass V2 caches successful responses for idempotent requests for up to 8 hours.
    public var clientToken: Swift.String?
    /// The recipe to use to create the component. The recipe defines the component's metadata, parameters, dependencies, lifecycle, artifacts, and platform compatibility. You must specify either inlineRecipe or lambdaFunction.
    public var inlineRecipe: Foundation.Data?
    /// The parameters to create a component from a Lambda function. You must specify either inlineRecipe or lambdaFunction.
    public var lambdaFunction: GreengrassV2ClientTypes.LambdaFunctionRecipeSource?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        inlineRecipe: Foundation.Data? = nil,
        lambdaFunction: GreengrassV2ClientTypes.LambdaFunctionRecipeSource? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.inlineRecipe = inlineRecipe
        self.lambdaFunction = lambdaFunction
        self.tags = tags
    }
}

public struct CreateComponentVersionOutput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
    public var arn: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The version of the component.
    /// This member is required.
    public var componentVersion: Swift.String?
    /// The time at which the component was created, expressed in ISO 8601 format.
    /// This member is required.
    public var creationTimestamp: Foundation.Date?
    /// The status of the component version in IoT Greengrass V2. This status is different from the status of the component on a core device.
    /// This member is required.
    public var status: GreengrassV2ClientTypes.CloudComponentStatus?

    public init(
        arn: Swift.String? = nil,
        componentName: Swift.String? = nil,
        componentVersion: Swift.String? = nil,
        creationTimestamp: Foundation.Date? = nil,
        status: GreengrassV2ClientTypes.CloudComponentStatus? = nil
    )
    {
        self.arn = arn
        self.componentName = componentName
        self.componentVersion = componentVersion
        self.creationTimestamp = creationTimestamp
        self.status = status
    }
}

extension GreengrassV2ClientTypes {

    public enum DeploymentComponentUpdatePolicyAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notifyComponents
        case skipNotifyComponents
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentComponentUpdatePolicyAction] {
            return [
                .notifyComponents,
                .skipNotifyComponents
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notifyComponents: return "NOTIFY_COMPONENTS"
            case .skipNotifyComponents: return "SKIP_NOTIFY_COMPONENTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a deployment's policy that defines when components are safe to update. Each component on a device can report whether or not it's ready to update. After a component and its dependencies are ready, they can apply the update in the deployment. You can configure whether or not the deployment notifies components of an update and waits for a response. You specify the amount of time each component has to respond to the update notification.
    public struct DeploymentComponentUpdatePolicy: Swift.Sendable {
        /// Whether or not to notify components and wait for components to become safe to update. Choose from the following options:
        ///
        /// * NOTIFY_COMPONENTS – The deployment notifies each component before it stops and updates that component. Components can use the [SubscribeToComponentUpdates](https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-subscribetocomponentupdates) IPC operation to receive these notifications. Then, components can respond with the [DeferComponentUpdate](https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-defercomponentupdate) IPC operation. For more information, see [Create deployments](https://docs.aws.amazon.com/greengrass/v2/developerguide/create-deployments.html) in the IoT Greengrass V2 Developer Guide.
        ///
        /// * SKIP_NOTIFY_COMPONENTS – The deployment doesn't notify components or wait for them to be safe to update.
        ///
        ///
        /// Default: NOTIFY_COMPONENTS
        public var action: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicyAction?
        /// The amount of time in seconds that each component on a device has to report that it's safe to update. If the component waits for longer than this timeout, then the deployment proceeds on the device. Default: 60
        public var timeoutInSeconds: Swift.Int?

        public init(
            action: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicyAction? = nil,
            timeoutInSeconds: Swift.Int? = 0
        )
        {
            self.action = action
            self.timeoutInSeconds = timeoutInSeconds
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about how long a component on a core device can validate its configuration updates before it times out. Components can use the [SubscribeToValidateConfigurationUpdates](https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-subscribetovalidateconfigurationupdates) IPC operation to receive notifications when a deployment specifies a configuration update. Then, components can respond with the [SendConfigurationValidityReport](https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-sendconfigurationvalidityreport) IPC operation. For more information, see [Create deployments](https://docs.aws.amazon.com/greengrass/v2/developerguide/create-deployments.html) in the IoT Greengrass V2 Developer Guide.
    public struct DeploymentConfigurationValidationPolicy: Swift.Sendable {
        /// The amount of time in seconds that a component can validate its configuration updates. If the validation time exceeds this timeout, then the deployment proceeds for the device. Default: 30
        public var timeoutInSeconds: Swift.Int?

        public init(
            timeoutInSeconds: Swift.Int? = 0
        )
        {
            self.timeoutInSeconds = timeoutInSeconds
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum DeploymentFailureHandlingPolicy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case doNothing
        case rollback
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentFailureHandlingPolicy] {
            return [
                .doNothing,
                .rollback
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .doNothing: return "DO_NOTHING"
            case .rollback: return "ROLLBACK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about policies that define how a deployment updates components and handles failure.
    public struct DeploymentPolicies: Swift.Sendable {
        /// The component update policy for the configuration deployment. This policy defines when it's safe to deploy the configuration to devices.
        public var componentUpdatePolicy: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy?
        /// The configuration validation policy for the configuration deployment. This policy defines how long each component has to validate its configure updates.
        public var configurationValidationPolicy: GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy?
        /// The failure handling policy for the configuration deployment. This policy defines what to do if the deployment fails. Default: ROLLBACK
        public var failureHandlingPolicy: GreengrassV2ClientTypes.DeploymentFailureHandlingPolicy?

        public init(
            componentUpdatePolicy: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy? = nil,
            configurationValidationPolicy: GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy? = nil,
            failureHandlingPolicy: GreengrassV2ClientTypes.DeploymentFailureHandlingPolicy? = nil
        )
        {
            self.componentUpdatePolicy = componentUpdatePolicy
            self.configurationValidationPolicy = configurationValidationPolicy
            self.failureHandlingPolicy = failureHandlingPolicy
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum IoTJobAbortAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancel
        case sdkUnknown(Swift.String)

        public static var allCases: [IoTJobAbortAction] {
            return [
                .cancel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum IoTJobExecutionFailureType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case failed
        case rejected
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [IoTJobExecutionFailureType] {
            return [
                .all,
                .failed,
                .rejected,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .rejected: return "REJECTED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains criteria that define when and how to cancel a job. The deployment stops if the following conditions are true:
    ///
    /// * The number of things that receive the deployment exceeds the minNumberOfExecutedThings.
    ///
    /// * The percentage of failures with type failureType exceeds the thresholdPercentage.
    public struct IoTJobAbortCriteria: Swift.Sendable {
        /// The action to perform when the criteria are met.
        /// This member is required.
        public var action: GreengrassV2ClientTypes.IoTJobAbortAction?
        /// The type of job deployment failure that can cancel a job.
        /// This member is required.
        public var failureType: GreengrassV2ClientTypes.IoTJobExecutionFailureType?
        /// The minimum number of things that receive the configuration before the job can cancel.
        /// This member is required.
        public var minNumberOfExecutedThings: Swift.Int?
        /// The minimum percentage of failureType failures that occur before the job can cancel. This parameter supports up to two digits after the decimal (for example, you can specify 10.9 or 10.99, but not 10.999).
        /// This member is required.
        public var thresholdPercentage: Swift.Double

        public init(
            action: GreengrassV2ClientTypes.IoTJobAbortAction? = nil,
            failureType: GreengrassV2ClientTypes.IoTJobExecutionFailureType? = nil,
            minNumberOfExecutedThings: Swift.Int? = nil,
            thresholdPercentage: Swift.Double = 0.0
        )
        {
            self.action = action
            self.failureType = failureType
            self.minNumberOfExecutedThings = minNumberOfExecutedThings
            self.thresholdPercentage = thresholdPercentage
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains a list of criteria that define when and how to cancel a configuration deployment.
    public struct IoTJobAbortConfig: Swift.Sendable {
        /// The list of criteria that define when and how to cancel the configuration deployment.
        /// This member is required.
        public var criteriaList: [GreengrassV2ClientTypes.IoTJobAbortCriteria]?

        public init(
            criteriaList: [GreengrassV2ClientTypes.IoTJobAbortCriteria]? = nil
        )
        {
            self.criteriaList = criteriaList
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about criteria to meet before a job increases its rollout rate. Specify either numberOfNotifiedThings or numberOfSucceededThings.
    public struct IoTJobRateIncreaseCriteria: Swift.Sendable {
        /// The number of devices to receive the job notification before the rollout rate increases.
        public var numberOfNotifiedThings: Swift.Int?
        /// The number of devices to successfully run the configuration job before the rollout rate increases.
        public var numberOfSucceededThings: Swift.Int?

        public init(
            numberOfNotifiedThings: Swift.Int? = nil,
            numberOfSucceededThings: Swift.Int? = nil
        )
        {
            self.numberOfNotifiedThings = numberOfNotifiedThings
            self.numberOfSucceededThings = numberOfSucceededThings
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about an exponential rollout rate for a configuration deployment job.
    public struct IoTJobExponentialRolloutRate: Swift.Sendable {
        /// The minimum number of devices that receive a pending job notification, per minute, when the job starts. This parameter defines the initial rollout rate of the job.
        /// This member is required.
        public var baseRatePerMinute: Swift.Int?
        /// The exponential factor to increase the rollout rate for the job. This parameter supports up to one digit after the decimal (for example, you can specify 1.5, but not 1.55).
        /// This member is required.
        public var incrementFactor: Swift.Double?
        /// The criteria to increase the rollout rate for the job.
        /// This member is required.
        public var rateIncreaseCriteria: GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria?

        public init(
            baseRatePerMinute: Swift.Int? = nil,
            incrementFactor: Swift.Double? = nil,
            rateIncreaseCriteria: GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria? = nil
        )
        {
            self.baseRatePerMinute = baseRatePerMinute
            self.incrementFactor = incrementFactor
            self.rateIncreaseCriteria = rateIncreaseCriteria
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about the rollout configuration for a job. This configuration defines the rate at which the job deploys a configuration to a fleet of target devices.
    public struct IoTJobExecutionsRolloutConfig: Swift.Sendable {
        /// The exponential rate to increase the job rollout rate.
        public var exponentialRate: GreengrassV2ClientTypes.IoTJobExponentialRolloutRate?
        /// The maximum number of devices that receive a pending job notification, per minute.
        public var maximumPerMinute: Swift.Int?

        public init(
            exponentialRate: GreengrassV2ClientTypes.IoTJobExponentialRolloutRate? = nil,
            maximumPerMinute: Swift.Int? = nil
        )
        {
            self.exponentialRate = exponentialRate
            self.maximumPerMinute = maximumPerMinute
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about the timeout configuration for a job.
    public struct IoTJobTimeoutConfig: Swift.Sendable {
        /// The amount of time, in minutes, that devices have to complete the job. The timer starts when the job status is set to IN_PROGRESS. If the job status doesn't change to a terminal state before the time expires, then the job status is set to TIMED_OUT. The timeout interval must be between 1 minute and 7 days (10080 minutes).
        public var inProgressTimeoutInMinutes: Swift.Int?

        public init(
            inProgressTimeoutInMinutes: Swift.Int? = 0
        )
        {
            self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about an IoT job configuration.
    public struct DeploymentIoTJobConfiguration: Swift.Sendable {
        /// The stop configuration for the job. This configuration defines when and how to stop a job rollout.
        public var abortConfig: GreengrassV2ClientTypes.IoTJobAbortConfig?
        /// The rollout configuration for the job. This configuration defines the rate at which the job rolls out to the fleet of target devices.
        public var jobExecutionsRolloutConfig: GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig?
        /// The timeout configuration for the job. This configuration defines the amount of time each device has to complete the job.
        public var timeoutConfig: GreengrassV2ClientTypes.IoTJobTimeoutConfig?

        public init(
            abortConfig: GreengrassV2ClientTypes.IoTJobAbortConfig? = nil,
            jobExecutionsRolloutConfig: GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig? = nil,
            timeoutConfig: GreengrassV2ClientTypes.IoTJobTimeoutConfig? = nil
        )
        {
            self.abortConfig = abortConfig
            self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
            self.timeoutConfig = timeoutConfig
        }
    }
}

public struct CreateDeploymentInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you can provide to ensure that the request is idempotent. Idempotency means that the request is successfully processed only once, even if you send the request multiple times. When a request succeeds, and you specify the same client token for subsequent successful requests, the IoT Greengrass V2 service returns the successful response that it caches from the previous request. IoT Greengrass V2 caches successful responses for idempotent requests for up to 8 hours.
    public var clientToken: Swift.String?
    /// The components to deploy. This is a dictionary, where each key is the name of a component, and each key's value is the version and configuration to deploy for that component.
    public var components: [Swift.String: GreengrassV2ClientTypes.ComponentDeploymentSpecification]?
    /// The name of the deployment.
    public var deploymentName: Swift.String?
    /// The deployment policies for the deployment. These policies define how the deployment updates components and handles failure.
    public var deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies?
    /// The job configuration for the deployment configuration. The job configuration specifies the rollout, timeout, and stop configurations for the deployment configuration.
    public var iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration?
    /// The parent deployment's target [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) within a subdeployment.
    public var parentTargetArn: Swift.String?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String: Swift.String]?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the target IoT thing or thing group. When creating a subdeployment, the targetARN can only be a thing group.
    /// This member is required.
    public var targetArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        components: [Swift.String: GreengrassV2ClientTypes.ComponentDeploymentSpecification]? = nil,
        deploymentName: Swift.String? = nil,
        deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies? = nil,
        iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration? = nil,
        parentTargetArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.components = components
        self.deploymentName = deploymentName
        self.deploymentPolicies = deploymentPolicies
        self.iotJobConfiguration = iotJobConfiguration
        self.parentTargetArn = parentTargetArn
        self.tags = tags
        self.targetArn = targetArn
    }
}

public struct CreateDeploymentOutput: Swift.Sendable {
    /// The ID of the deployment.
    public var deploymentId: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IoT job that applies the deployment to target devices.
    public var iotJobArn: Swift.String?
    /// The ID of the IoT job that applies the deployment to target devices.
    public var iotJobId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        iotJobArn: Swift.String? = nil,
        iotJobId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.iotJobArn = iotJobArn
        self.iotJobId = iotJobId
    }
}

public struct DeleteComponentInput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteCoreDeviceInput: Swift.Sendable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?

    public init(
        coreDeviceThingName: Swift.String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
    }
}

public struct DeleteDeploymentInput: Swift.Sendable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

extension GreengrassV2ClientTypes {

    public enum DeploymentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case canceled
        case completed
        case failed
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .active,
                .canceled,
                .completed,
                .failed,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a deployment.
    public struct Deployment: Swift.Sendable {
        /// The time at which the deployment was created, expressed in ISO 8601 format.
        public var creationTimestamp: Foundation.Date?
        /// The ID of the deployment.
        public var deploymentId: Swift.String?
        /// The name of the deployment.
        public var deploymentName: Swift.String?
        /// The status of the deployment.
        public var deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus?
        /// Whether or not the deployment is the latest revision for its target.
        public var isLatestForTarget: Swift.Bool
        /// The parent deployment's target [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) within a subdeployment.
        public var parentTargetArn: Swift.String?
        /// The revision number of the deployment.
        public var revisionId: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the target IoT thing or thing group. When creating a subdeployment, the targetARN can only be a thing group.
        public var targetArn: Swift.String?

        public init(
            creationTimestamp: Foundation.Date? = nil,
            deploymentId: Swift.String? = nil,
            deploymentName: Swift.String? = nil,
            deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus? = nil,
            isLatestForTarget: Swift.Bool = false,
            parentTargetArn: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.deploymentId = deploymentId
            self.deploymentName = deploymentName
            self.deploymentStatus = deploymentStatus
            self.isLatestForTarget = isLatestForTarget
            self.parentTargetArn = parentTargetArn
            self.revisionId = revisionId
            self.targetArn = targetArn
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum DeploymentHistoryFilter: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case latestOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentHistoryFilter] {
            return [
                .all,
                .latestOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .latestOnly: return "LATEST_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeComponentInput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DescribeComponentOutput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
    public var arn: Swift.String?
    /// The name of the component.
    public var componentName: Swift.String?
    /// The version of the component.
    public var componentVersion: Swift.String?
    /// The time at which the component was created, expressed in ISO 8601 format.
    public var creationTimestamp: Foundation.Date?
    /// The description of the component version.
    public var description: Swift.String?
    /// The platforms that the component version supports.
    public var platforms: [GreengrassV2ClientTypes.ComponentPlatform]?
    /// The publisher of the component version.
    public var publisher: Swift.String?
    /// The status of the component version in IoT Greengrass V2. This status is different from the status of the component on a core device.
    public var status: GreengrassV2ClientTypes.CloudComponentStatus?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        componentName: Swift.String? = nil,
        componentVersion: Swift.String? = nil,
        creationTimestamp: Foundation.Date? = nil,
        description: Swift.String? = nil,
        platforms: [GreengrassV2ClientTypes.ComponentPlatform]? = nil,
        publisher: Swift.String? = nil,
        status: GreengrassV2ClientTypes.CloudComponentStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.componentName = componentName
        self.componentVersion = componentVersion
        self.creationTimestamp = creationTimestamp
        self.description = description
        self.platforms = platforms
        self.publisher = publisher
        self.status = status
        self.tags = tags
    }
}

public struct DisassociateServiceRoleFromAccountInput: Swift.Sendable {

    public init() { }
}

public struct DisassociateServiceRoleFromAccountOutput: Swift.Sendable {
    /// The time when the service role was disassociated from IoT Greengrass for your Amazon Web Services account in this Amazon Web Services Region.
    public var disassociatedAt: Swift.String?

    public init(
        disassociatedAt: Swift.String? = nil
    )
    {
        self.disassociatedAt = disassociatedAt
    }
}

extension GreengrassV2ClientTypes {

    public enum EffectiveDeploymentExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case inProgress
        case queued
        case rejected
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [EffectiveDeploymentExecutionStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .inProgress,
                .queued,
                .rejected,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .rejected: return "REJECTED"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains all error-related information for the deployment record. The status details will be null if the deployment is in a success state. Greengrass nucleus v2.8.0 or later is required to get an accurate errorStack and errorTypes response. This field will not be returned for earlier Greengrass nucleus versions.
    public struct EffectiveDeploymentStatusDetails: Swift.Sendable {
        /// Contains an ordered list of short error codes that range from the most generic error to the most specific one. The error codes describe the reason for failure whenever the coreDeviceExecutionStatus is in a failed state. The response will be an empty list if there is no error.
        public var errorStack: [Swift.String]?
        /// Contains tags which describe the error. You can use the error types to classify errors to assist with remediating the failure. The response will be an empty list if there is no error.
        public var errorTypes: [Swift.String]?

        public init(
            errorStack: [Swift.String]? = nil,
            errorTypes: [Swift.String]? = nil
        )
        {
            self.errorStack = errorStack
            self.errorTypes = errorTypes
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a deployment job that IoT Greengrass sends to a Greengrass core device.
    public struct EffectiveDeployment: Swift.Sendable {
        /// The status of the deployment job on the Greengrass core device.
        ///
        /// * IN_PROGRESS – The deployment job is running.
        ///
        /// * QUEUED – The deployment job is in the job queue and waiting to run.
        ///
        /// * FAILED – The deployment failed. For more information, see the statusDetails field.
        ///
        /// * COMPLETED – The deployment to an IoT thing was completed successfully.
        ///
        /// * TIMED_OUT – The deployment didn't complete in the allotted time.
        ///
        /// * CANCELED – The deployment was canceled by the user.
        ///
        /// * REJECTED – The deployment was rejected. For more information, see the statusDetails field.
        ///
        /// * SUCCEEDED – The deployment to an IoT thing group was completed successfully.
        /// This member is required.
        public var coreDeviceExecutionStatus: GreengrassV2ClientTypes.EffectiveDeploymentExecutionStatus?
        /// The time at which the deployment was created, expressed in ISO 8601 format.
        /// This member is required.
        public var creationTimestamp: Foundation.Date?
        /// The ID of the deployment.
        /// This member is required.
        public var deploymentId: Swift.String?
        /// The name of the deployment.
        /// This member is required.
        public var deploymentName: Swift.String?
        /// The description of the deployment job.
        public var description: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IoT job that applies the deployment to target devices.
        public var iotJobArn: Swift.String?
        /// The ID of the IoT job that applies the deployment to target devices.
        public var iotJobId: Swift.String?
        /// The time at which the deployment job was last modified, expressed in ISO 8601 format.
        /// This member is required.
        public var modifiedTimestamp: Foundation.Date?
        /// The reason code for the update, if the job was updated.
        public var reason: Swift.String?
        /// The status details that explain why a deployment has an error. This response will be null if the deployment is in a success state.
        public var statusDetails: GreengrassV2ClientTypes.EffectiveDeploymentStatusDetails?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the target IoT thing or thing group.
        /// This member is required.
        public var targetArn: Swift.String?

        public init(
            coreDeviceExecutionStatus: GreengrassV2ClientTypes.EffectiveDeploymentExecutionStatus? = nil,
            creationTimestamp: Foundation.Date? = nil,
            deploymentId: Swift.String? = nil,
            deploymentName: Swift.String? = nil,
            description: Swift.String? = nil,
            iotJobArn: Swift.String? = nil,
            iotJobId: Swift.String? = nil,
            modifiedTimestamp: Foundation.Date? = nil,
            reason: Swift.String? = nil,
            statusDetails: GreengrassV2ClientTypes.EffectiveDeploymentStatusDetails? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.coreDeviceExecutionStatus = coreDeviceExecutionStatus
            self.creationTimestamp = creationTimestamp
            self.deploymentId = deploymentId
            self.deploymentName = deploymentName
            self.description = description
            self.iotJobArn = iotJobArn
            self.iotJobId = iotJobId
            self.modifiedTimestamp = modifiedTimestamp
            self.reason = reason
            self.statusDetails = statusDetails
            self.targetArn = targetArn
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum RecipeOutputFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case yaml
        case sdkUnknown(Swift.String)

        public static var allCases: [RecipeOutputFormat] {
            return [
                .json,
                .yaml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .yaml: return "YAML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetComponentInput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
    /// This member is required.
    public var arn: Swift.String?
    /// The format of the recipe.
    public var recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat?

    public init(
        arn: Swift.String? = nil,
        recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat? = nil
    )
    {
        self.arn = arn
        self.recipeOutputFormat = recipeOutputFormat
    }
}

public struct GetComponentOutput: Swift.Sendable {
    /// The recipe of the component version.
    /// This member is required.
    public var recipe: Foundation.Data?
    /// The format of the recipe.
    /// This member is required.
    public var recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        recipe: Foundation.Data? = nil,
        recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.recipe = recipe
        self.recipeOutputFormat = recipeOutputFormat
        self.tags = tags
    }
}

extension GreengrassV2ClientTypes {

    public enum IotEndpointType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fips
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [IotEndpointType] {
            return [
                .fips,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fips: return "fips"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    public enum S3EndpointType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case global
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [S3EndpointType] {
            return [
                .global,
                .regional
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .global: return "GLOBAL"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetComponentVersionArtifactInput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version. Specify the ARN of a public or a Lambda component version.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the artifact. You can use the [GetComponent](https://docs.aws.amazon.com/greengrass/v2/APIReference/API_GetComponent.html) operation to download the component recipe, which includes the URI of the artifact. The artifact name is the section of the URI after the scheme. For example, in the artifact URI greengrass:SomeArtifact.zip, the artifact name is SomeArtifact.zip.
    /// This member is required.
    public var artifactName: Swift.String?
    /// Determines if the Amazon S3 URL returned is a FIPS pre-signed URL endpoint. Specify fips if you want the returned Amazon S3 pre-signed URL to point to an Amazon S3 FIPS endpoint. If you don't specify a value, the default is standard.
    public var iotEndpointType: GreengrassV2ClientTypes.IotEndpointType?
    /// Specifies the endpoint to use when getting Amazon S3 pre-signed URLs. All Amazon Web Services Regions except US East (N. Virginia) use REGIONAL in all cases. In the US East (N. Virginia) Region the default is GLOBAL, but you can change it to REGIONAL with this parameter.
    public var s3EndpointType: GreengrassV2ClientTypes.S3EndpointType?

    public init(
        arn: Swift.String? = nil,
        artifactName: Swift.String? = nil,
        iotEndpointType: GreengrassV2ClientTypes.IotEndpointType? = nil,
        s3EndpointType: GreengrassV2ClientTypes.S3EndpointType? = nil
    )
    {
        self.arn = arn
        self.artifactName = artifactName
        self.iotEndpointType = iotEndpointType
        self.s3EndpointType = s3EndpointType
    }
}

public struct GetComponentVersionArtifactOutput: Swift.Sendable {
    /// The URL of the artifact.
    /// This member is required.
    public var preSignedUrl: Swift.String?

    public init(
        preSignedUrl: Swift.String? = nil
    )
    {
        self.preSignedUrl = preSignedUrl
    }
}

public struct GetConnectivityInfoInput: Swift.Sendable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        thingName: Swift.String? = nil
    )
    {
        self.thingName = thingName
    }
}

public struct GetConnectivityInfoOutput: Swift.Sendable {
    /// The connectivity information for the core device.
    public var connectivityInfo: [GreengrassV2ClientTypes.ConnectivityInfo]?
    /// A message about the connectivity information request.
    public var message: Swift.String?

    public init(
        connectivityInfo: [GreengrassV2ClientTypes.ConnectivityInfo]? = nil,
        message: Swift.String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.message = message
    }
}

public struct GetCoreDeviceInput: Swift.Sendable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?

    public init(
        coreDeviceThingName: Swift.String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
    }
}

public struct GetCoreDeviceOutput: Swift.Sendable {
    /// The computer architecture of the core device.
    public var architecture: Swift.String?
    /// The name of the core device. This is also the name of the IoT thing.
    public var coreDeviceThingName: Swift.String?
    /// The version of the IoT Greengrass Core software that the core device runs. This version is equivalent to the version of the Greengrass nucleus component that runs on the core device. For more information, see the [Greengrass nucleus component](https://docs.aws.amazon.com/greengrass/v2/developerguide/greengrass-nucleus-component.html) in the IoT Greengrass V2 Developer Guide.
    public var coreVersion: Swift.String?
    /// The time at which the core device's status last updated, expressed in ISO 8601 format.
    public var lastStatusUpdateTimestamp: Foundation.Date?
    /// The operating system platform that the core device runs.
    public var platform: Swift.String?
    /// The status of the core device. The core device status can be:
    ///
    /// * HEALTHY – The IoT Greengrass Core software and all components run on the core device without issue.
    ///
    /// * UNHEALTHY – The IoT Greengrass Core software or a component is in a failed state on the core device.
    public var status: GreengrassV2ClientTypes.CoreDeviceStatus?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        architecture: Swift.String? = nil,
        coreDeviceThingName: Swift.String? = nil,
        coreVersion: Swift.String? = nil,
        lastStatusUpdateTimestamp: Foundation.Date? = nil,
        platform: Swift.String? = nil,
        status: GreengrassV2ClientTypes.CoreDeviceStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.coreDeviceThingName = coreDeviceThingName
        self.coreVersion = coreVersion
        self.lastStatusUpdateTimestamp = lastStatusUpdateTimestamp
        self.platform = platform
        self.status = status
        self.tags = tags
    }
}

public struct GetDeploymentInput: Swift.Sendable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

public struct GetDeploymentOutput: Swift.Sendable {
    /// The components to deploy. This is a dictionary, where each key is the name of a component, and each key's value is the version and configuration to deploy for that component.
    public var components: [Swift.String: GreengrassV2ClientTypes.ComponentDeploymentSpecification]?
    /// The time at which the deployment was created, expressed in ISO 8601 format.
    public var creationTimestamp: Foundation.Date?
    /// The ID of the deployment.
    public var deploymentId: Swift.String?
    /// The name of the deployment.
    public var deploymentName: Swift.String?
    /// The deployment policies for the deployment. These policies define how the deployment updates components and handles failure.
    public var deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies?
    /// The status of the deployment.
    public var deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IoT job that applies the deployment to target devices.
    public var iotJobArn: Swift.String?
    /// The job configuration for the deployment configuration. The job configuration specifies the rollout, timeout, and stop configurations for the deployment configuration.
    public var iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration?
    /// The ID of the IoT job that applies the deployment to target devices.
    public var iotJobId: Swift.String?
    /// Whether or not the deployment is the latest revision for its target.
    public var isLatestForTarget: Swift.Bool
    /// The parent deployment's target [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) within a subdeployment.
    public var parentTargetArn: Swift.String?
    /// The revision number of the deployment.
    public var revisionId: Swift.String?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String: Swift.String]?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the target IoT thing or thing group.
    public var targetArn: Swift.String?

    public init(
        components: [Swift.String: GreengrassV2ClientTypes.ComponentDeploymentSpecification]? = nil,
        creationTimestamp: Foundation.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentName: Swift.String? = nil,
        deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies? = nil,
        deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus? = nil,
        iotJobArn: Swift.String? = nil,
        iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration? = nil,
        iotJobId: Swift.String? = nil,
        isLatestForTarget: Swift.Bool = false,
        parentTargetArn: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.components = components
        self.creationTimestamp = creationTimestamp
        self.deploymentId = deploymentId
        self.deploymentName = deploymentName
        self.deploymentPolicies = deploymentPolicies
        self.deploymentStatus = deploymentStatus
        self.iotJobArn = iotJobArn
        self.iotJobConfiguration = iotJobConfiguration
        self.iotJobId = iotJobId
        self.isLatestForTarget = isLatestForTarget
        self.parentTargetArn = parentTargetArn
        self.revisionId = revisionId
        self.tags = tags
        self.targetArn = targetArn
    }
}

public struct GetServiceRoleForAccountInput: Swift.Sendable {

    public init() { }
}

public struct GetServiceRoleForAccountOutput: Swift.Sendable {
    /// The time when the service role was associated with IoT Greengrass for your Amazon Web Services account in this Amazon Web Services Region.
    public var associatedAt: Swift.String?
    /// The ARN of the service role that is associated with IoT Greengrass for your Amazon Web Services account in this Amazon Web Services Region.
    public var roleArn: Swift.String?

    public init(
        associatedAt: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
        self.roleArn = roleArn
    }
}

public struct ListClientDevicesAssociatedWithCoreDeviceInput: Swift.Sendable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        coreDeviceThingName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListClientDevicesAssociatedWithCoreDeviceOutput: Swift.Sendable {
    /// A list that describes the client devices that are associated with the core device.
    public var associatedClientDevices: [GreengrassV2ClientTypes.AssociatedClientDevice]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        associatedClientDevices: [GreengrassV2ClientTypes.AssociatedClientDevice]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associatedClientDevices = associatedClientDevices
        self.nextToken = nextToken
    }
}

public struct ListComponentsInput: Swift.Sendable {
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The scope of the components to list. Default: PRIVATE
    public var scope: GreengrassV2ClientTypes.ComponentVisibilityScope?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        scope: GreengrassV2ClientTypes.ComponentVisibilityScope? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scope = scope
    }
}

public struct ListComponentsOutput: Swift.Sendable {
    /// A list that summarizes each component.
    public var components: [GreengrassV2ClientTypes.Component]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        components: [GreengrassV2ClientTypes.Component]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.components = components
        self.nextToken = nextToken
    }
}

public struct ListComponentVersionsInput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component.
    /// This member is required.
    public var arn: Swift.String?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListComponentVersionsOutput: Swift.Sendable {
    /// A list of versions that exist for the component.
    public var componentVersions: [GreengrassV2ClientTypes.ComponentVersionListItem]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        componentVersions: [GreengrassV2ClientTypes.ComponentVersionListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentVersions = componentVersions
        self.nextToken = nextToken
    }
}

public struct ListCoreDevicesInput: Swift.Sendable {
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The core device status by which to filter. If you specify this parameter, the list includes only core devices that have this status. Choose one of the following options:
    ///
    /// * HEALTHY – The IoT Greengrass Core software and all components run on the core device without issue.
    ///
    /// * UNHEALTHY – The IoT Greengrass Core software or a component is in a failed state on the core device.
    public var status: GreengrassV2ClientTypes.CoreDeviceStatus?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IoT thing group by which to filter. If you specify this parameter, the list includes only core devices that have successfully deployed a deployment that targets the thing group. When you remove a core device from a thing group, the list continues to include that core device.
    public var thingGroupArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: GreengrassV2ClientTypes.CoreDeviceStatus? = nil,
        thingGroupArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.thingGroupArn = thingGroupArn
    }
}

public struct ListCoreDevicesOutput: Swift.Sendable {
    /// A list that summarizes each core device.
    public var coreDevices: [GreengrassV2ClientTypes.CoreDevice]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        coreDevices: [GreengrassV2ClientTypes.CoreDevice]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDevices = coreDevices
        self.nextToken = nextToken
    }
}

public struct ListDeploymentsInput: Swift.Sendable {
    /// The filter for the list of deployments. Choose one of the following options:
    ///
    /// * ALL – The list includes all deployments.
    ///
    /// * LATEST_ONLY – The list includes only the latest revision of each deployment.
    ///
    ///
    /// Default: LATEST_ONLY
    public var historyFilter: GreengrassV2ClientTypes.DeploymentHistoryFilter?
    /// The maximum number of results to be returned per paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The parent deployment's target [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) within a subdeployment.
    public var parentTargetArn: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the target IoT thing or thing group.
    public var targetArn: Swift.String?

    public init(
        historyFilter: GreengrassV2ClientTypes.DeploymentHistoryFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parentTargetArn: Swift.String? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.historyFilter = historyFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parentTargetArn = parentTargetArn
        self.targetArn = targetArn
    }
}

public struct ListDeploymentsOutput: Swift.Sendable {
    /// A list that summarizes each deployment.
    public var deployments: [GreengrassV2ClientTypes.Deployment]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deployments: [GreengrassV2ClientTypes.Deployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

public struct ListEffectiveDeploymentsInput: Swift.Sendable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        coreDeviceThingName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListEffectiveDeploymentsOutput: Swift.Sendable {
    /// A list that summarizes each deployment on the core device.
    public var effectiveDeployments: [GreengrassV2ClientTypes.EffectiveDeployment]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        effectiveDeployments: [GreengrassV2ClientTypes.EffectiveDeployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.effectiveDeployments = effectiveDeployments
        self.nextToken = nextToken
    }
}

extension GreengrassV2ClientTypes {

    public enum InstalledComponentTopologyFilter: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case root
        case sdkUnknown(Swift.String)

        public static var allCases: [InstalledComponentTopologyFilter] {
            return [
                .all,
                .root
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .root: return "ROOT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListInstalledComponentsInput: Swift.Sendable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The filter for the list of components. Choose from the following options:
    ///
    /// * ALL – The list includes all components installed on the core device.
    ///
    /// * ROOT – The list includes only root components, which are components that you specify in a deployment. When you choose this option, the list doesn't include components that the core device installs as dependencies of other components.
    ///
    ///
    /// Default: ROOT
    public var topologyFilter: GreengrassV2ClientTypes.InstalledComponentTopologyFilter?

    public init(
        coreDeviceThingName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        topologyFilter: GreengrassV2ClientTypes.InstalledComponentTopologyFilter? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.topologyFilter = topologyFilter
    }
}

extension GreengrassV2ClientTypes {

    public enum InstalledComponentLifecycleState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case broken
        case errored
        case finished
        case installed
        case new
        case running
        case starting
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [InstalledComponentLifecycleState] {
            return [
                .broken,
                .errored,
                .finished,
                .installed,
                .new,
                .running,
                .starting,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .broken: return "BROKEN"
            case .errored: return "ERRORED"
            case .finished: return "FINISHED"
            case .installed: return "INSTALLED"
            case .new: return "NEW"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a component on a Greengrass core device.
    public struct InstalledComponent: Swift.Sendable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// Whether or not the component is a root component.
        public var isRoot: Swift.Bool
        /// The most recent deployment source that brought the component to the Greengrass core device. For a thing group deployment or thing deployment, the source will be the ID of the last deployment that contained the component. For local deployments it will be LOCAL. Any deployment will attempt to reinstall currently broken components on the device, which will update the last installation source.
        public var lastInstallationSource: Swift.String?
        /// The last time the Greengrass core device sent a message containing a component's state to the Amazon Web Services Cloud. A component does not need to see a state change for this field to update.
        public var lastReportedTimestamp: Foundation.Date?
        /// The status of how current the data is. This response is based off of component state changes. The status reflects component disruptions and deployments. If a component only sees a configuration update during a deployment, it might not undergo a state change and this status would not be updated.
        public var lastStatusChangeTimestamp: Foundation.Date?
        /// The lifecycle state of the component.
        public var lifecycleState: GreengrassV2ClientTypes.InstalledComponentLifecycleState?
        /// A detailed response about the lifecycle state of the component that explains the reason why a component has an error or is broken.
        public var lifecycleStateDetails: Swift.String?
        /// The status codes that indicate the reason for failure whenever the lifecycleState has an error or is in a broken state. Greengrass nucleus v2.8.0 or later is required to get an accurate lifecycleStatusCodes response. This response can be inaccurate in earlier Greengrass nucleus versions.
        public var lifecycleStatusCodes: [Swift.String]?

        public init(
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            isRoot: Swift.Bool = false,
            lastInstallationSource: Swift.String? = nil,
            lastReportedTimestamp: Foundation.Date? = nil,
            lastStatusChangeTimestamp: Foundation.Date? = nil,
            lifecycleState: GreengrassV2ClientTypes.InstalledComponentLifecycleState? = nil,
            lifecycleStateDetails: Swift.String? = nil,
            lifecycleStatusCodes: [Swift.String]? = nil
        )
        {
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.isRoot = isRoot
            self.lastInstallationSource = lastInstallationSource
            self.lastReportedTimestamp = lastReportedTimestamp
            self.lastStatusChangeTimestamp = lastStatusChangeTimestamp
            self.lifecycleState = lifecycleState
            self.lifecycleStateDetails = lifecycleStateDetails
            self.lifecycleStatusCodes = lifecycleStatusCodes
        }
    }
}

public struct ListInstalledComponentsOutput: Swift.Sendable {
    /// A list that summarizes each component on the core device. Greengrass nucleus v2.7.0 or later is required to get an accurate lastStatusChangeTimestamp response. This response can be inaccurate in earlier Greengrass nucleus versions. Greengrass nucleus v2.8.0 or later is required to get an accurate lastInstallationSource and lastReportedTimestamp response. This response can be inaccurate or null in earlier Greengrass nucleus versions.
    public var installedComponents: [GreengrassV2ClientTypes.InstalledComponent]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        installedComponents: [GreengrassV2ClientTypes.InstalledComponent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.installedComponents = installedComponents
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ResolveComponentCandidatesInput: Swift.Sendable {
    /// The list of components to resolve.
    public var componentCandidates: [GreengrassV2ClientTypes.ComponentCandidate]?
    /// The platform to use to resolve compatible components.
    public var platform: GreengrassV2ClientTypes.ComponentPlatform?

    public init(
        componentCandidates: [GreengrassV2ClientTypes.ComponentCandidate]? = nil,
        platform: GreengrassV2ClientTypes.ComponentPlatform? = nil
    )
    {
        self.componentCandidates = componentCandidates
        self.platform = platform
    }
}

extension GreengrassV2ClientTypes {

    /// Contains information about a component version that is compatible to run on a Greengrass core device.
    public struct ResolvedComponentVersion: Swift.Sendable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
        public var arn: Swift.String?
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// A message that communicates details about the vendor guidance state of the component version. This message communicates why a component version is discontinued or deleted.
        public var message: Swift.String?
        /// The recipe of the component version.
        public var recipe: Foundation.Data?
        /// The vendor guidance state for the component version. This state indicates whether the component version has any issues that you should consider before you deploy it. The vendor guidance state can be:
        ///
        /// * ACTIVE – This component version is available and recommended for use.
        ///
        /// * DISCONTINUED – This component version has been discontinued by its publisher. You can deploy this component version, but we recommend that you use a different version of this component.
        ///
        /// * DELETED – This component version has been deleted by its publisher, so you can't deploy it. If you have any existing deployments that specify this component version, those deployments will fail.
        public var vendorGuidance: GreengrassV2ClientTypes.VendorGuidance?

        public init(
            arn: Swift.String? = nil,
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            message: Swift.String? = nil,
            recipe: Foundation.Data? = nil,
            vendorGuidance: GreengrassV2ClientTypes.VendorGuidance? = nil
        )
        {
            self.arn = arn
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.message = message
            self.recipe = recipe
            self.vendorGuidance = vendorGuidance
        }
    }
}

public struct ResolveComponentCandidatesOutput: Swift.Sendable {
    /// A list of components that meet the requirements that you specify in the request. This list includes each component's recipe that you can use to install the component.
    public var resolvedComponentVersions: [GreengrassV2ClientTypes.ResolvedComponentVersion]?

    public init(
        resolvedComponentVersions: [GreengrassV2ClientTypes.ResolvedComponentVersion]? = nil
    )
    {
        self.resolvedComponentVersions = resolvedComponentVersions
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys for tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateConnectivityInfoInput: Swift.Sendable {
    /// The connectivity information for the core device.
    /// This member is required.
    public var connectivityInfo: [GreengrassV2ClientTypes.ConnectivityInfo]?
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        connectivityInfo: [GreengrassV2ClientTypes.ConnectivityInfo]? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.thingName = thingName
    }
}

public struct UpdateConnectivityInfoOutput: Swift.Sendable {
    /// A message about the connectivity information update request.
    public var message: Swift.String?
    /// The new version of the connectivity information for the core device.
    public var version: Swift.String?

    public init(
        message: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.message = message
        self.version = version
    }
}

extension AssociateServiceRoleToAccountInput {

    static func urlPathProvider(_ value: AssociateServiceRoleToAccountInput) -> Swift.String? {
        return "/greengrass/servicerole"
    }
}

extension BatchAssociateClientDeviceWithCoreDeviceInput {

    static func urlPathProvider(_ value: BatchAssociateClientDeviceWithCoreDeviceInput) -> Swift.String? {
        guard let coreDeviceThingName = value.coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/associateClientDevices"
    }
}

extension BatchDisassociateClientDeviceFromCoreDeviceInput {

    static func urlPathProvider(_ value: BatchDisassociateClientDeviceFromCoreDeviceInput) -> Swift.String? {
        guard let coreDeviceThingName = value.coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/disassociateClientDevices"
    }
}

extension CancelDeploymentInput {

    static func urlPathProvider(_ value: CancelDeploymentInput) -> Swift.String? {
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/greengrass/v2/deployments/\(deploymentId.urlPercentEncoding())/cancel"
    }
}

extension CreateComponentVersionInput {

    static func urlPathProvider(_ value: CreateComponentVersionInput) -> Swift.String? {
        return "/greengrass/v2/createComponentVersion"
    }
}

extension CreateDeploymentInput {

    static func urlPathProvider(_ value: CreateDeploymentInput) -> Swift.String? {
        return "/greengrass/v2/deployments"
    }
}

extension DeleteComponentInput {

    static func urlPathProvider(_ value: DeleteComponentInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/greengrass/v2/components/\(arn.urlPercentEncoding())"
    }
}

extension DeleteCoreDeviceInput {

    static func urlPathProvider(_ value: DeleteCoreDeviceInput) -> Swift.String? {
        guard let coreDeviceThingName = value.coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())"
    }
}

extension DeleteDeploymentInput {

    static func urlPathProvider(_ value: DeleteDeploymentInput) -> Swift.String? {
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/greengrass/v2/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

extension DescribeComponentInput {

    static func urlPathProvider(_ value: DescribeComponentInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/greengrass/v2/components/\(arn.urlPercentEncoding())/metadata"
    }
}

extension DisassociateServiceRoleFromAccountInput {

    static func urlPathProvider(_ value: DisassociateServiceRoleFromAccountInput) -> Swift.String? {
        return "/greengrass/servicerole"
    }
}

extension GetComponentInput {

    static func urlPathProvider(_ value: GetComponentInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/greengrass/v2/components/\(arn.urlPercentEncoding())"
    }
}

extension GetComponentInput {

    static func queryItemProvider(_ value: GetComponentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let recipeOutputFormat = value.recipeOutputFormat {
            let recipeOutputFormatQueryItem = Smithy.URIQueryItem(name: "recipeOutputFormat".urlPercentEncoding(), value: Swift.String(recipeOutputFormat.rawValue).urlPercentEncoding())
            items.append(recipeOutputFormatQueryItem)
        }
        return items
    }
}

extension GetComponentVersionArtifactInput {

    static func urlPathProvider(_ value: GetComponentVersionArtifactInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        guard let artifactName = value.artifactName else {
            return nil
        }
        return "/greengrass/v2/components/\(arn.urlPercentEncoding())/artifacts/\(artifactName.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension GetComponentVersionArtifactInput {

    static func headerProvider(_ value: GetComponentVersionArtifactInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let iotEndpointType = value.iotEndpointType {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-iot-endpoint-type", value: Swift.String(iotEndpointType.rawValue)))
        }
        return items
    }
}

extension GetComponentVersionArtifactInput {

    static func queryItemProvider(_ value: GetComponentVersionArtifactInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let s3EndpointType = value.s3EndpointType {
            let s3EndpointTypeQueryItem = Smithy.URIQueryItem(name: "s3EndpointType".urlPercentEncoding(), value: Swift.String(s3EndpointType.rawValue).urlPercentEncoding())
            items.append(s3EndpointTypeQueryItem)
        }
        return items
    }
}

extension GetConnectivityInfoInput {

    static func urlPathProvider(_ value: GetConnectivityInfoInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/connectivityInfo"
    }
}

extension GetCoreDeviceInput {

    static func urlPathProvider(_ value: GetCoreDeviceInput) -> Swift.String? {
        guard let coreDeviceThingName = value.coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())"
    }
}

extension GetDeploymentInput {

    static func urlPathProvider(_ value: GetDeploymentInput) -> Swift.String? {
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/greengrass/v2/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

extension GetServiceRoleForAccountInput {

    static func urlPathProvider(_ value: GetServiceRoleForAccountInput) -> Swift.String? {
        return "/greengrass/servicerole"
    }
}

extension ListClientDevicesAssociatedWithCoreDeviceInput {

    static func urlPathProvider(_ value: ListClientDevicesAssociatedWithCoreDeviceInput) -> Swift.String? {
        guard let coreDeviceThingName = value.coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/associatedClientDevices"
    }
}

extension ListClientDevicesAssociatedWithCoreDeviceInput {

    static func queryItemProvider(_ value: ListClientDevicesAssociatedWithCoreDeviceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListComponentsInput {

    static func urlPathProvider(_ value: ListComponentsInput) -> Swift.String? {
        return "/greengrass/v2/components"
    }
}

extension ListComponentsInput {

    static func queryItemProvider(_ value: ListComponentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let scope = value.scope {
            let scopeQueryItem = Smithy.URIQueryItem(name: "scope".urlPercentEncoding(), value: Swift.String(scope.rawValue).urlPercentEncoding())
            items.append(scopeQueryItem)
        }
        return items
    }
}

extension ListComponentVersionsInput {

    static func urlPathProvider(_ value: ListComponentVersionsInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/greengrass/v2/components/\(arn.urlPercentEncoding())/versions"
    }
}

extension ListComponentVersionsInput {

    static func queryItemProvider(_ value: ListComponentVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListCoreDevicesInput {

    static func urlPathProvider(_ value: ListCoreDevicesInput) -> Swift.String? {
        return "/greengrass/v2/coreDevices"
    }
}

extension ListCoreDevicesInput {

    static func queryItemProvider(_ value: ListCoreDevicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let thingGroupArn = value.thingGroupArn {
            let thingGroupArnQueryItem = Smithy.URIQueryItem(name: "thingGroupArn".urlPercentEncoding(), value: Swift.String(thingGroupArn).urlPercentEncoding())
            items.append(thingGroupArnQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListDeploymentsInput {

    static func urlPathProvider(_ value: ListDeploymentsInput) -> Swift.String? {
        return "/greengrass/v2/deployments"
    }
}

extension ListDeploymentsInput {

    static func queryItemProvider(_ value: ListDeploymentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let historyFilter = value.historyFilter {
            let historyFilterQueryItem = Smithy.URIQueryItem(name: "historyFilter".urlPercentEncoding(), value: Swift.String(historyFilter.rawValue).urlPercentEncoding())
            items.append(historyFilterQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let parentTargetArn = value.parentTargetArn {
            let parentTargetArnQueryItem = Smithy.URIQueryItem(name: "parentTargetArn".urlPercentEncoding(), value: Swift.String(parentTargetArn).urlPercentEncoding())
            items.append(parentTargetArnQueryItem)
        }
        if let targetArn = value.targetArn {
            let targetArnQueryItem = Smithy.URIQueryItem(name: "targetArn".urlPercentEncoding(), value: Swift.String(targetArn).urlPercentEncoding())
            items.append(targetArnQueryItem)
        }
        return items
    }
}

extension ListEffectiveDeploymentsInput {

    static func urlPathProvider(_ value: ListEffectiveDeploymentsInput) -> Swift.String? {
        guard let coreDeviceThingName = value.coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/effectiveDeployments"
    }
}

extension ListEffectiveDeploymentsInput {

    static func queryItemProvider(_ value: ListEffectiveDeploymentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListInstalledComponentsInput {

    static func urlPathProvider(_ value: ListInstalledComponentsInput) -> Swift.String? {
        guard let coreDeviceThingName = value.coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/installedComponents"
    }
}

extension ListInstalledComponentsInput {

    static func queryItemProvider(_ value: ListInstalledComponentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let topologyFilter = value.topologyFilter {
            let topologyFilterQueryItem = Smithy.URIQueryItem(name: "topologyFilter".urlPercentEncoding(), value: Swift.String(topologyFilter.rawValue).urlPercentEncoding())
            items.append(topologyFilterQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ResolveComponentCandidatesInput {

    static func urlPathProvider(_ value: ResolveComponentCandidatesInput) -> Swift.String? {
        return "/greengrass/v2/resolveComponentCandidates"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateConnectivityInfoInput {

    static func urlPathProvider(_ value: UpdateConnectivityInfoInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/connectivityInfo"
    }
}

extension AssociateServiceRoleToAccountInput {

    static func write(value: AssociateServiceRoleToAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoleArn"].write(value.roleArn)
    }
}

extension BatchAssociateClientDeviceWithCoreDeviceInput {

    static func write(value: BatchAssociateClientDeviceWithCoreDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entries"].writeList(value.entries, memberWritingClosure: GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDisassociateClientDeviceFromCoreDeviceInput {

    static func write(value: BatchDisassociateClientDeviceFromCoreDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entries"].writeList(value.entries, memberWritingClosure: GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateComponentVersionInput {

    static func write(value: CreateComponentVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["inlineRecipe"].write(value.inlineRecipe)
        try writer["lambdaFunction"].write(value.lambdaFunction, with: GreengrassV2ClientTypes.LambdaFunctionRecipeSource.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDeploymentInput {

    static func write(value: CreateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["components"].writeMap(value.components, valueWritingClosure: GreengrassV2ClientTypes.ComponentDeploymentSpecification.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["deploymentName"].write(value.deploymentName)
        try writer["deploymentPolicies"].write(value.deploymentPolicies, with: GreengrassV2ClientTypes.DeploymentPolicies.write(value:to:))
        try writer["iotJobConfiguration"].write(value.iotJobConfiguration, with: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration.write(value:to:))
        try writer["parentTargetArn"].write(value.parentTargetArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targetArn"].write(value.targetArn)
    }
}

extension ResolveComponentCandidatesInput {

    static func write(value: ResolveComponentCandidatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentCandidates"].writeList(value.componentCandidates, memberWritingClosure: GreengrassV2ClientTypes.ComponentCandidate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["platform"].write(value.platform, with: GreengrassV2ClientTypes.ComponentPlatform.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateConnectivityInfoInput {

    static func write(value: UpdateConnectivityInfoInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectivityInfo"].writeList(value.connectivityInfo, memberWritingClosure: GreengrassV2ClientTypes.ConnectivityInfo.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateServiceRoleToAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateServiceRoleToAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateServiceRoleToAccountOutput()
        value.associatedAt = try reader["AssociatedAt"].readIfPresent()
        return value
    }
}

extension BatchAssociateClientDeviceWithCoreDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchAssociateClientDeviceWithCoreDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchAssociateClientDeviceWithCoreDeviceOutput()
        value.errorEntries = try reader["errorEntries"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDisassociateClientDeviceFromCoreDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDisassociateClientDeviceFromCoreDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDisassociateClientDeviceFromCoreDeviceOutput()
        value.errorEntries = try reader["errorEntries"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CancelDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelDeploymentOutput()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension CreateComponentVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateComponentVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateComponentVersionOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.componentName = try reader["componentName"].readIfPresent() ?? ""
        value.componentVersion = try reader["componentVersion"].readIfPresent() ?? ""
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent(with: GreengrassV2ClientTypes.CloudComponentStatus.read(from:))
        return value
    }
}

extension CreateDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeploymentOutput()
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.iotJobArn = try reader["iotJobArn"].readIfPresent()
        value.iotJobId = try reader["iotJobId"].readIfPresent()
        return value
    }
}

extension DeleteComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteComponentOutput {
        return DeleteComponentOutput()
    }
}

extension DeleteCoreDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCoreDeviceOutput {
        return DeleteCoreDeviceOutput()
    }
}

extension DeleteDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDeploymentOutput {
        return DeleteDeploymentOutput()
    }
}

extension DescribeComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeComponentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeComponentOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.componentName = try reader["componentName"].readIfPresent()
        value.componentVersion = try reader["componentVersion"].readIfPresent()
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.platforms = try reader["platforms"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.ComponentPlatform.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.publisher = try reader["publisher"].readIfPresent()
        value.status = try reader["status"].readIfPresent(with: GreengrassV2ClientTypes.CloudComponentStatus.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DisassociateServiceRoleFromAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateServiceRoleFromAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateServiceRoleFromAccountOutput()
        value.disassociatedAt = try reader["DisassociatedAt"].readIfPresent()
        return value
    }
}

extension GetComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetComponentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetComponentOutput()
        value.recipe = try reader["recipe"].readIfPresent() ?? Foundation.Data("".utf8)
        value.recipeOutputFormat = try reader["recipeOutputFormat"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetComponentVersionArtifactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetComponentVersionArtifactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetComponentVersionArtifactOutput()
        value.preSignedUrl = try reader["preSignedUrl"].readIfPresent() ?? ""
        return value
    }
}

extension GetConnectivityInfoOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectivityInfoOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectivityInfoOutput()
        value.connectivityInfo = try reader["ConnectivityInfo"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.ConnectivityInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension GetCoreDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCoreDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCoreDeviceOutput()
        value.architecture = try reader["architecture"].readIfPresent()
        value.coreDeviceThingName = try reader["coreDeviceThingName"].readIfPresent()
        value.coreVersion = try reader["coreVersion"].readIfPresent()
        value.lastStatusUpdateTimestamp = try reader["lastStatusUpdateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.platform = try reader["platform"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeploymentOutput()
        value.components = try reader["components"].readMapIfPresent(valueReadingClosure: GreengrassV2ClientTypes.ComponentDeploymentSpecification.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.deploymentName = try reader["deploymentName"].readIfPresent()
        value.deploymentPolicies = try reader["deploymentPolicies"].readIfPresent(with: GreengrassV2ClientTypes.DeploymentPolicies.read(from:))
        value.deploymentStatus = try reader["deploymentStatus"].readIfPresent()
        value.iotJobArn = try reader["iotJobArn"].readIfPresent()
        value.iotJobConfiguration = try reader["iotJobConfiguration"].readIfPresent(with: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration.read(from:))
        value.iotJobId = try reader["iotJobId"].readIfPresent()
        value.isLatestForTarget = try reader["isLatestForTarget"].readIfPresent() ?? false
        value.parentTargetArn = try reader["parentTargetArn"].readIfPresent()
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targetArn = try reader["targetArn"].readIfPresent()
        return value
    }
}

extension GetServiceRoleForAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceRoleForAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceRoleForAccountOutput()
        value.associatedAt = try reader["AssociatedAt"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension ListClientDevicesAssociatedWithCoreDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListClientDevicesAssociatedWithCoreDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListClientDevicesAssociatedWithCoreDeviceOutput()
        value.associatedClientDevices = try reader["associatedClientDevices"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.AssociatedClientDevice.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListComponentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListComponentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListComponentsOutput()
        value.components = try reader["components"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.Component.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListComponentVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListComponentVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListComponentVersionsOutput()
        value.componentVersions = try reader["componentVersions"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.ComponentVersionListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCoreDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCoreDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCoreDevicesOutput()
        value.coreDevices = try reader["coreDevices"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.CoreDevice.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDeploymentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeploymentsOutput()
        value.deployments = try reader["deployments"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.Deployment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEffectiveDeploymentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEffectiveDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEffectiveDeploymentsOutput()
        value.effectiveDeployments = try reader["effectiveDeployments"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.EffectiveDeployment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListInstalledComponentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstalledComponentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInstalledComponentsOutput()
        value.installedComponents = try reader["installedComponents"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.InstalledComponent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ResolveComponentCandidatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResolveComponentCandidatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResolveComponentCandidatesOutput()
        value.resolvedComponentVersions = try reader["resolvedComponentVersions"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.ResolvedComponentVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateConnectivityInfoOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectivityInfoOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConnectivityInfoOutput()
        value.message = try reader["Message"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

enum AssociateServiceRoleToAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchAssociateClientDeviceWithCoreDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDisassociateClientDeviceFromCoreDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateComponentVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestAlreadyInProgressException": return try RequestAlreadyInProgressException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "RequestAlreadyInProgressException": return try RequestAlreadyInProgressException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCoreDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateServiceRoleFromAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetComponentVersionArtifactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectivityInfoOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCoreDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceRoleForAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListClientDevicesAssociatedWithCoreDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListComponentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListComponentVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCoreDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeploymentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEffectiveDeploymentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstalledComponentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResolveComponentCandidatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectivityInfoOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fields = try reader["fields"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RequestAlreadyInProgressException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RequestAlreadyInProgressException {
        let reader = baseError.errorBodyReader
        var value = RequestAlreadyInProgressException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry()
        value.thingName = try reader["thingName"].readIfPresent()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry()
        value.thingName = try reader["thingName"].readIfPresent()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension GreengrassV2ClientTypes.CloudComponentStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.CloudComponentStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.CloudComponentStatus()
        value.componentState = try reader["componentState"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.errors = try reader["errors"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vendorGuidance = try reader["vendorGuidance"].readIfPresent()
        value.vendorGuidanceMessage = try reader["vendorGuidanceMessage"].readIfPresent()
        return value
    }
}

extension GreengrassV2ClientTypes.ComponentPlatform {

    static func write(value: GreengrassV2ClientTypes.ComponentPlatform?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.ComponentPlatform {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.ComponentPlatform()
        value.name = try reader["name"].readIfPresent()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GreengrassV2ClientTypes.ConnectivityInfo {

    static func write(value: GreengrassV2ClientTypes.ConnectivityInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HostAddress"].write(value.hostAddress)
        try writer["Id"].write(value.id)
        try writer["Metadata"].write(value.metadata)
        try writer["PortNumber"].write(value.portNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.ConnectivityInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.ConnectivityInfo()
        value.id = try reader["Id"].readIfPresent()
        value.hostAddress = try reader["HostAddress"].readIfPresent()
        value.portNumber = try reader["PortNumber"].readIfPresent() ?? 0
        value.metadata = try reader["Metadata"].readIfPresent()
        return value
    }
}

extension GreengrassV2ClientTypes.ComponentDeploymentSpecification {

    static func write(value: GreengrassV2ClientTypes.ComponentDeploymentSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentVersion"].write(value.componentVersion)
        try writer["configurationUpdate"].write(value.configurationUpdate, with: GreengrassV2ClientTypes.ComponentConfigurationUpdate.write(value:to:))
        try writer["runWith"].write(value.runWith, with: GreengrassV2ClientTypes.ComponentRunWith.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.ComponentDeploymentSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.ComponentDeploymentSpecification()
        value.componentVersion = try reader["componentVersion"].readIfPresent() ?? ""
        value.configurationUpdate = try reader["configurationUpdate"].readIfPresent(with: GreengrassV2ClientTypes.ComponentConfigurationUpdate.read(from:))
        value.runWith = try reader["runWith"].readIfPresent(with: GreengrassV2ClientTypes.ComponentRunWith.read(from:))
        return value
    }
}

extension GreengrassV2ClientTypes.ComponentRunWith {

    static func write(value: GreengrassV2ClientTypes.ComponentRunWith?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["posixUser"].write(value.posixUser)
        try writer["systemResourceLimits"].write(value.systemResourceLimits, with: GreengrassV2ClientTypes.SystemResourceLimits.write(value:to:))
        try writer["windowsUser"].write(value.windowsUser)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.ComponentRunWith {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.ComponentRunWith()
        value.posixUser = try reader["posixUser"].readIfPresent()
        value.systemResourceLimits = try reader["systemResourceLimits"].readIfPresent(with: GreengrassV2ClientTypes.SystemResourceLimits.read(from:))
        value.windowsUser = try reader["windowsUser"].readIfPresent()
        return value
    }
}

extension GreengrassV2ClientTypes.SystemResourceLimits {

    static func write(value: GreengrassV2ClientTypes.SystemResourceLimits?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cpus"].write(value.cpus)
        try writer["memory"].write(value.memory)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.SystemResourceLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.SystemResourceLimits()
        value.memory = try reader["memory"].readIfPresent() ?? 0
        value.cpus = try reader["cpus"].readIfPresent() ?? 0
        return value
    }
}

extension GreengrassV2ClientTypes.ComponentConfigurationUpdate {

    static func write(value: GreengrassV2ClientTypes.ComponentConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["merge"].write(value.merge)
        try writer["reset"].writeList(value.reset, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.ComponentConfigurationUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.ComponentConfigurationUpdate()
        value.merge = try reader["merge"].readIfPresent()
        value.reset = try reader["reset"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassV2ClientTypes.DeploymentPolicies {

    static func write(value: GreengrassV2ClientTypes.DeploymentPolicies?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentUpdatePolicy"].write(value.componentUpdatePolicy, with: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy.write(value:to:))
        try writer["configurationValidationPolicy"].write(value.configurationValidationPolicy, with: GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy.write(value:to:))
        try writer["failureHandlingPolicy"].write(value.failureHandlingPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.DeploymentPolicies {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.DeploymentPolicies()
        value.failureHandlingPolicy = try reader["failureHandlingPolicy"].readIfPresent()
        value.componentUpdatePolicy = try reader["componentUpdatePolicy"].readIfPresent(with: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy.read(from:))
        value.configurationValidationPolicy = try reader["configurationValidationPolicy"].readIfPresent(with: GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy.read(from:))
        return value
    }
}

extension GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy {

    static func write(value: GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["timeoutInSeconds"].write(value.timeoutInSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy()
        value.timeoutInSeconds = try reader["timeoutInSeconds"].readIfPresent()
        return value
    }
}

extension GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy {

    static func write(value: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["timeoutInSeconds"].write(value.timeoutInSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy()
        value.timeoutInSeconds = try reader["timeoutInSeconds"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension GreengrassV2ClientTypes.DeploymentIoTJobConfiguration {

    static func write(value: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["abortConfig"].write(value.abortConfig, with: GreengrassV2ClientTypes.IoTJobAbortConfig.write(value:to:))
        try writer["jobExecutionsRolloutConfig"].write(value.jobExecutionsRolloutConfig, with: GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig.write(value:to:))
        try writer["timeoutConfig"].write(value.timeoutConfig, with: GreengrassV2ClientTypes.IoTJobTimeoutConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.DeploymentIoTJobConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.DeploymentIoTJobConfiguration()
        value.jobExecutionsRolloutConfig = try reader["jobExecutionsRolloutConfig"].readIfPresent(with: GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig.read(from:))
        value.abortConfig = try reader["abortConfig"].readIfPresent(with: GreengrassV2ClientTypes.IoTJobAbortConfig.read(from:))
        value.timeoutConfig = try reader["timeoutConfig"].readIfPresent(with: GreengrassV2ClientTypes.IoTJobTimeoutConfig.read(from:))
        return value
    }
}

extension GreengrassV2ClientTypes.IoTJobTimeoutConfig {

    static func write(value: GreengrassV2ClientTypes.IoTJobTimeoutConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inProgressTimeoutInMinutes"].write(value.inProgressTimeoutInMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.IoTJobTimeoutConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.IoTJobTimeoutConfig()
        value.inProgressTimeoutInMinutes = try reader["inProgressTimeoutInMinutes"].readIfPresent()
        return value
    }
}

extension GreengrassV2ClientTypes.IoTJobAbortConfig {

    static func write(value: GreengrassV2ClientTypes.IoTJobAbortConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["criteriaList"].writeList(value.criteriaList, memberWritingClosure: GreengrassV2ClientTypes.IoTJobAbortCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.IoTJobAbortConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.IoTJobAbortConfig()
        value.criteriaList = try reader["criteriaList"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.IoTJobAbortCriteria.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GreengrassV2ClientTypes.IoTJobAbortCriteria {

    static func write(value: GreengrassV2ClientTypes.IoTJobAbortCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["failureType"].write(value.failureType)
        try writer["minNumberOfExecutedThings"].write(value.minNumberOfExecutedThings)
        try writer["thresholdPercentage"].write(value.thresholdPercentage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.IoTJobAbortCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.IoTJobAbortCriteria()
        value.failureType = try reader["failureType"].readIfPresent() ?? .sdkUnknown("")
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.thresholdPercentage = try reader["thresholdPercentage"].readIfPresent() ?? 0
        value.minNumberOfExecutedThings = try reader["minNumberOfExecutedThings"].readIfPresent() ?? 0
        return value
    }
}

extension GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig {

    static func write(value: GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exponentialRate"].write(value.exponentialRate, with: GreengrassV2ClientTypes.IoTJobExponentialRolloutRate.write(value:to:))
        try writer["maximumPerMinute"].write(value.maximumPerMinute)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig()
        value.exponentialRate = try reader["exponentialRate"].readIfPresent(with: GreengrassV2ClientTypes.IoTJobExponentialRolloutRate.read(from:))
        value.maximumPerMinute = try reader["maximumPerMinute"].readIfPresent()
        return value
    }
}

extension GreengrassV2ClientTypes.IoTJobExponentialRolloutRate {

    static func write(value: GreengrassV2ClientTypes.IoTJobExponentialRolloutRate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseRatePerMinute"].write(value.baseRatePerMinute)
        try writer["incrementFactor"].write(value.incrementFactor)
        try writer["rateIncreaseCriteria"].write(value.rateIncreaseCriteria, with: GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.IoTJobExponentialRolloutRate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.IoTJobExponentialRolloutRate()
        value.baseRatePerMinute = try reader["baseRatePerMinute"].readIfPresent() ?? 0
        value.incrementFactor = try reader["incrementFactor"].readIfPresent() ?? 0.0
        value.rateIncreaseCriteria = try reader["rateIncreaseCriteria"].readIfPresent(with: GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria.read(from:))
        return value
    }
}

extension GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria {

    static func write(value: GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["numberOfNotifiedThings"].write(value.numberOfNotifiedThings)
        try writer["numberOfSucceededThings"].write(value.numberOfSucceededThings)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria()
        value.numberOfNotifiedThings = try reader["numberOfNotifiedThings"].readIfPresent()
        value.numberOfSucceededThings = try reader["numberOfSucceededThings"].readIfPresent()
        return value
    }
}

extension GreengrassV2ClientTypes.AssociatedClientDevice {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.AssociatedClientDevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.AssociatedClientDevice()
        value.thingName = try reader["thingName"].readIfPresent()
        value.associationTimestamp = try reader["associationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GreengrassV2ClientTypes.Component {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.Component {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.Component()
        value.arn = try reader["arn"].readIfPresent()
        value.componentName = try reader["componentName"].readIfPresent()
        value.latestVersion = try reader["latestVersion"].readIfPresent(with: GreengrassV2ClientTypes.ComponentLatestVersion.read(from:))
        return value
    }
}

extension GreengrassV2ClientTypes.ComponentLatestVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.ComponentLatestVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.ComponentLatestVersion()
        value.arn = try reader["arn"].readIfPresent()
        value.componentVersion = try reader["componentVersion"].readIfPresent()
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.publisher = try reader["publisher"].readIfPresent()
        value.platforms = try reader["platforms"].readListIfPresent(memberReadingClosure: GreengrassV2ClientTypes.ComponentPlatform.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassV2ClientTypes.ComponentVersionListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.ComponentVersionListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.ComponentVersionListItem()
        value.componentName = try reader["componentName"].readIfPresent()
        value.componentVersion = try reader["componentVersion"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension GreengrassV2ClientTypes.CoreDevice {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.CoreDevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.CoreDevice()
        value.coreDeviceThingName = try reader["coreDeviceThingName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.lastStatusUpdateTimestamp = try reader["lastStatusUpdateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GreengrassV2ClientTypes.Deployment {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.Deployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.Deployment()
        value.targetArn = try reader["targetArn"].readIfPresent()
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.deploymentName = try reader["deploymentName"].readIfPresent()
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deploymentStatus = try reader["deploymentStatus"].readIfPresent()
        value.isLatestForTarget = try reader["isLatestForTarget"].readIfPresent() ?? false
        value.parentTargetArn = try reader["parentTargetArn"].readIfPresent()
        return value
    }
}

extension GreengrassV2ClientTypes.EffectiveDeployment {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.EffectiveDeployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.EffectiveDeployment()
        value.deploymentId = try reader["deploymentId"].readIfPresent() ?? ""
        value.deploymentName = try reader["deploymentName"].readIfPresent() ?? ""
        value.iotJobId = try reader["iotJobId"].readIfPresent()
        value.iotJobArn = try reader["iotJobArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.targetArn = try reader["targetArn"].readIfPresent() ?? ""
        value.coreDeviceExecutionStatus = try reader["coreDeviceExecutionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.reason = try reader["reason"].readIfPresent()
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedTimestamp = try reader["modifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.statusDetails = try reader["statusDetails"].readIfPresent(with: GreengrassV2ClientTypes.EffectiveDeploymentStatusDetails.read(from:))
        return value
    }
}

extension GreengrassV2ClientTypes.EffectiveDeploymentStatusDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.EffectiveDeploymentStatusDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.EffectiveDeploymentStatusDetails()
        value.errorStack = try reader["errorStack"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorTypes = try reader["errorTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassV2ClientTypes.InstalledComponent {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.InstalledComponent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.InstalledComponent()
        value.componentName = try reader["componentName"].readIfPresent()
        value.componentVersion = try reader["componentVersion"].readIfPresent()
        value.lifecycleState = try reader["lifecycleState"].readIfPresent()
        value.lifecycleStateDetails = try reader["lifecycleStateDetails"].readIfPresent()
        value.isRoot = try reader["isRoot"].readIfPresent() ?? false
        value.lastStatusChangeTimestamp = try reader["lastStatusChangeTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastReportedTimestamp = try reader["lastReportedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastInstallationSource = try reader["lastInstallationSource"].readIfPresent()
        value.lifecycleStatusCodes = try reader["lifecycleStatusCodes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassV2ClientTypes.ResolvedComponentVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.ResolvedComponentVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.ResolvedComponentVersion()
        value.arn = try reader["arn"].readIfPresent()
        value.componentName = try reader["componentName"].readIfPresent()
        value.componentVersion = try reader["componentVersion"].readIfPresent()
        value.recipe = try reader["recipe"].readIfPresent()
        value.vendorGuidance = try reader["vendorGuidance"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension GreengrassV2ClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassV2ClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassV2ClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry {

    static func write(value: GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["thingName"].write(value.thingName)
    }
}

extension GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry {

    static func write(value: GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["thingName"].write(value.thingName)
    }
}

extension GreengrassV2ClientTypes.LambdaFunctionRecipeSource {

    static func write(value: GreengrassV2ClientTypes.LambdaFunctionRecipeSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentDependencies"].writeMap(value.componentDependencies, valueWritingClosure: GreengrassV2ClientTypes.ComponentDependencyRequirement.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["componentLambdaParameters"].write(value.componentLambdaParameters, with: GreengrassV2ClientTypes.LambdaExecutionParameters.write(value:to:))
        try writer["componentName"].write(value.componentName)
        try writer["componentPlatforms"].writeList(value.componentPlatforms, memberWritingClosure: GreengrassV2ClientTypes.ComponentPlatform.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["componentVersion"].write(value.componentVersion)
        try writer["lambdaArn"].write(value.lambdaArn)
    }
}

extension GreengrassV2ClientTypes.LambdaExecutionParameters {

    static func write(value: GreengrassV2ClientTypes.LambdaExecutionParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["environmentVariables"].writeMap(value.environmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["eventSources"].writeList(value.eventSources, memberWritingClosure: GreengrassV2ClientTypes.LambdaEventSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["execArgs"].writeList(value.execArgs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["inputPayloadEncodingType"].write(value.inputPayloadEncodingType)
        try writer["linuxProcessParams"].write(value.linuxProcessParams, with: GreengrassV2ClientTypes.LambdaLinuxProcessParams.write(value:to:))
        try writer["maxIdleTimeInSeconds"].write(value.maxIdleTimeInSeconds)
        try writer["maxInstancesCount"].write(value.maxInstancesCount)
        try writer["maxQueueSize"].write(value.maxQueueSize)
        try writer["pinned"].write(value.pinned)
        try writer["statusTimeoutInSeconds"].write(value.statusTimeoutInSeconds)
        try writer["timeoutInSeconds"].write(value.timeoutInSeconds)
    }
}

extension GreengrassV2ClientTypes.LambdaLinuxProcessParams {

    static func write(value: GreengrassV2ClientTypes.LambdaLinuxProcessParams?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["containerParams"].write(value.containerParams, with: GreengrassV2ClientTypes.LambdaContainerParams.write(value:to:))
        try writer["isolationMode"].write(value.isolationMode)
    }
}

extension GreengrassV2ClientTypes.LambdaContainerParams {

    static func write(value: GreengrassV2ClientTypes.LambdaContainerParams?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["devices"].writeList(value.devices, memberWritingClosure: GreengrassV2ClientTypes.LambdaDeviceMount.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["memorySizeInKB"].write(value.memorySizeInKB)
        try writer["mountROSysfs"].write(value.mountROSysfs)
        try writer["volumes"].writeList(value.volumes, memberWritingClosure: GreengrassV2ClientTypes.LambdaVolumeMount.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GreengrassV2ClientTypes.LambdaDeviceMount {

    static func write(value: GreengrassV2ClientTypes.LambdaDeviceMount?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addGroupOwner"].write(value.addGroupOwner)
        try writer["path"].write(value.path)
        try writer["permission"].write(value.permission)
    }
}

extension GreengrassV2ClientTypes.LambdaVolumeMount {

    static func write(value: GreengrassV2ClientTypes.LambdaVolumeMount?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addGroupOwner"].write(value.addGroupOwner)
        try writer["destinationPath"].write(value.destinationPath)
        try writer["permission"].write(value.permission)
        try writer["sourcePath"].write(value.sourcePath)
    }
}

extension GreengrassV2ClientTypes.LambdaEventSource {

    static func write(value: GreengrassV2ClientTypes.LambdaEventSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["topic"].write(value.topic)
        try writer["type"].write(value.type)
    }
}

extension GreengrassV2ClientTypes.ComponentDependencyRequirement {

    static func write(value: GreengrassV2ClientTypes.ComponentDependencyRequirement?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dependencyType"].write(value.dependencyType)
        try writer["versionRequirement"].write(value.versionRequirement)
    }
}

extension GreengrassV2ClientTypes.ComponentCandidate {

    static func write(value: GreengrassV2ClientTypes.ComponentCandidate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentName"].write(value.componentName)
        try writer["componentVersion"].write(value.componentVersion)
        try writer["versionRequirements"].writeMap(value.versionRequirements, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public enum GreengrassV2ClientTypes {}
