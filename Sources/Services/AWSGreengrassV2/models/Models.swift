// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have permission to perform the action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains a request to associate a client device with a core device. The [BatchAssociateClientDeviceWithCoreDevice](https://docs.aws.amazon.com/greengrass/v2/APIReference/API_BatchAssociateClientDeviceWithCoreDevice.html) operation consumes a list of these requests.
    public struct AssociateClientDeviceWithCoreDeviceEntry: Swift.Equatable {
        /// The name of the IoT thing that represents the client device to associate.
        /// This member is required.
        public var thingName: Swift.String?

        public init(
            thingName: Swift.String? = nil
        )
        {
            self.thingName = thingName
        }
    }

}

extension GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains an error that occurs from a request to associate a client device with a core device. The [BatchAssociateClientDeviceWithCoreDevice](https://docs.aws.amazon.com/greengrass/v2/APIReference/API_BatchAssociateClientDeviceWithCoreDevice.html) operation returns a list of these errors.
    public struct AssociateClientDeviceWithCoreDeviceErrorEntry: Swift.Equatable {
        /// The error code for the request.
        public var code: Swift.String?
        /// A message that provides additional information about the error.
        public var message: Swift.String?
        /// The name of the IoT thing whose associate request failed.
        public var thingName: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.thingName = thingName
        }
    }

}

extension AssociateServiceRoleToAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension AssociateServiceRoleToAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/servicerole"
    }
}

public struct AssociateServiceRoleToAccountInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service role to associate with IoT Greengrass for your Amazon Web Services account in this Amazon Web Services Region.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        roleArn: Swift.String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

struct AssociateServiceRoleToAccountInputBody: Swift.Equatable {
    let roleArn: Swift.String?
}

extension AssociateServiceRoleToAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AssociateServiceRoleToAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateServiceRoleToAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.associatedAt = output.associatedAt
        } else {
            self.associatedAt = nil
        }
    }
}

public struct AssociateServiceRoleToAccountOutput: Swift.Equatable {
    /// The time when the service role was associated with IoT Greengrass for your Amazon Web Services account in this Amazon Web Services Region.
    public var associatedAt: Swift.String?

    public init(
        associatedAt: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
    }
}

struct AssociateServiceRoleToAccountOutputBody: Swift.Equatable {
    let associatedAt: Swift.String?
}

extension AssociateServiceRoleToAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedAt = "AssociatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
    }
}

enum AssociateServiceRoleToAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassV2ClientTypes.AssociatedClientDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationTimestamp
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationTimestamp = self.associationTimestamp {
            try encodeContainer.encodeTimestamp(associationTimestamp, format: .epochSeconds, forKey: .associationTimestamp)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let associationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .associationTimestamp)
        associationTimestamp = associationTimestampDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a client device that is associated to a core device for cloud discovery.
    public struct AssociatedClientDevice: Swift.Equatable {
        /// The time that the client device was associated, expressed in ISO 8601 format.
        public var associationTimestamp: ClientRuntime.Date?
        /// The name of the IoT thing that represents the associated client device.
        public var thingName: Swift.String?

        public init(
            associationTimestamp: ClientRuntime.Date? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.associationTimestamp = associationTimestamp
            self.thingName = thingName
        }
    }

}

extension BatchAssociateClientDeviceWithCoreDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for associateclientdevicewithcoredeviceentry0 in entries {
                try entriesContainer.encode(associateclientdevicewithcoredeviceentry0)
            }
        }
    }
}

extension BatchAssociateClientDeviceWithCoreDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDeviceThingName = coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/associateClientDevices"
    }
}

public struct BatchAssociateClientDeviceWithCoreDeviceInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The list of client devices to associate.
    public var entries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry]?

    public init(
        coreDeviceThingName: Swift.String? = nil,
        entries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry]? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.entries = entries
    }
}

struct BatchAssociateClientDeviceWithCoreDeviceInputBody: Swift.Equatable {
    let entries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry]?
}

extension BatchAssociateClientDeviceWithCoreDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry?].self, forKey: .entries)
        var entriesDecoded0:[GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchAssociateClientDeviceWithCoreDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchAssociateClientDeviceWithCoreDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchAssociateClientDeviceWithCoreDeviceOutput: Swift.Equatable {
    /// The list of any errors for the entries in the request. Each error entry contains the name of the IoT thing that failed to associate.
    public var errorEntries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry]?

    public init(
        errorEntries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchAssociateClientDeviceWithCoreDeviceOutputBody: Swift.Equatable {
    let errorEntries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry]?
}

extension BatchAssociateClientDeviceWithCoreDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

enum BatchAssociateClientDeviceWithCoreDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDisassociateClientDeviceFromCoreDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for disassociateclientdevicefromcoredeviceentry0 in entries {
                try entriesContainer.encode(disassociateclientdevicefromcoredeviceentry0)
            }
        }
    }
}

extension BatchDisassociateClientDeviceFromCoreDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDeviceThingName = coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/disassociateClientDevices"
    }
}

public struct BatchDisassociateClientDeviceFromCoreDeviceInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The list of client devices to disassociate.
    public var entries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry]?

    public init(
        coreDeviceThingName: Swift.String? = nil,
        entries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry]? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.entries = entries
    }
}

struct BatchDisassociateClientDeviceFromCoreDeviceInputBody: Swift.Equatable {
    let entries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry]?
}

extension BatchDisassociateClientDeviceFromCoreDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry?].self, forKey: .entries)
        var entriesDecoded0:[GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchDisassociateClientDeviceFromCoreDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDisassociateClientDeviceFromCoreDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchDisassociateClientDeviceFromCoreDeviceOutput: Swift.Equatable {
    /// The list of any errors for the entries in the request. Each error entry contains the name of the IoT thing that failed to disassociate.
    public var errorEntries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry]?

    public init(
        errorEntries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchDisassociateClientDeviceFromCoreDeviceOutputBody: Swift.Equatable {
    let errorEntries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry]?
}

extension BatchDisassociateClientDeviceFromCoreDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

enum BatchDisassociateClientDeviceFromCoreDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/greengrass/v2/deployments/\(deploymentId.urlPercentEncoding())/cancel"
    }
}

public struct CancelDeploymentInput: Swift.Equatable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct CancelDeploymentInputBody: Swift.Equatable {
}

extension CancelDeploymentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct CancelDeploymentOutput: Swift.Equatable {
    /// A message that communicates if the cancel was successful.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CancelDeploymentOutputBody: Swift.Equatable {
    let message: Swift.String?
}

extension CancelDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum CancelDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassV2ClientTypes {
    public enum CloudComponentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deployable
        case deprecated
        case failed
        case initiated
        case requested
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudComponentState] {
            return [
                .deployable,
                .deprecated,
                .failed,
                .initiated,
                .requested,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deployable: return "DEPLOYABLE"
            case .deprecated: return "DEPRECATED"
            case .failed: return "FAILED"
            case .initiated: return "INITIATED"
            case .requested: return "REQUESTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudComponentState(rawValue: rawValue) ?? CloudComponentState.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.CloudComponentStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentState
        case errors
        case message
        case vendorGuidance
        case vendorGuidanceMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentState = self.componentState {
            try encodeContainer.encode(componentState.rawValue, forKey: .componentState)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .errors)
            for (dictKey0, stringMap0) in errors {
                try errorsContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let vendorGuidance = self.vendorGuidance {
            try encodeContainer.encode(vendorGuidance.rawValue, forKey: .vendorGuidance)
        }
        if let vendorGuidanceMessage = self.vendorGuidanceMessage {
            try encodeContainer.encode(vendorGuidanceMessage, forKey: .vendorGuidanceMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentStateDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.CloudComponentState.self, forKey: .componentState)
        componentState = componentStateDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .errors)
        var errorsDecoded0: [Swift.String:Swift.String]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in errorsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    errorsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        errors = errorsDecoded0
        let vendorGuidanceDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.VendorGuidance.self, forKey: .vendorGuidance)
        vendorGuidance = vendorGuidanceDecoded
        let vendorGuidanceMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorGuidanceMessage)
        vendorGuidanceMessage = vendorGuidanceMessageDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains the status of a component version in the IoT Greengrass service.
    public struct CloudComponentStatus: Swift.Equatable {
        /// The state of the component version.
        public var componentState: GreengrassV2ClientTypes.CloudComponentState?
        /// A dictionary of errors that communicate why the component version is in an error state. For example, if IoT Greengrass can't access an artifact for the component version, then errors contains the artifact's URI as a key, and the error message as the value for that key.
        public var errors: [Swift.String:Swift.String]?
        /// A message that communicates details, such as errors, about the status of the component version.
        public var message: Swift.String?
        /// The vendor guidance state for the component version. This state indicates whether the component version has any issues that you should consider before you deploy it. The vendor guidance state can be:
        ///
        /// * ACTIVE – This component version is available and recommended for use.
        ///
        /// * DISCONTINUED – This component version has been discontinued by its publisher. You can deploy this component version, but we recommend that you use a different version of this component.
        ///
        /// * DELETED – This component version has been deleted by its publisher, so you can't deploy it. If you have any existing deployments that specify this component version, those deployments will fail.
        public var vendorGuidance: GreengrassV2ClientTypes.VendorGuidance?
        /// A message that communicates details about the vendor guidance state of the component version. This message communicates why a component version is discontinued or deleted.
        public var vendorGuidanceMessage: Swift.String?

        public init(
            componentState: GreengrassV2ClientTypes.CloudComponentState? = nil,
            errors: [Swift.String:Swift.String]? = nil,
            message: Swift.String? = nil,
            vendorGuidance: GreengrassV2ClientTypes.VendorGuidance? = nil,
            vendorGuidanceMessage: Swift.String? = nil
        )
        {
            self.componentState = componentState
            self.errors = errors
            self.message = message
            self.vendorGuidance = vendorGuidance
            self.vendorGuidanceMessage = vendorGuidanceMessage
        }
    }

}

extension GreengrassV2ClientTypes.Component: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentName
        case latestVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let latestVersion = self.latestVersion {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.ComponentLatestVersion.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component.
    public struct Component: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
        public var arn: Swift.String?
        /// The name of the component.
        public var componentName: Swift.String?
        /// The latest version of the component and its details.
        public var latestVersion: GreengrassV2ClientTypes.ComponentLatestVersion?

        public init(
            arn: Swift.String? = nil,
            componentName: Swift.String? = nil,
            latestVersion: GreengrassV2ClientTypes.ComponentLatestVersion? = nil
        )
        {
            self.arn = arn
            self.componentName = componentName
            self.latestVersion = latestVersion
        }
    }

}

extension GreengrassV2ClientTypes.ComponentCandidate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentVersion
        case versionRequirements
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = self.componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let versionRequirements = versionRequirements {
            var versionRequirementsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .versionRequirements)
            for (dictKey0, componentVersionRequirementMap0) in versionRequirements {
                try versionRequirementsContainer.encode(componentVersionRequirementMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let versionRequirementsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .versionRequirements)
        var versionRequirementsDecoded0: [Swift.String:Swift.String]? = nil
        if let versionRequirementsContainer = versionRequirementsContainer {
            versionRequirementsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in versionRequirementsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    versionRequirementsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        versionRequirements = versionRequirementsDecoded0
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component that is a candidate to deploy to a Greengrass core device.
    public struct ComponentCandidate: Swift.Equatable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// The version requirements for the component's dependencies. Greengrass core devices get the version requirements from component recipes. IoT Greengrass V2 uses semantic version constraints. For more information, see [Semantic Versioning](https://semver.org/).
        public var versionRequirements: [Swift.String:Swift.String]?

        public init(
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            versionRequirements: [Swift.String:Swift.String]? = nil
        )
        {
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.versionRequirements = versionRequirements
        }
    }

}

extension GreengrassV2ClientTypes.ComponentConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case merge
        case reset
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let merge = self.merge {
            try encodeContainer.encode(merge, forKey: .merge)
        }
        if let reset = reset {
            var resetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reset)
            for componentconfigurationpath0 in reset {
                try resetContainer.encode(componentconfigurationpath0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .merge)
        merge = mergeDecoded
        let resetContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reset)
        var resetDecoded0:[Swift.String]? = nil
        if let resetContainer = resetContainer {
            resetDecoded0 = [Swift.String]()
            for string0 in resetContainer {
                if let string0 = string0 {
                    resetDecoded0?.append(string0)
                }
            }
        }
        reset = resetDecoded0
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a deployment's update to a component's configuration on Greengrass core devices. For more information, see [Update component configurations](https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html) in the IoT Greengrass V2 Developer Guide.
    public struct ComponentConfigurationUpdate: Swift.Equatable {
        /// A serialized JSON string that contains the configuration object to merge to target devices. The core device merges this configuration with the component's existing configuration. If this is the first time a component deploys on a device, the core device merges this configuration with the component's default configuration. This means that the core device keeps it's existing configuration for keys and values that you don't specify in this object. For more information, see [Merge configuration updates](https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html#merge-configuration-update) in the IoT Greengrass V2 Developer Guide.
        public var merge: Swift.String?
        /// The list of configuration nodes to reset to default values on target devices. Use JSON pointers to specify each node to reset. JSON pointers start with a forward slash (/) and use forward slashes to separate the key for each level in the object. For more information, see the [JSON pointer specification](https://tools.ietf.org/html/rfc6901) and [Reset configuration updates](https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html#reset-configuration-update) in the IoT Greengrass V2 Developer Guide.
        public var reset: [Swift.String]?

        public init(
            merge: Swift.String? = nil,
            reset: [Swift.String]? = nil
        )
        {
            self.merge = merge
            self.reset = reset
        }
    }

}

extension GreengrassV2ClientTypes.ComponentDependencyRequirement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencyType
        case versionRequirement
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependencyType = self.dependencyType {
            try encodeContainer.encode(dependencyType.rawValue, forKey: .dependencyType)
        }
        if let versionRequirement = self.versionRequirement {
            try encodeContainer.encode(versionRequirement, forKey: .versionRequirement)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionRequirementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRequirement)
        versionRequirement = versionRequirementDecoded
        let dependencyTypeDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.ComponentDependencyType.self, forKey: .dependencyType)
        dependencyType = dependencyTypeDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component dependency for a Lambda function component.
    public struct ComponentDependencyRequirement: Swift.Equatable {
        /// The type of this dependency. Choose from the following options:
        ///
        /// * SOFT – The component doesn't restart if the dependency changes state.
        ///
        /// * HARD – The component restarts if the dependency changes state.
        ///
        ///
        /// Default: HARD
        public var dependencyType: GreengrassV2ClientTypes.ComponentDependencyType?
        /// The component version requirement for the component dependency. IoT Greengrass V2 uses semantic version constraints. For more information, see [Semantic Versioning](https://semver.org/).
        public var versionRequirement: Swift.String?

        public init(
            dependencyType: GreengrassV2ClientTypes.ComponentDependencyType? = nil,
            versionRequirement: Swift.String? = nil
        )
        {
            self.dependencyType = dependencyType
            self.versionRequirement = versionRequirement
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum ComponentDependencyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hard
        case soft
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentDependencyType] {
            return [
                .hard,
                .soft,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hard: return "HARD"
            case .soft: return "SOFT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentDependencyType(rawValue: rawValue) ?? ComponentDependencyType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.ComponentDeploymentSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentVersion
        case configurationUpdate
        case runWith
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentVersion = self.componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let configurationUpdate = self.configurationUpdate {
            try encodeContainer.encode(configurationUpdate, forKey: .configurationUpdate)
        }
        if let runWith = self.runWith {
            try encodeContainer.encode(runWith, forKey: .runWith)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let configurationUpdateDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.ComponentConfigurationUpdate.self, forKey: .configurationUpdate)
        configurationUpdate = configurationUpdateDecoded
        let runWithDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.ComponentRunWith.self, forKey: .runWith)
        runWith = runWithDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component to deploy.
    public struct ComponentDeploymentSpecification: Swift.Equatable {
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// The configuration updates to deploy for the component. You can define reset updates and merge updates. A reset updates the keys that you specify to the default configuration for the component. A merge updates the core device's component configuration with the keys and values that you specify. The IoT Greengrass Core software applies reset updates before it applies merge updates. For more information, see [Update component configurations](https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html) in the IoT Greengrass V2 Developer Guide.
        public var configurationUpdate: GreengrassV2ClientTypes.ComponentConfigurationUpdate?
        /// The system user and group that the IoT Greengrass Core software uses to run component processes on the core device. If you omit this parameter, the IoT Greengrass Core software uses the system user and group that you configure for the core device. For more information, see [Configure the user and group that run components](https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-user) in the IoT Greengrass V2 Developer Guide.
        public var runWith: GreengrassV2ClientTypes.ComponentRunWith?

        public init(
            componentVersion: Swift.String? = nil,
            configurationUpdate: GreengrassV2ClientTypes.ComponentConfigurationUpdate? = nil,
            runWith: GreengrassV2ClientTypes.ComponentRunWith? = nil
        )
        {
            self.componentVersion = componentVersion
            self.configurationUpdate = configurationUpdate
            self.runWith = runWith
        }
    }

}

extension GreengrassV2ClientTypes.ComponentLatestVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentVersion
        case creationTimestamp
        case description
        case platforms
        case publisher
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentVersion = self.componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encodeTimestamp(creationTimestamp, format: .epochSeconds, forKey: .creationTimestamp)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let platforms = platforms {
            var platformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platforms)
            for componentplatform0 in platforms {
                try platformsContainer.encode(componentplatform0)
            }
        }
        if let publisher = self.publisher {
            try encodeContainer.encode(publisher, forKey: .publisher)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let publisherDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publisher)
        publisher = publisherDecoded
        let platformsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ComponentPlatform?].self, forKey: .platforms)
        var platformsDecoded0:[GreengrassV2ClientTypes.ComponentPlatform]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [GreengrassV2ClientTypes.ComponentPlatform]()
            for structure0 in platformsContainer {
                if let structure0 = structure0 {
                    platformsDecoded0?.append(structure0)
                }
            }
        }
        platforms = platformsDecoded0
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about the latest version of a component.
    public struct ComponentLatestVersion: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
        public var arn: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// The time at which the component was created, expressed in ISO 8601 format.
        public var creationTimestamp: ClientRuntime.Date?
        /// The description of the component version.
        public var description: Swift.String?
        /// The platforms that the component version supports.
        public var platforms: [GreengrassV2ClientTypes.ComponentPlatform]?
        /// The publisher of the component version.
        public var publisher: Swift.String?

        public init(
            arn: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            creationTimestamp: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            platforms: [GreengrassV2ClientTypes.ComponentPlatform]? = nil,
            publisher: Swift.String? = nil
        )
        {
            self.arn = arn
            self.componentVersion = componentVersion
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.platforms = platforms
            self.publisher = publisher
        }
    }

}

extension GreengrassV2ClientTypes.ComponentPlatform: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, platformAttributesMap0) in attributes {
                try attributesContainer.encode(platformAttributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in attributesContainer {
                if let nonemptystring0 = nonemptystring0 {
                    attributesDecoded0?[key0] = nonemptystring0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a platform that a component supports.
    public struct ComponentPlatform: Swift.Equatable {
        /// A dictionary of attributes for the platform. The IoT Greengrass Core software defines the os and architecture by default. You can specify additional platform attributes for a core device when you deploy the Greengrass nucleus component. For more information, see the [Greengrass nucleus component](https://docs.aws.amazon.com/greengrass/v2/developerguide/greengrass-nucleus-component.html) in the IoT Greengrass V2 Developer Guide.
        public var attributes: [Swift.String:Swift.String]?
        /// The friendly name of the platform. This name helps you identify the platform. If you omit this parameter, IoT Greengrass creates a friendly name from the os and architecture of the platform.
        public var name: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.name = name
        }
    }

}

extension GreengrassV2ClientTypes.ComponentRunWith: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case posixUser
        case systemResourceLimits
        case windowsUser
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let posixUser = self.posixUser {
            try encodeContainer.encode(posixUser, forKey: .posixUser)
        }
        if let systemResourceLimits = self.systemResourceLimits {
            try encodeContainer.encode(systemResourceLimits, forKey: .systemResourceLimits)
        }
        if let windowsUser = self.windowsUser {
            try encodeContainer.encode(windowsUser, forKey: .windowsUser)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let posixUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .posixUser)
        posixUser = posixUserDecoded
        let systemResourceLimitsDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.SystemResourceLimits.self, forKey: .systemResourceLimits)
        systemResourceLimits = systemResourceLimitsDecoded
        let windowsUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowsUser)
        windowsUser = windowsUserDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information system user and group that the IoT Greengrass Core software uses to run component processes on the core device. For more information, see [Configure the user and group that run components](https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-user) in the IoT Greengrass V2 Developer Guide.
    public struct ComponentRunWith: Swift.Equatable {
        /// The POSIX system user and, optionally, group to use to run this component on Linux core devices. The user, and group if specified, must exist on each Linux core device. Specify the user and group separated by a colon (:) in the following format: user:group. The group is optional. If you don't specify a group, the IoT Greengrass Core software uses the primary user for the group. If you omit this parameter, the IoT Greengrass Core software uses the default system user and group that you configure on the Greengrass nucleus component. For more information, see [Configure the user and group that run components](https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-user).
        public var posixUser: Swift.String?
        /// The system resource limits to apply to this component's process on the core device. IoT Greengrass currently supports this feature on only Linux core devices. If you omit this parameter, the IoT Greengrass Core software uses the default system resource limits that you configure on the Greengrass nucleus component. For more information, see [Configure system resource limits for components](https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-system-resource-limits).
        public var systemResourceLimits: GreengrassV2ClientTypes.SystemResourceLimits?
        /// The Windows user to use to run this component on Windows core devices. The user must exist on each Windows core device, and its name and password must be in the LocalSystem account's Credentials Manager instance. If you omit this parameter, the IoT Greengrass Core software uses the default Windows user that you configure on the Greengrass nucleus component. For more information, see [Configure the user and group that run components](https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-user).
        public var windowsUser: Swift.String?

        public init(
            posixUser: Swift.String? = nil,
            systemResourceLimits: GreengrassV2ClientTypes.SystemResourceLimits? = nil,
            windowsUser: Swift.String? = nil
        )
        {
            self.posixUser = posixUser
            self.systemResourceLimits = systemResourceLimits
            self.windowsUser = windowsUser
        }
    }

}

extension GreengrassV2ClientTypes.ComponentVersionListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentName
        case componentVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = self.componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component version in a list.
    public struct ComponentVersionListItem: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
        public var arn: Swift.String?
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.componentName = componentName
            self.componentVersion = componentVersion
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum ComponentVisibilityScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentVisibilityScope] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentVisibilityScope(rawValue: rawValue) ?? ComponentVisibilityScope.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that conflicts with the request.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that conflicts with the request.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension GreengrassV2ClientTypes.ConnectivityInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostAddress = "HostAddress"
        case id = "Id"
        case metadata = "Metadata"
        case portNumber = "PortNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostAddress = self.hostAddress {
            try encodeContainer.encode(hostAddress, forKey: .hostAddress)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if portNumber != 0 {
            try encodeContainer.encode(portNumber, forKey: .portNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let hostAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostAddress)
        hostAddress = hostAddressDecoded
        let portNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .portNumber) ?? 0
        portNumber = portNumberDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about an endpoint and port where client devices can connect to an MQTT broker on a Greengrass core device.
    public struct ConnectivityInfo: Swift.Equatable {
        /// The IP address or DNS address where client devices can connect to an MQTT broker on the Greengrass core device.
        public var hostAddress: Swift.String?
        /// An ID for the connectivity information.
        public var id: Swift.String?
        /// Additional metadata to provide to client devices that connect to this core device.
        public var metadata: Swift.String?
        /// The port where the MQTT broker operates on the core device. This port is typically 8883, which is the default port for the MQTT broker component that runs on core devices.
        public var portNumber: Swift.Int

        public init(
            hostAddress: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: Swift.String? = nil,
            portNumber: Swift.Int = 0
        )
        {
            self.hostAddress = hostAddress
            self.id = id
            self.metadata = metadata
            self.portNumber = portNumber
        }
    }

}

extension GreengrassV2ClientTypes.CoreDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreDeviceThingName
        case lastStatusUpdateTimestamp
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreDeviceThingName = self.coreDeviceThingName {
            try encodeContainer.encode(coreDeviceThingName, forKey: .coreDeviceThingName)
        }
        if let lastStatusUpdateTimestamp = self.lastStatusUpdateTimestamp {
            try encodeContainer.encodeTimestamp(lastStatusUpdateTimestamp, format: .epochSeconds, forKey: .lastStatusUpdateTimestamp)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreDeviceThingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreDeviceThingName)
        coreDeviceThingName = coreDeviceThingNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.CoreDeviceStatus.self, forKey: .status)
        status = statusDecoded
        let lastStatusUpdateTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStatusUpdateTimestamp)
        lastStatusUpdateTimestamp = lastStatusUpdateTimestampDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a Greengrass core device, which is an IoT thing that runs the IoT Greengrass Core software.
    public struct CoreDevice: Swift.Equatable {
        /// The name of the core device. This is also the name of the IoT thing.
        public var coreDeviceThingName: Swift.String?
        /// The time at which the core device's status last updated, expressed in ISO 8601 format.
        public var lastStatusUpdateTimestamp: ClientRuntime.Date?
        /// The status of the core device. Core devices can have the following statuses:
        ///
        /// * HEALTHY – The IoT Greengrass Core software and all components run on the core device without issue.
        ///
        /// * UNHEALTHY – The IoT Greengrass Core software or a component is in a failed state on the core device.
        public var status: GreengrassV2ClientTypes.CoreDeviceStatus?

        public init(
            coreDeviceThingName: Swift.String? = nil,
            lastStatusUpdateTimestamp: ClientRuntime.Date? = nil,
            status: GreengrassV2ClientTypes.CoreDeviceStatus? = nil
        )
        {
            self.coreDeviceThingName = coreDeviceThingName
            self.lastStatusUpdateTimestamp = lastStatusUpdateTimestamp
            self.status = status
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum CoreDeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [CoreDeviceStatus] {
            return [
                .healthy,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoreDeviceStatus(rawValue: rawValue) ?? CoreDeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateComponentVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case inlineRecipe
        case lambdaFunction
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let inlineRecipe = self.inlineRecipe {
            try encodeContainer.encode(inlineRecipe.base64EncodedString(), forKey: .inlineRecipe)
        }
        if let lambdaFunction = self.lambdaFunction {
            try encodeContainer.encode(lambdaFunction, forKey: .lambdaFunction)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateComponentVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/v2/createComponentVersion"
    }
}

public struct CreateComponentVersionInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you can provide to ensure that the request is idempotent. Idempotency means that the request is successfully processed only once, even if you send the request multiple times. When a request succeeds, and you specify the same client token for subsequent successful requests, the IoT Greengrass V2 service returns the successful response that it caches from the previous request. IoT Greengrass V2 caches successful responses for idempotent requests for up to 8 hours.
    public var clientToken: Swift.String?
    /// The recipe to use to create the component. The recipe defines the component's metadata, parameters, dependencies, lifecycle, artifacts, and platform compatibility. You must specify either inlineRecipe or lambdaFunction.
    public var inlineRecipe: ClientRuntime.Data?
    /// The parameters to create a component from a Lambda function. You must specify either inlineRecipe or lambdaFunction.
    public var lambdaFunction: GreengrassV2ClientTypes.LambdaFunctionRecipeSource?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        inlineRecipe: ClientRuntime.Data? = nil,
        lambdaFunction: GreengrassV2ClientTypes.LambdaFunctionRecipeSource? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.inlineRecipe = inlineRecipe
        self.lambdaFunction = lambdaFunction
        self.tags = tags
    }
}

struct CreateComponentVersionInputBody: Swift.Equatable {
    let inlineRecipe: ClientRuntime.Data?
    let lambdaFunction: GreengrassV2ClientTypes.LambdaFunctionRecipeSource?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateComponentVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case inlineRecipe
        case lambdaFunction
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlineRecipeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .inlineRecipe)
        inlineRecipe = inlineRecipeDecoded
        let lambdaFunctionDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaFunctionRecipeSource.self, forKey: .lambdaFunction)
        lambdaFunction = lambdaFunctionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateComponentVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateComponentVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.componentName = output.componentName
            self.componentVersion = output.componentVersion
            self.creationTimestamp = output.creationTimestamp
            self.status = output.status
        } else {
            self.arn = nil
            self.componentName = nil
            self.componentVersion = nil
            self.creationTimestamp = nil
            self.status = nil
        }
    }
}

public struct CreateComponentVersionOutput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
    public var arn: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The version of the component.
    /// This member is required.
    public var componentVersion: Swift.String?
    /// The time at which the component was created, expressed in ISO 8601 format.
    /// This member is required.
    public var creationTimestamp: ClientRuntime.Date?
    /// The status of the component version in IoT Greengrass V2. This status is different from the status of the component on a core device.
    /// This member is required.
    public var status: GreengrassV2ClientTypes.CloudComponentStatus?

    public init(
        arn: Swift.String? = nil,
        componentName: Swift.String? = nil,
        componentVersion: Swift.String? = nil,
        creationTimestamp: ClientRuntime.Date? = nil,
        status: GreengrassV2ClientTypes.CloudComponentStatus? = nil
    )
    {
        self.arn = arn
        self.componentName = componentName
        self.componentVersion = componentVersion
        self.creationTimestamp = creationTimestamp
        self.status = status
    }
}

struct CreateComponentVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let componentName: Swift.String?
    let componentVersion: Swift.String?
    let creationTimestamp: ClientRuntime.Date?
    let status: GreengrassV2ClientTypes.CloudComponentStatus?
}

extension CreateComponentVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentName
        case componentVersion
        case creationTimestamp
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.CloudComponentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateComponentVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestAlreadyInProgressException": return try await RequestAlreadyInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case components
        case deploymentName
        case deploymentPolicies
        case iotJobConfiguration
        case parentTargetArn
        case tags
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .components)
            for (dictKey0, componentDeploymentSpecifications0) in components {
                try componentsContainer.encode(componentDeploymentSpecifications0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let deploymentName = self.deploymentName {
            try encodeContainer.encode(deploymentName, forKey: .deploymentName)
        }
        if let deploymentPolicies = self.deploymentPolicies {
            try encodeContainer.encode(deploymentPolicies, forKey: .deploymentPolicies)
        }
        if let iotJobConfiguration = self.iotJobConfiguration {
            try encodeContainer.encode(iotJobConfiguration, forKey: .iotJobConfiguration)
        }
        if let parentTargetArn = self.parentTargetArn {
            try encodeContainer.encode(parentTargetArn, forKey: .parentTargetArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

extension CreateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/v2/deployments"
    }
}

public struct CreateDeploymentInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you can provide to ensure that the request is idempotent. Idempotency means that the request is successfully processed only once, even if you send the request multiple times. When a request succeeds, and you specify the same client token for subsequent successful requests, the IoT Greengrass V2 service returns the successful response that it caches from the previous request. IoT Greengrass V2 caches successful responses for idempotent requests for up to 8 hours.
    public var clientToken: Swift.String?
    /// The components to deploy. This is a dictionary, where each key is the name of a component, and each key's value is the version and configuration to deploy for that component.
    public var components: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]?
    /// The name of the deployment.
    public var deploymentName: Swift.String?
    /// The deployment policies for the deployment. These policies define how the deployment updates components and handles failure.
    public var deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies?
    /// The job configuration for the deployment configuration. The job configuration specifies the rollout, timeout, and stop configurations for the deployment configuration.
    public var iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration?
    /// The parent deployment's target [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) within a subdeployment.
    public var parentTargetArn: Swift.String?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the target IoT thing or thing group. When creating a subdeployment, the targetARN can only be a thing group.
    /// This member is required.
    public var targetArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        components: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]? = nil,
        deploymentName: Swift.String? = nil,
        deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies? = nil,
        iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration? = nil,
        parentTargetArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.components = components
        self.deploymentName = deploymentName
        self.deploymentPolicies = deploymentPolicies
        self.iotJobConfiguration = iotJobConfiguration
        self.parentTargetArn = parentTargetArn
        self.tags = tags
        self.targetArn = targetArn
    }
}

struct CreateDeploymentInputBody: Swift.Equatable {
    let targetArn: Swift.String?
    let deploymentName: Swift.String?
    let components: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]?
    let iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration?
    let deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies?
    let parentTargetArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case components
        case deploymentName
        case deploymentPolicies
        case iotJobConfiguration
        case parentTargetArn
        case tags
        case targetArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let deploymentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let componentsContainer = try containerValues.decodeIfPresent([Swift.String: GreengrassV2ClientTypes.ComponentDeploymentSpecification?].self, forKey: .components)
        var componentsDecoded0: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]()
            for (key0, componentdeploymentspecification0) in componentsContainer {
                if let componentdeploymentspecification0 = componentdeploymentspecification0 {
                    componentsDecoded0?[key0] = componentdeploymentspecification0
                }
            }
        }
        components = componentsDecoded0
        let iotJobConfigurationDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentIoTJobConfiguration.self, forKey: .iotJobConfiguration)
        iotJobConfiguration = iotJobConfigurationDecoded
        let deploymentPoliciesDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentPolicies.self, forKey: .deploymentPolicies)
        deploymentPolicies = deploymentPoliciesDecoded
        let parentTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentTargetArn)
        parentTargetArn = parentTargetArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.deploymentId = output.deploymentId
            self.iotJobArn = output.iotJobArn
            self.iotJobId = output.iotJobId
        } else {
            self.deploymentId = nil
            self.iotJobArn = nil
            self.iotJobId = nil
        }
    }
}

public struct CreateDeploymentOutput: Swift.Equatable {
    /// The ID of the deployment.
    public var deploymentId: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IoT job that applies the deployment to target devices.
    public var iotJobArn: Swift.String?
    /// The ID of the IoT job that applies the deployment to target devices.
    public var iotJobId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        iotJobArn: Swift.String? = nil,
        iotJobId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.iotJobArn = iotJobArn
        self.iotJobId = iotJobId
    }
}

struct CreateDeploymentOutputBody: Swift.Equatable {
    let deploymentId: Swift.String?
    let iotJobId: Swift.String?
    let iotJobArn: Swift.String?
}

extension CreateDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case iotJobArn
        case iotJobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let iotJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobId)
        iotJobId = iotJobIdDecoded
        let iotJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobArn)
        iotJobArn = iotJobArnDecoded
    }
}

enum CreateDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestAlreadyInProgressException": return try await RequestAlreadyInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/greengrass/v2/components/\(arn.urlPercentEncoding())"
    }
}

public struct DeleteComponentInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteComponentInputBody: Swift.Equatable {
}

extension DeleteComponentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteComponentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCoreDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDeviceThingName = coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())"
    }
}

public struct DeleteCoreDeviceInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?

    public init(
        coreDeviceThingName: Swift.String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
    }
}

struct DeleteCoreDeviceInputBody: Swift.Equatable {
}

extension DeleteCoreDeviceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCoreDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCoreDeviceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCoreDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/greengrass/v2/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

public struct DeleteDeploymentInput: Swift.Equatable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct DeleteDeploymentInputBody: Swift.Equatable {
}

extension DeleteDeploymentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDeploymentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassV2ClientTypes.Deployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp
        case deploymentId
        case deploymentName
        case deploymentStatus
        case isLatestForTarget
        case parentTargetArn
        case revisionId
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encodeTimestamp(creationTimestamp, format: .epochSeconds, forKey: .creationTimestamp)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentName = self.deploymentName {
            try encodeContainer.encode(deploymentName, forKey: .deploymentName)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if isLatestForTarget != false {
            try encodeContainer.encode(isLatestForTarget, forKey: .isLatestForTarget)
        }
        if let parentTargetArn = self.parentTargetArn {
            try encodeContainer.encode(parentTargetArn, forKey: .parentTargetArn)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let isLatestForTargetDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLatestForTarget) ?? false
        isLatestForTarget = isLatestForTargetDecoded
        let parentTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentTargetArn)
        parentTargetArn = parentTargetArnDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a deployment.
    public struct Deployment: Swift.Equatable {
        /// The time at which the deployment was created, expressed in ISO 8601 format.
        public var creationTimestamp: ClientRuntime.Date?
        /// The ID of the deployment.
        public var deploymentId: Swift.String?
        /// The name of the deployment.
        public var deploymentName: Swift.String?
        /// The status of the deployment.
        public var deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus?
        /// Whether or not the deployment is the latest revision for its target.
        public var isLatestForTarget: Swift.Bool
        /// The parent deployment's target [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) within a subdeployment.
        public var parentTargetArn: Swift.String?
        /// The revision number of the deployment.
        public var revisionId: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the target IoT thing or thing group. When creating a subdeployment, the targetARN can only be a thing group.
        public var targetArn: Swift.String?

        public init(
            creationTimestamp: ClientRuntime.Date? = nil,
            deploymentId: Swift.String? = nil,
            deploymentName: Swift.String? = nil,
            deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus? = nil,
            isLatestForTarget: Swift.Bool = false,
            parentTargetArn: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.deploymentId = deploymentId
            self.deploymentName = deploymentName
            self.deploymentStatus = deploymentStatus
            self.isLatestForTarget = isLatestForTarget
            self.parentTargetArn = parentTargetArn
            self.revisionId = revisionId
            self.targetArn = targetArn
        }
    }

}

extension GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case timeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let timeoutInSeconds = self.timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentComponentUpdatePolicyAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a deployment's policy that defines when components are safe to update. Each component on a device can report whether or not it's ready to update. After a component and its dependencies are ready, they can apply the update in the deployment. You can configure whether or not the deployment notifies components of an update and waits for a response. You specify the amount of time each component has to respond to the update notification.
    public struct DeploymentComponentUpdatePolicy: Swift.Equatable {
        /// Whether or not to notify components and wait for components to become safe to update. Choose from the following options:
        ///
        /// * NOTIFY_COMPONENTS – The deployment notifies each component before it stops and updates that component. Components can use the [SubscribeToComponentUpdates](https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-subscribetocomponentupdates) IPC operation to receive these notifications. Then, components can respond with the [DeferComponentUpdate](https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-defercomponentupdate) IPC operation. For more information, see [Create deployments](https://docs.aws.amazon.com/greengrass/v2/developerguide/create-deployments.html) in the IoT Greengrass V2 Developer Guide.
        ///
        /// * SKIP_NOTIFY_COMPONENTS – The deployment doesn't notify components or wait for them to be safe to update.
        ///
        ///
        /// Default: NOTIFY_COMPONENTS
        public var action: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicyAction?
        /// The amount of time in seconds that each component on a device has to report that it's safe to update. If the component waits for longer than this timeout, then the deployment proceeds on the device. Default: 60
        public var timeoutInSeconds: Swift.Int?

        public init(
            action: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicyAction? = nil,
            timeoutInSeconds: Swift.Int? = nil
        )
        {
            self.action = action
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum DeploymentComponentUpdatePolicyAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notifyComponents
        case skipNotifyComponents
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentComponentUpdatePolicyAction] {
            return [
                .notifyComponents,
                .skipNotifyComponents,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notifyComponents: return "NOTIFY_COMPONENTS"
            case .skipNotifyComponents: return "SKIP_NOTIFY_COMPONENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentComponentUpdatePolicyAction(rawValue: rawValue) ?? DeploymentComponentUpdatePolicyAction.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeoutInSeconds = self.timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about how long a component on a core device can validate its configuration updates before it times out. Components can use the [SubscribeToValidateConfigurationUpdates](https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-subscribetovalidateconfigurationupdates) IPC operation to receive notifications when a deployment specifies a configuration update. Then, components can respond with the [SendConfigurationValidityReport](https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-sendconfigurationvalidityreport) IPC operation. For more information, see [Create deployments](https://docs.aws.amazon.com/greengrass/v2/developerguide/create-deployments.html) in the IoT Greengrass V2 Developer Guide.
    public struct DeploymentConfigurationValidationPolicy: Swift.Equatable {
        /// The amount of time in seconds that a component can validate its configuration updates. If the validation time exceeds this timeout, then the deployment proceeds for the device. Default: 30
        public var timeoutInSeconds: Swift.Int?

        public init(
            timeoutInSeconds: Swift.Int? = nil
        )
        {
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum DeploymentFailureHandlingPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case doNothing
        case rollback
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentFailureHandlingPolicy] {
            return [
                .doNothing,
                .rollback,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .doNothing: return "DO_NOTHING"
            case .rollback: return "ROLLBACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentFailureHandlingPolicy(rawValue: rawValue) ?? DeploymentFailureHandlingPolicy.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes {
    public enum DeploymentHistoryFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case latestOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentHistoryFilter] {
            return [
                .all,
                .latestOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .latestOnly: return "LATEST_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentHistoryFilter(rawValue: rawValue) ?? DeploymentHistoryFilter.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.DeploymentIoTJobConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortConfig
        case jobExecutionsRolloutConfig
        case timeoutConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortConfig = self.abortConfig {
            try encodeContainer.encode(abortConfig, forKey: .abortConfig)
        }
        if let jobExecutionsRolloutConfig = self.jobExecutionsRolloutConfig {
            try encodeContainer.encode(jobExecutionsRolloutConfig, forKey: .jobExecutionsRolloutConfig)
        }
        if let timeoutConfig = self.timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobAbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobTimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about an IoT job configuration.
    public struct DeploymentIoTJobConfiguration: Swift.Equatable {
        /// The stop configuration for the job. This configuration defines when and how to stop a job rollout.
        public var abortConfig: GreengrassV2ClientTypes.IoTJobAbortConfig?
        /// The rollout configuration for the job. This configuration defines the rate at which the job rolls out to the fleet of target devices.
        public var jobExecutionsRolloutConfig: GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig?
        /// The timeout configuration for the job. This configuration defines the amount of time each device has to complete the job.
        public var timeoutConfig: GreengrassV2ClientTypes.IoTJobTimeoutConfig?

        public init(
            abortConfig: GreengrassV2ClientTypes.IoTJobAbortConfig? = nil,
            jobExecutionsRolloutConfig: GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig? = nil,
            timeoutConfig: GreengrassV2ClientTypes.IoTJobTimeoutConfig? = nil
        )
        {
            self.abortConfig = abortConfig
            self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
            self.timeoutConfig = timeoutConfig
        }
    }

}

extension GreengrassV2ClientTypes.DeploymentPolicies: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentUpdatePolicy
        case configurationValidationPolicy
        case failureHandlingPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentUpdatePolicy = self.componentUpdatePolicy {
            try encodeContainer.encode(componentUpdatePolicy, forKey: .componentUpdatePolicy)
        }
        if let configurationValidationPolicy = self.configurationValidationPolicy {
            try encodeContainer.encode(configurationValidationPolicy, forKey: .configurationValidationPolicy)
        }
        if let failureHandlingPolicy = self.failureHandlingPolicy {
            try encodeContainer.encode(failureHandlingPolicy.rawValue, forKey: .failureHandlingPolicy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureHandlingPolicyDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentFailureHandlingPolicy.self, forKey: .failureHandlingPolicy)
        failureHandlingPolicy = failureHandlingPolicyDecoded
        let componentUpdatePolicyDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy.self, forKey: .componentUpdatePolicy)
        componentUpdatePolicy = componentUpdatePolicyDecoded
        let configurationValidationPolicyDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy.self, forKey: .configurationValidationPolicy)
        configurationValidationPolicy = configurationValidationPolicyDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about policies that define how a deployment updates components and handles failure.
    public struct DeploymentPolicies: Swift.Equatable {
        /// The component update policy for the configuration deployment. This policy defines when it's safe to deploy the configuration to devices.
        public var componentUpdatePolicy: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy?
        /// The configuration validation policy for the configuration deployment. This policy defines how long each component has to validate its configure updates.
        public var configurationValidationPolicy: GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy?
        /// The failure handling policy for the configuration deployment. This policy defines what to do if the deployment fails. Default: ROLLBACK
        public var failureHandlingPolicy: GreengrassV2ClientTypes.DeploymentFailureHandlingPolicy?

        public init(
            componentUpdatePolicy: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy? = nil,
            configurationValidationPolicy: GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy? = nil,
            failureHandlingPolicy: GreengrassV2ClientTypes.DeploymentFailureHandlingPolicy? = nil
        )
        {
            self.componentUpdatePolicy = componentUpdatePolicy
            self.configurationValidationPolicy = configurationValidationPolicy
            self.failureHandlingPolicy = failureHandlingPolicy
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case canceled
        case completed
        case failed
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .active,
                .canceled,
                .completed,
                .failed,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension DescribeComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/greengrass/v2/components/\(arn.urlPercentEncoding())/metadata"
    }
}

public struct DescribeComponentInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DescribeComponentInputBody: Swift.Equatable {
}

extension DescribeComponentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.componentName = output.componentName
            self.componentVersion = output.componentVersion
            self.creationTimestamp = output.creationTimestamp
            self.description = output.description
            self.platforms = output.platforms
            self.publisher = output.publisher
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.componentName = nil
            self.componentVersion = nil
            self.creationTimestamp = nil
            self.description = nil
            self.platforms = nil
            self.publisher = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct DescribeComponentOutput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
    public var arn: Swift.String?
    /// The name of the component.
    public var componentName: Swift.String?
    /// The version of the component.
    public var componentVersion: Swift.String?
    /// The time at which the component was created, expressed in ISO 8601 format.
    public var creationTimestamp: ClientRuntime.Date?
    /// The description of the component version.
    public var description: Swift.String?
    /// The platforms that the component version supports.
    public var platforms: [GreengrassV2ClientTypes.ComponentPlatform]?
    /// The publisher of the component version.
    public var publisher: Swift.String?
    /// The status of the component version in IoT Greengrass V2. This status is different from the status of the component on a core device.
    public var status: GreengrassV2ClientTypes.CloudComponentStatus?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        componentName: Swift.String? = nil,
        componentVersion: Swift.String? = nil,
        creationTimestamp: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        platforms: [GreengrassV2ClientTypes.ComponentPlatform]? = nil,
        publisher: Swift.String? = nil,
        status: GreengrassV2ClientTypes.CloudComponentStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.componentName = componentName
        self.componentVersion = componentVersion
        self.creationTimestamp = creationTimestamp
        self.description = description
        self.platforms = platforms
        self.publisher = publisher
        self.status = status
        self.tags = tags
    }
}

struct DescribeComponentOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let componentName: Swift.String?
    let componentVersion: Swift.String?
    let creationTimestamp: ClientRuntime.Date?
    let publisher: Swift.String?
    let description: Swift.String?
    let status: GreengrassV2ClientTypes.CloudComponentStatus?
    let platforms: [GreengrassV2ClientTypes.ComponentPlatform]?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentName
        case componentVersion
        case creationTimestamp
        case description
        case platforms
        case publisher
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let publisherDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publisher)
        publisher = publisherDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.CloudComponentStatus.self, forKey: .status)
        status = statusDecoded
        let platformsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ComponentPlatform?].self, forKey: .platforms)
        var platformsDecoded0:[GreengrassV2ClientTypes.ComponentPlatform]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [GreengrassV2ClientTypes.ComponentPlatform]()
            for structure0 in platformsContainer {
                if let structure0 = structure0 {
                    platformsDecoded0?.append(structure0)
                }
            }
        }
        platforms = platformsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains a request to disassociate a client device from a core device. The [BatchDisassociateClientDeviceWithCoreDevice](https://docs.aws.amazon.com/greengrass/v2/APIReference/API_BatchDisassociateClientDeviceWithCoreDevice.html) operation consumes a list of these requests.
    public struct DisassociateClientDeviceFromCoreDeviceEntry: Swift.Equatable {
        /// The name of the IoT thing that represents the client device to disassociate.
        /// This member is required.
        public var thingName: Swift.String?

        public init(
            thingName: Swift.String? = nil
        )
        {
            self.thingName = thingName
        }
    }

}

extension GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let thingName = self.thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains an error that occurs from a request to disassociate a client device from a core device. The [BatchDisassociateClientDeviceWithCoreDevice](https://docs.aws.amazon.com/greengrass/v2/APIReference/API_BatchDisassociateClientDeviceWithCoreDevice.html) operation returns a list of these errors.
    public struct DisassociateClientDeviceFromCoreDeviceErrorEntry: Swift.Equatable {
        /// The error code for the request.
        public var code: Swift.String?
        /// A message that provides additional information about the error.
        public var message: Swift.String?
        /// The name of the IoT thing whose disassociate request failed.
        public var thingName: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.thingName = thingName
        }
    }

}

extension DisassociateServiceRoleFromAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/servicerole"
    }
}

public struct DisassociateServiceRoleFromAccountInput: Swift.Equatable {

    public init() { }
}

struct DisassociateServiceRoleFromAccountInputBody: Swift.Equatable {
}

extension DisassociateServiceRoleFromAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateServiceRoleFromAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateServiceRoleFromAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.disassociatedAt = output.disassociatedAt
        } else {
            self.disassociatedAt = nil
        }
    }
}

public struct DisassociateServiceRoleFromAccountOutput: Swift.Equatable {
    /// The time when the service role was disassociated from IoT Greengrass for your Amazon Web Services account in this Amazon Web Services Region.
    public var disassociatedAt: Swift.String?

    public init(
        disassociatedAt: Swift.String? = nil
    )
    {
        self.disassociatedAt = disassociatedAt
    }
}

struct DisassociateServiceRoleFromAccountOutputBody: Swift.Equatable {
    let disassociatedAt: Swift.String?
}

extension DisassociateServiceRoleFromAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disassociatedAt = "DisassociatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disassociatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disassociatedAt)
        disassociatedAt = disassociatedAtDecoded
    }
}

enum DisassociateServiceRoleFromAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassV2ClientTypes.EffectiveDeployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreDeviceExecutionStatus
        case creationTimestamp
        case deploymentId
        case deploymentName
        case description
        case iotJobArn
        case iotJobId
        case modifiedTimestamp
        case reason
        case statusDetails
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreDeviceExecutionStatus = self.coreDeviceExecutionStatus {
            try encodeContainer.encode(coreDeviceExecutionStatus.rawValue, forKey: .coreDeviceExecutionStatus)
        }
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encodeTimestamp(creationTimestamp, format: .epochSeconds, forKey: .creationTimestamp)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentName = self.deploymentName {
            try encodeContainer.encode(deploymentName, forKey: .deploymentName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iotJobArn = self.iotJobArn {
            try encodeContainer.encode(iotJobArn, forKey: .iotJobArn)
        }
        if let iotJobId = self.iotJobId {
            try encodeContainer.encode(iotJobId, forKey: .iotJobId)
        }
        if let modifiedTimestamp = self.modifiedTimestamp {
            try encodeContainer.encodeTimestamp(modifiedTimestamp, format: .epochSeconds, forKey: .modifiedTimestamp)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let statusDetails = self.statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let iotJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobId)
        iotJobId = iotJobIdDecoded
        let iotJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobArn)
        iotJobArn = iotJobArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let coreDeviceExecutionStatusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.EffectiveDeploymentExecutionStatus.self, forKey: .coreDeviceExecutionStatus)
        coreDeviceExecutionStatus = coreDeviceExecutionStatusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.EffectiveDeploymentStatusDetails.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a deployment job that IoT Greengrass sends to a Greengrass core device.
    public struct EffectiveDeployment: Swift.Equatable {
        /// The status of the deployment job on the Greengrass core device.
        ///
        /// * IN_PROGRESS – The deployment job is running.
        ///
        /// * QUEUED – The deployment job is in the job queue and waiting to run.
        ///
        /// * FAILED – The deployment failed. For more information, see the statusDetails field.
        ///
        /// * COMPLETED – The deployment to an IoT thing was completed successfully.
        ///
        /// * TIMED_OUT – The deployment didn't complete in the allotted time.
        ///
        /// * CANCELED – The deployment was canceled by the user.
        ///
        /// * REJECTED – The deployment was rejected. For more information, see the statusDetails field.
        ///
        /// * SUCCEEDED – The deployment to an IoT thing group was completed successfully.
        /// This member is required.
        public var coreDeviceExecutionStatus: GreengrassV2ClientTypes.EffectiveDeploymentExecutionStatus?
        /// The time at which the deployment was created, expressed in ISO 8601 format.
        /// This member is required.
        public var creationTimestamp: ClientRuntime.Date?
        /// The ID of the deployment.
        /// This member is required.
        public var deploymentId: Swift.String?
        /// The name of the deployment.
        /// This member is required.
        public var deploymentName: Swift.String?
        /// The description of the deployment job.
        public var description: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IoT job that applies the deployment to target devices.
        public var iotJobArn: Swift.String?
        /// The ID of the IoT job that applies the deployment to target devices.
        public var iotJobId: Swift.String?
        /// The time at which the deployment job was last modified, expressed in ISO 8601 format.
        /// This member is required.
        public var modifiedTimestamp: ClientRuntime.Date?
        /// The reason code for the update, if the job was updated.
        public var reason: Swift.String?
        /// The status details that explain why a deployment has an error. This response will be null if the deployment is in a success state.
        public var statusDetails: GreengrassV2ClientTypes.EffectiveDeploymentStatusDetails?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the target IoT thing or thing group.
        /// This member is required.
        public var targetArn: Swift.String?

        public init(
            coreDeviceExecutionStatus: GreengrassV2ClientTypes.EffectiveDeploymentExecutionStatus? = nil,
            creationTimestamp: ClientRuntime.Date? = nil,
            deploymentId: Swift.String? = nil,
            deploymentName: Swift.String? = nil,
            description: Swift.String? = nil,
            iotJobArn: Swift.String? = nil,
            iotJobId: Swift.String? = nil,
            modifiedTimestamp: ClientRuntime.Date? = nil,
            reason: Swift.String? = nil,
            statusDetails: GreengrassV2ClientTypes.EffectiveDeploymentStatusDetails? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.coreDeviceExecutionStatus = coreDeviceExecutionStatus
            self.creationTimestamp = creationTimestamp
            self.deploymentId = deploymentId
            self.deploymentName = deploymentName
            self.description = description
            self.iotJobArn = iotJobArn
            self.iotJobId = iotJobId
            self.modifiedTimestamp = modifiedTimestamp
            self.reason = reason
            self.statusDetails = statusDetails
            self.targetArn = targetArn
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum EffectiveDeploymentExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case inProgress
        case queued
        case rejected
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [EffectiveDeploymentExecutionStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .inProgress,
                .queued,
                .rejected,
                .succeeded,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .rejected: return "REJECTED"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EffectiveDeploymentExecutionStatus(rawValue: rawValue) ?? EffectiveDeploymentExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.EffectiveDeploymentStatusDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorStack
        case errorTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorStack = errorStack {
            var errorStackContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorStack)
            for effectivedeploymenterrorcode0 in errorStack {
                try errorStackContainer.encode(effectivedeploymenterrorcode0)
            }
        }
        if let errorTypes = errorTypes {
            var errorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorTypes)
            for effectivedeploymenterrortype0 in errorTypes {
                try errorTypesContainer.encode(effectivedeploymenterrortype0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorStackContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .errorStack)
        var errorStackDecoded0:[Swift.String]? = nil
        if let errorStackContainer = errorStackContainer {
            errorStackDecoded0 = [Swift.String]()
            for string0 in errorStackContainer {
                if let string0 = string0 {
                    errorStackDecoded0?.append(string0)
                }
            }
        }
        errorStack = errorStackDecoded0
        let errorTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .errorTypes)
        var errorTypesDecoded0:[Swift.String]? = nil
        if let errorTypesContainer = errorTypesContainer {
            errorTypesDecoded0 = [Swift.String]()
            for string0 in errorTypesContainer {
                if let string0 = string0 {
                    errorTypesDecoded0?.append(string0)
                }
            }
        }
        errorTypes = errorTypesDecoded0
    }
}

extension GreengrassV2ClientTypes {
    /// Contains all error-related information for the deployment record. The status details will be null if the deployment is in a success state. Greengrass nucleus v2.8.0 or later is required to get an accurate errorStack and errorTypes response. This field will not be returned for earlier Greengrass nucleus versions.
    public struct EffectiveDeploymentStatusDetails: Swift.Equatable {
        /// Contains an ordered list of short error codes that range from the most generic error to the most specific one. The error codes describe the reason for failure whenever the coreDeviceExecutionStatus is in a failed state. The response will be an empty list if there is no error.
        public var errorStack: [Swift.String]?
        /// Contains tags which describe the error. You can use the error types to classify errors to assist with remediating the failure. The response will be an empty list if there is no error.
        public var errorTypes: [Swift.String]?

        public init(
            errorStack: [Swift.String]? = nil,
            errorTypes: [Swift.String]? = nil
        )
        {
            self.errorStack = errorStack
            self.errorTypes = errorTypes
        }
    }

}

extension GetComponentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let recipeOutputFormat = recipeOutputFormat {
                let recipeOutputFormatQueryItem = ClientRuntime.URLQueryItem(name: "recipeOutputFormat".urlPercentEncoding(), value: Swift.String(recipeOutputFormat.rawValue).urlPercentEncoding())
                items.append(recipeOutputFormatQueryItem)
            }
            return items
        }
    }
}

extension GetComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/greengrass/v2/components/\(arn.urlPercentEncoding())"
    }
}

public struct GetComponentInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
    /// This member is required.
    public var arn: Swift.String?
    /// The format of the recipe.
    public var recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat?

    public init(
        arn: Swift.String? = nil,
        recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat? = nil
    )
    {
        self.arn = arn
        self.recipeOutputFormat = recipeOutputFormat
    }
}

struct GetComponentInputBody: Swift.Equatable {
}

extension GetComponentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.recipe = output.recipe
            self.recipeOutputFormat = output.recipeOutputFormat
            self.tags = output.tags
        } else {
            self.recipe = nil
            self.recipeOutputFormat = nil
            self.tags = nil
        }
    }
}

public struct GetComponentOutput: Swift.Equatable {
    /// The recipe of the component version.
    /// This member is required.
    public var recipe: ClientRuntime.Data?
    /// The format of the recipe.
    /// This member is required.
    public var recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?

    public init(
        recipe: ClientRuntime.Data? = nil,
        recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.recipe = recipe
        self.recipeOutputFormat = recipeOutputFormat
        self.tags = tags
    }
}

struct GetComponentOutputBody: Swift.Equatable {
    let recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat?
    let recipe: ClientRuntime.Data?
    let tags: [Swift.String:Swift.String]?
}

extension GetComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipe
        case recipeOutputFormat
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeOutputFormatDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.RecipeOutputFormat.self, forKey: .recipeOutputFormat)
        recipeOutputFormat = recipeOutputFormatDecoded
        let recipeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .recipe)
        recipe = recipeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetComponentVersionArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        guard let artifactName = artifactName else {
            return nil
        }
        return "/greengrass/v2/components/\(arn.urlPercentEncoding())/artifacts/\(artifactName.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

public struct GetComponentVersionArtifactInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version. Specify the ARN of a public or a Lambda component version.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the artifact. You can use the [GetComponent](https://docs.aws.amazon.com/greengrass/v2/APIReference/API_GetComponent.html) operation to download the component recipe, which includes the URI of the artifact. The artifact name is the section of the URI after the scheme. For example, in the artifact URI greengrass:SomeArtifact.zip, the artifact name is SomeArtifact.zip.
    /// This member is required.
    public var artifactName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        artifactName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.artifactName = artifactName
    }
}

struct GetComponentVersionArtifactInputBody: Swift.Equatable {
}

extension GetComponentVersionArtifactInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentVersionArtifactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetComponentVersionArtifactOutputBody = try responseDecoder.decode(responseBody: data)
            self.preSignedUrl = output.preSignedUrl
        } else {
            self.preSignedUrl = nil
        }
    }
}

public struct GetComponentVersionArtifactOutput: Swift.Equatable {
    /// The URL of the artifact.
    /// This member is required.
    public var preSignedUrl: Swift.String?

    public init(
        preSignedUrl: Swift.String? = nil
    )
    {
        self.preSignedUrl = preSignedUrl
    }
}

struct GetComponentVersionArtifactOutputBody: Swift.Equatable {
    let preSignedUrl: Swift.String?
}

extension GetComponentVersionArtifactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preSignedUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preSignedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preSignedUrl)
        preSignedUrl = preSignedUrlDecoded
    }
}

enum GetComponentVersionArtifactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConnectivityInfoInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/connectivityInfo"
    }
}

public struct GetConnectivityInfoInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        thingName: Swift.String? = nil
    )
    {
        self.thingName = thingName
    }
}

struct GetConnectivityInfoInputBody: Swift.Equatable {
}

extension GetConnectivityInfoInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectivityInfoOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConnectivityInfoOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectivityInfo = output.connectivityInfo
            self.message = output.message
        } else {
            self.connectivityInfo = nil
            self.message = nil
        }
    }
}

public struct GetConnectivityInfoOutput: Swift.Equatable {
    /// The connectivity information for the core device.
    public var connectivityInfo: [GreengrassV2ClientTypes.ConnectivityInfo]?
    /// A message about the connectivity information request.
    public var message: Swift.String?

    public init(
        connectivityInfo: [GreengrassV2ClientTypes.ConnectivityInfo]? = nil,
        message: Swift.String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.message = message
    }
}

struct GetConnectivityInfoOutputBody: Swift.Equatable {
    let connectivityInfo: [GreengrassV2ClientTypes.ConnectivityInfo]?
    let message: Swift.String?
}

extension GetConnectivityInfoOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectivityInfo = "ConnectivityInfo"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectivityInfoContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ConnectivityInfo?].self, forKey: .connectivityInfo)
        var connectivityInfoDecoded0:[GreengrassV2ClientTypes.ConnectivityInfo]? = nil
        if let connectivityInfoContainer = connectivityInfoContainer {
            connectivityInfoDecoded0 = [GreengrassV2ClientTypes.ConnectivityInfo]()
            for structure0 in connectivityInfoContainer {
                if let structure0 = structure0 {
                    connectivityInfoDecoded0?.append(structure0)
                }
            }
        }
        connectivityInfo = connectivityInfoDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum GetConnectivityInfoOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCoreDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDeviceThingName = coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())"
    }
}

public struct GetCoreDeviceInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?

    public init(
        coreDeviceThingName: Swift.String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
    }
}

struct GetCoreDeviceInputBody: Swift.Equatable {
}

extension GetCoreDeviceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCoreDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCoreDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.architecture = output.architecture
            self.coreDeviceThingName = output.coreDeviceThingName
            self.coreVersion = output.coreVersion
            self.lastStatusUpdateTimestamp = output.lastStatusUpdateTimestamp
            self.platform = output.platform
            self.status = output.status
            self.tags = output.tags
        } else {
            self.architecture = nil
            self.coreDeviceThingName = nil
            self.coreVersion = nil
            self.lastStatusUpdateTimestamp = nil
            self.platform = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetCoreDeviceOutput: Swift.Equatable {
    /// The computer architecture of the core device.
    public var architecture: Swift.String?
    /// The name of the core device. This is also the name of the IoT thing.
    public var coreDeviceThingName: Swift.String?
    /// The version of the IoT Greengrass Core software that the core device runs. This version is equivalent to the version of the Greengrass nucleus component that runs on the core device. For more information, see the [Greengrass nucleus component](https://docs.aws.amazon.com/greengrass/v2/developerguide/greengrass-nucleus-component.html) in the IoT Greengrass V2 Developer Guide.
    public var coreVersion: Swift.String?
    /// The time at which the core device's status last updated, expressed in ISO 8601 format.
    public var lastStatusUpdateTimestamp: ClientRuntime.Date?
    /// The operating system platform that the core device runs.
    public var platform: Swift.String?
    /// The status of the core device. The core device status can be:
    ///
    /// * HEALTHY – The IoT Greengrass Core software and all components run on the core device without issue.
    ///
    /// * UNHEALTHY – The IoT Greengrass Core software or a component is in a failed state on the core device.
    public var status: GreengrassV2ClientTypes.CoreDeviceStatus?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?

    public init(
        architecture: Swift.String? = nil,
        coreDeviceThingName: Swift.String? = nil,
        coreVersion: Swift.String? = nil,
        lastStatusUpdateTimestamp: ClientRuntime.Date? = nil,
        platform: Swift.String? = nil,
        status: GreengrassV2ClientTypes.CoreDeviceStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.coreDeviceThingName = coreDeviceThingName
        self.coreVersion = coreVersion
        self.lastStatusUpdateTimestamp = lastStatusUpdateTimestamp
        self.platform = platform
        self.status = status
        self.tags = tags
    }
}

struct GetCoreDeviceOutputBody: Swift.Equatable {
    let coreDeviceThingName: Swift.String?
    let coreVersion: Swift.String?
    let platform: Swift.String?
    let architecture: Swift.String?
    let status: GreengrassV2ClientTypes.CoreDeviceStatus?
    let lastStatusUpdateTimestamp: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetCoreDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case coreDeviceThingName
        case coreVersion
        case lastStatusUpdateTimestamp
        case platform
        case status
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreDeviceThingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreDeviceThingName)
        coreDeviceThingName = coreDeviceThingNameDecoded
        let coreVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreVersion)
        coreVersion = coreVersionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecture)
        architecture = architectureDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.CoreDeviceStatus.self, forKey: .status)
        status = statusDecoded
        let lastStatusUpdateTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStatusUpdateTimestamp)
        lastStatusUpdateTimestamp = lastStatusUpdateTimestampDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetCoreDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/greengrass/v2/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

public struct GetDeploymentInput: Swift.Equatable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct GetDeploymentInputBody: Swift.Equatable {
}

extension GetDeploymentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.components = output.components
            self.creationTimestamp = output.creationTimestamp
            self.deploymentId = output.deploymentId
            self.deploymentName = output.deploymentName
            self.deploymentPolicies = output.deploymentPolicies
            self.deploymentStatus = output.deploymentStatus
            self.iotJobArn = output.iotJobArn
            self.iotJobConfiguration = output.iotJobConfiguration
            self.iotJobId = output.iotJobId
            self.isLatestForTarget = output.isLatestForTarget
            self.parentTargetArn = output.parentTargetArn
            self.revisionId = output.revisionId
            self.tags = output.tags
            self.targetArn = output.targetArn
        } else {
            self.components = nil
            self.creationTimestamp = nil
            self.deploymentId = nil
            self.deploymentName = nil
            self.deploymentPolicies = nil
            self.deploymentStatus = nil
            self.iotJobArn = nil
            self.iotJobConfiguration = nil
            self.iotJobId = nil
            self.isLatestForTarget = false
            self.parentTargetArn = nil
            self.revisionId = nil
            self.tags = nil
            self.targetArn = nil
        }
    }
}

public struct GetDeploymentOutput: Swift.Equatable {
    /// The components to deploy. This is a dictionary, where each key is the name of a component, and each key's value is the version and configuration to deploy for that component.
    public var components: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]?
    /// The time at which the deployment was created, expressed in ISO 8601 format.
    public var creationTimestamp: ClientRuntime.Date?
    /// The ID of the deployment.
    public var deploymentId: Swift.String?
    /// The name of the deployment.
    public var deploymentName: Swift.String?
    /// The deployment policies for the deployment. These policies define how the deployment updates components and handles failure.
    public var deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies?
    /// The status of the deployment.
    public var deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IoT job that applies the deployment to target devices.
    public var iotJobArn: Swift.String?
    /// The job configuration for the deployment configuration. The job configuration specifies the rollout, timeout, and stop configurations for the deployment configuration.
    public var iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration?
    /// The ID of the IoT job that applies the deployment to target devices.
    public var iotJobId: Swift.String?
    /// Whether or not the deployment is the latest revision for its target.
    public var isLatestForTarget: Swift.Bool
    /// The parent deployment's target [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) within a subdeployment.
    public var parentTargetArn: Swift.String?
    /// The revision number of the deployment.
    public var revisionId: Swift.String?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the target IoT thing or thing group.
    public var targetArn: Swift.String?

    public init(
        components: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]? = nil,
        creationTimestamp: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentName: Swift.String? = nil,
        deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies? = nil,
        deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus? = nil,
        iotJobArn: Swift.String? = nil,
        iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration? = nil,
        iotJobId: Swift.String? = nil,
        isLatestForTarget: Swift.Bool = false,
        parentTargetArn: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.components = components
        self.creationTimestamp = creationTimestamp
        self.deploymentId = deploymentId
        self.deploymentName = deploymentName
        self.deploymentPolicies = deploymentPolicies
        self.deploymentStatus = deploymentStatus
        self.iotJobArn = iotJobArn
        self.iotJobConfiguration = iotJobConfiguration
        self.iotJobId = iotJobId
        self.isLatestForTarget = isLatestForTarget
        self.parentTargetArn = parentTargetArn
        self.revisionId = revisionId
        self.tags = tags
        self.targetArn = targetArn
    }
}

struct GetDeploymentOutputBody: Swift.Equatable {
    let targetArn: Swift.String?
    let revisionId: Swift.String?
    let deploymentId: Swift.String?
    let deploymentName: Swift.String?
    let deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus?
    let iotJobId: Swift.String?
    let iotJobArn: Swift.String?
    let components: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]?
    let deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies?
    let iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration?
    let creationTimestamp: ClientRuntime.Date?
    let isLatestForTarget: Swift.Bool
    let parentTargetArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components
        case creationTimestamp
        case deploymentId
        case deploymentName
        case deploymentPolicies
        case deploymentStatus
        case iotJobArn
        case iotJobConfiguration
        case iotJobId
        case isLatestForTarget
        case parentTargetArn
        case revisionId
        case tags
        case targetArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let iotJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobId)
        iotJobId = iotJobIdDecoded
        let iotJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobArn)
        iotJobArn = iotJobArnDecoded
        let componentsContainer = try containerValues.decodeIfPresent([Swift.String: GreengrassV2ClientTypes.ComponentDeploymentSpecification?].self, forKey: .components)
        var componentsDecoded0: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]()
            for (key0, componentdeploymentspecification0) in componentsContainer {
                if let componentdeploymentspecification0 = componentdeploymentspecification0 {
                    componentsDecoded0?[key0] = componentdeploymentspecification0
                }
            }
        }
        components = componentsDecoded0
        let deploymentPoliciesDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentPolicies.self, forKey: .deploymentPolicies)
        deploymentPolicies = deploymentPoliciesDecoded
        let iotJobConfigurationDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentIoTJobConfiguration.self, forKey: .iotJobConfiguration)
        iotJobConfiguration = iotJobConfigurationDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let isLatestForTargetDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLatestForTarget) ?? false
        isLatestForTarget = isLatestForTargetDecoded
        let parentTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentTargetArn)
        parentTargetArn = parentTargetArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceRoleForAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/servicerole"
    }
}

public struct GetServiceRoleForAccountInput: Swift.Equatable {

    public init() { }
}

struct GetServiceRoleForAccountInputBody: Swift.Equatable {
}

extension GetServiceRoleForAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceRoleForAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceRoleForAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.associatedAt = output.associatedAt
            self.roleArn = output.roleArn
        } else {
            self.associatedAt = nil
            self.roleArn = nil
        }
    }
}

public struct GetServiceRoleForAccountOutput: Swift.Equatable {
    /// The time when the service role was associated with IoT Greengrass for your Amazon Web Services account in this Amazon Web Services Region.
    public var associatedAt: Swift.String?
    /// The ARN of the service role that is associated with IoT Greengrass for your Amazon Web Services account in this Amazon Web Services Region.
    public var roleArn: Swift.String?

    public init(
        associatedAt: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
        self.roleArn = roleArn
    }
}

struct GetServiceRoleForAccountOutputBody: Swift.Equatable {
    let associatedAt: Swift.String?
    let roleArn: Swift.String?
}

extension GetServiceRoleForAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedAt = "AssociatedAt"
        case roleArn = "RoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum GetServiceRoleForAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassV2ClientTypes.InstalledComponent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentVersion
        case isRoot
        case lastInstallationSource
        case lastReportedTimestamp
        case lastStatusChangeTimestamp
        case lifecycleState
        case lifecycleStateDetails
        case lifecycleStatusCodes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = self.componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if isRoot != false {
            try encodeContainer.encode(isRoot, forKey: .isRoot)
        }
        if let lastInstallationSource = self.lastInstallationSource {
            try encodeContainer.encode(lastInstallationSource, forKey: .lastInstallationSource)
        }
        if let lastReportedTimestamp = self.lastReportedTimestamp {
            try encodeContainer.encodeTimestamp(lastReportedTimestamp, format: .epochSeconds, forKey: .lastReportedTimestamp)
        }
        if let lastStatusChangeTimestamp = self.lastStatusChangeTimestamp {
            try encodeContainer.encodeTimestamp(lastStatusChangeTimestamp, format: .epochSeconds, forKey: .lastStatusChangeTimestamp)
        }
        if let lifecycleState = self.lifecycleState {
            try encodeContainer.encode(lifecycleState.rawValue, forKey: .lifecycleState)
        }
        if let lifecycleStateDetails = self.lifecycleStateDetails {
            try encodeContainer.encode(lifecycleStateDetails, forKey: .lifecycleStateDetails)
        }
        if let lifecycleStatusCodes = lifecycleStatusCodes {
            var lifecycleStatusCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lifecycleStatusCodes)
            for installedcomponentlifecyclestatuscode0 in lifecycleStatusCodes {
                try lifecycleStatusCodesContainer.encode(installedcomponentlifecyclestatuscode0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let lifecycleStateDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.InstalledComponentLifecycleState.self, forKey: .lifecycleState)
        lifecycleState = lifecycleStateDecoded
        let lifecycleStateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleStateDetails)
        lifecycleStateDetails = lifecycleStateDetailsDecoded
        let isRootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRoot) ?? false
        isRoot = isRootDecoded
        let lastStatusChangeTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastStatusChangeTimestamp)
        lastStatusChangeTimestamp = lastStatusChangeTimestampDecoded
        let lastReportedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastReportedTimestamp)
        lastReportedTimestamp = lastReportedTimestampDecoded
        let lastInstallationSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastInstallationSource)
        lastInstallationSource = lastInstallationSourceDecoded
        let lifecycleStatusCodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lifecycleStatusCodes)
        var lifecycleStatusCodesDecoded0:[Swift.String]? = nil
        if let lifecycleStatusCodesContainer = lifecycleStatusCodesContainer {
            lifecycleStatusCodesDecoded0 = [Swift.String]()
            for string0 in lifecycleStatusCodesContainer {
                if let string0 = string0 {
                    lifecycleStatusCodesDecoded0?.append(string0)
                }
            }
        }
        lifecycleStatusCodes = lifecycleStatusCodesDecoded0
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component on a Greengrass core device.
    public struct InstalledComponent: Swift.Equatable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// Whether or not the component is a root component.
        public var isRoot: Swift.Bool
        /// The most recent deployment source that brought the component to the Greengrass core device. For a thing group deployment or thing deployment, the source will be the The ID of the deployment. and for local deployments it will be LOCAL. Any deployment will attempt to reinstall currently broken components on the device, which will update the last installation source.
        public var lastInstallationSource: Swift.String?
        /// The last time the Greengrass core device sent a message containing a component's state to the Amazon Web Services Cloud. A component does not need to see a state change for this field to update.
        public var lastReportedTimestamp: ClientRuntime.Date?
        /// The status of how current the data is. This response is based off of component state changes. The status reflects component disruptions and deployments. If a component only sees a configuration update during a deployment, it might not undergo a state change and this status would not be updated.
        public var lastStatusChangeTimestamp: ClientRuntime.Date?
        /// The lifecycle state of the component.
        public var lifecycleState: GreengrassV2ClientTypes.InstalledComponentLifecycleState?
        /// A detailed response about the lifecycle state of the component that explains the reason why a component has an error or is broken.
        public var lifecycleStateDetails: Swift.String?
        /// The status codes that indicate the reason for failure whenever the lifecycleState has an error or is in a broken state. Greengrass nucleus v2.8.0 or later is required to get an accurate lifecycleStatusCodes response. This response can be inaccurate in earlier Greengrass nucleus versions.
        public var lifecycleStatusCodes: [Swift.String]?

        public init(
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            isRoot: Swift.Bool = false,
            lastInstallationSource: Swift.String? = nil,
            lastReportedTimestamp: ClientRuntime.Date? = nil,
            lastStatusChangeTimestamp: ClientRuntime.Date? = nil,
            lifecycleState: GreengrassV2ClientTypes.InstalledComponentLifecycleState? = nil,
            lifecycleStateDetails: Swift.String? = nil,
            lifecycleStatusCodes: [Swift.String]? = nil
        )
        {
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.isRoot = isRoot
            self.lastInstallationSource = lastInstallationSource
            self.lastReportedTimestamp = lastReportedTimestamp
            self.lastStatusChangeTimestamp = lastStatusChangeTimestamp
            self.lifecycleState = lifecycleState
            self.lifecycleStateDetails = lifecycleStateDetails
            self.lifecycleStatusCodes = lifecycleStatusCodes
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum InstalledComponentLifecycleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case broken
        case errored
        case finished
        case installed
        case new
        case running
        case starting
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [InstalledComponentLifecycleState] {
            return [
                .broken,
                .errored,
                .finished,
                .installed,
                .new,
                .running,
                .starting,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .broken: return "BROKEN"
            case .errored: return "ERRORED"
            case .finished: return "FINISHED"
            case .installed: return "INSTALLED"
            case .new: return "NEW"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstalledComponentLifecycleState(rawValue: rawValue) ?? InstalledComponentLifecycleState.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes {
    public enum InstalledComponentTopologyFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case root
        case sdkUnknown(Swift.String)

        public static var allCases: [InstalledComponentTopologyFilter] {
            return [
                .all,
                .root,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .root: return "ROOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstalledComponentTopologyFilter(rawValue: rawValue) ?? InstalledComponentTopologyFilter.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// IoT Greengrass can't process your request right now. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The amount of time to wait before you retry the request.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassV2ClientTypes {
    public enum IoTJobAbortAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancel
        case sdkUnknown(Swift.String)

        public static var allCases: [IoTJobAbortAction] {
            return [
                .cancel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IoTJobAbortAction(rawValue: rawValue) ?? IoTJobAbortAction.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.IoTJobAbortConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criteriaList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criteriaList = criteriaList {
            var criteriaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .criteriaList)
            for iotjobabortcriteria0 in criteriaList {
                try criteriaListContainer.encode(iotjobabortcriteria0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criteriaListContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.IoTJobAbortCriteria?].self, forKey: .criteriaList)
        var criteriaListDecoded0:[GreengrassV2ClientTypes.IoTJobAbortCriteria]? = nil
        if let criteriaListContainer = criteriaListContainer {
            criteriaListDecoded0 = [GreengrassV2ClientTypes.IoTJobAbortCriteria]()
            for structure0 in criteriaListContainer {
                if let structure0 = structure0 {
                    criteriaListDecoded0?.append(structure0)
                }
            }
        }
        criteriaList = criteriaListDecoded0
    }
}

extension GreengrassV2ClientTypes {
    /// Contains a list of criteria that define when and how to cancel a configuration deployment.
    public struct IoTJobAbortConfig: Swift.Equatable {
        /// The list of criteria that define when and how to cancel the configuration deployment.
        /// This member is required.
        public var criteriaList: [GreengrassV2ClientTypes.IoTJobAbortCriteria]?

        public init(
            criteriaList: [GreengrassV2ClientTypes.IoTJobAbortCriteria]? = nil
        )
        {
            self.criteriaList = criteriaList
        }
    }

}

extension GreengrassV2ClientTypes.IoTJobAbortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case failureType
        case minNumberOfExecutedThings
        case thresholdPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let failureType = self.failureType {
            try encodeContainer.encode(failureType.rawValue, forKey: .failureType)
        }
        if minNumberOfExecutedThings != 0 {
            try encodeContainer.encode(minNumberOfExecutedThings, forKey: .minNumberOfExecutedThings)
        }
        if thresholdPercentage != 0.0 {
            try encodeContainer.encode(thresholdPercentage, forKey: .thresholdPercentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureTypeDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobExecutionFailureType.self, forKey: .failureType)
        failureType = failureTypeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobAbortAction.self, forKey: .action)
        action = actionDecoded
        let thresholdPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .thresholdPercentage) ?? 0.0
        thresholdPercentage = thresholdPercentageDecoded
        let minNumberOfExecutedThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minNumberOfExecutedThings) ?? 0
        minNumberOfExecutedThings = minNumberOfExecutedThingsDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains criteria that define when and how to cancel a job. The deployment stops if the following conditions are true:
    ///
    /// * The number of things that receive the deployment exceeds the minNumberOfExecutedThings.
    ///
    /// * The percentage of failures with type failureType exceeds the thresholdPercentage.
    public struct IoTJobAbortCriteria: Swift.Equatable {
        /// The action to perform when the criteria are met.
        /// This member is required.
        public var action: GreengrassV2ClientTypes.IoTJobAbortAction?
        /// The type of job deployment failure that can cancel a job.
        /// This member is required.
        public var failureType: GreengrassV2ClientTypes.IoTJobExecutionFailureType?
        /// The minimum number of things that receive the configuration before the job can cancel.
        /// This member is required.
        public var minNumberOfExecutedThings: Swift.Int
        /// The minimum percentage of failureType failures that occur before the job can cancel. This parameter supports up to two digits after the decimal (for example, you can specify 10.9 or 10.99, but not 10.999).
        /// This member is required.
        public var thresholdPercentage: Swift.Double

        public init(
            action: GreengrassV2ClientTypes.IoTJobAbortAction? = nil,
            failureType: GreengrassV2ClientTypes.IoTJobExecutionFailureType? = nil,
            minNumberOfExecutedThings: Swift.Int = 0,
            thresholdPercentage: Swift.Double = 0.0
        )
        {
            self.action = action
            self.failureType = failureType
            self.minNumberOfExecutedThings = minNumberOfExecutedThings
            self.thresholdPercentage = thresholdPercentage
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum IoTJobExecutionFailureType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case failed
        case rejected
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [IoTJobExecutionFailureType] {
            return [
                .all,
                .failed,
                .rejected,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .rejected: return "REJECTED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IoTJobExecutionFailureType(rawValue: rawValue) ?? IoTJobExecutionFailureType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exponentialRate
        case maximumPerMinute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exponentialRate = self.exponentialRate {
            try encodeContainer.encode(exponentialRate, forKey: .exponentialRate)
        }
        if let maximumPerMinute = self.maximumPerMinute {
            try encodeContainer.encode(maximumPerMinute, forKey: .maximumPerMinute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exponentialRateDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobExponentialRolloutRate.self, forKey: .exponentialRate)
        exponentialRate = exponentialRateDecoded
        let maximumPerMinuteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumPerMinute)
        maximumPerMinute = maximumPerMinuteDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about the rollout configuration for a job. This configuration defines the rate at which the job deploys a configuration to a fleet of target devices.
    public struct IoTJobExecutionsRolloutConfig: Swift.Equatable {
        /// The exponential rate to increase the job rollout rate.
        public var exponentialRate: GreengrassV2ClientTypes.IoTJobExponentialRolloutRate?
        /// The maximum number of devices that receive a pending job notification, per minute.
        public var maximumPerMinute: Swift.Int?

        public init(
            exponentialRate: GreengrassV2ClientTypes.IoTJobExponentialRolloutRate? = nil,
            maximumPerMinute: Swift.Int? = nil
        )
        {
            self.exponentialRate = exponentialRate
            self.maximumPerMinute = maximumPerMinute
        }
    }

}

extension GreengrassV2ClientTypes.IoTJobExponentialRolloutRate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseRatePerMinute
        case incrementFactor
        case rateIncreaseCriteria
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if baseRatePerMinute != 0 {
            try encodeContainer.encode(baseRatePerMinute, forKey: .baseRatePerMinute)
        }
        if incrementFactor != 0.0 {
            try encodeContainer.encode(incrementFactor, forKey: .incrementFactor)
        }
        if let rateIncreaseCriteria = self.rateIncreaseCriteria {
            try encodeContainer.encode(rateIncreaseCriteria, forKey: .rateIncreaseCriteria)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseRatePerMinuteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .baseRatePerMinute) ?? 0
        baseRatePerMinute = baseRatePerMinuteDecoded
        let incrementFactorDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .incrementFactor) ?? 0.0
        incrementFactor = incrementFactorDecoded
        let rateIncreaseCriteriaDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria.self, forKey: .rateIncreaseCriteria)
        rateIncreaseCriteria = rateIncreaseCriteriaDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about an exponential rollout rate for a configuration deployment job.
    public struct IoTJobExponentialRolloutRate: Swift.Equatable {
        /// The minimum number of devices that receive a pending job notification, per minute, when the job starts. This parameter defines the initial rollout rate of the job.
        /// This member is required.
        public var baseRatePerMinute: Swift.Int
        /// The exponential factor to increase the rollout rate for the job. This parameter supports up to one digit after the decimal (for example, you can specify 1.5, but not 1.55).
        /// This member is required.
        public var incrementFactor: Swift.Double
        /// The criteria to increase the rollout rate for the job.
        /// This member is required.
        public var rateIncreaseCriteria: GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria?

        public init(
            baseRatePerMinute: Swift.Int = 0,
            incrementFactor: Swift.Double = 0.0,
            rateIncreaseCriteria: GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria? = nil
        )
        {
            self.baseRatePerMinute = baseRatePerMinute
            self.incrementFactor = incrementFactor
            self.rateIncreaseCriteria = rateIncreaseCriteria
        }
    }

}

extension GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfNotifiedThings
        case numberOfSucceededThings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfNotifiedThings = self.numberOfNotifiedThings {
            try encodeContainer.encode(numberOfNotifiedThings, forKey: .numberOfNotifiedThings)
        }
        if let numberOfSucceededThings = self.numberOfSucceededThings {
            try encodeContainer.encode(numberOfSucceededThings, forKey: .numberOfSucceededThings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfNotifiedThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfNotifiedThings)
        numberOfNotifiedThings = numberOfNotifiedThingsDecoded
        let numberOfSucceededThingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfSucceededThings)
        numberOfSucceededThings = numberOfSucceededThingsDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about criteria to meet before a job increases its rollout rate. Specify either numberOfNotifiedThings or numberOfSucceededThings.
    public struct IoTJobRateIncreaseCriteria: Swift.Equatable {
        /// The number of devices to receive the job notification before the rollout rate increases.
        public var numberOfNotifiedThings: Swift.Int?
        /// The number of devices to successfully run the configuration job before the rollout rate increases.
        public var numberOfSucceededThings: Swift.Int?

        public init(
            numberOfNotifiedThings: Swift.Int? = nil,
            numberOfSucceededThings: Swift.Int? = nil
        )
        {
            self.numberOfNotifiedThings = numberOfNotifiedThings
            self.numberOfSucceededThings = numberOfSucceededThings
        }
    }

}

extension GreengrassV2ClientTypes.IoTJobTimeoutConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inProgressTimeoutInMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inProgressTimeoutInMinutes = self.inProgressTimeoutInMinutes {
            try encodeContainer.encode(inProgressTimeoutInMinutes, forKey: .inProgressTimeoutInMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inProgressTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inProgressTimeoutInMinutes)
        inProgressTimeoutInMinutes = inProgressTimeoutInMinutesDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about the timeout configuration for a job.
    public struct IoTJobTimeoutConfig: Swift.Equatable {
        /// The amount of time, in minutes, that devices have to complete the job. The timer starts when the job status is set to IN_PROGRESS. If the job status doesn't change to a terminal state before the time expires, then the job status is set to TIMED_OUT. The timeout interval must be between 1 minute and 7 days (10080 minutes).
        public var inProgressTimeoutInMinutes: Swift.Int?

        public init(
            inProgressTimeoutInMinutes: Swift.Int? = nil
        )
        {
            self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
        }
    }

}

extension GreengrassV2ClientTypes.LambdaContainerParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices
        case memorySizeInKB
        case mountROSysfs
        case volumes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for lambdadevicemount0 in devices {
                try devicesContainer.encode(lambdadevicemount0)
            }
        }
        if let memorySizeInKB = self.memorySizeInKB {
            try encodeContainer.encode(memorySizeInKB, forKey: .memorySizeInKB)
        }
        if let mountROSysfs = self.mountROSysfs {
            try encodeContainer.encode(mountROSysfs, forKey: .mountROSysfs)
        }
        if let volumes = volumes {
            var volumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumes)
            for lambdavolumemount0 in volumes {
                try volumesContainer.encode(lambdavolumemount0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memorySizeInKBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySizeInKB)
        memorySizeInKB = memorySizeInKBDecoded
        let mountROSysfsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mountROSysfs)
        mountROSysfs = mountROSysfsDecoded
        let volumesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.LambdaVolumeMount?].self, forKey: .volumes)
        var volumesDecoded0:[GreengrassV2ClientTypes.LambdaVolumeMount]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [GreengrassV2ClientTypes.LambdaVolumeMount]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
        let devicesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.LambdaDeviceMount?].self, forKey: .devices)
        var devicesDecoded0:[GreengrassV2ClientTypes.LambdaDeviceMount]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [GreengrassV2ClientTypes.LambdaDeviceMount]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a container in which Lambda functions run on Greengrass core devices.
    public struct LambdaContainerParams: Swift.Equatable {
        /// The list of system devices that the container can access.
        public var devices: [GreengrassV2ClientTypes.LambdaDeviceMount]?
        /// The memory size of the container, expressed in kilobytes. Default: 16384 (16 MB)
        public var memorySizeInKB: Swift.Int?
        /// Whether or not the container can read information from the device's /sys folder. Default: false
        public var mountROSysfs: Swift.Bool?
        /// The list of volumes that the container can access.
        public var volumes: [GreengrassV2ClientTypes.LambdaVolumeMount]?

        public init(
            devices: [GreengrassV2ClientTypes.LambdaDeviceMount]? = nil,
            memorySizeInKB: Swift.Int? = nil,
            mountROSysfs: Swift.Bool? = nil,
            volumes: [GreengrassV2ClientTypes.LambdaVolumeMount]? = nil
        )
        {
            self.devices = devices
            self.memorySizeInKB = memorySizeInKB
            self.mountROSysfs = mountROSysfs
            self.volumes = volumes
        }
    }

}

extension GreengrassV2ClientTypes.LambdaDeviceMount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addGroupOwner
        case path
        case permission
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addGroupOwner = self.addGroupOwner {
            try encodeContainer.encode(addGroupOwner, forKey: .addGroupOwner)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let permission = self.permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaFilesystemPermission.self, forKey: .permission)
        permission = permissionDecoded
        let addGroupOwnerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addGroupOwner)
        addGroupOwner = addGroupOwnerDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a device that Linux processes in a container can access.
    public struct LambdaDeviceMount: Swift.Equatable {
        /// Whether or not to add the component's system user as an owner of the device. Default: false
        public var addGroupOwner: Swift.Bool?
        /// The mount path for the device in the file system.
        /// This member is required.
        public var path: Swift.String?
        /// The permission to access the device: read/only (ro) or read/write (rw). Default: ro
        public var permission: GreengrassV2ClientTypes.LambdaFilesystemPermission?

        public init(
            addGroupOwner: Swift.Bool? = nil,
            path: Swift.String? = nil,
            permission: GreengrassV2ClientTypes.LambdaFilesystemPermission? = nil
        )
        {
            self.addGroupOwner = addGroupOwner
            self.path = path
            self.permission = permission
        }
    }

}

extension GreengrassV2ClientTypes.LambdaEventSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topic
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topic = self.topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topic)
        topic = topicDecoded
        let typeDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaEventSourceType.self, forKey: .type)
        type = typeDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about an event source for an Lambda function. The event source defines the topics on which this Lambda function subscribes to receive messages that run the function.
    public struct LambdaEventSource: Swift.Equatable {
        /// The topic to which to subscribe to receive event messages.
        /// This member is required.
        public var topic: Swift.String?
        /// The type of event source. Choose from the following options:
        ///
        /// * PUB_SUB – Subscribe to local publish/subscribe messages. This event source type doesn't support MQTT wildcards (+ and #) in the event source topic.
        ///
        /// * IOT_CORE – Subscribe to Amazon Web Services IoT Core MQTT messages. This event source type supports MQTT wildcards (+ and #) in the event source topic.
        /// This member is required.
        public var type: GreengrassV2ClientTypes.LambdaEventSourceType?

        public init(
            topic: Swift.String? = nil,
            type: GreengrassV2ClientTypes.LambdaEventSourceType? = nil
        )
        {
            self.topic = topic
            self.type = type
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum LambdaEventSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iotCore
        case pubSub
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaEventSourceType] {
            return [
                .iotCore,
                .pubSub,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iotCore: return "IOT_CORE"
            case .pubSub: return "PUB_SUB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LambdaEventSourceType(rawValue: rawValue) ?? LambdaEventSourceType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.LambdaExecutionParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentVariables
        case eventSources
        case execArgs
        case inputPayloadEncodingType
        case linuxProcessParams
        case maxIdleTimeInSeconds
        case maxInstancesCount
        case maxQueueSize
        case pinned
        case statusTimeoutInSeconds
        case timeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, lambdaEnvironmentVariables0) in environmentVariables {
                try environmentVariablesContainer.encode(lambdaEnvironmentVariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let eventSources = eventSources {
            var eventSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSources)
            for lambdaeventsource0 in eventSources {
                try eventSourcesContainer.encode(lambdaeventsource0)
            }
        }
        if let execArgs = execArgs {
            var execArgsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .execArgs)
            for lambdaexecarg0 in execArgs {
                try execArgsContainer.encode(lambdaexecarg0)
            }
        }
        if let inputPayloadEncodingType = self.inputPayloadEncodingType {
            try encodeContainer.encode(inputPayloadEncodingType.rawValue, forKey: .inputPayloadEncodingType)
        }
        if let linuxProcessParams = self.linuxProcessParams {
            try encodeContainer.encode(linuxProcessParams, forKey: .linuxProcessParams)
        }
        if let maxIdleTimeInSeconds = self.maxIdleTimeInSeconds {
            try encodeContainer.encode(maxIdleTimeInSeconds, forKey: .maxIdleTimeInSeconds)
        }
        if let maxInstancesCount = self.maxInstancesCount {
            try encodeContainer.encode(maxInstancesCount, forKey: .maxInstancesCount)
        }
        if let maxQueueSize = self.maxQueueSize {
            try encodeContainer.encode(maxQueueSize, forKey: .maxQueueSize)
        }
        if let pinned = self.pinned {
            try encodeContainer.encode(pinned, forKey: .pinned)
        }
        if let statusTimeoutInSeconds = self.statusTimeoutInSeconds {
            try encodeContainer.encode(statusTimeoutInSeconds, forKey: .statusTimeoutInSeconds)
        }
        if let timeoutInSeconds = self.timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourcesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.LambdaEventSource?].self, forKey: .eventSources)
        var eventSourcesDecoded0:[GreengrassV2ClientTypes.LambdaEventSource]? = nil
        if let eventSourcesContainer = eventSourcesContainer {
            eventSourcesDecoded0 = [GreengrassV2ClientTypes.LambdaEventSource]()
            for structure0 in eventSourcesContainer {
                if let structure0 = structure0 {
                    eventSourcesDecoded0?.append(structure0)
                }
            }
        }
        eventSources = eventSourcesDecoded0
        let maxQueueSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxQueueSize)
        maxQueueSize = maxQueueSizeDecoded
        let maxInstancesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxInstancesCount)
        maxInstancesCount = maxInstancesCountDecoded
        let maxIdleTimeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxIdleTimeInSeconds)
        maxIdleTimeInSeconds = maxIdleTimeInSecondsDecoded
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let statusTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusTimeoutInSeconds)
        statusTimeoutInSeconds = statusTimeoutInSecondsDecoded
        let pinnedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pinned)
        pinned = pinnedDecoded
        let inputPayloadEncodingTypeDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaInputPayloadEncodingType.self, forKey: .inputPayloadEncodingType)
        inputPayloadEncodingType = inputPayloadEncodingTypeDecoded
        let execArgsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .execArgs)
        var execArgsDecoded0:[Swift.String]? = nil
        if let execArgsContainer = execArgsContainer {
            execArgsDecoded0 = [Swift.String]()
            for string0 in execArgsContainer {
                if let string0 = string0 {
                    execArgsDecoded0?.append(string0)
                }
            }
        }
        execArgs = execArgsDecoded0
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in environmentVariablesContainer {
                if let string0 = string0 {
                    environmentVariablesDecoded0?[key0] = string0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let linuxProcessParamsDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaLinuxProcessParams.self, forKey: .linuxProcessParams)
        linuxProcessParams = linuxProcessParamsDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains parameters for a Lambda function that runs on IoT Greengrass.
    public struct LambdaExecutionParameters: Swift.Equatable {
        /// The map of environment variables that are available to the Lambda function when it runs.
        public var environmentVariables: [Swift.String:Swift.String]?
        /// The list of event sources to which to subscribe to receive work messages. The Lambda function runs when it receives a message from an event source. You can subscribe this function to local publish/subscribe messages and Amazon Web Services IoT Core MQTT messages.
        public var eventSources: [GreengrassV2ClientTypes.LambdaEventSource]?
        /// The list of arguments to pass to the Lambda function when it runs.
        public var execArgs: [Swift.String]?
        /// The encoding type that the Lambda function supports. Default: json
        public var inputPayloadEncodingType: GreengrassV2ClientTypes.LambdaInputPayloadEncodingType?
        /// The parameters for the Linux process that contains the Lambda function.
        public var linuxProcessParams: GreengrassV2ClientTypes.LambdaLinuxProcessParams?
        /// The maximum amount of time in seconds that a non-pinned Lambda function can idle before the IoT Greengrass Core software stops its process.
        public var maxIdleTimeInSeconds: Swift.Int?
        /// The maximum number of instances that a non-pinned Lambda function can run at the same time.
        public var maxInstancesCount: Swift.Int?
        /// The maximum size of the message queue for the Lambda function component. The IoT Greengrass core stores messages in a FIFO (first-in-first-out) queue until it can run the Lambda function to consume each message.
        public var maxQueueSize: Swift.Int?
        /// Whether or not the Lambda function is pinned, or long-lived.
        ///
        /// * A pinned Lambda function starts when IoT Greengrass starts and keeps running in its own container.
        ///
        /// * A non-pinned Lambda function starts only when it receives a work item and exists after it idles for maxIdleTimeInSeconds. If the function has multiple work items, the IoT Greengrass Core software creates multiple instances of the function.
        ///
        ///
        /// Default: true
        public var pinned: Swift.Bool?
        /// The interval in seconds at which a pinned (also known as long-lived) Lambda function component sends status updates to the Lambda manager component.
        public var statusTimeoutInSeconds: Swift.Int?
        /// The maximum amount of time in seconds that the Lambda function can process a work item.
        public var timeoutInSeconds: Swift.Int?

        public init(
            environmentVariables: [Swift.String:Swift.String]? = nil,
            eventSources: [GreengrassV2ClientTypes.LambdaEventSource]? = nil,
            execArgs: [Swift.String]? = nil,
            inputPayloadEncodingType: GreengrassV2ClientTypes.LambdaInputPayloadEncodingType? = nil,
            linuxProcessParams: GreengrassV2ClientTypes.LambdaLinuxProcessParams? = nil,
            maxIdleTimeInSeconds: Swift.Int? = nil,
            maxInstancesCount: Swift.Int? = nil,
            maxQueueSize: Swift.Int? = nil,
            pinned: Swift.Bool? = nil,
            statusTimeoutInSeconds: Swift.Int? = nil,
            timeoutInSeconds: Swift.Int? = nil
        )
        {
            self.environmentVariables = environmentVariables
            self.eventSources = eventSources
            self.execArgs = execArgs
            self.inputPayloadEncodingType = inputPayloadEncodingType
            self.linuxProcessParams = linuxProcessParams
            self.maxIdleTimeInSeconds = maxIdleTimeInSeconds
            self.maxInstancesCount = maxInstancesCount
            self.maxQueueSize = maxQueueSize
            self.pinned = pinned
            self.statusTimeoutInSeconds = statusTimeoutInSeconds
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum LambdaFilesystemPermission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ro
        case rw
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaFilesystemPermission] {
            return [
                .ro,
                .rw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ro: return "ro"
            case .rw: return "rw"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LambdaFilesystemPermission(rawValue: rawValue) ?? LambdaFilesystemPermission.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.LambdaFunctionRecipeSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentDependencies
        case componentLambdaParameters
        case componentName
        case componentPlatforms
        case componentVersion
        case lambdaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentDependencies = componentDependencies {
            var componentDependenciesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .componentDependencies)
            for (dictKey0, componentDependencyMap0) in componentDependencies {
                try componentDependenciesContainer.encode(componentDependencyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let componentLambdaParameters = self.componentLambdaParameters {
            try encodeContainer.encode(componentLambdaParameters, forKey: .componentLambdaParameters)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentPlatforms = componentPlatforms {
            var componentPlatformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .componentPlatforms)
            for componentplatform0 in componentPlatforms {
                try componentPlatformsContainer.encode(componentplatform0)
            }
        }
        if let componentVersion = self.componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let lambdaArn = self.lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let componentPlatformsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ComponentPlatform?].self, forKey: .componentPlatforms)
        var componentPlatformsDecoded0:[GreengrassV2ClientTypes.ComponentPlatform]? = nil
        if let componentPlatformsContainer = componentPlatformsContainer {
            componentPlatformsDecoded0 = [GreengrassV2ClientTypes.ComponentPlatform]()
            for structure0 in componentPlatformsContainer {
                if let structure0 = structure0 {
                    componentPlatformsDecoded0?.append(structure0)
                }
            }
        }
        componentPlatforms = componentPlatformsDecoded0
        let componentDependenciesContainer = try containerValues.decodeIfPresent([Swift.String: GreengrassV2ClientTypes.ComponentDependencyRequirement?].self, forKey: .componentDependencies)
        var componentDependenciesDecoded0: [Swift.String:GreengrassV2ClientTypes.ComponentDependencyRequirement]? = nil
        if let componentDependenciesContainer = componentDependenciesContainer {
            componentDependenciesDecoded0 = [Swift.String:GreengrassV2ClientTypes.ComponentDependencyRequirement]()
            for (key0, componentdependencyrequirement0) in componentDependenciesContainer {
                if let componentdependencyrequirement0 = componentdependencyrequirement0 {
                    componentDependenciesDecoded0?[key0] = componentdependencyrequirement0
                }
            }
        }
        componentDependencies = componentDependenciesDecoded0
        let componentLambdaParametersDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaExecutionParameters.self, forKey: .componentLambdaParameters)
        componentLambdaParameters = componentLambdaParametersDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about an Lambda function to import to create a component.
    public struct LambdaFunctionRecipeSource: Swift.Equatable {
        /// The component versions on which this Lambda function component depends.
        public var componentDependencies: [Swift.String:GreengrassV2ClientTypes.ComponentDependencyRequirement]?
        /// The system and runtime parameters for the Lambda function as it runs on the Greengrass core device.
        public var componentLambdaParameters: GreengrassV2ClientTypes.LambdaExecutionParameters?
        /// The name of the component. Defaults to the name of the Lambda function.
        public var componentName: Swift.String?
        /// The platforms that the component version supports.
        public var componentPlatforms: [GreengrassV2ClientTypes.ComponentPlatform]?
        /// The version of the component. Defaults to the version of the Lambda function as a semantic version. For example, if your function version is 3, the component version becomes 3.0.0.
        public var componentVersion: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Lambda function. The ARN must include the version of the function to import. You can't use version aliases like $LATEST.
        /// This member is required.
        public var lambdaArn: Swift.String?

        public init(
            componentDependencies: [Swift.String:GreengrassV2ClientTypes.ComponentDependencyRequirement]? = nil,
            componentLambdaParameters: GreengrassV2ClientTypes.LambdaExecutionParameters? = nil,
            componentName: Swift.String? = nil,
            componentPlatforms: [GreengrassV2ClientTypes.ComponentPlatform]? = nil,
            componentVersion: Swift.String? = nil,
            lambdaArn: Swift.String? = nil
        )
        {
            self.componentDependencies = componentDependencies
            self.componentLambdaParameters = componentLambdaParameters
            self.componentName = componentName
            self.componentPlatforms = componentPlatforms
            self.componentVersion = componentVersion
            self.lambdaArn = lambdaArn
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum LambdaInputPayloadEncodingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binary
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaInputPayloadEncodingType] {
            return [
                .binary,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binary: return "binary"
            case .json: return "json"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LambdaInputPayloadEncodingType(rawValue: rawValue) ?? LambdaInputPayloadEncodingType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes {
    public enum LambdaIsolationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case greengrassContainer
        case noContainer
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaIsolationMode] {
            return [
                .greengrassContainer,
                .noContainer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .greengrassContainer: return "GreengrassContainer"
            case .noContainer: return "NoContainer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LambdaIsolationMode(rawValue: rawValue) ?? LambdaIsolationMode.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.LambdaLinuxProcessParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerParams
        case isolationMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerParams = self.containerParams {
            try encodeContainer.encode(containerParams, forKey: .containerParams)
        }
        if let isolationMode = self.isolationMode {
            try encodeContainer.encode(isolationMode.rawValue, forKey: .isolationMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isolationModeDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaIsolationMode.self, forKey: .isolationMode)
        isolationMode = isolationModeDecoded
        let containerParamsDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaContainerParams.self, forKey: .containerParams)
        containerParams = containerParamsDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains parameters for a Linux process that contains an Lambda function.
    public struct LambdaLinuxProcessParams: Swift.Equatable {
        /// The parameters for the container in which the Lambda function runs.
        public var containerParams: GreengrassV2ClientTypes.LambdaContainerParams?
        /// The isolation mode for the process that contains the Lambda function. The process can run in an isolated runtime environment inside the IoT Greengrass container, or as a regular process outside any container. Default: GreengrassContainer
        public var isolationMode: GreengrassV2ClientTypes.LambdaIsolationMode?

        public init(
            containerParams: GreengrassV2ClientTypes.LambdaContainerParams? = nil,
            isolationMode: GreengrassV2ClientTypes.LambdaIsolationMode? = nil
        )
        {
            self.containerParams = containerParams
            self.isolationMode = isolationMode
        }
    }

}

extension GreengrassV2ClientTypes.LambdaVolumeMount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addGroupOwner
        case destinationPath
        case permission
        case sourcePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addGroupOwner = self.addGroupOwner {
            try encodeContainer.encode(addGroupOwner, forKey: .addGroupOwner)
        }
        if let destinationPath = self.destinationPath {
            try encodeContainer.encode(destinationPath, forKey: .destinationPath)
        }
        if let permission = self.permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
        if let sourcePath = self.sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
        let destinationPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPath)
        destinationPath = destinationPathDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaFilesystemPermission.self, forKey: .permission)
        permission = permissionDecoded
        let addGroupOwnerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addGroupOwner)
        addGroupOwner = addGroupOwnerDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a volume that Linux processes in a container can access. When you define a volume, the IoT Greengrass Core software mounts the source files to the destination inside the container.
    public struct LambdaVolumeMount: Swift.Equatable {
        /// Whether or not to add the IoT Greengrass user group as an owner of the volume. Default: false
        public var addGroupOwner: Swift.Bool?
        /// The path to the logical volume in the file system.
        /// This member is required.
        public var destinationPath: Swift.String?
        /// The permission to access the volume: read/only (ro) or read/write (rw). Default: ro
        public var permission: GreengrassV2ClientTypes.LambdaFilesystemPermission?
        /// The path to the physical volume in the file system.
        /// This member is required.
        public var sourcePath: Swift.String?

        public init(
            addGroupOwner: Swift.Bool? = nil,
            destinationPath: Swift.String? = nil,
            permission: GreengrassV2ClientTypes.LambdaFilesystemPermission? = nil,
            sourcePath: Swift.String? = nil
        )
        {
            self.addGroupOwner = addGroupOwner
            self.destinationPath = destinationPath
            self.permission = permission
            self.sourcePath = sourcePath
        }
    }

}

extension ListClientDevicesAssociatedWithCoreDeviceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListClientDevicesAssociatedWithCoreDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDeviceThingName = coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/associatedClientDevices"
    }
}

public struct ListClientDevicesAssociatedWithCoreDeviceInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        coreDeviceThingName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClientDevicesAssociatedWithCoreDeviceInputBody: Swift.Equatable {
}

extension ListClientDevicesAssociatedWithCoreDeviceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListClientDevicesAssociatedWithCoreDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListClientDevicesAssociatedWithCoreDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.associatedClientDevices = output.associatedClientDevices
            self.nextToken = output.nextToken
        } else {
            self.associatedClientDevices = nil
            self.nextToken = nil
        }
    }
}

public struct ListClientDevicesAssociatedWithCoreDeviceOutput: Swift.Equatable {
    /// A list that describes the client devices that are associated with the core device.
    public var associatedClientDevices: [GreengrassV2ClientTypes.AssociatedClientDevice]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        associatedClientDevices: [GreengrassV2ClientTypes.AssociatedClientDevice]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associatedClientDevices = associatedClientDevices
        self.nextToken = nextToken
    }
}

struct ListClientDevicesAssociatedWithCoreDeviceOutputBody: Swift.Equatable {
    let associatedClientDevices: [GreengrassV2ClientTypes.AssociatedClientDevice]?
    let nextToken: Swift.String?
}

extension ListClientDevicesAssociatedWithCoreDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedClientDevices
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedClientDevicesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.AssociatedClientDevice?].self, forKey: .associatedClientDevices)
        var associatedClientDevicesDecoded0:[GreengrassV2ClientTypes.AssociatedClientDevice]? = nil
        if let associatedClientDevicesContainer = associatedClientDevicesContainer {
            associatedClientDevicesDecoded0 = [GreengrassV2ClientTypes.AssociatedClientDevice]()
            for structure0 in associatedClientDevicesContainer {
                if let structure0 = structure0 {
                    associatedClientDevicesDecoded0?.append(structure0)
                }
            }
        }
        associatedClientDevices = associatedClientDevicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListClientDevicesAssociatedWithCoreDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListComponentVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListComponentVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/greengrass/v2/components/\(arn.urlPercentEncoding())/versions"
    }
}

public struct ListComponentVersionsInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component.
    /// This member is required.
    public var arn: Swift.String?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComponentVersionsInputBody: Swift.Equatable {
}

extension ListComponentVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListComponentVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListComponentVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.componentVersions = output.componentVersions
            self.nextToken = output.nextToken
        } else {
            self.componentVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentVersionsOutput: Swift.Equatable {
    /// A list of versions that exist for the component.
    public var componentVersions: [GreengrassV2ClientTypes.ComponentVersionListItem]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        componentVersions: [GreengrassV2ClientTypes.ComponentVersionListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentVersions = componentVersions
        self.nextToken = nextToken
    }
}

struct ListComponentVersionsOutputBody: Swift.Equatable {
    let componentVersions: [GreengrassV2ClientTypes.ComponentVersionListItem]?
    let nextToken: Swift.String?
}

extension ListComponentVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentVersions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentVersionsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ComponentVersionListItem?].self, forKey: .componentVersions)
        var componentVersionsDecoded0:[GreengrassV2ClientTypes.ComponentVersionListItem]? = nil
        if let componentVersionsContainer = componentVersionsContainer {
            componentVersionsDecoded0 = [GreengrassV2ClientTypes.ComponentVersionListItem]()
            for structure0 in componentVersionsContainer {
                if let structure0 = structure0 {
                    componentVersionsDecoded0?.append(structure0)
                }
            }
        }
        componentVersions = componentVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListComponentVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListComponentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let scope = scope {
                let scopeQueryItem = ClientRuntime.URLQueryItem(name: "scope".urlPercentEncoding(), value: Swift.String(scope.rawValue).urlPercentEncoding())
                items.append(scopeQueryItem)
            }
            return items
        }
    }
}

extension ListComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/v2/components"
    }
}

public struct ListComponentsInput: Swift.Equatable {
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The scope of the components to list. Default: PRIVATE
    public var scope: GreengrassV2ClientTypes.ComponentVisibilityScope?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        scope: GreengrassV2ClientTypes.ComponentVisibilityScope? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scope = scope
    }
}

struct ListComponentsInputBody: Swift.Equatable {
}

extension ListComponentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListComponentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListComponentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.components = output.components
            self.nextToken = output.nextToken
        } else {
            self.components = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentsOutput: Swift.Equatable {
    /// A list that summarizes each component.
    public var components: [GreengrassV2ClientTypes.Component]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        components: [GreengrassV2ClientTypes.Component]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.components = components
        self.nextToken = nextToken
    }
}

struct ListComponentsOutputBody: Swift.Equatable {
    let components: [GreengrassV2ClientTypes.Component]?
    let nextToken: Swift.String?
}

extension ListComponentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.Component?].self, forKey: .components)
        var componentsDecoded0:[GreengrassV2ClientTypes.Component]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [GreengrassV2ClientTypes.Component]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListComponentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCoreDevicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let thingGroupArn = thingGroupArn {
                let thingGroupArnQueryItem = ClientRuntime.URLQueryItem(name: "thingGroupArn".urlPercentEncoding(), value: Swift.String(thingGroupArn).urlPercentEncoding())
                items.append(thingGroupArnQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListCoreDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/v2/coreDevices"
    }
}

public struct ListCoreDevicesInput: Swift.Equatable {
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The core device status by which to filter. If you specify this parameter, the list includes only core devices that have this status. Choose one of the following options:
    ///
    /// * HEALTHY – The IoT Greengrass Core software and all components run on the core device without issue.
    ///
    /// * UNHEALTHY – The IoT Greengrass Core software or a component is in a failed state on the core device.
    public var status: GreengrassV2ClientTypes.CoreDeviceStatus?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IoT thing group by which to filter. If you specify this parameter, the list includes only core devices that have successfully deployed a deployment that targets the thing group. When you remove a core device from a thing group, the list continues to include that core device.
    public var thingGroupArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: GreengrassV2ClientTypes.CoreDeviceStatus? = nil,
        thingGroupArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.thingGroupArn = thingGroupArn
    }
}

struct ListCoreDevicesInputBody: Swift.Equatable {
}

extension ListCoreDevicesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCoreDevicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCoreDevicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.coreDevices = output.coreDevices
            self.nextToken = output.nextToken
        } else {
            self.coreDevices = nil
            self.nextToken = nil
        }
    }
}

public struct ListCoreDevicesOutput: Swift.Equatable {
    /// A list that summarizes each core device.
    public var coreDevices: [GreengrassV2ClientTypes.CoreDevice]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        coreDevices: [GreengrassV2ClientTypes.CoreDevice]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDevices = coreDevices
        self.nextToken = nextToken
    }
}

struct ListCoreDevicesOutputBody: Swift.Equatable {
    let coreDevices: [GreengrassV2ClientTypes.CoreDevice]?
    let nextToken: Swift.String?
}

extension ListCoreDevicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreDevices
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreDevicesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.CoreDevice?].self, forKey: .coreDevices)
        var coreDevicesDecoded0:[GreengrassV2ClientTypes.CoreDevice]? = nil
        if let coreDevicesContainer = coreDevicesContainer {
            coreDevicesDecoded0 = [GreengrassV2ClientTypes.CoreDevice]()
            for structure0 in coreDevicesContainer {
                if let structure0 = structure0 {
                    coreDevicesDecoded0?.append(structure0)
                }
            }
        }
        coreDevices = coreDevicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCoreDevicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let historyFilter = historyFilter {
                let historyFilterQueryItem = ClientRuntime.URLQueryItem(name: "historyFilter".urlPercentEncoding(), value: Swift.String(historyFilter.rawValue).urlPercentEncoding())
                items.append(historyFilterQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let parentTargetArn = parentTargetArn {
                let parentTargetArnQueryItem = ClientRuntime.URLQueryItem(name: "parentTargetArn".urlPercentEncoding(), value: Swift.String(parentTargetArn).urlPercentEncoding())
                items.append(parentTargetArnQueryItem)
            }
            if let targetArn = targetArn {
                let targetArnQueryItem = ClientRuntime.URLQueryItem(name: "targetArn".urlPercentEncoding(), value: Swift.String(targetArn).urlPercentEncoding())
                items.append(targetArnQueryItem)
            }
            return items
        }
    }
}

extension ListDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/v2/deployments"
    }
}

public struct ListDeploymentsInput: Swift.Equatable {
    /// The filter for the list of deployments. Choose one of the following options:
    ///
    /// * ALL – The list includes all deployments.
    ///
    /// * LATEST_ONLY – The list includes only the latest revision of each deployment.
    ///
    ///
    /// Default: LATEST_ONLY
    public var historyFilter: GreengrassV2ClientTypes.DeploymentHistoryFilter?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The parent deployment's target [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) within a subdeployment.
    public var parentTargetArn: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the target IoT thing or thing group.
    public var targetArn: Swift.String?

    public init(
        historyFilter: GreengrassV2ClientTypes.DeploymentHistoryFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parentTargetArn: Swift.String? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.historyFilter = historyFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parentTargetArn = parentTargetArn
        self.targetArn = targetArn
    }
}

struct ListDeploymentsInputBody: Swift.Equatable {
}

extension ListDeploymentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deployments = output.deployments
            self.nextToken = output.nextToken
        } else {
            self.deployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentsOutput: Swift.Equatable {
    /// A list that summarizes each deployment.
    public var deployments: [GreengrassV2ClientTypes.Deployment]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deployments: [GreengrassV2ClientTypes.Deployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

struct ListDeploymentsOutputBody: Swift.Equatable {
    let deployments: [GreengrassV2ClientTypes.Deployment]?
    let nextToken: Swift.String?
}

extension ListDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.Deployment?].self, forKey: .deployments)
        var deploymentsDecoded0:[GreengrassV2ClientTypes.Deployment]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [GreengrassV2ClientTypes.Deployment]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEffectiveDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListEffectiveDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDeviceThingName = coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/effectiveDeployments"
    }
}

public struct ListEffectiveDeploymentsInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        coreDeviceThingName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEffectiveDeploymentsInputBody: Swift.Equatable {
}

extension ListEffectiveDeploymentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEffectiveDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEffectiveDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.effectiveDeployments = output.effectiveDeployments
            self.nextToken = output.nextToken
        } else {
            self.effectiveDeployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListEffectiveDeploymentsOutput: Swift.Equatable {
    /// A list that summarizes each deployment on the core device.
    public var effectiveDeployments: [GreengrassV2ClientTypes.EffectiveDeployment]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        effectiveDeployments: [GreengrassV2ClientTypes.EffectiveDeployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.effectiveDeployments = effectiveDeployments
        self.nextToken = nextToken
    }
}

struct ListEffectiveDeploymentsOutputBody: Swift.Equatable {
    let effectiveDeployments: [GreengrassV2ClientTypes.EffectiveDeployment]?
    let nextToken: Swift.String?
}

extension ListEffectiveDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveDeployments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectiveDeploymentsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.EffectiveDeployment?].self, forKey: .effectiveDeployments)
        var effectiveDeploymentsDecoded0:[GreengrassV2ClientTypes.EffectiveDeployment]? = nil
        if let effectiveDeploymentsContainer = effectiveDeploymentsContainer {
            effectiveDeploymentsDecoded0 = [GreengrassV2ClientTypes.EffectiveDeployment]()
            for structure0 in effectiveDeploymentsContainer {
                if let structure0 = structure0 {
                    effectiveDeploymentsDecoded0?.append(structure0)
                }
            }
        }
        effectiveDeployments = effectiveDeploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEffectiveDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListInstalledComponentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let topologyFilter = topologyFilter {
                let topologyFilterQueryItem = ClientRuntime.URLQueryItem(name: "topologyFilter".urlPercentEncoding(), value: Swift.String(topologyFilter.rawValue).urlPercentEncoding())
                items.append(topologyFilterQueryItem)
            }
            return items
        }
    }
}

extension ListInstalledComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDeviceThingName = coreDeviceThingName else {
            return nil
        }
        return "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/installedComponents"
    }
}

public struct ListInstalledComponentsInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The filter for the list of components. Choose from the following options:
    ///
    /// * ALL – The list includes all components installed on the core device.
    ///
    /// * ROOT – The list includes only root components, which are components that you specify in a deployment. When you choose this option, the list doesn't include components that the core device installs as dependencies of other components.
    ///
    ///
    /// Default: ROOT
    public var topologyFilter: GreengrassV2ClientTypes.InstalledComponentTopologyFilter?

    public init(
        coreDeviceThingName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        topologyFilter: GreengrassV2ClientTypes.InstalledComponentTopologyFilter? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.topologyFilter = topologyFilter
    }
}

struct ListInstalledComponentsInputBody: Swift.Equatable {
}

extension ListInstalledComponentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListInstalledComponentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInstalledComponentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.installedComponents = output.installedComponents
            self.nextToken = output.nextToken
        } else {
            self.installedComponents = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstalledComponentsOutput: Swift.Equatable {
    /// A list that summarizes each component on the core device. Greengrass nucleus v2.7.0 or later is required to get an accurate lastStatusChangeTimestamp response. This response can be inaccurate in earlier Greengrass nucleus versions. Greengrass nucleus v2.8.0 or later is required to get an accurate lastInstallationSource and lastReportedTimestamp response. This response can be inaccurate or null in earlier Greengrass nucleus versions.
    public var installedComponents: [GreengrassV2ClientTypes.InstalledComponent]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        installedComponents: [GreengrassV2ClientTypes.InstalledComponent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.installedComponents = installedComponents
        self.nextToken = nextToken
    }
}

struct ListInstalledComponentsOutputBody: Swift.Equatable {
    let installedComponents: [GreengrassV2ClientTypes.InstalledComponent]?
    let nextToken: Swift.String?
}

extension ListInstalledComponentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case installedComponents
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let installedComponentsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.InstalledComponent?].self, forKey: .installedComponents)
        var installedComponentsDecoded0:[GreengrassV2ClientTypes.InstalledComponent]? = nil
        if let installedComponentsContainer = installedComponentsContainer {
            installedComponentsDecoded0 = [GreengrassV2ClientTypes.InstalledComponent]()
            for structure0 in installedComponentsContainer {
                if let structure0 = structure0 {
                    installedComponentsDecoded0?.append(structure0)
                }
            }
        }
        installedComponents = installedComponentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListInstalledComponentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassV2ClientTypes {
    public enum RecipeOutputFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case yaml
        case sdkUnknown(Swift.String)

        public static var allCases: [RecipeOutputFormat] {
            return [
                .json,
                .yaml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .yaml: return "YAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecipeOutputFormat(rawValue: rawValue) ?? RecipeOutputFormat.sdkUnknown(rawValue)
        }
    }
}

extension RequestAlreadyInProgressException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestAlreadyInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is already in progress. This exception occurs when you use a client token for multiple requests while IoT Greengrass is still processing an earlier request that uses the same client token.
public struct RequestAlreadyInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestAlreadyInProgressException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RequestAlreadyInProgressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestAlreadyInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResolveComponentCandidatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentCandidates
        case platform
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentCandidates = componentCandidates {
            var componentCandidatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .componentCandidates)
            for componentcandidate0 in componentCandidates {
                try componentCandidatesContainer.encode(componentcandidate0)
            }
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
    }
}

extension ResolveComponentCandidatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/v2/resolveComponentCandidates"
    }
}

public struct ResolveComponentCandidatesInput: Swift.Equatable {
    /// The list of components to resolve.
    public var componentCandidates: [GreengrassV2ClientTypes.ComponentCandidate]?
    /// The platform to use to resolve compatible components.
    public var platform: GreengrassV2ClientTypes.ComponentPlatform?

    public init(
        componentCandidates: [GreengrassV2ClientTypes.ComponentCandidate]? = nil,
        platform: GreengrassV2ClientTypes.ComponentPlatform? = nil
    )
    {
        self.componentCandidates = componentCandidates
        self.platform = platform
    }
}

struct ResolveComponentCandidatesInputBody: Swift.Equatable {
    let platform: GreengrassV2ClientTypes.ComponentPlatform?
    let componentCandidates: [GreengrassV2ClientTypes.ComponentCandidate]?
}

extension ResolveComponentCandidatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentCandidates
        case platform
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.ComponentPlatform.self, forKey: .platform)
        platform = platformDecoded
        let componentCandidatesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ComponentCandidate?].self, forKey: .componentCandidates)
        var componentCandidatesDecoded0:[GreengrassV2ClientTypes.ComponentCandidate]? = nil
        if let componentCandidatesContainer = componentCandidatesContainer {
            componentCandidatesDecoded0 = [GreengrassV2ClientTypes.ComponentCandidate]()
            for structure0 in componentCandidatesContainer {
                if let structure0 = structure0 {
                    componentCandidatesDecoded0?.append(structure0)
                }
            }
        }
        componentCandidates = componentCandidatesDecoded0
    }
}

extension ResolveComponentCandidatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResolveComponentCandidatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.resolvedComponentVersions = output.resolvedComponentVersions
        } else {
            self.resolvedComponentVersions = nil
        }
    }
}

public struct ResolveComponentCandidatesOutput: Swift.Equatable {
    /// A list of components that meet the requirements that you specify in the request. This list includes each component's recipe that you can use to install the component.
    public var resolvedComponentVersions: [GreengrassV2ClientTypes.ResolvedComponentVersion]?

    public init(
        resolvedComponentVersions: [GreengrassV2ClientTypes.ResolvedComponentVersion]? = nil
    )
    {
        self.resolvedComponentVersions = resolvedComponentVersions
    }
}

struct ResolveComponentCandidatesOutputBody: Swift.Equatable {
    let resolvedComponentVersions: [GreengrassV2ClientTypes.ResolvedComponentVersion]?
}

extension ResolveComponentCandidatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolvedComponentVersions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolvedComponentVersionsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ResolvedComponentVersion?].self, forKey: .resolvedComponentVersions)
        var resolvedComponentVersionsDecoded0:[GreengrassV2ClientTypes.ResolvedComponentVersion]? = nil
        if let resolvedComponentVersionsContainer = resolvedComponentVersionsContainer {
            resolvedComponentVersionsDecoded0 = [GreengrassV2ClientTypes.ResolvedComponentVersion]()
            for structure0 in resolvedComponentVersionsContainer {
                if let structure0 = structure0 {
                    resolvedComponentVersionsDecoded0?.append(structure0)
                }
            }
        }
        resolvedComponentVersions = resolvedComponentVersionsDecoded0
    }
}

enum ResolveComponentCandidatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassV2ClientTypes.ResolvedComponentVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentName
        case componentVersion
        case message
        case recipe
        case vendorGuidance
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = self.componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let recipe = self.recipe {
            try encodeContainer.encode(recipe.base64EncodedString(), forKey: .recipe)
        }
        if let vendorGuidance = self.vendorGuidance {
            try encodeContainer.encode(vendorGuidance.rawValue, forKey: .vendorGuidance)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let recipeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .recipe)
        recipe = recipeDecoded
        let vendorGuidanceDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.VendorGuidance.self, forKey: .vendorGuidance)
        vendorGuidance = vendorGuidanceDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component version that is compatible to run on a Greengrass core device.
    public struct ResolvedComponentVersion: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the component version.
        public var arn: Swift.String?
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// A message that communicates details about the vendor guidance state of the component version. This message communicates why a component version is discontinued or deleted.
        public var message: Swift.String?
        /// The recipe of the component version.
        public var recipe: ClientRuntime.Data?
        /// The vendor guidance state for the component version. This state indicates whether the component version has any issues that you should consider before you deploy it. The vendor guidance state can be:
        ///
        /// * ACTIVE – This component version is available and recommended for use.
        ///
        /// * DISCONTINUED – This component version has been discontinued by its publisher. You can deploy this component version, but we recommend that you use a different version of this component.
        ///
        /// * DELETED – This component version has been deleted by its publisher, so you can't deploy it. If you have any existing deployments that specify this component version, those deployments will fail.
        public var vendorGuidance: GreengrassV2ClientTypes.VendorGuidance?

        public init(
            arn: Swift.String? = nil,
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            message: Swift.String? = nil,
            recipe: ClientRuntime.Data? = nil,
            vendorGuidance: GreengrassV2ClientTypes.VendorGuidance? = nil
        )
        {
            self.arn = arn
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.message = message
            self.recipe = recipe
            self.vendorGuidance = vendorGuidance
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that isn't found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that isn't found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request exceeds a service quota. For example, you might have the maximum number of components that you can create.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource that exceeds the service quota.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that exceeds the service quota.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code for the service in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension GreengrassV2ClientTypes.SystemResourceLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpus
        case memory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cpus != 0.0 {
            try encodeContainer.encode(cpus, forKey: .cpus)
        }
        if memory != 0 {
            try encodeContainer.encode(memory, forKey: .memory)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memory) ?? 0
        memory = memoryDecoded
        let cpusDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .cpus) ?? 0.0
        cpus = cpusDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about system resource limits that the IoT Greengrass Core software applies to a component's processes. For more information, see [Configure system resource limits for components](https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-system-resource-limits).
    public struct SystemResourceLimits: Swift.Equatable {
        /// The maximum amount of CPU time that a component's processes can use on the core device. A core device's total CPU time is equivalent to the device's number of CPU cores. For example, on a core device with 4 CPU cores, you can set this value to 2 to limit the component's processes to 50 percent usage of each CPU core. On a device with 1 CPU core, you can set this value to 0.25 to limit the component's processes to 25 percent usage of the CPU. If you set this value to a number greater than the number of CPU cores, the IoT Greengrass Core software doesn't limit the component's CPU usage.
        public var cpus: Swift.Double
        /// The maximum amount of RAM, expressed in kilobytes, that a component's processes can use on the core device.
        public var memory: Swift.Int

        public init(
            cpus: Swift.Double = 0.0,
            memory: Swift.Int = 0
        )
        {
            self.cpus = cpus
            self.memory = memory
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tag your resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the IoT Greengrass V2 Developer Guide.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request exceeded a request rate quota. For example, you might have exceeded the amount of times that you can retrieve device or deployment status per second.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var quotaCode: Swift.String? = nil
        /// The amount of time to wait before you retry the request.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// The code for the service in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys for tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConnectivityInfoInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectivityInfo = "ConnectivityInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectivityInfo = connectivityInfo {
            var connectivityInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectivityInfo)
            for connectivityinfo0 in connectivityInfo {
                try connectivityInfoContainer.encode(connectivityinfo0)
            }
        }
    }
}

extension UpdateConnectivityInfoInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/connectivityInfo"
    }
}

public struct UpdateConnectivityInfoInput: Swift.Equatable {
    /// The connectivity information for the core device.
    /// This member is required.
    public var connectivityInfo: [GreengrassV2ClientTypes.ConnectivityInfo]?
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        connectivityInfo: [GreengrassV2ClientTypes.ConnectivityInfo]? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.thingName = thingName
    }
}

struct UpdateConnectivityInfoInputBody: Swift.Equatable {
    let connectivityInfo: [GreengrassV2ClientTypes.ConnectivityInfo]?
}

extension UpdateConnectivityInfoInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectivityInfo = "ConnectivityInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectivityInfoContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ConnectivityInfo?].self, forKey: .connectivityInfo)
        var connectivityInfoDecoded0:[GreengrassV2ClientTypes.ConnectivityInfo]? = nil
        if let connectivityInfoContainer = connectivityInfoContainer {
            connectivityInfoDecoded0 = [GreengrassV2ClientTypes.ConnectivityInfo]()
            for structure0 in connectivityInfoContainer {
                if let structure0 = structure0 {
                    connectivityInfoDecoded0?.append(structure0)
                }
            }
        }
        connectivityInfo = connectivityInfoDecoded0
    }
}

extension UpdateConnectivityInfoOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConnectivityInfoOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.version = output.version
        } else {
            self.message = nil
            self.version = nil
        }
    }
}

public struct UpdateConnectivityInfoOutput: Swift.Equatable {
    /// A message about the connectivity information update request.
    public var message: Swift.String?
    /// The new version of the connectivity information for the core device.
    public var version: Swift.String?

    public init(
        message: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.message = message
        self.version = version
    }
}

struct UpdateConnectivityInfoOutputBody: Swift.Equatable {
    let version: Swift.String?
    let message: Swift.String?
}

extension UpdateConnectivityInfoOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum UpdateConnectivityInfoOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request isn't valid. This can occur if your request contains malformed JSON or unsupported characters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that failed to validate.
        public internal(set) var fields: [GreengrassV2ClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation exception.
        public internal(set) var reason: GreengrassV2ClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [GreengrassV2ClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: GreengrassV2ClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: GreengrassV2ClientTypes.ValidationExceptionReason?
    let fields: [GreengrassV2ClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[GreengrassV2ClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [GreengrassV2ClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension GreengrassV2ClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassV2ClientTypes {
    /// Contains information about a validation exception field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message of the exception field.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the exception field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes {
    public enum VendorGuidance: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case discontinued
        case sdkUnknown(Swift.String)

        public static var allCases: [VendorGuidance] {
            return [
                .active,
                .deleted,
                .discontinued,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .discontinued: return "DISCONTINUED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VendorGuidance(rawValue: rawValue) ?? VendorGuidance.sdkUnknown(rawValue)
        }
    }
}
